
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2_double *data;
} _a2__a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a1_int64_t *data;
} _a2__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1_bool *data;
} _a3__a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  _a1__a2_bool *data;
} _a1__a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a2_bool *data;
} _a3__a1__a2_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  _a3__a3_bool *data;
} _a1__a3__a3_bool;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_bool *data;
} _a2__a2__a3_bool;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2__a1_int64_t *data;
} _a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_bool *data;
} _a2__a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a2_double *data;
} _a2__a1__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1_int64_t *data;
} _a2__a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_int64_t *data;
} _a3__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

int64_t b(_a2_double c) {
    int64_t _0 = 804;
    int64_t _1 = c.d1 * _0;
    _a3_int64_t _2;
    if (!a)
    goto _jump198;
    _a3_int64_t _3;
    if (!a)
    goto _jump199;
    _a3_int64_t _4;
    // Computing bound for f
    _4.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing bound for g
    _4.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing bound for h
    _4.d2 = c.d1;
    if (c.d1 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= c.d1;
    _5 *= c.d1;
    _5 *= c.d1;
    _5 *= sizeof(int64_t);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // h
    int64_t _7 = 0; // g
    int64_t _8 = 0; // f
    _jump203:; // Begin body of loop
    int64_t _9 = 0;
    _9 *= _4.d0;
    _9 += _8;
    _9 *= _4.d1;
    _9 += _7;
    _9 *= _4.d2;
    _9 += _6;
    _4.data[_9] = c.d1;
    _6++;
    if (_6 < c.d1)
    goto _jump203;
    _6 = 0;
    _7++;
    if (_7 < c.d1)
    goto _jump203;
    _7 = 0;
    _8++;
    if (_8 < c.d1)
    goto _jump203;
    // End body of loop
    _3 = _4;
    goto _jump204;
    _jump199:;
    _a3_int64_t _10;
    // Computing bound for f
    _10.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing bound for g
    _10.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    // Computing bound for h
    _10.d2 = c.d0;
    if (c.d0 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= c.d0;
    _11 *= c.d0;
    _11 *= c.d0;
    _11 *= sizeof(int64_t);
    _10.data = jpl_alloc(_11);
    int64_t _12 = 0; // h
    int64_t _13 = 0; // g
    int64_t _14 = 0; // f
    _jump208:; // Begin body of loop
    int64_t _15 = 990;
    int64_t _16 = 0;
    _16 *= _10.d0;
    _16 += _14;
    _16 *= _10.d1;
    _16 += _13;
    _16 *= _10.d2;
    _16 += _12;
    _10.data[_16] = _15;
    _12++;
    if (_12 < c.d0)
    goto _jump208;
    _12 = 0;
    _13++;
    if (_13 < c.d0)
    goto _jump208;
    _13 = 0;
    _14++;
    if (_14 < c.d0)
    goto _jump208;
    // End body of loop
    _3 = _10;
    _jump204:;
    _2 = _3;
    goto _jump209;
    _jump198:;
    _a3_int64_t _17;
    // Computing bound for f
    int64_t _18 = -c.d1;
    _17.d0 = _18;
    if (_18 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for g
    _17.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for h
    int64_t _19 = c.d1 / c.d0;
    _17.d2 = _19;
    if (_19 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _18;
    _20 *= c.d1;
    _20 *= _19;
    _20 *= sizeof(int64_t);
    _17.data = jpl_alloc(_20);
    int64_t _21 = 0; // h
    int64_t _22 = 0; // g
    int64_t _23 = 0; // f
    _jump213:; // Begin body of loop
    int64_t _24 = 0;
    _24 *= _17.d0;
    _24 += _23;
    _24 *= _17.d1;
    _24 += _22;
    _24 *= _17.d2;
    _24 += _21;
    _17.data[_24] = _22;
    _21++;
    if (_21 < _19)
    goto _jump213;
    _21 = 0;
    _22++;
    if (_22 < c.d1)
    goto _jump213;
    _22 = 0;
    _23++;
    if (_23 < _18)
    goto _jump213;
    // End body of loop
    _2 = _17;
    _jump209:;
    _a2__a2_double _25;
    // Computing bound for f
    _25.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump214;
    fail_assertion("non-positive loop bound");
    _jump214:;
    // Computing bound for g
    int64_t _26 = 207;
    _25.d1 = _26;
    if (_26 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= c.d1;
    _27 *= _26;
    _27 *= sizeof(_a2_double);
    _25.data = jpl_alloc(_27);
    int64_t _28 = 0; // g
    int64_t _29 = 0; // f
    _jump216:; // Begin body of loop
    int64_t _30 = 0;
    _30 *= _25.d0;
    _30 += _29;
    _30 *= _25.d1;
    _30 += _28;
    _25.data[_30] = c;
    _28++;
    if (_28 < _26)
    goto _jump216;
    _28 = 0;
    _29++;
    if (_29 < c.d1)
    goto _jump216;
    // End body of loop
    int64_t _31 = 277;
    int64_t _32 = -_31;
    if (c.d1 >= 0)
    goto _jump217;
    fail_assertion("negative array index");
    _jump217:;
    if (c.d1 < _25.d0)
    goto _jump218;
    fail_assertion("index too large");
    _jump218:;
    if (_32 >= 0)
    goto _jump219;
    fail_assertion("negative array index");
    _jump219:;
    if (_32 < _25.d1)
    goto _jump220;
    fail_assertion("index too large");
    _jump220:;
    int64_t _33 = 0;
    _33 *= _25.d0;
    _33 += c.d1;
    _33 *= _25.d1;
    _33 += _32;
    _a2_double _34 = _25.data[_33];
    int64_t _35 = b(_34);
    bool _36 = !a;
    bool _37 = !_36;
    int64_t _38;
    if (!_37)
    goto _jump221;
    int64_t _39 = c.d0 - c.d1;
    _38 = _39;
    goto _jump222;
    _jump221:;
    _38 = c.d0;
    _jump222:;
    if (_35 >= 0)
    goto _jump223;
    fail_assertion("negative array index");
    _jump223:;
    if (_35 < _2.d0)
    goto _jump224;
    fail_assertion("index too large");
    _jump224:;
    if (_38 >= 0)
    goto _jump225;
    fail_assertion("negative array index");
    _jump225:;
    if (_38 < _2.d1)
    goto _jump226;
    fail_assertion("index too large");
    _jump226:;
    if (c.d0 >= 0)
    goto _jump227;
    fail_assertion("negative array index");
    _jump227:;
    if (c.d0 < _2.d2)
    goto _jump228;
    fail_assertion("index too large");
    _jump228:;
    int64_t _40 = 0;
    _40 *= _2.d0;
    _40 += _35;
    _40 *= _2.d1;
    _40 += _38;
    _40 *= _2.d2;
    _40 += c.d0;
    int64_t _41 = _2.data[_40];
    int64_t _42 = _1 - _41;
    _a3__a2_double _43;
    // Computing bound for f
    _a3_int64_t _44;
    // Computing bound for f
    _44.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for g
    _44.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for h
    _44.d2 = c.d0;
    if (c.d0 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    // Computing total size of heap memory to allocate
    int64_t _45 = 1;
    _45 *= c.d0;
    _45 *= c.d1;
    _45 *= c.d0;
    _45 *= sizeof(int64_t);
    _44.data = jpl_alloc(_45);
    int64_t _46 = 0; // h
    int64_t _47 = 0; // g
    int64_t _48 = 0; // f
    _jump232:; // Begin body of loop
    int64_t _49 = 0;
    _49 *= _44.d0;
    _49 += _48;
    _49 *= _44.d1;
    _49 += _47;
    _49 *= _44.d2;
    _49 += _46;
    _44.data[_49] = _46;
    _46++;
    if (_46 < c.d0)
    goto _jump232;
    _46 = 0;
    _47++;
    if (_47 < c.d1)
    goto _jump232;
    _47 = 0;
    _48++;
    if (_48 < c.d0)
    goto _jump232;
    // End body of loop
    int64_t _50 = 24;
    bool _51 = true;
    int64_t _52;
    if (!_51)
    goto _jump233;
    _52 = c.d0;
    goto _jump234;
    _jump233:;
    _52 = c.d1;
    _jump234:;
    if (c.d1 >= 0)
    goto _jump235;
    fail_assertion("negative array index");
    _jump235:;
    if (c.d1 < _44.d0)
    goto _jump236;
    fail_assertion("index too large");
    _jump236:;
    if (_50 >= 0)
    goto _jump237;
    fail_assertion("negative array index");
    _jump237:;
    if (_50 < _44.d1)
    goto _jump238;
    fail_assertion("index too large");
    _jump238:;
    if (_52 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (_52 < _44.d2)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    int64_t _53 = 0;
    _53 *= _44.d0;
    _53 += c.d1;
    _53 *= _44.d1;
    _53 += _50;
    _53 *= _44.d2;
    _53 += _52;
    int64_t _54 = _44.data[_53];
    _43.d0 = _54;
    if (_54 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing bound for g
    int64_t _55 = c.d1 - c.d1;
    _43.d1 = _55;
    if (_55 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for h
    int64_t _56;
    // Computing bound for f
    int64_t _57 = -c.d1;
    if (_57 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    _56 = 0;
    int64_t _58 = 0; // f
    _jump244:; // Begin body of loop
    _56 += _58;
    _58++;
    if (_58 < _57)
    goto _jump244;
    // End body of loop
    _43.d2 = _56;
    if (_56 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _59 = 1;
    _59 *= _54;
    _59 *= _55;
    _59 *= _56;
    _59 *= sizeof(_a2_double);
    _43.data = jpl_alloc(_59);
    int64_t _60 = 0; // h
    int64_t _61 = 0; // g
    int64_t _62 = 0; // f
    _jump246:; // Begin body of loop
    bool _63 = c.d1 != _62;
    _a2_double _64;
    if (!_63)
    goto _jump247;
    _64 = c;
    goto _jump248;
    _jump247:;
    _64 = c;
    _jump248:;
    int64_t _65 = 0;
    _65 *= _43.d0;
    _65 += _62;
    _65 *= _43.d1;
    _65 += _61;
    _65 *= _43.d2;
    _65 += _60;
    _43.data[_65] = _64;
    _60++;
    if (_60 < _56)
    goto _jump246;
    _60 = 0;
    _61++;
    if (_61 < _55)
    goto _jump246;
    _61 = 0;
    _62++;
    if (_62 < _54)
    goto _jump246;
    // End body of loop
    _a2_int64_t _66;
    // Computing bound for f
    int64_t _67 = c.d1 % c.d1;
    _66.d0 = _67;
    if (_67 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    // Computing bound for g
    int64_t _68 = 771;
    int64_t _69 = _68 / c.d0;
    _66.d1 = _69;
    if (_69 > 0) 
    goto _jump250;
    fail_assertion("non-positive loop bound");
    _jump250:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= _67;
    _70 *= _69;
    _70 *= sizeof(int64_t);
    _66.data = jpl_alloc(_70);
    int64_t _71 = 0; // g
    int64_t _72 = 0; // f
    _jump251:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _66.d0;
    _73 += _72;
    _73 *= _66.d1;
    _73 += _71;
    _66.data[_73] = c.d0;
    _71++;
    if (_71 < _69)
    goto _jump251;
    _71 = 0;
    _72++;
    if (_72 < _67)
    goto _jump251;
    // End body of loop
    int64_t _74;
    // Computing bound for f
    if (c.d0 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for g
    int64_t _75 = 62;
    if (_75 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    _74 = 0;
    int64_t _76 = 0; // g
    int64_t _77 = 0; // f
    _jump254:; // Begin body of loop
    int64_t _78 = b(c);
    _74 += _78;
    _76++;
    if (_76 < _75)
    goto _jump254;
    _76 = 0;
    _77++;
    if (_77 < c.d0)
    goto _jump254;
    // End body of loop
    bool _79 = false;
    int64_t _80;
    if (!_79)
    goto _jump255;
    _80 = c.d0;
    goto _jump256;
    _jump255:;
    _80 = c.d0;
    _jump256:;
    if (_74 >= 0)
    goto _jump257;
    fail_assertion("negative array index");
    _jump257:;
    if (_74 < _66.d0)
    goto _jump258;
    fail_assertion("index too large");
    _jump258:;
    if (_80 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_80 < _66.d1)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    int64_t _81 = 0;
    _81 *= _66.d0;
    _81 += _74;
    _81 *= _66.d1;
    _81 += _80;
    int64_t _82 = _66.data[_81];
    if (c.d1 >= 0)
    goto _jump261;
    fail_assertion("negative array index");
    _jump261:;
    if (c.d1 < _43.d0)
    goto _jump262;
    fail_assertion("index too large");
    _jump262:;
    if (c.d0 >= 0)
    goto _jump263;
    fail_assertion("negative array index");
    _jump263:;
    if (c.d0 < _43.d1)
    goto _jump264;
    fail_assertion("index too large");
    _jump264:;
    if (_82 >= 0)
    goto _jump265;
    fail_assertion("negative array index");
    _jump265:;
    if (_82 < _43.d2)
    goto _jump266;
    fail_assertion("index too large");
    _jump266:;
    int64_t _83 = 0;
    _83 *= _43.d0;
    _83 += c.d1;
    _83 *= _43.d1;
    _83 += c.d0;
    _83 *= _43.d2;
    _83 += _82;
    _a2_double _84 = _43.data[_83];
    int64_t _85 = b(_84);
    int64_t _86 = _42 + _85;
    bool _87 = _86 <= c.d0;
    bool _88 = _87;
    if (0 != _87)
    goto _jump267;
    _a2__a2__a2_double _89;
    // Computing bound for g
    int64_t _90 = b(c);
    _89.d0 = _90;
    if (_90 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for h
    int64_t _91 = 528;
    int64_t _92 = 412;
    int64_t _93 = _91 - _92;
    _89.d1 = _93;
    if (_93 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    // Computing total size of heap memory to allocate
    int64_t _94 = 1;
    _94 *= _90;
    _94 *= _93;
    _94 *= sizeof(_a2__a2_double);
    _89.data = jpl_alloc(_94);
    int64_t _95 = 0; // h
    int64_t _96 = 0; // g
    _jump270:; // Begin body of loop
    _a2__a2_double _97;
    // Computing bound for i
    _97.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for j
    int64_t _98 = 931;
    _97.d1 = _98;
    if (_98 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= c.d1;
    _99 *= _98;
    _99 *= sizeof(_a2_double);
    _97.data = jpl_alloc(_99);
    int64_t _100 = 0; // j
    int64_t _101 = 0; // i
    _jump273:; // Begin body of loop
    int64_t _102 = 0;
    _102 *= _97.d0;
    _102 += _101;
    _102 *= _97.d1;
    _102 += _100;
    _97.data[_102] = c;
    _100++;
    if (_100 < _98)
    goto _jump273;
    _100 = 0;
    _101++;
    if (_101 < c.d1)
    goto _jump273;
    // End body of loop
    int64_t _103 = 0;
    _103 *= _89.d0;
    _103 += _96;
    _103 *= _89.d1;
    _103 += _95;
    _89.data[_103] = _97;
    _95++;
    if (_95 < _93)
    goto _jump270;
    _95 = 0;
    _96++;
    if (_96 < _90)
    goto _jump270;
    // End body of loop
    int64_t _104 = b(c);
    if (c.d1 >= 0)
    goto _jump274;
    fail_assertion("negative array index");
    _jump274:;
    if (c.d1 < _89.d0)
    goto _jump275;
    fail_assertion("index too large");
    _jump275:;
    if (_104 >= 0)
    goto _jump276;
    fail_assertion("negative array index");
    _jump276:;
    if (_104 < _89.d1)
    goto _jump277;
    fail_assertion("index too large");
    _jump277:;
    int64_t _105 = 0;
    _105 *= _89.d0;
    _105 += c.d1;
    _105 *= _89.d1;
    _105 += _104;
    _a2__a2_double _106 = _89.data[_105];
    bool _107 = a == a;
    int64_t _108;
    if (!_107)
    goto _jump278;
    int64_t _109 = 596;
    _108 = _109;
    goto _jump279;
    _jump278:;
    _108 = c.d0;
    _jump279:;
    int64_t _110 = -_108;
    int64_t _111;
    // Computing bound for g
    if (c.d0 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    _111 = 0;
    int64_t _112 = 0; // g
    _jump281:; // Begin body of loop
    _111 += _112;
    _112++;
    if (_112 < c.d0)
    goto _jump281;
    // End body of loop
    if (_110 >= 0)
    goto _jump282;
    fail_assertion("negative array index");
    _jump282:;
    if (_110 < _106.d0)
    goto _jump283;
    fail_assertion("index too large");
    _jump283:;
    if (_111 >= 0)
    goto _jump284;
    fail_assertion("negative array index");
    _jump284:;
    if (_111 < _106.d1)
    goto _jump285;
    fail_assertion("index too large");
    _jump285:;
    int64_t _113 = 0;
    _113 *= _106.d0;
    _113 += _110;
    _113 *= _106.d1;
    _113 += _111;
    _a2_double _114 = _106.data[_113];
    int64_t _115 = b(_114);
    int64_t _116;
    // Computing bound for g
    _a2_double _117;
    // Computing bound for g
    int64_t _118;
    // Computing bound for g
    if (c.d0 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    _118 = 0;
    int64_t _119 = 0; // g
    _jump287:; // Begin body of loop
    int64_t _120 = 982;
    _118 += _120;
    _119++;
    if (_119 < c.d0)
    goto _jump287;
    // End body of loop
    int64_t _121 = -_118;
    _117.d0 = _121;
    if (_121 > 0) 
    goto _jump288;
    fail_assertion("non-positive loop bound");
    _jump288:;
    // Computing bound for h
    int64_t _122;
    // Computing bound for g
    int64_t _123 = -c.d1;
    if (_123 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    _122 = 0;
    int64_t _124 = 0; // g
    _jump290:; // Begin body of loop
    int64_t _125 = -c.d1;
    _122 += _125;
    _124++;
    if (_124 < _123)
    goto _jump290;
    // End body of loop
    _117.d1 = _122;
    if (_122 > 0) 
    goto _jump291;
    fail_assertion("non-positive loop bound");
    _jump291:;
    // Computing total size of heap memory to allocate
    int64_t _126 = 1;
    _126 *= _121;
    _126 *= _122;
    _126 *= sizeof(double);
    _117.data = jpl_alloc(_126);
    int64_t _127 = 0; // h
    int64_t _128 = 0; // g
    _jump292:; // Begin body of loop
    double _129;
    if (!_87)
    goto _jump293;
    double _130 = 50.0;
    double _131 = -_130;
    _129 = _131;
    goto _jump294;
    _jump293:;
    if (_127 >= 0)
    goto _jump295;
    fail_assertion("negative array index");
    _jump295:;
    if (_127 < c.d0)
    goto _jump296;
    fail_assertion("index too large");
    _jump296:;
    if (c.d1 >= 0)
    goto _jump297;
    fail_assertion("negative array index");
    _jump297:;
    if (c.d1 < c.d1)
    goto _jump298;
    fail_assertion("index too large");
    _jump298:;
    int64_t _132 = 0;
    _132 *= c.d0;
    _132 += _127;
    _132 *= c.d1;
    _132 += c.d1;
    double _133 = c.data[_132];
    _129 = _133;
    _jump294:;
    int64_t _134 = 0;
    _134 *= _117.d0;
    _134 += _128;
    _134 *= _117.d1;
    _134 += _127;
    _117.data[_134] = _129;
    _127++;
    if (_127 < _122)
    goto _jump292;
    _127 = 0;
    _128++;
    if (_128 < _121)
    goto _jump292;
    // End body of loop
    int64_t _135 = b(_117);
    if (_135 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for h
    int64_t _136;
    // Computing bound for g
    int64_t _137 = 8;
    if (_137 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing bound for h
    int64_t _138 = b(c);
    if (_138 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing bound for i
    int64_t _139 = b(c);
    if (_139 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    _136 = 0;
    int64_t _140 = 0; // i
    int64_t _141 = 0; // h
    int64_t _142 = 0; // g
    _jump303:; // Begin body of loop
    _a1_int64_t _143;
    // Computing bound for j
    int64_t _144 = b(c);
    _143.d0 = _144;
    if (_144 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= _144;
    _145 *= sizeof(int64_t);
    _143.data = jpl_alloc(_145);
    int64_t _146 = 0; // j
    _jump305:; // Begin body of loop
    int64_t _147 = 0;
    _147 *= _143.d0;
    _147 += _146;
    _143.data[_147] = _146;
    _146++;
    if (_146 < _144)
    goto _jump305;
    // End body of loop
    int64_t _148 = 726;
    if (_148 >= 0)
    goto _jump306;
    fail_assertion("negative array index");
    _jump306:;
    if (_148 < _143.d0)
    goto _jump307;
    fail_assertion("index too large");
    _jump307:;
    int64_t _149 = 0;
    _149 *= _143.d0;
    _149 += _148;
    int64_t _150 = _143.data[_149];
    _136 += _150;
    _140++;
    if (_140 < _139)
    goto _jump303;
    _140 = 0;
    _141++;
    if (_141 < _138)
    goto _jump303;
    _141 = 0;
    _142++;
    if (_142 < _137)
    goto _jump303;
    // End body of loop
    if (_136 > 0) 
    goto _jump308;
    fail_assertion("non-positive loop bound");
    _jump308:;
    _116 = 0;
    int64_t _151 = 0; // h
    int64_t _152 = 0; // g
    _jump309:; // Begin body of loop
    _116 += _151;
    _151++;
    if (_151 < _136)
    goto _jump309;
    _151 = 0;
    _152++;
    if (_152 < _135)
    goto _jump309;
    // End body of loop
    bool _153 = _115 != _116;
    _88 = _153;
    _jump267:;
    if (0 != _88)
    goto _jump310;
    fail_assertion("g");
    _jump310:;
    _a1_int64_t _154;
    // Computing bound for g
    int64_t _155 = 717;
    _154.d0 = _155;
    if (_155 > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= _155;
    _156 *= sizeof(int64_t);
    _154.data = jpl_alloc(_156);
    int64_t _157 = 0; // g
    _jump312:; // Begin body of loop
    _a2_double _158;
    // Computing bound for h
    _158.d0 = _157;
    if (_157 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for i
    _a1_bool _159;
    _159.d0 = 2;
    _159.data = jpl_alloc(sizeof(bool) * 2);
    _159.data[0] = _87;
    _159.data[1] = a;
    int64_t _160;
    if (!_87)
    goto _jump314;
    _160 = c.d1;
    goto _jump315;
    _jump314:;
    _160 = c.d1;
    _jump315:;
    if (_160 >= 0)
    goto _jump316;
    fail_assertion("negative array index");
    _jump316:;
    if (_160 < _159.d0)
    goto _jump317;
    fail_assertion("index too large");
    _jump317:;
    int64_t _161 = 0;
    _161 *= _159.d0;
    _161 += _160;
    bool _162 = _159.data[_161];
    bool _163;
    if (!_162)
    goto _jump318;
    bool _164 = !a;
    bool _165 = !_164;
    _163 = _165;
    goto _jump319;
    _jump318:;
    bool _167 = !a;
    bool _166 = _167;
    if (0 == _167)
    goto _jump320;
    bool _168 = true;
    _166 = _168;
    _jump320:;
    _163 = _166;
    _jump319:;
    int64_t _169;
    if (!_163)
    goto _jump321;
    int64_t _170 = 568;
    _169 = _170;
    goto _jump322;
    _jump321:;
    _169 = c.d0;
    _jump322:;
    _158.d1 = _169;
    if (_169 > 0) 
    goto _jump323;
    fail_assertion("non-positive loop bound");
    _jump323:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _157;
    _171 *= _169;
    _171 *= sizeof(double);
    _158.data = jpl_alloc(_171);
    int64_t _172 = 0; // i
    int64_t _173 = 0; // h
    _jump324:; // Begin body of loop
    double _174;
    // Computing bound for j
    _a2_double _175;
    if (!_87)
    goto _jump325;
    _a2_double _176;
    // Computing bound for j
    _176.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing bound for k
    _176.d1 = _172;
    if (_172 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= c.d0;
    _177 *= _172;
    _177 *= sizeof(double);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // k
    int64_t _179 = 0; // j
    _jump328:; // Begin body of loop
    double _180 = 0.0;
    int64_t _181 = 0;
    _181 *= _176.d0;
    _181 += _179;
    _181 *= _176.d1;
    _181 += _178;
    _176.data[_181] = _180;
    _178++;
    if (_178 < _172)
    goto _jump328;
    _178 = 0;
    _179++;
    if (_179 < c.d0)
    goto _jump328;
    // End body of loop
    _175 = _176;
    goto _jump329;
    _jump325:;
    _175 = c;
    _jump329:;
    int64_t _182 = b(_175);
    if (_182 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for k
    int64_t _183 = 666;
    int64_t _184 = _173 % _183;
    if (_184 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing bound for l
    if (_173 > 0) 
    goto _jump332;
    fail_assertion("non-positive loop bound");
    _jump332:;
    _174 = 0;
    int64_t _185 = 0; // l
    int64_t _186 = 0; // k
    int64_t _187 = 0; // j
    _jump333:; // Begin body of loop
    bool _188 = true;
    double _189;
    if (!_188)
    goto _jump334;
    double _190 = 88.0;
    double _191 = -_190;
    double _192 = -_191;
    _189 = _192;
    goto _jump335;
    _jump334:;
    bool _193 = true;
    double _194;
    if (!_193)
    goto _jump336;
    double _195 = 30.0;
    _194 = _195;
    goto _jump337;
    _jump336:;
    double _196 = 21.0;
    _194 = _196;
    _jump337:;
    double _197 = -_194;
    _189 = _197;
    _jump335:;
    _174 += _189;
    _185++;
    if (_185 < _173)
    goto _jump333;
    _185 = 0;
    _186++;
    if (_186 < _184)
    goto _jump333;
    _186 = 0;
    _187++;
    if (_187 < _182)
    goto _jump333;
    // End body of loop
    int64_t _198 = 0;
    _198 *= _158.d0;
    _198 += _173;
    _198 *= _158.d1;
    _198 += _172;
    _158.data[_198] = _174;
    _172++;
    if (_172 < _169)
    goto _jump324;
    _172 = 0;
    _173++;
    if (_173 < _157)
    goto _jump324;
    // End body of loop
    int64_t _199 = b(_158);
    int64_t _200 = 0;
    _200 *= _154.d0;
    _200 += _157;
    _154.data[_200] = _199;
    _157++;
    if (_157 < _155)
    goto _jump312;
    // End body of loop
    int64_t _201 = b(c);
    int64_t _202 = 291;
    bool _203 = _201 >= _202;
    bool _204 = !_203;
    _a3__a1_int64_t _205;
    if (!_204)
    goto _jump338;
    _a3__a1_int64_t _206;
    // Computing bound for i
    int64_t _207 = 770;
    int64_t _208 = c.d1 / _207;
    _206.d0 = _208;
    if (_208 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    // Computing bound for j
    _a2_int64_t _209;
    // Computing bound for i
    _209.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump340;
    fail_assertion("non-positive loop bound");
    _jump340:;
    // Computing bound for j
    int64_t _210 = 741;
    int64_t _211 = c.d0 % _210;
    _209.d1 = _211;
    if (_211 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= c.d0;
    _212 *= _211;
    _212 *= sizeof(int64_t);
    _209.data = jpl_alloc(_212);
    int64_t _213 = 0; // j
    int64_t _214 = 0; // i
    _jump342:; // Begin body of loop
    int64_t _215 = 0;
    _215 *= _209.d0;
    _215 += _214;
    _215 *= _209.d1;
    _215 += _213;
    _209.data[_215] = _213;
    _213++;
    if (_213 < _211)
    goto _jump342;
    _213 = 0;
    _214++;
    if (_214 < c.d0)
    goto _jump342;
    // End body of loop
    int64_t _216 = 379;
    if (_216 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (_216 < _209.d0)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (c.d1 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (c.d1 < _209.d1)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _217 = 0;
    _217 *= _209.d0;
    _217 += _216;
    _217 *= _209.d1;
    _217 += c.d1;
    int64_t _218 = _209.data[_217];
    _206.d1 = _218;
    if (_218 > 0) 
    goto _jump347;
    fail_assertion("non-positive loop bound");
    _jump347:;
    // Computing bound for k
    int64_t _219 = -c.d1;
    int64_t _220 = -_219;
    _206.d2 = _220;
    if (_220 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _208;
    _221 *= _218;
    _221 *= _220;
    _221 *= sizeof(_a1_int64_t);
    _206.data = jpl_alloc(_221);
    int64_t _222 = 0; // k
    int64_t _223 = 0; // j
    int64_t _224 = 0; // i
    _jump349:; // Begin body of loop
    int64_t _225 = 0;
    _225 *= _206.d0;
    _225 += _224;
    _225 *= _206.d1;
    _225 += _223;
    _225 *= _206.d2;
    _225 += _222;
    _206.data[_225] = _154;
    _222++;
    if (_222 < _220)
    goto _jump349;
    _222 = 0;
    _223++;
    if (_223 < _218)
    goto _jump349;
    _223 = 0;
    _224++;
    if (_224 < _208)
    goto _jump349;
    // End body of loop
    _205 = _206;
    goto _jump350;
    _jump338:;
    _a3_bool _226;
    // Computing bound for i
    int64_t _227 = 774;
    _226.d0 = _227;
    if (_227 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing bound for j
    _226.d1 = _154.d0;
    if (_154.d0 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    // Computing bound for k
    int64_t _228;
    // Computing bound for i
    if (_154.d0 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    _228 = 0;
    int64_t _229 = 0; // i
    _jump354:; // Begin body of loop
    _228 += _229;
    _229++;
    if (_229 < _154.d0)
    goto _jump354;
    // End body of loop
    _226.d2 = _228;
    if (_228 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= _227;
    _230 *= _154.d0;
    _230 *= _228;
    _230 *= sizeof(bool);
    _226.data = jpl_alloc(_230);
    int64_t _231 = 0; // k
    int64_t _232 = 0; // j
    int64_t _233 = 0; // i
    _jump356:; // Begin body of loop
    bool _234 = true;
    int64_t _235 = 0;
    _235 *= _226.d0;
    _235 += _233;
    _235 *= _226.d1;
    _235 += _232;
    _235 *= _226.d2;
    _235 += _231;
    _226.data[_235] = _234;
    _231++;
    if (_231 < _228)
    goto _jump356;
    _231 = 0;
    _232++;
    if (_232 < _154.d0)
    goto _jump356;
    _232 = 0;
    _233++;
    if (_233 < _227)
    goto _jump356;
    // End body of loop
    int64_t _236 = b(c);
    int64_t _237 = -_236;
    _a1_int64_t _238;
    // Computing bound for i
    int64_t _239 = 720;
    _238.d0 = _239;
    if (_239 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    // Computing total size of heap memory to allocate
    int64_t _240 = 1;
    _240 *= _239;
    _240 *= sizeof(int64_t);
    _238.data = jpl_alloc(_240);
    int64_t _241 = 0; // i
    _jump358:; // Begin body of loop
    int64_t _242 = 0;
    _242 *= _238.d0;
    _242 += _241;
    _238.data[_242] = _241;
    _241++;
    if (_241 < _239)
    goto _jump358;
    // End body of loop
    int64_t _243 = _154.d0 + _154.d0;
    if (_243 >= 0)
    goto _jump359;
    fail_assertion("negative array index");
    _jump359:;
    if (_243 < _238.d0)
    goto _jump360;
    fail_assertion("index too large");
    _jump360:;
    int64_t _244 = 0;
    _244 *= _238.d0;
    _244 += _243;
    int64_t _245 = _238.data[_244];
    int64_t _246;
    // Computing bound for i
    int64_t _247 = -c.d1;
    if (_247 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    _246 = 0;
    int64_t _248 = 0; // i
    _jump362:; // Begin body of loop
    int64_t _249 = _248 * _248;
    _246 += _249;
    _248++;
    if (_248 < _247)
    goto _jump362;
    // End body of loop
    if (_237 >= 0)
    goto _jump363;
    fail_assertion("negative array index");
    _jump363:;
    if (_237 < _226.d0)
    goto _jump364;
    fail_assertion("index too large");
    _jump364:;
    if (_245 >= 0)
    goto _jump365;
    fail_assertion("negative array index");
    _jump365:;
    if (_245 < _226.d1)
    goto _jump366;
    fail_assertion("index too large");
    _jump366:;
    if (_246 >= 0)
    goto _jump367;
    fail_assertion("negative array index");
    _jump367:;
    if (_246 < _226.d2)
    goto _jump368;
    fail_assertion("index too large");
    _jump368:;
    int64_t _250 = 0;
    _250 *= _226.d0;
    _250 += _237;
    _250 *= _226.d1;
    _250 += _245;
    _250 *= _226.d2;
    _250 += _246;
    bool _251 = _226.data[_250];
    _a3__a1_int64_t _252;
    if (!_251)
    goto _jump369;
    _a3__a1_int64_t _253;
    // Computing bound for i
    bool _254 = true;
    int64_t _255;
    if (!_254)
    goto _jump370;
    _255 = c.d1;
    goto _jump371;
    _jump370:;
    _255 = _154.d0;
    _jump371:;
    _253.d0 = _255;
    if (_255 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    // Computing bound for j
    _253.d1 = _154.d0;
    if (_154.d0 > 0) 
    goto _jump373;
    fail_assertion("non-positive loop bound");
    _jump373:;
    // Computing bound for k
    _253.d2 = c.d1;
    if (c.d1 > 0) 
    goto _jump374;
    fail_assertion("non-positive loop bound");
    _jump374:;
    // Computing total size of heap memory to allocate
    int64_t _256 = 1;
    _256 *= _255;
    _256 *= _154.d0;
    _256 *= c.d1;
    _256 *= sizeof(_a1_int64_t);
    _253.data = jpl_alloc(_256);
    int64_t _257 = 0; // k
    int64_t _258 = 0; // j
    int64_t _259 = 0; // i
    _jump375:; // Begin body of loop
    _a1_int64_t _260;
    if (!a)
    goto _jump376;
    int64_t _261 = 715;
    _a1_int64_t _262;
    _262.d0 = 3;
    _262.data = jpl_alloc(sizeof(int64_t) * 3);
    _262.data[0] = _259;
    _262.data[1] = _261;
    _262.data[2] = c.d1;
    _260 = _262;
    goto _jump377;
    _jump376:;
    _a1_int64_t _263;
    _263.d0 = 1;
    _263.data = jpl_alloc(sizeof(int64_t) * 1);
    _263.data[0] = _259;
    _260 = _263;
    _jump377:;
    int64_t _264 = 0;
    _264 *= _253.d0;
    _264 += _259;
    _264 *= _253.d1;
    _264 += _258;
    _264 *= _253.d2;
    _264 += _257;
    _253.data[_264] = _260;
    _257++;
    if (_257 < c.d1)
    goto _jump375;
    _257 = 0;
    _258++;
    if (_258 < _154.d0)
    goto _jump375;
    _258 = 0;
    _259++;
    if (_259 < _255)
    goto _jump375;
    // End body of loop
    _252 = _253;
    goto _jump378;
    _jump369:;
    _a2__a3__a1_int64_t _265;
    // Computing bound for i
    int64_t _266;
    // Computing bound for i
    if (c.d1 > 0) 
    goto _jump379;
    fail_assertion("non-positive loop bound");
    _jump379:;
    _266 = 0;
    int64_t _267 = 0; // i
    _jump380:; // Begin body of loop
    _266 += _267;
    _267++;
    if (_267 < c.d1)
    goto _jump380;
    // End body of loop
    _265.d0 = _266;
    if (_266 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing bound for j
    int64_t _268 = b(c);
    _265.d1 = _268;
    if (_268 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing total size of heap memory to allocate
    int64_t _269 = 1;
    _269 *= _266;
    _269 *= _268;
    _269 *= sizeof(_a3__a1_int64_t);
    _265.data = jpl_alloc(_269);
    int64_t _270 = 0; // j
    int64_t _271 = 0; // i
    _jump383:; // Begin body of loop
    _a3__a1_int64_t _272;
    // Computing bound for k
    _272.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    // Computing bound for l
    int64_t _273 = 389;
    _272.d1 = _273;
    if (_273 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing bound for m
    int64_t _274 = 382;
    _272.d2 = _274;
    if (_274 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing total size of heap memory to allocate
    int64_t _275 = 1;
    _275 *= c.d1;
    _275 *= _273;
    _275 *= _274;
    _275 *= sizeof(_a1_int64_t);
    _272.data = jpl_alloc(_275);
    int64_t _276 = 0; // m
    int64_t _277 = 0; // l
    int64_t _278 = 0; // k
    _jump387:; // Begin body of loop
    int64_t _279 = 0;
    _279 *= _272.d0;
    _279 += _278;
    _279 *= _272.d1;
    _279 += _277;
    _279 *= _272.d2;
    _279 += _276;
    _272.data[_279] = _154;
    _276++;
    if (_276 < _274)
    goto _jump387;
    _276 = 0;
    _277++;
    if (_277 < _273)
    goto _jump387;
    _277 = 0;
    _278++;
    if (_278 < c.d1)
    goto _jump387;
    // End body of loop
    int64_t _280 = 0;
    _280 *= _265.d0;
    _280 += _271;
    _280 *= _265.d1;
    _280 += _270;
    _265.data[_280] = _272;
    _270++;
    if (_270 < _268)
    goto _jump383;
    _270 = 0;
    _271++;
    if (_271 < _266)
    goto _jump383;
    // End body of loop
    int64_t _281 = -c.d1;
    if (c.d0 >= 0)
    goto _jump388;
    fail_assertion("negative array index");
    _jump388:;
    if (c.d0 < _265.d0)
    goto _jump389;
    fail_assertion("index too large");
    _jump389:;
    if (_281 >= 0)
    goto _jump390;
    fail_assertion("negative array index");
    _jump390:;
    if (_281 < _265.d1)
    goto _jump391;
    fail_assertion("index too large");
    _jump391:;
    int64_t _282 = 0;
    _282 *= _265.d0;
    _282 += c.d0;
    _282 *= _265.d1;
    _282 += _281;
    _a3__a1_int64_t _283 = _265.data[_282];
    _252 = _283;
    _jump378:;
    _205 = _252;
    _jump350:;
    bool _284 = false;
    _a2_int64_t _285;
    if (!_284)
    goto _jump392;
    _a1__a2_int64_t _286;
    // Computing bound for i
    _286.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= c.d1;
    _287 *= sizeof(_a2_int64_t);
    _286.data = jpl_alloc(_287);
    int64_t _288 = 0; // i
    _jump394:; // Begin body of loop
    _a2_int64_t _289;
    // Computing bound for j
    _289.d0 = _154.d0;
    if (_154.d0 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    // Computing bound for k
    _289.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    // Computing total size of heap memory to allocate
    int64_t _290 = 1;
    _290 *= _154.d0;
    _290 *= c.d0;
    _290 *= sizeof(int64_t);
    _289.data = jpl_alloc(_290);
    int64_t _291 = 0; // k
    int64_t _292 = 0; // j
    _jump397:; // Begin body of loop
    int64_t _293 = 0;
    _293 *= _289.d0;
    _293 += _292;
    _293 *= _289.d1;
    _293 += _291;
    _289.data[_293] = _154.d0;
    _291++;
    if (_291 < c.d0)
    goto _jump397;
    _291 = 0;
    _292++;
    if (_292 < _154.d0)
    goto _jump397;
    // End body of loop
    int64_t _294 = 0;
    _294 *= _286.d0;
    _294 += _288;
    _286.data[_294] = _289;
    _288++;
    if (_288 < c.d1)
    goto _jump394;
    // End body of loop
    int64_t _295 = 661;
    int64_t _296 = -_295;
    if (_296 >= 0)
    goto _jump398;
    fail_assertion("negative array index");
    _jump398:;
    if (_296 < _286.d0)
    goto _jump399;
    fail_assertion("index too large");
    _jump399:;
    int64_t _297 = 0;
    _297 *= _286.d0;
    _297 += _296;
    _a2_int64_t _298 = _286.data[_297];
    _285 = _298;
    goto _jump400;
    _jump392:;
    _a2_int64_t _299;
    // Computing bound for i
    _299.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for j
    _a2_int64_t _300;
    // Computing bound for i
    _300.d0 = _154.d0;
    if (_154.d0 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    // Computing bound for j
    int64_t _301 = 680;
    _300.d1 = _301;
    if (_301 > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _154.d0;
    _302 *= _301;
    _302 *= sizeof(int64_t);
    _300.data = jpl_alloc(_302);
    int64_t _303 = 0; // j
    int64_t _304 = 0; // i
    _jump404:; // Begin body of loop
    int64_t _305 = 0;
    _305 *= _300.d0;
    _305 += _304;
    _305 *= _300.d1;
    _305 += _303;
    _300.data[_305] = c.d1;
    _303++;
    if (_303 < _301)
    goto _jump404;
    _303 = 0;
    _304++;
    if (_304 < _154.d0)
    goto _jump404;
    // End body of loop
    int64_t _306 = -c.d1;
    int64_t _307 = 429;
    if (_306 >= 0)
    goto _jump405;
    fail_assertion("negative array index");
    _jump405:;
    if (_306 < _300.d0)
    goto _jump406;
    fail_assertion("index too large");
    _jump406:;
    if (_307 >= 0)
    goto _jump407;
    fail_assertion("negative array index");
    _jump407:;
    if (_307 < _300.d1)
    goto _jump408;
    fail_assertion("index too large");
    _jump408:;
    int64_t _308 = 0;
    _308 *= _300.d0;
    _308 += _306;
    _308 *= _300.d1;
    _308 += _307;
    int64_t _309 = _300.data[_308];
    _299.d1 = _309;
    if (_309 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    // Computing total size of heap memory to allocate
    int64_t _310 = 1;
    _310 *= c.d1;
    _310 *= _309;
    _310 *= sizeof(int64_t);
    _299.data = jpl_alloc(_310);
    int64_t _311 = 0; // j
    int64_t _312 = 0; // i
    _jump410:; // Begin body of loop
    int64_t _313 = 0;
    _313 *= _299.d0;
    _313 += _312;
    _313 *= _299.d1;
    _313 += _311;
    _299.data[_313] = _154.d0;
    _311++;
    if (_311 < _309)
    goto _jump410;
    _311 = 0;
    _312++;
    if (_312 < c.d1)
    goto _jump410;
    // End body of loop
    _285 = _299;
    _jump400:;
    int64_t _314;
    // Computing bound for i
    bool _315 = _154.d0 != _154.d0;
    bool _316 = !_315;
    int64_t _317;
    if (!_316)
    goto _jump411;
    _317 = c.d1;
    goto _jump412;
    _jump411:;
    int64_t _318 = 776;
    _317 = _318;
    _jump412:;
    if (_317 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing bound for j
    int64_t _319 = 992;
    int64_t _320;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    _320 = 0;
    int64_t _321 = 0; // i
    _jump415:; // Begin body of loop
    _320 += _321;
    _321++;
    if (_321 < c.d0)
    goto _jump415;
    // End body of loop
    int64_t _322 = -_320;
    int64_t _323 = _319 / _322;
    if (_323 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for k
    int64_t _324;
    if (!a)
    goto _jump417;
    int64_t _325 = b(c);
    _324 = _325;
    goto _jump418;
    _jump417:;
    int64_t _326 = c.d1 % c.d1;
    int64_t _327 = -_326;
    _324 = _327;
    _jump418:;
    if (_324 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    _314 = 0;
    int64_t _328 = 0; // k
    int64_t _329 = 0; // j
    int64_t _330 = 0; // i
    _jump420:; // Begin body of loop
    _314 += _329;
    _328++;
    if (_328 < _324)
    goto _jump420;
    _328 = 0;
    _329++;
    if (_329 < _323)
    goto _jump420;
    _329 = 0;
    _330++;
    if (_330 < _317)
    goto _jump420;
    // End body of loop
    if (_314 >= 0)
    goto _jump421;
    fail_assertion("negative array index");
    _jump421:;
    if (_314 < _285.d0)
    goto _jump422;
    fail_assertion("index too large");
    _jump422:;
    if (c.d0 >= 0)
    goto _jump423;
    fail_assertion("negative array index");
    _jump423:;
    if (c.d0 < _285.d1)
    goto _jump424;
    fail_assertion("index too large");
    _jump424:;
    int64_t _331 = 0;
    _331 *= _285.d0;
    _331 += _314;
    _331 *= _285.d1;
    _331 += c.d0;
    int64_t _332 = _285.data[_331];
    int64_t _333;
    if (!a)
    goto _jump425;
    int64_t _334 = 3;
    int64_t _335;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    _335 = 0;
    int64_t _336 = 0; // i
    _jump427:; // Begin body of loop
    _335 += _336;
    _336++;
    if (_336 < c.d0)
    goto _jump427;
    // End body of loop
    _a1_int64_t _337;
    _337.d0 = 2;
    _337.data = jpl_alloc(sizeof(int64_t) * 2);
    _337.data[0] = _334;
    _337.data[1] = _335;
    if (c.d0 >= 0)
    goto _jump428;
    fail_assertion("negative array index");
    _jump428:;
    if (c.d0 < _337.d0)
    goto _jump429;
    fail_assertion("index too large");
    _jump429:;
    int64_t _338 = 0;
    _338 *= _337.d0;
    _338 += c.d0;
    int64_t _339 = _337.data[_338];
    _333 = _339;
    goto _jump430;
    _jump425:;
    int64_t _340 = 428;
    int64_t _341;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    // Computing bound for j
    _a1_int64_t _342;
    // Computing bound for i
    _342.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump432;
    fail_assertion("non-positive loop bound");
    _jump432:;
    // Computing total size of heap memory to allocate
    int64_t _343 = 1;
    _343 *= c.d0;
    _343 *= sizeof(int64_t);
    _342.data = jpl_alloc(_343);
    int64_t _344 = 0; // i
    _jump433:; // Begin body of loop
    int64_t _345 = 66;
    int64_t _346 = 0;
    _346 *= _342.d0;
    _346 += _344;
    _342.data[_346] = _345;
    _344++;
    if (_344 < c.d0)
    goto _jump433;
    // End body of loop
    if (c.d1 >= 0)
    goto _jump434;
    fail_assertion("negative array index");
    _jump434:;
    if (c.d1 < _342.d0)
    goto _jump435;
    fail_assertion("index too large");
    _jump435:;
    int64_t _347 = 0;
    _347 *= _342.d0;
    _347 += c.d1;
    int64_t _348 = _342.data[_347];
    if (_348 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    _341 = 0;
    int64_t _349 = 0; // j
    int64_t _350 = 0; // i
    _jump437:; // Begin body of loop
    int64_t _351 = -c.d0;
    _341 += _351;
    _349++;
    if (_349 < _348)
    goto _jump437;
    _349 = 0;
    _350++;
    if (_350 < c.d0)
    goto _jump437;
    // End body of loop
    int64_t _352 = _340 % _341;
    _333 = _352;
    _jump430:;
    if (_154.d0 >= 0)
    goto _jump438;
    fail_assertion("negative array index");
    _jump438:;
    if (_154.d0 < _205.d0)
    goto _jump439;
    fail_assertion("index too large");
    _jump439:;
    if (_332 >= 0)
    goto _jump440;
    fail_assertion("negative array index");
    _jump440:;
    if (_332 < _205.d1)
    goto _jump441;
    fail_assertion("index too large");
    _jump441:;
    if (_333 >= 0)
    goto _jump442;
    fail_assertion("negative array index");
    _jump442:;
    if (_333 < _205.d2)
    goto _jump443;
    fail_assertion("index too large");
    _jump443:;
    int64_t _353 = 0;
    _353 *= _205.d0;
    _353 += _154.d0;
    _353 *= _205.d1;
    _353 += _332;
    _353 *= _205.d2;
    _353 += _333;
    _a1_int64_t _354 = _205.data[_353];
    _a1__a1_int64_t _355;
    _355.d0 = 1;
    _355.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _355.data[0] = _354;
    int64_t _357;
    // Computing bound for j
    _a2_double _358;
    // Computing bound for j
    _358.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing bound for k
    int64_t _359 = b(c);
    _358.d1 = _359;
    if (_359 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    // Computing total size of heap memory to allocate
    int64_t _360 = 1;
    _360 *= c.d1;
    _360 *= _359;
    _360 *= sizeof(double);
    _358.data = jpl_alloc(_360);
    int64_t _361 = 0; // k
    int64_t _362 = 0; // j
    _jump446:; // Begin body of loop
    double _363 = 66.0;
    int64_t _364 = 0;
    _364 *= _358.d0;
    _364 += _362;
    _364 *= _358.d1;
    _364 += _361;
    _358.data[_364] = _363;
    _361++;
    if (_361 < _359)
    goto _jump446;
    _361 = 0;
    _362++;
    if (_362 < c.d1)
    goto _jump446;
    // End body of loop
    int64_t _365 = b(_358);
    int64_t _366 = -_365;
    if (_366 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    // Computing bound for k
    int64_t _367;
    // Computing bound for j
    int64_t _368 = -c.d0;
    if (_368 > 0) 
    goto _jump448;
    fail_assertion("non-positive loop bound");
    _jump448:;
    // Computing bound for k
    int64_t _369;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for k
    int64_t _370;
    if (!a)
    goto _jump450;
    _370 = c.d0;
    goto _jump451;
    _jump450:;
    int64_t _371;
    // Computing bound for j
    int64_t _372 = 629;
    if (_372 > 0) 
    goto _jump452;
    fail_assertion("non-positive loop bound");
    _jump452:;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    _371 = 0;
    int64_t _373 = 0; // k
    int64_t _374 = 0; // j
    _jump454:; // Begin body of loop
    int64_t _375 = 547;
    _371 += _375;
    _373++;
    if (_373 < c.d1)
    goto _jump454;
    _373 = 0;
    _374++;
    if (_374 < _372)
    goto _jump454;
    // End body of loop
    _370 = _371;
    _jump451:;
    if (_370 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for l
    int64_t _376;
    if (!a)
    goto _jump456;
    int64_t _377 = 503;
    _376 = _377;
    goto _jump457;
    _jump456:;
    _376 = c.d0;
    _jump457:;
    if (_376 > 0) 
    goto _jump458;
    fail_assertion("non-positive loop bound");
    _jump458:;
    _369 = 0;
    int64_t _378 = 0; // l
    int64_t _379 = 0; // k
    int64_t _380 = 0; // j
    _jump459:; // Begin body of loop
    int64_t _381 = 340;
    _369 += _381;
    _378++;
    if (_378 < _376)
    goto _jump459;
    _378 = 0;
    _379++;
    if (_379 < _370)
    goto _jump459;
    _379 = 0;
    _380++;
    if (_380 < c.d0)
    goto _jump459;
    // End body of loop
    if (_369 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing bound for l
    int64_t _382 = 664;
    if (_382 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    _367 = 0;
    int64_t _383 = 0; // l
    int64_t _384 = 0; // k
    int64_t _385 = 0; // j
    _jump462:; // Begin body of loop
    _367 += c.d1;
    _383++;
    if (_383 < _382)
    goto _jump462;
    _383 = 0;
    _384++;
    if (_384 < _369)
    goto _jump462;
    _384 = 0;
    _385++;
    if (_385 < _368)
    goto _jump462;
    // End body of loop
    if (_367 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing bound for l
    int64_t _386;
    // Computing bound for j
    int64_t _387;
    // Computing bound for j
    if (_154.d0 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing bound for k
    int64_t _388 = 286;
    int64_t _389 = -_388;
    if (_389 > 0) 
    goto _jump465;
    fail_assertion("non-positive loop bound");
    _jump465:;
    _387 = 0;
    int64_t _390 = 0; // k
    int64_t _391 = 0; // j
    _jump466:; // Begin body of loop
    _387 += _154.d0;
    _390++;
    if (_390 < _389)
    goto _jump466;
    _390 = 0;
    _391++;
    if (_391 < _154.d0)
    goto _jump466;
    // End body of loop
    if (_387 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing bound for k
    if (_154.d0 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    _386 = 0;
    int64_t _392 = 0; // l
    int64_t _393 = 0; // k
    int64_t _394 = 0; // j
    _jump470:; // Begin body of loop
    int64_t _395 = b(c);
    int64_t _396 = -_395;
    _386 += _396;
    _392++;
    if (_392 < c.d0)
    goto _jump470;
    _392 = 0;
    _393++;
    if (_393 < _154.d0)
    goto _jump470;
    _393 = 0;
    _394++;
    if (_394 < _387)
    goto _jump470;
    // End body of loop
    int64_t _397 = 493;
    int64_t _398 = -_397;
    int64_t _399;
    if (!_87)
    goto _jump471;
    _399 = c.d1;
    goto _jump472;
    _jump471:;
    _399 = c.d1;
    _jump472:;
    int64_t _400 = _398 % _399;
    int64_t _401 = _386 / _400;
    if (_401 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    _357 = 0;
    int64_t _402 = 0; // l
    int64_t _403 = 0; // k
    int64_t _404 = 0; // j
    _jump474:; // Begin body of loop
    _a3_int64_t _405;
    // Computing bound for m
    _405.d0 = _154.d0;
    if (_154.d0 > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing bound for n
    int64_t _406 = b(c);
    _405.d1 = _406;
    if (_406 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing bound for o
    _405.d2 = _402;
    if (_402 > 0) 
    goto _jump477;
    fail_assertion("non-positive loop bound");
    _jump477:;
    // Computing total size of heap memory to allocate
    int64_t _407 = 1;
    _407 *= _154.d0;
    _407 *= _406;
    _407 *= _402;
    _407 *= sizeof(int64_t);
    _405.data = jpl_alloc(_407);
    int64_t _408 = 0; // o
    int64_t _409 = 0; // n
    int64_t _410 = 0; // m
    _jump478:; // Begin body of loop
    int64_t _411 = 0;
    _411 *= _405.d0;
    _411 += _410;
    _411 *= _405.d1;
    _411 += _409;
    _411 *= _405.d2;
    _411 += _408;
    _405.data[_411] = _154.d0;
    _408++;
    if (_408 < _402)
    goto _jump478;
    _408 = 0;
    _409++;
    if (_409 < _406)
    goto _jump478;
    _409 = 0;
    _410++;
    if (_410 < _154.d0)
    goto _jump478;
    // End body of loop
    int64_t _412;
    if (!a)
    goto _jump479;
    int64_t _413;
    // Computing bound for m
    if (_154.d0 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for n
    if (c.d1 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    _413 = 0;
    int64_t _414 = 0; // n
    int64_t _415 = 0; // m
    _jump482:; // Begin body of loop
    _413 += _415;
    _414++;
    if (_414 < c.d1)
    goto _jump482;
    _414 = 0;
    _415++;
    if (_415 < _154.d0)
    goto _jump482;
    // End body of loop
    _412 = _413;
    goto _jump483;
    _jump479:;
    _412 = _404;
    _jump483:;
    int64_t _416 = c.d0 + _403;
    bool _417 = !_87;
    _a2_double _418;
    if (!_417)
    goto _jump484;
    _a2_double _419;
    // Computing bound for m
    int64_t _420 = 908;
    _419.d0 = _420;
    if (_420 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing bound for n
    int64_t _421 = 90;
    _419.d1 = _421;
    if (_421 > 0) 
    goto _jump486;
    fail_assertion("non-positive loop bound");
    _jump486:;
    // Computing total size of heap memory to allocate
    int64_t _422 = 1;
    _422 *= _420;
    _422 *= _421;
    _422 *= sizeof(double);
    _419.data = jpl_alloc(_422);
    int64_t _423 = 0; // n
    int64_t _424 = 0; // m
    _jump487:; // Begin body of loop
    double _425 = 81.0;
    int64_t _426 = 0;
    _426 *= _419.d0;
    _426 += _424;
    _426 *= _419.d1;
    _426 += _423;
    _419.data[_426] = _425;
    _423++;
    if (_423 < _421)
    goto _jump487;
    _423 = 0;
    _424++;
    if (_424 < _420)
    goto _jump487;
    // End body of loop
    _418 = _419;
    goto _jump488;
    _jump484:;
    _418 = c;
    _jump488:;
    int64_t _427 = b(_418);
    if (_412 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_412 < _405.d0)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    if (_416 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_416 < _405.d1)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_427 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_427 < _405.d2)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    int64_t _428 = 0;
    _428 *= _405.d0;
    _428 += _412;
    _428 *= _405.d1;
    _428 += _416;
    _428 *= _405.d2;
    _428 += _427;
    int64_t _429 = _405.data[_428];
    _357 += _429;
    _402++;
    if (_402 < _401)
    goto _jump474;
    _402 = 0;
    _403++;
    if (_403 < _367)
    goto _jump474;
    _403 = 0;
    _404++;
    if (_404 < _366)
    goto _jump474;
    // End body of loop
    _a2_int64_t _430;
    // Computing bound for j
    _430.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing bound for k
    int64_t _431;
    // Computing bound for j
    if (_154.d0 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing bound for k
    int64_t _432 = 949;
    int64_t _433 = -_432;
    int64_t _434 = -_433;
    if (_434 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    _431 = 0;
    int64_t _435 = 0; // k
    int64_t _436 = 0; // j
    _jump498:; // Begin body of loop
    int64_t _437;
    // Computing bound for l
    if (_154.d0 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing bound for m
    if (c.d1 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    // Computing bound for n
    if (_154.d0 > 0) 
    goto _jump501;
    fail_assertion("non-positive loop bound");
    _jump501:;
    _437 = 0;
    int64_t _438 = 0; // n
    int64_t _439 = 0; // m
    int64_t _440 = 0; // l
    _jump502:; // Begin body of loop
    _437 += _154.d0;
    _438++;
    if (_438 < _154.d0)
    goto _jump502;
    _438 = 0;
    _439++;
    if (_439 < c.d1)
    goto _jump502;
    _439 = 0;
    _440++;
    if (_440 < _154.d0)
    goto _jump502;
    // End body of loop
    int64_t _441 = -_437;
    _431 += _441;
    _435++;
    if (_435 < _434)
    goto _jump498;
    _435 = 0;
    _436++;
    if (_436 < _154.d0)
    goto _jump498;
    // End body of loop
    _430.d1 = _431;
    if (_431 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing total size of heap memory to allocate
    int64_t _442 = 1;
    _442 *= c.d0;
    _442 *= _431;
    _442 *= sizeof(int64_t);
    _430.data = jpl_alloc(_442);
    int64_t _443 = 0; // k
    int64_t _444 = 0; // j
    _jump504:; // Begin body of loop
    int64_t _445 = 707;
    int64_t _446 = _445 / c.d0;
    int64_t _447 = _446 / _154.d0;
    int64_t _448 = 0;
    _448 *= _430.d0;
    _448 += _444;
    _448 *= _430.d1;
    _448 += _443;
    _430.data[_448] = _447;
    _443++;
    if (_443 < _431)
    goto _jump504;
    _443 = 0;
    _444++;
    if (_444 < c.d0)
    goto _jump504;
    // End body of loop
    int64_t _449;
    // Computing bound for j
    bool _450 = true;
    bool _451 = !_450;
    bool _452 = a != _451;
    int64_t _453;
    if (!_452)
    goto _jump505;
    int64_t _454 = 852;
    _453 = _454;
    goto _jump506;
    _jump505:;
    int64_t _455;
    // Computing bound for j
    if (_154.d0 >= 0)
    goto _jump507;
    fail_assertion("negative array index");
    _jump507:;
    if (_154.d0 < _154.d0)
    goto _jump508;
    fail_assertion("index too large");
    _jump508:;
    int64_t _456 = 0;
    _456 *= _154.d0;
    _456 += _154.d0;
    int64_t _457 = _154.data[_456];
    if (_457 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    _455 = 0;
    int64_t _458 = 0; // j
    _jump510:; // Begin body of loop
    int64_t _459;
    // Computing bound for k
    if (_458 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    _459 = 0;
    int64_t _460 = 0; // k
    _jump512:; // Begin body of loop
    _459 += _154.d0;
    _460++;
    if (_460 < _458)
    goto _jump512;
    // End body of loop
    _455 += _459;
    _458++;
    if (_458 < _457)
    goto _jump510;
    // End body of loop
    _453 = _455;
    _jump506:;
    if (_453 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump515;
    fail_assertion("non-positive loop bound");
    _jump515:;
    _449 = 0;
    int64_t _461 = 0; // l
    int64_t _462 = 0; // k
    int64_t _463 = 0; // j
    _jump516:; // Begin body of loop
    _449 += _462;
    _461++;
    if (_461 < c.d0)
    goto _jump516;
    _461 = 0;
    _462++;
    if (_462 < c.d0)
    goto _jump516;
    _462 = 0;
    _463++;
    if (_463 < _453)
    goto _jump516;
    // End body of loop
    int64_t _464 = 536;
    int64_t _465 = -_464;
    if (_449 >= 0)
    goto _jump517;
    fail_assertion("negative array index");
    _jump517:;
    if (_449 < _430.d0)
    goto _jump518;
    fail_assertion("index too large");
    _jump518:;
    if (_465 >= 0)
    goto _jump519;
    fail_assertion("negative array index");
    _jump519:;
    if (_465 < _430.d1)
    goto _jump520;
    fail_assertion("index too large");
    _jump520:;
    int64_t _466 = 0;
    _466 *= _430.d0;
    _466 += _449;
    _466 *= _430.d1;
    _466 += _465;
    int64_t _467 = _430.data[_466];
    bool _468 = _357 > _467;
    bool _356 = _468;
    if (0 == _468)
    goto _jump521;
    int64_t _469 = c.d0 % c.d0;
    bool _470 = c.d0 > _469;
    bool _471;
    if (!_470)
    goto _jump522;
    bool _472;
    if (!a)
    goto _jump523;
    bool _474 = false;
    _a1_bool _475;
    _475.d0 = 1;
    _475.data = jpl_alloc(sizeof(bool) * 1);
    _475.data[0] = _474;
    if (_154.d0 >= 0)
    goto _jump524;
    fail_assertion("negative array index");
    _jump524:;
    if (_154.d0 < _475.d0)
    goto _jump525;
    fail_assertion("index too large");
    _jump525:;
    int64_t _476 = 0;
    _476 *= _475.d0;
    _476 += _154.d0;
    bool _477 = _475.data[_476];
    bool _478 = _87 == _477;
    bool _473 = _478;
    if (0 == _478)
    goto _jump526;
    _473 = a;
    _jump526:;
    _472 = _473;
    goto _jump527;
    _jump523:;
    _472 = _87;
    _jump527:;
    _471 = _472;
    goto _jump528;
    _jump522:;
    _a1__a2_double _479;
    // Computing bound for j
    int64_t _480 = 164;
    _479.d0 = _480;
    if (_480 > 0) 
    goto _jump529;
    fail_assertion("non-positive loop bound");
    _jump529:;
    // Computing total size of heap memory to allocate
    int64_t _481 = 1;
    _481 *= _480;
    _481 *= sizeof(_a2_double);
    _479.data = jpl_alloc(_481);
    int64_t _482 = 0; // j
    _jump530:; // Begin body of loop
    int64_t _483 = 0;
    _483 *= _479.d0;
    _483 += _482;
    _479.data[_483] = c;
    _482++;
    if (_482 < _480)
    goto _jump530;
    // End body of loop
    if (_154.d0 >= 0)
    goto _jump531;
    fail_assertion("negative array index");
    _jump531:;
    if (_154.d0 < _479.d0)
    goto _jump532;
    fail_assertion("index too large");
    _jump532:;
    int64_t _484 = 0;
    _484 *= _479.d0;
    _484 += _154.d0;
    _a2_double _485 = _479.data[_484];
    int64_t _486 = b(_485);
    int64_t _487 = -_486;
    bool _488 = c.d1 > _487;
    _471 = _488;
    _jump528:;
    _356 = _471;
    _jump521:;
    if (0 != _356)
    goto _jump533;
    fail_assertion("j");
    _jump533:;
    return _154.d0;
}

double j(_a2_double k, rgba n, void_t o) {
    if (0 != a)
    goto _jump888;
    fail_assertion("p");
    _jump888:;
    _a2__a2_double _0;
    // Computing bound for p
    _0.d0 = g;
    if (g > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing bound for q
    bool _1 = a == a;
    bool _2 = !_1;
    int64_t _3;
    if (!_2)
    goto _jump890;
    _a2_bool _4;
    // Computing bound for p
    _4.d0 = g;
    if (g > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing bound for q
    _4.d1 = d;
    if (d > 0) 
    goto _jump892;
    fail_assertion("non-positive loop bound");
    _jump892:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= g;
    _5 *= d;
    _5 *= sizeof(bool);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // q
    int64_t _7 = 0; // p
    _jump893:; // Begin body of loop
    bool _8 = false;
    bool _9 = !_8;
    int64_t _10 = 0;
    _10 *= _4.d0;
    _10 += _7;
    _10 *= _4.d1;
    _10 += _6;
    _4.data[_10] = _9;
    _6++;
    if (_6 < d)
    goto _jump893;
    _6 = 0;
    _7++;
    if (_7 < g)
    goto _jump893;
    // End body of loop
    if (k.d0 >= 0)
    goto _jump894;
    fail_assertion("negative array index");
    _jump894:;
    if (k.d0 < _4.d0)
    goto _jump895;
    fail_assertion("index too large");
    _jump895:;
    if (i >= 0)
    goto _jump896;
    fail_assertion("negative array index");
    _jump896:;
    if (i < _4.d1)
    goto _jump897;
    fail_assertion("index too large");
    _jump897:;
    int64_t _11 = 0;
    _11 *= _4.d0;
    _11 += k.d0;
    _11 *= _4.d1;
    _11 += i;
    bool _12 = _4.data[_11];
    int64_t _13;
    if (!_12)
    goto _jump898;
    _a1_int64_t _14;
    // Computing bound for p
    int64_t _15 = -f;
    _14.d0 = _15;
    if (_15 > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _15;
    _16 *= sizeof(int64_t);
    _14.data = jpl_alloc(_16);
    int64_t _17 = 0; // p
    _jump900:; // Begin body of loop
    int64_t _18 = 0;
    _18 *= _14.d0;
    _18 += _17;
    _14.data[_18] = e;
    _17++;
    if (_17 < _15)
    goto _jump900;
    // End body of loop
    _a1_int64_t _19;
    // Computing bound for p
    _19.d0 = g;
    if (g > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= g;
    _20 *= sizeof(int64_t);
    _19.data = jpl_alloc(_20);
    int64_t _21 = 0; // p
    _jump902:; // Begin body of loop
    int64_t _22 = 0;
    _22 *= _19.d0;
    _22 += _21;
    _19.data[_22] = f;
    _21++;
    if (_21 < g)
    goto _jump902;
    // End body of loop
    if (d >= 0)
    goto _jump903;
    fail_assertion("negative array index");
    _jump903:;
    if (d < _19.d0)
    goto _jump904;
    fail_assertion("index too large");
    _jump904:;
    int64_t _23 = 0;
    _23 *= _19.d0;
    _23 += d;
    int64_t _24 = _19.data[_23];
    if (_24 >= 0)
    goto _jump905;
    fail_assertion("negative array index");
    _jump905:;
    if (_24 < _14.d0)
    goto _jump906;
    fail_assertion("index too large");
    _jump906:;
    int64_t _25 = 0;
    _25 *= _14.d0;
    _25 += _24;
    int64_t _26 = _14.data[_25];
    _13 = _26;
    goto _jump907;
    _jump898:;
    _13 = e;
    _jump907:;
    _3 = _13;
    goto _jump908;
    _jump890:;
    _3 = f;
    _jump908:;
    int64_t _27 = -_3;
    _0.d1 = _27;
    if (_27 > 0) 
    goto _jump909;
    fail_assertion("non-positive loop bound");
    _jump909:;
    // Computing total size of heap memory to allocate
    int64_t _28 = 1;
    _28 *= g;
    _28 *= _27;
    _28 *= sizeof(_a2_double);
    _0.data = jpl_alloc(_28);
    int64_t _29 = 0; // q
    int64_t _30 = 0; // p
    _jump910:; // Begin body of loop
    int64_t _31 = 0;
    _31 *= _0.d0;
    _31 += _30;
    _31 *= _0.d1;
    _31 += _29;
    _0.data[_31] = k;
    _29++;
    if (_29 < _27)
    goto _jump910;
    _29 = 0;
    _30++;
    if (_30 < g)
    goto _jump910;
    // End body of loop
    _a1_bool _32;
    // Computing bound for s
    _a2_int64_t _33;
    // Computing bound for s
    _33.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing bound for t
    int64_t _34;
    // Computing bound for s
    if (k.d0 > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    _34 = 0;
    int64_t _35 = 0; // s
    _jump913:; // Begin body of loop
    _34 += _0.d0;
    _35++;
    if (_35 < k.d0)
    goto _jump913;
    // End body of loop
    _33.d1 = _34;
    if (_34 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _0.d1;
    _36 *= _34;
    _36 *= sizeof(int64_t);
    _33.data = jpl_alloc(_36);
    int64_t _37 = 0; // t
    int64_t _38 = 0; // s
    _jump915:; // Begin body of loop
    int64_t _39 = 0;
    _39 *= _33.d0;
    _39 += _38;
    _39 *= _33.d1;
    _39 += _37;
    _33.data[_39] = d;
    _37++;
    if (_37 < _34)
    goto _jump915;
    _37 = 0;
    _38++;
    if (_38 < _0.d1)
    goto _jump915;
    // End body of loop
    if (g >= 0)
    goto _jump916;
    fail_assertion("negative array index");
    _jump916:;
    if (g < _33.d0)
    goto _jump917;
    fail_assertion("index too large");
    _jump917:;
    if (_0.d0 >= 0)
    goto _jump918;
    fail_assertion("negative array index");
    _jump918:;
    if (_0.d0 < _33.d1)
    goto _jump919;
    fail_assertion("index too large");
    _jump919:;
    int64_t _40 = 0;
    _40 *= _33.d0;
    _40 += g;
    _40 *= _33.d1;
    _40 += _0.d0;
    int64_t _41 = _33.data[_40];
    _32.d0 = _41;
    if (_41 > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= _41;
    _42 *= sizeof(bool);
    _32.data = jpl_alloc(_42);
    int64_t _43 = 0; // s
    _jump921:; // Begin body of loop
    bool _45 = false;
    bool _44 = _45;
    if (0 == _45)
    goto _jump922;
    int64_t _46 = 168;
    bool _47 = _43 <= _46;
    _44 = _47;
    _jump922:;
    bool _48;
    if (!_44)
    goto _jump923;
    _a3_bool _49;
    // Computing bound for t
    _49.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump924;
    fail_assertion("non-positive loop bound");
    _jump924:;
    // Computing bound for u
    _49.d1 = e;
    if (e > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for v
    _49.d2 = f;
    if (f > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= k.d1;
    _50 *= e;
    _50 *= f;
    _50 *= sizeof(bool);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // v
    int64_t _52 = 0; // u
    int64_t _53 = 0; // t
    _jump927:; // Begin body of loop
    int64_t _54 = 0;
    _54 *= _49.d0;
    _54 += _53;
    _54 *= _49.d1;
    _54 += _52;
    _54 *= _49.d2;
    _54 += _51;
    _49.data[_54] = a;
    _51++;
    if (_51 < f)
    goto _jump927;
    _51 = 0;
    _52++;
    if (_52 < e)
    goto _jump927;
    _52 = 0;
    _53++;
    if (_53 < k.d1)
    goto _jump927;
    // End body of loop
    int64_t _55 = -i;
    if (d >= 0)
    goto _jump928;
    fail_assertion("negative array index");
    _jump928:;
    if (d < _49.d0)
    goto _jump929;
    fail_assertion("index too large");
    _jump929:;
    if (_55 >= 0)
    goto _jump930;
    fail_assertion("negative array index");
    _jump930:;
    if (_55 < _49.d1)
    goto _jump931;
    fail_assertion("index too large");
    _jump931:;
    if (e >= 0)
    goto _jump932;
    fail_assertion("negative array index");
    _jump932:;
    if (e < _49.d2)
    goto _jump933;
    fail_assertion("index too large");
    _jump933:;
    int64_t _56 = 0;
    _56 *= _49.d0;
    _56 += d;
    _56 *= _49.d1;
    _56 += _55;
    _56 *= _49.d2;
    _56 += e;
    bool _57 = _49.data[_56];
    _48 = _57;
    goto _jump934;
    _jump923:;
    _a1_bool _58;
    // Computing bound for t
    _58.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _59 = 1;
    _59 *= k.d1;
    _59 *= sizeof(bool);
    _58.data = jpl_alloc(_59);
    int64_t _60 = 0; // t
    _jump936:; // Begin body of loop
    int64_t _61 = 0;
    _61 *= _58.d0;
    _61 += _60;
    _58.data[_61] = a;
    _60++;
    if (_60 < k.d1)
    goto _jump936;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump937;
    fail_assertion("negative array index");
    _jump937:;
    if (_0.d1 < _58.d0)
    goto _jump938;
    fail_assertion("index too large");
    _jump938:;
    int64_t _62 = 0;
    _62 *= _58.d0;
    _62 += _0.d1;
    bool _63 = _58.data[_62];
    _48 = _63;
    _jump934:;
    int64_t _64 = 0;
    _64 *= _32.d0;
    _64 += _43;
    _32.data[_64] = _48;
    _43++;
    if (_43 < _41)
    goto _jump921;
    // End body of loop
    int64_t _65 = 114;
    if (_65 >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (_65 < _32.d0)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    int64_t _66 = 0;
    _66 *= _32.d0;
    _66 += _65;
    bool _67 = _32.data[_66];
    _a1__a1_bool _68;
    if (!_67)
    goto _jump941;
    _a3__a1__a1_bool _69;
    // Computing bound for s
    _69.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing bound for t
    _69.d1 = f;
    if (f > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    // Computing bound for u
    int64_t _70;
    // Computing bound for s
    if (_0.d1 > 0) 
    goto _jump944;
    fail_assertion("non-positive loop bound");
    _jump944:;
    // Computing bound for t
    int64_t _71 = b(k);
    if (_71 > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    // Computing bound for u
    if (g > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    _70 = 0;
    int64_t _72 = 0; // u
    int64_t _73 = 0; // t
    int64_t _74 = 0; // s
    _jump947:; // Begin body of loop
    _70 += e;
    _72++;
    if (_72 < g)
    goto _jump947;
    _72 = 0;
    _73++;
    if (_73 < _71)
    goto _jump947;
    _73 = 0;
    _74++;
    if (_74 < _0.d1)
    goto _jump947;
    // End body of loop
    int64_t _75 = -_70;
    _69.d2 = _75;
    if (_75 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _0.d1;
    _76 *= f;
    _76 *= _75;
    _76 *= sizeof(_a1__a1_bool);
    _69.data = jpl_alloc(_76);
    int64_t _77 = 0; // u
    int64_t _78 = 0; // t
    int64_t _79 = 0; // s
    _jump949:; // Begin body of loop
    _a1__a1_bool _80;
    // Computing bound for v
    _80.d0 = g;
    if (g > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= g;
    _81 *= sizeof(_a1_bool);
    _80.data = jpl_alloc(_81);
    int64_t _82 = 0; // v
    _jump951:; // Begin body of loop
    bool _84 = true;
    bool _83 = _84;
    if (0 != _84)
    goto _jump952;
    _83 = a;
    _jump952:;
    _a1_bool _85;
    _85.d0 = 1;
    _85.data = jpl_alloc(sizeof(bool) * 1);
    _85.data[0] = _83;
    int64_t _86 = 0;
    _86 *= _80.d0;
    _86 += _82;
    _80.data[_86] = _85;
    _82++;
    if (_82 < g)
    goto _jump951;
    // End body of loop
    int64_t _87 = 0;
    _87 *= _69.d0;
    _87 += _79;
    _87 *= _69.d1;
    _87 += _78;
    _87 *= _69.d2;
    _87 += _77;
    _69.data[_87] = _80;
    _77++;
    if (_77 < _75)
    goto _jump949;
    _77 = 0;
    _78++;
    if (_78 < f)
    goto _jump949;
    _78 = 0;
    _79++;
    if (_79 < _0.d1)
    goto _jump949;
    // End body of loop
    int64_t _88 = 583;
    if (d >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (d < _69.d0)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    if (g >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (g < _69.d1)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    if (_88 >= 0)
    goto _jump957;
    fail_assertion("negative array index");
    _jump957:;
    if (_88 < _69.d2)
    goto _jump958;
    fail_assertion("index too large");
    _jump958:;
    int64_t _89 = 0;
    _89 *= _69.d0;
    _89 += d;
    _89 *= _69.d1;
    _89 += g;
    _89 *= _69.d2;
    _89 += _88;
    _a1__a1_bool _90 = _69.data[_89];
    _68 = _90;
    goto _jump959;
    _jump941:;
    _a3__a1_bool _91;
    // Computing bound for s
    _91.d0 = d;
    if (d > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for t
    int64_t _92 = -d;
    _91.d1 = _92;
    if (_92 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for u
    _91.d2 = k.d0;
    if (k.d0 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= d;
    _93 *= _92;
    _93 *= k.d0;
    _93 *= sizeof(_a1_bool);
    _91.data = jpl_alloc(_93);
    int64_t _94 = 0; // u
    int64_t _95 = 0; // t
    int64_t _96 = 0; // s
    _jump963:; // Begin body of loop
    bool _97 = _94 == _95;
    _a1_bool _98;
    if (!_97)
    goto _jump964;
    _a1_bool _99;
    // Computing bound for v
    _99.d0 = g;
    if (g > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= g;
    _100 *= sizeof(bool);
    _99.data = jpl_alloc(_100);
    int64_t _101 = 0; // v
    _jump966:; // Begin body of loop
    int64_t _102 = 0;
    _102 *= _99.d0;
    _102 += _101;
    _99.data[_102] = a;
    _101++;
    if (_101 < g)
    goto _jump966;
    // End body of loop
    _98 = _99;
    goto _jump967;
    _jump964:;
    _a1_bool _103;
    // Computing bound for v
    _103.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump968;
    fail_assertion("non-positive loop bound");
    _jump968:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= _0.d0;
    _104 *= sizeof(bool);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // v
    _jump969:; // Begin body of loop
    bool _106 = false;
    int64_t _107 = 0;
    _107 *= _103.d0;
    _107 += _105;
    _103.data[_107] = _106;
    _105++;
    if (_105 < _0.d0)
    goto _jump969;
    // End body of loop
    _98 = _103;
    _jump967:;
    int64_t _108 = 0;
    _108 *= _91.d0;
    _108 += _96;
    _108 *= _91.d1;
    _108 += _95;
    _108 *= _91.d2;
    _108 += _94;
    _91.data[_108] = _98;
    _94++;
    if (_94 < k.d0)
    goto _jump963;
    _94 = 0;
    _95++;
    if (_95 < _92)
    goto _jump963;
    _95 = 0;
    _96++;
    if (_96 < d)
    goto _jump963;
    // End body of loop
    if (f >= 0)
    goto _jump970;
    fail_assertion("negative array index");
    _jump970:;
    if (f < _91.d0)
    goto _jump971;
    fail_assertion("index too large");
    _jump971:;
    if (e >= 0)
    goto _jump972;
    fail_assertion("negative array index");
    _jump972:;
    if (e < _91.d1)
    goto _jump973;
    fail_assertion("index too large");
    _jump973:;
    if (_0.d0 >= 0)
    goto _jump974;
    fail_assertion("negative array index");
    _jump974:;
    if (_0.d0 < _91.d2)
    goto _jump975;
    fail_assertion("index too large");
    _jump975:;
    int64_t _109 = 0;
    _109 *= _91.d0;
    _109 += f;
    _109 *= _91.d1;
    _109 += e;
    _109 *= _91.d2;
    _109 += _0.d0;
    _a1_bool _110 = _91.data[_109];
    _a1__a1_bool _111;
    _111.d0 = 1;
    _111.data = jpl_alloc(sizeof(_a1_bool) * 1);
    _111.data[0] = _110;
    _68 = _111;
    _jump959:;
    bool _112 = k.d0 == g;
    _a3_int64_t _113;
    if (!_112)
    goto _jump976;
    _a3_int64_t _114;
    // Computing bound for s
    _114.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing bound for t
    _114.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for u
    _114.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _0.d1;
    _115 *= _0.d0;
    _115 *= _0.d1;
    _115 *= sizeof(int64_t);
    _114.data = jpl_alloc(_115);
    int64_t _116 = 0; // u
    int64_t _117 = 0; // t
    int64_t _118 = 0; // s
    _jump980:; // Begin body of loop
    int64_t _119 = 0;
    _119 *= _114.d0;
    _119 += _118;
    _119 *= _114.d1;
    _119 += _117;
    _119 *= _114.d2;
    _119 += _116;
    _114.data[_119] = _116;
    _116++;
    if (_116 < _0.d1)
    goto _jump980;
    _116 = 0;
    _117++;
    if (_117 < _0.d0)
    goto _jump980;
    _117 = 0;
    _118++;
    if (_118 < _0.d1)
    goto _jump980;
    // End body of loop
    _113 = _114;
    goto _jump981;
    _jump976:;
    _a1__a3_int64_t _120;
    // Computing bound for s
    _120.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump982;
    fail_assertion("non-positive loop bound");
    _jump982:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= _0.d0;
    _121 *= sizeof(_a3_int64_t);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // s
    _jump983:; // Begin body of loop
    bool _124 = false;
    bool _123 = _124;
    if (0 != _124)
    goto _jump984;
    _123 = a;
    _jump984:;
    _a3_int64_t _125;
    if (!_123)
    goto _jump985;
    _a3_int64_t _126;
    // Computing bound for t
    _126.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump986;
    fail_assertion("non-positive loop bound");
    _jump986:;
    // Computing bound for u
    _126.d1 = g;
    if (g > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing bound for v
    _126.d2 = _122;
    if (_122 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= _0.d0;
    _127 *= g;
    _127 *= _122;
    _127 *= sizeof(int64_t);
    _126.data = jpl_alloc(_127);
    int64_t _128 = 0; // v
    int64_t _129 = 0; // u
    int64_t _130 = 0; // t
    _jump989:; // Begin body of loop
    int64_t _131 = 0;
    _131 *= _126.d0;
    _131 += _130;
    _131 *= _126.d1;
    _131 += _129;
    _131 *= _126.d2;
    _131 += _128;
    _126.data[_131] = _129;
    _128++;
    if (_128 < _122)
    goto _jump989;
    _128 = 0;
    _129++;
    if (_129 < g)
    goto _jump989;
    _129 = 0;
    _130++;
    if (_130 < _0.d0)
    goto _jump989;
    // End body of loop
    _125 = _126;
    goto _jump990;
    _jump985:;
    _a3_int64_t _132;
    // Computing bound for t
    _132.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump991;
    fail_assertion("non-positive loop bound");
    _jump991:;
    // Computing bound for u
    int64_t _133 = 819;
    _132.d1 = _133;
    if (_133 > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    // Computing bound for v
    _132.d2 = k.d0;
    if (k.d0 > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= k.d1;
    _134 *= _133;
    _134 *= k.d0;
    _134 *= sizeof(int64_t);
    _132.data = jpl_alloc(_134);
    int64_t _135 = 0; // v
    int64_t _136 = 0; // u
    int64_t _137 = 0; // t
    _jump994:; // Begin body of loop
    int64_t _138 = 0;
    _138 *= _132.d0;
    _138 += _137;
    _138 *= _132.d1;
    _138 += _136;
    _138 *= _132.d2;
    _138 += _135;
    _132.data[_138] = _136;
    _135++;
    if (_135 < k.d0)
    goto _jump994;
    _135 = 0;
    _136++;
    if (_136 < _133)
    goto _jump994;
    _136 = 0;
    _137++;
    if (_137 < k.d1)
    goto _jump994;
    // End body of loop
    _125 = _132;
    _jump990:;
    int64_t _139 = 0;
    _139 *= _120.d0;
    _139 += _122;
    _120.data[_139] = _125;
    _122++;
    if (_122 < _0.d0)
    goto _jump983;
    // End body of loop
    int64_t _140;
    // Computing bound for s
    if (d > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for t
    if (_0.d1 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing bound for u
    if (k.d1 > 0) 
    goto _jump997;
    fail_assertion("non-positive loop bound");
    _jump997:;
    _140 = 0;
    int64_t _141 = 0; // u
    int64_t _142 = 0; // t
    int64_t _143 = 0; // s
    _jump998:; // Begin body of loop
    int64_t _144 = b(k);
    _140 += _144;
    _141++;
    if (_141 < k.d1)
    goto _jump998;
    _141 = 0;
    _142++;
    if (_142 < _0.d1)
    goto _jump998;
    _142 = 0;
    _143++;
    if (_143 < d)
    goto _jump998;
    // End body of loop
    if (_140 >= 0)
    goto _jump999;
    fail_assertion("negative array index");
    _jump999:;
    if (_140 < _120.d0)
    goto _jump1000;
    fail_assertion("index too large");
    _jump1000:;
    int64_t _145 = 0;
    _145 *= _120.d0;
    _145 += _140;
    _a3_int64_t _146 = _120.data[_145];
    _113 = _146;
    _jump981:;
    bool _148;
    if (!a)
    goto _jump1001;
    _148 = h;
    goto _jump1002;
    _jump1001:;
    _148 = h;
    _jump1002:;
    bool _147 = _148;
    if (0 != _148)
    goto _jump1003;
    bool _149;
    if (!a)
    goto _jump1004;
    bool _150 = true;
    _149 = _150;
    goto _jump1005;
    _jump1004:;
    bool _151 = true;
    _149 = _151;
    _jump1005:;
    _147 = _149;
    _jump1003:;
    bool _153 = true;
    bool _152 = _153;
    if (0 == _153)
    goto _jump1006;
    _152 = h;
    _jump1006:;
    bool _154 = false;
    bool _155 = _152 == _154;
    bool _156 = _147 != _155;
    _a2_double _157;
    if (!_156)
    goto _jump1007;
    _a3__a2_double _158;
    // Computing bound for s
    int64_t _159 = _0.d0 / i;
    _158.d0 = _159;
    if (_159 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for t
    int64_t _160 = g - f;
    _158.d1 = _160;
    if (_160 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing bound for u
    _158.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing total size of heap memory to allocate
    int64_t _161 = 1;
    _161 *= _159;
    _161 *= _160;
    _161 *= _0.d1;
    _161 *= sizeof(_a2_double);
    _158.data = jpl_alloc(_161);
    int64_t _162 = 0; // u
    int64_t _163 = 0; // t
    int64_t _164 = 0; // s
    _jump1011:; // Begin body of loop
    _a2_double _165;
    if (!h)
    goto _jump1012;
    _165 = k;
    goto _jump1013;
    _jump1012:;
    _165 = k;
    _jump1013:;
    int64_t _166 = 0;
    _166 *= _158.d0;
    _166 += _164;
    _166 *= _158.d1;
    _166 += _163;
    _166 *= _158.d2;
    _166 += _162;
    _158.data[_166] = _165;
    _162++;
    if (_162 < _0.d1)
    goto _jump1011;
    _162 = 0;
    _163++;
    if (_163 < _160)
    goto _jump1011;
    _163 = 0;
    _164++;
    if (_164 < _159)
    goto _jump1011;
    // End body of loop
    int64_t _167 = 716;
    if (i >= 0)
    goto _jump1014;
    fail_assertion("negative array index");
    _jump1014:;
    if (i < _158.d0)
    goto _jump1015;
    fail_assertion("index too large");
    _jump1015:;
    if (_167 >= 0)
    goto _jump1016;
    fail_assertion("negative array index");
    _jump1016:;
    if (_167 < _158.d1)
    goto _jump1017;
    fail_assertion("index too large");
    _jump1017:;
    if (_0.d0 >= 0)
    goto _jump1018;
    fail_assertion("negative array index");
    _jump1018:;
    if (_0.d0 < _158.d2)
    goto _jump1019;
    fail_assertion("index too large");
    _jump1019:;
    int64_t _168 = 0;
    _168 *= _158.d0;
    _168 += i;
    _168 *= _158.d1;
    _168 += _167;
    _168 *= _158.d2;
    _168 += _0.d0;
    _a2_double _169 = _158.data[_168];
    _157 = _169;
    goto _jump1020;
    _jump1007:;
    bool _171 = _0.d1 <= k.d0;
    bool _170 = _171;
    if (0 == _171)
    goto _jump1021;
    bool _172;
    if (!a)
    goto _jump1022;
    _172 = h;
    goto _jump1023;
    _jump1022:;
    bool _173 = false;
    _172 = _173;
    _jump1023:;
    _170 = _172;
    _jump1021:;
    _a2_double _174;
    if (!_170)
    goto _jump1024;
    _a2_double _175;
    if (!h)
    goto _jump1025;
    _a2_double _176;
    // Computing bound for s
    _176.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump1026;
    fail_assertion("non-positive loop bound");
    _jump1026:;
    // Computing bound for t
    _176.d1 = d;
    if (d > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= k.d1;
    _177 *= d;
    _177 *= sizeof(double);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // t
    int64_t _179 = 0; // s
    _jump1028:; // Begin body of loop
    double _180 = 46.0;
    int64_t _181 = 0;
    _181 *= _176.d0;
    _181 += _179;
    _181 *= _176.d1;
    _181 += _178;
    _176.data[_181] = _180;
    _178++;
    if (_178 < d)
    goto _jump1028;
    _178 = 0;
    _179++;
    if (_179 < k.d1)
    goto _jump1028;
    // End body of loop
    _175 = _176;
    goto _jump1029;
    _jump1025:;
    _175 = k;
    _jump1029:;
    _174 = _175;
    goto _jump1030;
    _jump1024:;
    _174 = k;
    _jump1030:;
    _157 = _174;
    _jump1020:;
    int64_t _182 = b(_157);
    bool _184 = false;
    bool _183 = _184;
    if (0 == _184)
    goto _jump1031;
    int64_t _185 = 917;
    bool _186 = k.d1 != _185;
    _183 = _186;
    _jump1031:;
    _a2__a2_double _187;
    if (!_183)
    goto _jump1032;
    _187 = _0;
    goto _jump1033;
    _jump1032:;
    bool _188 = true;
    _a2__a2_double _189;
    if (!_188)
    goto _jump1034;
    _a2__a2_double _190;
    // Computing bound for s
    _190.d0 = e;
    if (e > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    // Computing bound for t
    _190.d1 = i;
    if (i > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    // Computing total size of heap memory to allocate
    int64_t _191 = 1;
    _191 *= e;
    _191 *= i;
    _191 *= sizeof(_a2_double);
    _190.data = jpl_alloc(_191);
    int64_t _192 = 0; // t
    int64_t _193 = 0; // s
    _jump1037:; // Begin body of loop
    int64_t _194 = 0;
    _194 *= _190.d0;
    _194 += _193;
    _194 *= _190.d1;
    _194 += _192;
    _190.data[_194] = k;
    _192++;
    if (_192 < i)
    goto _jump1037;
    _192 = 0;
    _193++;
    if (_193 < e)
    goto _jump1037;
    // End body of loop
    _189 = _190;
    goto _jump1038;
    _jump1034:;
    bool _195 = false;
    _a2__a2_double _196;
    if (!_195)
    goto _jump1039;
    _196 = _0;
    goto _jump1040;
    _jump1039:;
    _196 = _0;
    _jump1040:;
    _189 = _196;
    _jump1038:;
    _187 = _189;
    _jump1033:;
    int64_t _197 = b(k);
    if (k.d1 >= 0)
    goto _jump1041;
    fail_assertion("negative array index");
    _jump1041:;
    if (k.d1 < _187.d0)
    goto _jump1042;
    fail_assertion("index too large");
    _jump1042:;
    if (_197 >= 0)
    goto _jump1043;
    fail_assertion("negative array index");
    _jump1043:;
    if (_197 < _187.d1)
    goto _jump1044;
    fail_assertion("index too large");
    _jump1044:;
    int64_t _198 = 0;
    _198 *= _187.d0;
    _198 += k.d1;
    _198 *= _187.d1;
    _198 += _197;
    _a2_double _199 = _187.data[_198];
    int64_t _200 = b(_199);
    if (_182 >= 0)
    goto _jump1045;
    fail_assertion("negative array index");
    _jump1045:;
    if (_182 < _113.d0)
    goto _jump1046;
    fail_assertion("index too large");
    _jump1046:;
    if (_200 >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (_200 < _113.d1)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    if (g >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (g < _113.d2)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    int64_t _201 = 0;
    _201 *= _113.d0;
    _201 += _182;
    _201 *= _113.d1;
    _201 += _200;
    _201 *= _113.d2;
    _201 += g;
    int64_t _202 = _113.data[_201];
    if (_202 >= 0)
    goto _jump1051;
    fail_assertion("negative array index");
    _jump1051:;
    if (_202 < _68.d0)
    goto _jump1052;
    fail_assertion("index too large");
    _jump1052:;
    int64_t _203 = 0;
    _203 *= _68.d0;
    _203 += _202;
    _a1_bool _204 = _68.data[_203];
    _a2_bool _205;
    if (!h)
    goto _jump1053;
    _a2_bool _206;
    // Computing bound for u
    _206.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing bound for v
    int64_t _207 = b(k);
    _206.d1 = _207;
    if (_207 > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    // Computing total size of heap memory to allocate
    int64_t _208 = 1;
    _208 *= _0.d1;
    _208 *= _207;
    _208 *= sizeof(bool);
    _206.data = jpl_alloc(_208);
    int64_t _209 = 0; // v
    int64_t _210 = 0; // u
    _jump1056:; // Begin body of loop
    int64_t _211 = 0;
    _211 *= _206.d0;
    _211 += _210;
    _211 *= _206.d1;
    _211 += _209;
    _206.data[_211] = h;
    _209++;
    if (_209 < _207)
    goto _jump1056;
    _209 = 0;
    _210++;
    if (_210 < _0.d1)
    goto _jump1056;
    // End body of loop
    _205 = _206;
    goto _jump1057;
    _jump1053:;
    bool _212 = false;
    bool _213 = h == _212;
    _a2_bool _214;
    if (!_213)
    goto _jump1058;
    _a2__a2_bool _215;
    // Computing bound for u
    _215.d0 = _204.d0;
    if (_204.d0 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing bound for v
    int64_t _216 = _0.d0 / _0.d1;
    _215.d1 = _216;
    if (_216 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= _204.d0;
    _217 *= _216;
    _217 *= sizeof(_a2_bool);
    _215.data = jpl_alloc(_217);
    int64_t _218 = 0; // v
    int64_t _219 = 0; // u
    _jump1061:; // Begin body of loop
    _a2_bool _220;
    if (!h)
    goto _jump1062;
    _a2_bool _221;
    // Computing bound for w
    int64_t _222 = 913;
    _221.d0 = _222;
    if (_222 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for x
    _221.d1 = _219;
    if (_219 > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing total size of heap memory to allocate
    int64_t _223 = 1;
    _223 *= _222;
    _223 *= _219;
    _223 *= sizeof(bool);
    _221.data = jpl_alloc(_223);
    int64_t _224 = 0; // x
    int64_t _225 = 0; // w
    _jump1065:; // Begin body of loop
    double _226 = 66.0;
    double _227 = 94.0;
    bool _228 = _226 == _227;
    int64_t _229 = 0;
    _229 *= _221.d0;
    _229 += _225;
    _229 *= _221.d1;
    _229 += _224;
    _221.data[_229] = _228;
    _224++;
    if (_224 < _219)
    goto _jump1065;
    _224 = 0;
    _225++;
    if (_225 < _222)
    goto _jump1065;
    // End body of loop
    _220 = _221;
    goto _jump1066;
    _jump1062:;
    _a2_bool _230;
    // Computing bound for w
    _230.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump1067;
    fail_assertion("non-positive loop bound");
    _jump1067:;
    // Computing bound for x
    _230.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing total size of heap memory to allocate
    int64_t _231 = 1;
    _231 *= k.d1;
    _231 *= _0.d0;
    _231 *= sizeof(bool);
    _230.data = jpl_alloc(_231);
    int64_t _232 = 0; // x
    int64_t _233 = 0; // w
    _jump1069:; // Begin body of loop
    int64_t _234 = 0;
    _234 *= _230.d0;
    _234 += _233;
    _234 *= _230.d1;
    _234 += _232;
    _230.data[_234] = a;
    _232++;
    if (_232 < _0.d0)
    goto _jump1069;
    _232 = 0;
    _233++;
    if (_233 < k.d1)
    goto _jump1069;
    // End body of loop
    _220 = _230;
    _jump1066:;
    int64_t _235 = 0;
    _235 *= _215.d0;
    _235 += _219;
    _235 *= _215.d1;
    _235 += _218;
    _215.data[_235] = _220;
    _218++;
    if (_218 < _216)
    goto _jump1061;
    _218 = 0;
    _219++;
    if (_219 < _204.d0)
    goto _jump1061;
    // End body of loop
    if (i >= 0)
    goto _jump1070;
    fail_assertion("negative array index");
    _jump1070:;
    if (i < _215.d0)
    goto _jump1071;
    fail_assertion("index too large");
    _jump1071:;
    if (k.d0 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (k.d0 < _215.d1)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    int64_t _236 = 0;
    _236 *= _215.d0;
    _236 += i;
    _236 *= _215.d1;
    _236 += k.d0;
    _a2_bool _237 = _215.data[_236];
    _214 = _237;
    goto _jump1074;
    _jump1058:;
    bool _238 = !a;
    bool _239 = !_238;
    _a2_bool _240;
    if (!_239)
    goto _jump1075;
    _a2_bool _241;
    // Computing bound for u
    int64_t _242 = -_0.d0;
    int64_t _243 = 250;
    int64_t _244 = _242 + _243;
    _241.d0 = _244;
    if (_244 > 0) 
    goto _jump1076;
    fail_assertion("non-positive loop bound");
    _jump1076:;
    // Computing bound for v
    _a3_int64_t _245;
    // Computing bound for u
    int64_t _246 = -_0.d1;
    _245.d0 = _246;
    if (_246 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    // Computing bound for v
    int64_t _247 = d + g;
    _245.d1 = _247;
    if (_247 > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    // Computing bound for w
    _245.d2 = i;
    if (i > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= _246;
    _248 *= _247;
    _248 *= i;
    _248 *= sizeof(int64_t);
    _245.data = jpl_alloc(_248);
    int64_t _249 = 0; // w
    int64_t _250 = 0; // v
    int64_t _251 = 0; // u
    _jump1080:; // Begin body of loop
    int64_t _252 = 0;
    _252 *= _245.d0;
    _252 += _251;
    _252 *= _245.d1;
    _252 += _250;
    _252 *= _245.d2;
    _252 += _249;
    _245.data[_252] = _204.d0;
    _249++;
    if (_249 < i)
    goto _jump1080;
    _249 = 0;
    _250++;
    if (_250 < _247)
    goto _jump1080;
    _250 = 0;
    _251++;
    if (_251 < _246)
    goto _jump1080;
    // End body of loop
    if (k.d1 >= 0)
    goto _jump1081;
    fail_assertion("negative array index");
    _jump1081:;
    if (k.d1 < _245.d0)
    goto _jump1082;
    fail_assertion("index too large");
    _jump1082:;
    if (_0.d1 >= 0)
    goto _jump1083;
    fail_assertion("negative array index");
    _jump1083:;
    if (_0.d1 < _245.d1)
    goto _jump1084;
    fail_assertion("index too large");
    _jump1084:;
    if (d >= 0)
    goto _jump1085;
    fail_assertion("negative array index");
    _jump1085:;
    if (d < _245.d2)
    goto _jump1086;
    fail_assertion("index too large");
    _jump1086:;
    int64_t _253 = 0;
    _253 *= _245.d0;
    _253 += k.d1;
    _253 *= _245.d1;
    _253 += _0.d1;
    _253 *= _245.d2;
    _253 += d;
    int64_t _254 = _245.data[_253];
    _241.d1 = _254;
    if (_254 > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing total size of heap memory to allocate
    int64_t _255 = 1;
    _255 *= _244;
    _255 *= _254;
    _255 *= sizeof(bool);
    _241.data = jpl_alloc(_255);
    int64_t _256 = 0; // v
    int64_t _257 = 0; // u
    _jump1088:; // Begin body of loop
    int64_t _258 = 0;
    _258 *= _241.d0;
    _258 += _257;
    _258 *= _241.d1;
    _258 += _256;
    _241.data[_258] = h;
    _256++;
    if (_256 < _254)
    goto _jump1088;
    _256 = 0;
    _257++;
    if (_257 < _244)
    goto _jump1088;
    // End body of loop
    _240 = _241;
    goto _jump1089;
    _jump1075:;
    _a2_bool _259;
    // Computing bound for u
    int64_t _260;
    // Computing bound for u
    if (k.d0 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for v
    if (_0.d1 > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    _260 = 0;
    int64_t _261 = 0; // v
    int64_t _262 = 0; // u
    _jump1092:; // Begin body of loop
    _260 += g;
    _261++;
    if (_261 < _0.d1)
    goto _jump1092;
    _261 = 0;
    _262++;
    if (_262 < k.d0)
    goto _jump1092;
    // End body of loop
    _259.d0 = _260;
    if (_260 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing bound for v
    _259.d1 = d;
    if (d > 0) 
    goto _jump1094;
    fail_assertion("non-positive loop bound");
    _jump1094:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _260;
    _263 *= d;
    _263 *= sizeof(bool);
    _259.data = jpl_alloc(_263);
    int64_t _264 = 0; // v
    int64_t _265 = 0; // u
    _jump1095:; // Begin body of loop
    bool _266 = !a;
    int64_t _267 = 0;
    _267 *= _259.d0;
    _267 += _265;
    _267 *= _259.d1;
    _267 += _264;
    _259.data[_267] = _266;
    _264++;
    if (_264 < d)
    goto _jump1095;
    _264 = 0;
    _265++;
    if (_265 < _260)
    goto _jump1095;
    // End body of loop
    _240 = _259;
    _jump1089:;
    _214 = _240;
    _jump1074:;
    _205 = _214;
    _jump1057:;
    bool _269 = _204.d0 < _205.d0;
    bool _270 = !_269;
    bool _268 = _270;
    if (0 != _270)
    goto _jump1096;
    _268 = a;
    _jump1096:;
    _a3_double _271;
    if (!_268)
    goto _jump1097;
    _a1_bool _273;
    // Computing bound for x
    _273.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= k.d0;
    _274 *= sizeof(bool);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // x
    _jump1099:; // Begin body of loop
    bool _276 = false;
    int64_t _277 = 0;
    _277 *= _273.d0;
    _277 += _275;
    _273.data[_277] = _276;
    _275++;
    if (_275 < k.d0)
    goto _jump1099;
    // End body of loop
    bool _278 = true;
    int64_t _279;
    if (!_278)
    goto _jump1100;
    _279 = f;
    goto _jump1101;
    _jump1100:;
    _279 = _205.d1;
    _jump1101:;
    if (_279 >= 0)
    goto _jump1102;
    fail_assertion("negative array index");
    _jump1102:;
    if (_279 < _273.d0)
    goto _jump1103;
    fail_assertion("index too large");
    _jump1103:;
    int64_t _280 = 0;
    _280 *= _273.d0;
    _280 += _279;
    bool _281 = _273.data[_280];
    bool _272 = _281;
    if (0 != _281)
    goto _jump1104;
    int64_t _282;
    // Computing bound for x
    if (d > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing bound for y
    if (i > 0) 
    goto _jump1106;
    fail_assertion("non-positive loop bound");
    _jump1106:;
    // Computing bound for z
    if (_205.d0 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    _282 = 0;
    int64_t _283 = 0; // z
    int64_t _284 = 0; // y
    int64_t _285 = 0; // x
    _jump1108:; // Begin body of loop
    _282 += _0.d1;
    _283++;
    if (_283 < _205.d0)
    goto _jump1108;
    _283 = 0;
    _284++;
    if (_284 < i)
    goto _jump1108;
    _284 = 0;
    _285++;
    if (_285 < d)
    goto _jump1108;
    // End body of loop
    bool _286 = _0.d1 <= _282;
    _272 = _286;
    _jump1104:;
    _a3_double _287;
    if (!_272)
    goto _jump1109;
    _a3_double _288;
    // Computing bound for x
    _288.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for y
    _288.d1 = i;
    if (i > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for z
    int64_t _289 = 618;
    _288.d2 = _289;
    if (_289 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing total size of heap memory to allocate
    int64_t _290 = 1;
    _290 *= _0.d1;
    _290 *= i;
    _290 *= _289;
    _290 *= sizeof(double);
    _288.data = jpl_alloc(_290);
    int64_t _291 = 0; // z
    int64_t _292 = 0; // y
    int64_t _293 = 0; // x
    _jump1113:; // Begin body of loop
    if (i >= 0)
    goto _jump1114;
    fail_assertion("negative array index");
    _jump1114:;
    if (i < k.d0)
    goto _jump1115;
    fail_assertion("index too large");
    _jump1115:;
    if (f >= 0)
    goto _jump1116;
    fail_assertion("negative array index");
    _jump1116:;
    if (f < k.d1)
    goto _jump1117;
    fail_assertion("index too large");
    _jump1117:;
    int64_t _294 = 0;
    _294 *= k.d0;
    _294 += i;
    _294 *= k.d1;
    _294 += f;
    double _295 = k.data[_294];
    int64_t _296 = 0;
    _296 *= _288.d0;
    _296 += _293;
    _296 *= _288.d1;
    _296 += _292;
    _296 *= _288.d2;
    _296 += _291;
    _288.data[_296] = _295;
    _291++;
    if (_291 < _289)
    goto _jump1113;
    _291 = 0;
    _292++;
    if (_292 < i)
    goto _jump1113;
    _292 = 0;
    _293++;
    if (_293 < _0.d1)
    goto _jump1113;
    // End body of loop
    _287 = _288;
    goto _jump1118;
    _jump1109:;
    _a3_double _297;
    // Computing bound for x
    _297.d0 = d;
    if (d > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing bound for y
    _297.d1 = i;
    if (i > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing bound for z
    _297.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing total size of heap memory to allocate
    int64_t _298 = 1;
    _298 *= d;
    _298 *= i;
    _298 *= _0.d0;
    _298 *= sizeof(double);
    _297.data = jpl_alloc(_298);
    int64_t _299 = 0; // z
    int64_t _300 = 0; // y
    int64_t _301 = 0; // x
    _jump1122:; // Begin body of loop
    double _302 = n.a;
    int64_t _303 = 0;
    _303 *= _297.d0;
    _303 += _301;
    _303 *= _297.d1;
    _303 += _300;
    _303 *= _297.d2;
    _303 += _299;
    _297.data[_303] = _302;
    _299++;
    if (_299 < _0.d0)
    goto _jump1122;
    _299 = 0;
    _300++;
    if (_300 < i)
    goto _jump1122;
    _300 = 0;
    _301++;
    if (_301 < d)
    goto _jump1122;
    // End body of loop
    _287 = _297;
    _jump1118:;
    _271 = _287;
    goto _jump1123;
    _jump1097:;
    _a3_double _304;
    // Computing bound for x
    _304.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing bound for y
    _304.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    // Computing bound for z
    _304.d2 = f;
    if (f > 0) 
    goto _jump1126;
    fail_assertion("non-positive loop bound");
    _jump1126:;
    // Computing total size of heap memory to allocate
    int64_t _305 = 1;
    _305 *= _0.d0;
    _305 *= _0.d0;
    _305 *= f;
    _305 *= sizeof(double);
    _304.data = jpl_alloc(_305);
    int64_t _306 = 0; // z
    int64_t _307 = 0; // y
    int64_t _308 = 0; // x
    _jump1127:; // Begin body of loop
    double _309 = 29.0;
    double _310 = -_309;
    double _311;
    // Computing bound for A
    if (_307 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    _311 = 0;
    int64_t _312 = 0; // A
    _jump1129:; // Begin body of loop
    double _313;
    // Computing bound for B
    if (e > 0) 
    goto _jump1130;
    fail_assertion("non-positive loop bound");
    _jump1130:;
    // Computing bound for C
    if (_0.d0 > 0) 
    goto _jump1131;
    fail_assertion("non-positive loop bound");
    _jump1131:;
    _313 = 0;
    int64_t _314 = 0; // C
    int64_t _315 = 0; // B
    _jump1132:; // Begin body of loop
    double _316 = 97.0;
    _313 += _316;
    _314++;
    if (_314 < _0.d0)
    goto _jump1132;
    _314 = 0;
    _315++;
    if (_315 < e)
    goto _jump1132;
    // End body of loop
    _311 += _313;
    _312++;
    if (_312 < _307)
    goto _jump1129;
    // End body of loop
    double _317 = _310 * _311;
    int64_t _318 = 0;
    _318 *= _304.d0;
    _318 += _308;
    _318 *= _304.d1;
    _318 += _307;
    _318 *= _304.d2;
    _318 += _306;
    _304.data[_318] = _317;
    _306++;
    if (_306 < f)
    goto _jump1127;
    _306 = 0;
    _307++;
    if (_307 < _0.d0)
    goto _jump1127;
    _307 = 0;
    _308++;
    if (_308 < _0.d0)
    goto _jump1127;
    // End body of loop
    _271 = _304;
    _jump1123:;
    int64_t _319 = 934;
    if (e >= 0)
    goto _jump1133;
    fail_assertion("negative array index");
    _jump1133:;
    if (e < _271.d0)
    goto _jump1134;
    fail_assertion("index too large");
    _jump1134:;
    if (g >= 0)
    goto _jump1135;
    fail_assertion("negative array index");
    _jump1135:;
    if (g < _271.d1)
    goto _jump1136;
    fail_assertion("index too large");
    _jump1136:;
    if (_319 >= 0)
    goto _jump1137;
    fail_assertion("negative array index");
    _jump1137:;
    if (_319 < _271.d2)
    goto _jump1138;
    fail_assertion("index too large");
    _jump1138:;
    int64_t _320 = 0;
    _320 *= _271.d0;
    _320 += e;
    _320 *= _271.d1;
    _320 += g;
    _320 *= _271.d2;
    _320 += _319;
    double _321 = _271.data[_320];
    _a2_double _322;
    if (!a)
    goto _jump1139;
    _a3__a2_double _323;
    // Computing bound for x
    _323.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    // Computing bound for y
    _323.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    // Computing bound for z
    int64_t _324 = b(k);
    _323.d2 = _324;
    if (_324 > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= k.d1;
    _325 *= _0.d0;
    _325 *= _324;
    _325 *= sizeof(_a2_double);
    _323.data = jpl_alloc(_325);
    int64_t _326 = 0; // z
    int64_t _327 = 0; // y
    int64_t _328 = 0; // x
    _jump1143:; // Begin body of loop
    bool _329 = false;
    bool _330 = !_329;
    _a2_double _331;
    if (!_330)
    goto _jump1144;
    _331 = k;
    goto _jump1145;
    _jump1144:;
    _331 = k;
    _jump1145:;
    int64_t _332 = 0;
    _332 *= _323.d0;
    _332 += _328;
    _332 *= _323.d1;
    _332 += _327;
    _332 *= _323.d2;
    _332 += _326;
    _323.data[_332] = _331;
    _326++;
    if (_326 < _324)
    goto _jump1143;
    _326 = 0;
    _327++;
    if (_327 < _0.d0)
    goto _jump1143;
    _327 = 0;
    _328++;
    if (_328 < k.d1)
    goto _jump1143;
    // End body of loop
    if (f >= 0)
    goto _jump1146;
    fail_assertion("negative array index");
    _jump1146:;
    if (f < _323.d0)
    goto _jump1147;
    fail_assertion("index too large");
    _jump1147:;
    if (k.d1 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (k.d1 < _323.d1)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    if (_0.d1 >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (_0.d1 < _323.d2)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _333 = 0;
    _333 *= _323.d0;
    _333 += f;
    _333 *= _323.d1;
    _333 += k.d1;
    _333 *= _323.d2;
    _333 += _0.d1;
    _a2_double _334 = _323.data[_333];
    _322 = _334;
    goto _jump1152;
    _jump1139:;
    _a3__a2_double _335;
    // Computing bound for x
    _335.d0 = _204.d0;
    if (_204.d0 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    // Computing bound for y
    _335.d1 = f;
    if (f > 0) 
    goto _jump1154;
    fail_assertion("non-positive loop bound");
    _jump1154:;
    // Computing bound for z
    _335.d2 = k.d0;
    if (k.d0 > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _204.d0;
    _336 *= f;
    _336 *= k.d0;
    _336 *= sizeof(_a2_double);
    _335.data = jpl_alloc(_336);
    int64_t _337 = 0; // z
    int64_t _338 = 0; // y
    int64_t _339 = 0; // x
    _jump1156:; // Begin body of loop
    int64_t _340 = 0;
    _340 *= _335.d0;
    _340 += _339;
    _340 *= _335.d1;
    _340 += _338;
    _340 *= _335.d2;
    _340 += _337;
    _335.data[_340] = k;
    _337++;
    if (_337 < k.d0)
    goto _jump1156;
    _337 = 0;
    _338++;
    if (_338 < f)
    goto _jump1156;
    _338 = 0;
    _339++;
    if (_339 < _204.d0)
    goto _jump1156;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump1157;
    fail_assertion("negative array index");
    _jump1157:;
    if (_0.d1 < _335.d0)
    goto _jump1158;
    fail_assertion("index too large");
    _jump1158:;
    if (_204.d0 >= 0)
    goto _jump1159;
    fail_assertion("negative array index");
    _jump1159:;
    if (_204.d0 < _335.d1)
    goto _jump1160;
    fail_assertion("index too large");
    _jump1160:;
    if (e >= 0)
    goto _jump1161;
    fail_assertion("negative array index");
    _jump1161:;
    if (e < _335.d2)
    goto _jump1162;
    fail_assertion("index too large");
    _jump1162:;
    int64_t _341 = 0;
    _341 *= _335.d0;
    _341 += _0.d1;
    _341 *= _335.d1;
    _341 += _204.d0;
    _341 *= _335.d2;
    _341 += e;
    _a2_double _342 = _335.data[_341];
    _a2_double _343;
    // Computing bound for x
    _343.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing bound for y
    int64_t _344 = 546;
    int64_t _345 = -_344;
    _343.d1 = _345;
    if (_345 > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    // Computing total size of heap memory to allocate
    int64_t _346 = 1;
    _346 *= _0.d0;
    _346 *= _345;
    _346 *= sizeof(double);
    _343.data = jpl_alloc(_346);
    int64_t _347 = 0; // y
    int64_t _348 = 0; // x
    _jump1165:; // Begin body of loop
    double _349 = 15.0;
    double _350 = -_349;
    int64_t _351 = 0;
    _351 *= _343.d0;
    _351 += _348;
    _351 *= _343.d1;
    _351 += _347;
    _343.data[_351] = _350;
    _347++;
    if (_347 < _345)
    goto _jump1165;
    _347 = 0;
    _348++;
    if (_348 < _0.d0)
    goto _jump1165;
    // End body of loop
    _a2_double _352;
    // Computing bound for x
    _352.d0 = _205.d1;
    if (_205.d1 > 0) 
    goto _jump1166;
    fail_assertion("non-positive loop bound");
    _jump1166:;
    // Computing bound for y
    _352.d1 = _205.d1;
    if (_205.d1 > 0) 
    goto _jump1167;
    fail_assertion("non-positive loop bound");
    _jump1167:;
    // Computing total size of heap memory to allocate
    int64_t _353 = 1;
    _353 *= _205.d1;
    _353 *= _205.d1;
    _353 *= sizeof(double);
    _352.data = jpl_alloc(_353);
    int64_t _354 = 0; // y
    int64_t _355 = 0; // x
    _jump1168:; // Begin body of loop
    double _356 = 2.0;
    double _357 = -_356;
    int64_t _358 = 0;
    _358 *= _352.d0;
    _358 += _355;
    _358 *= _352.d1;
    _358 += _354;
    _352.data[_358] = _357;
    _354++;
    if (_354 < _205.d1)
    goto _jump1168;
    _354 = 0;
    _355++;
    if (_355 < _205.d1)
    goto _jump1168;
    // End body of loop
    _a1__a2_double _359;
    _359.d0 = 3;
    _359.data = jpl_alloc(sizeof(_a2_double) * 3);
    _359.data[0] = _342;
    _359.data[1] = _343;
    _359.data[2] = _352;
    if (e >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (e < _359.d0)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    int64_t _360 = 0;
    _360 *= _359.d0;
    _360 += e;
    _a2_double _361 = _359.data[_360];
    _322 = _361;
    _jump1152:;
    if (k.d0 >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (k.d0 < _322.d0)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    if (_0.d1 >= 0)
    goto _jump1173;
    fail_assertion("negative array index");
    _jump1173:;
    if (_0.d1 < _322.d1)
    goto _jump1174;
    fail_assertion("index too large");
    _jump1174:;
    int64_t _362 = 0;
    _362 *= _322.d0;
    _362 += k.d0;
    _362 *= _322.d1;
    _362 += _0.d1;
    double _363 = _322.data[_362];
    bool _364 = _321 > _363;
    if (0 != _364)
    goto _jump1175;
    fail_assertion("x");
    _jump1175:;
    bool _365 = false;
    bool _366 = !_365;
    _a1__a1__a2_bool _367;
    if (!_366)
    goto _jump1176;
    _a1__a1__a2_bool _368;
    // Computing bound for x
    _a1_int64_t _369;
    // Computing bound for x
    _369.d0 = i;
    if (i > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing total size of heap memory to allocate
    int64_t _370 = 1;
    _370 *= i;
    _370 *= sizeof(int64_t);
    _369.data = jpl_alloc(_370);
    int64_t _371 = 0; // x
    _jump1178:; // Begin body of loop
    int64_t _372 = 0;
    _372 *= _369.d0;
    _372 += _371;
    _369.data[_372] = _371;
    _371++;
    if (_371 < i)
    goto _jump1178;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump1179;
    fail_assertion("negative array index");
    _jump1179:;
    if (_0.d1 < _369.d0)
    goto _jump1180;
    fail_assertion("index too large");
    _jump1180:;
    int64_t _373 = 0;
    _373 *= _369.d0;
    _373 += _0.d1;
    int64_t _374 = _369.data[_373];
    int64_t _375 = -_374;
    _368.d0 = _375;
    if (_375 > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= _375;
    _376 *= sizeof(_a1__a2_bool);
    _368.data = jpl_alloc(_376);
    int64_t _377 = 0; // x
    _jump1182:; // Begin body of loop
    _a3__a1__a2_bool _378;
    // Computing bound for y
    int64_t _379 = b(k);
    _378.d0 = _379;
    if (_379 > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    // Computing bound for z
    int64_t _380;
    // Computing bound for y
    if (f > 0) 
    goto _jump1184;
    fail_assertion("non-positive loop bound");
    _jump1184:;
    // Computing bound for z
    if (_0.d1 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing bound for A
    if (i > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    _380 = 0;
    int64_t _381 = 0; // A
    int64_t _382 = 0; // z
    int64_t _383 = 0; // y
    _jump1187:; // Begin body of loop
    _380 += _0.d0;
    _381++;
    if (_381 < i)
    goto _jump1187;
    _381 = 0;
    _382++;
    if (_382 < _0.d1)
    goto _jump1187;
    _382 = 0;
    _383++;
    if (_383 < f)
    goto _jump1187;
    // End body of loop
    _378.d1 = _380;
    if (_380 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    // Computing bound for A
    _378.d2 = k.d1;
    if (k.d1 > 0) 
    goto _jump1189;
    fail_assertion("non-positive loop bound");
    _jump1189:;
    // Computing total size of heap memory to allocate
    int64_t _384 = 1;
    _384 *= _379;
    _384 *= _380;
    _384 *= k.d1;
    _384 *= sizeof(_a1__a2_bool);
    _378.data = jpl_alloc(_384);
    int64_t _385 = 0; // A
    int64_t _386 = 0; // z
    int64_t _387 = 0; // y
    _jump1190:; // Begin body of loop
    _a1__a2_bool _388;
    // Computing bound for B
    _388.d0 = i;
    if (i > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= i;
    _389 *= sizeof(_a2_bool);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // B
    _jump1192:; // Begin body of loop
    int64_t _391 = 0;
    _391 *= _388.d0;
    _391 += _390;
    _388.data[_391] = _205;
    _390++;
    if (_390 < i)
    goto _jump1192;
    // End body of loop
    int64_t _392 = 0;
    _392 *= _378.d0;
    _392 += _387;
    _392 *= _378.d1;
    _392 += _386;
    _392 *= _378.d2;
    _392 += _385;
    _378.data[_392] = _388;
    _385++;
    if (_385 < k.d1)
    goto _jump1190;
    _385 = 0;
    _386++;
    if (_386 < _380)
    goto _jump1190;
    _386 = 0;
    _387++;
    if (_387 < _379)
    goto _jump1190;
    // End body of loop
    if (d >= 0)
    goto _jump1193;
    fail_assertion("negative array index");
    _jump1193:;
    if (d < _378.d0)
    goto _jump1194;
    fail_assertion("index too large");
    _jump1194:;
    if (_0.d0 >= 0)
    goto _jump1195;
    fail_assertion("negative array index");
    _jump1195:;
    if (_0.d0 < _378.d1)
    goto _jump1196;
    fail_assertion("index too large");
    _jump1196:;
    if (_205.d0 >= 0)
    goto _jump1197;
    fail_assertion("negative array index");
    _jump1197:;
    if (_205.d0 < _378.d2)
    goto _jump1198;
    fail_assertion("index too large");
    _jump1198:;
    int64_t _393 = 0;
    _393 *= _378.d0;
    _393 += d;
    _393 *= _378.d1;
    _393 += _0.d0;
    _393 *= _378.d2;
    _393 += _205.d0;
    _a1__a2_bool _394 = _378.data[_393];
    int64_t _395 = 0;
    _395 *= _368.d0;
    _395 += _377;
    _368.data[_395] = _394;
    _377++;
    if (_377 < _375)
    goto _jump1182;
    // End body of loop
    _367 = _368;
    goto _jump1199;
    _jump1176:;
    _a2_bool _396;
    // Computing bound for x
    _396.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing bound for y
    int64_t _397;
    if (!h)
    goto _jump1201;
    _397 = i;
    goto _jump1202;
    _jump1201:;
    _397 = g;
    _jump1202:;
    _396.d1 = _397;
    if (_397 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing total size of heap memory to allocate
    int64_t _398 = 1;
    _398 *= k.d0;
    _398 *= _397;
    _398 *= sizeof(bool);
    _396.data = jpl_alloc(_398);
    int64_t _399 = 0; // y
    int64_t _400 = 0; // x
    _jump1204:; // Begin body of loop
    bool _402 = false;
    bool _401 = _402;
    if (0 != _402)
    goto _jump1205;
    _401 = a;
    _jump1205:;
    int64_t _403 = 0;
    _403 *= _396.d0;
    _403 += _400;
    _403 *= _396.d1;
    _403 += _399;
    _396.data[_403] = _401;
    _399++;
    if (_399 < _397)
    goto _jump1204;
    _399 = 0;
    _400++;
    if (_400 < k.d0)
    goto _jump1204;
    // End body of loop
    _a2_bool _404;
    // Computing bound for x
    _404.d0 = _204.d0;
    if (_204.d0 > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    // Computing bound for y
    _404.d1 = _205.d0;
    if (_205.d0 > 0) 
    goto _jump1207;
    fail_assertion("non-positive loop bound");
    _jump1207:;
    // Computing total size of heap memory to allocate
    int64_t _405 = 1;
    _405 *= _204.d0;
    _405 *= _205.d0;
    _405 *= sizeof(bool);
    _404.data = jpl_alloc(_405);
    int64_t _406 = 0; // y
    int64_t _407 = 0; // x
    _jump1208:; // Begin body of loop
    if (e >= 0)
    goto _jump1209;
    fail_assertion("negative array index");
    _jump1209:;
    if (e < _204.d0)
    goto _jump1210;
    fail_assertion("index too large");
    _jump1210:;
    int64_t _408 = 0;
    _408 *= _204.d0;
    _408 += e;
    bool _409 = _204.data[_408];
    int64_t _410 = 0;
    _410 *= _404.d0;
    _410 += _407;
    _410 *= _404.d1;
    _410 += _406;
    _404.data[_410] = _409;
    _406++;
    if (_406 < _205.d0)
    goto _jump1208;
    _406 = 0;
    _407++;
    if (_407 < _204.d0)
    goto _jump1208;
    // End body of loop
    _a1__a2_bool _411;
    _411.d0 = 3;
    _411.data = jpl_alloc(sizeof(_a2_bool) * 3);
    _411.data[0] = _396;
    _411.data[1] = _404;
    _411.data[2] = _205;
    _a1__a1__a2_bool _412;
    _412.d0 = 1;
    _412.data = jpl_alloc(sizeof(_a1__a2_bool) * 1);
    _412.data[0] = _411;
    _367 = _412;
    _jump1199:;
    int64_t _413 = -k.d1;
    int64_t _414 = _413 + d;
    if (_414 >= 0)
    goto _jump1211;
    fail_assertion("negative array index");
    _jump1211:;
    if (_414 < _367.d0)
    goto _jump1212;
    fail_assertion("index too large");
    _jump1212:;
    int64_t _415 = 0;
    _415 *= _367.d0;
    _415 += _414;
    _a1__a2_bool _416 = _367.data[_415];
    if (_204.d0 >= 0)
    goto _jump1213;
    fail_assertion("negative array index");
    _jump1213:;
    if (_204.d0 < _416.d0)
    goto _jump1214;
    fail_assertion("index too large");
    _jump1214:;
    int64_t _417 = 0;
    _417 *= _416.d0;
    _417 += _204.d0;
    _a2_bool _418 = _416.data[_417];
    if (k.d0 >= 0)
    goto _jump1215;
    fail_assertion("negative array index");
    _jump1215:;
    if (k.d0 < _205.d0)
    goto _jump1216;
    fail_assertion("index too large");
    _jump1216:;
    if (g >= 0)
    goto _jump1217;
    fail_assertion("negative array index");
    _jump1217:;
    if (g < _205.d1)
    goto _jump1218;
    fail_assertion("index too large");
    _jump1218:;
    int64_t _419 = 0;
    _419 *= _205.d0;
    _419 += k.d0;
    _419 *= _205.d1;
    _419 += g;
    bool _420 = _205.data[_419];
    double _421;
    if (!_420)
    goto _jump1219;
    double _422 = 12.0;
    bool _423 = !a;
    double _424;
    if (!_423)
    goto _jump1220;
    double _425 = n.b;
    _424 = _425;
    goto _jump1221;
    _jump1220:;
    double _426 = n.a;
    _424 = _426;
    _jump1221:;
    bool _427;
    if (!a)
    goto _jump1222;
    _427 = a;
    goto _jump1223;
    _jump1222:;
    bool _428 = true;
    _427 = _428;
    _jump1223:;
    double _429;
    if (!_427)
    goto _jump1224;
    double _430 = 67.0;
    _429 = _430;
    goto _jump1225;
    _jump1224:;
    double _431 = 12.0;
    _429 = _431;
    _jump1225:;
    _a2_double _432;
    // Computing bound for A
    _432.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for B
    _432.d1 = k.d1;
    if (k.d1 > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing total size of heap memory to allocate
    int64_t _433 = 1;
    _433 *= _0.d0;
    _433 *= k.d1;
    _433 *= sizeof(double);
    _432.data = jpl_alloc(_433);
    int64_t _434 = 0; // B
    int64_t _435 = 0; // A
    _jump1228:; // Begin body of loop
    double _436 = 20.0;
    int64_t _437 = 0;
    _437 *= _432.d0;
    _437 += _435;
    _437 *= _432.d1;
    _437 += _434;
    _432.data[_437] = _436;
    _434++;
    if (_434 < k.d1)
    goto _jump1228;
    _434 = 0;
    _435++;
    if (_435 < _0.d0)
    goto _jump1228;
    // End body of loop
    int64_t _438 = -k.d0;
    if (_438 >= 0)
    goto _jump1229;
    fail_assertion("negative array index");
    _jump1229:;
    if (_438 < _432.d0)
    goto _jump1230;
    fail_assertion("index too large");
    _jump1230:;
    if (_418.d0 >= 0)
    goto _jump1231;
    fail_assertion("negative array index");
    _jump1231:;
    if (_418.d0 < _432.d1)
    goto _jump1232;
    fail_assertion("index too large");
    _jump1232:;
    int64_t _439 = 0;
    _439 *= _432.d0;
    _439 += _438;
    _439 *= _432.d1;
    _439 += _418.d0;
    double _440 = _432.data[_439];
    rgba _441 = { _422, _424, _429, _440 };
    double _442 = j(k, _441, o);
    _a2_double _443;
    // Computing bound for A
    int64_t _444 = 657;
    _443.d0 = _444;
    if (_444 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing bound for B
    _443.d1 = g;
    if (g > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing total size of heap memory to allocate
    int64_t _445 = 1;
    _445 *= _444;
    _445 *= g;
    _445 *= sizeof(double);
    _443.data = jpl_alloc(_445);
    int64_t _446 = 0; // B
    int64_t _447 = 0; // A
    _jump1235:; // Begin body of loop
    double _448 = 24.0;
    double _449 = 2.0;
    double _450 = -_449;
    double _451 = _448 + _450;
    int64_t _452 = 0;
    _452 *= _443.d0;
    _452 += _447;
    _452 *= _443.d1;
    _452 += _446;
    _443.data[_452] = _451;
    _446++;
    if (_446 < g)
    goto _jump1235;
    _446 = 0;
    _447++;
    if (_447 < _444)
    goto _jump1235;
    // End body of loop
    double _453;
    // Computing bound for A
    if (d > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing bound for B
    if (_418.d1 > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    _453 = 0;
    int64_t _454 = 0; // B
    int64_t _455 = 0; // A
    _jump1238:; // Begin body of loop
    double _456 = 58.0;
    _453 += _456;
    _454++;
    if (_454 < _418.d1)
    goto _jump1238;
    _454 = 0;
    _455++;
    if (_455 < d)
    goto _jump1238;
    // End body of loop
    double _457 = 83.0;
    bool _458 = _453 != _457;
    rgba _459;
    if (!_458)
    goto _jump1239;
    _459 = n;
    goto _jump1240;
    _jump1239:;
    _459 = n;
    _jump1240:;
    double _460 = j(_443, _459, o);
    double _461 = _442 / _460;
    double _462 = -_461;
    _421 = _462;
    goto _jump1241;
    _jump1219:;
    _a3__a2_double _463;
    // Computing bound for A
    _463.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump1242;
    fail_assertion("non-positive loop bound");
    _jump1242:;
    // Computing bound for B
    _463.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1243;
    fail_assertion("non-positive loop bound");
    _jump1243:;
    // Computing bound for C
    _463.d2 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1244;
    fail_assertion("non-positive loop bound");
    _jump1244:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= k.d1;
    _464 *= _0.d0;
    _464 *= _418.d0;
    _464 *= sizeof(_a2_double);
    _463.data = jpl_alloc(_464);
    int64_t _465 = 0; // C
    int64_t _466 = 0; // B
    int64_t _467 = 0; // A
    _jump1245:; // Begin body of loop
    int64_t _468 = 0;
    _468 *= _463.d0;
    _468 += _467;
    _468 *= _463.d1;
    _468 += _466;
    _468 *= _463.d2;
    _468 += _465;
    _463.data[_468] = k;
    _465++;
    if (_465 < _418.d0)
    goto _jump1245;
    _465 = 0;
    _466++;
    if (_466 < _0.d0)
    goto _jump1245;
    _466 = 0;
    _467++;
    if (_467 < k.d1)
    goto _jump1245;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump1246;
    fail_assertion("negative array index");
    _jump1246:;
    if (_0.d1 < _463.d0)
    goto _jump1247;
    fail_assertion("index too large");
    _jump1247:;
    if (_418.d1 >= 0)
    goto _jump1248;
    fail_assertion("negative array index");
    _jump1248:;
    if (_418.d1 < _463.d1)
    goto _jump1249;
    fail_assertion("index too large");
    _jump1249:;
    if (f >= 0)
    goto _jump1250;
    fail_assertion("negative array index");
    _jump1250:;
    if (f < _463.d2)
    goto _jump1251;
    fail_assertion("index too large");
    _jump1251:;
    int64_t _469 = 0;
    _469 *= _463.d0;
    _469 += _0.d1;
    _469 *= _463.d1;
    _469 += _418.d1;
    _469 *= _463.d2;
    _469 += f;
    _a2_double _470 = _463.data[_469];
    _a2_double _471;
    if (!a)
    goto _jump1252;
    _471 = k;
    goto _jump1253;
    _jump1252:;
    _471 = k;
    _jump1253:;
    int64_t _472 = b(_471);
    if (_472 >= 0)
    goto _jump1254;
    fail_assertion("negative array index");
    _jump1254:;
    if (_472 < _470.d0)
    goto _jump1255;
    fail_assertion("index too large");
    _jump1255:;
    if (_205.d1 >= 0)
    goto _jump1256;
    fail_assertion("negative array index");
    _jump1256:;
    if (_205.d1 < _470.d1)
    goto _jump1257;
    fail_assertion("index too large");
    _jump1257:;
    int64_t _473 = 0;
    _473 *= _470.d0;
    _473 += _472;
    _473 *= _470.d1;
    _473 += _205.d1;
    double _474 = _470.data[_473];
    double _475 = -_474;
    double _476;
    // Computing bound for A
    if (d > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    // Computing bound for B
    if (d > 0) 
    goto _jump1259;
    fail_assertion("non-positive loop bound");
    _jump1259:;
    // Computing bound for C
    if (e > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    _476 = 0;
    int64_t _477 = 0; // C
    int64_t _478 = 0; // B
    int64_t _479 = 0; // A
    _jump1261:; // Begin body of loop
    double _480 = 15.0;
    _476 += _480;
    _477++;
    if (_477 < e)
    goto _jump1261;
    _477 = 0;
    _478++;
    if (_478 < d)
    goto _jump1261;
    _478 = 0;
    _479++;
    if (_479 < d)
    goto _jump1261;
    // End body of loop
    double _481 = -_476;
    double _482 = -_481;
    double _483 = -_482;
    double _484 = 30.0;
    _a1_double _485;
    _485.d0 = 1;
    _485.data = jpl_alloc(sizeof(double) * 1);
    _485.data[0] = _484;
    if (f >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (f < _485.d0)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    int64_t _486 = 0;
    _486 *= _485.d0;
    _486 += f;
    double _487 = _485.data[_486];
    double _488;
    // Computing bound for A
    if (_418.d1 > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing bound for B
    if (_418.d1 > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    // Computing bound for C
    if (_418.d1 > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    _488 = 0;
    int64_t _489 = 0; // C
    int64_t _490 = 0; // B
    int64_t _491 = 0; // A
    _jump1267:; // Begin body of loop
    double _492 = 33.0;
    _488 += _492;
    _489++;
    if (_489 < _418.d1)
    goto _jump1267;
    _489 = 0;
    _490++;
    if (_490 < _418.d1)
    goto _jump1267;
    _490 = 0;
    _491++;
    if (_491 < _418.d1)
    goto _jump1267;
    // End body of loop
    rgba _493 = { _475, _483, _487, _488 };
    bool _494 = _0.d1 <= _204.d0;
    _a3_void_t _495;
    if (!_494)
    goto _jump1268;
    _a2__a3_void_t _496;
    // Computing bound for A
    _496.d0 = _204.d0;
    if (_204.d0 > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    // Computing bound for B
    _496.d1 = _205.d1;
    if (_205.d1 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    // Computing total size of heap memory to allocate
    int64_t _497 = 1;
    _497 *= _204.d0;
    _497 *= _205.d1;
    _497 *= sizeof(_a3_void_t);
    _496.data = jpl_alloc(_497);
    int64_t _498 = 0; // B
    int64_t _499 = 0; // A
    _jump1271:; // Begin body of loop
    _a3_void_t _500;
    // Computing bound for C
    _500.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for D
    _500.d1 = d;
    if (d > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing bound for E
    _500.d2 = k.d1;
    if (k.d1 > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    // Computing total size of heap memory to allocate
    int64_t _501 = 1;
    _501 *= _0.d1;
    _501 *= d;
    _501 *= k.d1;
    _501 *= sizeof(void_t);
    _500.data = jpl_alloc(_501);
    int64_t _502 = 0; // E
    int64_t _503 = 0; // D
    int64_t _504 = 0; // C
    _jump1275:; // Begin body of loop
    int64_t _505 = 0;
    _505 *= _500.d0;
    _505 += _504;
    _505 *= _500.d1;
    _505 += _503;
    _505 *= _500.d2;
    _505 += _502;
    _500.data[_505] = o;
    _502++;
    if (_502 < k.d1)
    goto _jump1275;
    _502 = 0;
    _503++;
    if (_503 < d)
    goto _jump1275;
    _503 = 0;
    _504++;
    if (_504 < _0.d1)
    goto _jump1275;
    // End body of loop
    int64_t _506 = 0;
    _506 *= _496.d0;
    _506 += _499;
    _506 *= _496.d1;
    _506 += _498;
    _496.data[_506] = _500;
    _498++;
    if (_498 < _205.d1)
    goto _jump1271;
    _498 = 0;
    _499++;
    if (_499 < _204.d0)
    goto _jump1271;
    // End body of loop
    if (i >= 0)
    goto _jump1276;
    fail_assertion("negative array index");
    _jump1276:;
    if (i < _496.d0)
    goto _jump1277;
    fail_assertion("index too large");
    _jump1277:;
    if (k.d1 >= 0)
    goto _jump1278;
    fail_assertion("negative array index");
    _jump1278:;
    if (k.d1 < _496.d1)
    goto _jump1279;
    fail_assertion("index too large");
    _jump1279:;
    int64_t _507 = 0;
    _507 *= _496.d0;
    _507 += i;
    _507 *= _496.d1;
    _507 += k.d1;
    _a3_void_t _508 = _496.data[_507];
    _495 = _508;
    goto _jump1280;
    _jump1268:;
    bool _509 = h;
    if (0 != h)
    goto _jump1281;
    _509 = h;
    _jump1281:;
    bool _510 = !_509;
    _a3_void_t _511;
    if (!_510)
    goto _jump1282;
    _a3_void_t _512;
    // Computing bound for A
    _512.d0 = _204.d0;
    if (_204.d0 > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for B
    _512.d1 = f;
    if (f > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing bound for C
    int64_t _513 = 401;
    _512.d2 = _513;
    if (_513 > 0) 
    goto _jump1285;
    fail_assertion("non-positive loop bound");
    _jump1285:;
    // Computing total size of heap memory to allocate
    int64_t _514 = 1;
    _514 *= _204.d0;
    _514 *= f;
    _514 *= _513;
    _514 *= sizeof(void_t);
    _512.data = jpl_alloc(_514);
    int64_t _515 = 0; // C
    int64_t _516 = 0; // B
    int64_t _517 = 0; // A
    _jump1286:; // Begin body of loop
    int64_t _518 = 0;
    _518 *= _512.d0;
    _518 += _517;
    _518 *= _512.d1;
    _518 += _516;
    _518 *= _512.d2;
    _518 += _515;
    _512.data[_518] = o;
    _515++;
    if (_515 < _513)
    goto _jump1286;
    _515 = 0;
    _516++;
    if (_516 < f)
    goto _jump1286;
    _516 = 0;
    _517++;
    if (_517 < _204.d0)
    goto _jump1286;
    // End body of loop
    _511 = _512;
    goto _jump1287;
    _jump1282:;
    _a3_void_t _519;
    // Computing bound for A
    _519.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump1288;
    fail_assertion("non-positive loop bound");
    _jump1288:;
    // Computing bound for B
    _519.d1 = d;
    if (d > 0) 
    goto _jump1289;
    fail_assertion("non-positive loop bound");
    _jump1289:;
    // Computing bound for C
    _519.d2 = k.d1;
    if (k.d1 > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing total size of heap memory to allocate
    int64_t _520 = 1;
    _520 *= k.d0;
    _520 *= d;
    _520 *= k.d1;
    _520 *= sizeof(void_t);
    _519.data = jpl_alloc(_520);
    int64_t _521 = 0; // C
    int64_t _522 = 0; // B
    int64_t _523 = 0; // A
    _jump1291:; // Begin body of loop
    int64_t _524 = 0;
    _524 *= _519.d0;
    _524 += _523;
    _524 *= _519.d1;
    _524 += _522;
    _524 *= _519.d2;
    _524 += _521;
    _519.data[_524] = o;
    _521++;
    if (_521 < k.d1)
    goto _jump1291;
    _521 = 0;
    _522++;
    if (_522 < d)
    goto _jump1291;
    _522 = 0;
    _523++;
    if (_523 < k.d0)
    goto _jump1291;
    // End body of loop
    _511 = _519;
    _jump1287:;
    _495 = _511;
    _jump1280:;
    int64_t _525;
    // Computing bound for A
    int64_t _526;
    // Computing bound for A
    if (_205.d1 > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    _526 = 0;
    int64_t _527 = 0; // A
    _jump1293:; // Begin body of loop
    _526 += k.d0;
    _527++;
    if (_527 < _205.d1)
    goto _jump1293;
    // End body of loop
    if (_526 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    _525 = 0;
    int64_t _528 = 0; // A
    _jump1295:; // Begin body of loop
    _525 += _0.d0;
    _528++;
    if (_528 < _526)
    goto _jump1295;
    // End body of loop
    if (_525 >= 0)
    goto _jump1296;
    fail_assertion("negative array index");
    _jump1296:;
    if (_525 < _495.d0)
    goto _jump1297;
    fail_assertion("index too large");
    _jump1297:;
    if (e >= 0)
    goto _jump1298;
    fail_assertion("negative array index");
    _jump1298:;
    if (e < _495.d1)
    goto _jump1299;
    fail_assertion("index too large");
    _jump1299:;
    if (d >= 0)
    goto _jump1300;
    fail_assertion("negative array index");
    _jump1300:;
    if (d < _495.d2)
    goto _jump1301;
    fail_assertion("index too large");
    _jump1301:;
    int64_t _529 = 0;
    _529 *= _495.d0;
    _529 += _525;
    _529 *= _495.d1;
    _529 += e;
    _529 *= _495.d2;
    _529 += d;
    void_t _530 = _495.data[_529];
    double _531 = j(k, _493, _530);
    _421 = _531;
    _jump1241:;
    return _421;
}

double k(rgba l, void_t m) {
    double _0 = l.r;
    _a2_double _1;
    // Computing bound for n
    _1.d0 = e;
    if (e > 0) 
    goto _jump1302;
    fail_assertion("non-positive loop bound");
    _jump1302:;
    // Computing bound for o
    int64_t _2 = 30;
    _1.d1 = _2;
    if (_2 > 0) 
    goto _jump1303;
    fail_assertion("non-positive loop bound");
    _jump1303:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= e;
    _3 *= _2;
    _3 *= sizeof(double);
    _1.data = jpl_alloc(_3);
    int64_t _4 = 0; // o
    int64_t _5 = 0; // n
    _jump1304:; // Begin body of loop
    double _6 = l.a;
    int64_t _7 = 0;
    _7 *= _1.d0;
    _7 += _5;
    _7 *= _1.d1;
    _7 += _4;
    _1.data[_7] = _6;
    _4++;
    if (_4 < _2)
    goto _jump1304;
    _4 = 0;
    _5++;
    if (_5 < e)
    goto _jump1304;
    // End body of loop
    double _8 = j(_1, l, m);
    bool _9 = _0 >= _8;
    _a3_bool _10;
    if (!_9)
    goto _jump1305;
    bool _11 = i >= e;
    bool _12;
    if (!_11)
    goto _jump1306;
    _a3_bool _13;
    if (!a)
    goto _jump1307;
    _13 = c;
    goto _jump1308;
    _jump1307:;
    _13 = c;
    _jump1308:;
    int64_t _14 = 747;
    int64_t _15 = -d;
    if (_14 >= 0)
    goto _jump1309;
    fail_assertion("negative array index");
    _jump1309:;
    if (_14 < _13.d0)
    goto _jump1310;
    fail_assertion("index too large");
    _jump1310:;
    if (g >= 0)
    goto _jump1311;
    fail_assertion("negative array index");
    _jump1311:;
    if (g < _13.d1)
    goto _jump1312;
    fail_assertion("index too large");
    _jump1312:;
    if (_15 >= 0)
    goto _jump1313;
    fail_assertion("negative array index");
    _jump1313:;
    if (_15 < _13.d2)
    goto _jump1314;
    fail_assertion("index too large");
    _jump1314:;
    int64_t _16 = 0;
    _16 *= _13.d0;
    _16 += _14;
    _16 *= _13.d1;
    _16 += g;
    _16 *= _13.d2;
    _16 += _15;
    bool _17 = _13.data[_16];
    _12 = _17;
    goto _jump1315;
    _jump1306:;
    int64_t _18;
    // Computing bound for n
    int64_t _19 = 858;
    if (_19 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    _18 = 0;
    int64_t _20 = 0; // n
    _jump1317:; // Begin body of loop
    _18 += g;
    _20++;
    if (_20 < _19)
    goto _jump1317;
    // End body of loop
    int64_t _21 = f * _18;
    int64_t _22;
    // Computing bound for n
    int64_t _23 = 664;
    if (_23 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for o
    int64_t _24 = e + e;
    if (_24 > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    // Computing bound for p
    int64_t _25 = e / g;
    if (_25 > 0) 
    goto _jump1320;
    fail_assertion("non-positive loop bound");
    _jump1320:;
    _22 = 0;
    int64_t _26 = 0; // p
    int64_t _27 = 0; // o
    int64_t _28 = 0; // n
    _jump1321:; // Begin body of loop
    int64_t _29 = -g;
    _22 += _29;
    _26++;
    if (_26 < _25)
    goto _jump1321;
    _26 = 0;
    _27++;
    if (_27 < _24)
    goto _jump1321;
    _27 = 0;
    _28++;
    if (_28 < _23)
    goto _jump1321;
    // End body of loop
    int64_t _30;
    // Computing bound for n
    int64_t _31 = 633;
    if (_31 > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing bound for o
    if (g > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    _30 = 0;
    int64_t _32 = 0; // o
    int64_t _33 = 0; // n
    _jump1324:; // Begin body of loop
    _30 += d;
    _32++;
    if (_32 < g)
    goto _jump1324;
    _32 = 0;
    _33++;
    if (_33 < _31)
    goto _jump1324;
    // End body of loop
    int64_t _34 = -e;
    int64_t _35 = _30 - _34;
    if (_21 >= 0)
    goto _jump1325;
    fail_assertion("negative array index");
    _jump1325:;
    if (_21 < c.d0)
    goto _jump1326;
    fail_assertion("index too large");
    _jump1326:;
    if (_22 >= 0)
    goto _jump1327;
    fail_assertion("negative array index");
    _jump1327:;
    if (_22 < c.d1)
    goto _jump1328;
    fail_assertion("index too large");
    _jump1328:;
    if (_35 >= 0)
    goto _jump1329;
    fail_assertion("negative array index");
    _jump1329:;
    if (_35 < c.d2)
    goto _jump1330;
    fail_assertion("index too large");
    _jump1330:;
    int64_t _36 = 0;
    _36 *= c.d0;
    _36 += _21;
    _36 *= c.d1;
    _36 += _22;
    _36 *= c.d2;
    _36 += _35;
    bool _37 = c.data[_36];
    _12 = _37;
    _jump1315:;
    _a3_bool _38;
    if (!_12)
    goto _jump1331;
    _a1__a3__a3_bool _39;
    // Computing bound for n
    _39.d0 = e;
    if (e > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= e;
    _40 *= sizeof(_a3__a3_bool);
    _39.data = jpl_alloc(_40);
    int64_t _41 = 0; // n
    _jump1333:; // Begin body of loop
    _a3__a3_bool _42;
    // Computing bound for o
    _42.d0 = d;
    if (d > 0) 
    goto _jump1334;
    fail_assertion("non-positive loop bound");
    _jump1334:;
    // Computing bound for p
    _42.d1 = e;
    if (e > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    // Computing bound for q
    _42.d2 = e;
    if (e > 0) 
    goto _jump1336;
    fail_assertion("non-positive loop bound");
    _jump1336:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= d;
    _43 *= e;
    _43 *= e;
    _43 *= sizeof(_a3_bool);
    _42.data = jpl_alloc(_43);
    int64_t _44 = 0; // q
    int64_t _45 = 0; // p
    int64_t _46 = 0; // o
    _jump1337:; // Begin body of loop
    int64_t _47 = 0;
    _47 *= _42.d0;
    _47 += _46;
    _47 *= _42.d1;
    _47 += _45;
    _47 *= _42.d2;
    _47 += _44;
    _42.data[_47] = c;
    _44++;
    if (_44 < e)
    goto _jump1337;
    _44 = 0;
    _45++;
    if (_45 < e)
    goto _jump1337;
    _45 = 0;
    _46++;
    if (_46 < d)
    goto _jump1337;
    // End body of loop
    int64_t _48 = 0;
    _48 *= _39.d0;
    _48 += _41;
    _39.data[_48] = _42;
    _41++;
    if (_41 < e)
    goto _jump1333;
    // End body of loop
    bool _49 = !h;
    int64_t _50;
    if (!_49)
    goto _jump1338;
    int64_t _51;
    if (!a)
    goto _jump1339;
    _51 = d;
    goto _jump1340;
    _jump1339:;
    _51 = f;
    _jump1340:;
    _50 = _51;
    goto _jump1341;
    _jump1338:;
    _50 = f;
    _jump1341:;
    if (_50 >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (_50 < _39.d0)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    int64_t _52 = 0;
    _52 *= _39.d0;
    _52 += _50;
    _a3__a3_bool _53 = _39.data[_52];
    int64_t _54 = 979;
    int64_t _55 = _54 % i;
    int64_t _56 = -i;
    if (_55 >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (_55 < _53.d0)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    if (_56 >= 0)
    goto _jump1346;
    fail_assertion("negative array index");
    _jump1346:;
    if (_56 < _53.d1)
    goto _jump1347;
    fail_assertion("index too large");
    _jump1347:;
    if (f >= 0)
    goto _jump1348;
    fail_assertion("negative array index");
    _jump1348:;
    if (f < _53.d2)
    goto _jump1349;
    fail_assertion("index too large");
    _jump1349:;
    int64_t _57 = 0;
    _57 *= _53.d0;
    _57 += _55;
    _57 *= _53.d1;
    _57 += _56;
    _57 *= _53.d2;
    _57 += f;
    _a3_bool _58 = _53.data[_57];
    _38 = _58;
    goto _jump1350;
    _jump1331:;
    _a3_bool _59;
    // Computing bound for n
    bool _60 = true;
    int64_t _61;
    if (!_60)
    goto _jump1351;
    _61 = e;
    goto _jump1352;
    _jump1351:;
    int64_t _62 = g - g;
    _61 = _62;
    _jump1352:;
    int64_t _63 = _61 - g;
    _59.d0 = _63;
    if (_63 > 0) 
    goto _jump1353;
    fail_assertion("non-positive loop bound");
    _jump1353:;
    // Computing bound for o
    _59.d1 = d;
    if (d > 0) 
    goto _jump1354;
    fail_assertion("non-positive loop bound");
    _jump1354:;
    // Computing bound for p
    int64_t _64 = i % d;
    _59.d2 = _64;
    if (_64 > 0) 
    goto _jump1355;
    fail_assertion("non-positive loop bound");
    _jump1355:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= _63;
    _65 *= d;
    _65 *= _64;
    _65 *= sizeof(bool);
    _59.data = jpl_alloc(_65);
    int64_t _66 = 0; // p
    int64_t _67 = 0; // o
    int64_t _68 = 0; // n
    _jump1356:; // Begin body of loop
    int64_t _69 = 0;
    _69 *= _59.d0;
    _69 += _68;
    _69 *= _59.d1;
    _69 += _67;
    _69 *= _59.d2;
    _69 += _66;
    _59.data[_69] = a;
    _66++;
    if (_66 < _64)
    goto _jump1356;
    _66 = 0;
    _67++;
    if (_67 < d)
    goto _jump1356;
    _67 = 0;
    _68++;
    if (_68 < _63)
    goto _jump1356;
    // End body of loop
    _38 = _59;
    _jump1350:;
    _10 = _38;
    goto _jump1357;
    _jump1305:;
    _a3_bool _70;
    // Computing bound for n
    _a3_int64_t _71;
    // Computing bound for n
    _a3_int64_t _72;
    // Computing bound for n
    _72.d0 = i;
    if (i > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    // Computing bound for o
    _72.d1 = f;
    if (f > 0) 
    goto _jump1359;
    fail_assertion("non-positive loop bound");
    _jump1359:;
    // Computing bound for p
    _72.d2 = f;
    if (f > 0) 
    goto _jump1360;
    fail_assertion("non-positive loop bound");
    _jump1360:;
    // Computing total size of heap memory to allocate
    int64_t _73 = 1;
    _73 *= i;
    _73 *= f;
    _73 *= f;
    _73 *= sizeof(int64_t);
    _72.data = jpl_alloc(_73);
    int64_t _74 = 0; // p
    int64_t _75 = 0; // o
    int64_t _76 = 0; // n
    _jump1361:; // Begin body of loop
    int64_t _77 = 0;
    _77 *= _72.d0;
    _77 += _76;
    _77 *= _72.d1;
    _77 += _75;
    _77 *= _72.d2;
    _77 += _74;
    _72.data[_77] = _76;
    _74++;
    if (_74 < f)
    goto _jump1361;
    _74 = 0;
    _75++;
    if (_75 < f)
    goto _jump1361;
    _75 = 0;
    _76++;
    if (_76 < i)
    goto _jump1361;
    // End body of loop
    int64_t _78;
    // Computing bound for n
    if (g > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    // Computing bound for o
    if (e > 0) 
    goto _jump1363;
    fail_assertion("non-positive loop bound");
    _jump1363:;
    // Computing bound for p
    if (g > 0) 
    goto _jump1364;
    fail_assertion("non-positive loop bound");
    _jump1364:;
    _78 = 0;
    int64_t _79 = 0; // p
    int64_t _80 = 0; // o
    int64_t _81 = 0; // n
    _jump1365:; // Begin body of loop
    _78 += f;
    _79++;
    if (_79 < g)
    goto _jump1365;
    _79 = 0;
    _80++;
    if (_80 < e)
    goto _jump1365;
    _80 = 0;
    _81++;
    if (_81 < g)
    goto _jump1365;
    // End body of loop
    int64_t _82 = 523;
    int64_t _83 = _82 / i;
    if (i >= 0)
    goto _jump1366;
    fail_assertion("negative array index");
    _jump1366:;
    if (i < _72.d0)
    goto _jump1367;
    fail_assertion("index too large");
    _jump1367:;
    if (_78 >= 0)
    goto _jump1368;
    fail_assertion("negative array index");
    _jump1368:;
    if (_78 < _72.d1)
    goto _jump1369;
    fail_assertion("index too large");
    _jump1369:;
    if (_83 >= 0)
    goto _jump1370;
    fail_assertion("negative array index");
    _jump1370:;
    if (_83 < _72.d2)
    goto _jump1371;
    fail_assertion("index too large");
    _jump1371:;
    int64_t _84 = 0;
    _84 *= _72.d0;
    _84 += i;
    _84 *= _72.d1;
    _84 += _78;
    _84 *= _72.d2;
    _84 += _83;
    int64_t _85 = _72.data[_84];
    _71.d0 = _85;
    if (_85 > 0) 
    goto _jump1372;
    fail_assertion("non-positive loop bound");
    _jump1372:;
    // Computing bound for o
    _71.d1 = d;
    if (d > 0) 
    goto _jump1373;
    fail_assertion("non-positive loop bound");
    _jump1373:;
    // Computing bound for p
    int64_t _86 = e - d;
    _71.d2 = _86;
    if (_86 > 0) 
    goto _jump1374;
    fail_assertion("non-positive loop bound");
    _jump1374:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= _85;
    _87 *= d;
    _87 *= _86;
    _87 *= sizeof(int64_t);
    _71.data = jpl_alloc(_87);
    int64_t _88 = 0; // p
    int64_t _89 = 0; // o
    int64_t _90 = 0; // n
    _jump1375:; // Begin body of loop
    int64_t _91 = 0;
    _91 *= _71.d0;
    _91 += _90;
    _91 *= _71.d1;
    _91 += _89;
    _91 *= _71.d2;
    _91 += _88;
    _71.data[_91] = _90;
    _88++;
    if (_88 < _86)
    goto _jump1375;
    _88 = 0;
    _89++;
    if (_89 < d)
    goto _jump1375;
    _89 = 0;
    _90++;
    if (_90 < _85)
    goto _jump1375;
    // End body of loop
    int64_t _92;
    if (!h)
    goto _jump1376;
    int64_t _93 = 824;
    _92 = _93;
    goto _jump1377;
    _jump1376:;
    _92 = d;
    _jump1377:;
    if (g >= 0)
    goto _jump1378;
    fail_assertion("negative array index");
    _jump1378:;
    if (g < _71.d0)
    goto _jump1379;
    fail_assertion("index too large");
    _jump1379:;
    if (_92 >= 0)
    goto _jump1380;
    fail_assertion("negative array index");
    _jump1380:;
    if (_92 < _71.d1)
    goto _jump1381;
    fail_assertion("index too large");
    _jump1381:;
    if (i >= 0)
    goto _jump1382;
    fail_assertion("negative array index");
    _jump1382:;
    if (i < _71.d2)
    goto _jump1383;
    fail_assertion("index too large");
    _jump1383:;
    int64_t _94 = 0;
    _94 *= _71.d0;
    _94 += g;
    _94 *= _71.d1;
    _94 += _92;
    _94 *= _71.d2;
    _94 += i;
    int64_t _95 = _71.data[_94];
    _70.d0 = _95;
    if (_95 > 0) 
    goto _jump1384;
    fail_assertion("non-positive loop bound");
    _jump1384:;
    // Computing bound for o
    _a3_bool _96;
    if (!h)
    goto _jump1385;
    _96 = c;
    goto _jump1386;
    _jump1385:;
    _96 = c;
    _jump1386:;
    if (e >= 0)
    goto _jump1387;
    fail_assertion("negative array index");
    _jump1387:;
    if (e < _96.d0)
    goto _jump1388;
    fail_assertion("index too large");
    _jump1388:;
    if (d >= 0)
    goto _jump1389;
    fail_assertion("negative array index");
    _jump1389:;
    if (d < _96.d1)
    goto _jump1390;
    fail_assertion("index too large");
    _jump1390:;
    if (d >= 0)
    goto _jump1391;
    fail_assertion("negative array index");
    _jump1391:;
    if (d < _96.d2)
    goto _jump1392;
    fail_assertion("index too large");
    _jump1392:;
    int64_t _97 = 0;
    _97 *= _96.d0;
    _97 += e;
    _97 *= _96.d1;
    _97 += d;
    _97 *= _96.d2;
    _97 += d;
    bool _98 = _96.data[_97];
    _a2_double _99;
    if (!_98)
    goto _jump1393;
    _a2_double _100;
    // Computing bound for n
    _100.d0 = i;
    if (i > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing bound for o
    _100.d1 = i;
    if (i > 0) 
    goto _jump1395;
    fail_assertion("non-positive loop bound");
    _jump1395:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= i;
    _101 *= i;
    _101 *= sizeof(double);
    _100.data = jpl_alloc(_101);
    int64_t _102 = 0; // o
    int64_t _103 = 0; // n
    _jump1396:; // Begin body of loop
    double _104 = 41.0;
    double _105 = -_104;
    int64_t _106 = 0;
    _106 *= _100.d0;
    _106 += _103;
    _106 *= _100.d1;
    _106 += _102;
    _100.data[_106] = _105;
    _102++;
    if (_102 < i)
    goto _jump1396;
    _102 = 0;
    _103++;
    if (_103 < i)
    goto _jump1396;
    // End body of loop
    _99 = _100;
    goto _jump1397;
    _jump1393:;
    _a2_double _107;
    // Computing bound for n
    int64_t _108 = -f;
    _107.d0 = _108;
    if (_108 > 0) 
    goto _jump1398;
    fail_assertion("non-positive loop bound");
    _jump1398:;
    // Computing bound for o
    int64_t _109 = -f;
    _107.d1 = _109;
    if (_109 > 0) 
    goto _jump1399;
    fail_assertion("non-positive loop bound");
    _jump1399:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= _108;
    _110 *= _109;
    _110 *= sizeof(double);
    _107.data = jpl_alloc(_110);
    int64_t _111 = 0; // o
    int64_t _112 = 0; // n
    _jump1400:; // Begin body of loop
    double _113 = k(l, m);
    int64_t _114 = 0;
    _114 *= _107.d0;
    _114 += _112;
    _114 *= _107.d1;
    _114 += _111;
    _107.data[_114] = _113;
    _111++;
    if (_111 < _109)
    goto _jump1400;
    _111 = 0;
    _112++;
    if (_112 < _108)
    goto _jump1400;
    // End body of loop
    _99 = _107;
    _jump1397:;
    int64_t _115 = b(_99);
    _70.d1 = _115;
    if (_115 > 0) 
    goto _jump1401;
    fail_assertion("non-positive loop bound");
    _jump1401:;
    // Computing bound for p
    _70.d2 = i;
    if (i > 0) 
    goto _jump1402;
    fail_assertion("non-positive loop bound");
    _jump1402:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= _95;
    _116 *= _115;
    _116 *= i;
    _116 *= sizeof(bool);
    _70.data = jpl_alloc(_116);
    int64_t _117 = 0; // p
    int64_t _118 = 0; // o
    int64_t _119 = 0; // n
    _jump1403:; // Begin body of loop
    int64_t _121 = -g;
    int64_t _122 = 229;
    bool _123 = _121 < _122;
    bool _120 = _123;
    if (0 != _123)
    goto _jump1404;
    _120 = a;
    _jump1404:;
    bool _124;
    if (!_120)
    goto _jump1405;
    bool _125 = f == d;
    bool _126;
    if (!_125)
    goto _jump1406;
    bool _127 = true;
    _126 = _127;
    goto _jump1407;
    _jump1406:;
    _126 = a;
    _jump1407:;
    bool _128 = !_126;
    _124 = _128;
    goto _jump1408;
    _jump1405:;
    int64_t _129 = 348;
    bool _130 = f > _129;
    bool _131 = !_130;
    _124 = _131;
    _jump1408:;
    int64_t _132 = 0;
    _132 *= _70.d0;
    _132 += _119;
    _132 *= _70.d1;
    _132 += _118;
    _132 *= _70.d2;
    _132 += _117;
    _70.data[_132] = _124;
    _117++;
    if (_117 < i)
    goto _jump1403;
    _117 = 0;
    _118++;
    if (_118 < _115)
    goto _jump1403;
    _118 = 0;
    _119++;
    if (_119 < _95)
    goto _jump1403;
    // End body of loop
    _10 = _70;
    _jump1357:;
    _a1__a3_bool _133;
    _133.d0 = 2;
    _133.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _133.data[0] = c;
    _133.data[1] = _10;
    bool _134 = false;
    _a3_bool _135;
    if (!_134)
    goto _jump1409;
    _a2__a3_bool _136;
    // Computing bound for o
    _136.d0 = e;
    if (e > 0) 
    goto _jump1410;
    fail_assertion("non-positive loop bound");
    _jump1410:;
    // Computing bound for p
    _a3_int64_t _137;
    // Computing bound for o
    int64_t _138 = 235;
    _a1_int64_t _139;
    _139.d0 = 2;
    _139.data = jpl_alloc(sizeof(int64_t) * 2);
    _139.data[0] = d;
    _139.data[1] = _138;
    int64_t _140 = g + e;
    if (_140 >= 0)
    goto _jump1411;
    fail_assertion("negative array index");
    _jump1411:;
    if (_140 < _139.d0)
    goto _jump1412;
    fail_assertion("index too large");
    _jump1412:;
    int64_t _141 = 0;
    _141 *= _139.d0;
    _141 += _140;
    int64_t _142 = _139.data[_141];
    _137.d0 = _142;
    if (_142 > 0) 
    goto _jump1413;
    fail_assertion("non-positive loop bound");
    _jump1413:;
    // Computing bound for p
    _137.d1 = f;
    if (f > 0) 
    goto _jump1414;
    fail_assertion("non-positive loop bound");
    _jump1414:;
    // Computing bound for q
    bool _143 = true;
    bool _144 = !_143;
    int64_t _145;
    if (!_144)
    goto _jump1415;
    _145 = e;
    goto _jump1416;
    _jump1415:;
    int64_t _146;
    if (!h)
    goto _jump1417;
    _146 = i;
    goto _jump1418;
    _jump1417:;
    _146 = e;
    _jump1418:;
    _145 = _146;
    _jump1416:;
    _137.d2 = _145;
    if (_145 > 0) 
    goto _jump1419;
    fail_assertion("non-positive loop bound");
    _jump1419:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= _142;
    _147 *= f;
    _147 *= _145;
    _147 *= sizeof(int64_t);
    _137.data = jpl_alloc(_147);
    int64_t _148 = 0; // q
    int64_t _149 = 0; // p
    int64_t _150 = 0; // o
    _jump1420:; // Begin body of loop
    int64_t _151 = 0;
    _151 *= _137.d0;
    _151 += _150;
    _151 *= _137.d1;
    _151 += _149;
    _151 *= _137.d2;
    _151 += _148;
    _137.data[_151] = d;
    _148++;
    if (_148 < _145)
    goto _jump1420;
    _148 = 0;
    _149++;
    if (_149 < f)
    goto _jump1420;
    _149 = 0;
    _150++;
    if (_150 < _142)
    goto _jump1420;
    // End body of loop
    int64_t _152 = 95;
    int64_t _153 = d * _152;
    int64_t _154 = f - _153;
    int64_t _155 = -g;
    if (_154 >= 0)
    goto _jump1421;
    fail_assertion("negative array index");
    _jump1421:;
    if (_154 < _137.d0)
    goto _jump1422;
    fail_assertion("index too large");
    _jump1422:;
    if (f >= 0)
    goto _jump1423;
    fail_assertion("negative array index");
    _jump1423:;
    if (f < _137.d1)
    goto _jump1424;
    fail_assertion("index too large");
    _jump1424:;
    if (_155 >= 0)
    goto _jump1425;
    fail_assertion("negative array index");
    _jump1425:;
    if (_155 < _137.d2)
    goto _jump1426;
    fail_assertion("index too large");
    _jump1426:;
    int64_t _156 = 0;
    _156 *= _137.d0;
    _156 += _154;
    _156 *= _137.d1;
    _156 += f;
    _156 *= _137.d2;
    _156 += _155;
    int64_t _157 = _137.data[_156];
    _136.d1 = _157;
    if (_157 > 0) 
    goto _jump1427;
    fail_assertion("non-positive loop bound");
    _jump1427:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= e;
    _158 *= _157;
    _158 *= sizeof(_a3_bool);
    _136.data = jpl_alloc(_158);
    int64_t _159 = 0; // p
    int64_t _160 = 0; // o
    _jump1428:; // Begin body of loop
    bool _161 = a;
    if (0 == a)
    goto _jump1429;
    _161 = a;
    _jump1429:;
    bool _162;
    if (!_161)
    goto _jump1430;
    bool _163 = d > e;
    _162 = _163;
    goto _jump1431;
    _jump1430:;
    bool _164 = true;
    _162 = _164;
    _jump1431:;
    int64_t _165;
    if (!_162)
    goto _jump1432;
    _165 = e;
    goto _jump1433;
    _jump1432:;
    int64_t _166 = 755;
    _165 = _166;
    _jump1433:;
    if (_165 >= 0)
    goto _jump1434;
    fail_assertion("negative array index");
    _jump1434:;
    if (_165 < _133.d0)
    goto _jump1435;
    fail_assertion("index too large");
    _jump1435:;
    int64_t _167 = 0;
    _167 *= _133.d0;
    _167 += _165;
    _a3_bool _168 = _133.data[_167];
    int64_t _169 = 0;
    _169 *= _136.d0;
    _169 += _160;
    _169 *= _136.d1;
    _169 += _159;
    _136.data[_169] = _168;
    _159++;
    if (_159 < _157)
    goto _jump1428;
    _159 = 0;
    _160++;
    if (_160 < e)
    goto _jump1428;
    // End body of loop
    if (i >= 0)
    goto _jump1436;
    fail_assertion("negative array index");
    _jump1436:;
    if (i < _136.d0)
    goto _jump1437;
    fail_assertion("index too large");
    _jump1437:;
    if (g >= 0)
    goto _jump1438;
    fail_assertion("negative array index");
    _jump1438:;
    if (g < _136.d1)
    goto _jump1439;
    fail_assertion("index too large");
    _jump1439:;
    int64_t _170 = 0;
    _170 *= _136.d0;
    _170 += i;
    _170 *= _136.d1;
    _170 += g;
    _a3_bool _171 = _136.data[_170];
    _135 = _171;
    goto _jump1440;
    _jump1409:;
    _a2__a2__a3_bool _172;
    if (!a)
    goto _jump1441;
    _a2__a2__a3_bool _173;
    // Computing bound for o
    _173.d0 = f;
    if (f > 0) 
    goto _jump1442;
    fail_assertion("non-positive loop bound");
    _jump1442:;
    // Computing bound for p
    int64_t _174;
    if (!h)
    goto _jump1443;
    _174 = i;
    goto _jump1444;
    _jump1443:;
    _174 = d;
    _jump1444:;
    _173.d1 = _174;
    if (_174 > 0) 
    goto _jump1445;
    fail_assertion("non-positive loop bound");
    _jump1445:;
    // Computing total size of heap memory to allocate
    int64_t _175 = 1;
    _175 *= f;
    _175 *= _174;
    _175 *= sizeof(_a2__a3_bool);
    _173.data = jpl_alloc(_175);
    int64_t _176 = 0; // p
    int64_t _177 = 0; // o
    _jump1446:; // Begin body of loop
    _a2__a3_bool _178;
    // Computing bound for q
    _178.d0 = f;
    if (f > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    // Computing bound for r
    _178.d1 = e;
    if (e > 0) 
    goto _jump1448;
    fail_assertion("non-positive loop bound");
    _jump1448:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= f;
    _179 *= e;
    _179 *= sizeof(_a3_bool);
    _178.data = jpl_alloc(_179);
    int64_t _180 = 0; // r
    int64_t _181 = 0; // q
    _jump1449:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _178.d0;
    _182 += _181;
    _182 *= _178.d1;
    _182 += _180;
    _178.data[_182] = c;
    _180++;
    if (_180 < e)
    goto _jump1449;
    _180 = 0;
    _181++;
    if (_181 < f)
    goto _jump1449;
    // End body of loop
    int64_t _183 = 0;
    _183 *= _173.d0;
    _183 += _177;
    _183 *= _173.d1;
    _183 += _176;
    _173.data[_183] = _178;
    _176++;
    if (_176 < _174)
    goto _jump1446;
    _176 = 0;
    _177++;
    if (_177 < f)
    goto _jump1446;
    // End body of loop
    _172 = _173;
    goto _jump1450;
    _jump1441:;
    _a2__a2__a3_bool _184;
    // Computing bound for o
    _184.d0 = i;
    if (i > 0) 
    goto _jump1451;
    fail_assertion("non-positive loop bound");
    _jump1451:;
    // Computing bound for p
    _184.d1 = g;
    if (g > 0) 
    goto _jump1452;
    fail_assertion("non-positive loop bound");
    _jump1452:;
    // Computing total size of heap memory to allocate
    int64_t _185 = 1;
    _185 *= i;
    _185 *= g;
    _185 *= sizeof(_a2__a3_bool);
    _184.data = jpl_alloc(_185);
    int64_t _186 = 0; // p
    int64_t _187 = 0; // o
    _jump1453:; // Begin body of loop
    _a2__a3_bool _188;
    if (!a)
    goto _jump1454;
    _a2__a3_bool _189;
    // Computing bound for q
    _189.d0 = g;
    if (g > 0) 
    goto _jump1455;
    fail_assertion("non-positive loop bound");
    _jump1455:;
    // Computing bound for r
    _189.d1 = _186;
    if (_186 > 0) 
    goto _jump1456;
    fail_assertion("non-positive loop bound");
    _jump1456:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= g;
    _190 *= _186;
    _190 *= sizeof(_a3_bool);
    _189.data = jpl_alloc(_190);
    int64_t _191 = 0; // r
    int64_t _192 = 0; // q
    _jump1457:; // Begin body of loop
    int64_t _193 = 0;
    _193 *= _189.d0;
    _193 += _192;
    _193 *= _189.d1;
    _193 += _191;
    _189.data[_193] = c;
    _191++;
    if (_191 < _186)
    goto _jump1457;
    _191 = 0;
    _192++;
    if (_192 < g)
    goto _jump1457;
    // End body of loop
    _188 = _189;
    goto _jump1458;
    _jump1454:;
    _a2__a3_bool _194;
    // Computing bound for q
    _194.d0 = d;
    if (d > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    // Computing bound for r
    _194.d1 = i;
    if (i > 0) 
    goto _jump1460;
    fail_assertion("non-positive loop bound");
    _jump1460:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= d;
    _195 *= i;
    _195 *= sizeof(_a3_bool);
    _194.data = jpl_alloc(_195);
    int64_t _196 = 0; // r
    int64_t _197 = 0; // q
    _jump1461:; // Begin body of loop
    int64_t _198 = 0;
    _198 *= _194.d0;
    _198 += _197;
    _198 *= _194.d1;
    _198 += _196;
    _194.data[_198] = c;
    _196++;
    if (_196 < i)
    goto _jump1461;
    _196 = 0;
    _197++;
    if (_197 < d)
    goto _jump1461;
    // End body of loop
    _188 = _194;
    _jump1458:;
    int64_t _199 = 0;
    _199 *= _184.d0;
    _199 += _187;
    _199 *= _184.d1;
    _199 += _186;
    _184.data[_199] = _188;
    _186++;
    if (_186 < g)
    goto _jump1453;
    _186 = 0;
    _187++;
    if (_187 < i)
    goto _jump1453;
    // End body of loop
    _172 = _184;
    _jump1450:;
    int64_t _200;
    // Computing bound for o
    if (g > 0) 
    goto _jump1462;
    fail_assertion("non-positive loop bound");
    _jump1462:;
    // Computing bound for p
    if (g > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing bound for q
    int64_t _201;
    // Computing bound for o
    if (i > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing bound for p
    if (g > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    // Computing bound for q
    int64_t _202;
    // Computing bound for o
    if (i > 0) 
    goto _jump1466;
    fail_assertion("non-positive loop bound");
    _jump1466:;
    // Computing bound for p
    if (g > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    _202 = 0;
    int64_t _203 = 0; // p
    int64_t _204 = 0; // o
    _jump1468:; // Begin body of loop
    _202 += _204;
    _203++;
    if (_203 < g)
    goto _jump1468;
    _203 = 0;
    _204++;
    if (_204 < i)
    goto _jump1468;
    // End body of loop
    if (_202 > 0) 
    goto _jump1469;
    fail_assertion("non-positive loop bound");
    _jump1469:;
    _201 = 0;
    int64_t _205 = 0; // q
    int64_t _206 = 0; // p
    int64_t _207 = 0; // o
    _jump1470:; // Begin body of loop
    int64_t _208 = 194;
    _201 += _208;
    _205++;
    if (_205 < _202)
    goto _jump1470;
    _205 = 0;
    _206++;
    if (_206 < g)
    goto _jump1470;
    _206 = 0;
    _207++;
    if (_207 < i)
    goto _jump1470;
    // End body of loop
    int64_t _209 = -_201;
    if (_209 > 0) 
    goto _jump1471;
    fail_assertion("non-positive loop bound");
    _jump1471:;
    _200 = 0;
    int64_t _210 = 0; // q
    int64_t _211 = 0; // p
    int64_t _212 = 0; // o
    _jump1472:; // Begin body of loop
    _200 += _210;
    _210++;
    if (_210 < _209)
    goto _jump1472;
    _210 = 0;
    _211++;
    if (_211 < g)
    goto _jump1472;
    _211 = 0;
    _212++;
    if (_212 < g)
    goto _jump1472;
    // End body of loop
    _a2_double _213;
    // Computing bound for o
    int64_t _214;
    // Computing bound for o
    if (g > 0) 
    goto _jump1473;
    fail_assertion("non-positive loop bound");
    _jump1473:;
    // Computing bound for p
    int64_t _215 = 732;
    if (_215 > 0) 
    goto _jump1474;
    fail_assertion("non-positive loop bound");
    _jump1474:;
    _214 = 0;
    int64_t _216 = 0; // p
    int64_t _217 = 0; // o
    _jump1475:; // Begin body of loop
    int64_t _218 = 546;
    _214 += _218;
    _216++;
    if (_216 < _215)
    goto _jump1475;
    _216 = 0;
    _217++;
    if (_217 < g)
    goto _jump1475;
    // End body of loop
    int64_t _219 = g / _214;
    _213.d0 = _219;
    if (_219 > 0) 
    goto _jump1476;
    fail_assertion("non-positive loop bound");
    _jump1476:;
    // Computing bound for p
    _213.d1 = f;
    if (f > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    // Computing total size of heap memory to allocate
    int64_t _220 = 1;
    _220 *= _219;
    _220 *= f;
    _220 *= sizeof(double);
    _213.data = jpl_alloc(_220);
    int64_t _221 = 0; // p
    int64_t _222 = 0; // o
    _jump1478:; // Begin body of loop
    double _223;
    // Computing bound for q
    int64_t _224 = 433;
    if (_224 > 0) 
    goto _jump1479;
    fail_assertion("non-positive loop bound");
    _jump1479:;
    _223 = 0;
    int64_t _225 = 0; // q
    _jump1480:; // Begin body of loop
    double _226 = 12.0;
    _223 += _226;
    _225++;
    if (_225 < _224)
    goto _jump1480;
    // End body of loop
    int64_t _227 = 0;
    _227 *= _213.d0;
    _227 += _222;
    _227 *= _213.d1;
    _227 += _221;
    _213.data[_227] = _223;
    _221++;
    if (_221 < f)
    goto _jump1478;
    _221 = 0;
    _222++;
    if (_222 < _219)
    goto _jump1478;
    // End body of loop
    int64_t _228 = b(_213);
    if (_200 >= 0)
    goto _jump1481;
    fail_assertion("negative array index");
    _jump1481:;
    if (_200 < _172.d0)
    goto _jump1482;
    fail_assertion("index too large");
    _jump1482:;
    if (_228 >= 0)
    goto _jump1483;
    fail_assertion("negative array index");
    _jump1483:;
    if (_228 < _172.d1)
    goto _jump1484;
    fail_assertion("index too large");
    _jump1484:;
    int64_t _229 = 0;
    _229 *= _172.d0;
    _229 += _200;
    _229 *= _172.d1;
    _229 += _228;
    _a2__a3_bool _230 = _172.data[_229];
    int64_t _231;
    if (!h)
    goto _jump1485;
    _231 = e;
    goto _jump1486;
    _jump1485:;
    bool _232 = true;
    bool _233 = !_232;
    int64_t _234;
    if (!_233)
    goto _jump1487;
    _234 = e;
    goto _jump1488;
    _jump1487:;
    _a3_int64_t _235;
    // Computing bound for o
    _235.d0 = i;
    if (i > 0) 
    goto _jump1489;
    fail_assertion("non-positive loop bound");
    _jump1489:;
    // Computing bound for p
    _235.d1 = d;
    if (d > 0) 
    goto _jump1490;
    fail_assertion("non-positive loop bound");
    _jump1490:;
    // Computing bound for q
    _235.d2 = g;
    if (g > 0) 
    goto _jump1491;
    fail_assertion("non-positive loop bound");
    _jump1491:;
    // Computing total size of heap memory to allocate
    int64_t _236 = 1;
    _236 *= i;
    _236 *= d;
    _236 *= g;
    _236 *= sizeof(int64_t);
    _235.data = jpl_alloc(_236);
    int64_t _237 = 0; // q
    int64_t _238 = 0; // p
    int64_t _239 = 0; // o
    _jump1492:; // Begin body of loop
    int64_t _240 = 0;
    _240 *= _235.d0;
    _240 += _239;
    _240 *= _235.d1;
    _240 += _238;
    _240 *= _235.d2;
    _240 += _237;
    _235.data[_240] = _238;
    _237++;
    if (_237 < g)
    goto _jump1492;
    _237 = 0;
    _238++;
    if (_238 < d)
    goto _jump1492;
    _238 = 0;
    _239++;
    if (_239 < i)
    goto _jump1492;
    // End body of loop
    bool _241 = false;
    int64_t _242;
    if (!_241)
    goto _jump1493;
    _242 = e;
    goto _jump1494;
    _jump1493:;
    _242 = g;
    _jump1494:;
    int64_t _243;
    if (!h)
    goto _jump1495;
    _243 = e;
    goto _jump1496;
    _jump1495:;
    int64_t _244 = 290;
    _243 = _244;
    _jump1496:;
    int64_t _245;
    if (!h)
    goto _jump1497;
    _245 = f;
    goto _jump1498;
    _jump1497:;
    _245 = g;
    _jump1498:;
    if (_242 >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (_242 < _235.d0)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    if (_243 >= 0)
    goto _jump1501;
    fail_assertion("negative array index");
    _jump1501:;
    if (_243 < _235.d1)
    goto _jump1502;
    fail_assertion("index too large");
    _jump1502:;
    if (_245 >= 0)
    goto _jump1503;
    fail_assertion("negative array index");
    _jump1503:;
    if (_245 < _235.d2)
    goto _jump1504;
    fail_assertion("index too large");
    _jump1504:;
    int64_t _246 = 0;
    _246 *= _235.d0;
    _246 += _242;
    _246 *= _235.d1;
    _246 += _243;
    _246 *= _235.d2;
    _246 += _245;
    int64_t _247 = _235.data[_246];
    _234 = _247;
    _jump1488:;
    _231 = _234;
    _jump1486:;
    int64_t _248 = -_231;
    if (_248 >= 0)
    goto _jump1505;
    fail_assertion("negative array index");
    _jump1505:;
    if (_248 < _230.d0)
    goto _jump1506;
    fail_assertion("index too large");
    _jump1506:;
    if (d >= 0)
    goto _jump1507;
    fail_assertion("negative array index");
    _jump1507:;
    if (d < _230.d1)
    goto _jump1508;
    fail_assertion("index too large");
    _jump1508:;
    int64_t _249 = 0;
    _249 *= _230.d0;
    _249 += _248;
    _249 *= _230.d1;
    _249 += d;
    _a3_bool _250 = _230.data[_249];
    _135 = _250;
    _jump1440:;
    double _251 = 15.0;
    _a1_double _252;
    // Computing bound for s
    _252.d0 = _135.d0;
    if (_135.d0 > 0) 
    goto _jump1509;
    fail_assertion("non-positive loop bound");
    _jump1509:;
    // Computing total size of heap memory to allocate
    int64_t _253 = 1;
    _253 *= _135.d0;
    _253 *= sizeof(double);
    _252.data = jpl_alloc(_253);
    int64_t _254 = 0; // s
    _jump1510:; // Begin body of loop
    double _255 = 94.0;
    _a1_double _256;
    _256.d0 = 1;
    _256.data = jpl_alloc(sizeof(double) * 1);
    _256.data[0] = _255;
    if (f >= 0)
    goto _jump1511;
    fail_assertion("negative array index");
    _jump1511:;
    if (f < _256.d0)
    goto _jump1512;
    fail_assertion("index too large");
    _jump1512:;
    int64_t _257 = 0;
    _257 *= _256.d0;
    _257 += f;
    double _258 = _256.data[_257];
    double _259 = 65.0;
    double _260 = _258 - _259;
    int64_t _261 = 0;
    _261 *= _252.d0;
    _261 += _254;
    _252.data[_261] = _260;
    _254++;
    if (_254 < _135.d0)
    goto _jump1510;
    // End body of loop
    if (f >= 0)
    goto _jump1513;
    fail_assertion("negative array index");
    _jump1513:;
    if (f < _252.d0)
    goto _jump1514;
    fail_assertion("index too large");
    _jump1514:;
    int64_t _262 = 0;
    _262 *= _252.d0;
    _262 += f;
    double _263 = _252.data[_262];
    bool _264 = h == a;
    bool _265;
    if (!_264)
    goto _jump1515;
    if (d >= 0)
    goto _jump1516;
    fail_assertion("negative array index");
    _jump1516:;
    if (d < c.d0)
    goto _jump1517;
    fail_assertion("index too large");
    _jump1517:;
    if (f >= 0)
    goto _jump1518;
    fail_assertion("negative array index");
    _jump1518:;
    if (f < c.d1)
    goto _jump1519;
    fail_assertion("index too large");
    _jump1519:;
    if (d >= 0)
    goto _jump1520;
    fail_assertion("negative array index");
    _jump1520:;
    if (d < c.d2)
    goto _jump1521;
    fail_assertion("index too large");
    _jump1521:;
    int64_t _266 = 0;
    _266 *= c.d0;
    _266 += d;
    _266 *= c.d1;
    _266 += f;
    _266 *= c.d2;
    _266 += d;
    bool _267 = c.data[_266];
    _265 = _267;
    goto _jump1522;
    _jump1515:;
    bool _268 = !a;
    _265 = _268;
    _jump1522:;
    bool _269 = !_265;
    bool _270 = !_269;
    double _271;
    if (!_270)
    goto _jump1523;
    bool _272 = h;
    if (0 != h)
    goto _jump1524;
    bool _273 = false;
    _272 = _273;
    _jump1524:;
    double _274;
    if (!_272)
    goto _jump1525;
    double _275 = 39.0;
    _274 = _275;
    goto _jump1526;
    _jump1525:;
    double _276 = l.g;
    _274 = _276;
    _jump1526:;
    double _277 = 39.0;
    bool _278 = false;
    void_t _279;
    if (!_278)
    goto _jump1527;
    _279 = m;
    goto _jump1528;
    _jump1527:;
    _279 = m;
    _jump1528:;
    double _280 = k(l, _279);
    double _281 = 11.0;
    rgba _282 = { _274, _277, _280, _281 };
    double _283 = _282.b;
    _271 = _283;
    goto _jump1529;
    _jump1523:;
    bool _284 = false;
    bool _285 = !_284;
    double _286;
    if (!_285)
    goto _jump1530;
    _a3_void_t _287;
    // Computing bound for s
    _287.d0 = e;
    if (e > 0) 
    goto _jump1531;
    fail_assertion("non-positive loop bound");
    _jump1531:;
    // Computing bound for t
    _287.d1 = d;
    if (d > 0) 
    goto _jump1532;
    fail_assertion("non-positive loop bound");
    _jump1532:;
    // Computing bound for u
    _287.d2 = e;
    if (e > 0) 
    goto _jump1533;
    fail_assertion("non-positive loop bound");
    _jump1533:;
    // Computing total size of heap memory to allocate
    int64_t _288 = 1;
    _288 *= e;
    _288 *= d;
    _288 *= e;
    _288 *= sizeof(void_t);
    _287.data = jpl_alloc(_288);
    int64_t _289 = 0; // u
    int64_t _290 = 0; // t
    int64_t _291 = 0; // s
    _jump1534:; // Begin body of loop
    int64_t _292 = 0;
    _292 *= _287.d0;
    _292 += _291;
    _292 *= _287.d1;
    _292 += _290;
    _292 *= _287.d2;
    _292 += _289;
    _287.data[_292] = m;
    _289++;
    if (_289 < e)
    goto _jump1534;
    _289 = 0;
    _290++;
    if (_290 < d)
    goto _jump1534;
    _290 = 0;
    _291++;
    if (_291 < e)
    goto _jump1534;
    // End body of loop
    int64_t _293;
    // Computing bound for s
    if (e > 0) 
    goto _jump1535;
    fail_assertion("non-positive loop bound");
    _jump1535:;
    _293 = 0;
    int64_t _294 = 0; // s
    _jump1536:; // Begin body of loop
    _293 += f;
    _294++;
    if (_294 < e)
    goto _jump1536;
    // End body of loop
    if (_293 >= 0)
    goto _jump1537;
    fail_assertion("negative array index");
    _jump1537:;
    if (_293 < _287.d0)
    goto _jump1538;
    fail_assertion("index too large");
    _jump1538:;
    if (g >= 0)
    goto _jump1539;
    fail_assertion("negative array index");
    _jump1539:;
    if (g < _287.d1)
    goto _jump1540;
    fail_assertion("index too large");
    _jump1540:;
    if (f >= 0)
    goto _jump1541;
    fail_assertion("negative array index");
    _jump1541:;
    if (f < _287.d2)
    goto _jump1542;
    fail_assertion("index too large");
    _jump1542:;
    int64_t _295 = 0;
    _295 *= _287.d0;
    _295 += _293;
    _295 *= _287.d1;
    _295 += g;
    _295 *= _287.d2;
    _295 += f;
    void_t _296 = _287.data[_295];
    double _297 = k(l, _296);
    _286 = _297;
    goto _jump1543;
    _jump1530:;
    double _298 = 38.0;
    double _299 = -_298;
    double _300 = -_299;
    _286 = _300;
    _jump1543:;
    _271 = _286;
    _jump1529:;
    _a1_rgba _301;
    // Computing bound for s
    _301.d0 = f;
    if (f > 0) 
    goto _jump1544;
    fail_assertion("non-positive loop bound");
    _jump1544:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= f;
    _302 *= sizeof(rgba);
    _301.data = jpl_alloc(_302);
    int64_t _303 = 0; // s
    _jump1545:; // Begin body of loop
    int64_t _304 = 0;
    _304 *= _301.d0;
    _304 += _303;
    _301.data[_304] = l;
    _303++;
    if (_303 < f)
    goto _jump1545;
    // End body of loop
    if (f >= 0)
    goto _jump1546;
    fail_assertion("negative array index");
    _jump1546:;
    if (f < _301.d0)
    goto _jump1547;
    fail_assertion("index too large");
    _jump1547:;
    int64_t _305 = 0;
    _305 *= _301.d0;
    _305 += f;
    rgba _306 = _301.data[_305];
    double _307 = _306.g;
    _a3_double _308;
    // Computing bound for s
    int64_t _309 = -_135.d2;
    _308.d0 = _309;
    if (_309 > 0) 
    goto _jump1548;
    fail_assertion("non-positive loop bound");
    _jump1548:;
    // Computing bound for t
    int64_t _310 = 643;
    _308.d1 = _310;
    if (_310 > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    // Computing bound for u
    _308.d2 = d;
    if (d > 0) 
    goto _jump1550;
    fail_assertion("non-positive loop bound");
    _jump1550:;
    // Computing total size of heap memory to allocate
    int64_t _311 = 1;
    _311 *= _309;
    _311 *= _310;
    _311 *= d;
    _311 *= sizeof(double);
    _308.data = jpl_alloc(_311);
    int64_t _312 = 0; // u
    int64_t _313 = 0; // t
    int64_t _314 = 0; // s
    _jump1551:; // Begin body of loop
    double _315;
    // Computing bound for v
    if (i > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing bound for w
    int64_t _316;
    // Computing bound for v
    if (g > 0) 
    goto _jump1553;
    fail_assertion("non-positive loop bound");
    _jump1553:;
    // Computing bound for w
    if (_135.d0 > 0) 
    goto _jump1554;
    fail_assertion("non-positive loop bound");
    _jump1554:;
    _316 = 0;
    int64_t _317 = 0; // w
    int64_t _318 = 0; // v
    _jump1555:; // Begin body of loop
    _316 += _317;
    _317++;
    if (_317 < _135.d0)
    goto _jump1555;
    _317 = 0;
    _318++;
    if (_318 < g)
    goto _jump1555;
    // End body of loop
    if (_316 > 0) 
    goto _jump1556;
    fail_assertion("non-positive loop bound");
    _jump1556:;
    // Computing bound for x
    if (_135.d2 > 0) 
    goto _jump1557;
    fail_assertion("non-positive loop bound");
    _jump1557:;
    _315 = 0;
    int64_t _319 = 0; // x
    int64_t _320 = 0; // w
    int64_t _321 = 0; // v
    _jump1558:; // Begin body of loop
    double _322 = 62.0;
    _315 += _322;
    _319++;
    if (_319 < _135.d2)
    goto _jump1558;
    _319 = 0;
    _320++;
    if (_320 < _316)
    goto _jump1558;
    _320 = 0;
    _321++;
    if (_321 < i)
    goto _jump1558;
    // End body of loop
    int64_t _323 = 0;
    _323 *= _308.d0;
    _323 += _314;
    _323 *= _308.d1;
    _323 += _313;
    _323 *= _308.d2;
    _323 += _312;
    _308.data[_323] = _315;
    _312++;
    if (_312 < d)
    goto _jump1551;
    _312 = 0;
    _313++;
    if (_313 < _310)
    goto _jump1551;
    _313 = 0;
    _314++;
    if (_314 < _309)
    goto _jump1551;
    // End body of loop
    int64_t _324 = -_135.d1;
    _a1_int64_t _325;
    _325.d0 = 2;
    _325.data = jpl_alloc(sizeof(int64_t) * 2);
    _325.data[0] = _324;
    _325.data[1] = _135.d2;
    int64_t _326 = i / _135.d0;
    int64_t _327 = -_326;
    if (_327 >= 0)
    goto _jump1559;
    fail_assertion("negative array index");
    _jump1559:;
    if (_327 < _325.d0)
    goto _jump1560;
    fail_assertion("index too large");
    _jump1560:;
    int64_t _328 = 0;
    _328 *= _325.d0;
    _328 += _327;
    int64_t _329 = _325.data[_328];
    _a1_int64_t _330;
    _330.d0 = 2;
    _330.data = jpl_alloc(sizeof(int64_t) * 2);
    _330.data[0] = _135.d1;
    _330.data[1] = e;
    if (_135.d1 >= 0)
    goto _jump1561;
    fail_assertion("negative array index");
    _jump1561:;
    if (_135.d1 < _330.d0)
    goto _jump1562;
    fail_assertion("index too large");
    _jump1562:;
    int64_t _331 = 0;
    _331 *= _330.d0;
    _331 += _135.d1;
    int64_t _332 = _330.data[_331];
    if (_329 >= 0)
    goto _jump1563;
    fail_assertion("negative array index");
    _jump1563:;
    if (_329 < _308.d0)
    goto _jump1564;
    fail_assertion("index too large");
    _jump1564:;
    if (e >= 0)
    goto _jump1565;
    fail_assertion("negative array index");
    _jump1565:;
    if (e < _308.d1)
    goto _jump1566;
    fail_assertion("index too large");
    _jump1566:;
    if (_332 >= 0)
    goto _jump1567;
    fail_assertion("negative array index");
    _jump1567:;
    if (_332 < _308.d2)
    goto _jump1568;
    fail_assertion("index too large");
    _jump1568:;
    int64_t _333 = 0;
    _333 *= _308.d0;
    _333 += _329;
    _333 *= _308.d1;
    _333 += e;
    _333 *= _308.d2;
    _333 += _332;
    double _334 = _308.data[_333];
    double _335 = _307 * _334;
    rgba _336 = { _251, _263, _271, _335 };
    double _337 = k(_336, m);
    _a3_double _338;
    // Computing bound for t
    _a3__a2_double _339;
    // Computing bound for t
    int64_t _340;
    if (!a)
    goto _jump1569;
    int64_t _341 = 366;
    _340 = _341;
    goto _jump1570;
    _jump1569:;
    _340 = f;
    _jump1570:;
    int64_t _342 = _340 * d;
    _339.d0 = _342;
    if (_342 > 0) 
    goto _jump1571;
    fail_assertion("non-positive loop bound");
    _jump1571:;
    // Computing bound for u
    _339.d1 = f;
    if (f > 0) 
    goto _jump1572;
    fail_assertion("non-positive loop bound");
    _jump1572:;
    // Computing bound for v
    int64_t _343 = -_135.d1;
    _339.d2 = _343;
    if (_343 > 0) 
    goto _jump1573;
    fail_assertion("non-positive loop bound");
    _jump1573:;
    // Computing total size of heap memory to allocate
    int64_t _344 = 1;
    _344 *= _342;
    _344 *= f;
    _344 *= _343;
    _344 *= sizeof(_a2_double);
    _339.data = jpl_alloc(_344);
    int64_t _345 = 0; // v
    int64_t _346 = 0; // u
    int64_t _347 = 0; // t
    _jump1574:; // Begin body of loop
    _a2_double _348;
    // Computing bound for w
    _348.d0 = f;
    if (f > 0) 
    goto _jump1575;
    fail_assertion("non-positive loop bound");
    _jump1575:;
    // Computing bound for x
    _348.d1 = _135.d0;
    if (_135.d0 > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= f;
    _349 *= _135.d0;
    _349 *= sizeof(double);
    _348.data = jpl_alloc(_349);
    int64_t _350 = 0; // x
    int64_t _351 = 0; // w
    _jump1577:; // Begin body of loop
    double _352 = 20.0;
    int64_t _353 = 0;
    _353 *= _348.d0;
    _353 += _351;
    _353 *= _348.d1;
    _353 += _350;
    _348.data[_353] = _352;
    _350++;
    if (_350 < _135.d0)
    goto _jump1577;
    _350 = 0;
    _351++;
    if (_351 < f)
    goto _jump1577;
    // End body of loop
    int64_t _354 = 0;
    _354 *= _339.d0;
    _354 += _347;
    _354 *= _339.d1;
    _354 += _346;
    _354 *= _339.d2;
    _354 += _345;
    _339.data[_354] = _348;
    _345++;
    if (_345 < _343)
    goto _jump1574;
    _345 = 0;
    _346++;
    if (_346 < f)
    goto _jump1574;
    _346 = 0;
    _347++;
    if (_347 < _342)
    goto _jump1574;
    // End body of loop
    if (_135.d1 >= 0)
    goto _jump1578;
    fail_assertion("negative array index");
    _jump1578:;
    if (_135.d1 < _339.d0)
    goto _jump1579;
    fail_assertion("index too large");
    _jump1579:;
    if (e >= 0)
    goto _jump1580;
    fail_assertion("negative array index");
    _jump1580:;
    if (e < _339.d1)
    goto _jump1581;
    fail_assertion("index too large");
    _jump1581:;
    if (i >= 0)
    goto _jump1582;
    fail_assertion("negative array index");
    _jump1582:;
    if (i < _339.d2)
    goto _jump1583;
    fail_assertion("index too large");
    _jump1583:;
    int64_t _355 = 0;
    _355 *= _339.d0;
    _355 += _135.d1;
    _355 *= _339.d1;
    _355 += e;
    _355 *= _339.d2;
    _355 += i;
    _a2_double _356 = _339.data[_355];
    int64_t _357 = b(_356);
    int64_t _358 = _135.d2 * _357;
    _338.d0 = _358;
    if (_358 > 0) 
    goto _jump1584;
    fail_assertion("non-positive loop bound");
    _jump1584:;
    // Computing bound for u
    _a1_int64_t _359;
    // Computing bound for t
    int64_t _360 = 772;
    _359.d0 = _360;
    if (_360 > 0) 
    goto _jump1585;
    fail_assertion("non-positive loop bound");
    _jump1585:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= _360;
    _361 *= sizeof(int64_t);
    _359.data = jpl_alloc(_361);
    int64_t _362 = 0; // t
    _jump1586:; // Begin body of loop
    int64_t _363 = _135.d1 * d;
    int64_t _364 = _363 / _135.d1;
    int64_t _365 = 0;
    _365 *= _359.d0;
    _365 += _362;
    _359.data[_365] = _364;
    _362++;
    if (_362 < _360)
    goto _jump1586;
    // End body of loop
    int64_t _366;
    if (!a)
    goto _jump1587;
    _366 = g;
    goto _jump1588;
    _jump1587:;
    int64_t _367 = _135.d2 % i;
    _366 = _367;
    _jump1588:;
    _a1_int64_t _368;
    _368.d0 = 1;
    _368.data = jpl_alloc(sizeof(int64_t) * 1);
    _368.data[0] = f;
    if (_135.d1 >= 0)
    goto _jump1589;
    fail_assertion("negative array index");
    _jump1589:;
    if (_135.d1 < _368.d0)
    goto _jump1590;
    fail_assertion("index too large");
    _jump1590:;
    int64_t _369 = 0;
    _369 *= _368.d0;
    _369 += _135.d1;
    int64_t _370 = _368.data[_369];
    _a1_int64_t _371;
    _371.d0 = 3;
    _371.data = jpl_alloc(sizeof(int64_t) * 3);
    _371.data[0] = _366;
    _371.data[1] = _370;
    _371.data[2] = _135.d1;
    int64_t _372 = 593;
    int64_t _373 = _135.d0 * g;
    int64_t _374 = _372 / _373;
    if (_374 >= 0)
    goto _jump1591;
    fail_assertion("negative array index");
    _jump1591:;
    if (_374 < _371.d0)
    goto _jump1592;
    fail_assertion("index too large");
    _jump1592:;
    int64_t _375 = 0;
    _375 *= _371.d0;
    _375 += _374;
    int64_t _376 = _371.data[_375];
    if (_376 >= 0)
    goto _jump1593;
    fail_assertion("negative array index");
    _jump1593:;
    if (_376 < _359.d0)
    goto _jump1594;
    fail_assertion("index too large");
    _jump1594:;
    int64_t _377 = 0;
    _377 *= _359.d0;
    _377 += _376;
    int64_t _378 = _359.data[_377];
    int64_t _379 = -_378;
    _338.d1 = _379;
    if (_379 > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing bound for v
    bool _380;
    if (!a)
    goto _jump1596;
    _380 = h;
    goto _jump1597;
    _jump1596:;
    double _381 = k(l, m);
    _a3_double _382;
    // Computing bound for t
    _382.d0 = i;
    if (i > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    // Computing bound for u
    _382.d1 = _135.d0;
    if (_135.d0 > 0) 
    goto _jump1599;
    fail_assertion("non-positive loop bound");
    _jump1599:;
    // Computing bound for v
    _382.d2 = i;
    if (i > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing total size of heap memory to allocate
    int64_t _383 = 1;
    _383 *= i;
    _383 *= _135.d0;
    _383 *= i;
    _383 *= sizeof(double);
    _382.data = jpl_alloc(_383);
    int64_t _384 = 0; // v
    int64_t _385 = 0; // u
    int64_t _386 = 0; // t
    _jump1601:; // Begin body of loop
    int64_t _387 = 0;
    _387 *= _382.d0;
    _387 += _386;
    _387 *= _382.d1;
    _387 += _385;
    _387 *= _382.d2;
    _387 += _384;
    _382.data[_387] = _337;
    _384++;
    if (_384 < i)
    goto _jump1601;
    _384 = 0;
    _385++;
    if (_385 < _135.d0)
    goto _jump1601;
    _385 = 0;
    _386++;
    if (_386 < i)
    goto _jump1601;
    // End body of loop
    if (_135.d1 >= 0)
    goto _jump1602;
    fail_assertion("negative array index");
    _jump1602:;
    if (_135.d1 < _382.d0)
    goto _jump1603;
    fail_assertion("index too large");
    _jump1603:;
    if (d >= 0)
    goto _jump1604;
    fail_assertion("negative array index");
    _jump1604:;
    if (d < _382.d1)
    goto _jump1605;
    fail_assertion("index too large");
    _jump1605:;
    if (d >= 0)
    goto _jump1606;
    fail_assertion("negative array index");
    _jump1606:;
    if (d < _382.d2)
    goto _jump1607;
    fail_assertion("index too large");
    _jump1607:;
    int64_t _388 = 0;
    _388 *= _382.d0;
    _388 += _135.d1;
    _388 *= _382.d1;
    _388 += d;
    _388 *= _382.d2;
    _388 += d;
    double _389 = _382.data[_388];
    bool _390 = _381 == _389;
    bool _391;
    if (!_390)
    goto _jump1608;
    bool _392;
    if (!a)
    goto _jump1609;
    int64_t _393 = 191;
    bool _394 = _393 >= i;
    _392 = _394;
    goto _jump1610;
    _jump1609:;
    bool _395 = !a;
    _392 = _395;
    _jump1610:;
    bool _396;
    if (!_392)
    goto _jump1611;
    bool _397 = h;
    if (0 == h)
    goto _jump1612;
    bool _398 = false;
    _397 = _398;
    _jump1612:;
    _396 = _397;
    goto _jump1613;
    _jump1611:;
    _396 = a;
    _jump1613:;
    _391 = _396;
    goto _jump1614;
    _jump1608:;
    bool _399 = true;
    _391 = _399;
    _jump1614:;
    _380 = _391;
    _jump1597:;
    int64_t _400;
    if (!_380)
    goto _jump1615;
    _400 = _135.d0;
    goto _jump1616;
    _jump1615:;
    int64_t _401 = e / _135.d2;
    _400 = _401;
    _jump1616:;
    _338.d2 = _400;
    if (_400 > 0) 
    goto _jump1617;
    fail_assertion("non-positive loop bound");
    _jump1617:;
    // Computing total size of heap memory to allocate
    int64_t _402 = 1;
    _402 *= _358;
    _402 *= _379;
    _402 *= _400;
    _402 *= sizeof(double);
    _338.data = jpl_alloc(_402);
    int64_t _403 = 0; // v
    int64_t _404 = 0; // u
    int64_t _405 = 0; // t
    _jump1618:; // Begin body of loop
    _a2_double _406;
    // Computing bound for w
    bool _407 = !h;
    bool _408 = !_407;
    int64_t _409;
    if (!_408)
    goto _jump1619;
    _409 = g;
    goto _jump1620;
    _jump1619:;
    int64_t _410;
    // Computing bound for w
    if (_403 > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    // Computing bound for x
    int64_t _411 = 870;
    if (_411 > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    _410 = 0;
    int64_t _412 = 0; // x
    int64_t _413 = 0; // w
    _jump1623:; // Begin body of loop
    bool _414 = false;
    int64_t _415;
    if (!_414)
    goto _jump1624;
    _415 = i;
    goto _jump1625;
    _jump1624:;
    _415 = _413;
    _jump1625:;
    int64_t _416 = _135.d0 * _415;
    _410 += _416;
    _412++;
    if (_412 < _411)
    goto _jump1623;
    _412 = 0;
    _413++;
    if (_413 < _403)
    goto _jump1623;
    // End body of loop
    _409 = _410;
    _jump1620:;
    _406.d0 = _409;
    if (_409 > 0) 
    goto _jump1626;
    fail_assertion("non-positive loop bound");
    _jump1626:;
    // Computing bound for x
    _406.d1 = _135.d2;
    if (_135.d2 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing total size of heap memory to allocate
    int64_t _417 = 1;
    _417 *= _409;
    _417 *= _135.d2;
    _417 *= sizeof(double);
    _406.data = jpl_alloc(_417);
    int64_t _418 = 0; // x
    int64_t _419 = 0; // w
    _jump1628:; // Begin body of loop
    double _420 = 81.0;
    int64_t _421 = 0;
    _421 *= _406.d0;
    _421 += _419;
    _421 *= _406.d1;
    _421 += _418;
    _406.data[_421] = _420;
    _418++;
    if (_418 < _135.d2)
    goto _jump1628;
    _418 = 0;
    _419++;
    if (_419 < _409)
    goto _jump1628;
    // End body of loop
    _a1_rgba _422;
    // Computing bound for w
    _422.d0 = g;
    if (g > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing total size of heap memory to allocate
    int64_t _423 = 1;
    _423 *= g;
    _423 *= sizeof(rgba);
    _422.data = jpl_alloc(_423);
    int64_t _424 = 0; // w
    _jump1630:; // Begin body of loop
    rgba _425;
    if (!a)
    goto _jump1631;
    _425 = l;
    goto _jump1632;
    _jump1631:;
    _425 = l;
    _jump1632:;
    int64_t _426 = 0;
    _426 *= _422.d0;
    _426 += _424;
    _422.data[_426] = _425;
    _424++;
    if (_424 < g)
    goto _jump1630;
    // End body of loop
    int64_t _427 = -_404;
    int64_t _428 = 587;
    int64_t _429 = -_428;
    int64_t _430 = _427 - _429;
    if (_430 >= 0)
    goto _jump1633;
    fail_assertion("negative array index");
    _jump1633:;
    if (_430 < _422.d0)
    goto _jump1634;
    fail_assertion("index too large");
    _jump1634:;
    int64_t _431 = 0;
    _431 *= _422.d0;
    _431 += _430;
    rgba _432 = _422.data[_431];
    double _433 = _432.b;
    double _434 = -_337;
    double _435 = -_434;
    _a1_double _436;
    // Computing bound for w
    double _437 = 92.0;
    bool _438 = _337 <= _437;
    int64_t _439;
    if (!_438)
    goto _jump1635;
    _439 = i;
    goto _jump1636;
    _jump1635:;
    _439 = _403;
    _jump1636:;
    _436.d0 = _439;
    if (_439 > 0) 
    goto _jump1637;
    fail_assertion("non-positive loop bound");
    _jump1637:;
    // Computing total size of heap memory to allocate
    int64_t _440 = 1;
    _440 *= _439;
    _440 *= sizeof(double);
    _436.data = jpl_alloc(_440);
    int64_t _441 = 0; // w
    _jump1638:; // Begin body of loop
    double _442 = 77.0;
    int64_t _443 = 0;
    _443 *= _436.d0;
    _443 += _441;
    _436.data[_443] = _442;
    _441++;
    if (_441 < _439)
    goto _jump1638;
    // End body of loop
    if (_135.d2 >= 0)
    goto _jump1639;
    fail_assertion("negative array index");
    _jump1639:;
    if (_135.d2 < _436.d0)
    goto _jump1640;
    fail_assertion("index too large");
    _jump1640:;
    int64_t _444 = 0;
    _444 *= _436.d0;
    _444 += _135.d2;
    double _445 = _436.data[_444];
    double _446 = -_337;
    rgba _447 = { _433, _435, _445, _446 };
    _a1_void_t _448;
    // Computing bound for w
    int64_t _449;
    if (!a)
    goto _jump1641;
    _449 = _135.d0;
    goto _jump1642;
    _jump1641:;
    _449 = _135.d0;
    _jump1642:;
    _448.d0 = _449;
    if (_449 > 0) 
    goto _jump1643;
    fail_assertion("non-positive loop bound");
    _jump1643:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= _449;
    _450 *= sizeof(void_t);
    _448.data = jpl_alloc(_450);
    int64_t _451 = 0; // w
    _jump1644:; // Begin body of loop
    _a3_void_t _452;
    // Computing bound for x
    _452.d0 = f;
    if (f > 0) 
    goto _jump1645;
    fail_assertion("non-positive loop bound");
    _jump1645:;
    // Computing bound for y
    _452.d1 = e;
    if (e > 0) 
    goto _jump1646;
    fail_assertion("non-positive loop bound");
    _jump1646:;
    // Computing bound for z
    int64_t _453 = 553;
    _452.d2 = _453;
    if (_453 > 0) 
    goto _jump1647;
    fail_assertion("non-positive loop bound");
    _jump1647:;
    // Computing total size of heap memory to allocate
    int64_t _454 = 1;
    _454 *= f;
    _454 *= e;
    _454 *= _453;
    _454 *= sizeof(void_t);
    _452.data = jpl_alloc(_454);
    int64_t _455 = 0; // z
    int64_t _456 = 0; // y
    int64_t _457 = 0; // x
    _jump1648:; // Begin body of loop
    int64_t _458 = 0;
    _458 *= _452.d0;
    _458 += _457;
    _458 *= _452.d1;
    _458 += _456;
    _458 *= _452.d2;
    _458 += _455;
    _452.data[_458] = m;
    _455++;
    if (_455 < _453)
    goto _jump1648;
    _455 = 0;
    _456++;
    if (_456 < e)
    goto _jump1648;
    _456 = 0;
    _457++;
    if (_457 < f)
    goto _jump1648;
    // End body of loop
    int64_t _459 = 913;
    bool _460 = _135.d1 >= _459;
    int64_t _461;
    if (!_460)
    goto _jump1649;
    _461 = _451;
    goto _jump1650;
    _jump1649:;
    _461 = f;
    _jump1650:;
    if (_405 >= 0)
    goto _jump1651;
    fail_assertion("negative array index");
    _jump1651:;
    if (_405 < _452.d0)
    goto _jump1652;
    fail_assertion("index too large");
    _jump1652:;
    if (_405 >= 0)
    goto _jump1653;
    fail_assertion("negative array index");
    _jump1653:;
    if (_405 < _452.d1)
    goto _jump1654;
    fail_assertion("index too large");
    _jump1654:;
    if (_461 >= 0)
    goto _jump1655;
    fail_assertion("negative array index");
    _jump1655:;
    if (_461 < _452.d2)
    goto _jump1656;
    fail_assertion("index too large");
    _jump1656:;
    int64_t _462 = 0;
    _462 *= _452.d0;
    _462 += _405;
    _462 *= _452.d1;
    _462 += _405;
    _462 *= _452.d2;
    _462 += _461;
    void_t _463 = _452.data[_462];
    int64_t _464 = 0;
    _464 *= _448.d0;
    _464 += _451;
    _448.data[_464] = _463;
    _451++;
    if (_451 < _449)
    goto _jump1644;
    // End body of loop
    if (g >= 0)
    goto _jump1657;
    fail_assertion("negative array index");
    _jump1657:;
    if (g < _448.d0)
    goto _jump1658;
    fail_assertion("index too large");
    _jump1658:;
    int64_t _465 = 0;
    _465 *= _448.d0;
    _465 += g;
    void_t _466 = _448.data[_465];
    double _467 = j(_406, _447, _466);
    int64_t _468 = 0;
    _468 *= _338.d0;
    _468 += _405;
    _468 *= _338.d1;
    _468 += _404;
    _468 *= _338.d2;
    _468 += _403;
    _338.data[_468] = _467;
    _403++;
    if (_403 < _400)
    goto _jump1618;
    _403 = 0;
    _404++;
    if (_404 < _379)
    goto _jump1618;
    _404 = 0;
    _405++;
    if (_405 < _358)
    goto _jump1618;
    // End body of loop
    _a3__a3_double _469;
    // Computing bound for u
    _a1_bool _470;
    // Computing bound for u
    _470.d0 = d;
    if (d > 0) 
    goto _jump1659;
    fail_assertion("non-positive loop bound");
    _jump1659:;
    // Computing total size of heap memory to allocate
    int64_t _471 = 1;
    _471 *= d;
    _471 *= sizeof(bool);
    _470.data = jpl_alloc(_471);
    int64_t _472 = 0; // u
    _jump1660:; // Begin body of loop
    bool _473 = true;
    int64_t _474 = 0;
    _474 *= _470.d0;
    _474 += _472;
    _470.data[_474] = _473;
    _472++;
    if (_472 < d)
    goto _jump1660;
    // End body of loop
    if (_135.d1 >= 0)
    goto _jump1661;
    fail_assertion("negative array index");
    _jump1661:;
    if (_135.d1 < _135.d0)
    goto _jump1662;
    fail_assertion("index too large");
    _jump1662:;
    if (g >= 0)
    goto _jump1663;
    fail_assertion("negative array index");
    _jump1663:;
    if (g < _135.d1)
    goto _jump1664;
    fail_assertion("index too large");
    _jump1664:;
    if (d >= 0)
    goto _jump1665;
    fail_assertion("negative array index");
    _jump1665:;
    if (d < _135.d2)
    goto _jump1666;
    fail_assertion("index too large");
    _jump1666:;
    int64_t _475 = 0;
    _475 *= _135.d0;
    _475 += _135.d1;
    _475 *= _135.d1;
    _475 += g;
    _475 *= _135.d2;
    _475 += d;
    bool _476 = _135.data[_475];
    _a1_bool _477;
    if (!_476)
    goto _jump1667;
    _a1_bool _478;
    _478.d0 = 1;
    _478.data = jpl_alloc(sizeof(bool) * 1);
    _478.data[0] = h;
    _477 = _478;
    goto _jump1668;
    _jump1667:;
    _a1_bool _479;
    // Computing bound for u
    _479.d0 = _135.d1;
    if (_135.d1 > 0) 
    goto _jump1669;
    fail_assertion("non-positive loop bound");
    _jump1669:;
    // Computing total size of heap memory to allocate
    int64_t _480 = 1;
    _480 *= _135.d1;
    _480 *= sizeof(bool);
    _479.data = jpl_alloc(_480);
    int64_t _481 = 0; // u
    _jump1670:; // Begin body of loop
    int64_t _482 = 0;
    _482 *= _479.d0;
    _482 += _481;
    _479.data[_482] = a;
    _481++;
    if (_481 < _135.d1)
    goto _jump1670;
    // End body of loop
    _477 = _479;
    _jump1668:;
    _a1__a1_bool _483;
    _483.d0 = 2;
    _483.data = jpl_alloc(sizeof(_a1_bool) * 2);
    _483.data[0] = _470;
    _483.data[1] = _477;
    if (g >= 0)
    goto _jump1671;
    fail_assertion("negative array index");
    _jump1671:;
    if (g < _483.d0)
    goto _jump1672;
    fail_assertion("index too large");
    _jump1672:;
    int64_t _484 = 0;
    _484 *= _483.d0;
    _484 += g;
    _a1_bool _485 = _483.data[_484];
    int64_t _486;
    // Computing bound for u
    if (_135.d2 > 0) 
    goto _jump1673;
    fail_assertion("non-positive loop bound");
    _jump1673:;
    // Computing bound for v
    if (i > 0) 
    goto _jump1674;
    fail_assertion("non-positive loop bound");
    _jump1674:;
    // Computing bound for w
    if (_135.d1 > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    _486 = 0;
    int64_t _487 = 0; // w
    int64_t _488 = 0; // v
    int64_t _489 = 0; // u
    _jump1676:; // Begin body of loop
    int64_t _490 = 431;
    _486 += _490;
    _487++;
    if (_487 < _135.d1)
    goto _jump1676;
    _487 = 0;
    _488++;
    if (_488 < i)
    goto _jump1676;
    _488 = 0;
    _489++;
    if (_489 < _135.d2)
    goto _jump1676;
    // End body of loop
    if (_486 >= 0)
    goto _jump1677;
    fail_assertion("negative array index");
    _jump1677:;
    if (_486 < _485.d0)
    goto _jump1678;
    fail_assertion("index too large");
    _jump1678:;
    int64_t _491 = 0;
    _491 *= _485.d0;
    _491 += _486;
    bool _492 = _485.data[_491];
    int64_t _493;
    if (!_492)
    goto _jump1679;
    _493 = i;
    goto _jump1680;
    _jump1679:;
    _a2_double _494;
    // Computing bound for u
    double _495 = k(l, m);
    double _496 = l.a;
    bool _497 = _495 != _496;
    int64_t _498;
    if (!_497)
    goto _jump1681;
    int64_t _499;
    // Computing bound for u
    int64_t _500 = 822;
    if (_500 > 0) 
    goto _jump1682;
    fail_assertion("non-positive loop bound");
    _jump1682:;
    // Computing bound for v
    if (_135.d0 > 0) 
    goto _jump1683;
    fail_assertion("non-positive loop bound");
    _jump1683:;
    _499 = 0;
    int64_t _501 = 0; // v
    int64_t _502 = 0; // u
    _jump1684:; // Begin body of loop
    _499 += _502;
    _501++;
    if (_501 < _135.d0)
    goto _jump1684;
    _501 = 0;
    _502++;
    if (_502 < _500)
    goto _jump1684;
    // End body of loop
    _498 = _499;
    goto _jump1685;
    _jump1681:;
    _498 = i;
    _jump1685:;
    _494.d0 = _498;
    if (_498 > 0) 
    goto _jump1686;
    fail_assertion("non-positive loop bound");
    _jump1686:;
    // Computing bound for v
    _494.d1 = d;
    if (d > 0) 
    goto _jump1687;
    fail_assertion("non-positive loop bound");
    _jump1687:;
    // Computing total size of heap memory to allocate
    int64_t _503 = 1;
    _503 *= _498;
    _503 *= d;
    _503 *= sizeof(double);
    _494.data = jpl_alloc(_503);
    int64_t _504 = 0; // v
    int64_t _505 = 0; // u
    _jump1688:; // Begin body of loop
    double _506;
    if (!a)
    goto _jump1689;
    double _507 = 76.0;
    _506 = _507;
    goto _jump1690;
    _jump1689:;
    double _508 = k(l, m);
    _506 = _508;
    _jump1690:;
    int64_t _509 = 0;
    _509 *= _494.d0;
    _509 += _505;
    _509 *= _494.d1;
    _509 += _504;
    _494.data[_509] = _506;
    _504++;
    if (_504 < d)
    goto _jump1688;
    _504 = 0;
    _505++;
    if (_505 < _498)
    goto _jump1688;
    // End body of loop
    int64_t _510 = b(_494);
    _493 = _510;
    _jump1680:;
    _469.d0 = _493;
    if (_493 > 0) 
    goto _jump1691;
    fail_assertion("non-positive loop bound");
    _jump1691:;
    // Computing bound for v
    _469.d1 = _135.d0;
    if (_135.d0 > 0) 
    goto _jump1692;
    fail_assertion("non-positive loop bound");
    _jump1692:;
    // Computing bound for w
    _469.d2 = d;
    if (d > 0) 
    goto _jump1693;
    fail_assertion("non-positive loop bound");
    _jump1693:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= _493;
    _511 *= _135.d0;
    _511 *= d;
    _511 *= sizeof(_a3_double);
    _469.data = jpl_alloc(_511);
    int64_t _512 = 0; // w
    int64_t _513 = 0; // v
    int64_t _514 = 0; // u
    _jump1694:; // Begin body of loop
    int64_t _515 = 0;
    _515 *= _469.d0;
    _515 += _514;
    _515 *= _469.d1;
    _515 += _513;
    _515 *= _469.d2;
    _515 += _512;
    _469.data[_515] = _338;
    _512++;
    if (_512 < d)
    goto _jump1694;
    _512 = 0;
    _513++;
    if (_513 < _135.d0)
    goto _jump1694;
    _513 = 0;
    _514++;
    if (_514 < _493)
    goto _jump1694;
    // End body of loop
    bool _516 = false;
    void_t _517;
    if (!_516)
    goto _jump1695;
    _517 = m;
    goto _jump1696;
    _jump1695:;
    _517 = m;
    _jump1696:;
    double _518 = k(l, _517);
    bool _519 = _337 > _518;
    _a1_int64_t _520;
    if (!_519)
    goto _jump1697;
    _a2__a1_int64_t _521;
    // Computing bound for y
    int64_t _522 = -g;
    _521.d0 = _522;
    if (_522 > 0) 
    goto _jump1698;
    fail_assertion("non-positive loop bound");
    _jump1698:;
    // Computing bound for z
    _521.d1 = _469.d2;
    if (_469.d2 > 0) 
    goto _jump1699;
    fail_assertion("non-positive loop bound");
    _jump1699:;
    // Computing total size of heap memory to allocate
    int64_t _523 = 1;
    _523 *= _522;
    _523 *= _469.d2;
    _523 *= sizeof(_a1_int64_t);
    _521.data = jpl_alloc(_523);
    int64_t _524 = 0; // z
    int64_t _525 = 0; // y
    _jump1700:; // Begin body of loop
    _a1_int64_t _526;
    // Computing bound for A
    _526.d0 = _135.d2;
    if (_135.d2 > 0) 
    goto _jump1701;
    fail_assertion("non-positive loop bound");
    _jump1701:;
    // Computing total size of heap memory to allocate
    int64_t _527 = 1;
    _527 *= _135.d2;
    _527 *= sizeof(int64_t);
    _526.data = jpl_alloc(_527);
    int64_t _528 = 0; // A
    _jump1702:; // Begin body of loop
    int64_t _529 = 0;
    _529 *= _526.d0;
    _529 += _528;
    _526.data[_529] = _135.d1;
    _528++;
    if (_528 < _135.d2)
    goto _jump1702;
    // End body of loop
    int64_t _530 = 0;
    _530 *= _521.d0;
    _530 += _525;
    _530 *= _521.d1;
    _530 += _524;
    _521.data[_530] = _526;
    _524++;
    if (_524 < _469.d2)
    goto _jump1700;
    _524 = 0;
    _525++;
    if (_525 < _522)
    goto _jump1700;
    // End body of loop
    int64_t _531;
    if (!a)
    goto _jump1703;
    _531 = e;
    goto _jump1704;
    _jump1703:;
    _531 = _135.d0;
    _jump1704:;
    if (_531 >= 0)
    goto _jump1705;
    fail_assertion("negative array index");
    _jump1705:;
    if (_531 < _521.d0)
    goto _jump1706;
    fail_assertion("index too large");
    _jump1706:;
    if (d >= 0)
    goto _jump1707;
    fail_assertion("negative array index");
    _jump1707:;
    if (d < _521.d1)
    goto _jump1708;
    fail_assertion("index too large");
    _jump1708:;
    int64_t _532 = 0;
    _532 *= _521.d0;
    _532 += _531;
    _532 *= _521.d1;
    _532 += d;
    _a1_int64_t _533 = _521.data[_532];
    _520 = _533;
    goto _jump1709;
    _jump1697:;
    int64_t _534;
    // Computing bound for y
    int64_t _535 = -_469.d1;
    if (_535 > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    _534 = 0;
    int64_t _536 = 0; // y
    _jump1711:; // Begin body of loop
    _534 += _469.d2;
    _536++;
    if (_536 < _535)
    goto _jump1711;
    // End body of loop
    int64_t _537 = -_135.d0;
    int64_t _538 = _135.d2 / _537;
    _a1_int64_t _539;
    _539.d0 = 3;
    _539.data = jpl_alloc(sizeof(int64_t) * 3);
    _539.data[0] = _534;
    _539.data[1] = d;
    _539.data[2] = _538;
    _520 = _539;
    _jump1709:;
    if (e >= 0)
    goto _jump1712;
    fail_assertion("negative array index");
    _jump1712:;
    if (e < _520.d0)
    goto _jump1713;
    fail_assertion("index too large");
    _jump1713:;
    int64_t _540 = 0;
    _540 *= _520.d0;
    _540 += e;
    int64_t _541 = _520.data[_540];
    int64_t _542 = 803;
    bool _543 = _541 > _542;
    bool _544 = !_543;
    _a3__a3_int64_t _545;
    // Computing bound for z
    _a2_double _546;
    // Computing bound for z
    int64_t _547 = -e;
    _546.d0 = _547;
    if (_547 > 0) 
    goto _jump1714;
    fail_assertion("non-positive loop bound");
    _jump1714:;
    // Computing bound for A
    int64_t _548;
    if (!_544)
    goto _jump1715;
    _548 = f;
    goto _jump1716;
    _jump1715:;
    _548 = _135.d2;
    _jump1716:;
    _546.d1 = _548;
    if (_548 > 0) 
    goto _jump1717;
    fail_assertion("non-positive loop bound");
    _jump1717:;
    // Computing total size of heap memory to allocate
    int64_t _549 = 1;
    _549 *= _547;
    _549 *= _548;
    _549 *= sizeof(double);
    _546.data = jpl_alloc(_549);
    int64_t _550 = 0; // A
    int64_t _551 = 0; // z
    _jump1718:; // Begin body of loop
    double _552;
    // Computing bound for B
    if (g > 0) 
    goto _jump1719;
    fail_assertion("non-positive loop bound");
    _jump1719:;
    // Computing bound for C
    if (_135.d2 > 0) 
    goto _jump1720;
    fail_assertion("non-positive loop bound");
    _jump1720:;
    // Computing bound for D
    if (_469.d1 > 0) 
    goto _jump1721;
    fail_assertion("non-positive loop bound");
    _jump1721:;
    _552 = 0;
    int64_t _553 = 0; // D
    int64_t _554 = 0; // C
    int64_t _555 = 0; // B
    _jump1722:; // Begin body of loop
    _552 += _337;
    _553++;
    if (_553 < _469.d1)
    goto _jump1722;
    _553 = 0;
    _554++;
    if (_554 < _135.d2)
    goto _jump1722;
    _554 = 0;
    _555++;
    if (_555 < g)
    goto _jump1722;
    // End body of loop
    int64_t _556 = 0;
    _556 *= _546.d0;
    _556 += _551;
    _556 *= _546.d1;
    _556 += _550;
    _546.data[_556] = _552;
    _550++;
    if (_550 < _548)
    goto _jump1718;
    _550 = 0;
    _551++;
    if (_551 < _547)
    goto _jump1718;
    // End body of loop
    int64_t _557 = b(_546);
    _545.d0 = _557;
    if (_557 > 0) 
    goto _jump1723;
    fail_assertion("non-positive loop bound");
    _jump1723:;
    // Computing bound for A
    int64_t _558 = -_469.d0;
    _545.d1 = _558;
    if (_558 > 0) 
    goto _jump1724;
    fail_assertion("non-positive loop bound");
    _jump1724:;
    // Computing bound for B
    _545.d2 = _135.d0;
    if (_135.d0 > 0) 
    goto _jump1725;
    fail_assertion("non-positive loop bound");
    _jump1725:;
    // Computing total size of heap memory to allocate
    int64_t _559 = 1;
    _559 *= _557;
    _559 *= _558;
    _559 *= _135.d0;
    _559 *= sizeof(_a3_int64_t);
    _545.data = jpl_alloc(_559);
    int64_t _560 = 0; // B
    int64_t _561 = 0; // A
    int64_t _562 = 0; // z
    _jump1726:; // Begin body of loop
    _a3_int64_t _563;
    // Computing bound for C
    _563.d0 = _469.d0;
    if (_469.d0 > 0) 
    goto _jump1727;
    fail_assertion("non-positive loop bound");
    _jump1727:;
    // Computing bound for D
    _563.d1 = _562;
    if (_562 > 0) 
    goto _jump1728;
    fail_assertion("non-positive loop bound");
    _jump1728:;
    // Computing bound for E
    _563.d2 = _560;
    if (_560 > 0) 
    goto _jump1729;
    fail_assertion("non-positive loop bound");
    _jump1729:;
    // Computing total size of heap memory to allocate
    int64_t _564 = 1;
    _564 *= _469.d0;
    _564 *= _562;
    _564 *= _560;
    _564 *= sizeof(int64_t);
    _563.data = jpl_alloc(_564);
    int64_t _565 = 0; // E
    int64_t _566 = 0; // D
    int64_t _567 = 0; // C
    _jump1730:; // Begin body of loop
    int64_t _568 = 0;
    _568 *= _563.d0;
    _568 += _567;
    _568 *= _563.d1;
    _568 += _566;
    _568 *= _563.d2;
    _568 += _565;
    _563.data[_568] = e;
    _565++;
    if (_565 < _560)
    goto _jump1730;
    _565 = 0;
    _566++;
    if (_566 < _562)
    goto _jump1730;
    _566 = 0;
    _567++;
    if (_567 < _469.d0)
    goto _jump1730;
    // End body of loop
    int64_t _569 = 0;
    _569 *= _545.d0;
    _569 += _562;
    _569 *= _545.d1;
    _569 += _561;
    _569 *= _545.d2;
    _569 += _560;
    _545.data[_569] = _563;
    _560++;
    if (_560 < _135.d0)
    goto _jump1726;
    _560 = 0;
    _561++;
    if (_561 < _558)
    goto _jump1726;
    _561 = 0;
    _562++;
    if (_562 < _557)
    goto _jump1726;
    // End body of loop
    if (_135.d2 >= 0)
    goto _jump1731;
    fail_assertion("negative array index");
    _jump1731:;
    if (_135.d2 < _545.d0)
    goto _jump1732;
    fail_assertion("index too large");
    _jump1732:;
    if (_135.d2 >= 0)
    goto _jump1733;
    fail_assertion("negative array index");
    _jump1733:;
    if (_135.d2 < _545.d1)
    goto _jump1734;
    fail_assertion("index too large");
    _jump1734:;
    if (_135.d1 >= 0)
    goto _jump1735;
    fail_assertion("negative array index");
    _jump1735:;
    if (_135.d1 < _545.d2)
    goto _jump1736;
    fail_assertion("index too large");
    _jump1736:;
    int64_t _570 = 0;
    _570 *= _545.d0;
    _570 += _135.d2;
    _570 *= _545.d1;
    _570 += _135.d2;
    _570 *= _545.d2;
    _570 += _135.d1;
    _a3_int64_t _571 = _545.data[_570];
    if (_135.d2 >= 0)
    goto _jump1737;
    fail_assertion("negative array index");
    _jump1737:;
    if (_135.d2 < _571.d0)
    goto _jump1738;
    fail_assertion("index too large");
    _jump1738:;
    if (i >= 0)
    goto _jump1739;
    fail_assertion("negative array index");
    _jump1739:;
    if (i < _571.d1)
    goto _jump1740;
    fail_assertion("index too large");
    _jump1740:;
    if (_135.d1 >= 0)
    goto _jump1741;
    fail_assertion("negative array index");
    _jump1741:;
    if (_135.d1 < _571.d2)
    goto _jump1742;
    fail_assertion("index too large");
    _jump1742:;
    int64_t _572 = 0;
    _572 *= _571.d0;
    _572 += _135.d2;
    _572 *= _571.d1;
    _572 += i;
    _572 *= _571.d2;
    _572 += _135.d1;
    int64_t _573 = _571.data[_572];
    if (_573 >= 0)
    goto _jump1743;
    fail_assertion("negative array index");
    _jump1743:;
    if (_573 < _338.d0)
    goto _jump1744;
    fail_assertion("index too large");
    _jump1744:;
    if (_135.d0 >= 0)
    goto _jump1745;
    fail_assertion("negative array index");
    _jump1745:;
    if (_135.d0 < _338.d1)
    goto _jump1746;
    fail_assertion("index too large");
    _jump1746:;
    if (_469.d0 >= 0)
    goto _jump1747;
    fail_assertion("negative array index");
    _jump1747:;
    if (_469.d0 < _338.d2)
    goto _jump1748;
    fail_assertion("index too large");
    _jump1748:;
    int64_t _574 = 0;
    _574 *= _338.d0;
    _574 += _573;
    _574 *= _338.d1;
    _574 += _135.d0;
    _574 *= _338.d2;
    _574 += _469.d0;
    double _575 = _338.data[_574];
    return _575;
}

int64_t l(void_t m) {
    int64_t _0 = 354;
    _a2_bool _1;
    // Computing bound for o
    _1.d0 = f;
    if (f > 0) 
    goto _jump1749;
    fail_assertion("non-positive loop bound");
    _jump1749:;
    // Computing bound for p
    int64_t _2;
    // Computing bound for o
    if (i > 0) 
    goto _jump1750;
    fail_assertion("non-positive loop bound");
    _jump1750:;
    _2 = 0;
    int64_t _3 = 0; // o
    _jump1751:; // Begin body of loop
    _2 += f;
    _3++;
    if (_3 < i)
    goto _jump1751;
    // End body of loop
    int64_t _4 = -_2;
    _1.d1 = _4;
    if (_4 > 0) 
    goto _jump1752;
    fail_assertion("non-positive loop bound");
    _jump1752:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= f;
    _5 *= _4;
    _5 *= sizeof(bool);
    _1.data = jpl_alloc(_5);
    int64_t _6 = 0; // p
    int64_t _7 = 0; // o
    _jump1753:; // Begin body of loop
    bool _8;
    if (!a)
    goto _jump1754;
    bool _9 = true;
    _8 = _9;
    goto _jump1755;
    _jump1754:;
    _8 = h;
    _jump1755:;
    int64_t _10 = 0;
    _10 *= _1.d0;
    _10 += _7;
    _10 *= _1.d1;
    _10 += _6;
    _1.data[_10] = _8;
    _6++;
    if (_6 < _4)
    goto _jump1753;
    _6 = 0;
    _7++;
    if (_7 < f)
    goto _jump1753;
    // End body of loop
    int64_t _11 = 721;
    int64_t _12 = e / _11;
    _a2_double _13;
    // Computing bound for o
    int64_t _14 = 756;
    _13.d0 = _14;
    if (_14 > 0) 
    goto _jump1756;
    fail_assertion("non-positive loop bound");
    _jump1756:;
    // Computing bound for p
    _13.d1 = g;
    if (g > 0) 
    goto _jump1757;
    fail_assertion("non-positive loop bound");
    _jump1757:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= _14;
    _15 *= g;
    _15 *= sizeof(double);
    _13.data = jpl_alloc(_15);
    int64_t _16 = 0; // p
    int64_t _17 = 0; // o
    _jump1758:; // Begin body of loop
    double _18 = 83.0;
    int64_t _19 = 0;
    _19 *= _13.d0;
    _19 += _17;
    _19 *= _13.d1;
    _19 += _16;
    _13.data[_19] = _18;
    _16++;
    if (_16 < g)
    goto _jump1758;
    _16 = 0;
    _17++;
    if (_17 < _14)
    goto _jump1758;
    // End body of loop
    int64_t _20 = b(_13);
    if (_12 >= 0)
    goto _jump1759;
    fail_assertion("negative array index");
    _jump1759:;
    if (_12 < _1.d0)
    goto _jump1760;
    fail_assertion("index too large");
    _jump1760:;
    if (_20 >= 0)
    goto _jump1761;
    fail_assertion("negative array index");
    _jump1761:;
    if (_20 < _1.d1)
    goto _jump1762;
    fail_assertion("index too large");
    _jump1762:;
    int64_t _21 = 0;
    _21 *= _1.d0;
    _21 += _12;
    _21 *= _1.d1;
    _21 += _20;
    bool _22 = _1.data[_21];
    _a1_int64_t _23;
    if (!_22)
    goto _jump1763;
    _a1_int64_t _24;
    // Computing bound for o
    _24.d0 = f;
    if (f > 0) 
    goto _jump1764;
    fail_assertion("non-positive loop bound");
    _jump1764:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= f;
    _25 *= sizeof(int64_t);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // o
    _jump1765:; // Begin body of loop
    bool _27 = !a;
    int64_t _28;
    if (!_27)
    goto _jump1766;
    int64_t _29;
    // Computing bound for p
    if (d > 0) 
    goto _jump1767;
    fail_assertion("non-positive loop bound");
    _jump1767:;
    // Computing bound for q
    int64_t _30 = l(m);
    if (_30 > 0) 
    goto _jump1768;
    fail_assertion("non-positive loop bound");
    _jump1768:;
    // Computing bound for r
    int64_t _31 = l(m);
    if (_31 > 0) 
    goto _jump1769;
    fail_assertion("non-positive loop bound");
    _jump1769:;
    _29 = 0;
    int64_t _32 = 0; // r
    int64_t _33 = 0; // q
    int64_t _34 = 0; // p
    _jump1770:; // Begin body of loop
    _29 += d;
    _32++;
    if (_32 < _31)
    goto _jump1770;
    _32 = 0;
    _33++;
    if (_33 < _30)
    goto _jump1770;
    _33 = 0;
    _34++;
    if (_34 < d)
    goto _jump1770;
    // End body of loop
    _28 = _29;
    goto _jump1771;
    _jump1766:;
    _28 = i;
    _jump1771:;
    int64_t _35 = 0;
    _35 *= _24.d0;
    _35 += _26;
    _24.data[_35] = _28;
    _26++;
    if (_26 < f)
    goto _jump1765;
    // End body of loop
    _23 = _24;
    goto _jump1772;
    _jump1763:;
    _a1_int64_t _36;
    _36.d0 = 2;
    _36.data = jpl_alloc(sizeof(int64_t) * 2);
    _36.data[0] = g;
    _36.data[1] = g;
    _23 = _36;
    _jump1772:;
    if (i >= 0)
    goto _jump1773;
    fail_assertion("negative array index");
    _jump1773:;
    if (i < _23.d0)
    goto _jump1774;
    fail_assertion("index too large");
    _jump1774:;
    int64_t _37 = 0;
    _37 *= _23.d0;
    _37 += i;
    int64_t _38 = _23.data[_37];
    int64_t _39 = _0 + _38;
    return _39;
    bool _42 = false;
    bool _43;
    if (!_42)
    goto _jump1775;
    bool _44 = d > f;
    _43 = _44;
    goto _jump1776;
    _jump1775:;
    bool _45 = false;
    bool _46 = !_45;
    _43 = _46;
    _jump1776:;
    bool _47 = g > g;
    bool _48 = _43 != _47;
    bool _41 = _48;
    if (0 == _48)
    goto _jump1777;
    int64_t _49 = -g;
    bool _50 = _49 >= d;
    bool _51;
    if (!_50)
    goto _jump1778;
    bool _52;
    if (!a)
    goto _jump1779;
    bool _53 = false;
    _52 = _53;
    goto _jump1780;
    _jump1779:;
    bool _54 = false;
    _52 = _54;
    _jump1780:;
    _51 = _52;
    goto _jump1781;
    _jump1778:;
    _51 = h;
    _jump1781:;
    _41 = _51;
    _jump1777:;
    bool _40 = _41;
    if (0 != _41)
    goto _jump1782;
    bool _55 = true;
    _40 = _55;
    _jump1782:;
    bool _56;
    if (!a)
    goto _jump1783;
    bool _57;
    if (!h)
    goto _jump1784;
    _57 = h;
    goto _jump1785;
    _jump1784:;
    _57 = h;
    _jump1785:;
    _56 = _57;
    goto _jump1786;
    _jump1783:;
    double _58 = 37.0;
    double _59 = 78.0;
    bool _60 = _58 == _59;
    _56 = _60;
    _jump1786:;
    bool _61 = e < e;
    bool _62 = _56 == _61;
    bool _63;
    if (!h)
    goto _jump1787;
    _63 = h;
    goto _jump1788;
    _jump1787:;
    _63 = h;
    _jump1788:;
    bool _64;
    if (!_63)
    goto _jump1789;
    int64_t _65 = g - e;
    int64_t _66 = -d;
    if (e >= 0)
    goto _jump1790;
    fail_assertion("negative array index");
    _jump1790:;
    if (e < c.d0)
    goto _jump1791;
    fail_assertion("index too large");
    _jump1791:;
    if (_65 >= 0)
    goto _jump1792;
    fail_assertion("negative array index");
    _jump1792:;
    if (_65 < c.d1)
    goto _jump1793;
    fail_assertion("index too large");
    _jump1793:;
    if (_66 >= 0)
    goto _jump1794;
    fail_assertion("negative array index");
    _jump1794:;
    if (_66 < c.d2)
    goto _jump1795;
    fail_assertion("index too large");
    _jump1795:;
    int64_t _67 = 0;
    _67 *= c.d0;
    _67 += e;
    _67 *= c.d1;
    _67 += _65;
    _67 *= c.d2;
    _67 += _66;
    bool _68 = c.data[_67];
    _64 = _68;
    goto _jump1796;
    _jump1789:;
    int64_t _69;
    // Computing bound for o
    if (e > 0) 
    goto _jump1797;
    fail_assertion("non-positive loop bound");
    _jump1797:;
    _69 = 0;
    int64_t _70 = 0; // o
    _jump1798:; // Begin body of loop
    int64_t _71 = 949;
    _69 += _71;
    _70++;
    if (_70 < e)
    goto _jump1798;
    // End body of loop
    int64_t _72 = -e;
    int64_t _73 = _69 - _72;
    bool _74 = e >= _73;
    _64 = _74;
    _jump1796:;
    bool _75 = _62 != _64;
    bool _76 = _40 == _75;
    int64_t _77;
    if (!_76)
    goto _jump1799;
    _a2__a3_int64_t _78;
    // Computing bound for o
    int64_t _79;
    // Computing bound for o
    int64_t _80 = -f;
    if (_80 > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for p
    if (d > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing bound for q
    if (i > 0) 
    goto _jump1802;
    fail_assertion("non-positive loop bound");
    _jump1802:;
    _79 = 0;
    int64_t _81 = 0; // q
    int64_t _82 = 0; // p
    int64_t _83 = 0; // o
    _jump1803:; // Begin body of loop
    int64_t _84;
    // Computing bound for r
    int64_t _85;
    // Computing bound for r
    if (e > 0) 
    goto _jump1804;
    fail_assertion("non-positive loop bound");
    _jump1804:;
    _85 = 0;
    int64_t _86 = 0; // r
    _jump1805:; // Begin body of loop
    _85 += e;
    _86++;
    if (_86 < e)
    goto _jump1805;
    // End body of loop
    if (_85 > 0) 
    goto _jump1806;
    fail_assertion("non-positive loop bound");
    _jump1806:;
    // Computing bound for s
    if (g > 0) 
    goto _jump1807;
    fail_assertion("non-positive loop bound");
    _jump1807:;
    _84 = 0;
    int64_t _87 = 0; // s
    int64_t _88 = 0; // r
    _jump1808:; // Begin body of loop
    _84 += f;
    _87++;
    if (_87 < g)
    goto _jump1808;
    _87 = 0;
    _88++;
    if (_88 < _85)
    goto _jump1808;
    // End body of loop
    _79 += _84;
    _81++;
    if (_81 < i)
    goto _jump1803;
    _81 = 0;
    _82++;
    if (_82 < d)
    goto _jump1803;
    _82 = 0;
    _83++;
    if (_83 < _80)
    goto _jump1803;
    // End body of loop
    _78.d0 = _79;
    if (_79 > 0) 
    goto _jump1809;
    fail_assertion("non-positive loop bound");
    _jump1809:;
    // Computing bound for p
    _78.d1 = e;
    if (e > 0) 
    goto _jump1810;
    fail_assertion("non-positive loop bound");
    _jump1810:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _79;
    _89 *= e;
    _89 *= sizeof(_a3_int64_t);
    _78.data = jpl_alloc(_89);
    int64_t _90 = 0; // p
    int64_t _91 = 0; // o
    _jump1811:; // Begin body of loop
    _a3_int64_t _92;
    // Computing bound for q
    int64_t _93 = 934;
    _a1_int64_t _94;
    _94.d0 = 3;
    _94.data = jpl_alloc(sizeof(int64_t) * 3);
    _94.data[0] = _93;
    _94.data[1] = _90;
    _94.data[2] = i;
    if (d >= 0)
    goto _jump1812;
    fail_assertion("negative array index");
    _jump1812:;
    if (d < _94.d0)
    goto _jump1813;
    fail_assertion("index too large");
    _jump1813:;
    int64_t _95 = 0;
    _95 *= _94.d0;
    _95 += d;
    int64_t _96 = _94.data[_95];
    _92.d0 = _96;
    if (_96 > 0) 
    goto _jump1814;
    fail_assertion("non-positive loop bound");
    _jump1814:;
    // Computing bound for r
    _92.d1 = i;
    if (i > 0) 
    goto _jump1815;
    fail_assertion("non-positive loop bound");
    _jump1815:;
    // Computing bound for s
    _92.d2 = e;
    if (e > 0) 
    goto _jump1816;
    fail_assertion("non-positive loop bound");
    _jump1816:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= _96;
    _97 *= i;
    _97 *= e;
    _97 *= sizeof(int64_t);
    _92.data = jpl_alloc(_97);
    int64_t _98 = 0; // s
    int64_t _99 = 0; // r
    int64_t _100 = 0; // q
    _jump1817:; // Begin body of loop
    int64_t _101 = 0;
    _101 *= _92.d0;
    _101 += _100;
    _101 *= _92.d1;
    _101 += _99;
    _101 *= _92.d2;
    _101 += _98;
    _92.data[_101] = _98;
    _98++;
    if (_98 < e)
    goto _jump1817;
    _98 = 0;
    _99++;
    if (_99 < i)
    goto _jump1817;
    _99 = 0;
    _100++;
    if (_100 < _96)
    goto _jump1817;
    // End body of loop
    int64_t _102 = 0;
    _102 *= _78.d0;
    _102 += _91;
    _102 *= _78.d1;
    _102 += _90;
    _78.data[_102] = _92;
    _90++;
    if (_90 < e)
    goto _jump1811;
    _90 = 0;
    _91++;
    if (_91 < _79)
    goto _jump1811;
    // End body of loop
    int64_t _103 = -e;
    if (_103 >= 0)
    goto _jump1818;
    fail_assertion("negative array index");
    _jump1818:;
    if (_103 < _78.d0)
    goto _jump1819;
    fail_assertion("index too large");
    _jump1819:;
    if (e >= 0)
    goto _jump1820;
    fail_assertion("negative array index");
    _jump1820:;
    if (e < _78.d1)
    goto _jump1821;
    fail_assertion("index too large");
    _jump1821:;
    int64_t _104 = 0;
    _104 *= _78.d0;
    _104 += _103;
    _104 *= _78.d1;
    _104 += e;
    _a3_int64_t _105 = _78.data[_104];
    _a2_int64_t _106;
    // Computing bound for o
    int64_t _107 = 361;
    _106.d0 = _107;
    if (_107 > 0) 
    goto _jump1822;
    fail_assertion("non-positive loop bound");
    _jump1822:;
    // Computing bound for p
    int64_t _108 = l(m);
    int64_t _109 = _108 / e;
    int64_t _110 = -_109;
    _106.d1 = _110;
    if (_110 > 0) 
    goto _jump1823;
    fail_assertion("non-positive loop bound");
    _jump1823:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= _107;
    _111 *= _110;
    _111 *= sizeof(int64_t);
    _106.data = jpl_alloc(_111);
    int64_t _112 = 0; // p
    int64_t _113 = 0; // o
    _jump1824:; // Begin body of loop
    int64_t _114 = 938;
    int64_t _115 = 0;
    _115 *= _106.d0;
    _115 += _113;
    _115 *= _106.d1;
    _115 += _112;
    _106.data[_115] = _114;
    _112++;
    if (_112 < _110)
    goto _jump1824;
    _112 = 0;
    _113++;
    if (_113 < _107)
    goto _jump1824;
    // End body of loop
    _a2_double _116;
    // Computing bound for o
    int64_t _117 = l(m);
    _116.d0 = _117;
    if (_117 > 0) 
    goto _jump1825;
    fail_assertion("non-positive loop bound");
    _jump1825:;
    // Computing bound for p
    _116.d1 = g;
    if (g > 0) 
    goto _jump1826;
    fail_assertion("non-positive loop bound");
    _jump1826:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= _117;
    _118 *= g;
    _118 *= sizeof(double);
    _116.data = jpl_alloc(_118);
    int64_t _119 = 0; // p
    int64_t _120 = 0; // o
    _jump1827:; // Begin body of loop
    double _121 = 76.0;
    double _122 = -_121;
    double _123 = -_122;
    int64_t _124 = 0;
    _124 *= _116.d0;
    _124 += _120;
    _124 *= _116.d1;
    _124 += _119;
    _116.data[_124] = _123;
    _119++;
    if (_119 < g)
    goto _jump1827;
    _119 = 0;
    _120++;
    if (_120 < _117)
    goto _jump1827;
    // End body of loop
    int64_t _125 = b(_116);
    int64_t _126;
    // Computing bound for o
    int64_t _127 = -d;
    if (_127 > 0) 
    goto _jump1828;
    fail_assertion("non-positive loop bound");
    _jump1828:;
    // Computing bound for p
    if (g > 0) 
    goto _jump1829;
    fail_assertion("non-positive loop bound");
    _jump1829:;
    // Computing bound for q
    if (d > 0) 
    goto _jump1830;
    fail_assertion("non-positive loop bound");
    _jump1830:;
    _126 = 0;
    int64_t _128 = 0; // q
    int64_t _129 = 0; // p
    int64_t _130 = 0; // o
    _jump1831:; // Begin body of loop
    _126 += i;
    _128++;
    if (_128 < d)
    goto _jump1831;
    _128 = 0;
    _129++;
    if (_129 < g)
    goto _jump1831;
    _129 = 0;
    _130++;
    if (_130 < _127)
    goto _jump1831;
    // End body of loop
    int64_t _131;
    // Computing bound for o
    if (i > 0) 
    goto _jump1832;
    fail_assertion("non-positive loop bound");
    _jump1832:;
    // Computing bound for p
    if (f > 0) 
    goto _jump1833;
    fail_assertion("non-positive loop bound");
    _jump1833:;
    _131 = 0;
    int64_t _132 = 0; // p
    int64_t _133 = 0; // o
    _jump1834:; // Begin body of loop
    _131 += _133;
    _132++;
    if (_132 < f)
    goto _jump1834;
    _132 = 0;
    _133++;
    if (_133 < i)
    goto _jump1834;
    // End body of loop
    int64_t _134 = _126 * _131;
    if (_125 >= 0)
    goto _jump1835;
    fail_assertion("negative array index");
    _jump1835:;
    if (_125 < _106.d0)
    goto _jump1836;
    fail_assertion("index too large");
    _jump1836:;
    if (_134 >= 0)
    goto _jump1837;
    fail_assertion("negative array index");
    _jump1837:;
    if (_134 < _106.d1)
    goto _jump1838;
    fail_assertion("index too large");
    _jump1838:;
    int64_t _135 = 0;
    _135 *= _106.d0;
    _135 += _125;
    _135 *= _106.d1;
    _135 += _134;
    int64_t _136 = _106.data[_135];
    bool _137;
    if (!a)
    goto _jump1839;
    if (e >= 0)
    goto _jump1840;
    fail_assertion("negative array index");
    _jump1840:;
    if (e < c.d0)
    goto _jump1841;
    fail_assertion("index too large");
    _jump1841:;
    if (g >= 0)
    goto _jump1842;
    fail_assertion("negative array index");
    _jump1842:;
    if (g < c.d1)
    goto _jump1843;
    fail_assertion("index too large");
    _jump1843:;
    if (f >= 0)
    goto _jump1844;
    fail_assertion("negative array index");
    _jump1844:;
    if (f < c.d2)
    goto _jump1845;
    fail_assertion("index too large");
    _jump1845:;
    int64_t _138 = 0;
    _138 *= c.d0;
    _138 += e;
    _138 *= c.d1;
    _138 += g;
    _138 *= c.d2;
    _138 += f;
    bool _139 = c.data[_138];
    _137 = _139;
    goto _jump1846;
    _jump1839:;
    _137 = h;
    _jump1846:;
    _a2__a2_double _140;
    if (!_137)
    goto _jump1847;
    _a2__a2_double _141;
    // Computing bound for o
    int64_t _142 = l(m);
    _141.d0 = _142;
    if (_142 > 0) 
    goto _jump1848;
    fail_assertion("non-positive loop bound");
    _jump1848:;
    // Computing bound for p
    _141.d1 = e;
    if (e > 0) 
    goto _jump1849;
    fail_assertion("non-positive loop bound");
    _jump1849:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= _142;
    _143 *= e;
    _143 *= sizeof(_a2_double);
    _141.data = jpl_alloc(_143);
    int64_t _144 = 0; // p
    int64_t _145 = 0; // o
    _jump1850:; // Begin body of loop
    _a2_double _146;
    // Computing bound for q
    _146.d0 = e;
    if (e > 0) 
    goto _jump1851;
    fail_assertion("non-positive loop bound");
    _jump1851:;
    // Computing bound for r
    _146.d1 = i;
    if (i > 0) 
    goto _jump1852;
    fail_assertion("non-positive loop bound");
    _jump1852:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= e;
    _147 *= i;
    _147 *= sizeof(double);
    _146.data = jpl_alloc(_147);
    int64_t _148 = 0; // r
    int64_t _149 = 0; // q
    _jump1853:; // Begin body of loop
    double _150 = 53.0;
    int64_t _151 = 0;
    _151 *= _146.d0;
    _151 += _149;
    _151 *= _146.d1;
    _151 += _148;
    _146.data[_151] = _150;
    _148++;
    if (_148 < i)
    goto _jump1853;
    _148 = 0;
    _149++;
    if (_149 < e)
    goto _jump1853;
    // End body of loop
    int64_t _152 = 0;
    _152 *= _141.d0;
    _152 += _145;
    _152 *= _141.d1;
    _152 += _144;
    _141.data[_152] = _146;
    _144++;
    if (_144 < e)
    goto _jump1850;
    _144 = 0;
    _145++;
    if (_145 < _142)
    goto _jump1850;
    // End body of loop
    _140 = _141;
    goto _jump1854;
    _jump1847:;
    _a2__a2_double _153;
    // Computing bound for o
    int64_t _154 = -e;
    _153.d0 = _154;
    if (_154 > 0) 
    goto _jump1855;
    fail_assertion("non-positive loop bound");
    _jump1855:;
    // Computing bound for p
    _153.d1 = i;
    if (i > 0) 
    goto _jump1856;
    fail_assertion("non-positive loop bound");
    _jump1856:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= _154;
    _155 *= i;
    _155 *= sizeof(_a2_double);
    _153.data = jpl_alloc(_155);
    int64_t _156 = 0; // p
    int64_t _157 = 0; // o
    _jump1857:; // Begin body of loop
    _a2_double _158;
    // Computing bound for q
    _158.d0 = _156;
    if (_156 > 0) 
    goto _jump1858;
    fail_assertion("non-positive loop bound");
    _jump1858:;
    // Computing bound for r
    _158.d1 = d;
    if (d > 0) 
    goto _jump1859;
    fail_assertion("non-positive loop bound");
    _jump1859:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _156;
    _159 *= d;
    _159 *= sizeof(double);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // r
    int64_t _161 = 0; // q
    _jump1860:; // Begin body of loop
    double _162 = 61.0;
    int64_t _163 = 0;
    _163 *= _158.d0;
    _163 += _161;
    _163 *= _158.d1;
    _163 += _160;
    _158.data[_163] = _162;
    _160++;
    if (_160 < d)
    goto _jump1860;
    _160 = 0;
    _161++;
    if (_161 < _156)
    goto _jump1860;
    // End body of loop
    int64_t _164 = 0;
    _164 *= _153.d0;
    _164 += _157;
    _164 *= _153.d1;
    _164 += _156;
    _153.data[_164] = _158;
    _156++;
    if (_156 < i)
    goto _jump1857;
    _156 = 0;
    _157++;
    if (_157 < _154)
    goto _jump1857;
    // End body of loop
    _140 = _153;
    _jump1854:;
    _a2_int64_t _165;
    // Computing bound for o
    _165.d0 = f;
    if (f > 0) 
    goto _jump1861;
    fail_assertion("non-positive loop bound");
    _jump1861:;
    // Computing bound for p
    _165.d1 = i;
    if (i > 0) 
    goto _jump1862;
    fail_assertion("non-positive loop bound");
    _jump1862:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= f;
    _166 *= i;
    _166 *= sizeof(int64_t);
    _165.data = jpl_alloc(_166);
    int64_t _167 = 0; // p
    int64_t _168 = 0; // o
    _jump1863:; // Begin body of loop
    int64_t _169 = 0;
    _169 *= _165.d0;
    _169 += _168;
    _169 *= _165.d1;
    _169 += _167;
    _165.data[_169] = d;
    _167++;
    if (_167 < i)
    goto _jump1863;
    _167 = 0;
    _168++;
    if (_168 < f)
    goto _jump1863;
    // End body of loop
    bool _170 = !h;
    int64_t _171;
    if (!_170)
    goto _jump1864;
    int64_t _172 = 211;
    int64_t _173 = -_172;
    _171 = _173;
    goto _jump1865;
    _jump1864:;
    int64_t _174 = l(m);
    _171 = _174;
    _jump1865:;
    _a1_int64_t _175;
    // Computing bound for o
    int64_t _176 = 280;
    _175.d0 = _176;
    if (_176 > 0) 
    goto _jump1866;
    fail_assertion("non-positive loop bound");
    _jump1866:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _176;
    _177 *= sizeof(int64_t);
    _175.data = jpl_alloc(_177);
    int64_t _178 = 0; // o
    _jump1867:; // Begin body of loop
    int64_t _179 = 47;
    int64_t _180 = 0;
    _180 *= _175.d0;
    _180 += _178;
    _175.data[_180] = _179;
    _178++;
    if (_178 < _176)
    goto _jump1867;
    // End body of loop
    if (d >= 0)
    goto _jump1868;
    fail_assertion("negative array index");
    _jump1868:;
    if (d < _175.d0)
    goto _jump1869;
    fail_assertion("index too large");
    _jump1869:;
    int64_t _181 = 0;
    _181 *= _175.d0;
    _181 += d;
    int64_t _182 = _175.data[_181];
    if (_171 >= 0)
    goto _jump1870;
    fail_assertion("negative array index");
    _jump1870:;
    if (_171 < _165.d0)
    goto _jump1871;
    fail_assertion("index too large");
    _jump1871:;
    if (_182 >= 0)
    goto _jump1872;
    fail_assertion("negative array index");
    _jump1872:;
    if (_182 < _165.d1)
    goto _jump1873;
    fail_assertion("index too large");
    _jump1873:;
    int64_t _183 = 0;
    _183 *= _165.d0;
    _183 += _171;
    _183 *= _165.d1;
    _183 += _182;
    int64_t _184 = _165.data[_183];
    int64_t _185;
    // Computing bound for o
    int64_t _186 = 12;
    if (_186 > 0) 
    goto _jump1874;
    fail_assertion("non-positive loop bound");
    _jump1874:;
    _185 = 0;
    int64_t _187 = 0; // o
    _jump1875:; // Begin body of loop
    _185 += e;
    _187++;
    if (_187 < _186)
    goto _jump1875;
    // End body of loop
    if (_184 >= 0)
    goto _jump1876;
    fail_assertion("negative array index");
    _jump1876:;
    if (_184 < _140.d0)
    goto _jump1877;
    fail_assertion("index too large");
    _jump1877:;
    if (_185 >= 0)
    goto _jump1878;
    fail_assertion("negative array index");
    _jump1878:;
    if (_185 < _140.d1)
    goto _jump1879;
    fail_assertion("index too large");
    _jump1879:;
    int64_t _188 = 0;
    _188 *= _140.d0;
    _188 += _184;
    _188 *= _140.d1;
    _188 += _185;
    _a2_double _189 = _140.data[_188];
    int64_t _190 = b(_189);
    _a2_double _191;
    // Computing bound for o
    _191.d0 = e;
    if (e > 0) 
    goto _jump1880;
    fail_assertion("non-positive loop bound");
    _jump1880:;
    // Computing bound for p
    _191.d1 = f;
    if (f > 0) 
    goto _jump1881;
    fail_assertion("non-positive loop bound");
    _jump1881:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= e;
    _192 *= f;
    _192 *= sizeof(double);
    _191.data = jpl_alloc(_192);
    int64_t _193 = 0; // p
    int64_t _194 = 0; // o
    _jump1882:; // Begin body of loop
    double _195;
    // Computing bound for q
    if (i > 0) 
    goto _jump1883;
    fail_assertion("non-positive loop bound");
    _jump1883:;
    // Computing bound for r
    int64_t _196;
    // Computing bound for q
    if (i > 0) 
    goto _jump1884;
    fail_assertion("non-positive loop bound");
    _jump1884:;
    // Computing bound for r
    if (g > 0) 
    goto _jump1885;
    fail_assertion("non-positive loop bound");
    _jump1885:;
    _196 = 0;
    int64_t _197 = 0; // r
    int64_t _198 = 0; // q
    _jump1886:; // Begin body of loop
    _196 += _194;
    _197++;
    if (_197 < g)
    goto _jump1886;
    _197 = 0;
    _198++;
    if (_198 < i)
    goto _jump1886;
    // End body of loop
    if (_196 > 0) 
    goto _jump1887;
    fail_assertion("non-positive loop bound");
    _jump1887:;
    // Computing bound for s
    if (f > 0) 
    goto _jump1888;
    fail_assertion("non-positive loop bound");
    _jump1888:;
    _195 = 0;
    int64_t _199 = 0; // s
    int64_t _200 = 0; // r
    int64_t _201 = 0; // q
    _jump1889:; // Begin body of loop
    double _202 = 60.0;
    _195 += _202;
    _199++;
    if (_199 < f)
    goto _jump1889;
    _199 = 0;
    _200++;
    if (_200 < _196)
    goto _jump1889;
    _200 = 0;
    _201++;
    if (_201 < i)
    goto _jump1889;
    // End body of loop
    int64_t _203 = 0;
    _203 *= _191.d0;
    _203 += _194;
    _203 *= _191.d1;
    _203 += _193;
    _191.data[_203] = _195;
    _193++;
    if (_193 < f)
    goto _jump1882;
    _193 = 0;
    _194++;
    if (_194 < e)
    goto _jump1882;
    // End body of loop
    int64_t _204 = b(_191);
    if (_136 >= 0)
    goto _jump1890;
    fail_assertion("negative array index");
    _jump1890:;
    if (_136 < _105.d0)
    goto _jump1891;
    fail_assertion("index too large");
    _jump1891:;
    if (_190 >= 0)
    goto _jump1892;
    fail_assertion("negative array index");
    _jump1892:;
    if (_190 < _105.d1)
    goto _jump1893;
    fail_assertion("index too large");
    _jump1893:;
    if (_204 >= 0)
    goto _jump1894;
    fail_assertion("negative array index");
    _jump1894:;
    if (_204 < _105.d2)
    goto _jump1895;
    fail_assertion("index too large");
    _jump1895:;
    int64_t _205 = 0;
    _205 *= _105.d0;
    _205 += _136;
    _205 *= _105.d1;
    _205 += _190;
    _205 *= _105.d2;
    _205 += _204;
    int64_t _206 = _105.data[_205];
    _77 = _206;
    goto _jump1896;
    _jump1799:;
    _77 = f;
    _jump1896:;
    return _77;
    _a1_bool _207;
    // Computing bound for o
    int64_t _208;
    // Computing bound for o
    _a1_int64_t _209;
    // Computing bound for o
    _209.d0 = e;
    if (e > 0) 
    goto _jump1897;
    fail_assertion("non-positive loop bound");
    _jump1897:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= e;
    _210 *= sizeof(int64_t);
    _209.data = jpl_alloc(_210);
    int64_t _211 = 0; // o
    _jump1898:; // Begin body of loop
    int64_t _212 = 0;
    _212 *= _209.d0;
    _212 += _211;
    _209.data[_212] = e;
    _211++;
    if (_211 < e)
    goto _jump1898;
    // End body of loop
    int64_t _213;
    // Computing bound for o
    if (g > 0) 
    goto _jump1899;
    fail_assertion("non-positive loop bound");
    _jump1899:;
    // Computing bound for p
    int64_t _214 = l(m);
    if (_214 > 0) 
    goto _jump1900;
    fail_assertion("non-positive loop bound");
    _jump1900:;
    _213 = 0;
    int64_t _215 = 0; // p
    int64_t _216 = 0; // o
    _jump1901:; // Begin body of loop
    int64_t _217 = l(m);
    _213 += _217;
    _215++;
    if (_215 < _214)
    goto _jump1901;
    _215 = 0;
    _216++;
    if (_216 < g)
    goto _jump1901;
    // End body of loop
    if (_213 >= 0)
    goto _jump1902;
    fail_assertion("negative array index");
    _jump1902:;
    if (_213 < _209.d0)
    goto _jump1903;
    fail_assertion("index too large");
    _jump1903:;
    int64_t _218 = 0;
    _218 *= _209.d0;
    _218 += _213;
    int64_t _219 = _209.data[_218];
    int64_t _220 = -_219;
    int64_t _221 = -_220;
    if (_221 > 0) 
    goto _jump1904;
    fail_assertion("non-positive loop bound");
    _jump1904:;
    _208 = 0;
    int64_t _222 = 0; // o
    _jump1905:; // Begin body of loop
    int64_t _223;
    // Computing bound for p
    if (d > 0) 
    goto _jump1906;
    fail_assertion("non-positive loop bound");
    _jump1906:;
    // Computing bound for q
    bool _224;
    if (!h)
    goto _jump1907;
    _224 = a;
    goto _jump1908;
    _jump1907:;
    bool _225 = true;
    _224 = _225;
    _jump1908:;
    _a1_void_t _226;
    if (!_224)
    goto _jump1909;
    _a1_void_t _227;
    // Computing bound for p
    _227.d0 = d;
    if (d > 0) 
    goto _jump1910;
    fail_assertion("non-positive loop bound");
    _jump1910:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= d;
    _228 *= sizeof(void_t);
    _227.data = jpl_alloc(_228);
    int64_t _229 = 0; // p
    _jump1911:; // Begin body of loop
    int64_t _230 = 0;
    _230 *= _227.d0;
    _230 += _229;
    _227.data[_230] = m;
    _229++;
    if (_229 < d)
    goto _jump1911;
    // End body of loop
    _226 = _227;
    goto _jump1912;
    _jump1909:;
    _a1_void_t _231;
    // Computing bound for p
    _231.d0 = g;
    if (g > 0) 
    goto _jump1913;
    fail_assertion("non-positive loop bound");
    _jump1913:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= g;
    _232 *= sizeof(void_t);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // p
    _jump1914:; // Begin body of loop
    int64_t _234 = 0;
    _234 *= _231.d0;
    _234 += _233;
    _231.data[_234] = m;
    _233++;
    if (_233 < g)
    goto _jump1914;
    // End body of loop
    _226 = _231;
    _jump1912:;
    if (i >= 0)
    goto _jump1915;
    fail_assertion("negative array index");
    _jump1915:;
    if (i < _226.d0)
    goto _jump1916;
    fail_assertion("index too large");
    _jump1916:;
    int64_t _235 = 0;
    _235 *= _226.d0;
    _235 += i;
    void_t _236 = _226.data[_235];
    int64_t _237 = l(_236);
    if (_237 > 0) 
    goto _jump1917;
    fail_assertion("non-positive loop bound");
    _jump1917:;
    // Computing bound for r
    int64_t _238;
    // Computing bound for p
    if (d > 0) 
    goto _jump1918;
    fail_assertion("non-positive loop bound");
    _jump1918:;
    // Computing bound for q
    void_t _239;
    if (!a)
    goto _jump1919;
    _239 = m;
    goto _jump1920;
    _jump1919:;
    _239 = m;
    _jump1920:;
    int64_t _240 = l(_239);
    if (_240 > 0) 
    goto _jump1921;
    fail_assertion("non-positive loop bound");
    _jump1921:;
    // Computing bound for r
    if (d > 0) 
    goto _jump1922;
    fail_assertion("non-positive loop bound");
    _jump1922:;
    _238 = 0;
    int64_t _241 = 0; // r
    int64_t _242 = 0; // q
    int64_t _243 = 0; // p
    _jump1923:; // Begin body of loop
    _238 += d;
    _241++;
    if (_241 < d)
    goto _jump1923;
    _241 = 0;
    _242++;
    if (_242 < _240)
    goto _jump1923;
    _242 = 0;
    _243++;
    if (_243 < d)
    goto _jump1923;
    // End body of loop
    if (_238 > 0) 
    goto _jump1924;
    fail_assertion("non-positive loop bound");
    _jump1924:;
    _223 = 0;
    int64_t _244 = 0; // r
    int64_t _245 = 0; // q
    int64_t _246 = 0; // p
    _jump1925:; // Begin body of loop
    _223 += _222;
    _244++;
    if (_244 < _238)
    goto _jump1925;
    _244 = 0;
    _245++;
    if (_245 < _237)
    goto _jump1925;
    _245 = 0;
    _246++;
    if (_246 < d)
    goto _jump1925;
    // End body of loop
    _208 += _223;
    _222++;
    if (_222 < _221)
    goto _jump1905;
    // End body of loop
    _207.d0 = _208;
    if (_208 > 0) 
    goto _jump1926;
    fail_assertion("non-positive loop bound");
    _jump1926:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= _208;
    _247 *= sizeof(bool);
    _207.data = jpl_alloc(_247);
    int64_t _248 = 0; // o
    _jump1927:; // Begin body of loop
    int64_t _249 = 0;
    _249 *= _207.d0;
    _249 += _248;
    _207.data[_249] = a;
    _248++;
    if (_248 < _208)
    goto _jump1927;
    // End body of loop
    int64_t _250 = f + f;
    return _250;
    return e;
}

int64_t o() {
    _a1__a2__a1_int64_t _0;
    // Computing bound for p
    _0.d0 = m;
    if (m > 0) 
    goto _jump1973;
    fail_assertion("non-positive loop bound");
    _jump1973:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= m;
    _1 *= sizeof(_a2__a1_int64_t);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // p
    _jump1974:; // Begin body of loop
    _a2__a1_int64_t _3;
    // Computing bound for q
    _3.d0 = i;
    if (i > 0) 
    goto _jump1975;
    fail_assertion("non-positive loop bound");
    _jump1975:;
    // Computing bound for r
    _3.d1 = f;
    if (f > 0) 
    goto _jump1976;
    fail_assertion("non-positive loop bound");
    _jump1976:;
    // Computing total size of heap memory to allocate
    int64_t _4 = 1;
    _4 *= i;
    _4 *= f;
    _4 *= sizeof(_a1_int64_t);
    _3.data = jpl_alloc(_4);
    int64_t _5 = 0; // r
    int64_t _6 = 0; // q
    _jump1977:; // Begin body of loop
    _a1_int64_t _7;
    _7.d0 = 1;
    _7.data = jpl_alloc(sizeof(int64_t) * 1);
    _7.data[0] = d;
    int64_t _8 = 0;
    _8 *= _3.d0;
    _8 += _6;
    _8 *= _3.d1;
    _8 += _5;
    _3.data[_8] = _7;
    _5++;
    if (_5 < f)
    goto _jump1977;
    _5 = 0;
    _6++;
    if (_6 < i)
    goto _jump1977;
    // End body of loop
    int64_t _9 = 0;
    _9 *= _0.d0;
    _9 += _2;
    _0.data[_9] = _3;
    _2++;
    if (_2 < m)
    goto _jump1974;
    // End body of loop
    bool _10 = true;
    return _0.d0;
    _a1__a2_rgba _11;
    // Computing bound for t
    _11.d0 = g;
    if (g > 0) 
    goto _jump1978;
    fail_assertion("non-positive loop bound");
    _jump1978:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= g;
    _12 *= sizeof(_a2_rgba);
    _11.data = jpl_alloc(_12);
    int64_t _13 = 0; // t
    _jump1979:; // Begin body of loop
    _a2_rgba _14;
    // Computing bound for u
    _14.d0 = m;
    if (m > 0) 
    goto _jump1980;
    fail_assertion("non-positive loop bound");
    _jump1980:;
    // Computing bound for v
    _14.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1981;
    fail_assertion("non-positive loop bound");
    _jump1981:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= m;
    _15 *= _0.d0;
    _15 *= sizeof(rgba);
    _14.data = jpl_alloc(_15);
    int64_t _16 = 0; // v
    int64_t _17 = 0; // u
    _jump1982:; // Begin body of loop
    double _18;
    // Computing bound for w
    if (i > 0) 
    goto _jump1983;
    fail_assertion("non-positive loop bound");
    _jump1983:;
    // Computing bound for x
    if (_0.d0 > 0) 
    goto _jump1984;
    fail_assertion("non-positive loop bound");
    _jump1984:;
    _18 = 0;
    int64_t _19 = 0; // x
    int64_t _20 = 0; // w
    _jump1985:; // Begin body of loop
    double _21;
    // Computing bound for y
    if (m > 0) 
    goto _jump1986;
    fail_assertion("non-positive loop bound");
    _jump1986:;
    _21 = 0;
    int64_t _22 = 0; // y
    _jump1987:; // Begin body of loop
    double _23 = 1.0;
    _21 += _23;
    _22++;
    if (_22 < m)
    goto _jump1987;
    // End body of loop
    _18 += _21;
    _19++;
    if (_19 < _0.d0)
    goto _jump1985;
    _19 = 0;
    _20++;
    if (_20 < i)
    goto _jump1985;
    // End body of loop
    double _24 = 22.0;
    double _25 = -_24;
    double _26 = _18 / _25;
    double _27 = -_26;
    _a1_double _28;
    // Computing bound for w
    int64_t _29 = _16 % e;
    _28.d0 = _29;
    if (_29 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _29;
    _30 *= sizeof(double);
    _28.data = jpl_alloc(_30);
    int64_t _31 = 0; // w
    _jump1989:; // Begin body of loop
    double _32 = 79.0;
    int64_t _33 = 0;
    _33 *= _28.d0;
    _33 += _31;
    _28.data[_33] = _32;
    _31++;
    if (_31 < _29)
    goto _jump1989;
    // End body of loop
    _a1_int64_t _34;
    _34.d0 = 1;
    _34.data = jpl_alloc(sizeof(int64_t) * 1);
    _34.data[0] = e;
    int64_t _35;
    // Computing bound for w
    if (_0.d0 > 0) 
    goto _jump1990;
    fail_assertion("non-positive loop bound");
    _jump1990:;
    // Computing bound for x
    int64_t _36 = 530;
    if (_36 > 0) 
    goto _jump1991;
    fail_assertion("non-positive loop bound");
    _jump1991:;
    _35 = 0;
    int64_t _37 = 0; // x
    int64_t _38 = 0; // w
    _jump1992:; // Begin body of loop
    _35 += m;
    _37++;
    if (_37 < _36)
    goto _jump1992;
    _37 = 0;
    _38++;
    if (_38 < _0.d0)
    goto _jump1992;
    // End body of loop
    if (_35 >= 0)
    goto _jump1993;
    fail_assertion("negative array index");
    _jump1993:;
    if (_35 < _34.d0)
    goto _jump1994;
    fail_assertion("index too large");
    _jump1994:;
    int64_t _39 = 0;
    _39 *= _34.d0;
    _39 += _35;
    int64_t _40 = _34.data[_39];
    if (_40 >= 0)
    goto _jump1995;
    fail_assertion("negative array index");
    _jump1995:;
    if (_40 < _28.d0)
    goto _jump1996;
    fail_assertion("index too large");
    _jump1996:;
    int64_t _41 = 0;
    _41 *= _28.d0;
    _41 += _40;
    double _42 = _28.data[_41];
    double _43 = -_42;
    _a3_double _44;
    // Computing bound for w
    int64_t _45 = o();
    _44.d0 = _45;
    if (_45 > 0) 
    goto _jump1997;
    fail_assertion("non-positive loop bound");
    _jump1997:;
    // Computing bound for x
    _44.d1 = i;
    if (i > 0) 
    goto _jump1998;
    fail_assertion("non-positive loop bound");
    _jump1998:;
    // Computing bound for y
    _44.d2 = d;
    if (d > 0) 
    goto _jump1999;
    fail_assertion("non-positive loop bound");
    _jump1999:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= _45;
    _46 *= i;
    _46 *= d;
    _46 *= sizeof(double);
    _44.data = jpl_alloc(_46);
    int64_t _47 = 0; // y
    int64_t _48 = 0; // x
    int64_t _49 = 0; // w
    _jump2000:; // Begin body of loop
    double _50 = 45.0;
    int64_t _51 = 0;
    _51 *= _44.d0;
    _51 += _49;
    _51 *= _44.d1;
    _51 += _48;
    _51 *= _44.d2;
    _51 += _47;
    _44.data[_51] = _50;
    _47++;
    if (_47 < d)
    goto _jump2000;
    _47 = 0;
    _48++;
    if (_48 < i)
    goto _jump2000;
    _48 = 0;
    _49++;
    if (_49 < _45)
    goto _jump2000;
    // End body of loop
    if (g >= 0)
    goto _jump2001;
    fail_assertion("negative array index");
    _jump2001:;
    if (g < _44.d0)
    goto _jump2002;
    fail_assertion("index too large");
    _jump2002:;
    if (e >= 0)
    goto _jump2003;
    fail_assertion("negative array index");
    _jump2003:;
    if (e < _44.d1)
    goto _jump2004;
    fail_assertion("index too large");
    _jump2004:;
    if (_16 >= 0)
    goto _jump2005;
    fail_assertion("negative array index");
    _jump2005:;
    if (_16 < _44.d2)
    goto _jump2006;
    fail_assertion("index too large");
    _jump2006:;
    int64_t _52 = 0;
    _52 *= _44.d0;
    _52 += g;
    _52 *= _44.d1;
    _52 += e;
    _52 *= _44.d2;
    _52 += _16;
    double _53 = _44.data[_52];
    double _54 = -_53;
    double _55 = 90.0;
    rgba _56 = { _27, _43, _54, _55 };
    int64_t _57 = 0;
    _57 *= _14.d0;
    _57 += _17;
    _57 *= _14.d1;
    _57 += _16;
    _14.data[_57] = _56;
    _16++;
    if (_16 < _0.d0)
    goto _jump1982;
    _16 = 0;
    _17++;
    if (_17 < m)
    goto _jump1982;
    // End body of loop
    int64_t _58 = 0;
    _58 *= _11.d0;
    _58 += _13;
    _11.data[_58] = _14;
    _13++;
    if (_13 < g)
    goto _jump1979;
    // End body of loop
    bool _60;
    if (!a)
    goto _jump2007;
    bool _61 = true;
    _60 = _61;
    goto _jump2008;
    _jump2007:;
    _60 = h;
    _jump2008:;
    bool _59 = _60;
    if (0 == _60)
    goto _jump2009;
    bool _63 = true;
    bool _62 = _63;
    if (0 == _63)
    goto _jump2010;
    bool _64 = _10;
    if (0 == _10)
    goto _jump2011;
    if (_0.d0 >= 0)
    goto _jump2012;
    fail_assertion("negative array index");
    _jump2012:;
    if (_0.d0 < c.d0)
    goto _jump2013;
    fail_assertion("index too large");
    _jump2013:;
    if (g >= 0)
    goto _jump2014;
    fail_assertion("negative array index");
    _jump2014:;
    if (g < c.d1)
    goto _jump2015;
    fail_assertion("index too large");
    _jump2015:;
    if (m >= 0)
    goto _jump2016;
    fail_assertion("negative array index");
    _jump2016:;
    if (m < c.d2)
    goto _jump2017;
    fail_assertion("index too large");
    _jump2017:;
    int64_t _65 = 0;
    _65 *= c.d0;
    _65 += _0.d0;
    _65 *= c.d1;
    _65 += g;
    _65 *= c.d2;
    _65 += m;
    bool _66 = c.data[_65];
    _64 = _66;
    _jump2011:;
    _62 = _64;
    _jump2010:;
    _a3_bool _67;
    if (!_62)
    goto _jump2018;
    _a3_bool _68;
    // Computing bound for v
    _a2_double _69;
    // Computing bound for v
    _69.d0 = f;
    if (f > 0) 
    goto _jump2019;
    fail_assertion("non-positive loop bound");
    _jump2019:;
    // Computing bound for w
    _69.d1 = g;
    if (g > 0) 
    goto _jump2020;
    fail_assertion("non-positive loop bound");
    _jump2020:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= f;
    _70 *= g;
    _70 *= sizeof(double);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // w
    int64_t _72 = 0; // v
    _jump2021:; // Begin body of loop
    double _73 = 15.0;
    int64_t _74 = 0;
    _74 *= _69.d0;
    _74 += _72;
    _74 *= _69.d1;
    _74 += _71;
    _69.data[_74] = _73;
    _71++;
    if (_71 < g)
    goto _jump2021;
    _71 = 0;
    _72++;
    if (_72 < f)
    goto _jump2021;
    // End body of loop
    int64_t _75 = b(_69);
    _68.d0 = _75;
    if (_75 > 0) 
    goto _jump2022;
    fail_assertion("non-positive loop bound");
    _jump2022:;
    // Computing bound for w
    _68.d1 = _11.d0;
    if (_11.d0 > 0) 
    goto _jump2023;
    fail_assertion("non-positive loop bound");
    _jump2023:;
    // Computing bound for x
    int64_t _76 = e / i;
    _68.d2 = _76;
    if (_76 > 0) 
    goto _jump2024;
    fail_assertion("non-positive loop bound");
    _jump2024:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _75;
    _77 *= _11.d0;
    _77 *= _76;
    _77 *= sizeof(bool);
    _68.data = jpl_alloc(_77);
    int64_t _78 = 0; // x
    int64_t _79 = 0; // w
    int64_t _80 = 0; // v
    _jump2025:; // Begin body of loop
    int64_t _81 = 0;
    _81 *= _68.d0;
    _81 += _80;
    _81 *= _68.d1;
    _81 += _79;
    _81 *= _68.d2;
    _81 += _78;
    _68.data[_81] = _10;
    _78++;
    if (_78 < _76)
    goto _jump2025;
    _78 = 0;
    _79++;
    if (_79 < _11.d0)
    goto _jump2025;
    _79 = 0;
    _80++;
    if (_80 < _75)
    goto _jump2025;
    // End body of loop
    _67 = _68;
    goto _jump2026;
    _jump2018:;
    _67 = n;
    _jump2026:;
    if (_0.d0 >= 0)
    goto _jump2027;
    fail_assertion("negative array index");
    _jump2027:;
    if (_0.d0 < _67.d0)
    goto _jump2028;
    fail_assertion("index too large");
    _jump2028:;
    if (_0.d0 >= 0)
    goto _jump2029;
    fail_assertion("negative array index");
    _jump2029:;
    if (_0.d0 < _67.d1)
    goto _jump2030;
    fail_assertion("index too large");
    _jump2030:;
    if (f >= 0)
    goto _jump2031;
    fail_assertion("negative array index");
    _jump2031:;
    if (f < _67.d2)
    goto _jump2032;
    fail_assertion("index too large");
    _jump2032:;
    int64_t _82 = 0;
    _82 *= _67.d0;
    _82 += _0.d0;
    _82 *= _67.d1;
    _82 += _0.d0;
    _82 *= _67.d2;
    _82 += f;
    bool _83 = _67.data[_82];
    bool _84 = !_83;
    _59 = _84;
    _jump2009:;
    return f;
}

double v() {
    bool _1 = true;
    bool _0 = _1;
    if (0 == _1)
    goto _jump2202;
    bool _2;
    if (!h)
    goto _jump2203;
    _2 = a;
    goto _jump2204;
    _jump2203:;
    _2 = h;
    _jump2204:;
    _0 = _2;
    _jump2202:;
    bool _3;
    if (!_0)
    goto _jump2205;
    bool _4 = false;
    bool _5;
    if (!_4)
    goto _jump2206;
    bool _6 = true;
    _5 = _6;
    goto _jump2207;
    _jump2206:;
    _5 = a;
    _jump2207:;
    bool _7 = !_5;
    _3 = _7;
    goto _jump2208;
    _jump2205:;
    int64_t _8 = n.d0 % s;
    if (_8 >= 0)
    goto _jump2209;
    fail_assertion("negative array index");
    _jump2209:;
    if (_8 < p.d0)
    goto _jump2210;
    fail_assertion("index too large");
    _jump2210:;
    if (r >= 0)
    goto _jump2211;
    fail_assertion("negative array index");
    _jump2211:;
    if (r < p.d1)
    goto _jump2212;
    fail_assertion("index too large");
    _jump2212:;
    int64_t _9 = 0;
    _9 *= p.d0;
    _9 += _8;
    _9 *= p.d1;
    _9 += r;
    bool _10 = p.data[_9];
    _3 = _10;
    _jump2208:;
    _a1_bool _11;
    if (!_3)
    goto _jump2213;
    bool _12;
    if (!h)
    goto _jump2214;
    bool _13 = false;
    _12 = _13;
    goto _jump2215;
    _jump2214:;
    bool _14 = !a;
    _12 = _14;
    _jump2215:;
    _a1_bool _15;
    if (!_12)
    goto _jump2216;
    _a1_bool _16;
    // Computing bound for A
    _16.d0 = s;
    if (s > 0) 
    goto _jump2217;
    fail_assertion("non-positive loop bound");
    _jump2217:;
    // Computing total size of heap memory to allocate
    int64_t _17 = 1;
    _17 *= s;
    _17 *= sizeof(bool);
    _16.data = jpl_alloc(_17);
    int64_t _18 = 0; // A
    _jump2218:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _16.d0;
    _19 += _18;
    _16.data[_19] = h;
    _18++;
    if (_18 < s)
    goto _jump2218;
    // End body of loop
    _15 = _16;
    goto _jump2219;
    _jump2216:;
    _a1_bool _20;
    // Computing bound for A
    _20.d0 = f;
    if (f > 0) 
    goto _jump2220;
    fail_assertion("non-positive loop bound");
    _jump2220:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= f;
    _21 *= sizeof(bool);
    _20.data = jpl_alloc(_21);
    int64_t _22 = 0; // A
    _jump2221:; // Begin body of loop
    bool _23 = false;
    bool _24 = !_23;
    int64_t _25 = 0;
    _25 *= _20.d0;
    _25 += _22;
    _20.data[_25] = _24;
    _22++;
    if (_22 < f)
    goto _jump2221;
    // End body of loop
    _15 = _20;
    _jump2219:;
    _11 = _15;
    goto _jump2222;
    _jump2213:;
    _a1_bool _26;
    // Computing bound for A
    _26.d0 = f;
    if (f > 0) 
    goto _jump2223;
    fail_assertion("non-positive loop bound");
    _jump2223:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= f;
    _27 *= sizeof(bool);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // A
    _jump2224:; // Begin body of loop
    bool _29 = t >= n.d1;
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += _28;
    _26.data[_30] = _29;
    _28++;
    if (_28 < f)
    goto _jump2224;
    // End body of loop
    _11 = _26;
    _jump2222:;
    if (m >= 0)
    goto _jump2225;
    fail_assertion("negative array index");
    _jump2225:;
    if (m < _11.d0)
    goto _jump2226;
    fail_assertion("index too large");
    _jump2226:;
    int64_t _31 = 0;
    _31 *= _11.d0;
    _31 += m;
    bool _32 = _11.data[_31];
    _a1__a1_int64_t _33;
    if (!_32)
    goto _jump2227;
    _a2__a1__a1_int64_t _34;
    // Computing bound for A
    int64_t _35;
    // Computing bound for A
    if (i > 0) 
    goto _jump2228;
    fail_assertion("non-positive loop bound");
    _jump2228:;
    // Computing bound for B
    if (n.d1 > 0) 
    goto _jump2229;
    fail_assertion("non-positive loop bound");
    _jump2229:;
    _35 = 0;
    int64_t _36 = 0; // B
    int64_t _37 = 0; // A
    _jump2230:; // Begin body of loop
    _35 += t;
    _36++;
    if (_36 < n.d1)
    goto _jump2230;
    _36 = 0;
    _37++;
    if (_37 < i)
    goto _jump2230;
    // End body of loop
    _34.d0 = _35;
    if (_35 > 0) 
    goto _jump2231;
    fail_assertion("non-positive loop bound");
    _jump2231:;
    // Computing bound for B
    _34.d1 = f;
    if (f > 0) 
    goto _jump2232;
    fail_assertion("non-positive loop bound");
    _jump2232:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= _35;
    _38 *= f;
    _38 *= sizeof(_a1__a1_int64_t);
    _34.data = jpl_alloc(_38);
    int64_t _39 = 0; // B
    int64_t _40 = 0; // A
    _jump2233:; // Begin body of loop
    int64_t _41 = 155;
    bool _42 = _41 >= n.d1;
    _a1_int64_t _43;
    if (!_42)
    goto _jump2234;
    _a1_int64_t _44;
    _44.d0 = 2;
    _44.data = jpl_alloc(sizeof(int64_t) * 2);
    _44.data[0] = m;
    _44.data[1] = r;
    _43 = _44;
    goto _jump2235;
    _jump2234:;
    _a1_int64_t _45;
    _45.d0 = 3;
    _45.data = jpl_alloc(sizeof(int64_t) * 3);
    _45.data[0] = n.d2;
    _45.data[1] = n.d1;
    _45.data[2] = d;
    _43 = _45;
    _jump2235:;
    bool _46 = false;
    _a1_int64_t _47;
    if (!_46)
    goto _jump2236;
    _a1_int64_t _48;
    // Computing bound for C
    _48.d0 = q;
    if (q > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= q;
    _49 *= sizeof(int64_t);
    _48.data = jpl_alloc(_49);
    int64_t _50 = 0; // C
    _jump2238:; // Begin body of loop
    int64_t _51 = 0;
    _51 *= _48.d0;
    _51 += _50;
    _48.data[_51] = _50;
    _50++;
    if (_50 < q)
    goto _jump2238;
    // End body of loop
    _47 = _48;
    goto _jump2239;
    _jump2236:;
    _a1_int64_t _52;
    _52.d0 = 2;
    _52.data = jpl_alloc(sizeof(int64_t) * 2);
    _52.data[0] = q;
    _52.data[1] = d;
    _47 = _52;
    _jump2239:;
    int64_t _53;
    // Computing bound for C
    if (g > 0) 
    goto _jump2240;
    fail_assertion("non-positive loop bound");
    _jump2240:;
    // Computing bound for D
    if (_39 > 0) 
    goto _jump2241;
    fail_assertion("non-positive loop bound");
    _jump2241:;
    _53 = 0;
    int64_t _54 = 0; // D
    int64_t _55 = 0; // C
    _jump2242:; // Begin body of loop
    int64_t _56 = o();
    _53 += _56;
    _54++;
    if (_54 < _39)
    goto _jump2242;
    _54 = 0;
    _55++;
    if (_55 < g)
    goto _jump2242;
    // End body of loop
    _a1_int64_t _57;
    _57.d0 = 1;
    _57.data = jpl_alloc(sizeof(int64_t) * 1);
    _57.data[0] = _53;
    _a1__a1_int64_t _58;
    _58.d0 = 3;
    _58.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _58.data[0] = _43;
    _58.data[1] = _47;
    _58.data[2] = _57;
    int64_t _59 = 0;
    _59 *= _34.d0;
    _59 += _40;
    _59 *= _34.d1;
    _59 += _39;
    _34.data[_59] = _58;
    _39++;
    if (_39 < f)
    goto _jump2233;
    _39 = 0;
    _40++;
    if (_40 < _35)
    goto _jump2233;
    // End body of loop
    if (i >= 0)
    goto _jump2243;
    fail_assertion("negative array index");
    _jump2243:;
    if (i < _34.d0)
    goto _jump2244;
    fail_assertion("index too large");
    _jump2244:;
    if (n.d0 >= 0)
    goto _jump2245;
    fail_assertion("negative array index");
    _jump2245:;
    if (n.d0 < _34.d1)
    goto _jump2246;
    fail_assertion("index too large");
    _jump2246:;
    int64_t _60 = 0;
    _60 *= _34.d0;
    _60 += i;
    _60 *= _34.d1;
    _60 += n.d0;
    _a1__a1_int64_t _61 = _34.data[_60];
    _33 = _61;
    goto _jump2247;
    _jump2227:;
    _a3__a1_int64_t _62;
    // Computing bound for A
    _62.d0 = i;
    if (i > 0) 
    goto _jump2248;
    fail_assertion("non-positive loop bound");
    _jump2248:;
    // Computing bound for B
    int64_t _63 = o();
    bool _64 = _63 > r;
    int64_t _65;
    if (!_64)
    goto _jump2249;
    _65 = r;
    goto _jump2250;
    _jump2249:;
    _65 = t;
    _jump2250:;
    _62.d1 = _65;
    if (_65 > 0) 
    goto _jump2251;
    fail_assertion("non-positive loop bound");
    _jump2251:;
    // Computing bound for C
    _62.d2 = i;
    if (i > 0) 
    goto _jump2252;
    fail_assertion("non-positive loop bound");
    _jump2252:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= i;
    _66 *= _65;
    _66 *= i;
    _66 *= sizeof(_a1_int64_t);
    _62.data = jpl_alloc(_66);
    int64_t _67 = 0; // C
    int64_t _68 = 0; // B
    int64_t _69 = 0; // A
    _jump2253:; // Begin body of loop
    bool _70 = false;
    bool _71 = !_70;
    _a1_int64_t _72;
    if (!_71)
    goto _jump2254;
    _a1_int64_t _73;
    // Computing bound for D
    _73.d0 = s;
    if (s > 0) 
    goto _jump2255;
    fail_assertion("non-positive loop bound");
    _jump2255:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= s;
    _74 *= sizeof(int64_t);
    _73.data = jpl_alloc(_74);
    int64_t _75 = 0; // D
    _jump2256:; // Begin body of loop
    int64_t _76 = 0;
    _76 *= _73.d0;
    _76 += _75;
    _73.data[_76] = _69;
    _75++;
    if (_75 < s)
    goto _jump2256;
    // End body of loop
    _72 = _73;
    goto _jump2257;
    _jump2254:;
    _a1_int64_t _77;
    // Computing bound for D
    _77.d0 = e;
    if (e > 0) 
    goto _jump2258;
    fail_assertion("non-positive loop bound");
    _jump2258:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= e;
    _78 *= sizeof(int64_t);
    _77.data = jpl_alloc(_78);
    int64_t _79 = 0; // D
    _jump2259:; // Begin body of loop
    int64_t _80 = 0;
    _80 *= _77.d0;
    _80 += _79;
    _77.data[_80] = n.d1;
    _79++;
    if (_79 < e)
    goto _jump2259;
    // End body of loop
    _72 = _77;
    _jump2257:;
    int64_t _81 = 0;
    _81 *= _62.d0;
    _81 += _69;
    _81 *= _62.d1;
    _81 += _68;
    _81 *= _62.d2;
    _81 += _67;
    _62.data[_81] = _72;
    _67++;
    if (_67 < i)
    goto _jump2253;
    _67 = 0;
    _68++;
    if (_68 < _65)
    goto _jump2253;
    _68 = 0;
    _69++;
    if (_69 < i)
    goto _jump2253;
    // End body of loop
    if (q >= 0)
    goto _jump2260;
    fail_assertion("negative array index");
    _jump2260:;
    if (q < _62.d0)
    goto _jump2261;
    fail_assertion("index too large");
    _jump2261:;
    if (n.d0 >= 0)
    goto _jump2262;
    fail_assertion("negative array index");
    _jump2262:;
    if (n.d0 < _62.d1)
    goto _jump2263;
    fail_assertion("index too large");
    _jump2263:;
    if (n.d0 >= 0)
    goto _jump2264;
    fail_assertion("negative array index");
    _jump2264:;
    if (n.d0 < _62.d2)
    goto _jump2265;
    fail_assertion("index too large");
    _jump2265:;
    int64_t _82 = 0;
    _82 *= _62.d0;
    _82 += q;
    _82 *= _62.d1;
    _82 += n.d0;
    _82 *= _62.d2;
    _82 += n.d0;
    _a1_int64_t _83 = _62.data[_82];
    _a1__a1_int64_t _84;
    _84.d0 = 1;
    _84.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _84.data[0] = _83;
    _33 = _84;
    _jump2247:;
    bool _85 = !a;
    int64_t _86;
    if (!_85)
    goto _jump2266;
    _86 = q;
    goto _jump2267;
    _jump2266:;
    _86 = q;
    _jump2267:;
    if (_86 >= 0)
    goto _jump2268;
    fail_assertion("negative array index");
    _jump2268:;
    if (_86 < _33.d0)
    goto _jump2269;
    fail_assertion("index too large");
    _jump2269:;
    int64_t _87 = 0;
    _87 *= _33.d0;
    _87 += _86;
    _a1_int64_t _88 = _33.data[_87];
    _a1_int64_t _89;
    if (!h)
    goto _jump2270;
    _a3__a2__a1_int64_t _90;
    // Computing bound for C
    _90.d0 = i;
    if (i > 0) 
    goto _jump2271;
    fail_assertion("non-positive loop bound");
    _jump2271:;
    // Computing bound for D
    int64_t _91 = o();
    _90.d1 = _91;
    if (_91 > 0) 
    goto _jump2272;
    fail_assertion("non-positive loop bound");
    _jump2272:;
    // Computing bound for E
    _90.d2 = d;
    if (d > 0) 
    goto _jump2273;
    fail_assertion("non-positive loop bound");
    _jump2273:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= i;
    _92 *= _91;
    _92 *= d;
    _92 *= sizeof(_a2__a1_int64_t);
    _90.data = jpl_alloc(_92);
    int64_t _93 = 0; // E
    int64_t _94 = 0; // D
    int64_t _95 = 0; // C
    _jump2274:; // Begin body of loop
    _a2__a1_int64_t _96;
    // Computing bound for F
    _96.d0 = f;
    if (f > 0) 
    goto _jump2275;
    fail_assertion("non-positive loop bound");
    _jump2275:;
    // Computing bound for G
    _96.d1 = i;
    if (i > 0) 
    goto _jump2276;
    fail_assertion("non-positive loop bound");
    _jump2276:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= f;
    _97 *= i;
    _97 *= sizeof(_a1_int64_t);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // G
    int64_t _99 = 0; // F
    _jump2277:; // Begin body of loop
    int64_t _100 = -s;
    _a1_int64_t _101;
    _101.d0 = 3;
    _101.data = jpl_alloc(sizeof(int64_t) * 3);
    _101.data[0] = _99;
    _101.data[1] = f;
    _101.data[2] = _100;
    int64_t _102 = 0;
    _102 *= _96.d0;
    _102 += _99;
    _102 *= _96.d1;
    _102 += _98;
    _96.data[_102] = _101;
    _98++;
    if (_98 < i)
    goto _jump2277;
    _98 = 0;
    _99++;
    if (_99 < f)
    goto _jump2277;
    // End body of loop
    int64_t _103 = 0;
    _103 *= _90.d0;
    _103 += _95;
    _103 *= _90.d1;
    _103 += _94;
    _103 *= _90.d2;
    _103 += _93;
    _90.data[_103] = _96;
    _93++;
    if (_93 < d)
    goto _jump2274;
    _93 = 0;
    _94++;
    if (_94 < _91)
    goto _jump2274;
    _94 = 0;
    _95++;
    if (_95 < i)
    goto _jump2274;
    // End body of loop
    int64_t _104;
    // Computing bound for C
    if (q > 0) 
    goto _jump2278;
    fail_assertion("non-positive loop bound");
    _jump2278:;
    _104 = 0;
    int64_t _105 = 0; // C
    _jump2279:; // Begin body of loop
    int64_t _106;
    // Computing bound for D
    if (t > 0) 
    goto _jump2280;
    fail_assertion("non-positive loop bound");
    _jump2280:;
    // Computing bound for E
    if (n.d2 > 0) 
    goto _jump2281;
    fail_assertion("non-positive loop bound");
    _jump2281:;
    // Computing bound for F
    if (_88.d0 > 0) 
    goto _jump2282;
    fail_assertion("non-positive loop bound");
    _jump2282:;
    _106 = 0;
    int64_t _107 = 0; // F
    int64_t _108 = 0; // E
    int64_t _109 = 0; // D
    _jump2283:; // Begin body of loop
    int64_t _110;
    // Computing bound for G
    int64_t _111 = o();
    if (_111 > 0) 
    goto _jump2284;
    fail_assertion("non-positive loop bound");
    _jump2284:;
    // Computing bound for H
    if (n.d2 > 0) 
    goto _jump2285;
    fail_assertion("non-positive loop bound");
    _jump2285:;
    // Computing bound for I
    if (_88.d0 > 0) 
    goto _jump2286;
    fail_assertion("non-positive loop bound");
    _jump2286:;
    _110 = 0;
    int64_t _112 = 0; // I
    int64_t _113 = 0; // H
    int64_t _114 = 0; // G
    _jump2287:; // Begin body of loop
    _110 += q;
    _112++;
    if (_112 < _88.d0)
    goto _jump2287;
    _112 = 0;
    _113++;
    if (_113 < n.d2)
    goto _jump2287;
    _113 = 0;
    _114++;
    if (_114 < _111)
    goto _jump2287;
    // End body of loop
    _106 += _110;
    _107++;
    if (_107 < _88.d0)
    goto _jump2283;
    _107 = 0;
    _108++;
    if (_108 < n.d2)
    goto _jump2283;
    _108 = 0;
    _109++;
    if (_109 < t)
    goto _jump2283;
    // End body of loop
    _104 += _106;
    _105++;
    if (_105 < q)
    goto _jump2279;
    // End body of loop
    int64_t _115 = _104 / r;
    int64_t _116;
    // Computing bound for C
    if (r > 0) 
    goto _jump2288;
    fail_assertion("non-positive loop bound");
    _jump2288:;
    _116 = 0;
    int64_t _117 = 0; // C
    _jump2289:; // Begin body of loop
    _116 += r;
    _117++;
    if (_117 < r)
    goto _jump2289;
    // End body of loop
    if (_115 >= 0)
    goto _jump2290;
    fail_assertion("negative array index");
    _jump2290:;
    if (_115 < _90.d0)
    goto _jump2291;
    fail_assertion("index too large");
    _jump2291:;
    if (_116 >= 0)
    goto _jump2292;
    fail_assertion("negative array index");
    _jump2292:;
    if (_116 < _90.d1)
    goto _jump2293;
    fail_assertion("index too large");
    _jump2293:;
    if (_88.d0 >= 0)
    goto _jump2294;
    fail_assertion("negative array index");
    _jump2294:;
    if (_88.d0 < _90.d2)
    goto _jump2295;
    fail_assertion("index too large");
    _jump2295:;
    int64_t _118 = 0;
    _118 *= _90.d0;
    _118 += _115;
    _118 *= _90.d1;
    _118 += _116;
    _118 *= _90.d2;
    _118 += _88.d0;
    _a2__a1_int64_t _119 = _90.data[_118];
    if (_88.d0 >= 0)
    goto _jump2296;
    fail_assertion("negative array index");
    _jump2296:;
    if (_88.d0 < _119.d0)
    goto _jump2297;
    fail_assertion("index too large");
    _jump2297:;
    if (f >= 0)
    goto _jump2298;
    fail_assertion("negative array index");
    _jump2298:;
    if (f < _119.d1)
    goto _jump2299;
    fail_assertion("index too large");
    _jump2299:;
    int64_t _120 = 0;
    _120 *= _119.d0;
    _120 += _88.d0;
    _120 *= _119.d1;
    _120 += f;
    _a1_int64_t _121 = _119.data[_120];
    _89 = _121;
    goto _jump2300;
    _jump2270:;
    _a1_int64_t _122;
    // Computing bound for C
    int64_t _123 = o();
    _122.d0 = _123;
    if (_123 > 0) 
    goto _jump2301;
    fail_assertion("non-positive loop bound");
    _jump2301:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _123;
    _124 *= sizeof(int64_t);
    _122.data = jpl_alloc(_124);
    int64_t _125 = 0; // C
    _jump2302:; // Begin body of loop
    int64_t _126 = 0;
    _126 *= _122.d0;
    _126 += _125;
    _122.data[_126] = n.d0;
    _125++;
    if (_125 < _123)
    goto _jump2302;
    // End body of loop
    _89 = _122;
    _jump2300:;
    double _127;
    // Computing bound for F
    if (m > 0) 
    goto _jump2303;
    fail_assertion("non-positive loop bound");
    _jump2303:;
    // Computing bound for G
    if (d > 0) 
    goto _jump2304;
    fail_assertion("non-positive loop bound");
    _jump2304:;
    _127 = 0;
    int64_t _128 = 0; // G
    int64_t _129 = 0; // F
    _jump2305:; // Begin body of loop
    double _130 = 96.0;
    _127 += _130;
    _128++;
    if (_128 < d)
    goto _jump2305;
    _128 = 0;
    _129++;
    if (_129 < m)
    goto _jump2305;
    // End body of loop
    return _127;
    _a1__a2_bool _131;
    // Computing bound for F
    _131.d0 = d;
    if (d > 0) 
    goto _jump2306;
    fail_assertion("non-positive loop bound");
    _jump2306:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= d;
    _132 *= sizeof(_a2_bool);
    _131.data = jpl_alloc(_132);
    int64_t _133 = 0; // F
    _jump2307:; // Begin body of loop
    _a1__a2_bool _134;
    // Computing bound for G
    _134.d0 = f;
    if (f > 0) 
    goto _jump2308;
    fail_assertion("non-positive loop bound");
    _jump2308:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= f;
    _135 *= sizeof(_a2_bool);
    _134.data = jpl_alloc(_135);
    int64_t _136 = 0; // G
    _jump2309:; // Begin body of loop
    int64_t _137 = o();
    int64_t _138 = m / _137;
    bool _139 = m <= _138;
    _a2_bool _140;
    if (!_139)
    goto _jump2310;
    _140 = p;
    goto _jump2311;
    _jump2310:;
    _a3__a2_bool _141;
    // Computing bound for H
    _141.d0 = _133;
    if (_133 > 0) 
    goto _jump2312;
    fail_assertion("non-positive loop bound");
    _jump2312:;
    // Computing bound for I
    _141.d1 = _88.d0;
    if (_88.d0 > 0) 
    goto _jump2313;
    fail_assertion("non-positive loop bound");
    _jump2313:;
    // Computing bound for J
    int64_t _142 = 476;
    _141.d2 = _142;
    if (_142 > 0) 
    goto _jump2314;
    fail_assertion("non-positive loop bound");
    _jump2314:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= _133;
    _143 *= _88.d0;
    _143 *= _142;
    _143 *= sizeof(_a2_bool);
    _141.data = jpl_alloc(_143);
    int64_t _144 = 0; // J
    int64_t _145 = 0; // I
    int64_t _146 = 0; // H
    _jump2315:; // Begin body of loop
    int64_t _147 = 0;
    _147 *= _141.d0;
    _147 += _146;
    _147 *= _141.d1;
    _147 += _145;
    _147 *= _141.d2;
    _147 += _144;
    _141.data[_147] = p;
    _144++;
    if (_144 < _142)
    goto _jump2315;
    _144 = 0;
    _145++;
    if (_145 < _88.d0)
    goto _jump2315;
    _145 = 0;
    _146++;
    if (_146 < _133)
    goto _jump2315;
    // End body of loop
    int64_t _148;
    if (!a)
    goto _jump2316;
    _148 = i;
    goto _jump2317;
    _jump2316:;
    _148 = i;
    _jump2317:;
    if (t >= 0)
    goto _jump2318;
    fail_assertion("negative array index");
    _jump2318:;
    if (t < _141.d0)
    goto _jump2319;
    fail_assertion("index too large");
    _jump2319:;
    if (_148 >= 0)
    goto _jump2320;
    fail_assertion("negative array index");
    _jump2320:;
    if (_148 < _141.d1)
    goto _jump2321;
    fail_assertion("index too large");
    _jump2321:;
    if (r >= 0)
    goto _jump2322;
    fail_assertion("negative array index");
    _jump2322:;
    if (r < _141.d2)
    goto _jump2323;
    fail_assertion("index too large");
    _jump2323:;
    int64_t _149 = 0;
    _149 *= _141.d0;
    _149 += t;
    _149 *= _141.d1;
    _149 += _148;
    _149 *= _141.d2;
    _149 += r;
    _a2_bool _150 = _141.data[_149];
    _140 = _150;
    _jump2311:;
    int64_t _151 = 0;
    _151 *= _134.d0;
    _151 += _136;
    _134.data[_151] = _140;
    _136++;
    if (_136 < f)
    goto _jump2309;
    // End body of loop
    if (i >= 0)
    goto _jump2324;
    fail_assertion("negative array index");
    _jump2324:;
    if (i < _134.d0)
    goto _jump2325;
    fail_assertion("index too large");
    _jump2325:;
    int64_t _152 = 0;
    _152 *= _134.d0;
    _152 += i;
    _a2_bool _153 = _134.data[_152];
    int64_t _154 = 0;
    _154 *= _131.d0;
    _154 += _133;
    _131.data[_154] = _153;
    _133++;
    if (_133 < d)
    goto _jump2307;
    // End body of loop
    if (_89.d0 >= 0)
    goto _jump2326;
    fail_assertion("negative array index");
    _jump2326:;
    if (_89.d0 < _131.d0)
    goto _jump2327;
    fail_assertion("index too large");
    _jump2327:;
    int64_t _155 = 0;
    _155 *= _131.d0;
    _155 += _89.d0;
    _a2_bool _156 = _131.data[_155];
    double _157;
    // Computing bound for I
    if (_156.d1 > 0) 
    goto _jump2328;
    fail_assertion("non-positive loop bound");
    _jump2328:;
    // Computing bound for J
    int64_t _158 = o();
    int64_t _159 = -_158;
    if (_159 > 0) 
    goto _jump2329;
    fail_assertion("non-positive loop bound");
    _jump2329:;
    _157 = 0;
    int64_t _160 = 0; // J
    int64_t _161 = 0; // I
    _jump2330:; // Begin body of loop
    double _162 = 62.0;
    _157 += _162;
    _160++;
    if (_160 < _159)
    goto _jump2330;
    _160 = 0;
    _161++;
    if (_161 < _156.d1)
    goto _jump2330;
    // End body of loop
    _a1_double _163;
    _163.d0 = 2;
    _163.data = jpl_alloc(sizeof(double) * 2);
    _163.data[0] = _157;
    _163.data[1] = u;
    if (q >= 0)
    goto _jump2331;
    fail_assertion("negative array index");
    _jump2331:;
    if (q < _163.d0)
    goto _jump2332;
    fail_assertion("index too large");
    _jump2332:;
    int64_t _164 = 0;
    _164 *= _163.d0;
    _164 += q;
    double _165 = _163.data[_164];
    return _165;
}

_a3_rgba w() {
    int64_t _0 = -f;
    _a3_int64_t _1;
    // Computing bound for y
    _a3_int64_t _2;
    // Computing bound for y
    _2.d0 = g;
    if (g > 0) 
    goto _jump2333;
    fail_assertion("non-positive loop bound");
    _jump2333:;
    // Computing bound for z
    _2.d1 = e;
    if (e > 0) 
    goto _jump2334;
    fail_assertion("non-positive loop bound");
    _jump2334:;
    // Computing bound for A
    int64_t _3 = m + q;
    _2.d2 = _3;
    if (_3 > 0) 
    goto _jump2335;
    fail_assertion("non-positive loop bound");
    _jump2335:;
    // Computing total size of heap memory to allocate
    int64_t _4 = 1;
    _4 *= g;
    _4 *= e;
    _4 *= _3;
    _4 *= sizeof(int64_t);
    _2.data = jpl_alloc(_4);
    int64_t _5 = 0; // A
    int64_t _6 = 0; // z
    int64_t _7 = 0; // y
    _jump2336:; // Begin body of loop
    int64_t _8;
    if (!h)
    goto _jump2337;
    _8 = f;
    goto _jump2338;
    _jump2337:;
    _8 = t;
    _jump2338:;
    int64_t _9 = 0;
    _9 *= _2.d0;
    _9 += _7;
    _9 *= _2.d1;
    _9 += _6;
    _9 *= _2.d2;
    _9 += _5;
    _2.data[_9] = _8;
    _5++;
    if (_5 < _3)
    goto _jump2336;
    _5 = 0;
    _6++;
    if (_6 < e)
    goto _jump2336;
    _6 = 0;
    _7++;
    if (_7 < g)
    goto _jump2336;
    // End body of loop
    _a3_int64_t _10;
    // Computing bound for y
    int64_t _11;
    // Computing bound for y
    int64_t _12;
    // Computing bound for y
    if (e > 0) 
    goto _jump2339;
    fail_assertion("non-positive loop bound");
    _jump2339:;
    // Computing bound for z
    if (q > 0) 
    goto _jump2340;
    fail_assertion("non-positive loop bound");
    _jump2340:;
    // Computing bound for A
    if (e > 0) 
    goto _jump2341;
    fail_assertion("non-positive loop bound");
    _jump2341:;
    _12 = 0;
    int64_t _13 = 0; // A
    int64_t _14 = 0; // z
    int64_t _15 = 0; // y
    _jump2342:; // Begin body of loop
    _12 += _15;
    _13++;
    if (_13 < e)
    goto _jump2342;
    _13 = 0;
    _14++;
    if (_14 < q)
    goto _jump2342;
    _14 = 0;
    _15++;
    if (_15 < e)
    goto _jump2342;
    // End body of loop
    if (_12 > 0) 
    goto _jump2343;
    fail_assertion("non-positive loop bound");
    _jump2343:;
    _11 = 0;
    int64_t _16 = 0; // y
    _jump2344:; // Begin body of loop
    _11 += i;
    _16++;
    if (_16 < _12)
    goto _jump2344;
    // End body of loop
    _10.d0 = _11;
    if (_11 > 0) 
    goto _jump2345;
    fail_assertion("non-positive loop bound");
    _jump2345:;
    // Computing bound for z
    _10.d1 = t;
    if (t > 0) 
    goto _jump2346;
    fail_assertion("non-positive loop bound");
    _jump2346:;
    // Computing bound for A
    _a2_double _17;
    // Computing bound for y
    _17.d0 = d;
    if (d > 0) 
    goto _jump2347;
    fail_assertion("non-positive loop bound");
    _jump2347:;
    // Computing bound for z
    _17.d1 = e;
    if (e > 0) 
    goto _jump2348;
    fail_assertion("non-positive loop bound");
    _jump2348:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= d;
    _18 *= e;
    _18 *= sizeof(double);
    _17.data = jpl_alloc(_18);
    int64_t _19 = 0; // z
    int64_t _20 = 0; // y
    _jump2349:; // Begin body of loop
    int64_t _21 = 0;
    _21 *= _17.d0;
    _21 += _20;
    _21 *= _17.d1;
    _21 += _19;
    _17.data[_21] = u;
    _19++;
    if (_19 < e)
    goto _jump2349;
    _19 = 0;
    _20++;
    if (_20 < d)
    goto _jump2349;
    // End body of loop
    int64_t _22 = b(_17);
    _10.d2 = _22;
    if (_22 > 0) 
    goto _jump2350;
    fail_assertion("non-positive loop bound");
    _jump2350:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= _11;
    _23 *= t;
    _23 *= _22;
    _23 *= sizeof(int64_t);
    _10.data = jpl_alloc(_23);
    int64_t _24 = 0; // A
    int64_t _25 = 0; // z
    int64_t _26 = 0; // y
    _jump2351:; // Begin body of loop
    int64_t _27 = 0;
    _27 *= _10.d0;
    _27 += _26;
    _27 *= _10.d1;
    _27 += _25;
    _27 *= _10.d2;
    _27 += _24;
    _10.data[_27] = _25;
    _24++;
    if (_24 < _22)
    goto _jump2351;
    _24 = 0;
    _25++;
    if (_25 < t)
    goto _jump2351;
    _25 = 0;
    _26++;
    if (_26 < _11)
    goto _jump2351;
    // End body of loop
    _a3_int64_t _28;
    if (!h)
    goto _jump2352;
    _a3_int64_t _29;
    // Computing bound for y
    int64_t _30 = q / _0;
    _29.d0 = _30;
    if (_30 > 0) 
    goto _jump2353;
    fail_assertion("non-positive loop bound");
    _jump2353:;
    // Computing bound for z
    _29.d1 = e;
    if (e > 0) 
    goto _jump2354;
    fail_assertion("non-positive loop bound");
    _jump2354:;
    // Computing bound for A
    int64_t _31 = o();
    _29.d2 = _31;
    if (_31 > 0) 
    goto _jump2355;
    fail_assertion("non-positive loop bound");
    _jump2355:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _30;
    _32 *= e;
    _32 *= _31;
    _32 *= sizeof(int64_t);
    _29.data = jpl_alloc(_32);
    int64_t _33 = 0; // A
    int64_t _34 = 0; // z
    int64_t _35 = 0; // y
    _jump2356:; // Begin body of loop
    int64_t _36 = 0;
    _36 *= _29.d0;
    _36 += _35;
    _36 *= _29.d1;
    _36 += _34;
    _36 *= _29.d2;
    _36 += _33;
    _29.data[_36] = _35;
    _33++;
    if (_33 < _31)
    goto _jump2356;
    _33 = 0;
    _34++;
    if (_34 < e)
    goto _jump2356;
    _34 = 0;
    _35++;
    if (_35 < _30)
    goto _jump2356;
    // End body of loop
    _28 = _29;
    goto _jump2357;
    _jump2352:;
    _a3_int64_t _37;
    // Computing bound for y
    int64_t _38 = 974;
    _37.d0 = _38;
    if (_38 > 0) 
    goto _jump2358;
    fail_assertion("non-positive loop bound");
    _jump2358:;
    // Computing bound for z
    int64_t _39 = -q;
    _37.d1 = _39;
    if (_39 > 0) 
    goto _jump2359;
    fail_assertion("non-positive loop bound");
    _jump2359:;
    // Computing bound for A
    _37.d2 = _0;
    if (_0 > 0) 
    goto _jump2360;
    fail_assertion("non-positive loop bound");
    _jump2360:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= _38;
    _40 *= _39;
    _40 *= _0;
    _40 *= sizeof(int64_t);
    _37.data = jpl_alloc(_40);
    int64_t _41 = 0; // A
    int64_t _42 = 0; // z
    int64_t _43 = 0; // y
    _jump2361:; // Begin body of loop
    int64_t _44 = 0;
    _44 *= _37.d0;
    _44 += _43;
    _44 *= _37.d1;
    _44 += _42;
    _44 *= _37.d2;
    _44 += _41;
    _37.data[_44] = t;
    _41++;
    if (_41 < _0)
    goto _jump2361;
    _41 = 0;
    _42++;
    if (_42 < _39)
    goto _jump2361;
    _42 = 0;
    _43++;
    if (_43 < _38)
    goto _jump2361;
    // End body of loop
    _28 = _37;
    _jump2357:;
    _a1__a3_int64_t _45;
    _45.d0 = 3;
    _45.data = jpl_alloc(sizeof(_a3_int64_t) * 3);
    _45.data[0] = _2;
    _45.data[1] = _10;
    _45.data[2] = _28;
    if (m >= 0)
    goto _jump2362;
    fail_assertion("negative array index");
    _jump2362:;
    if (m < _45.d0)
    goto _jump2363;
    fail_assertion("index too large");
    _jump2363:;
    int64_t _46 = 0;
    _46 *= _45.d0;
    _46 += m;
    _a3_int64_t _47 = _45.data[_46];
    if (_0 >= 0)
    goto _jump2364;
    fail_assertion("negative array index");
    _jump2364:;
    if (_0 < _47.d0)
    goto _jump2365;
    fail_assertion("index too large");
    _jump2365:;
    if (m >= 0)
    goto _jump2366;
    fail_assertion("negative array index");
    _jump2366:;
    if (m < _47.d1)
    goto _jump2367;
    fail_assertion("index too large");
    _jump2367:;
    if (s >= 0)
    goto _jump2368;
    fail_assertion("negative array index");
    _jump2368:;
    if (s < _47.d2)
    goto _jump2369;
    fail_assertion("index too large");
    _jump2369:;
    int64_t _48 = 0;
    _48 *= _47.d0;
    _48 += _0;
    _48 *= _47.d1;
    _48 += m;
    _48 *= _47.d2;
    _48 += s;
    int64_t _49 = _47.data[_48];
    _1.d0 = _49;
    if (_49 > 0) 
    goto _jump2370;
    fail_assertion("non-positive loop bound");
    _jump2370:;
    // Computing bound for z
    int64_t _50 = -f;
    _1.d1 = _50;
    if (_50 > 0) 
    goto _jump2371;
    fail_assertion("non-positive loop bound");
    _jump2371:;
    // Computing bound for A
    int64_t _51;
    // Computing bound for y
    int64_t _52;
    // Computing bound for y
    if (m > 0) 
    goto _jump2372;
    fail_assertion("non-positive loop bound");
    _jump2372:;
    // Computing bound for z
    if (i > 0) 
    goto _jump2373;
    fail_assertion("non-positive loop bound");
    _jump2373:;
    // Computing bound for A
    if (_0 > 0) 
    goto _jump2374;
    fail_assertion("non-positive loop bound");
    _jump2374:;
    _52 = 0;
    int64_t _53 = 0; // A
    int64_t _54 = 0; // z
    int64_t _55 = 0; // y
    _jump2375:; // Begin body of loop
    int64_t _56 = -r;
    int64_t _57 = f - _56;
    _52 += _57;
    _53++;
    if (_53 < _0)
    goto _jump2375;
    _53 = 0;
    _54++;
    if (_54 < i)
    goto _jump2375;
    _54 = 0;
    _55++;
    if (_55 < m)
    goto _jump2375;
    // End body of loop
    int64_t _58;
    // Computing bound for y
    bool _59 = false;
    int64_t _60;
    if (!_59)
    goto _jump2376;
    _60 = i;
    goto _jump2377;
    _jump2376:;
    _60 = t;
    _jump2377:;
    if (_60 > 0) 
    goto _jump2378;
    fail_assertion("non-positive loop bound");
    _jump2378:;
    // Computing bound for z
    int64_t _61 = o();
    if (_61 > 0) 
    goto _jump2379;
    fail_assertion("non-positive loop bound");
    _jump2379:;
    _58 = 0;
    int64_t _62 = 0; // z
    int64_t _63 = 0; // y
    _jump2380:; // Begin body of loop
    _58 += g;
    _62++;
    if (_62 < _61)
    goto _jump2380;
    _62 = 0;
    _63++;
    if (_63 < _60)
    goto _jump2380;
    // End body of loop
    int64_t _64 = _52 * _58;
    if (_64 > 0) 
    goto _jump2381;
    fail_assertion("non-positive loop bound");
    _jump2381:;
    // Computing bound for z
    if (q > 0) 
    goto _jump2382;
    fail_assertion("non-positive loop bound");
    _jump2382:;
    // Computing bound for A
    if (q > 0) 
    goto _jump2383;
    fail_assertion("non-positive loop bound");
    _jump2383:;
    _51 = 0;
    int64_t _65 = 0; // A
    int64_t _66 = 0; // z
    int64_t _67 = 0; // y
    _jump2384:; // Begin body of loop
    _51 += g;
    _65++;
    if (_65 < q)
    goto _jump2384;
    _65 = 0;
    _66++;
    if (_66 < q)
    goto _jump2384;
    _66 = 0;
    _67++;
    if (_67 < _64)
    goto _jump2384;
    // End body of loop
    int64_t _68 = -_51;
    _1.d2 = _68;
    if (_68 > 0) 
    goto _jump2385;
    fail_assertion("non-positive loop bound");
    _jump2385:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= _49;
    _69 *= _50;
    _69 *= _68;
    _69 *= sizeof(int64_t);
    _1.data = jpl_alloc(_69);
    int64_t _70 = 0; // A
    int64_t _71 = 0; // z
    int64_t _72 = 0; // y
    _jump2386:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _1.d0;
    _73 += _72;
    _73 *= _1.d1;
    _73 += _71;
    _73 *= _1.d2;
    _73 += _70;
    _1.data[_73] = f;
    _70++;
    if (_70 < _68)
    goto _jump2386;
    _70 = 0;
    _71++;
    if (_71 < _50)
    goto _jump2386;
    _71 = 0;
    _72++;
    if (_72 < _49)
    goto _jump2386;
    // End body of loop
    _a2_bool _74;
    // Computing bound for G
    int64_t _75;
    // Computing bound for G
    if (_0 > 0) 
    goto _jump2387;
    fail_assertion("non-positive loop bound");
    _jump2387:;
    _75 = 0;
    int64_t _76 = 0; // G
    _jump2388:; // Begin body of loop
    _75 += _1.d1;
    _76++;
    if (_76 < _0)
    goto _jump2388;
    // End body of loop
    _74.d0 = _75;
    if (_75 > 0) 
    goto _jump2389;
    fail_assertion("non-positive loop bound");
    _jump2389:;
    // Computing bound for H
    _74.d1 = _1.d2;
    if (_1.d2 > 0) 
    goto _jump2390;
    fail_assertion("non-positive loop bound");
    _jump2390:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _75;
    _77 *= _1.d2;
    _77 *= sizeof(bool);
    _74.data = jpl_alloc(_77);
    int64_t _78 = 0; // H
    int64_t _79 = 0; // G
    _jump2391:; // Begin body of loop
    bool _80 = false;
    int64_t _81 = 0;
    _81 *= _74.d0;
    _81 += _79;
    _81 *= _74.d1;
    _81 += _78;
    _74.data[_81] = _80;
    _78++;
    if (_78 < _1.d2)
    goto _jump2391;
    _78 = 0;
    _79++;
    if (_79 < _75)
    goto _jump2391;
    // End body of loop
    bool _82 = _74.d0 <= _1.d2;
    _a2__a1_int64_t _83;
    if (!_82)
    goto _jump2392;
    _a2__a1_int64_t _84;
    // Computing bound for J
    _84.d0 = _74.d1;
    if (_74.d1 > 0) 
    goto _jump2393;
    fail_assertion("non-positive loop bound");
    _jump2393:;
    // Computing bound for K
    _84.d1 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump2394;
    fail_assertion("non-positive loop bound");
    _jump2394:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= _74.d1;
    _85 *= _1.d1;
    _85 *= sizeof(_a1_int64_t);
    _84.data = jpl_alloc(_85);
    int64_t _86 = 0; // K
    int64_t _87 = 0; // J
    _jump2395:; // Begin body of loop
    _a2__a1_int64_t _88;
    // Computing bound for L
    _88.d0 = e;
    if (e > 0) 
    goto _jump2396;
    fail_assertion("non-positive loop bound");
    _jump2396:;
    // Computing bound for M
    _88.d1 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump2397;
    fail_assertion("non-positive loop bound");
    _jump2397:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= e;
    _89 *= _1.d1;
    _89 *= sizeof(_a1_int64_t);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // M
    int64_t _91 = 0; // L
    _jump2398:; // Begin body of loop
    _a1_int64_t _92;
    _92.d0 = 1;
    _92.data = jpl_alloc(sizeof(int64_t) * 1);
    _92.data[0] = _1.d0;
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _91;
    _93 *= _88.d1;
    _93 += _90;
    _88.data[_93] = _92;
    _90++;
    if (_90 < _1.d1)
    goto _jump2398;
    _90 = 0;
    _91++;
    if (_91 < e)
    goto _jump2398;
    // End body of loop
    if (r >= 0)
    goto _jump2399;
    fail_assertion("negative array index");
    _jump2399:;
    if (r < _88.d0)
    goto _jump2400;
    fail_assertion("index too large");
    _jump2400:;
    if (t >= 0)
    goto _jump2401;
    fail_assertion("negative array index");
    _jump2401:;
    if (t < _88.d1)
    goto _jump2402;
    fail_assertion("index too large");
    _jump2402:;
    int64_t _94 = 0;
    _94 *= _88.d0;
    _94 += r;
    _94 *= _88.d1;
    _94 += t;
    _a1_int64_t _95 = _88.data[_94];
    int64_t _96 = 0;
    _96 *= _84.d0;
    _96 += _87;
    _96 *= _84.d1;
    _96 += _86;
    _84.data[_96] = _95;
    _86++;
    if (_86 < _1.d1)
    goto _jump2395;
    _86 = 0;
    _87++;
    if (_87 < _74.d1)
    goto _jump2395;
    // End body of loop
    _83 = _84;
    goto _jump2403;
    _jump2392:;
    bool _97 = false;
    _a2__a1_int64_t _98;
    if (!_97)
    goto _jump2404;
    _a2__a1_int64_t _99;
    // Computing bound for J
    _99.d0 = _0;
    if (_0 > 0) 
    goto _jump2405;
    fail_assertion("non-positive loop bound");
    _jump2405:;
    // Computing bound for K
    _99.d1 = _74.d1;
    if (_74.d1 > 0) 
    goto _jump2406;
    fail_assertion("non-positive loop bound");
    _jump2406:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= _0;
    _100 *= _74.d1;
    _100 *= sizeof(_a1_int64_t);
    _99.data = jpl_alloc(_100);
    int64_t _101 = 0; // K
    int64_t _102 = 0; // J
    _jump2407:; // Begin body of loop
    _a1_int64_t _103;
    // Computing bound for L
    _103.d0 = _0;
    if (_0 > 0) 
    goto _jump2408;
    fail_assertion("non-positive loop bound");
    _jump2408:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= _0;
    _104 *= sizeof(int64_t);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // L
    _jump2409:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _103.d0;
    _106 += _105;
    _103.data[_106] = _1.d0;
    _105++;
    if (_105 < _0)
    goto _jump2409;
    // End body of loop
    int64_t _107 = 0;
    _107 *= _99.d0;
    _107 += _102;
    _107 *= _99.d1;
    _107 += _101;
    _99.data[_107] = _103;
    _101++;
    if (_101 < _74.d1)
    goto _jump2407;
    _101 = 0;
    _102++;
    if (_102 < _0)
    goto _jump2407;
    // End body of loop
    _98 = _99;
    goto _jump2410;
    _jump2404:;
    _a1__a2__a1_int64_t _108;
    // Computing bound for J
    _108.d0 = t;
    if (t > 0) 
    goto _jump2411;
    fail_assertion("non-positive loop bound");
    _jump2411:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= t;
    _109 *= sizeof(_a2__a1_int64_t);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // J
    _jump2412:; // Begin body of loop
    _a2__a1_int64_t _111;
    // Computing bound for K
    _111.d0 = s;
    if (s > 0) 
    goto _jump2413;
    fail_assertion("non-positive loop bound");
    _jump2413:;
    // Computing bound for L
    _111.d1 = t;
    if (t > 0) 
    goto _jump2414;
    fail_assertion("non-positive loop bound");
    _jump2414:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= s;
    _112 *= t;
    _112 *= sizeof(_a1_int64_t);
    _111.data = jpl_alloc(_112);
    int64_t _113 = 0; // L
    int64_t _114 = 0; // K
    _jump2415:; // Begin body of loop
    _a1_int64_t _115;
    // Computing bound for M
    _115.d0 = _1.d2;
    if (_1.d2 > 0) 
    goto _jump2416;
    fail_assertion("non-positive loop bound");
    _jump2416:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= _1.d2;
    _116 *= sizeof(int64_t);
    _115.data = jpl_alloc(_116);
    int64_t _117 = 0; // M
    _jump2417:; // Begin body of loop
    int64_t _118 = 0;
    _118 *= _115.d0;
    _118 += _117;
    _115.data[_118] = g;
    _117++;
    if (_117 < _1.d2)
    goto _jump2417;
    // End body of loop
    int64_t _119 = 0;
    _119 *= _111.d0;
    _119 += _114;
    _119 *= _111.d1;
    _119 += _113;
    _111.data[_119] = _115;
    _113++;
    if (_113 < t)
    goto _jump2415;
    _113 = 0;
    _114++;
    if (_114 < s)
    goto _jump2415;
    // End body of loop
    int64_t _120 = 0;
    _120 *= _108.d0;
    _120 += _110;
    _108.data[_120] = _111;
    _110++;
    if (_110 < t)
    goto _jump2412;
    // End body of loop
    if (t >= 0)
    goto _jump2418;
    fail_assertion("negative array index");
    _jump2418:;
    if (t < _108.d0)
    goto _jump2419;
    fail_assertion("index too large");
    _jump2419:;
    int64_t _121 = 0;
    _121 *= _108.d0;
    _121 += t;
    _a2__a1_int64_t _122 = _108.data[_121];
    _98 = _122;
    _jump2410:;
    _83 = _98;
    _jump2403:;
    int64_t _123 = t / _1.d1;
    if (_123 >= 0)
    goto _jump2420;
    fail_assertion("negative array index");
    _jump2420:;
    if (_123 < _83.d0)
    goto _jump2421;
    fail_assertion("index too large");
    _jump2421:;
    if (_0 >= 0)
    goto _jump2422;
    fail_assertion("negative array index");
    _jump2422:;
    if (_0 < _83.d1)
    goto _jump2423;
    fail_assertion("index too large");
    _jump2423:;
    int64_t _124 = 0;
    _124 *= _83.d0;
    _124 += _123;
    _124 *= _83.d1;
    _124 += _0;
    _a1_int64_t _125 = _83.data[_124];
    _a3_rgba _126;
    // Computing bound for O
    int64_t _127;
    if (!h)
    goto _jump2424;
    _127 = i;
    goto _jump2425;
    _jump2424:;
    int64_t _128 = o();
    _127 = _128;
    _jump2425:;
    _126.d0 = _127;
    if (_127 > 0) 
    goto _jump2426;
    fail_assertion("non-positive loop bound");
    _jump2426:;
    // Computing bound for P
    _a3_int64_t _129;
    if (!h)
    goto _jump2427;
    _a3_int64_t _130;
    // Computing bound for O
    _130.d0 = e;
    if (e > 0) 
    goto _jump2428;
    fail_assertion("non-positive loop bound");
    _jump2428:;
    // Computing bound for P
    int64_t _131 = -_1.d2;
    _130.d1 = _131;
    if (_131 > 0) 
    goto _jump2429;
    fail_assertion("non-positive loop bound");
    _jump2429:;
    // Computing bound for Q
    _130.d2 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump2430;
    fail_assertion("non-positive loop bound");
    _jump2430:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= e;
    _132 *= _131;
    _132 *= _1.d0;
    _132 *= sizeof(int64_t);
    _130.data = jpl_alloc(_132);
    int64_t _133 = 0; // Q
    int64_t _134 = 0; // P
    int64_t _135 = 0; // O
    _jump2431:; // Begin body of loop
    int64_t _136 = m % r;
    int64_t _137 = 0;
    _137 *= _130.d0;
    _137 += _135;
    _137 *= _130.d1;
    _137 += _134;
    _137 *= _130.d2;
    _137 += _133;
    _130.data[_137] = _136;
    _133++;
    if (_133 < _1.d0)
    goto _jump2431;
    _133 = 0;
    _134++;
    if (_134 < _131)
    goto _jump2431;
    _134 = 0;
    _135++;
    if (_135 < e)
    goto _jump2431;
    // End body of loop
    _129 = _130;
    goto _jump2432;
    _jump2427:;
    bool _138 = !a;
    _a3_int64_t _139;
    if (!_138)
    goto _jump2433;
    _139 = _1;
    goto _jump2434;
    _jump2433:;
    _a1__a3_int64_t _140;
    // Computing bound for O
    _140.d0 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump2435;
    fail_assertion("non-positive loop bound");
    _jump2435:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= _1.d1;
    _141 *= sizeof(_a3_int64_t);
    _140.data = jpl_alloc(_141);
    int64_t _142 = 0; // O
    _jump2436:; // Begin body of loop
    int64_t _143 = 0;
    _143 *= _140.d0;
    _143 += _142;
    _140.data[_143] = _1;
    _142++;
    if (_142 < _1.d1)
    goto _jump2436;
    // End body of loop
    if (_125.d0 >= 0)
    goto _jump2437;
    fail_assertion("negative array index");
    _jump2437:;
    if (_125.d0 < _140.d0)
    goto _jump2438;
    fail_assertion("index too large");
    _jump2438:;
    int64_t _144 = 0;
    _144 *= _140.d0;
    _144 += _125.d0;
    _a3_int64_t _145 = _140.data[_144];
    _139 = _145;
    _jump2434:;
    _129 = _139;
    _jump2432:;
    int64_t _146 = o();
    if (d >= 0)
    goto _jump2439;
    fail_assertion("negative array index");
    _jump2439:;
    if (d < _129.d0)
    goto _jump2440;
    fail_assertion("index too large");
    _jump2440:;
    if (m >= 0)
    goto _jump2441;
    fail_assertion("negative array index");
    _jump2441:;
    if (m < _129.d1)
    goto _jump2442;
    fail_assertion("index too large");
    _jump2442:;
    if (_146 >= 0)
    goto _jump2443;
    fail_assertion("negative array index");
    _jump2443:;
    if (_146 < _129.d2)
    goto _jump2444;
    fail_assertion("index too large");
    _jump2444:;
    int64_t _147 = 0;
    _147 *= _129.d0;
    _147 += d;
    _147 *= _129.d1;
    _147 += m;
    _147 *= _129.d2;
    _147 += _146;
    int64_t _148 = _129.data[_147];
    _126.d1 = _148;
    if (_148 > 0) 
    goto _jump2445;
    fail_assertion("non-positive loop bound");
    _jump2445:;
    // Computing bound for Q
    _126.d2 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump2446;
    fail_assertion("non-positive loop bound");
    _jump2446:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _127;
    _149 *= _148;
    _149 *= _1.d1;
    _149 *= sizeof(rgba);
    _126.data = jpl_alloc(_149);
    int64_t _150 = 0; // Q
    int64_t _151 = 0; // P
    int64_t _152 = 0; // O
    _jump2447:; // Begin body of loop
    bool _154 = true;
    bool _153 = _154;
    if (0 != _154)
    goto _jump2448;
    bool _155 = false;
    bool _156 = !_155;
    _153 = _156;
    _jump2448:;
    rgba _157;
    if (!_153)
    goto _jump2449;
    _a1_rgba _158;
    // Computing bound for R
    _158.d0 = q;
    if (q > 0) 
    goto _jump2450;
    fail_assertion("non-positive loop bound");
    _jump2450:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= q;
    _159 *= sizeof(rgba);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // R
    _jump2451:; // Begin body of loop
    double _161 = v();
    double _162 = 43.0;
    _a1_double _163;
    _163.d0 = 3;
    _163.data = jpl_alloc(sizeof(double) * 3);
    _163.data[0] = u;
    _163.data[1] = _161;
    _163.data[2] = _162;
    int64_t _164 = o();
    if (_164 >= 0)
    goto _jump2452;
    fail_assertion("negative array index");
    _jump2452:;
    if (_164 < _163.d0)
    goto _jump2453;
    fail_assertion("index too large");
    _jump2453:;
    int64_t _165 = 0;
    _165 *= _163.d0;
    _165 += _164;
    double _166 = _163.data[_165];
    double _167 = v();
    double _168 = u / _167;
    _a3_rgba _169 = w();
    if (q >= 0)
    goto _jump2454;
    fail_assertion("negative array index");
    _jump2454:;
    if (q < _169.d0)
    goto _jump2455;
    fail_assertion("index too large");
    _jump2455:;
    if (_1.d0 >= 0)
    goto _jump2456;
    fail_assertion("negative array index");
    _jump2456:;
    if (_1.d0 < _169.d1)
    goto _jump2457;
    fail_assertion("index too large");
    _jump2457:;
    if (_125.d0 >= 0)
    goto _jump2458;
    fail_assertion("negative array index");
    _jump2458:;
    if (_125.d0 < _169.d2)
    goto _jump2459;
    fail_assertion("index too large");
    _jump2459:;
    int64_t _170 = 0;
    _170 *= _169.d0;
    _170 += q;
    _170 *= _169.d1;
    _170 += _1.d0;
    _170 *= _169.d2;
    _170 += _125.d0;
    rgba _171 = _169.data[_170];
    double _172 = _171.r;
    rgba _173 = { _166, _168, _172, u };
    int64_t _174 = 0;
    _174 *= _158.d0;
    _174 += _160;
    _158.data[_174] = _173;
    _160++;
    if (_160 < q)
    goto _jump2451;
    // End body of loop
    if (_1.d1 >= 0)
    goto _jump2460;
    fail_assertion("negative array index");
    _jump2460:;
    if (_1.d1 < _158.d0)
    goto _jump2461;
    fail_assertion("index too large");
    _jump2461:;
    int64_t _175 = 0;
    _175 *= _158.d0;
    _175 += _1.d1;
    rgba _176 = _158.data[_175];
    _157 = _176;
    goto _jump2462;
    _jump2449:;
    bool _177 = !a;
    rgba _178;
    if (!_177)
    goto _jump2463;
    rgba _179;
    if (!a)
    goto _jump2464;
    _a3_rgba _180 = w();
    bool _181 = h;
    if (0 != h)
    goto _jump2465;
    _181 = h;
    _jump2465:;
    int64_t _182;
    if (!_181)
    goto _jump2466;
    _182 = _151;
    goto _jump2467;
    _jump2466:;
    _182 = _74.d1;
    _jump2467:;
    if (_182 >= 0)
    goto _jump2468;
    fail_assertion("negative array index");
    _jump2468:;
    if (_182 < _180.d0)
    goto _jump2469;
    fail_assertion("index too large");
    _jump2469:;
    if (_1.d0 >= 0)
    goto _jump2470;
    fail_assertion("negative array index");
    _jump2470:;
    if (_1.d0 < _180.d1)
    goto _jump2471;
    fail_assertion("index too large");
    _jump2471:;
    if (m >= 0)
    goto _jump2472;
    fail_assertion("negative array index");
    _jump2472:;
    if (m < _180.d2)
    goto _jump2473;
    fail_assertion("index too large");
    _jump2473:;
    int64_t _183 = 0;
    _183 *= _180.d0;
    _183 += _182;
    _183 *= _180.d1;
    _183 += _1.d0;
    _183 *= _180.d2;
    _183 += m;
    rgba _184 = _180.data[_183];
    _179 = _184;
    goto _jump2474;
    _jump2464:;
    double _185;
    // Computing bound for R
    if (_74.d0 > 0) 
    goto _jump2475;
    fail_assertion("non-positive loop bound");
    _jump2475:;
    _185 = 0;
    int64_t _186 = 0; // R
    _jump2476:; // Begin body of loop
    double _187 = v();
    _185 += _187;
    _186++;
    if (_186 < _74.d0)
    goto _jump2476;
    // End body of loop
    double _188 = u - _185;
    _a1_double _189;
    // Computing bound for R
    _189.d0 = e;
    if (e > 0) 
    goto _jump2477;
    fail_assertion("non-positive loop bound");
    _jump2477:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= e;
    _190 *= sizeof(double);
    _189.data = jpl_alloc(_190);
    int64_t _191 = 0; // R
    _jump2478:; // Begin body of loop
    double _192 = v();
    int64_t _193 = 0;
    _193 *= _189.d0;
    _193 += _191;
    _189.data[_193] = _192;
    _191++;
    if (_191 < e)
    goto _jump2478;
    // End body of loop
    int64_t _194 = 991;
    if (_194 >= 0)
    goto _jump2479;
    fail_assertion("negative array index");
    _jump2479:;
    if (_194 < _189.d0)
    goto _jump2480;
    fail_assertion("index too large");
    _jump2480:;
    int64_t _195 = 0;
    _195 *= _189.d0;
    _195 += _194;
    double _196 = _189.data[_195];
    double _197 = 87.0;
    double _198;
    // Computing bound for R
    int64_t _199 = p.d1 - g;
    if (_199 > 0) 
    goto _jump2481;
    fail_assertion("non-positive loop bound");
    _jump2481:;
    // Computing bound for S
    int64_t _200 = i / _152;
    if (_200 > 0) 
    goto _jump2482;
    fail_assertion("non-positive loop bound");
    _jump2482:;
    _198 = 0;
    int64_t _201 = 0; // S
    int64_t _202 = 0; // R
    _jump2483:; // Begin body of loop
    _198 += u;
    _201++;
    if (_201 < _200)
    goto _jump2483;
    _201 = 0;
    _202++;
    if (_202 < _199)
    goto _jump2483;
    // End body of loop
    rgba _203 = { _188, _196, _197, _198 };
    _179 = _203;
    _jump2474:;
    _178 = _179;
    goto _jump2484;
    _jump2463:;
    _a2_double _204;
    // Computing bound for R
    _204.d0 = p.d1;
    if (p.d1 > 0) 
    goto _jump2485;
    fail_assertion("non-positive loop bound");
    _jump2485:;
    // Computing bound for S
    _204.d1 = _0;
    if (_0 > 0) 
    goto _jump2486;
    fail_assertion("non-positive loop bound");
    _jump2486:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= p.d1;
    _205 *= _0;
    _205 *= sizeof(double);
    _204.data = jpl_alloc(_205);
    int64_t _206 = 0; // S
    int64_t _207 = 0; // R
    _jump2487:; // Begin body of loop
    int64_t _208 = 0;
    _208 *= _204.d0;
    _208 += _207;
    _208 *= _204.d1;
    _208 += _206;
    _204.data[_208] = u;
    _206++;
    if (_206 < _0)
    goto _jump2487;
    _206 = 0;
    _207++;
    if (_207 < p.d1)
    goto _jump2487;
    // End body of loop
    if (_1.d2 >= 0)
    goto _jump2488;
    fail_assertion("negative array index");
    _jump2488:;
    if (_1.d2 < _204.d0)
    goto _jump2489;
    fail_assertion("index too large");
    _jump2489:;
    if (_150 >= 0)
    goto _jump2490;
    fail_assertion("negative array index");
    _jump2490:;
    if (_150 < _204.d1)
    goto _jump2491;
    fail_assertion("index too large");
    _jump2491:;
    int64_t _209 = 0;
    _209 *= _204.d0;
    _209 += _1.d2;
    _209 *= _204.d1;
    _209 += _150;
    double _210 = _204.data[_209];
    bool _211 = false;
    rgba _212;
    if (!_211)
    goto _jump2492;
    _a3_rgba _213 = w();
    if (_152 >= 0)
    goto _jump2493;
    fail_assertion("negative array index");
    _jump2493:;
    if (_152 < _213.d0)
    goto _jump2494;
    fail_assertion("index too large");
    _jump2494:;
    if (_1.d0 >= 0)
    goto _jump2495;
    fail_assertion("negative array index");
    _jump2495:;
    if (_1.d0 < _213.d1)
    goto _jump2496;
    fail_assertion("index too large");
    _jump2496:;
    if (_74.d0 >= 0)
    goto _jump2497;
    fail_assertion("negative array index");
    _jump2497:;
    if (_74.d0 < _213.d2)
    goto _jump2498;
    fail_assertion("index too large");
    _jump2498:;
    int64_t _214 = 0;
    _214 *= _213.d0;
    _214 += _152;
    _214 *= _213.d1;
    _214 += _1.d0;
    _214 *= _213.d2;
    _214 += _74.d0;
    rgba _215 = _213.data[_214];
    _212 = _215;
    goto _jump2499;
    _jump2492:;
    _a3_rgba _216 = w();
    int64_t _217 = o();
    if (f >= 0)
    goto _jump2500;
    fail_assertion("negative array index");
    _jump2500:;
    if (f < _216.d0)
    goto _jump2501;
    fail_assertion("index too large");
    _jump2501:;
    if (_150 >= 0)
    goto _jump2502;
    fail_assertion("negative array index");
    _jump2502:;
    if (_150 < _216.d1)
    goto _jump2503;
    fail_assertion("index too large");
    _jump2503:;
    if (_217 >= 0)
    goto _jump2504;
    fail_assertion("negative array index");
    _jump2504:;
    if (_217 < _216.d2)
    goto _jump2505;
    fail_assertion("index too large");
    _jump2505:;
    int64_t _218 = 0;
    _218 *= _216.d0;
    _218 += f;
    _218 *= _216.d1;
    _218 += _150;
    _218 *= _216.d2;
    _218 += _217;
    rgba _219 = _216.data[_218];
    _212 = _219;
    _jump2499:;
    double _220 = _212.r;
    double _221 = v();
    _a3_double _222;
    // Computing bound for R
    _222.d0 = q;
    if (q > 0) 
    goto _jump2506;
    fail_assertion("non-positive loop bound");
    _jump2506:;
    // Computing bound for S
    _222.d1 = q;
    if (q > 0) 
    goto _jump2507;
    fail_assertion("non-positive loop bound");
    _jump2507:;
    // Computing bound for T
    _222.d2 = s;
    if (s > 0) 
    goto _jump2508;
    fail_assertion("non-positive loop bound");
    _jump2508:;
    // Computing total size of heap memory to allocate
    int64_t _223 = 1;
    _223 *= q;
    _223 *= q;
    _223 *= s;
    _223 *= sizeof(double);
    _222.data = jpl_alloc(_223);
    int64_t _224 = 0; // T
    int64_t _225 = 0; // S
    int64_t _226 = 0; // R
    _jump2509:; // Begin body of loop
    int64_t _227 = 0;
    _227 *= _222.d0;
    _227 += _226;
    _227 *= _222.d1;
    _227 += _225;
    _227 *= _222.d2;
    _227 += _224;
    _222.data[_227] = u;
    _224++;
    if (_224 < s)
    goto _jump2509;
    _224 = 0;
    _225++;
    if (_225 < q)
    goto _jump2509;
    _225 = 0;
    _226++;
    if (_226 < q)
    goto _jump2509;
    // End body of loop
    if (_1.d2 >= 0)
    goto _jump2510;
    fail_assertion("negative array index");
    _jump2510:;
    if (_1.d2 < _222.d0)
    goto _jump2511;
    fail_assertion("index too large");
    _jump2511:;
    if (_125.d0 >= 0)
    goto _jump2512;
    fail_assertion("negative array index");
    _jump2512:;
    if (_125.d0 < _222.d1)
    goto _jump2513;
    fail_assertion("index too large");
    _jump2513:;
    if (_1.d2 >= 0)
    goto _jump2514;
    fail_assertion("negative array index");
    _jump2514:;
    if (_1.d2 < _222.d2)
    goto _jump2515;
    fail_assertion("index too large");
    _jump2515:;
    int64_t _228 = 0;
    _228 *= _222.d0;
    _228 += _1.d2;
    _228 *= _222.d1;
    _228 += _125.d0;
    _228 *= _222.d2;
    _228 += _1.d2;
    double _229 = _222.data[_228];
    rgba _230 = { _210, _220, _221, _229 };
    _178 = _230;
    _jump2484:;
    _157 = _178;
    _jump2462:;
    int64_t _231 = 0;
    _231 *= _126.d0;
    _231 += _152;
    _231 *= _126.d1;
    _231 += _151;
    _231 *= _126.d2;
    _231 += _150;
    _126.data[_231] = _157;
    _150++;
    if (_150 < _1.d1)
    goto _jump2447;
    _150 = 0;
    _151++;
    if (_151 < _148)
    goto _jump2447;
    _151 = 0;
    _152++;
    if (_152 < _127)
    goto _jump2447;
    // End body of loop
    return _126;
}

_a3_double x(int64_t y, double z, _a2_rgba A) {
    int64_t _0 = 547;
    _a1__a2_rgba _1;
    // Computing bound for D
    _1.d0 = i;
    if (i > 0) 
    goto _jump2516;
    fail_assertion("non-positive loop bound");
    _jump2516:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= i;
    _2 *= sizeof(_a2_rgba);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // D
    _jump2517:; // Begin body of loop
    _a2_rgba _4;
    // Computing bound for E
    _4.d0 = s;
    if (s > 0) 
    goto _jump2518;
    fail_assertion("non-positive loop bound");
    _jump2518:;
    // Computing bound for F
    _4.d1 = i;
    if (i > 0) 
    goto _jump2519;
    fail_assertion("non-positive loop bound");
    _jump2519:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= s;
    _5 *= i;
    _5 *= sizeof(rgba);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // F
    int64_t _7 = 0; // E
    _jump2520:; // Begin body of loop
    int64_t _8 = A.d0 * _3;
    if (A.d1 >= 0)
    goto _jump2521;
    fail_assertion("negative array index");
    _jump2521:;
    if (A.d1 < A.d0)
    goto _jump2522;
    fail_assertion("index too large");
    _jump2522:;
    if (_8 >= 0)
    goto _jump2523;
    fail_assertion("negative array index");
    _jump2523:;
    if (_8 < A.d1)
    goto _jump2524;
    fail_assertion("index too large");
    _jump2524:;
    int64_t _9 = 0;
    _9 *= A.d0;
    _9 += A.d1;
    _9 *= A.d1;
    _9 += _8;
    rgba _10 = A.data[_9];
    int64_t _11 = 0;
    _11 *= _4.d0;
    _11 += _7;
    _11 *= _4.d1;
    _11 += _6;
    _4.data[_11] = _10;
    _6++;
    if (_6 < i)
    goto _jump2520;
    _6 = 0;
    _7++;
    if (_7 < s)
    goto _jump2520;
    // End body of loop
    int64_t _12 = 0;
    _12 *= _1.d0;
    _12 += _3;
    _1.data[_12] = _4;
    _3++;
    if (_3 < i)
    goto _jump2517;
    // End body of loop
    if (i >= 0)
    goto _jump2525;
    fail_assertion("negative array index");
    _jump2525:;
    if (i < _1.d0)
    goto _jump2526;
    fail_assertion("index too large");
    _jump2526:;
    int64_t _13 = 0;
    _13 *= _1.d0;
    _13 += i;
    _a2_rgba _14 = _1.data[_13];
    _a3_double _15 = x(_0, u, _14);
    double _16;
    // Computing bound for H
    if (A.d0 > 0) 
    goto _jump2527;
    fail_assertion("non-positive loop bound");
    _jump2527:;
    // Computing bound for I
    if (_15.d0 > 0) 
    goto _jump2528;
    fail_assertion("non-positive loop bound");
    _jump2528:;
    _16 = 0;
    int64_t _17 = 0; // I
    int64_t _18 = 0; // H
    _jump2529:; // Begin body of loop
    _a3_double _19;
    // Computing bound for J
    _19.d0 = g;
    if (g > 0) 
    goto _jump2530;
    fail_assertion("non-positive loop bound");
    _jump2530:;
    // Computing bound for K
    _19.d1 = _15.d0;
    if (_15.d0 > 0) 
    goto _jump2531;
    fail_assertion("non-positive loop bound");
    _jump2531:;
    // Computing bound for L
    int64_t _20 = f % _15.d0;
    _19.d2 = _20;
    if (_20 > 0) 
    goto _jump2532;
    fail_assertion("non-positive loop bound");
    _jump2532:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= g;
    _21 *= _15.d0;
    _21 *= _20;
    _21 *= sizeof(double);
    _19.data = jpl_alloc(_21);
    int64_t _22 = 0; // L
    int64_t _23 = 0; // K
    int64_t _24 = 0; // J
    _jump2533:; // Begin body of loop
    double _25;
    // Computing bound for M
    if (_18 > 0) 
    goto _jump2534;
    fail_assertion("non-positive loop bound");
    _jump2534:;
    // Computing bound for N
    if (_15.d2 > 0) 
    goto _jump2535;
    fail_assertion("non-positive loop bound");
    _jump2535:;
    // Computing bound for O
    if (_24 > 0) 
    goto _jump2536;
    fail_assertion("non-positive loop bound");
    _jump2536:;
    _25 = 0;
    int64_t _26 = 0; // O
    int64_t _27 = 0; // N
    int64_t _28 = 0; // M
    _jump2537:; // Begin body of loop
    double _29 = 25.0;
    _25 += _29;
    _26++;
    if (_26 < _24)
    goto _jump2537;
    _26 = 0;
    _27++;
    if (_27 < _15.d2)
    goto _jump2537;
    _27 = 0;
    _28++;
    if (_28 < _18)
    goto _jump2537;
    // End body of loop
    int64_t _30 = 0;
    _30 *= _19.d0;
    _30 += _24;
    _30 *= _19.d1;
    _30 += _23;
    _30 *= _19.d2;
    _30 += _22;
    _19.data[_30] = _25;
    _22++;
    if (_22 < _20)
    goto _jump2533;
    _22 = 0;
    _23++;
    if (_23 < _15.d0)
    goto _jump2533;
    _23 = 0;
    _24++;
    if (_24 < g)
    goto _jump2533;
    // End body of loop
    int64_t _31 = 956;
    _a1_int64_t _32;
    _32.d0 = 2;
    _32.data = jpl_alloc(sizeof(int64_t) * 2);
    _32.data[0] = A.d1;
    _32.data[1] = _31;
    if (A.d1 >= 0)
    goto _jump2538;
    fail_assertion("negative array index");
    _jump2538:;
    if (A.d1 < _32.d0)
    goto _jump2539;
    fail_assertion("index too large");
    _jump2539:;
    int64_t _33 = 0;
    _33 *= _32.d0;
    _33 += A.d1;
    int64_t _34 = _32.data[_33];
    if (g >= 0)
    goto _jump2540;
    fail_assertion("negative array index");
    _jump2540:;
    if (g < _19.d0)
    goto _jump2541;
    fail_assertion("index too large");
    _jump2541:;
    if (_34 >= 0)
    goto _jump2542;
    fail_assertion("negative array index");
    _jump2542:;
    if (_34 < _19.d1)
    goto _jump2543;
    fail_assertion("index too large");
    _jump2543:;
    if (A.d0 >= 0)
    goto _jump2544;
    fail_assertion("negative array index");
    _jump2544:;
    if (A.d0 < _19.d2)
    goto _jump2545;
    fail_assertion("index too large");
    _jump2545:;
    int64_t _35 = 0;
    _35 *= _19.d0;
    _35 += g;
    _35 *= _19.d1;
    _35 += _34;
    _35 *= _19.d2;
    _35 += A.d0;
    double _36 = _19.data[_35];
    _16 += _36;
    _17++;
    if (_17 < _15.d0)
    goto _jump2529;
    _17 = 0;
    _18++;
    if (_18 < A.d0)
    goto _jump2529;
    // End body of loop
    double _37;
    // Computing bound for H
    int64_t _38 = o();
    if (_38 > 0) 
    goto _jump2546;
    fail_assertion("non-positive loop bound");
    _jump2546:;
    // Computing bound for I
    if (g > 0) 
    goto _jump2547;
    fail_assertion("non-positive loop bound");
    _jump2547:;
    // Computing bound for J
    if (q > 0) 
    goto _jump2548;
    fail_assertion("non-positive loop bound");
    _jump2548:;
    _37 = 0;
    int64_t _39 = 0; // J
    int64_t _40 = 0; // I
    int64_t _41 = 0; // H
    _jump2549:; // Begin body of loop
    double _42;
    // Computing bound for K
    if (_15.d2 > 0) 
    goto _jump2550;
    fail_assertion("non-positive loop bound");
    _jump2550:;
    // Computing bound for L
    int64_t _43 = -f;
    if (_43 > 0) 
    goto _jump2551;
    fail_assertion("non-positive loop bound");
    _jump2551:;
    _42 = 0;
    int64_t _44 = 0; // L
    int64_t _45 = 0; // K
    _jump2552:; // Begin body of loop
    double _46 = v();
    double _47 = -_46;
    _42 += _47;
    _44++;
    if (_44 < _43)
    goto _jump2552;
    _44 = 0;
    _45++;
    if (_45 < _15.d2)
    goto _jump2552;
    // End body of loop
    _37 += _42;
    _39++;
    if (_39 < q)
    goto _jump2549;
    _39 = 0;
    _40++;
    if (_40 < g)
    goto _jump2549;
    _40 = 0;
    _41++;
    if (_41 < _38)
    goto _jump2549;
    // End body of loop
    bool _48 = _16 != _37;
    _a1__a3_bool _49;
    if (!_48)
    goto _jump2553;
    _a1__a3_bool _50;
    // Computing bound for H
    _50.d0 = i;
    if (i > 0) 
    goto _jump2554;
    fail_assertion("non-positive loop bound");
    _jump2554:;
    // Computing total size of heap memory to allocate
    int64_t _51 = 1;
    _51 *= i;
    _51 *= sizeof(_a3_bool);
    _50.data = jpl_alloc(_51);
    int64_t _52 = 0; // H
    _jump2555:; // Begin body of loop
    int64_t _53 = 0;
    _53 *= _50.d0;
    _53 += _52;
    _50.data[_53] = c;
    _52++;
    if (_52 < i)
    goto _jump2555;
    // End body of loop
    _49 = _50;
    goto _jump2556;
    _jump2553:;
    bool _54 = false;
    bool _55 = !_54;
    _a3__a3_bool _56;
    if (!_55)
    goto _jump2557;
    int64_t _57;
    // Computing bound for H
    if (d > 0) 
    goto _jump2558;
    fail_assertion("non-positive loop bound");
    _jump2558:;
    _57 = 0;
    int64_t _58 = 0; // H
    _jump2559:; // Begin body of loop
    _57 += A.d0;
    _58++;
    if (_58 < d)
    goto _jump2559;
    // End body of loop
    if (m >= 0)
    goto _jump2560;
    fail_assertion("negative array index");
    _jump2560:;
    if (m < c.d0)
    goto _jump2561;
    fail_assertion("index too large");
    _jump2561:;
    if (_57 >= 0)
    goto _jump2562;
    fail_assertion("negative array index");
    _jump2562:;
    if (_57 < c.d1)
    goto _jump2563;
    fail_assertion("index too large");
    _jump2563:;
    if (t >= 0)
    goto _jump2564;
    fail_assertion("negative array index");
    _jump2564:;
    if (t < c.d2)
    goto _jump2565;
    fail_assertion("index too large");
    _jump2565:;
    int64_t _59 = 0;
    _59 *= c.d0;
    _59 += m;
    _59 *= c.d1;
    _59 += _57;
    _59 *= c.d2;
    _59 += t;
    bool _60 = c.data[_59];
    _a3__a3_bool _61;
    if (!_60)
    goto _jump2566;
    _a3__a3_bool _62;
    // Computing bound for H
    _62.d0 = f;
    if (f > 0) 
    goto _jump2567;
    fail_assertion("non-positive loop bound");
    _jump2567:;
    // Computing bound for I
    int64_t _63 = -g;
    _62.d1 = _63;
    if (_63 > 0) 
    goto _jump2568;
    fail_assertion("non-positive loop bound");
    _jump2568:;
    // Computing bound for J
    _62.d2 = e;
    if (e > 0) 
    goto _jump2569;
    fail_assertion("non-positive loop bound");
    _jump2569:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= f;
    _64 *= _63;
    _64 *= e;
    _64 *= sizeof(_a3_bool);
    _62.data = jpl_alloc(_64);
    int64_t _65 = 0; // J
    int64_t _66 = 0; // I
    int64_t _67 = 0; // H
    _jump2570:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _62.d0;
    _68 += _67;
    _68 *= _62.d1;
    _68 += _66;
    _68 *= _62.d2;
    _68 += _65;
    _62.data[_68] = c;
    _65++;
    if (_65 < e)
    goto _jump2570;
    _65 = 0;
    _66++;
    if (_66 < _63)
    goto _jump2570;
    _66 = 0;
    _67++;
    if (_67 < f)
    goto _jump2570;
    // End body of loop
    _61 = _62;
    goto _jump2571;
    _jump2566:;
    int64_t _69 = o();
    bool _70 = _69 != t;
    _a3__a3_bool _71;
    if (!_70)
    goto _jump2572;
    _a3__a3_bool _72;
    // Computing bound for H
    _72.d0 = f;
    if (f > 0) 
    goto _jump2573;
    fail_assertion("non-positive loop bound");
    _jump2573:;
    // Computing bound for I
    _72.d1 = t;
    if (t > 0) 
    goto _jump2574;
    fail_assertion("non-positive loop bound");
    _jump2574:;
    // Computing bound for J
    _72.d2 = _15.d2;
    if (_15.d2 > 0) 
    goto _jump2575;
    fail_assertion("non-positive loop bound");
    _jump2575:;
    // Computing total size of heap memory to allocate
    int64_t _73 = 1;
    _73 *= f;
    _73 *= t;
    _73 *= _15.d2;
    _73 *= sizeof(_a3_bool);
    _72.data = jpl_alloc(_73);
    int64_t _74 = 0; // J
    int64_t _75 = 0; // I
    int64_t _76 = 0; // H
    _jump2576:; // Begin body of loop
    int64_t _77 = 0;
    _77 *= _72.d0;
    _77 += _76;
    _77 *= _72.d1;
    _77 += _75;
    _77 *= _72.d2;
    _77 += _74;
    _72.data[_77] = n;
    _74++;
    if (_74 < _15.d2)
    goto _jump2576;
    _74 = 0;
    _75++;
    if (_75 < t)
    goto _jump2576;
    _75 = 0;
    _76++;
    if (_76 < f)
    goto _jump2576;
    // End body of loop
    _71 = _72;
    goto _jump2577;
    _jump2572:;
    _a3__a3_bool _78;
    // Computing bound for H
    _78.d0 = i;
    if (i > 0) 
    goto _jump2578;
    fail_assertion("non-positive loop bound");
    _jump2578:;
    // Computing bound for I
    _78.d1 = _15.d0;
    if (_15.d0 > 0) 
    goto _jump2579;
    fail_assertion("non-positive loop bound");
    _jump2579:;
    // Computing bound for J
    _78.d2 = _15.d2;
    if (_15.d2 > 0) 
    goto _jump2580;
    fail_assertion("non-positive loop bound");
    _jump2580:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= i;
    _79 *= _15.d0;
    _79 *= _15.d2;
    _79 *= sizeof(_a3_bool);
    _78.data = jpl_alloc(_79);
    int64_t _80 = 0; // J
    int64_t _81 = 0; // I
    int64_t _82 = 0; // H
    _jump2581:; // Begin body of loop
    int64_t _83 = 0;
    _83 *= _78.d0;
    _83 += _82;
    _83 *= _78.d1;
    _83 += _81;
    _83 *= _78.d2;
    _83 += _80;
    _78.data[_83] = c;
    _80++;
    if (_80 < _15.d2)
    goto _jump2581;
    _80 = 0;
    _81++;
    if (_81 < _15.d0)
    goto _jump2581;
    _81 = 0;
    _82++;
    if (_82 < i)
    goto _jump2581;
    // End body of loop
    _71 = _78;
    _jump2577:;
    _61 = _71;
    _jump2571:;
    _56 = _61;
    goto _jump2582;
    _jump2557:;
    _a3__a3_bool _84;
    // Computing bound for H
    _84.d0 = e;
    if (e > 0) 
    goto _jump2583;
    fail_assertion("non-positive loop bound");
    _jump2583:;
    // Computing bound for I
    _84.d1 = _15.d2;
    if (_15.d2 > 0) 
    goto _jump2584;
    fail_assertion("non-positive loop bound");
    _jump2584:;
    // Computing bound for J
    int64_t _85 = 148;
    _84.d2 = _85;
    if (_85 > 0) 
    goto _jump2585;
    fail_assertion("non-positive loop bound");
    _jump2585:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= e;
    _86 *= _15.d2;
    _86 *= _85;
    _86 *= sizeof(_a3_bool);
    _84.data = jpl_alloc(_86);
    int64_t _87 = 0; // J
    int64_t _88 = 0; // I
    int64_t _89 = 0; // H
    _jump2586:; // Begin body of loop
    _a3_bool _90;
    // Computing bound for K
    _90.d0 = f;
    if (f > 0) 
    goto _jump2587;
    fail_assertion("non-positive loop bound");
    _jump2587:;
    // Computing bound for L
    int64_t _91;
    if (!a)
    goto _jump2588;
    _91 = _87;
    goto _jump2589;
    _jump2588:;
    _91 = e;
    _jump2589:;
    _90.d1 = _91;
    if (_91 > 0) 
    goto _jump2590;
    fail_assertion("non-positive loop bound");
    _jump2590:;
    // Computing bound for M
    int64_t _92;
    // Computing bound for K
    if (_15.d0 > 0) 
    goto _jump2591;
    fail_assertion("non-positive loop bound");
    _jump2591:;
    // Computing bound for L
    if (r > 0) 
    goto _jump2592;
    fail_assertion("non-positive loop bound");
    _jump2592:;
    // Computing bound for M
    if (f > 0) 
    goto _jump2593;
    fail_assertion("non-positive loop bound");
    _jump2593:;
    _92 = 0;
    int64_t _93 = 0; // M
    int64_t _94 = 0; // L
    int64_t _95 = 0; // K
    _jump2594:; // Begin body of loop
    _92 += t;
    _93++;
    if (_93 < f)
    goto _jump2594;
    _93 = 0;
    _94++;
    if (_94 < r)
    goto _jump2594;
    _94 = 0;
    _95++;
    if (_95 < _15.d0)
    goto _jump2594;
    // End body of loop
    _90.d2 = _92;
    if (_92 > 0) 
    goto _jump2595;
    fail_assertion("non-positive loop bound");
    _jump2595:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= f;
    _96 *= _91;
    _96 *= _92;
    _96 *= sizeof(bool);
    _90.data = jpl_alloc(_96);
    int64_t _97 = 0; // M
    int64_t _98 = 0; // L
    int64_t _99 = 0; // K
    _jump2596:; // Begin body of loop
    int64_t _100 = o();
    bool _101 = _100 > _15.d1;
    int64_t _102 = 0;
    _102 *= _90.d0;
    _102 += _99;
    _102 *= _90.d1;
    _102 += _98;
    _102 *= _90.d2;
    _102 += _97;
    _90.data[_102] = _101;
    _97++;
    if (_97 < _92)
    goto _jump2596;
    _97 = 0;
    _98++;
    if (_98 < _91)
    goto _jump2596;
    _98 = 0;
    _99++;
    if (_99 < f)
    goto _jump2596;
    // End body of loop
    int64_t _103 = 0;
    _103 *= _84.d0;
    _103 += _89;
    _103 *= _84.d1;
    _103 += _88;
    _103 *= _84.d2;
    _103 += _87;
    _84.data[_103] = _90;
    _87++;
    if (_87 < _85)
    goto _jump2586;
    _87 = 0;
    _88++;
    if (_88 < _15.d2)
    goto _jump2586;
    _88 = 0;
    _89++;
    if (_89 < e)
    goto _jump2586;
    // End body of loop
    _56 = _84;
    _jump2582:;
    bool _104;
    if (!a)
    goto _jump2597;
    bool _105 = d == t;
    bool _107 = true;
    bool _106 = _107;
    if (0 != _107)
    goto _jump2598;
    bool _108 = true;
    _106 = _108;
    _jump2598:;
    bool _109 = _105 != _106;
    _104 = _109;
    goto _jump2599;
    _jump2597:;
    _104 = h;
    _jump2599:;
    int64_t _110;
    if (!_104)
    goto _jump2600;
    _110 = A.d0;
    goto _jump2601;
    _jump2600:;
    _110 = f;
    _jump2601:;
    if (s >= 0)
    goto _jump2602;
    fail_assertion("negative array index");
    _jump2602:;
    if (s < _56.d0)
    goto _jump2603;
    fail_assertion("index too large");
    _jump2603:;
    if (_110 >= 0)
    goto _jump2604;
    fail_assertion("negative array index");
    _jump2604:;
    if (_110 < _56.d1)
    goto _jump2605;
    fail_assertion("index too large");
    _jump2605:;
    if (g >= 0)
    goto _jump2606;
    fail_assertion("negative array index");
    _jump2606:;
    if (g < _56.d2)
    goto _jump2607;
    fail_assertion("index too large");
    _jump2607:;
    int64_t _111 = 0;
    _111 *= _56.d0;
    _111 += s;
    _111 *= _56.d1;
    _111 += _110;
    _111 *= _56.d2;
    _111 += g;
    _a3_bool _112 = _56.data[_111];
    _a1__a3_bool _113;
    _113.d0 = 2;
    _113.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _113.data[0] = _112;
    _113.data[1] = n;
    _49 = _113;
    _jump2556:;
    bool _114 = a;
    if (0 != a)
    goto _jump2608;
    bool _115 = true;
    bool _116 = a == _115;
    _114 = _116;
    _jump2608:;
    _a2_double _117;
    // Computing bound for L
    _117.d0 = t;
    if (t > 0) 
    goto _jump2609;
    fail_assertion("non-positive loop bound");
    _jump2609:;
    // Computing bound for M
    _117.d1 = e;
    if (e > 0) 
    goto _jump2610;
    fail_assertion("non-positive loop bound");
    _jump2610:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= t;
    _118 *= e;
    _118 *= sizeof(double);
    _117.data = jpl_alloc(_118);
    int64_t _119 = 0; // M
    int64_t _120 = 0; // L
    _jump2611:; // Begin body of loop
    bool _121 = t <= _120;
    double _122;
    if (!_121)
    goto _jump2612;
    double _123;
    // Computing bound for N
    if (_120 > 0) 
    goto _jump2613;
    fail_assertion("non-positive loop bound");
    _jump2613:;
    _123 = 0;
    int64_t _124 = 0; // N
    _jump2614:; // Begin body of loop
    _123 += z;
    _124++;
    if (_124 < _120)
    goto _jump2614;
    // End body of loop
    double _125 = -_123;
    _122 = _125;
    goto _jump2615;
    _jump2612:;
    _122 = z;
    _jump2615:;
    int64_t _126 = 0;
    _126 *= _117.d0;
    _126 += _120;
    _126 *= _117.d1;
    _126 += _119;
    _117.data[_126] = _122;
    _119++;
    if (_119 < e)
    goto _jump2611;
    _119 = 0;
    _120++;
    if (_120 < t)
    goto _jump2611;
    // End body of loop
    int64_t _127 = b(_117);
    double _128 = 71.0;
    _a1_double _129;
    _129.d0 = 1;
    _129.data = jpl_alloc(sizeof(double) * 1);
    _129.data[0] = _128;
    if (r >= 0)
    goto _jump2616;
    fail_assertion("negative array index");
    _jump2616:;
    if (r < _129.d0)
    goto _jump2617;
    fail_assertion("index too large");
    _jump2617:;
    int64_t _130 = 0;
    _130 *= _129.d0;
    _130 += r;
    double _131 = _129.data[_130];
    _a3_double _132 = x(_127, _131, A);
    return _132;
    return _15;
}

void jpl_main(struct args args) {
    double _0;
    // Computing bound for a
    _a1_int64_t _1;
    // Computing bound for a
    int64_t _2 = 877;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= sizeof(int64_t);
    _1.data = jpl_alloc(_3);
    int64_t _4 = 0; // a
    _jump2:; // Begin body of loop
    int64_t _5 = -_4;
    int64_t _6 = 0;
    _6 *= _1.d0;
    _6 += _4;
    _1.data[_6] = _5;
    _4++;
    if (_4 < _2)
    goto _jump2;
    // End body of loop
    int64_t _7 = 476;
    if (_7 >= 0)
    goto _jump3;
    fail_assertion("negative array index");
    _jump3:;
    if (_7 < _1.d0)
    goto _jump4;
    fail_assertion("index too large");
    _jump4:;
    int64_t _8 = 0;
    _8 *= _1.d0;
    _8 += _7;
    int64_t _9 = _1.data[_8];
    if (_9 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing bound for b
    int64_t _10 = 805;
    int64_t _11 = 441;
    int64_t _12 = _10 * _11;
    if (_12 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    // Computing bound for c
    int64_t _13;
    // Computing bound for a
    int64_t _14 = 913;
    int64_t _15 = -_14;
    int64_t _16 = -_15;
    if (_16 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing bound for b
    int64_t _17 = 13;
    int64_t _18 = 806;
    int64_t _19 = _17 % _18;
    int64_t _20 = -_19;
    if (_20 > 0) 
    goto _jump8;
    fail_assertion("non-positive loop bound");
    _jump8:;
    // Computing bound for c
    int64_t _21 = 370;
    int64_t _22 = -_21;
    int64_t _23 = 284;
    int64_t _24 = 828;
    int64_t _25 = _23 / _24;
    int64_t _26 = _22 - _25;
    if (_26 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    _13 = 0;
    int64_t _27 = 0; // c
    int64_t _28 = 0; // b
    int64_t _29 = 0; // a
    _jump10:; // Begin body of loop
    _a2_int64_t _30;
    // Computing bound for d
    _30.d0 = _28;
    if (_28 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for e
    _30.d1 = _29;
    if (_29 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= _28;
    _31 *= _29;
    _31 *= sizeof(int64_t);
    _30.data = jpl_alloc(_31);
    int64_t _32 = 0; // e
    int64_t _33 = 0; // d
    _jump13:; // Begin body of loop
    int64_t _34 = 0;
    _34 *= _30.d0;
    _34 += _33;
    _34 *= _30.d1;
    _34 += _32;
    _30.data[_34] = _33;
    _32++;
    if (_32 < _29)
    goto _jump13;
    _32 = 0;
    _33++;
    if (_33 < _28)
    goto _jump13;
    // End body of loop
    int64_t _35 = 151;
    bool _36 = false;
    int64_t _37;
    if (!_36)
    goto _jump14;
    _37 = _29;
    goto _jump15;
    _jump14:;
    _37 = _28;
    _jump15:;
    if (_35 >= 0)
    goto _jump16;
    fail_assertion("negative array index");
    _jump16:;
    if (_35 < _30.d0)
    goto _jump17;
    fail_assertion("index too large");
    _jump17:;
    if (_37 >= 0)
    goto _jump18;
    fail_assertion("negative array index");
    _jump18:;
    if (_37 < _30.d1)
    goto _jump19;
    fail_assertion("index too large");
    _jump19:;
    int64_t _38 = 0;
    _38 *= _30.d0;
    _38 += _35;
    _38 *= _30.d1;
    _38 += _37;
    int64_t _39 = _30.data[_38];
    _13 += _39;
    _27++;
    if (_27 < _26)
    goto _jump10;
    _27 = 0;
    _28++;
    if (_28 < _20)
    goto _jump10;
    _28 = 0;
    _29++;
    if (_29 < _16)
    goto _jump10;
    // End body of loop
    if (_13 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _0 = 0;
    int64_t _40 = 0; // c
    int64_t _41 = 0; // b
    int64_t _42 = 0; // a
    _jump21:; // Begin body of loop
    double _43 = 44.0;
    _0 += _43;
    _40++;
    if (_40 < _13)
    goto _jump21;
    _40 = 0;
    _41++;
    if (_41 < _12)
    goto _jump21;
    _41 = 0;
    _42++;
    if (_42 < _9)
    goto _jump21;
    // End body of loop
    double _44 = 96.0;
    double _45;
    // Computing bound for a
    int64_t _46 = 912;
    int64_t _47 = -_46;
    if (_47 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    _45 = 0;
    int64_t _48 = 0; // a
    _jump23:; // Begin body of loop
    double _49 = 17.0;
    _45 += _49;
    _48++;
    if (_48 < _47)
    goto _jump23;
    // End body of loop
    double _50;
    // Computing bound for a
    bool _51 = true;
    int64_t _52;
    if (!_51)
    goto _jump24;
    int64_t _53 = 55;
    _52 = _53;
    goto _jump25;
    _jump24:;
    int64_t _54 = 733;
    _52 = _54;
    _jump25:;
    if (_52 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    _50 = 0;
    int64_t _55 = 0; // a
    _jump27:; // Begin body of loop
    double _56 = 69.0;
    double _57 = -_56;
    _50 += _57;
    _55++;
    if (_55 < _52)
    goto _jump27;
    // End body of loop
    double _58 = _45 * _50;
    double _59 = _44 - _58;
    bool _60 = _0 != _59;
    bool _61 = true;
    bool _62 = true;
    _a1_bool _63;
    _63.d0 = 3;
    _63.data = jpl_alloc(sizeof(bool) * 3);
    _63.data[0] = _60;
    _63.data[1] = _61;
    _63.data[2] = _62;
    int64_t _64;
    // Computing bound for a
    int64_t _65;
    // Computing bound for a
    int64_t _66 = 284;
    int64_t _67 = -_66;
    if (_67 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    _65 = 0;
    int64_t _68 = 0; // a
    _jump29:; // Begin body of loop
    bool _69 = true;
    int64_t _70;
    if (!_69)
    goto _jump30;
    _70 = _68;
    goto _jump31;
    _jump30:;
    _70 = _68;
    _jump31:;
    _65 += _70;
    _68++;
    if (_68 < _67)
    goto _jump29;
    // End body of loop
    int64_t _71 = 548;
    int64_t _72 = -_71;
    int64_t _73 = 835;
    int64_t _74 = _72 - _73;
    bool _75 = _65 == _74;
    bool _76 = !_75;
    int64_t _77;
    if (!_76)
    goto _jump32;
    double _78 = 40.0;
    double _79 = 83.0;
    double _80 = -_79;
    bool _81 = _78 <= _80;
    bool _82 = !_81;
    int64_t _83;
    if (!_82)
    goto _jump33;
    int64_t _84 = 887;
    int64_t _85 = 730;
    int64_t _86 = -_85;
    int64_t _87 = _84 * _86;
    _83 = _87;
    goto _jump34;
    _jump33:;
    int64_t _88;
    // Computing bound for a
    int64_t _89 = 204;
    int64_t _90 = 646;
    int64_t _91 = _89 / _90;
    int64_t _92 = -_91;
    if (_92 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for b
    bool _93 = false;
    int64_t _94;
    if (!_93)
    goto _jump36;
    int64_t _95 = 261;
    _94 = _95;
    goto _jump37;
    _jump36:;
    int64_t _96 = 879;
    _94 = _96;
    _jump37:;
    if (_94 > 0) 
    goto _jump38;
    fail_assertion("non-positive loop bound");
    _jump38:;
    _88 = 0;
    int64_t _97 = 0; // b
    int64_t _98 = 0; // a
    _jump39:; // Begin body of loop
    _a2_int64_t _99;
    // Computing bound for c
    _99.d0 = _98;
    if (_98 > 0) 
    goto _jump40;
    fail_assertion("non-positive loop bound");
    _jump40:;
    // Computing bound for d
    int64_t _100 = 891;
    _99.d1 = _100;
    if (_100 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _98;
    _101 *= _100;
    _101 *= sizeof(int64_t);
    _99.data = jpl_alloc(_101);
    int64_t _102 = 0; // d
    int64_t _103 = 0; // c
    _jump42:; // Begin body of loop
    int64_t _104 = 0;
    _104 *= _99.d0;
    _104 += _103;
    _104 *= _99.d1;
    _104 += _102;
    _99.data[_104] = _98;
    _102++;
    if (_102 < _100)
    goto _jump42;
    _102 = 0;
    _103++;
    if (_103 < _98)
    goto _jump42;
    // End body of loop
    bool _105 = false;
    int64_t _106;
    if (!_105)
    goto _jump43;
    int64_t _107 = 563;
    _106 = _107;
    goto _jump44;
    _jump43:;
    _106 = _97;
    _jump44:;
    if (_97 >= 0)
    goto _jump45;
    fail_assertion("negative array index");
    _jump45:;
    if (_97 < _99.d0)
    goto _jump46;
    fail_assertion("index too large");
    _jump46:;
    if (_106 >= 0)
    goto _jump47;
    fail_assertion("negative array index");
    _jump47:;
    if (_106 < _99.d1)
    goto _jump48;
    fail_assertion("index too large");
    _jump48:;
    int64_t _108 = 0;
    _108 *= _99.d0;
    _108 += _97;
    _108 *= _99.d1;
    _108 += _106;
    int64_t _109 = _99.data[_108];
    _88 += _109;
    _97++;
    if (_97 < _94)
    goto _jump39;
    _97 = 0;
    _98++;
    if (_98 < _92)
    goto _jump39;
    // End body of loop
    _83 = _88;
    _jump34:;
    _77 = _83;
    goto _jump49;
    _jump32:;
    int64_t _110 = 252;
    int64_t _111 = 552;
    int64_t _112 = -_111;
    bool _113 = _110 <= _112;
    bool _114 = !_113;
    int64_t _115;
    if (!_114)
    goto _jump50;
    _a2_bool _116;
    // Computing bound for a
    int64_t _117 = 900;
    _116.d0 = _117;
    if (_117 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    // Computing bound for b
    int64_t _118 = 594;
    _116.d1 = _118;
    if (_118 > 0) 
    goto _jump52;
    fail_assertion("non-positive loop bound");
    _jump52:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= _117;
    _119 *= _118;
    _119 *= sizeof(bool);
    _116.data = jpl_alloc(_119);
    int64_t _120 = 0; // b
    int64_t _121 = 0; // a
    _jump53:; // Begin body of loop
    bool _122 = false;
    int64_t _123 = 0;
    _123 *= _116.d0;
    _123 += _121;
    _123 *= _116.d1;
    _123 += _120;
    _116.data[_123] = _122;
    _120++;
    if (_120 < _118)
    goto _jump53;
    _120 = 0;
    _121++;
    if (_121 < _117)
    goto _jump53;
    // End body of loop
    int64_t _124 = 936;
    int64_t _125 = 18;
    int64_t _126 = _124 / _125;
    int64_t _127 = 981;
    if (_126 >= 0)
    goto _jump54;
    fail_assertion("negative array index");
    _jump54:;
    if (_126 < _116.d0)
    goto _jump55;
    fail_assertion("index too large");
    _jump55:;
    if (_127 >= 0)
    goto _jump56;
    fail_assertion("negative array index");
    _jump56:;
    if (_127 < _116.d1)
    goto _jump57;
    fail_assertion("index too large");
    _jump57:;
    int64_t _128 = 0;
    _128 *= _116.d0;
    _128 += _126;
    _128 *= _116.d1;
    _128 += _127;
    bool _129 = _116.data[_128];
    int64_t _130;
    if (!_129)
    goto _jump58;
    int64_t _131;
    // Computing bound for a
    int64_t _132 = 806;
    if (_132 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    // Computing bound for b
    int64_t _133 = 148;
    if (_133 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    _131 = 0;
    int64_t _134 = 0; // b
    int64_t _135 = 0; // a
    _jump61:; // Begin body of loop
    _131 += _135;
    _134++;
    if (_134 < _133)
    goto _jump61;
    _134 = 0;
    _135++;
    if (_135 < _132)
    goto _jump61;
    // End body of loop
    int64_t _136 = -_131;
    _130 = _136;
    goto _jump62;
    _jump58:;
    bool _137 = false;
    bool _138 = !_137;
    int64_t _139;
    if (!_138)
    goto _jump63;
    int64_t _140 = 986;
    _139 = _140;
    goto _jump64;
    _jump63:;
    int64_t _141 = 612;
    _139 = _141;
    _jump64:;
    _130 = _139;
    _jump62:;
    _115 = _130;
    goto _jump65;
    _jump50:;
    int64_t _142 = 598;
    int64_t _143;
    // Computing bound for a
    int64_t _144 = 652;
    if (_144 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    _143 = 0;
    int64_t _145 = 0; // a
    _jump67:; // Begin body of loop
    int64_t _146 = 897;
    int64_t _147 = -_146;
    _143 += _147;
    _145++;
    if (_145 < _144)
    goto _jump67;
    // End body of loop
    int64_t _148 = _142 - _143;
    _115 = _148;
    _jump65:;
    _77 = _115;
    _jump49:;
    if (_77 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    // Computing bound for b
    _a2_int64_t _149;
    // Computing bound for a
    int64_t _150 = 411;
    int64_t _151 = -_150;
    _149.d0 = _151;
    if (_151 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    // Computing bound for b
    bool _153 = true;
    bool _152 = _153;
    if (0 != _153)
    goto _jump70;
    bool _154 = true;
    _152 = _154;
    _jump70:;
    int64_t _155;
    if (!_152)
    goto _jump71;
    int64_t _156 = 884;
    _155 = _156;
    goto _jump72;
    _jump71:;
    int64_t _157 = 29;
    _155 = _157;
    _jump72:;
    _149.d1 = _155;
    if (_155 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= _151;
    _158 *= _155;
    _158 *= sizeof(int64_t);
    _149.data = jpl_alloc(_158);
    int64_t _159 = 0; // b
    int64_t _160 = 0; // a
    _jump74:; // Begin body of loop
    int64_t _161 = 0;
    _161 *= _149.d0;
    _161 += _160;
    _161 *= _149.d1;
    _161 += _159;
    _149.data[_161] = _160;
    _159++;
    if (_159 < _155)
    goto _jump74;
    _159 = 0;
    _160++;
    if (_160 < _151)
    goto _jump74;
    // End body of loop
    int64_t _162;
    // Computing bound for a
    int64_t _163 = 847;
    if (_163 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    _162 = 0;
    int64_t _164 = 0; // a
    _jump76:; // Begin body of loop
    int64_t _165 = 870;
    _162 += _165;
    _164++;
    if (_164 < _163)
    goto _jump76;
    // End body of loop
    int64_t _166 = -_162;
    _a3_int64_t _167;
    // Computing bound for a
    int64_t _168 = 35;
    _167.d0 = _168;
    if (_168 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    // Computing bound for b
    int64_t _169 = 935;
    _167.d1 = _169;
    if (_169 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing bound for c
    int64_t _170 = 993;
    _167.d2 = _170;
    if (_170 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _168;
    _171 *= _169;
    _171 *= _170;
    _171 *= sizeof(int64_t);
    _167.data = jpl_alloc(_171);
    int64_t _172 = 0; // c
    int64_t _173 = 0; // b
    int64_t _174 = 0; // a
    _jump80:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _167.d0;
    _175 += _174;
    _175 *= _167.d1;
    _175 += _173;
    _175 *= _167.d2;
    _175 += _172;
    _167.data[_175] = _174;
    _172++;
    if (_172 < _170)
    goto _jump80;
    _172 = 0;
    _173++;
    if (_173 < _169)
    goto _jump80;
    _173 = 0;
    _174++;
    if (_174 < _168)
    goto _jump80;
    // End body of loop
    int64_t _176 = 725;
    int64_t _177 = -_176;
    int64_t _178 = 354;
    int64_t _179 = 958;
    int64_t _180 = 11;
    int64_t _181 = _179 % _180;
    if (_177 >= 0)
    goto _jump81;
    fail_assertion("negative array index");
    _jump81:;
    if (_177 < _167.d0)
    goto _jump82;
    fail_assertion("index too large");
    _jump82:;
    if (_178 >= 0)
    goto _jump83;
    fail_assertion("negative array index");
    _jump83:;
    if (_178 < _167.d1)
    goto _jump84;
    fail_assertion("index too large");
    _jump84:;
    if (_181 >= 0)
    goto _jump85;
    fail_assertion("negative array index");
    _jump85:;
    if (_181 < _167.d2)
    goto _jump86;
    fail_assertion("index too large");
    _jump86:;
    int64_t _182 = 0;
    _182 *= _167.d0;
    _182 += _177;
    _182 *= _167.d1;
    _182 += _178;
    _182 *= _167.d2;
    _182 += _181;
    int64_t _183 = _167.data[_182];
    int64_t _184 = _166 % _183;
    int64_t _185 = 484;
    if (_184 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_184 < _149.d0)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    if (_185 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (_185 < _149.d1)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    int64_t _186 = 0;
    _186 *= _149.d0;
    _186 += _184;
    _186 *= _149.d1;
    _186 += _185;
    int64_t _187 = _149.data[_186];
    _a3_int64_t _188;
    // Computing bound for a
    int64_t _189 = 967;
    int64_t _190 = -_189;
    int64_t _191 = -_190;
    _188.d0 = _191;
    if (_191 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for b
    int64_t _192 = 110;
    _188.d1 = _192;
    if (_192 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    // Computing bound for c
    int64_t _193 = 887;
    int64_t _194 = -_193;
    _188.d2 = _194;
    if (_194 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= _191;
    _195 *= _192;
    _195 *= _194;
    _195 *= sizeof(int64_t);
    _188.data = jpl_alloc(_195);
    int64_t _196 = 0; // c
    int64_t _197 = 0; // b
    int64_t _198 = 0; // a
    _jump94:; // Begin body of loop
    int64_t _199;
    // Computing bound for d
    if (_197 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    // Computing bound for e
    if (_196 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    _199 = 0;
    int64_t _200 = 0; // e
    int64_t _201 = 0; // d
    _jump97:; // Begin body of loop
    _199 += _198;
    _200++;
    if (_200 < _196)
    goto _jump97;
    _200 = 0;
    _201++;
    if (_201 < _197)
    goto _jump97;
    // End body of loop
    int64_t _202 = 0;
    _202 *= _188.d0;
    _202 += _198;
    _202 *= _188.d1;
    _202 += _197;
    _202 *= _188.d2;
    _202 += _196;
    _188.data[_202] = _199;
    _196++;
    if (_196 < _194)
    goto _jump94;
    _196 = 0;
    _197++;
    if (_197 < _192)
    goto _jump94;
    _197 = 0;
    _198++;
    if (_198 < _191)
    goto _jump94;
    // End body of loop
    int64_t _203;
    // Computing bound for a
    int64_t _204 = 150;
    if (_204 > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    _203 = 0;
    int64_t _205 = 0; // a
    _jump99:; // Begin body of loop
    int64_t _206;
    // Computing bound for b
    int64_t _207 = 642;
    int64_t _208 = _205 / _207;
    if (_208 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    // Computing bound for c
    int64_t _209 = 158;
    if (_209 > 0) 
    goto _jump101;
    fail_assertion("non-positive loop bound");
    _jump101:;
    _206 = 0;
    int64_t _210 = 0; // c
    int64_t _211 = 0; // b
    _jump102:; // Begin body of loop
    _206 += _205;
    _210++;
    if (_210 < _209)
    goto _jump102;
    _210 = 0;
    _211++;
    if (_211 < _208)
    goto _jump102;
    // End body of loop
    _203 += _206;
    _205++;
    if (_205 < _204)
    goto _jump99;
    // End body of loop
    bool _212 = true;
    int64_t _213;
    if (!_212)
    goto _jump103;
    int64_t _214 = 100;
    _213 = _214;
    goto _jump104;
    _jump103:;
    int64_t _215 = 737;
    _213 = _215;
    _jump104:;
    int64_t _216 = -_213;
    int64_t _217 = 248;
    int64_t _218 = _216 / _217;
    _a3_int64_t _219;
    // Computing bound for a
    int64_t _220 = 506;
    _219.d0 = _220;
    if (_220 > 0) 
    goto _jump105;
    fail_assertion("non-positive loop bound");
    _jump105:;
    // Computing bound for b
    int64_t _221 = 435;
    _219.d1 = _221;
    if (_221 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing bound for c
    int64_t _222 = 650;
    int64_t _223 = -_222;
    _219.d2 = _223;
    if (_223 > 0) 
    goto _jump107;
    fail_assertion("non-positive loop bound");
    _jump107:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= _220;
    _224 *= _221;
    _224 *= _223;
    _224 *= sizeof(int64_t);
    _219.data = jpl_alloc(_224);
    int64_t _225 = 0; // c
    int64_t _226 = 0; // b
    int64_t _227 = 0; // a
    _jump108:; // Begin body of loop
    int64_t _228 = 0;
    _228 *= _219.d0;
    _228 += _227;
    _228 *= _219.d1;
    _228 += _226;
    _228 *= _219.d2;
    _228 += _225;
    _219.data[_228] = _227;
    _225++;
    if (_225 < _223)
    goto _jump108;
    _225 = 0;
    _226++;
    if (_226 < _221)
    goto _jump108;
    _226 = 0;
    _227++;
    if (_227 < _220)
    goto _jump108;
    // End body of loop
    int64_t _229 = 32;
    int64_t _230 = -_229;
    int64_t _231;
    // Computing bound for a
    int64_t _232 = 488;
    int64_t _233 = -_232;
    if (_233 > 0) 
    goto _jump109;
    fail_assertion("non-positive loop bound");
    _jump109:;
    _231 = 0;
    int64_t _234 = 0; // a
    _jump110:; // Begin body of loop
    int64_t _235 = -_234;
    _231 += _235;
    _234++;
    if (_234 < _233)
    goto _jump110;
    // End body of loop
    int64_t _236;
    // Computing bound for a
    int64_t _237 = 805;
    if (_237 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing bound for b
    int64_t _238 = 226;
    int64_t _239 = -_238;
    if (_239 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing bound for c
    int64_t _240;
    // Computing bound for a
    int64_t _241 = 813;
    if (_241 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    // Computing bound for b
    int64_t _242 = 869;
    if (_242 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    _240 = 0;
    int64_t _243 = 0; // b
    int64_t _244 = 0; // a
    _jump115:; // Begin body of loop
    _240 += _244;
    _243++;
    if (_243 < _242)
    goto _jump115;
    _243 = 0;
    _244++;
    if (_244 < _241)
    goto _jump115;
    // End body of loop
    if (_240 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _236 = 0;
    int64_t _245 = 0; // c
    int64_t _246 = 0; // b
    int64_t _247 = 0; // a
    _jump117:; // Begin body of loop
    _236 += _247;
    _245++;
    if (_245 < _240)
    goto _jump117;
    _245 = 0;
    _246++;
    if (_246 < _239)
    goto _jump117;
    _246 = 0;
    _247++;
    if (_247 < _237)
    goto _jump117;
    // End body of loop
    if (_230 >= 0)
    goto _jump118;
    fail_assertion("negative array index");
    _jump118:;
    if (_230 < _219.d0)
    goto _jump119;
    fail_assertion("index too large");
    _jump119:;
    if (_231 >= 0)
    goto _jump120;
    fail_assertion("negative array index");
    _jump120:;
    if (_231 < _219.d1)
    goto _jump121;
    fail_assertion("index too large");
    _jump121:;
    if (_236 >= 0)
    goto _jump122;
    fail_assertion("negative array index");
    _jump122:;
    if (_236 < _219.d2)
    goto _jump123;
    fail_assertion("index too large");
    _jump123:;
    int64_t _248 = 0;
    _248 *= _219.d0;
    _248 += _230;
    _248 *= _219.d1;
    _248 += _231;
    _248 *= _219.d2;
    _248 += _236;
    int64_t _249 = _219.data[_248];
    if (_203 >= 0)
    goto _jump124;
    fail_assertion("negative array index");
    _jump124:;
    if (_203 < _188.d0)
    goto _jump125;
    fail_assertion("index too large");
    _jump125:;
    if (_218 >= 0)
    goto _jump126;
    fail_assertion("negative array index");
    _jump126:;
    if (_218 < _188.d1)
    goto _jump127;
    fail_assertion("index too large");
    _jump127:;
    if (_249 >= 0)
    goto _jump128;
    fail_assertion("negative array index");
    _jump128:;
    if (_249 < _188.d2)
    goto _jump129;
    fail_assertion("index too large");
    _jump129:;
    int64_t _250 = 0;
    _250 *= _188.d0;
    _250 += _203;
    _250 *= _188.d1;
    _250 += _218;
    _250 *= _188.d2;
    _250 += _249;
    int64_t _251 = _188.data[_250];
    int64_t _252 = _187 / _251;
    if (_252 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for c
    _a3_int64_t _253;
    // Computing bound for a
    int64_t _254;
    // Computing bound for a
    int64_t _255 = 3;
    if (_255 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing bound for b
    int64_t _256 = 303;
    int64_t _257 = -_256;
    if (_257 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    // Computing bound for c
    int64_t _258 = 250;
    if (_258 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    _254 = 0;
    int64_t _259 = 0; // c
    int64_t _260 = 0; // b
    int64_t _261 = 0; // a
    _jump134:; // Begin body of loop
    int64_t _262 = 459;
    _254 += _262;
    _259++;
    if (_259 < _258)
    goto _jump134;
    _259 = 0;
    _260++;
    if (_260 < _257)
    goto _jump134;
    _260 = 0;
    _261++;
    if (_261 < _255)
    goto _jump134;
    // End body of loop
    int64_t _263 = 215;
    int64_t _264 = -_263;
    int64_t _265 = 786;
    int64_t _266 = _264 / _265;
    int64_t _267 = _254 - _266;
    _253.d0 = _267;
    if (_267 > 0) 
    goto _jump135;
    fail_assertion("non-positive loop bound");
    _jump135:;
    // Computing bound for b
    int64_t _268 = 552;
    int64_t _269 = -_268;
    int64_t _270 = 864;
    int64_t _271 = _269 + _270;
    _253.d1 = _271;
    if (_271 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    // Computing bound for c
    int64_t _272;
    // Computing bound for a
    int64_t _273 = 173;
    if (_273 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing bound for b
    int64_t _274;
    // Computing bound for a
    int64_t _275 = 740;
    if (_275 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    _274 = 0;
    int64_t _276 = 0; // a
    _jump139:; // Begin body of loop
    int64_t _277 = 467;
    int64_t _278 = 906;
    int64_t _279 = _277 / _278;
    _274 += _279;
    _276++;
    if (_276 < _275)
    goto _jump139;
    // End body of loop
    if (_274 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing bound for c
    int64_t _280 = 86;
    int64_t _281 = -_280;
    if (_281 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    _272 = 0;
    int64_t _282 = 0; // c
    int64_t _283 = 0; // b
    int64_t _284 = 0; // a
    _jump142:; // Begin body of loop
    bool _285 = false;
    int64_t _286;
    if (!_285)
    goto _jump143;
    _286 = _283;
    goto _jump144;
    _jump143:;
    int64_t _287 = 81;
    _286 = _287;
    _jump144:;
    int64_t _288 = _283 % _286;
    _272 += _288;
    _282++;
    if (_282 < _281)
    goto _jump142;
    _282 = 0;
    _283++;
    if (_283 < _274)
    goto _jump142;
    _283 = 0;
    _284++;
    if (_284 < _273)
    goto _jump142;
    // End body of loop
    _253.d2 = _272;
    if (_272 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing total size of heap memory to allocate
    int64_t _289 = 1;
    _289 *= _267;
    _289 *= _271;
    _289 *= _272;
    _289 *= sizeof(int64_t);
    _253.data = jpl_alloc(_289);
    int64_t _290 = 0; // c
    int64_t _291 = 0; // b
    int64_t _292 = 0; // a
    _jump146:; // Begin body of loop
    int64_t _293 = -_292;
    int64_t _294 = 0;
    _294 *= _253.d0;
    _294 += _292;
    _294 *= _253.d1;
    _294 += _291;
    _294 *= _253.d2;
    _294 += _290;
    _253.data[_294] = _293;
    _290++;
    if (_290 < _272)
    goto _jump146;
    _290 = 0;
    _291++;
    if (_291 < _271)
    goto _jump146;
    _291 = 0;
    _292++;
    if (_292 < _267)
    goto _jump146;
    // End body of loop
    int64_t _295 = 561;
    int64_t _296;
    // Computing bound for a
    int64_t _297;
    // Computing bound for a
    int64_t _298 = 562;
    if (_298 > 0) 
    goto _jump147;
    fail_assertion("non-positive loop bound");
    _jump147:;
    // Computing bound for b
    int64_t _299;
    // Computing bound for a
    int64_t _300 = 437;
    if (_300 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    _299 = 0;
    int64_t _301 = 0; // a
    _jump149:; // Begin body of loop
    _299 += _301;
    _301++;
    if (_301 < _300)
    goto _jump149;
    // End body of loop
    if (_299 > 0) 
    goto _jump150;
    fail_assertion("non-positive loop bound");
    _jump150:;
    _297 = 0;
    int64_t _302 = 0; // b
    int64_t _303 = 0; // a
    _jump151:; // Begin body of loop
    int64_t _304 = 551;
    _297 += _304;
    _302++;
    if (_302 < _299)
    goto _jump151;
    _302 = 0;
    _303++;
    if (_303 < _298)
    goto _jump151;
    // End body of loop
    int64_t _305;
    // Computing bound for a
    int64_t _306 = 683;
    if (_306 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    _305 = 0;
    int64_t _307 = 0; // a
    _jump153:; // Begin body of loop
    int64_t _308 = 813;
    _305 += _308;
    _307++;
    if (_307 < _306)
    goto _jump153;
    // End body of loop
    int64_t _309;
    // Computing bound for a
    int64_t _310 = 327;
    if (_310 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for b
    int64_t _311 = 204;
    if (_311 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    _309 = 0;
    int64_t _312 = 0; // b
    int64_t _313 = 0; // a
    _jump156:; // Begin body of loop
    _309 += _312;
    _312++;
    if (_312 < _311)
    goto _jump156;
    _312 = 0;
    _313++;
    if (_313 < _310)
    goto _jump156;
    // End body of loop
    int64_t _314 = _305 - _309;
    int64_t _315 = _297 % _314;
    if (_315 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing bound for b
    int64_t _316 = 980;
    if (_316 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    // Computing bound for c
    int64_t _317;
    // Computing bound for a
    int64_t _318 = 557;
    if (_318 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing bound for b
    int64_t _319;
    // Computing bound for a
    int64_t _320 = 697;
    int64_t _321 = -_320;
    if (_321 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    // Computing bound for b
    int64_t _322 = 98;
    if (_322 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    _319 = 0;
    int64_t _323 = 0; // b
    int64_t _324 = 0; // a
    _jump162:; // Begin body of loop
    _319 += _323;
    _323++;
    if (_323 < _322)
    goto _jump162;
    _323 = 0;
    _324++;
    if (_324 < _321)
    goto _jump162;
    // End body of loop
    if (_319 > 0) 
    goto _jump163;
    fail_assertion("non-positive loop bound");
    _jump163:;
    _317 = 0;
    int64_t _325 = 0; // b
    int64_t _326 = 0; // a
    _jump164:; // Begin body of loop
    _317 += _325;
    _325++;
    if (_325 < _319)
    goto _jump164;
    _325 = 0;
    _326++;
    if (_326 < _318)
    goto _jump164;
    // End body of loop
    if (_317 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    _296 = 0;
    int64_t _327 = 0; // c
    int64_t _328 = 0; // b
    int64_t _329 = 0; // a
    _jump166:; // Begin body of loop
    int64_t _330;
    // Computing bound for d
    _a2_int64_t _331;
    // Computing bound for d
    int64_t _332 = 134;
    _331.d0 = _332;
    if (_332 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing bound for e
    _331.d1 = _327;
    if (_327 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    // Computing total size of heap memory to allocate
    int64_t _333 = 1;
    _333 *= _332;
    _333 *= _327;
    _333 *= sizeof(int64_t);
    _331.data = jpl_alloc(_333);
    int64_t _334 = 0; // e
    int64_t _335 = 0; // d
    _jump169:; // Begin body of loop
    int64_t _336 = 0;
    _336 *= _331.d0;
    _336 += _335;
    _336 *= _331.d1;
    _336 += _334;
    _331.data[_336] = _335;
    _334++;
    if (_334 < _327)
    goto _jump169;
    _334 = 0;
    _335++;
    if (_335 < _332)
    goto _jump169;
    // End body of loop
    int64_t _337 = 566;
    int64_t _338 = _337 + _329;
    if (_338 >= 0)
    goto _jump170;
    fail_assertion("negative array index");
    _jump170:;
    if (_338 < _331.d0)
    goto _jump171;
    fail_assertion("index too large");
    _jump171:;
    if (_329 >= 0)
    goto _jump172;
    fail_assertion("negative array index");
    _jump172:;
    if (_329 < _331.d1)
    goto _jump173;
    fail_assertion("index too large");
    _jump173:;
    int64_t _339 = 0;
    _339 *= _331.d0;
    _339 += _338;
    _339 *= _331.d1;
    _339 += _329;
    int64_t _340 = _331.data[_339];
    if (_340 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    _330 = 0;
    int64_t _341 = 0; // d
    _jump175:; // Begin body of loop
    int64_t _342 = -_341;
    int64_t _343 = 171;
    int64_t _344 = _342 - _343;
    _330 += _344;
    _341++;
    if (_341 < _340)
    goto _jump175;
    // End body of loop
    _296 += _330;
    _327++;
    if (_327 < _317)
    goto _jump166;
    _327 = 0;
    _328++;
    if (_328 < _316)
    goto _jump166;
    _328 = 0;
    _329++;
    if (_329 < _315)
    goto _jump166;
    // End body of loop
    int64_t _345;
    // Computing bound for a
    int64_t _346 = 983;
    int64_t _347 = -_346;
    int64_t _348 = 452;
    int64_t _349 = _347 - _348;
    if (_349 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    _345 = 0;
    int64_t _350 = 0; // a
    _jump177:; // Begin body of loop
    int64_t _351 = 856;
    int64_t _352 = -_351;
    _345 += _352;
    _350++;
    if (_350 < _349)
    goto _jump177;
    // End body of loop
    double _353 = 1.0;
    double _354 = 42.0;
    bool _355 = _353 != _354;
    bool _356;
    if (!_355)
    goto _jump178;
    bool _357 = true;
    _356 = _357;
    goto _jump179;
    _jump178:;
    bool _358 = false;
    _356 = _358;
    _jump179:;
    int64_t _359;
    if (!_356)
    goto _jump180;
    int64_t _360 = 45;
    int64_t _361 = -_360;
    _359 = _361;
    goto _jump181;
    _jump180:;
    int64_t _362;
    // Computing bound for a
    int64_t _363 = 266;
    int64_t _364 = -_363;
    if (_364 > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing bound for b
    int64_t _365 = 276;
    if (_365 > 0) 
    goto _jump183;
    fail_assertion("non-positive loop bound");
    _jump183:;
    // Computing bound for c
    int64_t _366 = 304;
    if (_366 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    _362 = 0;
    int64_t _367 = 0; // c
    int64_t _368 = 0; // b
    int64_t _369 = 0; // a
    _jump185:; // Begin body of loop
    bool _370 = true;
    int64_t _371;
    if (!_370)
    goto _jump186;
    _371 = _369;
    goto _jump187;
    _jump186:;
    _371 = _368;
    _jump187:;
    _362 += _371;
    _367++;
    if (_367 < _366)
    goto _jump185;
    _367 = 0;
    _368++;
    if (_368 < _365)
    goto _jump185;
    _368 = 0;
    _369++;
    if (_369 < _364)
    goto _jump185;
    // End body of loop
    _359 = _362;
    _jump181:;
    int64_t _372 = _345 + _359;
    if (_295 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_295 < _253.d0)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    if (_296 >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (_296 < _253.d1)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    if (_372 >= 0)
    goto _jump192;
    fail_assertion("negative array index");
    _jump192:;
    if (_372 < _253.d2)
    goto _jump193;
    fail_assertion("index too large");
    _jump193:;
    int64_t _373 = 0;
    _373 *= _253.d0;
    _373 += _295;
    _373 *= _253.d1;
    _373 += _296;
    _373 *= _253.d2;
    _373 += _372;
    int64_t _374 = _253.data[_373];
    if (_374 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    _64 = 0;
    int64_t _375 = 0; // c
    int64_t _376 = 0; // b
    int64_t _377 = 0; // a
    _jump195:; // Begin body of loop
    int64_t _378 = 376;
    _64 += _378;
    _375++;
    if (_375 < _374)
    goto _jump195;
    _375 = 0;
    _376++;
    if (_376 < _252)
    goto _jump195;
    _376 = 0;
    _377++;
    if (_377 < _77)
    goto _jump195;
    // End body of loop
    if (_64 >= 0)
    goto _jump196;
    fail_assertion("negative array index");
    _jump196:;
    if (_64 < _63.d0)
    goto _jump197;
    fail_assertion("index too large");
    _jump197:;
    int64_t _379 = 0;
    _379 *= _63.d0;
    _379 += _64;
    bool _380 = _63.data[_379];
    _a3_bool _381;
    // Computing bound for c
    int64_t _382 = 938;
    int64_t _383 = -_382;
    _381.d0 = _383;
    if (_383 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing bound for d
    int64_t _384;
    // Computing bound for c
    _a2_double _385;
    // Computing bound for c
    int64_t _386 = 598;
    int64_t _387 = 666;
    int64_t _388 = _386 + _387;
    _385.d0 = _388;
    if (_388 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    // Computing bound for d
    int64_t _389 = 244;
    int64_t _390 = -_389;
    int64_t _391 = -_390;
    _385.d1 = _391;
    if (_391 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= _388;
    _392 *= _391;
    _392 *= sizeof(double);
    _385.data = jpl_alloc(_392);
    int64_t _393 = 0; // d
    int64_t _394 = 0; // c
    _jump537:; // Begin body of loop
    double _395;
    // Computing bound for e
    int64_t _396;
    // Computing bound for e
    if (_393 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing bound for f
    int64_t _397 = 592;
    if (_397 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    // Computing bound for g
    int64_t _398 = 739;
    int64_t _399 = _398 % _394;
    if (_399 > 0) 
    goto _jump540;
    fail_assertion("non-positive loop bound");
    _jump540:;
    _396 = 0;
    int64_t _400 = 0; // g
    int64_t _401 = 0; // f
    int64_t _402 = 0; // e
    _jump541:; // Begin body of loop
    int64_t _403 = 547;
    int64_t _404 = _401 / _403;
    _396 += _404;
    _400++;
    if (_400 < _399)
    goto _jump541;
    _400 = 0;
    _401++;
    if (_401 < _397)
    goto _jump541;
    _401 = 0;
    _402++;
    if (_402 < _393)
    goto _jump541;
    // End body of loop
    if (_396 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    // Computing bound for f
    int64_t _405 = 475;
    if (_405 > 0) 
    goto _jump543;
    fail_assertion("non-positive loop bound");
    _jump543:;
    // Computing bound for g
    _a2_int64_t _406;
    // Computing bound for e
    _406.d0 = _393;
    if (_393 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for f
    _406.d1 = _394;
    if (_394 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing total size of heap memory to allocate
    int64_t _407 = 1;
    _407 *= _393;
    _407 *= _394;
    _407 *= sizeof(int64_t);
    _406.data = jpl_alloc(_407);
    int64_t _408 = 0; // f
    int64_t _409 = 0; // e
    _jump546:; // Begin body of loop
    int64_t _410 = 768;
    int64_t _411 = 0;
    _411 *= _406.d0;
    _411 += _409;
    _411 *= _406.d1;
    _411 += _408;
    _406.data[_411] = _410;
    _408++;
    if (_408 < _394)
    goto _jump546;
    _408 = 0;
    _409++;
    if (_409 < _393)
    goto _jump546;
    // End body of loop
    int64_t _412;
    // Computing bound for e
    if (_393 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    // Computing bound for f
    int64_t _413 = 550;
    if (_413 > 0) 
    goto _jump548;
    fail_assertion("non-positive loop bound");
    _jump548:;
    // Computing bound for g
    if (_393 > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    _412 = 0;
    int64_t _414 = 0; // g
    int64_t _415 = 0; // f
    int64_t _416 = 0; // e
    _jump550:; // Begin body of loop
    _412 += _415;
    _414++;
    if (_414 < _393)
    goto _jump550;
    _414 = 0;
    _415++;
    if (_415 < _413)
    goto _jump550;
    _415 = 0;
    _416++;
    if (_416 < _393)
    goto _jump550;
    // End body of loop
    int64_t _417 = -_394;
    if (_412 >= 0)
    goto _jump551;
    fail_assertion("negative array index");
    _jump551:;
    if (_412 < _406.d0)
    goto _jump552;
    fail_assertion("index too large");
    _jump552:;
    if (_417 >= 0)
    goto _jump553;
    fail_assertion("negative array index");
    _jump553:;
    if (_417 < _406.d1)
    goto _jump554;
    fail_assertion("index too large");
    _jump554:;
    int64_t _418 = 0;
    _418 *= _406.d0;
    _418 += _412;
    _418 *= _406.d1;
    _418 += _417;
    int64_t _419 = _406.data[_418];
    if (_419 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    _395 = 0;
    int64_t _420 = 0; // g
    int64_t _421 = 0; // f
    int64_t _422 = 0; // e
    _jump556:; // Begin body of loop
    double _423 = 27.0;
    double _424 = 8.0;
    double _425 = _423 / _424;
    _395 += _425;
    _420++;
    if (_420 < _419)
    goto _jump556;
    _420 = 0;
    _421++;
    if (_421 < _405)
    goto _jump556;
    _421 = 0;
    _422++;
    if (_422 < _396)
    goto _jump556;
    // End body of loop
    int64_t _426 = 0;
    _426 *= _385.d0;
    _426 += _394;
    _426 *= _385.d1;
    _426 += _393;
    _385.data[_426] = _395;
    _393++;
    if (_393 < _391)
    goto _jump537;
    _393 = 0;
    _394++;
    if (_394 < _388)
    goto _jump537;
    // End body of loop
    int64_t _427 = b(_385);
    if (_427 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    _384 = 0;
    int64_t _428 = 0; // c
    _jump558:; // Begin body of loop
    int64_t _429;
    // Computing bound for d
    _a2_double _430;
    // Computing bound for d
    int64_t _431;
    // Computing bound for d
    if (_428 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    _431 = 0;
    int64_t _432 = 0; // d
    _jump560:; // Begin body of loop
    _431 += _428;
    _432++;
    if (_432 < _428)
    goto _jump560;
    // End body of loop
    _430.d0 = _431;
    if (_431 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for e
    _430.d1 = _428;
    if (_428 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    // Computing total size of heap memory to allocate
    int64_t _433 = 1;
    _433 *= _431;
    _433 *= _428;
    _433 *= sizeof(double);
    _430.data = jpl_alloc(_433);
    int64_t _434 = 0; // e
    int64_t _435 = 0; // d
    _jump563:; // Begin body of loop
    double _436 = 39.0;
    int64_t _437 = 0;
    _437 *= _430.d0;
    _437 += _435;
    _437 *= _430.d1;
    _437 += _434;
    _430.data[_437] = _436;
    _434++;
    if (_434 < _428)
    goto _jump563;
    _434 = 0;
    _435++;
    if (_435 < _431)
    goto _jump563;
    // End body of loop
    int64_t _438 = b(_430);
    int64_t _439 = -_438;
    if (_439 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing bound for e
    bool _441 = _380;
    if (0 == _380)
    goto _jump565;
    _441 = _380;
    _jump565:;
    bool _440 = _441;
    if (0 != _441)
    goto _jump566;
    _440 = _380;
    _jump566:;
    int64_t _442;
    if (!_440)
    goto _jump567;
    int64_t _443 = 50;
    int64_t _444 = _428 * _443;
    _442 = _444;
    goto _jump568;
    _jump567:;
    _a3_int64_t _445;
    // Computing bound for d
    int64_t _446 = 202;
    _445.d0 = _446;
    if (_446 > 0) 
    goto _jump569;
    fail_assertion("non-positive loop bound");
    _jump569:;
    // Computing bound for e
    _445.d1 = _428;
    if (_428 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for f
    _445.d2 = _428;
    if (_428 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= _446;
    _447 *= _428;
    _447 *= _428;
    _447 *= sizeof(int64_t);
    _445.data = jpl_alloc(_447);
    int64_t _448 = 0; // f
    int64_t _449 = 0; // e
    int64_t _450 = 0; // d
    _jump572:; // Begin body of loop
    int64_t _451 = 0;
    _451 *= _445.d0;
    _451 += _450;
    _451 *= _445.d1;
    _451 += _449;
    _451 *= _445.d2;
    _451 += _448;
    _445.data[_451] = _449;
    _448++;
    if (_448 < _428)
    goto _jump572;
    _448 = 0;
    _449++;
    if (_449 < _428)
    goto _jump572;
    _449 = 0;
    _450++;
    if (_450 < _446)
    goto _jump572;
    // End body of loop
    int64_t _452 = 370;
    int64_t _453 = _428 - _428;
    if (_452 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (_452 < _445.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    if (_453 >= 0)
    goto _jump575;
    fail_assertion("negative array index");
    _jump575:;
    if (_453 < _445.d1)
    goto _jump576;
    fail_assertion("index too large");
    _jump576:;
    if (_428 >= 0)
    goto _jump577;
    fail_assertion("negative array index");
    _jump577:;
    if (_428 < _445.d2)
    goto _jump578;
    fail_assertion("index too large");
    _jump578:;
    int64_t _454 = 0;
    _454 *= _445.d0;
    _454 += _452;
    _454 *= _445.d1;
    _454 += _453;
    _454 *= _445.d2;
    _454 += _428;
    int64_t _455 = _445.data[_454];
    _442 = _455;
    _jump568:;
    int64_t _456 = -_442;
    if (_456 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    _429 = 0;
    int64_t _457 = 0; // e
    int64_t _458 = 0; // d
    _jump580:; // Begin body of loop
    int64_t _459;
    // Computing bound for f
    if (_457 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing bound for g
    bool _461 = true;
    bool _460 = _461;
    if (0 != _461)
    goto _jump582;
    bool _462 = false;
    _460 = _462;
    _jump582:;
    bool _463 = true;
    bool _464 = !_463;
    bool _465 = _460 == _464;
    int64_t _466;
    if (!_465)
    goto _jump583;
    _466 = _458;
    goto _jump584;
    _jump583:;
    int64_t _467 = 127;
    _466 = _467;
    _jump584:;
    if (_466 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    _459 = 0;
    int64_t _468 = 0; // g
    int64_t _469 = 0; // f
    _jump586:; // Begin body of loop
    _459 += _468;
    _468++;
    if (_468 < _466)
    goto _jump586;
    _468 = 0;
    _469++;
    if (_469 < _457)
    goto _jump586;
    // End body of loop
    _429 += _459;
    _457++;
    if (_457 < _456)
    goto _jump580;
    _457 = 0;
    _458++;
    if (_458 < _439)
    goto _jump580;
    // End body of loop
    _384 += _429;
    _428++;
    if (_428 < _427)
    goto _jump558;
    // End body of loop
    _381.d1 = _384;
    if (_384 > 0) 
    goto _jump587;
    fail_assertion("non-positive loop bound");
    _jump587:;
    // Computing bound for e
    _a3_int64_t _470;
    // Computing bound for c
    int64_t _471 = 250;
    int64_t _472 = -_471;
    _470.d0 = _472;
    if (_472 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing bound for d
    int64_t _473 = 402;
    int64_t _474 = 484;
    bool _475 = _473 < _474;
    int64_t _476;
    if (!_475)
    goto _jump589;
    int64_t _477 = 194;
    int64_t _478 = 805;
    int64_t _479 = _477 + _478;
    _476 = _479;
    goto _jump590;
    _jump589:;
    _a2_double _480;
    // Computing bound for c
    int64_t _481;
    // Computing bound for c
    int64_t _482 = 429;
    if (_482 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for d
    int64_t _483 = 647;
    if (_483 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    _481 = 0;
    int64_t _484 = 0; // d
    int64_t _485 = 0; // c
    _jump593:; // Begin body of loop
    _481 += _484;
    _484++;
    if (_484 < _483)
    goto _jump593;
    _484 = 0;
    _485++;
    if (_485 < _482)
    goto _jump593;
    // End body of loop
    _480.d0 = _481;
    if (_481 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for d
    int64_t _486 = 992;
    _480.d1 = _486;
    if (_486 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing total size of heap memory to allocate
    int64_t _487 = 1;
    _487 *= _481;
    _487 *= _486;
    _487 *= sizeof(double);
    _480.data = jpl_alloc(_487);
    int64_t _488 = 0; // d
    int64_t _489 = 0; // c
    _jump596:; // Begin body of loop
    double _490;
    // Computing bound for e
    if (_488 > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    _490 = 0;
    int64_t _491 = 0; // e
    _jump598:; // Begin body of loop
    double _492 = 90.0;
    _490 += _492;
    _491++;
    if (_491 < _488)
    goto _jump598;
    // End body of loop
    int64_t _493 = 0;
    _493 *= _480.d0;
    _493 += _489;
    _493 *= _480.d1;
    _493 += _488;
    _480.data[_493] = _490;
    _488++;
    if (_488 < _486)
    goto _jump596;
    _488 = 0;
    _489++;
    if (_489 < _481)
    goto _jump596;
    // End body of loop
    int64_t _494 = b(_480);
    _476 = _494;
    _jump590:;
    _470.d1 = _476;
    if (_476 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    // Computing bound for e
    int64_t _495 = 111;
    _470.d2 = _495;
    if (_495 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing total size of heap memory to allocate
    int64_t _496 = 1;
    _496 *= _472;
    _496 *= _476;
    _496 *= _495;
    _496 *= sizeof(int64_t);
    _470.data = jpl_alloc(_496);
    int64_t _497 = 0; // e
    int64_t _498 = 0; // d
    int64_t _499 = 0; // c
    _jump601:; // Begin body of loop
    int64_t _500;
    if (!_380)
    goto _jump602;
    int64_t _501 = 757;
    _500 = _501;
    goto _jump603;
    _jump602:;
    _500 = _499;
    _jump603:;
    int64_t _502 = 0;
    _502 *= _470.d0;
    _502 += _499;
    _502 *= _470.d1;
    _502 += _498;
    _502 *= _470.d2;
    _502 += _497;
    _470.data[_502] = _500;
    _497++;
    if (_497 < _495)
    goto _jump601;
    _497 = 0;
    _498++;
    if (_498 < _476)
    goto _jump601;
    _498 = 0;
    _499++;
    if (_499 < _472)
    goto _jump601;
    // End body of loop
    int64_t _503 = 263;
    int64_t _504 = 878;
    int64_t _505;
    if (!_380)
    goto _jump604;
    int64_t _506;
    // Computing bound for c
    int64_t _507 = 565;
    if (_507 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for d
    int64_t _508 = 440;
    int64_t _509 = -_508;
    if (_509 > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    // Computing bound for e
    int64_t _510 = 998;
    int64_t _511 = -_510;
    if (_511 > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    _506 = 0;
    int64_t _512 = 0; // e
    int64_t _513 = 0; // d
    int64_t _514 = 0; // c
    _jump608:; // Begin body of loop
    _506 += _513;
    _512++;
    if (_512 < _511)
    goto _jump608;
    _512 = 0;
    _513++;
    if (_513 < _509)
    goto _jump608;
    _513 = 0;
    _514++;
    if (_514 < _507)
    goto _jump608;
    // End body of loop
    _505 = _506;
    goto _jump609;
    _jump604:;
    int64_t _515 = 928;
    _505 = _515;
    _jump609:;
    int64_t _516;
    // Computing bound for c
    int64_t _517;
    // Computing bound for c
    int64_t _518 = 283;
    int64_t _519 = -_518;
    if (_519 > 0) 
    goto _jump610;
    fail_assertion("non-positive loop bound");
    _jump610:;
    _517 = 0;
    int64_t _520 = 0; // c
    _jump611:; // Begin body of loop
    int64_t _521;
    if (!_380)
    goto _jump612;
    _521 = _520;
    goto _jump613;
    _jump612:;
    int64_t _522 = 162;
    int64_t _523 = -_522;
    _521 = _523;
    _jump613:;
    _517 += _521;
    _520++;
    if (_520 < _519)
    goto _jump611;
    // End body of loop
    if (_517 > 0) 
    goto _jump614;
    fail_assertion("non-positive loop bound");
    _jump614:;
    _516 = 0;
    int64_t _524 = 0; // c
    _jump615:; // Begin body of loop
    int64_t _525;
    // Computing bound for d
    if (_524 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing bound for e
    int64_t _526 = 937;
    if (_526 > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    _525 = 0;
    int64_t _527 = 0; // e
    int64_t _528 = 0; // d
    _jump618:; // Begin body of loop
    _525 += _527;
    _527++;
    if (_527 < _526)
    goto _jump618;
    _527 = 0;
    _528++;
    if (_528 < _524)
    goto _jump618;
    // End body of loop
    int64_t _529 = -_525;
    int64_t _530 = -_529;
    _516 += _530;
    _524++;
    if (_524 < _517)
    goto _jump615;
    // End body of loop
    int64_t _531 = _505 - _516;
    if (_503 >= 0)
    goto _jump619;
    fail_assertion("negative array index");
    _jump619:;
    if (_503 < _470.d0)
    goto _jump620;
    fail_assertion("index too large");
    _jump620:;
    if (_504 >= 0)
    goto _jump621;
    fail_assertion("negative array index");
    _jump621:;
    if (_504 < _470.d1)
    goto _jump622;
    fail_assertion("index too large");
    _jump622:;
    if (_531 >= 0)
    goto _jump623;
    fail_assertion("negative array index");
    _jump623:;
    if (_531 < _470.d2)
    goto _jump624;
    fail_assertion("index too large");
    _jump624:;
    int64_t _532 = 0;
    _532 *= _470.d0;
    _532 += _503;
    _532 *= _470.d1;
    _532 += _504;
    _532 *= _470.d2;
    _532 += _531;
    int64_t _533 = _470.data[_532];
    _381.d2 = _533;
    if (_533 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing total size of heap memory to allocate
    int64_t _534 = 1;
    _534 *= _383;
    _534 *= _384;
    _534 *= _533;
    _534 *= sizeof(bool);
    _381.data = jpl_alloc(_534);
    int64_t _535 = 0; // e
    int64_t _536 = 0; // d
    int64_t _537 = 0; // c
    _jump626:; // Begin body of loop
    bool _538 = true;
    bool _539 = !_538;
    int64_t _540 = 0;
    _540 *= _381.d0;
    _540 += _537;
    _540 *= _381.d1;
    _540 += _536;
    _540 *= _381.d2;
    _540 += _535;
    _381.data[_540] = _539;
    _535++;
    if (_535 < _533)
    goto _jump626;
    _535 = 0;
    _536++;
    if (_536 < _384)
    goto _jump626;
    _536 = 0;
    _537++;
    if (_537 < _383)
    goto _jump626;
    // End body of loop
    double _541 = get_time();
    double _542 = get_time();
    print_time(_542 - _541);
    double _543;
    // Computing bound for h
    if (_381.d2 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    // Computing bound for i
    int64_t _544 = -_381.d1;
    bool _545 = _544 > _381.d0;
    _a3_int64_t _546;
    if (!_545)
    goto _jump628;
    _a3_int64_t _547;
    // Computing bound for h
    int64_t _548;
    // Computing bound for h
    if (_381.d1 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    _548 = 0;
    int64_t _549 = 0; // h
    _jump630:; // Begin body of loop
    _548 += _381.d0;
    _549++;
    if (_549 < _381.d1)
    goto _jump630;
    // End body of loop
    _547.d0 = _548;
    if (_548 > 0) 
    goto _jump631;
    fail_assertion("non-positive loop bound");
    _jump631:;
    // Computing bound for i
    int64_t _550 = 793;
    int64_t _551 = -_550;
    int64_t _552 = _551 % _381.d0;
    _547.d1 = _552;
    if (_552 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for j
    _547.d2 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing total size of heap memory to allocate
    int64_t _553 = 1;
    _553 *= _548;
    _553 *= _552;
    _553 *= _381.d2;
    _553 *= sizeof(int64_t);
    _547.data = jpl_alloc(_553);
    int64_t _554 = 0; // j
    int64_t _555 = 0; // i
    int64_t _556 = 0; // h
    _jump634:; // Begin body of loop
    int64_t _557 = 0;
    _557 *= _547.d0;
    _557 += _556;
    _557 *= _547.d1;
    _557 += _555;
    _557 *= _547.d2;
    _557 += _554;
    _547.data[_557] = _555;
    _554++;
    if (_554 < _381.d2)
    goto _jump634;
    _554 = 0;
    _555++;
    if (_555 < _552)
    goto _jump634;
    _555 = 0;
    _556++;
    if (_556 < _548)
    goto _jump634;
    // End body of loop
    _546 = _547;
    goto _jump635;
    _jump628:;
    _a3__a3_int64_t _558;
    // Computing bound for h
    _558.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for i
    _558.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for j
    _558.d2 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    // Computing total size of heap memory to allocate
    int64_t _559 = 1;
    _559 *= _381.d0;
    _559 *= _381.d0;
    _559 *= _381.d1;
    _559 *= sizeof(_a3_int64_t);
    _558.data = jpl_alloc(_559);
    int64_t _560 = 0; // j
    int64_t _561 = 0; // i
    int64_t _562 = 0; // h
    _jump639:; // Begin body of loop
    _a3_int64_t _563;
    // Computing bound for k
    _563.d0 = _562;
    if (_562 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for l
    _563.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing bound for m
    _563.d2 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing total size of heap memory to allocate
    int64_t _564 = 1;
    _564 *= _562;
    _564 *= _381.d2;
    _564 *= _381.d0;
    _564 *= sizeof(int64_t);
    _563.data = jpl_alloc(_564);
    int64_t _565 = 0; // m
    int64_t _566 = 0; // l
    int64_t _567 = 0; // k
    _jump643:; // Begin body of loop
    int64_t _568 = 0;
    _568 *= _563.d0;
    _568 += _567;
    _568 *= _563.d1;
    _568 += _566;
    _568 *= _563.d2;
    _568 += _565;
    _563.data[_568] = _567;
    _565++;
    if (_565 < _381.d0)
    goto _jump643;
    _565 = 0;
    _566++;
    if (_566 < _381.d2)
    goto _jump643;
    _566 = 0;
    _567++;
    if (_567 < _562)
    goto _jump643;
    // End body of loop
    int64_t _569 = 0;
    _569 *= _558.d0;
    _569 += _562;
    _569 *= _558.d1;
    _569 += _561;
    _569 *= _558.d2;
    _569 += _560;
    _558.data[_569] = _563;
    _560++;
    if (_560 < _381.d1)
    goto _jump639;
    _560 = 0;
    _561++;
    if (_561 < _381.d0)
    goto _jump639;
    _561 = 0;
    _562++;
    if (_562 < _381.d0)
    goto _jump639;
    // End body of loop
    int64_t _570 = 393;
    int64_t _571 = _570 % _381.d0;
    int64_t _572 = _381.d1 / _571;
    _a3_int64_t _573;
    // Computing bound for h
    _573.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    // Computing bound for i
    _573.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    // Computing bound for j
    _573.d2 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing total size of heap memory to allocate
    int64_t _574 = 1;
    _574 *= _381.d2;
    _574 *= _381.d2;
    _574 *= _381.d0;
    _574 *= sizeof(int64_t);
    _573.data = jpl_alloc(_574);
    int64_t _575 = 0; // j
    int64_t _576 = 0; // i
    int64_t _577 = 0; // h
    _jump647:; // Begin body of loop
    int64_t _578 = 0;
    _578 *= _573.d0;
    _578 += _577;
    _578 *= _573.d1;
    _578 += _576;
    _578 *= _573.d2;
    _578 += _575;
    _573.data[_578] = _576;
    _575++;
    if (_575 < _381.d0)
    goto _jump647;
    _575 = 0;
    _576++;
    if (_576 < _381.d2)
    goto _jump647;
    _576 = 0;
    _577++;
    if (_577 < _381.d2)
    goto _jump647;
    // End body of loop
    int64_t _579 = 187;
    int64_t _580 = -_579;
    if (_381.d1 >= 0)
    goto _jump648;
    fail_assertion("negative array index");
    _jump648:;
    if (_381.d1 < _573.d0)
    goto _jump649;
    fail_assertion("index too large");
    _jump649:;
    if (_381.d1 >= 0)
    goto _jump650;
    fail_assertion("negative array index");
    _jump650:;
    if (_381.d1 < _573.d1)
    goto _jump651;
    fail_assertion("index too large");
    _jump651:;
    if (_580 >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (_580 < _573.d2)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    int64_t _581 = 0;
    _581 *= _573.d0;
    _581 += _381.d1;
    _581 *= _573.d1;
    _581 += _381.d1;
    _581 *= _573.d2;
    _581 += _580;
    int64_t _582 = _573.data[_581];
    if (_381.d1 >= 0)
    goto _jump654;
    fail_assertion("negative array index");
    _jump654:;
    if (_381.d1 < _558.d0)
    goto _jump655;
    fail_assertion("index too large");
    _jump655:;
    if (_572 >= 0)
    goto _jump656;
    fail_assertion("negative array index");
    _jump656:;
    if (_572 < _558.d1)
    goto _jump657;
    fail_assertion("index too large");
    _jump657:;
    if (_582 >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (_582 < _558.d2)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    int64_t _583 = 0;
    _583 *= _558.d0;
    _583 += _381.d1;
    _583 *= _558.d1;
    _583 += _572;
    _583 *= _558.d2;
    _583 += _582;
    _a3_int64_t _584 = _558.data[_583];
    _546 = _584;
    _jump635:;
    double _585 = 51.0;
    double _586 = -_585;
    double _587 = 55.0;
    double _588 = -_587;
    bool _589 = _586 >= _588;
    bool _590;
    if (!_589)
    goto _jump660;
    _590 = _380;
    goto _jump661;
    _jump660:;
    bool _591;
    if (!_380)
    goto _jump662;
    bool _592 = true;
    bool _593 = !_592;
    _591 = _593;
    goto _jump663;
    _jump662:;
    bool _594 = false;
    bool _595 = !_594;
    _591 = _595;
    _jump663:;
    _590 = _591;
    _jump661:;
    int64_t _596;
    if (!_590)
    goto _jump664;
    int64_t _597 = 191;
    int64_t _598 = _381.d2 % _597;
    int64_t _599 = 423;
    int64_t _600 = _598 + _599;
    int64_t _601 = _600 % _381.d0;
    _596 = _601;
    goto _jump665;
    _jump664:;
    _596 = _381.d1;
    _jump665:;
    _a3_int64_t _602;
    // Computing bound for h
    bool _604 = true;
    bool _603 = _604;
    if (0 != _604)
    goto _jump666;
    _603 = _380;
    _jump666:;
    int64_t _605;
    if (!_603)
    goto _jump667;
    int64_t _606;
    // Computing bound for h
    int64_t _607 = 640;
    if (_607 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    _606 = 0;
    int64_t _608 = 0; // h
    _jump669:; // Begin body of loop
    _606 += _381.d2;
    _608++;
    if (_608 < _607)
    goto _jump669;
    // End body of loop
    _605 = _606;
    goto _jump670;
    _jump667:;
    int64_t _609 = 203;
    _605 = _609;
    _jump670:;
    _602.d0 = _605;
    if (_605 > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    // Computing bound for i
    _602.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing bound for j
    int64_t _610;
    // Computing bound for h
    int64_t _611 = -_381.d0;
    if (_611 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    // Computing bound for i
    int64_t _612 = 469;
    int64_t _613 = _612 - _381.d1;
    if (_613 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing bound for j
    int64_t _614 = 998;
    if (_614 > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    _610 = 0;
    int64_t _615 = 0; // j
    int64_t _616 = 0; // i
    int64_t _617 = 0; // h
    _jump676:; // Begin body of loop
    int64_t _618;
    // Computing bound for k
    if (_381.d2 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    // Computing bound for l
    if (_381.d0 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing bound for m
    if (_617 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    _618 = 0;
    int64_t _619 = 0; // m
    int64_t _620 = 0; // l
    int64_t _621 = 0; // k
    _jump680:; // Begin body of loop
    _618 += _615;
    _619++;
    if (_619 < _617)
    goto _jump680;
    _619 = 0;
    _620++;
    if (_620 < _381.d0)
    goto _jump680;
    _620 = 0;
    _621++;
    if (_621 < _381.d2)
    goto _jump680;
    // End body of loop
    _610 += _618;
    _615++;
    if (_615 < _614)
    goto _jump676;
    _615 = 0;
    _616++;
    if (_616 < _613)
    goto _jump676;
    _616 = 0;
    _617++;
    if (_617 < _611)
    goto _jump676;
    // End body of loop
    _602.d2 = _610;
    if (_610 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    // Computing total size of heap memory to allocate
    int64_t _622 = 1;
    _622 *= _605;
    _622 *= _381.d2;
    _622 *= _610;
    _622 *= sizeof(int64_t);
    _602.data = jpl_alloc(_622);
    int64_t _623 = 0; // j
    int64_t _624 = 0; // i
    int64_t _625 = 0; // h
    _jump682:; // Begin body of loop
    int64_t _626;
    // Computing bound for k
    if (_381.d0 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing bound for l
    if (_623 > 0) 
    goto _jump684;
    fail_assertion("non-positive loop bound");
    _jump684:;
    // Computing bound for m
    if (_623 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    _626 = 0;
    int64_t _627 = 0; // m
    int64_t _628 = 0; // l
    int64_t _629 = 0; // k
    _jump686:; // Begin body of loop
    _626 += _627;
    _627++;
    if (_627 < _623)
    goto _jump686;
    _627 = 0;
    _628++;
    if (_628 < _623)
    goto _jump686;
    _628 = 0;
    _629++;
    if (_629 < _381.d0)
    goto _jump686;
    // End body of loop
    int64_t _630 = 0;
    _630 *= _602.d0;
    _630 += _625;
    _630 *= _602.d1;
    _630 += _624;
    _630 *= _602.d2;
    _630 += _623;
    _602.data[_630] = _626;
    _623++;
    if (_623 < _610)
    goto _jump682;
    _623 = 0;
    _624++;
    if (_624 < _381.d2)
    goto _jump682;
    _624 = 0;
    _625++;
    if (_625 < _605)
    goto _jump682;
    // End body of loop
    bool _631 = false;
    _a2_double _632;
    if (!_631)
    goto _jump687;
    _a2_double _633;
    // Computing bound for h
    int64_t _634 = 399;
    _633.d0 = _634;
    if (_634 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for i
    int64_t _635 = 112;
    _633.d1 = _635;
    if (_635 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing total size of heap memory to allocate
    int64_t _636 = 1;
    _636 *= _634;
    _636 *= _635;
    _636 *= sizeof(double);
    _633.data = jpl_alloc(_636);
    int64_t _637 = 0; // i
    int64_t _638 = 0; // h
    _jump690:; // Begin body of loop
    double _639 = 63.0;
    int64_t _640 = 0;
    _640 *= _633.d0;
    _640 += _638;
    _640 *= _633.d1;
    _640 += _637;
    _633.data[_640] = _639;
    _637++;
    if (_637 < _635)
    goto _jump690;
    _637 = 0;
    _638++;
    if (_638 < _634)
    goto _jump690;
    // End body of loop
    _632 = _633;
    goto _jump691;
    _jump687:;
    _a2_double _641;
    // Computing bound for h
    _641.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing bound for i
    _641.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    // Computing total size of heap memory to allocate
    int64_t _642 = 1;
    _642 *= _381.d0;
    _642 *= _381.d2;
    _642 *= sizeof(double);
    _641.data = jpl_alloc(_642);
    int64_t _643 = 0; // i
    int64_t _644 = 0; // h
    _jump694:; // Begin body of loop
    double _645 = 67.0;
    int64_t _646 = 0;
    _646 *= _641.d0;
    _646 += _644;
    _646 *= _641.d1;
    _646 += _643;
    _641.data[_646] = _645;
    _643++;
    if (_643 < _381.d2)
    goto _jump694;
    _643 = 0;
    _644++;
    if (_644 < _381.d0)
    goto _jump694;
    // End body of loop
    _632 = _641;
    _jump691:;
    int64_t _647 = b(_632);
    int64_t _648;
    // Computing bound for h
    int64_t _649 = 260;
    if (_649 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for i
    if (_381.d2 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for j
    int64_t _650;
    if (!_380)
    goto _jump697;
    _650 = _381.d0;
    goto _jump698;
    _jump697:;
    _650 = _381.d1;
    _jump698:;
    if (_650 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    _648 = 0;
    int64_t _651 = 0; // j
    int64_t _652 = 0; // i
    int64_t _653 = 0; // h
    _jump700:; // Begin body of loop
    _648 += _381.d0;
    _651++;
    if (_651 < _650)
    goto _jump700;
    _651 = 0;
    _652++;
    if (_652 < _381.d2)
    goto _jump700;
    _652 = 0;
    _653++;
    if (_653 < _649)
    goto _jump700;
    // End body of loop
    if (_381.d2 >= 0)
    goto _jump701;
    fail_assertion("negative array index");
    _jump701:;
    if (_381.d2 < _602.d0)
    goto _jump702;
    fail_assertion("index too large");
    _jump702:;
    if (_647 >= 0)
    goto _jump703;
    fail_assertion("negative array index");
    _jump703:;
    if (_647 < _602.d1)
    goto _jump704;
    fail_assertion("index too large");
    _jump704:;
    if (_648 >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (_648 < _602.d2)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    int64_t _654 = 0;
    _654 *= _602.d0;
    _654 += _381.d2;
    _654 *= _602.d1;
    _654 += _647;
    _654 *= _602.d2;
    _654 += _648;
    int64_t _655 = _602.data[_654];
    double _657 = 83.0;
    double _658 = 59.0;
    bool _659 = _657 > _658;
    bool _656 = _659;
    if (0 == _659)
    goto _jump707;
    bool _660 = _381.d2 >= _381.d2;
    _656 = _660;
    _jump707:;
    int64_t _661;
    if (!_656)
    goto _jump708;
    _661 = _381.d0;
    goto _jump709;
    _jump708:;
    _661 = _381.d0;
    _jump709:;
    int64_t _662 = _381.d0 - _661;
    if (_596 >= 0)
    goto _jump710;
    fail_assertion("negative array index");
    _jump710:;
    if (_596 < _546.d0)
    goto _jump711;
    fail_assertion("index too large");
    _jump711:;
    if (_655 >= 0)
    goto _jump712;
    fail_assertion("negative array index");
    _jump712:;
    if (_655 < _546.d1)
    goto _jump713;
    fail_assertion("index too large");
    _jump713:;
    if (_662 >= 0)
    goto _jump714;
    fail_assertion("negative array index");
    _jump714:;
    if (_662 < _546.d2)
    goto _jump715;
    fail_assertion("index too large");
    _jump715:;
    int64_t _663 = 0;
    _663 *= _546.d0;
    _663 += _596;
    _663 *= _546.d1;
    _663 += _655;
    _663 *= _546.d2;
    _663 += _662;
    int64_t _664 = _546.data[_663];
    if (_664 > 0) 
    goto _jump716;
    fail_assertion("non-positive loop bound");
    _jump716:;
    // Computing bound for j
    _a3_bool _665;
    // Computing bound for h
    _665.d0 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump717;
    fail_assertion("non-positive loop bound");
    _jump717:;
    // Computing bound for i
    _665.d1 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for j
    _665.d2 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing total size of heap memory to allocate
    int64_t _666 = 1;
    _666 *= _381.d1;
    _666 *= _381.d1;
    _666 *= _381.d1;
    _666 *= sizeof(bool);
    _665.data = jpl_alloc(_666);
    int64_t _667 = 0; // j
    int64_t _668 = 0; // i
    int64_t _669 = 0; // h
    _jump720:; // Begin body of loop
    int64_t _670 = 0;
    _670 *= _665.d0;
    _670 += _669;
    _670 *= _665.d1;
    _670 += _668;
    _670 *= _665.d2;
    _670 += _667;
    _665.data[_670] = _380;
    _667++;
    if (_667 < _381.d1)
    goto _jump720;
    _667 = 0;
    _668++;
    if (_668 < _381.d1)
    goto _jump720;
    _668 = 0;
    _669++;
    if (_669 < _381.d1)
    goto _jump720;
    // End body of loop
    int64_t _671 = 1000;
    int64_t _672 = -_381.d0;
    int64_t _673 = -_381.d0;
    if (_671 >= 0)
    goto _jump721;
    fail_assertion("negative array index");
    _jump721:;
    if (_671 < _665.d0)
    goto _jump722;
    fail_assertion("index too large");
    _jump722:;
    if (_672 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (_672 < _665.d1)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    if (_673 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_673 < _665.d2)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    int64_t _674 = 0;
    _674 *= _665.d0;
    _674 += _671;
    _674 *= _665.d1;
    _674 += _672;
    _674 *= _665.d2;
    _674 += _673;
    bool _675 = _665.data[_674];
    bool _676 = !_675;
    bool _677 = !_676;
    int64_t _678;
    if (!_677)
    goto _jump727;
    int64_t _679 = 335;
    _678 = _679;
    goto _jump728;
    _jump727:;
    int64_t _680 = 247;
    _678 = _680;
    _jump728:;
    if (_678 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    _543 = 0;
    int64_t _681 = 0; // j
    int64_t _682 = 0; // i
    int64_t _683 = 0; // h
    _jump730:; // Begin body of loop
    double _684 = 11.0;
    _543 += _684;
    _681++;
    if (_681 < _678)
    goto _jump730;
    _681 = 0;
    _682++;
    if (_682 < _664)
    goto _jump730;
    _682 = 0;
    _683++;
    if (_683 < _381.d2)
    goto _jump730;
    // End body of loop
    bool _686 = true;
    bool _687;
    if (!_686)
    goto _jump731;
    _687 = _380;
    goto _jump732;
    _jump731:;
    bool _688 = false;
    _687 = _688;
    _jump732:;
    _a2_bool _689;
    if (!_687)
    goto _jump733;
    _a2_bool _690;
    // Computing bound for h
    _690.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing bound for i
    _690.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing total size of heap memory to allocate
    int64_t _691 = 1;
    _691 *= _381.d0;
    _691 *= _381.d0;
    _691 *= sizeof(bool);
    _690.data = jpl_alloc(_691);
    int64_t _692 = 0; // i
    int64_t _693 = 0; // h
    _jump736:; // Begin body of loop
    bool _694;
    if (!_380)
    goto _jump737;
    _694 = _380;
    goto _jump738;
    _jump737:;
    _694 = _380;
    _jump738:;
    int64_t _695 = 0;
    _695 *= _690.d0;
    _695 += _693;
    _695 *= _690.d1;
    _695 += _692;
    _690.data[_695] = _694;
    _692++;
    if (_692 < _381.d0)
    goto _jump736;
    _692 = 0;
    _693++;
    if (_693 < _381.d0)
    goto _jump736;
    // End body of loop
    _689 = _690;
    goto _jump739;
    _jump733:;
    bool _696 = false;
    _a2_bool _697;
    if (!_696)
    goto _jump740;
    _a2_bool _698;
    // Computing bound for h
    int64_t _699 = 561;
    _698.d0 = _699;
    if (_699 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for i
    _698.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing total size of heap memory to allocate
    int64_t _700 = 1;
    _700 *= _699;
    _700 *= _381.d2;
    _700 *= sizeof(bool);
    _698.data = jpl_alloc(_700);
    int64_t _701 = 0; // i
    int64_t _702 = 0; // h
    _jump743:; // Begin body of loop
    int64_t _703 = 0;
    _703 *= _698.d0;
    _703 += _702;
    _703 *= _698.d1;
    _703 += _701;
    _698.data[_703] = _380;
    _701++;
    if (_701 < _381.d2)
    goto _jump743;
    _701 = 0;
    _702++;
    if (_702 < _699)
    goto _jump743;
    // End body of loop
    _697 = _698;
    goto _jump744;
    _jump740:;
    _a2_bool _704;
    // Computing bound for h
    _704.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing bound for i
    _704.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing total size of heap memory to allocate
    int64_t _705 = 1;
    _705 *= _381.d0;
    _705 *= _381.d0;
    _705 *= sizeof(bool);
    _704.data = jpl_alloc(_705);
    int64_t _706 = 0; // i
    int64_t _707 = 0; // h
    _jump747:; // Begin body of loop
    bool _708 = false;
    int64_t _709 = 0;
    _709 *= _704.d0;
    _709 += _707;
    _709 *= _704.d1;
    _709 += _706;
    _704.data[_709] = _708;
    _706++;
    if (_706 < _381.d0)
    goto _jump747;
    _706 = 0;
    _707++;
    if (_707 < _381.d0)
    goto _jump747;
    // End body of loop
    _697 = _704;
    _jump744:;
    _689 = _697;
    _jump739:;
    _a2_double _710;
    // Computing bound for h
    int64_t _711 = 269;
    _710.d0 = _711;
    if (_711 > 0) 
    goto _jump748;
    fail_assertion("non-positive loop bound");
    _jump748:;
    // Computing bound for i
    _710.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing total size of heap memory to allocate
    int64_t _712 = 1;
    _712 *= _711;
    _712 *= _381.d2;
    _712 *= sizeof(double);
    _710.data = jpl_alloc(_712);
    int64_t _713 = 0; // i
    int64_t _714 = 0; // h
    _jump750:; // Begin body of loop
    double _715 = 89.0;
    double _716 = -_715;
    int64_t _717 = 0;
    _717 *= _710.d0;
    _717 += _714;
    _717 *= _710.d1;
    _717 += _713;
    _710.data[_717] = _716;
    _713++;
    if (_713 < _381.d2)
    goto _jump750;
    _713 = 0;
    _714++;
    if (_714 < _711)
    goto _jump750;
    // End body of loop
    int64_t _718 = b(_710);
    if (_718 >= 0)
    goto _jump751;
    fail_assertion("negative array index");
    _jump751:;
    if (_718 < _689.d0)
    goto _jump752;
    fail_assertion("index too large");
    _jump752:;
    if (_381.d0 >= 0)
    goto _jump753;
    fail_assertion("negative array index");
    _jump753:;
    if (_381.d0 < _689.d1)
    goto _jump754;
    fail_assertion("index too large");
    _jump754:;
    int64_t _719 = 0;
    _719 *= _689.d0;
    _719 += _718;
    _719 *= _689.d1;
    _719 += _381.d0;
    bool _720 = _689.data[_719];
    bool _685 = _720;
    if (0 == _720)
    goto _jump755;
    bool _721 = false;
    int64_t _722;
    if (!_721)
    goto _jump756;
    int64_t _723 = 135;
    int64_t _724 = _723 / _381.d0;
    int64_t _725 = -_724;
    _722 = _725;
    goto _jump757;
    _jump756:;
    _722 = _381.d0;
    _jump757:;
    _a2_int64_t _726;
    // Computing bound for h
    int64_t _727 = _381.d0 - _381.d1;
    _726.d0 = _727;
    if (_727 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing bound for i
    int64_t _728 = -_381.d0;
    _726.d1 = _728;
    if (_728 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing total size of heap memory to allocate
    int64_t _729 = 1;
    _729 *= _727;
    _729 *= _728;
    _729 *= sizeof(int64_t);
    _726.data = jpl_alloc(_729);
    int64_t _730 = 0; // i
    int64_t _731 = 0; // h
    _jump760:; // Begin body of loop
    int64_t _732 = _381.d0 + _381.d0;
    int64_t _733 = 0;
    _733 *= _726.d0;
    _733 += _731;
    _733 *= _726.d1;
    _733 += _730;
    _726.data[_733] = _732;
    _730++;
    if (_730 < _728)
    goto _jump760;
    _730 = 0;
    _731++;
    if (_731 < _727)
    goto _jump760;
    // End body of loop
    int64_t _734 = 870;
    if (_734 >= 0)
    goto _jump761;
    fail_assertion("negative array index");
    _jump761:;
    if (_734 < _726.d0)
    goto _jump762;
    fail_assertion("index too large");
    _jump762:;
    if (_381.d0 >= 0)
    goto _jump763;
    fail_assertion("negative array index");
    _jump763:;
    if (_381.d0 < _726.d1)
    goto _jump764;
    fail_assertion("index too large");
    _jump764:;
    int64_t _735 = 0;
    _735 *= _726.d0;
    _735 += _734;
    _735 *= _726.d1;
    _735 += _381.d0;
    int64_t _736 = _726.data[_735];
    bool _737 = _722 <= _736;
    _685 = _737;
    _jump755:;
    double _738;
    if (!_685)
    goto _jump765;
    double _739;
    // Computing bound for h
    int64_t _740 = -_381.d2;
    if (_740 > 0) 
    goto _jump766;
    fail_assertion("non-positive loop bound");
    _jump766:;
    // Computing bound for i
    if (_381.d2 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for j
    int64_t _741 = _381.d0 * _381.d0;
    if (_741 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    _739 = 0;
    int64_t _742 = 0; // j
    int64_t _743 = 0; // i
    int64_t _744 = 0; // h
    _jump769:; // Begin body of loop
    double _745 = 65.0;
    _739 += _745;
    _742++;
    if (_742 < _741)
    goto _jump769;
    _742 = 0;
    _743++;
    if (_743 < _381.d2)
    goto _jump769;
    _743 = 0;
    _744++;
    if (_744 < _740)
    goto _jump769;
    // End body of loop
    double _746 = 33.0;
    double _747 = -_746;
    double _748 = -_747;
    double _749 = -_748;
    double _750 = 59.0;
    double _751;
    // Computing bound for h
    if (_381.d1 > 0) 
    goto _jump770;
    fail_assertion("non-positive loop bound");
    _jump770:;
    // Computing bound for i
    if (_381.d0 > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    // Computing bound for j
    int64_t _752 = 824;
    if (_752 > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    _751 = 0;
    int64_t _753 = 0; // j
    int64_t _754 = 0; // i
    int64_t _755 = 0; // h
    _jump773:; // Begin body of loop
    double _756;
    // Computing bound for k
    if (_381.d2 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    // Computing bound for l
    if (_754 > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    // Computing bound for m
    if (_753 > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    _756 = 0;
    int64_t _757 = 0; // m
    int64_t _758 = 0; // l
    int64_t _759 = 0; // k
    _jump777:; // Begin body of loop
    double _760 = 81.0;
    _756 += _760;
    _757++;
    if (_757 < _753)
    goto _jump777;
    _757 = 0;
    _758++;
    if (_758 < _754)
    goto _jump777;
    _758 = 0;
    _759++;
    if (_759 < _381.d2)
    goto _jump777;
    // End body of loop
    _751 += _756;
    _753++;
    if (_753 < _752)
    goto _jump773;
    _753 = 0;
    _754++;
    if (_754 < _381.d0)
    goto _jump773;
    _754 = 0;
    _755++;
    if (_755 < _381.d1)
    goto _jump773;
    // End body of loop
    double _761 = _750 - _751;
    double _762 = 7.0;
    double _763 = -_762;
    rgba _764 = { _739, _749, _761, _763 };
    double _765 = _764.r;
    _738 = _765;
    goto _jump778;
    _jump765:;
    _a2_double _766;
    // Computing bound for h
    _766.d0 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing bound for i
    _766.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing total size of heap memory to allocate
    int64_t _767 = 1;
    _767 *= _381.d1;
    _767 *= _381.d2;
    _767 *= sizeof(double);
    _766.data = jpl_alloc(_767);
    int64_t _768 = 0; // i
    int64_t _769 = 0; // h
    _jump781:; // Begin body of loop
    double _770 = 93.0;
    double _771 = -_770;
    int64_t _772 = 0;
    _772 *= _766.d0;
    _772 += _769;
    _772 *= _766.d1;
    _772 += _768;
    _766.data[_772] = _771;
    _768++;
    if (_768 < _381.d2)
    goto _jump781;
    _768 = 0;
    _769++;
    if (_769 < _381.d1)
    goto _jump781;
    // End body of loop
    _a2_double _773;
    // Computing bound for h
    _773.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing bound for i
    _773.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing total size of heap memory to allocate
    int64_t _774 = 1;
    _774 *= _381.d0;
    _774 *= _381.d0;
    _774 *= sizeof(double);
    _773.data = jpl_alloc(_774);
    int64_t _775 = 0; // i
    int64_t _776 = 0; // h
    _jump784:; // Begin body of loop
    double _777 = 50.0;
    int64_t _778 = 0;
    _778 *= _773.d0;
    _778 += _776;
    _778 *= _773.d1;
    _778 += _775;
    _773.data[_778] = _777;
    _775++;
    if (_775 < _381.d0)
    goto _jump784;
    _775 = 0;
    _776++;
    if (_776 < _381.d0)
    goto _jump784;
    // End body of loop
    _a1__a2_double _779;
    _779.d0 = 1;
    _779.data = jpl_alloc(sizeof(_a2_double) * 1);
    _779.data[0] = _773;
    int64_t _780;
    // Computing bound for h
    if (_381.d0 > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    _780 = 0;
    int64_t _781 = 0; // h
    _jump786:; // Begin body of loop
    int64_t _782 = 624;
    int64_t _783 = -_782;
    _780 += _783;
    _781++;
    if (_781 < _381.d0)
    goto _jump786;
    // End body of loop
    if (_780 >= 0)
    goto _jump787;
    fail_assertion("negative array index");
    _jump787:;
    if (_780 < _779.d0)
    goto _jump788;
    fail_assertion("index too large");
    _jump788:;
    int64_t _784 = 0;
    _784 *= _779.d0;
    _784 += _780;
    _a2_double _785 = _779.data[_784];
    int64_t _786 = b(_785);
    if (_381.d1 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_381.d1 < _766.d0)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    if (_786 >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (_786 < _766.d1)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    int64_t _787 = 0;
    _787 *= _766.d0;
    _787 += _381.d1;
    _787 *= _766.d1;
    _787 += _786;
    double _788 = _766.data[_787];
    _738 = _788;
    _jump778:;
    bool _789 = _543 == _738;
    double _790 = get_time();
    print("i");
    double _791 = get_time();
    print_time(_791 - _790);
    bool _793 = false;
    bool _792 = _793;
    if (0 != _793)
    goto _jump793;
    _a2_bool _794;
    // Computing bound for i
    _794.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    // Computing bound for j
    int64_t _795 = 249;
    int64_t _796 = _795 / _381.d0;
    _794.d1 = _796;
    if (_796 > 0) 
    goto _jump795;
    fail_assertion("non-positive loop bound");
    _jump795:;
    // Computing total size of heap memory to allocate
    int64_t _797 = 1;
    _797 *= _381.d0;
    _797 *= _796;
    _797 *= sizeof(bool);
    _794.data = jpl_alloc(_797);
    int64_t _798 = 0; // j
    int64_t _799 = 0; // i
    _jump796:; // Begin body of loop
    int64_t _800 = 0;
    _800 *= _794.d0;
    _800 += _799;
    _800 *= _794.d1;
    _800 += _798;
    _794.data[_800] = _789;
    _798++;
    if (_798 < _796)
    goto _jump796;
    _798 = 0;
    _799++;
    if (_799 < _381.d0)
    goto _jump796;
    // End body of loop
    if (_381.d2 >= 0)
    goto _jump797;
    fail_assertion("negative array index");
    _jump797:;
    if (_381.d2 < _794.d0)
    goto _jump798;
    fail_assertion("index too large");
    _jump798:;
    if (_381.d0 >= 0)
    goto _jump799;
    fail_assertion("negative array index");
    _jump799:;
    if (_381.d0 < _794.d1)
    goto _jump800;
    fail_assertion("index too large");
    _jump800:;
    int64_t _801 = 0;
    _801 *= _794.d0;
    _801 += _381.d2;
    _801 *= _794.d1;
    _801 += _381.d0;
    bool _802 = _794.data[_801];
    _a2_bool _803;
    if (!_802)
    goto _jump801;
    bool _806 = _380;
    if (0 != _380)
    goto _jump802;
    _806 = _380;
    _jump802:;
    bool _805 = _806;
    if (0 != _806)
    goto _jump803;
    bool _807 = true;
    _805 = _807;
    _jump803:;
    bool _804 = _805;
    if (0 != _805)
    goto _jump804;
    bool _808 = !_789;
    _804 = _808;
    _jump804:;
    _a2_bool _809;
    if (!_804)
    goto _jump805;
    bool _810;
    if (!_380)
    goto _jump806;
    _810 = _789;
    goto _jump807;
    _jump806:;
    bool _811 = _789;
    if (0 == _789)
    goto _jump808;
    _811 = _380;
    _jump808:;
    _810 = _811;
    _jump807:;
    _a2_bool _812;
    if (!_810)
    goto _jump809;
    _a2_bool _813;
    // Computing bound for i
    _813.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    // Computing bound for j
    int64_t _814 = _381.d2 + _381.d2;
    _813.d1 = _814;
    if (_814 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    // Computing total size of heap memory to allocate
    int64_t _815 = 1;
    _815 *= _381.d2;
    _815 *= _814;
    _815 *= sizeof(bool);
    _813.data = jpl_alloc(_815);
    int64_t _816 = 0; // j
    int64_t _817 = 0; // i
    _jump812:; // Begin body of loop
    int64_t _818 = 0;
    _818 *= _813.d0;
    _818 += _817;
    _818 *= _813.d1;
    _818 += _816;
    _813.data[_818] = _789;
    _816++;
    if (_816 < _814)
    goto _jump812;
    _816 = 0;
    _817++;
    if (_817 < _381.d2)
    goto _jump812;
    // End body of loop
    _812 = _813;
    goto _jump813;
    _jump809:;
    _a2_bool _819;
    // Computing bound for i
    int64_t _820 = 468;
    _819.d0 = _820;
    if (_820 > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    // Computing bound for j
    _819.d1 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump815;
    fail_assertion("non-positive loop bound");
    _jump815:;
    // Computing total size of heap memory to allocate
    int64_t _821 = 1;
    _821 *= _820;
    _821 *= _381.d1;
    _821 *= sizeof(bool);
    _819.data = jpl_alloc(_821);
    int64_t _822 = 0; // j
    int64_t _823 = 0; // i
    _jump816:; // Begin body of loop
    bool _824 = true;
    bool _825;
    if (!_824)
    goto _jump817;
    _825 = _789;
    goto _jump818;
    _jump817:;
    _825 = _789;
    _jump818:;
    int64_t _826 = 0;
    _826 *= _819.d0;
    _826 += _823;
    _826 *= _819.d1;
    _826 += _822;
    _819.data[_826] = _825;
    _822++;
    if (_822 < _381.d1)
    goto _jump816;
    _822 = 0;
    _823++;
    if (_823 < _820)
    goto _jump816;
    // End body of loop
    _812 = _819;
    _jump813:;
    _809 = _812;
    goto _jump819;
    _jump805:;
    bool _827;
    if (!_789)
    goto _jump820;
    _827 = _789;
    goto _jump821;
    _jump820:;
    bool _828 = false;
    _827 = _828;
    _jump821:;
    bool _829 = !_827;
    _a2_bool _830;
    if (!_829)
    goto _jump822;
    _a2_bool _831;
    // Computing bound for i
    int64_t _832;
    // Computing bound for i
    if (_381.d1 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing bound for j
    if (_381.d2 > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    _832 = 0;
    int64_t _833 = 0; // j
    int64_t _834 = 0; // i
    _jump825:; // Begin body of loop
    _832 += _381.d2;
    _833++;
    if (_833 < _381.d2)
    goto _jump825;
    _833 = 0;
    _834++;
    if (_834 < _381.d1)
    goto _jump825;
    // End body of loop
    _831.d0 = _832;
    if (_832 > 0) 
    goto _jump826;
    fail_assertion("non-positive loop bound");
    _jump826:;
    // Computing bound for j
    int64_t _835;
    if (!_789)
    goto _jump827;
    _835 = _381.d0;
    goto _jump828;
    _jump827:;
    _835 = _381.d0;
    _jump828:;
    _831.d1 = _835;
    if (_835 > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    // Computing total size of heap memory to allocate
    int64_t _836 = 1;
    _836 *= _832;
    _836 *= _835;
    _836 *= sizeof(bool);
    _831.data = jpl_alloc(_836);
    int64_t _837 = 0; // j
    int64_t _838 = 0; // i
    _jump830:; // Begin body of loop
    int64_t _839 = 0;
    _839 *= _831.d0;
    _839 += _838;
    _839 *= _831.d1;
    _839 += _837;
    _831.data[_839] = _380;
    _837++;
    if (_837 < _835)
    goto _jump830;
    _837 = 0;
    _838++;
    if (_838 < _832)
    goto _jump830;
    // End body of loop
    _830 = _831;
    goto _jump831;
    _jump822:;
    _a2_bool _840;
    // Computing bound for i
    bool _841 = false;
    int64_t _842;
    if (!_841)
    goto _jump832;
    _842 = _381.d2;
    goto _jump833;
    _jump832:;
    _842 = _381.d0;
    _jump833:;
    _840.d0 = _842;
    if (_842 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing bound for j
    int64_t _843 = 418;
    _840.d1 = _843;
    if (_843 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing total size of heap memory to allocate
    int64_t _844 = 1;
    _844 *= _842;
    _844 *= _843;
    _844 *= sizeof(bool);
    _840.data = jpl_alloc(_844);
    int64_t _845 = 0; // j
    int64_t _846 = 0; // i
    _jump836:; // Begin body of loop
    bool _847 = _789;
    if (0 == _789)
    goto _jump837;
    _847 = _380;
    _jump837:;
    int64_t _848 = 0;
    _848 *= _840.d0;
    _848 += _846;
    _848 *= _840.d1;
    _848 += _845;
    _840.data[_848] = _847;
    _845++;
    if (_845 < _843)
    goto _jump836;
    _845 = 0;
    _846++;
    if (_846 < _842)
    goto _jump836;
    // End body of loop
    _830 = _840;
    _jump831:;
    _809 = _830;
    _jump819:;
    _803 = _809;
    goto _jump838;
    _jump801:;
    int64_t _849;
    // Computing bound for i
    if (_381.d1 > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    // Computing bound for j
    int64_t _850 = _381.d0 + _381.d0;
    if (_850 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for k
    int64_t _851;
    // Computing bound for i
    int64_t _852 = 835;
    if (_852 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing bound for j
    int64_t _853 = 42;
    if (_853 > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing bound for k
    if (_381.d2 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    _851 = 0;
    int64_t _854 = 0; // k
    int64_t _855 = 0; // j
    int64_t _856 = 0; // i
    _jump844:; // Begin body of loop
    _851 += _381.d2;
    _854++;
    if (_854 < _381.d2)
    goto _jump844;
    _854 = 0;
    _855++;
    if (_855 < _853)
    goto _jump844;
    _855 = 0;
    _856++;
    if (_856 < _852)
    goto _jump844;
    // End body of loop
    if (_851 > 0) 
    goto _jump845;
    fail_assertion("non-positive loop bound");
    _jump845:;
    _849 = 0;
    int64_t _857 = 0; // k
    int64_t _858 = 0; // j
    int64_t _859 = 0; // i
    _jump846:; // Begin body of loop
    _849 += _381.d0;
    _857++;
    if (_857 < _851)
    goto _jump846;
    _857 = 0;
    _858++;
    if (_858 < _850)
    goto _jump846;
    _858 = 0;
    _859++;
    if (_859 < _381.d1)
    goto _jump846;
    // End body of loop
    bool _860 = _849 < _381.d1;
    _a2_bool _861;
    if (!_860)
    goto _jump847;
    _a2_bool _862;
    // Computing bound for i
    int64_t _863;
    // Computing bound for i
    int64_t _864;
    if (!_789)
    goto _jump848;
    _864 = _381.d2;
    goto _jump849;
    _jump848:;
    _864 = _381.d1;
    _jump849:;
    if (_864 > 0) 
    goto _jump850;
    fail_assertion("non-positive loop bound");
    _jump850:;
    _863 = 0;
    int64_t _865 = 0; // i
    _jump851:; // Begin body of loop
    _863 += _381.d0;
    _865++;
    if (_865 < _864)
    goto _jump851;
    // End body of loop
    _862.d0 = _863;
    if (_863 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for j
    int64_t _866;
    if (!_789)
    goto _jump853;
    int64_t _867 = -_381.d0;
    _866 = _867;
    goto _jump854;
    _jump853:;
    _866 = _381.d0;
    _jump854:;
    _862.d1 = _866;
    if (_866 > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    // Computing total size of heap memory to allocate
    int64_t _868 = 1;
    _868 *= _863;
    _868 *= _866;
    _868 *= sizeof(bool);
    _862.data = jpl_alloc(_868);
    int64_t _869 = 0; // j
    int64_t _870 = 0; // i
    _jump856:; // Begin body of loop
    bool _871 = _381.d0 > _381.d0;
    int64_t _872 = 0;
    _872 *= _862.d0;
    _872 += _870;
    _872 *= _862.d1;
    _872 += _869;
    _862.data[_872] = _871;
    _869++;
    if (_869 < _866)
    goto _jump856;
    _869 = 0;
    _870++;
    if (_870 < _863)
    goto _jump856;
    // End body of loop
    _861 = _862;
    goto _jump857;
    _jump847:;
    bool _873;
    if (!_789)
    goto _jump858;
    if (_381.d1 >= 0)
    goto _jump859;
    fail_assertion("negative array index");
    _jump859:;
    if (_381.d1 < _381.d0)
    goto _jump860;
    fail_assertion("index too large");
    _jump860:;
    if (_381.d0 >= 0)
    goto _jump861;
    fail_assertion("negative array index");
    _jump861:;
    if (_381.d0 < _381.d1)
    goto _jump862;
    fail_assertion("index too large");
    _jump862:;
    if (_381.d2 >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (_381.d2 < _381.d2)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    int64_t _874 = 0;
    _874 *= _381.d0;
    _874 += _381.d1;
    _874 *= _381.d1;
    _874 += _381.d0;
    _874 *= _381.d2;
    _874 += _381.d2;
    bool _875 = _381.data[_874];
    _873 = _875;
    goto _jump865;
    _jump858:;
    bool _876 = true;
    _873 = _876;
    _jump865:;
    _a2_bool _877;
    if (!_873)
    goto _jump866;
    bool _878 = _789;
    if (0 == _789)
    goto _jump867;
    bool _879 = false;
    _878 = _879;
    _jump867:;
    _a2_bool _880;
    if (!_878)
    goto _jump868;
    _a2_bool _881;
    // Computing bound for i
    _881.d0 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing bound for j
    _881.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    // Computing total size of heap memory to allocate
    int64_t _882 = 1;
    _882 *= _381.d1;
    _882 *= _381.d0;
    _882 *= sizeof(bool);
    _881.data = jpl_alloc(_882);
    int64_t _883 = 0; // j
    int64_t _884 = 0; // i
    _jump871:; // Begin body of loop
    bool _885 = false;
    int64_t _886 = 0;
    _886 *= _881.d0;
    _886 += _884;
    _886 *= _881.d1;
    _886 += _883;
    _881.data[_886] = _885;
    _883++;
    if (_883 < _381.d0)
    goto _jump871;
    _883 = 0;
    _884++;
    if (_884 < _381.d1)
    goto _jump871;
    // End body of loop
    _880 = _881;
    goto _jump872;
    _jump868:;
    _a2_bool _887;
    // Computing bound for i
    _887.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    // Computing bound for j
    int64_t _888 = 512;
    _887.d1 = _888;
    if (_888 > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing total size of heap memory to allocate
    int64_t _889 = 1;
    _889 *= _381.d2;
    _889 *= _888;
    _889 *= sizeof(bool);
    _887.data = jpl_alloc(_889);
    int64_t _890 = 0; // j
    int64_t _891 = 0; // i
    _jump875:; // Begin body of loop
    int64_t _892 = 0;
    _892 *= _887.d0;
    _892 += _891;
    _892 *= _887.d1;
    _892 += _890;
    _887.data[_892] = _380;
    _890++;
    if (_890 < _888)
    goto _jump875;
    _890 = 0;
    _891++;
    if (_891 < _381.d2)
    goto _jump875;
    // End body of loop
    _880 = _887;
    _jump872:;
    _877 = _880;
    goto _jump876;
    _jump866:;
    _a2_bool _893;
    // Computing bound for i
    int64_t _894;
    if (!_789)
    goto _jump877;
    _894 = _381.d1;
    goto _jump878;
    _jump877:;
    _894 = _381.d2;
    _jump878:;
    _893.d0 = _894;
    if (_894 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing bound for j
    int64_t _895 = _381.d0 - _381.d1;
    _893.d1 = _895;
    if (_895 > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    // Computing total size of heap memory to allocate
    int64_t _896 = 1;
    _896 *= _894;
    _896 *= _895;
    _896 *= sizeof(bool);
    _893.data = jpl_alloc(_896);
    int64_t _897 = 0; // j
    int64_t _898 = 0; // i
    _jump881:; // Begin body of loop
    bool _899 = _789;
    if (0 == _789)
    goto _jump882;
    _899 = _789;
    _jump882:;
    int64_t _900 = 0;
    _900 *= _893.d0;
    _900 += _898;
    _900 *= _893.d1;
    _900 += _897;
    _893.data[_900] = _899;
    _897++;
    if (_897 < _895)
    goto _jump881;
    _897 = 0;
    _898++;
    if (_898 < _894)
    goto _jump881;
    // End body of loop
    _877 = _893;
    _jump876:;
    _861 = _877;
    _jump857:;
    _803 = _861;
    _jump838:;
    if (_381.d2 >= 0)
    goto _jump883;
    fail_assertion("negative array index");
    _jump883:;
    if (_381.d2 < _803.d0)
    goto _jump884;
    fail_assertion("index too large");
    _jump884:;
    if (_381.d2 >= 0)
    goto _jump885;
    fail_assertion("negative array index");
    _jump885:;
    if (_381.d2 < _803.d1)
    goto _jump886;
    fail_assertion("index too large");
    _jump886:;
    int64_t _901 = 0;
    _901 *= _803.d0;
    _901 += _381.d2;
    _901 *= _803.d1;
    _901 += _381.d2;
    bool _902 = _803.data[_901];
    _792 = _902;
    _jump793:;
    if (0 != _792)
    goto _jump887;
    fail_assertion("i");
    _jump887:;
    show("(BoolType)", &_380);
    _a3_bool _903;
    // Computing bound for n
    _a1__a3_int64_t _904;
    // Computing bound for n
    _904.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump1928;
    fail_assertion("non-positive loop bound");
    _jump1928:;
    // Computing total size of heap memory to allocate
    int64_t _905 = 1;
    _905 *= _381.d0;
    _905 *= sizeof(_a3_int64_t);
    _904.data = jpl_alloc(_905);
    int64_t _906 = 0; // n
    _jump1929:; // Begin body of loop
    _a3_int64_t _907;
    // Computing bound for o
    _a2_double _908;
    // Computing bound for o
    _908.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump1930;
    fail_assertion("non-positive loop bound");
    _jump1930:;
    // Computing bound for p
    _908.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump1931;
    fail_assertion("non-positive loop bound");
    _jump1931:;
    // Computing total size of heap memory to allocate
    int64_t _909 = 1;
    _909 *= _381.d2;
    _909 *= _381.d2;
    _909 *= sizeof(double);
    _908.data = jpl_alloc(_909);
    int64_t _910 = 0; // p
    int64_t _911 = 0; // o
    _jump1932:; // Begin body of loop
    double _912 = 18.0;
    int64_t _913 = 0;
    _913 *= _908.d0;
    _913 += _911;
    _913 *= _908.d1;
    _913 += _910;
    _908.data[_913] = _912;
    _910++;
    if (_910 < _381.d2)
    goto _jump1932;
    _910 = 0;
    _911++;
    if (_911 < _381.d2)
    goto _jump1932;
    // End body of loop
    int64_t _914 = b(_908);
    _907.d0 = _914;
    if (_914 > 0) 
    goto _jump1933;
    fail_assertion("non-positive loop bound");
    _jump1933:;
    // Computing bound for p
    _907.d1 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump1934;
    fail_assertion("non-positive loop bound");
    _jump1934:;
    // Computing bound for q
    int64_t _915 = 10;
    int64_t _916 = -_915;
    _907.d2 = _916;
    if (_916 > 0) 
    goto _jump1935;
    fail_assertion("non-positive loop bound");
    _jump1935:;
    // Computing total size of heap memory to allocate
    int64_t _917 = 1;
    _917 *= _914;
    _917 *= _381.d1;
    _917 *= _916;
    _917 *= sizeof(int64_t);
    _907.data = jpl_alloc(_917);
    int64_t _918 = 0; // q
    int64_t _919 = 0; // p
    int64_t _920 = 0; // o
    _jump1936:; // Begin body of loop
    int64_t _921 = 0;
    _921 *= _907.d0;
    _921 += _920;
    _921 *= _907.d1;
    _921 += _919;
    _921 *= _907.d2;
    _921 += _918;
    _907.data[_921] = _381.d0;
    _918++;
    if (_918 < _916)
    goto _jump1936;
    _918 = 0;
    _919++;
    if (_919 < _381.d1)
    goto _jump1936;
    _919 = 0;
    _920++;
    if (_920 < _914)
    goto _jump1936;
    // End body of loop
    int64_t _922 = 0;
    _922 *= _904.d0;
    _922 += _906;
    _904.data[_922] = _907;
    _906++;
    if (_906 < _381.d0)
    goto _jump1929;
    // End body of loop
    bool _923 = _381.d0 != _381.d0;
    bool _924 = !_923;
    _a2_double _925;
    if (!_924)
    goto _jump1937;
    _a2_double _926;
    // Computing bound for n
    int64_t _927 = _381.d2 * _381.d0;
    _926.d0 = _927;
    if (_927 > 0) 
    goto _jump1938;
    fail_assertion("non-positive loop bound");
    _jump1938:;
    // Computing bound for o
    _926.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump1939;
    fail_assertion("non-positive loop bound");
    _jump1939:;
    // Computing total size of heap memory to allocate
    int64_t _928 = 1;
    _928 *= _927;
    _928 *= _381.d2;
    _928 *= sizeof(double);
    _926.data = jpl_alloc(_928);
    int64_t _929 = 0; // o
    int64_t _930 = 0; // n
    _jump1940:; // Begin body of loop
    double _931 = 43.0;
    double _932 = -_931;
    int64_t _933 = 0;
    _933 *= _926.d0;
    _933 += _930;
    _933 *= _926.d1;
    _933 += _929;
    _926.data[_933] = _932;
    _929++;
    if (_929 < _381.d2)
    goto _jump1940;
    _929 = 0;
    _930++;
    if (_930 < _927)
    goto _jump1940;
    // End body of loop
    _925 = _926;
    goto _jump1941;
    _jump1937:;
    _a2_double _934;
    // Computing bound for n
    _934.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump1942;
    fail_assertion("non-positive loop bound");
    _jump1942:;
    // Computing bound for o
    _934.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump1943;
    fail_assertion("non-positive loop bound");
    _jump1943:;
    // Computing total size of heap memory to allocate
    int64_t _935 = 1;
    _935 *= _381.d2;
    _935 *= _381.d0;
    _935 *= sizeof(double);
    _934.data = jpl_alloc(_935);
    int64_t _936 = 0; // o
    int64_t _937 = 0; // n
    _jump1944:; // Begin body of loop
    double _938 = 55.0;
    int64_t _939 = 0;
    _939 *= _934.d0;
    _939 += _937;
    _939 *= _934.d1;
    _939 += _936;
    _934.data[_939] = _938;
    _936++;
    if (_936 < _381.d0)
    goto _jump1944;
    _936 = 0;
    _937++;
    if (_937 < _381.d2)
    goto _jump1944;
    // End body of loop
    _925 = _934;
    _jump1941:;
    int64_t _940 = b(_925);
    if (_940 >= 0)
    goto _jump1945;
    fail_assertion("negative array index");
    _jump1945:;
    if (_940 < _904.d0)
    goto _jump1946;
    fail_assertion("index too large");
    _jump1946:;
    int64_t _941 = 0;
    _941 *= _904.d0;
    _941 += _940;
    _a3_int64_t _942 = _904.data[_941];
    int64_t _943 = -_381.d0;
    int64_t _944;
    // Computing bound for n
    if (_381.d1 > 0) 
    goto _jump1947;
    fail_assertion("non-positive loop bound");
    _jump1947:;
    // Computing bound for o
    int64_t _945 = 788;
    if (_945 > 0) 
    goto _jump1948;
    fail_assertion("non-positive loop bound");
    _jump1948:;
    // Computing bound for p
    if (_381.d0 > 0) 
    goto _jump1949;
    fail_assertion("non-positive loop bound");
    _jump1949:;
    _944 = 0;
    int64_t _946 = 0; // p
    int64_t _947 = 0; // o
    int64_t _948 = 0; // n
    _jump1950:; // Begin body of loop
    _a2_double _949;
    // Computing bound for q
    _949.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump1951;
    fail_assertion("non-positive loop bound");
    _jump1951:;
    // Computing bound for r
    int64_t _950 = 634;
    int64_t _951 = _950 - _381.d0;
    int64_t _952 = -_951;
    _949.d1 = _952;
    if (_952 > 0) 
    goto _jump1952;
    fail_assertion("non-positive loop bound");
    _jump1952:;
    // Computing total size of heap memory to allocate
    int64_t _953 = 1;
    _953 *= _381.d2;
    _953 *= _952;
    _953 *= sizeof(double);
    _949.data = jpl_alloc(_953);
    int64_t _954 = 0; // r
    int64_t _955 = 0; // q
    _jump1953:; // Begin body of loop
    double _956 = 64.0;
    int64_t _957 = 0;
    _957 *= _949.d0;
    _957 += _955;
    _957 *= _949.d1;
    _957 += _954;
    _949.data[_957] = _956;
    _954++;
    if (_954 < _952)
    goto _jump1953;
    _954 = 0;
    _955++;
    if (_955 < _381.d2)
    goto _jump1953;
    // End body of loop
    int64_t _958 = b(_949);
    _944 += _958;
    _946++;
    if (_946 < _381.d0)
    goto _jump1950;
    _946 = 0;
    _947++;
    if (_947 < _945)
    goto _jump1950;
    _947 = 0;
    _948++;
    if (_948 < _381.d1)
    goto _jump1950;
    // End body of loop
    if (_943 >= 0)
    goto _jump1954;
    fail_assertion("negative array index");
    _jump1954:;
    if (_943 < _942.d0)
    goto _jump1955;
    fail_assertion("index too large");
    _jump1955:;
    if (_944 >= 0)
    goto _jump1956;
    fail_assertion("negative array index");
    _jump1956:;
    if (_944 < _942.d1)
    goto _jump1957;
    fail_assertion("index too large");
    _jump1957:;
    if (_381.d2 >= 0)
    goto _jump1958;
    fail_assertion("negative array index");
    _jump1958:;
    if (_381.d2 < _942.d2)
    goto _jump1959;
    fail_assertion("index too large");
    _jump1959:;
    int64_t _959 = 0;
    _959 *= _942.d0;
    _959 += _943;
    _959 *= _942.d1;
    _959 += _944;
    _959 *= _942.d2;
    _959 += _381.d2;
    int64_t _960 = _942.data[_959];
    _903.d0 = _960;
    if (_960 > 0) 
    goto _jump1960;
    fail_assertion("non-positive loop bound");
    _jump1960:;
    // Computing bound for o
    _903.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump1961;
    fail_assertion("non-positive loop bound");
    _jump1961:;
    // Computing bound for p
    _903.d2 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump1962;
    fail_assertion("non-positive loop bound");
    _jump1962:;
    // Computing total size of heap memory to allocate
    int64_t _961 = 1;
    _961 *= _960;
    _961 *= _381.d0;
    _961 *= _381.d0;
    _961 *= sizeof(bool);
    _903.data = jpl_alloc(_961);
    int64_t _962 = 0; // p
    int64_t _963 = 0; // o
    int64_t _964 = 0; // n
    _jump1963:; // Begin body of loop
    _a2_double _965;
    // Computing bound for q
    bool _967 = true;
    bool _966 = _967;
    if (0 == _967)
    goto _jump1964;
    bool _968 = false;
    _966 = _968;
    _jump1964:;
    int64_t _969;
    if (!_966)
    goto _jump1965;
    int64_t _970;
    // Computing bound for q
    if (_381.d2 > 0) 
    goto _jump1966;
    fail_assertion("non-positive loop bound");
    _jump1966:;
    // Computing bound for r
    if (_381.d2 > 0) 
    goto _jump1967;
    fail_assertion("non-positive loop bound");
    _jump1967:;
    _970 = 0;
    int64_t _971 = 0; // r
    int64_t _972 = 0; // q
    _jump1968:; // Begin body of loop
    _970 += _962;
    _971++;
    if (_971 < _381.d2)
    goto _jump1968;
    _971 = 0;
    _972++;
    if (_972 < _381.d2)
    goto _jump1968;
    // End body of loop
    _969 = _970;
    goto _jump1969;
    _jump1965:;
    int64_t _973 = -_381.d1;
    _969 = _973;
    _jump1969:;
    int64_t _974 = -_969;
    _965.d0 = _974;
    if (_974 > 0) 
    goto _jump1970;
    fail_assertion("non-positive loop bound");
    _jump1970:;
    // Computing bound for r
    _965.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump1971;
    fail_assertion("non-positive loop bound");
    _jump1971:;
    // Computing total size of heap memory to allocate
    int64_t _975 = 1;
    _975 *= _974;
    _975 *= _381.d2;
    _975 *= sizeof(double);
    _965.data = jpl_alloc(_975);
    int64_t _976 = 0; // r
    int64_t _977 = 0; // q
    _jump1972:; // Begin body of loop
    double _978 = 83.0;
    int64_t _979 = 0;
    _979 *= _965.d0;
    _979 += _977;
    _979 *= _965.d1;
    _979 += _976;
    _965.data[_979] = _978;
    _976++;
    if (_976 < _381.d2)
    goto _jump1972;
    _976 = 0;
    _977++;
    if (_977 < _974)
    goto _jump1972;
    // End body of loop
    int64_t _980 = b(_965);
    bool _981 = _980 > _381.d0;
    int64_t _982 = 0;
    _982 *= _903.d0;
    _982 += _964;
    _982 *= _903.d1;
    _982 += _963;
    _982 *= _903.d2;
    _982 += _962;
    _903.data[_982] = _981;
    _962++;
    if (_962 < _381.d0)
    goto _jump1963;
    _962 = 0;
    _963++;
    if (_963 < _381.d0)
    goto _jump1963;
    _963 = 0;
    _964++;
    if (_964 < _960)
    goto _jump1963;
    // End body of loop
    bool _983 = !_789;
    bool _984;
    if (!_983)
    goto _jump2033;
    bool _985 = false;
    _984 = _985;
    goto _jump2034;
    _jump2033:;
    bool _986 = !_380;
    _984 = _986;
    _jump2034:;
    _a3__a2_bool _987;
    if (!_984)
    goto _jump2035;
    _a3__a2_bool _988;
    if (!_380)
    goto _jump2036;
    _a2__a3__a2_bool _989;
    // Computing bound for p
    _989.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump2037;
    fail_assertion("non-positive loop bound");
    _jump2037:;
    // Computing bound for q
    _989.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump2038;
    fail_assertion("non-positive loop bound");
    _jump2038:;
    // Computing total size of heap memory to allocate
    int64_t _990 = 1;
    _990 *= _381.d0;
    _990 *= _381.d0;
    _990 *= sizeof(_a3__a2_bool);
    _989.data = jpl_alloc(_990);
    int64_t _991 = 0; // q
    int64_t _992 = 0; // p
    _jump2039:; // Begin body of loop
    _a3__a2_bool _993;
    // Computing bound for r
    int64_t _994;
    // Computing bound for r
    int64_t _995 = o();
    if (_995 > 0) 
    goto _jump2040;
    fail_assertion("non-positive loop bound");
    _jump2040:;
    // Computing bound for s
    if (_381.d1 > 0) 
    goto _jump2041;
    fail_assertion("non-positive loop bound");
    _jump2041:;
    // Computing bound for t
    if (_381.d1 > 0) 
    goto _jump2042;
    fail_assertion("non-positive loop bound");
    _jump2042:;
    _994 = 0;
    int64_t _996 = 0; // t
    int64_t _997 = 0; // s
    int64_t _998 = 0; // r
    _jump2043:; // Begin body of loop
    _994 += _381.d0;
    _996++;
    if (_996 < _381.d1)
    goto _jump2043;
    _996 = 0;
    _997++;
    if (_997 < _381.d1)
    goto _jump2043;
    _997 = 0;
    _998++;
    if (_998 < _995)
    goto _jump2043;
    // End body of loop
    _993.d0 = _994;
    if (_994 > 0) 
    goto _jump2044;
    fail_assertion("non-positive loop bound");
    _jump2044:;
    // Computing bound for s
    int64_t _999 = 714;
    _993.d1 = _999;
    if (_999 > 0) 
    goto _jump2045;
    fail_assertion("non-positive loop bound");
    _jump2045:;
    // Computing bound for t
    _993.d2 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump2046;
    fail_assertion("non-positive loop bound");
    _jump2046:;
    // Computing total size of heap memory to allocate
    int64_t _1000 = 1;
    _1000 *= _994;
    _1000 *= _999;
    _1000 *= _381.d1;
    _1000 *= sizeof(_a2_bool);
    _993.data = jpl_alloc(_1000);
    int64_t _1001 = 0; // t
    int64_t _1002 = 0; // s
    int64_t _1003 = 0; // r
    _jump2047:; // Begin body of loop
    _a2_bool _1004;
    // Computing bound for u
    _1004.d0 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump2048;
    fail_assertion("non-positive loop bound");
    _jump2048:;
    // Computing bound for v
    _1004.d1 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump2049;
    fail_assertion("non-positive loop bound");
    _jump2049:;
    // Computing total size of heap memory to allocate
    int64_t _1005 = 1;
    _1005 *= _381.d1;
    _1005 *= _381.d0;
    _1005 *= sizeof(bool);
    _1004.data = jpl_alloc(_1005);
    int64_t _1006 = 0; // v
    int64_t _1007 = 0; // u
    _jump2050:; // Begin body of loop
    int64_t _1008 = 0;
    _1008 *= _1004.d0;
    _1008 += _1007;
    _1008 *= _1004.d1;
    _1008 += _1006;
    _1004.data[_1008] = _789;
    _1006++;
    if (_1006 < _381.d0)
    goto _jump2050;
    _1006 = 0;
    _1007++;
    if (_1007 < _381.d1)
    goto _jump2050;
    // End body of loop
    int64_t _1009 = 0;
    _1009 *= _993.d0;
    _1009 += _1003;
    _1009 *= _993.d1;
    _1009 += _1002;
    _1009 *= _993.d2;
    _1009 += _1001;
    _993.data[_1009] = _1004;
    _1001++;
    if (_1001 < _381.d1)
    goto _jump2047;
    _1001 = 0;
    _1002++;
    if (_1002 < _999)
    goto _jump2047;
    _1002 = 0;
    _1003++;
    if (_1003 < _994)
    goto _jump2047;
    // End body of loop
    int64_t _1010 = 0;
    _1010 *= _989.d0;
    _1010 += _992;
    _1010 *= _989.d1;
    _1010 += _991;
    _989.data[_1010] = _993;
    _991++;
    if (_991 < _381.d0)
    goto _jump2039;
    _991 = 0;
    _992++;
    if (_992 < _381.d0)
    goto _jump2039;
    // End body of loop
    int64_t _1011 = 645;
    int64_t _1012 = _381.d1 - _1011;
    int64_t _1013 = -_1012;
    int64_t _1014 = o();
    int64_t _1015 = _1013 + _1014;
    if (_1015 >= 0)
    goto _jump2051;
    fail_assertion("negative array index");
    _jump2051:;
    if (_1015 < _989.d0)
    goto _jump2052;
    fail_assertion("index too large");
    _jump2052:;
    if (_381.d2 >= 0)
    goto _jump2053;
    fail_assertion("negative array index");
    _jump2053:;
    if (_381.d2 < _989.d1)
    goto _jump2054;
    fail_assertion("index too large");
    _jump2054:;
    int64_t _1016 = 0;
    _1016 *= _989.d0;
    _1016 += _1015;
    _1016 *= _989.d1;
    _1016 += _381.d2;
    _a3__a2_bool _1017 = _989.data[_1016];
    _988 = _1017;
    goto _jump2055;
    _jump2036:;
    _a3__a2_bool _1018;
    // Computing bound for p
    int64_t _1019 = o();
    int64_t _1020 = 440;
    _a1_int64_t _1021;
    _1021.d0 = 2;
    _1021.data = jpl_alloc(sizeof(int64_t) * 2);
    _1021.data[0] = _1019;
    _1021.data[1] = _1020;
    int64_t _1022 = o();
    if (_1022 >= 0)
    goto _jump2056;
    fail_assertion("negative array index");
    _jump2056:;
    if (_1022 < _1021.d0)
    goto _jump2057;
    fail_assertion("index too large");
    _jump2057:;
    int64_t _1023 = 0;
    _1023 *= _1021.d0;
    _1023 += _1022;
    int64_t _1024 = _1021.data[_1023];
    _1018.d0 = _1024;
    if (_1024 > 0) 
    goto _jump2058;
    fail_assertion("non-positive loop bound");
    _jump2058:;
    // Computing bound for q
    int64_t _1025 = o();
    int64_t _1026 = _381.d1 - _1025;
    _1018.d1 = _1026;
    if (_1026 > 0) 
    goto _jump2059;
    fail_assertion("non-positive loop bound");
    _jump2059:;
    // Computing bound for r
    int64_t _1027;
    // Computing bound for p
    int64_t _1028 = o();
    int64_t _1029 = _1028 / _381.d2;
    if (_1029 > 0) 
    goto _jump2060;
    fail_assertion("non-positive loop bound");
    _jump2060:;
    _1027 = 0;
    int64_t _1030 = 0; // p
    _jump2061:; // Begin body of loop
    _1027 += _381.d2;
    _1030++;
    if (_1030 < _1029)
    goto _jump2061;
    // End body of loop
    _1018.d2 = _1027;
    if (_1027 > 0) 
    goto _jump2062;
    fail_assertion("non-positive loop bound");
    _jump2062:;
    // Computing total size of heap memory to allocate
    int64_t _1031 = 1;
    _1031 *= _1024;
    _1031 *= _1026;
    _1031 *= _1027;
    _1031 *= sizeof(_a2_bool);
    _1018.data = jpl_alloc(_1031);
    int64_t _1032 = 0; // r
    int64_t _1033 = 0; // q
    int64_t _1034 = 0; // p
    _jump2063:; // Begin body of loop
    _a3__a2_bool _1035;
    // Computing bound for s
    _1035.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2064;
    fail_assertion("non-positive loop bound");
    _jump2064:;
    // Computing bound for t
    _1035.d1 = _1032;
    if (_1032 > 0) 
    goto _jump2065;
    fail_assertion("non-positive loop bound");
    _jump2065:;
    // Computing bound for u
    _1035.d2 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2066;
    fail_assertion("non-positive loop bound");
    _jump2066:;
    // Computing total size of heap memory to allocate
    int64_t _1036 = 1;
    _1036 *= _381.d2;
    _1036 *= _1032;
    _1036 *= _381.d2;
    _1036 *= sizeof(_a2_bool);
    _1035.data = jpl_alloc(_1036);
    int64_t _1037 = 0; // u
    int64_t _1038 = 0; // t
    int64_t _1039 = 0; // s
    _jump2067:; // Begin body of loop
    _a2_bool _1040;
    // Computing bound for v
    _1040.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump2068;
    fail_assertion("non-positive loop bound");
    _jump2068:;
    // Computing bound for w
    _1040.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2069;
    fail_assertion("non-positive loop bound");
    _jump2069:;
    // Computing total size of heap memory to allocate
    int64_t _1041 = 1;
    _1041 *= _381.d0;
    _1041 *= _381.d2;
    _1041 *= sizeof(bool);
    _1040.data = jpl_alloc(_1041);
    int64_t _1042 = 0; // w
    int64_t _1043 = 0; // v
    _jump2070:; // Begin body of loop
    bool _1044 = false;
    int64_t _1045 = 0;
    _1045 *= _1040.d0;
    _1045 += _1043;
    _1045 *= _1040.d1;
    _1045 += _1042;
    _1040.data[_1045] = _1044;
    _1042++;
    if (_1042 < _381.d2)
    goto _jump2070;
    _1042 = 0;
    _1043++;
    if (_1043 < _381.d0)
    goto _jump2070;
    // End body of loop
    int64_t _1046 = 0;
    _1046 *= _1035.d0;
    _1046 += _1039;
    _1046 *= _1035.d1;
    _1046 += _1038;
    _1046 *= _1035.d2;
    _1046 += _1037;
    _1035.data[_1046] = _1040;
    _1037++;
    if (_1037 < _381.d2)
    goto _jump2067;
    _1037 = 0;
    _1038++;
    if (_1038 < _1032)
    goto _jump2067;
    _1038 = 0;
    _1039++;
    if (_1039 < _381.d2)
    goto _jump2067;
    // End body of loop
    if (_381.d0 >= 0)
    goto _jump2071;
    fail_assertion("negative array index");
    _jump2071:;
    if (_381.d0 < _1035.d0)
    goto _jump2072;
    fail_assertion("index too large");
    _jump2072:;
    if (_381.d2 >= 0)
    goto _jump2073;
    fail_assertion("negative array index");
    _jump2073:;
    if (_381.d2 < _1035.d1)
    goto _jump2074;
    fail_assertion("index too large");
    _jump2074:;
    if (_1032 >= 0)
    goto _jump2075;
    fail_assertion("negative array index");
    _jump2075:;
    if (_1032 < _1035.d2)
    goto _jump2076;
    fail_assertion("index too large");
    _jump2076:;
    int64_t _1047 = 0;
    _1047 *= _1035.d0;
    _1047 += _381.d0;
    _1047 *= _1035.d1;
    _1047 += _381.d2;
    _1047 *= _1035.d2;
    _1047 += _1032;
    _a2_bool _1048 = _1035.data[_1047];
    int64_t _1049 = 0;
    _1049 *= _1018.d0;
    _1049 += _1034;
    _1049 *= _1018.d1;
    _1049 += _1033;
    _1049 *= _1018.d2;
    _1049 += _1032;
    _1018.data[_1049] = _1048;
    _1032++;
    if (_1032 < _1027)
    goto _jump2063;
    _1032 = 0;
    _1033++;
    if (_1033 < _1026)
    goto _jump2063;
    _1033 = 0;
    _1034++;
    if (_1034 < _1024)
    goto _jump2063;
    // End body of loop
    _988 = _1018;
    _jump2055:;
    _987 = _988;
    goto _jump2077;
    _jump2035:;
    bool _1050 = false;
    bool _1051 = !_380;
    bool _1052 = _1050 == _1051;
    bool _1053;
    if (!_1052)
    goto _jump2078;
    bool _1054 = false;
    bool _1056 = true;
    bool _1055 = _1056;
    if (0 == _1056)
    goto _jump2079;
    _1055 = _789;
    _jump2079:;
    bool _1057 = _1054 != _1055;
    _1053 = _1057;
    goto _jump2080;
    _jump2078:;
    _1053 = _789;
    _jump2080:;
    _a2__a3__a2_bool _1058;
    if (!_1053)
    goto _jump2081;
    _a2__a3__a2_bool _1059;
    // Computing bound for p
    int64_t _1060 = 12;
    _1059.d0 = _1060;
    if (_1060 > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing bound for q
    int64_t _1061 = 589;
    _1059.d1 = _1061;
    if (_1061 > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing total size of heap memory to allocate
    int64_t _1062 = 1;
    _1062 *= _1060;
    _1062 *= _1061;
    _1062 *= sizeof(_a3__a2_bool);
    _1059.data = jpl_alloc(_1062);
    int64_t _1063 = 0; // q
    int64_t _1064 = 0; // p
    _jump2084:; // Begin body of loop
    _a3__a2_bool _1065;
    // Computing bound for r
    _1065.d0 = _1064;
    if (_1064 > 0) 
    goto _jump2085;
    fail_assertion("non-positive loop bound");
    _jump2085:;
    // Computing bound for s
    _1065.d1 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump2086;
    fail_assertion("non-positive loop bound");
    _jump2086:;
    // Computing bound for t
    int64_t _1066 = 537;
    int64_t _1067 = _1066 - _381.d0;
    _1065.d2 = _1067;
    if (_1067 > 0) 
    goto _jump2087;
    fail_assertion("non-positive loop bound");
    _jump2087:;
    // Computing total size of heap memory to allocate
    int64_t _1068 = 1;
    _1068 *= _1064;
    _1068 *= _381.d1;
    _1068 *= _1067;
    _1068 *= sizeof(_a2_bool);
    _1065.data = jpl_alloc(_1068);
    int64_t _1069 = 0; // t
    int64_t _1070 = 0; // s
    int64_t _1071 = 0; // r
    _jump2088:; // Begin body of loop
    _a2_bool _1072;
    // Computing bound for u
    int64_t _1073 = 96;
    _1072.d0 = _1073;
    if (_1073 > 0) 
    goto _jump2089;
    fail_assertion("non-positive loop bound");
    _jump2089:;
    // Computing bound for v
    int64_t _1074 = 581;
    _1072.d1 = _1074;
    if (_1074 > 0) 
    goto _jump2090;
    fail_assertion("non-positive loop bound");
    _jump2090:;
    // Computing total size of heap memory to allocate
    int64_t _1075 = 1;
    _1075 *= _1073;
    _1075 *= _1074;
    _1075 *= sizeof(bool);
    _1072.data = jpl_alloc(_1075);
    int64_t _1076 = 0; // v
    int64_t _1077 = 0; // u
    _jump2091:; // Begin body of loop
    bool _1078 = true;
    int64_t _1079 = 0;
    _1079 *= _1072.d0;
    _1079 += _1077;
    _1079 *= _1072.d1;
    _1079 += _1076;
    _1072.data[_1079] = _1078;
    _1076++;
    if (_1076 < _1074)
    goto _jump2091;
    _1076 = 0;
    _1077++;
    if (_1077 < _1073)
    goto _jump2091;
    // End body of loop
    int64_t _1080 = 0;
    _1080 *= _1065.d0;
    _1080 += _1071;
    _1080 *= _1065.d1;
    _1080 += _1070;
    _1080 *= _1065.d2;
    _1080 += _1069;
    _1065.data[_1080] = _1072;
    _1069++;
    if (_1069 < _1067)
    goto _jump2088;
    _1069 = 0;
    _1070++;
    if (_1070 < _381.d1)
    goto _jump2088;
    _1070 = 0;
    _1071++;
    if (_1071 < _1064)
    goto _jump2088;
    // End body of loop
    int64_t _1081 = 0;
    _1081 *= _1059.d0;
    _1081 += _1064;
    _1081 *= _1059.d1;
    _1081 += _1063;
    _1059.data[_1081] = _1065;
    _1063++;
    if (_1063 < _1061)
    goto _jump2084;
    _1063 = 0;
    _1064++;
    if (_1064 < _1060)
    goto _jump2084;
    // End body of loop
    _1058 = _1059;
    goto _jump2092;
    _jump2081:;
    _a2__a3__a2_bool _1082;
    // Computing bound for p
    int64_t _1083 = -_381.d1;
    _1082.d0 = _1083;
    if (_1083 > 0) 
    goto _jump2093;
    fail_assertion("non-positive loop bound");
    _jump2093:;
    // Computing bound for q
    int64_t _1084;
    if (!_380)
    goto _jump2094;
    bool _1085 = false;
    int64_t _1086;
    if (!_1085)
    goto _jump2095;
    _1086 = _381.d2;
    goto _jump2096;
    _jump2095:;
    _1086 = _381.d0;
    _jump2096:;
    _1084 = _1086;
    goto _jump2097;
    _jump2094:;
    _1084 = _381.d1;
    _jump2097:;
    _1082.d1 = _1084;
    if (_1084 > 0) 
    goto _jump2098;
    fail_assertion("non-positive loop bound");
    _jump2098:;
    // Computing total size of heap memory to allocate
    int64_t _1087 = 1;
    _1087 *= _1083;
    _1087 *= _1084;
    _1087 *= sizeof(_a3__a2_bool);
    _1082.data = jpl_alloc(_1087);
    int64_t _1088 = 0; // q
    int64_t _1089 = 0; // p
    _jump2099:; // Begin body of loop
    _a3__a2_bool _1090;
    // Computing bound for r
    int64_t _1091 = _381.d2 % _381.d2;
    _1090.d0 = _1091;
    if (_1091 > 0) 
    goto _jump2100;
    fail_assertion("non-positive loop bound");
    _jump2100:;
    // Computing bound for s
    _1090.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2101;
    fail_assertion("non-positive loop bound");
    _jump2101:;
    // Computing bound for t
    _1090.d2 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2102;
    fail_assertion("non-positive loop bound");
    _jump2102:;
    // Computing total size of heap memory to allocate
    int64_t _1092 = 1;
    _1092 *= _1091;
    _1092 *= _381.d2;
    _1092 *= _381.d2;
    _1092 *= sizeof(_a2_bool);
    _1090.data = jpl_alloc(_1092);
    int64_t _1093 = 0; // t
    int64_t _1094 = 0; // s
    int64_t _1095 = 0; // r
    _jump2103:; // Begin body of loop
    _a2_bool _1096;
    // Computing bound for u
    _1096.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump2104;
    fail_assertion("non-positive loop bound");
    _jump2104:;
    // Computing bound for v
    int64_t _1097 = o();
    _1096.d1 = _1097;
    if (_1097 > 0) 
    goto _jump2105;
    fail_assertion("non-positive loop bound");
    _jump2105:;
    // Computing total size of heap memory to allocate
    int64_t _1098 = 1;
    _1098 *= _381.d0;
    _1098 *= _1097;
    _1098 *= sizeof(bool);
    _1096.data = jpl_alloc(_1098);
    int64_t _1099 = 0; // v
    int64_t _1100 = 0; // u
    _jump2106:; // Begin body of loop
    int64_t _1101 = 0;
    _1101 *= _1096.d0;
    _1101 += _1100;
    _1101 *= _1096.d1;
    _1101 += _1099;
    _1096.data[_1101] = _789;
    _1099++;
    if (_1099 < _1097)
    goto _jump2106;
    _1099 = 0;
    _1100++;
    if (_1100 < _381.d0)
    goto _jump2106;
    // End body of loop
    int64_t _1102 = 0;
    _1102 *= _1090.d0;
    _1102 += _1095;
    _1102 *= _1090.d1;
    _1102 += _1094;
    _1102 *= _1090.d2;
    _1102 += _1093;
    _1090.data[_1102] = _1096;
    _1093++;
    if (_1093 < _381.d2)
    goto _jump2103;
    _1093 = 0;
    _1094++;
    if (_1094 < _381.d2)
    goto _jump2103;
    _1094 = 0;
    _1095++;
    if (_1095 < _1091)
    goto _jump2103;
    // End body of loop
    int64_t _1103 = 0;
    _1103 *= _1082.d0;
    _1103 += _1089;
    _1103 *= _1082.d1;
    _1103 += _1088;
    _1082.data[_1103] = _1090;
    _1088++;
    if (_1088 < _1084)
    goto _jump2099;
    _1088 = 0;
    _1089++;
    if (_1089 < _1083)
    goto _jump2099;
    // End body of loop
    _1058 = _1082;
    _jump2092:;
    _a2_int64_t _1104;
    // Computing bound for p
    int64_t _1105 = _381.d0 - _381.d2;
    int64_t _1106 = -_1105;
    _1104.d0 = _1106;
    if (_1106 > 0) 
    goto _jump2107;
    fail_assertion("non-positive loop bound");
    _jump2107:;
    // Computing bound for q
    _1104.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2108;
    fail_assertion("non-positive loop bound");
    _jump2108:;
    // Computing total size of heap memory to allocate
    int64_t _1107 = 1;
    _1107 *= _1106;
    _1107 *= _381.d2;
    _1107 *= sizeof(int64_t);
    _1104.data = jpl_alloc(_1107);
    int64_t _1108 = 0; // q
    int64_t _1109 = 0; // p
    _jump2109:; // Begin body of loop
    bool _1110 = _1109 > _381.d0;
    int64_t _1111;
    if (!_1110)
    goto _jump2110;
    _1111 = _1108;
    goto _jump2111;
    _jump2110:;
    int64_t _1112 = o();
    _1111 = _1112;
    _jump2111:;
    int64_t _1113 = 0;
    _1113 *= _1104.d0;
    _1113 += _1109;
    _1113 *= _1104.d1;
    _1113 += _1108;
    _1104.data[_1113] = _1111;
    _1108++;
    if (_1108 < _381.d2)
    goto _jump2109;
    _1108 = 0;
    _1109++;
    if (_1109 < _1106)
    goto _jump2109;
    // End body of loop
    if (_381.d2 >= 0)
    goto _jump2112;
    fail_assertion("negative array index");
    _jump2112:;
    if (_381.d2 < _1104.d0)
    goto _jump2113;
    fail_assertion("index too large");
    _jump2113:;
    if (_381.d2 >= 0)
    goto _jump2114;
    fail_assertion("negative array index");
    _jump2114:;
    if (_381.d2 < _1104.d1)
    goto _jump2115;
    fail_assertion("index too large");
    _jump2115:;
    int64_t _1114 = 0;
    _1114 *= _1104.d0;
    _1114 += _381.d2;
    _1114 *= _1104.d1;
    _1114 += _381.d2;
    int64_t _1115 = _1104.data[_1114];
    bool _1116 = false;
    bool _1117;
    if (!_1116)
    goto _jump2116;
    int64_t _1118 = o();
    if (_381.d0 >= 0)
    goto _jump2117;
    fail_assertion("negative array index");
    _jump2117:;
    if (_381.d0 < _381.d0)
    goto _jump2118;
    fail_assertion("index too large");
    _jump2118:;
    if (_381.d0 >= 0)
    goto _jump2119;
    fail_assertion("negative array index");
    _jump2119:;
    if (_381.d0 < _381.d1)
    goto _jump2120;
    fail_assertion("index too large");
    _jump2120:;
    if (_1118 >= 0)
    goto _jump2121;
    fail_assertion("negative array index");
    _jump2121:;
    if (_1118 < _381.d2)
    goto _jump2122;
    fail_assertion("index too large");
    _jump2122:;
    int64_t _1119 = 0;
    _1119 *= _381.d0;
    _1119 += _381.d0;
    _1119 *= _381.d1;
    _1119 += _381.d0;
    _1119 *= _381.d2;
    _1119 += _1118;
    bool _1120 = _381.data[_1119];
    bool _1121 = !_1120;
    _1117 = _1121;
    goto _jump2123;
    _jump2116:;
    bool _1122 = false;
    bool _1123 = !_1122;
    bool _1124 = !_1123;
    _1117 = _1124;
    _jump2123:;
    int64_t _1125;
    if (!_1117)
    goto _jump2124;
    _1125 = _381.d2;
    goto _jump2125;
    _jump2124:;
    int64_t _1126;
    // Computing bound for p
    if (_381.d1 > 0) 
    goto _jump2126;
    fail_assertion("non-positive loop bound");
    _jump2126:;
    // Computing bound for q
    if (_381.d2 > 0) 
    goto _jump2127;
    fail_assertion("non-positive loop bound");
    _jump2127:;
    // Computing bound for r
    int64_t _1127;
    // Computing bound for p
    if (_381.d0 > 0) 
    goto _jump2128;
    fail_assertion("non-positive loop bound");
    _jump2128:;
    _1127 = 0;
    int64_t _1128 = 0; // p
    _jump2129:; // Begin body of loop
    _1127 += _381.d2;
    _1128++;
    if (_1128 < _381.d0)
    goto _jump2129;
    // End body of loop
    if (_1127 > 0) 
    goto _jump2130;
    fail_assertion("non-positive loop bound");
    _jump2130:;
    _1126 = 0;
    int64_t _1129 = 0; // r
    int64_t _1130 = 0; // q
    int64_t _1131 = 0; // p
    _jump2131:; // Begin body of loop
    _1126 += _381.d1;
    _1129++;
    if (_1129 < _1127)
    goto _jump2131;
    _1129 = 0;
    _1130++;
    if (_1130 < _381.d2)
    goto _jump2131;
    _1130 = 0;
    _1131++;
    if (_1131 < _381.d1)
    goto _jump2131;
    // End body of loop
    _1125 = _1126;
    _jump2125:;
    if (_1115 >= 0)
    goto _jump2132;
    fail_assertion("negative array index");
    _jump2132:;
    if (_1115 < _1058.d0)
    goto _jump2133;
    fail_assertion("index too large");
    _jump2133:;
    if (_1125 >= 0)
    goto _jump2134;
    fail_assertion("negative array index");
    _jump2134:;
    if (_1125 < _1058.d1)
    goto _jump2135;
    fail_assertion("index too large");
    _jump2135:;
    int64_t _1132 = 0;
    _1132 *= _1058.d0;
    _1132 += _1115;
    _1132 *= _1058.d1;
    _1132 += _1125;
    _a3__a2_bool _1133 = _1058.data[_1132];
    _987 = _1133;
    _jump2077:;
    _a2__a1__a2_double _1134;
    // Computing bound for p
    _1134.d0 = _381.d0;
    if (_381.d0 > 0) 
    goto _jump2136;
    fail_assertion("non-positive loop bound");
    _jump2136:;
    // Computing bound for q
    _1134.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2137;
    fail_assertion("non-positive loop bound");
    _jump2137:;
    // Computing total size of heap memory to allocate
    int64_t _1135 = 1;
    _1135 *= _381.d0;
    _1135 *= _381.d2;
    _1135 *= sizeof(_a1__a2_double);
    _1134.data = jpl_alloc(_1135);
    int64_t _1136 = 0; // q
    int64_t _1137 = 0; // p
    _jump2138:; // Begin body of loop
    _a1__a2_double _1138;
    // Computing bound for r
    int64_t _1139 = o();
    _1138.d0 = _1139;
    if (_1139 > 0) 
    goto _jump2139;
    fail_assertion("non-positive loop bound");
    _jump2139:;
    // Computing total size of heap memory to allocate
    int64_t _1140 = 1;
    _1140 *= _1139;
    _1140 *= sizeof(_a2_double);
    _1138.data = jpl_alloc(_1140);
    int64_t _1141 = 0; // r
    _jump2140:; // Begin body of loop
    _a2_double _1142;
    // Computing bound for s
    _1142.d0 = _1141;
    if (_1141 > 0) 
    goto _jump2141;
    fail_assertion("non-positive loop bound");
    _jump2141:;
    // Computing bound for t
    int64_t _1143 = o();
    _1142.d1 = _1143;
    if (_1143 > 0) 
    goto _jump2142;
    fail_assertion("non-positive loop bound");
    _jump2142:;
    // Computing total size of heap memory to allocate
    int64_t _1144 = 1;
    _1144 *= _1141;
    _1144 *= _1143;
    _1144 *= sizeof(double);
    _1142.data = jpl_alloc(_1144);
    int64_t _1145 = 0; // t
    int64_t _1146 = 0; // s
    _jump2143:; // Begin body of loop
    double _1147 = 5.0;
    int64_t _1148 = 0;
    _1148 *= _1142.d0;
    _1148 += _1146;
    _1148 *= _1142.d1;
    _1148 += _1145;
    _1142.data[_1148] = _1147;
    _1145++;
    if (_1145 < _1143)
    goto _jump2143;
    _1145 = 0;
    _1146++;
    if (_1146 < _1141)
    goto _jump2143;
    // End body of loop
    int64_t _1149 = 0;
    _1149 *= _1138.d0;
    _1149 += _1141;
    _1138.data[_1149] = _1142;
    _1141++;
    if (_1141 < _1139)
    goto _jump2140;
    // End body of loop
    int64_t _1150 = 0;
    _1150 *= _1134.d0;
    _1150 += _1137;
    _1150 *= _1134.d1;
    _1150 += _1136;
    _1134.data[_1150] = _1138;
    _1136++;
    if (_1136 < _381.d2)
    goto _jump2138;
    _1136 = 0;
    _1137++;
    if (_1137 < _381.d0)
    goto _jump2138;
    // End body of loop
    int64_t _1151 = o();
    int64_t _1152 = -_1151;
    if (_381.d2 >= 0)
    goto _jump2144;
    fail_assertion("negative array index");
    _jump2144:;
    if (_381.d2 < _1134.d0)
    goto _jump2145;
    fail_assertion("index too large");
    _jump2145:;
    if (_1152 >= 0)
    goto _jump2146;
    fail_assertion("negative array index");
    _jump2146:;
    if (_1152 < _1134.d1)
    goto _jump2147;
    fail_assertion("index too large");
    _jump2147:;
    int64_t _1153 = 0;
    _1153 *= _1134.d0;
    _1153 += _381.d2;
    _1153 *= _1134.d1;
    _1153 += _1152;
    _a1__a2_double _1154 = _1134.data[_1153];
    bool _1155 = false;
    _a3_bool _1156;
    if (!_1155)
    goto _jump2148;
    _1156 = _381;
    goto _jump2149;
    _jump2148:;
    _1156 = _903;
    _jump2149:;
    int64_t _1157 = 863;
    int64_t _1158 = 354;
    int64_t _1159 = 172;
    if (_1157 >= 0)
    goto _jump2150;
    fail_assertion("negative array index");
    _jump2150:;
    if (_1157 < _1156.d0)
    goto _jump2151;
    fail_assertion("index too large");
    _jump2151:;
    if (_1158 >= 0)
    goto _jump2152;
    fail_assertion("negative array index");
    _jump2152:;
    if (_1158 < _1156.d1)
    goto _jump2153;
    fail_assertion("index too large");
    _jump2153:;
    if (_1159 >= 0)
    goto _jump2154;
    fail_assertion("negative array index");
    _jump2154:;
    if (_1159 < _1156.d2)
    goto _jump2155;
    fail_assertion("index too large");
    _jump2155:;
    int64_t _1160 = 0;
    _1160 *= _1156.d0;
    _1160 += _1157;
    _1160 *= _1156.d1;
    _1160 += _1158;
    _1160 *= _1156.d2;
    _1160 += _1159;
    bool _1161 = _1156.data[_1160];
    _a3_int64_t _1162;
    if (!_1161)
    goto _jump2156;
    _a3_int64_t _1163;
    // Computing bound for p
    int64_t _1164 = 276;
    _1163.d0 = _1164;
    if (_1164 > 0) 
    goto _jump2157;
    fail_assertion("non-positive loop bound");
    _jump2157:;
    // Computing bound for q
    _1163.d1 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2158;
    fail_assertion("non-positive loop bound");
    _jump2158:;
    // Computing bound for r
    int64_t _1165 = o();
    _1163.d2 = _1165;
    if (_1165 > 0) 
    goto _jump2159;
    fail_assertion("non-positive loop bound");
    _jump2159:;
    // Computing total size of heap memory to allocate
    int64_t _1166 = 1;
    _1166 *= _1164;
    _1166 *= _381.d2;
    _1166 *= _1165;
    _1166 *= sizeof(int64_t);
    _1163.data = jpl_alloc(_1166);
    int64_t _1167 = 0; // r
    int64_t _1168 = 0; // q
    int64_t _1169 = 0; // p
    _jump2160:; // Begin body of loop
    int64_t _1170 = 0;
    _1170 *= _1163.d0;
    _1170 += _1169;
    _1170 *= _1163.d1;
    _1170 += _1168;
    _1170 *= _1163.d2;
    _1170 += _1167;
    _1163.data[_1170] = _381.d2;
    _1167++;
    if (_1167 < _1165)
    goto _jump2160;
    _1167 = 0;
    _1168++;
    if (_1168 < _381.d2)
    goto _jump2160;
    _1168 = 0;
    _1169++;
    if (_1169 < _1164)
    goto _jump2160;
    // End body of loop
    _1162 = _1163;
    goto _jump2161;
    _jump2156:;
    _a3_int64_t _1171;
    // Computing bound for p
    _1171.d0 = _381.d2;
    if (_381.d2 > 0) 
    goto _jump2162;
    fail_assertion("non-positive loop bound");
    _jump2162:;
    // Computing bound for q
    bool _1172 = false;
    int64_t _1173;
    if (!_1172)
    goto _jump2163;
    _1173 = _381.d0;
    goto _jump2164;
    _jump2163:;
    int64_t _1174 = 752;
    _1173 = _1174;
    _jump2164:;
    _1171.d1 = _1173;
    if (_1173 > 0) 
    goto _jump2165;
    fail_assertion("non-positive loop bound");
    _jump2165:;
    // Computing bound for r
    int64_t _1175 = _381.d0 - _381.d2;
    _1171.d2 = _1175;
    if (_1175 > 0) 
    goto _jump2166;
    fail_assertion("non-positive loop bound");
    _jump2166:;
    // Computing total size of heap memory to allocate
    int64_t _1176 = 1;
    _1176 *= _381.d2;
    _1176 *= _1173;
    _1176 *= _1175;
    _1176 *= sizeof(int64_t);
    _1171.data = jpl_alloc(_1176);
    int64_t _1177 = 0; // r
    int64_t _1178 = 0; // q
    int64_t _1179 = 0; // p
    _jump2167:; // Begin body of loop
    int64_t _1180 = 0;
    _1180 *= _1171.d0;
    _1180 += _1179;
    _1180 *= _1171.d1;
    _1180 += _1178;
    _1180 *= _1171.d2;
    _1180 += _1177;
    _1171.data[_1180] = _381.d0;
    _1177++;
    if (_1177 < _1175)
    goto _jump2167;
    _1177 = 0;
    _1178++;
    if (_1178 < _1173)
    goto _jump2167;
    _1178 = 0;
    _1179++;
    if (_1179 < _381.d2)
    goto _jump2167;
    // End body of loop
    _1162 = _1171;
    _jump2161:;
    _a3_int64_t _1181;
    // Computing bound for p
    _1181.d0 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump2168;
    fail_assertion("non-positive loop bound");
    _jump2168:;
    // Computing bound for q
    _1181.d1 = _381.d1;
    if (_381.d1 > 0) 
    goto _jump2169;
    fail_assertion("non-positive loop bound");
    _jump2169:;
    // Computing bound for r
    int64_t _1182 = -_381.d2;
    _1181.d2 = _1182;
    if (_1182 > 0) 
    goto _jump2170;
    fail_assertion("non-positive loop bound");
    _jump2170:;
    // Computing total size of heap memory to allocate
    int64_t _1183 = 1;
    _1183 *= _381.d1;
    _1183 *= _381.d1;
    _1183 *= _1182;
    _1183 *= sizeof(int64_t);
    _1181.data = jpl_alloc(_1183);
    int64_t _1184 = 0; // r
    int64_t _1185 = 0; // q
    int64_t _1186 = 0; // p
    _jump2171:; // Begin body of loop
    int64_t _1187 = 0;
    _1187 *= _1181.d0;
    _1187 += _1186;
    _1187 *= _1181.d1;
    _1187 += _1185;
    _1187 *= _1181.d2;
    _1187 += _1184;
    _1181.data[_1187] = _381.d2;
    _1184++;
    if (_1184 < _1182)
    goto _jump2171;
    _1184 = 0;
    _1185++;
    if (_1185 < _381.d1)
    goto _jump2171;
    _1185 = 0;
    _1186++;
    if (_1186 < _381.d1)
    goto _jump2171;
    // End body of loop
    int64_t _1188;
    if (!_789)
    goto _jump2172;
    int64_t _1189 = o();
    _1188 = _1189;
    goto _jump2173;
    _jump2172:;
    _1188 = _381.d1;
    _jump2173:;
    int64_t _1190 = o();
    if (_1188 >= 0)
    goto _jump2174;
    fail_assertion("negative array index");
    _jump2174:;
    if (_1188 < _1181.d0)
    goto _jump2175;
    fail_assertion("index too large");
    _jump2175:;
    if (_1190 >= 0)
    goto _jump2176;
    fail_assertion("negative array index");
    _jump2176:;
    if (_1190 < _1181.d1)
    goto _jump2177;
    fail_assertion("index too large");
    _jump2177:;
    if (_381.d2 >= 0)
    goto _jump2178;
    fail_assertion("negative array index");
    _jump2178:;
    if (_381.d2 < _1181.d2)
    goto _jump2179;
    fail_assertion("index too large");
    _jump2179:;
    int64_t _1191 = 0;
    _1191 *= _1181.d0;
    _1191 += _1188;
    _1191 *= _1181.d1;
    _1191 += _1190;
    _1191 *= _1181.d2;
    _1191 += _381.d2;
    int64_t _1192 = _1181.data[_1191];
    int64_t _1193 = -_381.d2;
    if (_381.d2 >= 0)
    goto _jump2180;
    fail_assertion("negative array index");
    _jump2180:;
    if (_381.d2 < _1162.d0)
    goto _jump2181;
    fail_assertion("index too large");
    _jump2181:;
    if (_1192 >= 0)
    goto _jump2182;
    fail_assertion("negative array index");
    _jump2182:;
    if (_1192 < _1162.d1)
    goto _jump2183;
    fail_assertion("index too large");
    _jump2183:;
    if (_1193 >= 0)
    goto _jump2184;
    fail_assertion("negative array index");
    _jump2184:;
    if (_1193 < _1162.d2)
    goto _jump2185;
    fail_assertion("index too large");
    _jump2185:;
    int64_t _1194 = 0;
    _1194 *= _1162.d0;
    _1194 += _381.d2;
    _1194 *= _1162.d1;
    _1194 += _1192;
    _1194 *= _1162.d2;
    _1194 += _1193;
    int64_t _1195 = _1162.data[_1194];
    if (_1195 >= 0)
    goto _jump2186;
    fail_assertion("negative array index");
    _jump2186:;
    if (_1195 < _1154.d0)
    goto _jump2187;
    fail_assertion("index too large");
    _jump2187:;
    int64_t _1196 = 0;
    _1196 *= _1154.d0;
    _1196 += _1195;
    _a2_double _1197 = _1154.data[_1196];
    int64_t _1198 = b(_1197);
    int64_t _1199 = o();
    int64_t _1200 = -_1199;
    int64_t _1201 = 156;
    if (_1198 >= 0)
    goto _jump2188;
    fail_assertion("negative array index");
    _jump2188:;
    if (_1198 < _987.d0)
    goto _jump2189;
    fail_assertion("index too large");
    _jump2189:;
    if (_1200 >= 0)
    goto _jump2190;
    fail_assertion("negative array index");
    _jump2190:;
    if (_1200 < _987.d1)
    goto _jump2191;
    fail_assertion("index too large");
    _jump2191:;
    if (_1201 >= 0)
    goto _jump2192;
    fail_assertion("negative array index");
    _jump2192:;
    if (_1201 < _987.d2)
    goto _jump2193;
    fail_assertion("index too large");
    _jump2193:;
    int64_t _1202 = 0;
    _1202 *= _987.d0;
    _1202 += _1198;
    _1202 *= _987.d1;
    _1202 += _1200;
    _1202 *= _987.d2;
    _1202 += _1201;
    _a2_bool _1203 = _987.data[_1202];
    double _1204;
    // Computing bound for u
    int64_t _1205;
    // Computing bound for u
    int64_t _1206 = o();
    int64_t _1207 = 700;
    int64_t _1208 = o();
    _a1_int64_t _1209;
    _1209.d0 = 3;
    _1209.data = jpl_alloc(sizeof(int64_t) * 3);
    _1209.data[0] = _1206;
    _1209.data[1] = _1207;
    _1209.data[2] = _1208;
    if (_381.d2 >= 0)
    goto _jump2194;
    fail_assertion("negative array index");
    _jump2194:;
    if (_381.d2 < _1209.d0)
    goto _jump2195;
    fail_assertion("index too large");
    _jump2195:;
    int64_t _1210 = 0;
    _1210 *= _1209.d0;
    _1210 += _381.d2;
    int64_t _1211 = _1209.data[_1210];
    if (_1211 > 0) 
    goto _jump2196;
    fail_assertion("non-positive loop bound");
    _jump2196:;
    // Computing bound for v
    if (_381.d2 > 0) 
    goto _jump2197;
    fail_assertion("non-positive loop bound");
    _jump2197:;
    _1205 = 0;
    int64_t _1212 = 0; // v
    int64_t _1213 = 0; // u
    _jump2198:; // Begin body of loop
    int64_t _1214 = 94;
    int64_t _1215 = _381.d0 + _1214;
    _1205 += _1215;
    _1212++;
    if (_1212 < _381.d2)
    goto _jump2198;
    _1212 = 0;
    _1213++;
    if (_1213 < _1211)
    goto _jump2198;
    // End body of loop
    if (_1205 > 0) 
    goto _jump2199;
    fail_assertion("non-positive loop bound");
    _jump2199:;
    // Computing bound for v
    int64_t _1216 = 31;
    if (_1216 > 0) 
    goto _jump2200;
    fail_assertion("non-positive loop bound");
    _jump2200:;
    _1204 = 0;
    int64_t _1217 = 0; // v
    int64_t _1218 = 0; // u
    _jump2201:; // Begin body of loop
    double _1219 = 24.0;
    _1204 += _1219;
    _1217++;
    if (_1217 < _1216)
    goto _jump2201;
    _1217 = 0;
    _1218++;
    if (_1218 < _1205)
    goto _jump2201;
    // End body of loop
    _a2_rgba _1220 = read_image("y.png");
}

