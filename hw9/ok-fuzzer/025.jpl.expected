
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_double *data;
} _a2__a1_double;

typedef struct {
  int64_t d0;
  _a2__a1_double *data;
} _a1__a2__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1__a2_int64_t *data;
} _a1__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1__a2_int64_t *data;
} _a2__a1__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2_int64_t *data;
} _a3__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2__a2_int64_t *data;
} _a2__a3__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2__a2_int64_t *data;
} _a1__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  _a1_double *data;
} _a1__a1_double;

typedef struct {
  int64_t d0;
  _a1__a1_double *data;
} _a1__a1__a1_double;

typedef struct {
  int64_t d0;
  _a2__a3_double *data;
} _a1__a2__a3_double;

typedef struct {
  int64_t d0;
  _a2__a3_int64_t *data;
} _a1__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_int64_t *data;
} _a2__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2_int64_t *data;
} _a2__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  _a2_void_t *data;
} _a1__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a3_double *data;
} _a2__a3__a3_double;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_void_t *data;
} _a2__a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_bool *data;
} _a3__a2__a3_bool;

int64_t a(_a2_bool b, void_t c) {
    _a2__a1_int64_t _0;
    // Computing bound for d
    bool _1 = false;
    int64_t _2;
    if (!_1)
    goto _jump1;
    int64_t _3 = 283;
    _2 = _3;
    goto _jump2;
    _jump1:;
    int64_t _4 = 566;
    _2 = _4;
    _jump2:;
    int64_t _5 = -_2;
    int64_t _6 = a(b, c);
    int64_t _7 = -_6;
    if (_5 >= 0)
    goto _jump3;
    fail_assertion("negative array index");
    _jump3:;
    if (_5 < b.d0)
    goto _jump4;
    fail_assertion("index too large");
    _jump4:;
    if (_7 >= 0)
    goto _jump5;
    fail_assertion("negative array index");
    _jump5:;
    if (_7 < b.d1)
    goto _jump6;
    fail_assertion("index too large");
    _jump6:;
    int64_t _8 = 0;
    _8 *= b.d0;
    _8 += _5;
    _8 *= b.d1;
    _8 += _7;
    bool _9 = b.data[_8];
    void_t _10;
    if (!_9)
    goto _jump7;
    _10 = c;
    goto _jump8;
    _jump7:;
    double _11 = 22.0;
    double _12 = 38.0;
    bool _13 = _11 > _12;
    void_t _14;
    if (!_13)
    goto _jump9;
    _14 = c;
    goto _jump10;
    _jump9:;
    _14 = c;
    _jump10:;
    _10 = _14;
    _jump8:;
    int64_t _15 = a(b, _10);
    int64_t _16 = -_15;
    _0.d0 = _16;
    if (_16 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for e
    int64_t _17;
    // Computing bound for d
    bool _18 = false;
    int64_t _19;
    if (!_18)
    goto _jump12;
    int64_t _20 = 595;
    int64_t _21 = 337;
    int64_t _22 = _20 + _21;
    bool _23 = false;
    int64_t _24;
    if (!_23)
    goto _jump13;
    int64_t _25 = 238;
    _24 = _25;
    goto _jump14;
    _jump13:;
    int64_t _26 = 995;
    _24 = _26;
    _jump14:;
    int64_t _27 = _22 % _24;
    int64_t _28 = 931;
    int64_t _29 = _27 / _28;
    _19 = _29;
    goto _jump15;
    _jump12:;
    int64_t _30;
    // Computing bound for d
    int64_t _31 = 831;
    if (_31 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    _30 = 0;
    int64_t _32 = 0; // d
    _jump17:; // Begin body of loop
    int64_t _33 = 177;
    _30 += _33;
    _32++;
    if (_32 < _31)
    goto _jump17;
    // End body of loop
    int64_t _34 = 211;
    int64_t _35 = -_34;
    if (_30 >= 0)
    goto _jump18;
    fail_assertion("negative array index");
    _jump18:;
    if (_30 < b.d0)
    goto _jump19;
    fail_assertion("index too large");
    _jump19:;
    if (_35 >= 0)
    goto _jump20;
    fail_assertion("negative array index");
    _jump20:;
    if (_35 < b.d1)
    goto _jump21;
    fail_assertion("index too large");
    _jump21:;
    int64_t _36 = 0;
    _36 *= b.d0;
    _36 += _30;
    _36 *= b.d1;
    _36 += _35;
    bool _37 = b.data[_36];
    int64_t _38;
    if (!_37)
    goto _jump22;
    int64_t _39;
    // Computing bound for d
    int64_t _40 = 929;
    if (_40 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    // Computing bound for e
    int64_t _41 = a(b, c);
    if (_41 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    _39 = 0;
    int64_t _42 = 0; // e
    int64_t _43 = 0; // d
    _jump25:; // Begin body of loop
    int64_t _44 = 97;
    int64_t _45 = _44 * _43;
    _39 += _45;
    _42++;
    if (_42 < _41)
    goto _jump25;
    _42 = 0;
    _43++;
    if (_43 < _40)
    goto _jump25;
    // End body of loop
    _38 = _39;
    goto _jump26;
    _jump22:;
    int64_t _46 = a(b, c);
    _38 = _46;
    _jump26:;
    _19 = _38;
    _jump15:;
    int64_t _47 = -_19;
    if (_47 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _17 = 0;
    int64_t _48 = 0; // d
    _jump28:; // Begin body of loop
    _a3_int64_t _49;
    // Computing bound for e
    int64_t _50 = 997;
    int64_t _51;
    // Computing bound for e
    if (_48 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    _51 = 0;
    int64_t _52 = 0; // e
    _jump30:; // Begin body of loop
    _51 += _48;
    _52++;
    if (_52 < _48)
    goto _jump30;
    // End body of loop
    int64_t _53 = _50 % _51;
    _49.d0 = _53;
    if (_53 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    // Computing bound for f
    int64_t _54 = 449;
    _49.d1 = _54;
    if (_54 > 0) 
    goto _jump32;
    fail_assertion("non-positive loop bound");
    _jump32:;
    // Computing bound for g
    int64_t _55 = 105;
    _49.d2 = _55;
    if (_55 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= _53;
    _56 *= _54;
    _56 *= _55;
    _56 *= sizeof(int64_t);
    _49.data = jpl_alloc(_56);
    int64_t _57 = 0; // g
    int64_t _58 = 0; // f
    int64_t _59 = 0; // e
    _jump34:; // Begin body of loop
    int64_t _60 = -_58;
    int64_t _61 = 0;
    _61 *= _49.d0;
    _61 += _59;
    _61 *= _49.d1;
    _61 += _58;
    _61 *= _49.d2;
    _61 += _57;
    _49.data[_61] = _60;
    _57++;
    if (_57 < _55)
    goto _jump34;
    _57 = 0;
    _58++;
    if (_58 < _54)
    goto _jump34;
    _58 = 0;
    _59++;
    if (_59 < _53)
    goto _jump34;
    // End body of loop
    int64_t _62 = -_48;
    _a2_int64_t _63;
    // Computing bound for e
    int64_t _64 = 544;
    _63.d0 = _64;
    if (_64 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for f
    int64_t _65 = 177;
    _63.d1 = _65;
    if (_65 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= _64;
    _66 *= _65;
    _66 *= sizeof(int64_t);
    _63.data = jpl_alloc(_66);
    int64_t _67 = 0; // f
    int64_t _68 = 0; // e
    _jump37:; // Begin body of loop
    int64_t _69 = 0;
    _69 *= _63.d0;
    _69 += _68;
    _69 *= _63.d1;
    _69 += _67;
    _63.data[_69] = _68;
    _67++;
    if (_67 < _65)
    goto _jump37;
    _67 = 0;
    _68++;
    if (_68 < _64)
    goto _jump37;
    // End body of loop
    int64_t _70 = _48 - _48;
    int64_t _71 = a(b, c);
    if (_70 >= 0)
    goto _jump38;
    fail_assertion("negative array index");
    _jump38:;
    if (_70 < _63.d0)
    goto _jump39;
    fail_assertion("index too large");
    _jump39:;
    if (_71 >= 0)
    goto _jump40;
    fail_assertion("negative array index");
    _jump40:;
    if (_71 < _63.d1)
    goto _jump41;
    fail_assertion("index too large");
    _jump41:;
    int64_t _72 = 0;
    _72 *= _63.d0;
    _72 += _70;
    _72 *= _63.d1;
    _72 += _71;
    int64_t _73 = _63.data[_72];
    int64_t _74 = -_73;
    int64_t _75 = _62 % _74;
    int64_t _76 = 142;
    if (_75 >= 0)
    goto _jump42;
    fail_assertion("negative array index");
    _jump42:;
    if (_75 < _49.d0)
    goto _jump43;
    fail_assertion("index too large");
    _jump43:;
    if (_48 >= 0)
    goto _jump44;
    fail_assertion("negative array index");
    _jump44:;
    if (_48 < _49.d1)
    goto _jump45;
    fail_assertion("index too large");
    _jump45:;
    if (_76 >= 0)
    goto _jump46;
    fail_assertion("negative array index");
    _jump46:;
    if (_76 < _49.d2)
    goto _jump47;
    fail_assertion("index too large");
    _jump47:;
    int64_t _77 = 0;
    _77 *= _49.d0;
    _77 += _75;
    _77 *= _49.d1;
    _77 += _48;
    _77 *= _49.d2;
    _77 += _76;
    int64_t _78 = _49.data[_77];
    _17 += _78;
    _48++;
    if (_48 < _47)
    goto _jump28;
    // End body of loop
    _0.d1 = _17;
    if (_17 > 0) 
    goto _jump48;
    fail_assertion("non-positive loop bound");
    _jump48:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= _16;
    _79 *= _17;
    _79 *= sizeof(_a1_int64_t);
    _0.data = jpl_alloc(_79);
    int64_t _80 = 0; // e
    int64_t _81 = 0; // d
    _jump49:; // Begin body of loop
    int64_t _83;
    // Computing bound for f
    if (_80 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    _83 = 0;
    int64_t _84 = 0; // f
    _jump51:; // Begin body of loop
    _83 += _84;
    _84++;
    if (_84 < _80)
    goto _jump51;
    // End body of loop
    int64_t _85 = _83 * _81;
    int64_t _86 = 767;
    if (_85 >= 0)
    goto _jump52;
    fail_assertion("negative array index");
    _jump52:;
    if (_85 < b.d0)
    goto _jump53;
    fail_assertion("index too large");
    _jump53:;
    if (_86 >= 0)
    goto _jump54;
    fail_assertion("negative array index");
    _jump54:;
    if (_86 < b.d1)
    goto _jump55;
    fail_assertion("index too large");
    _jump55:;
    int64_t _87 = 0;
    _87 *= b.d0;
    _87 += _85;
    _87 *= b.d1;
    _87 += _86;
    bool _88 = b.data[_87];
    bool _82 = _88;
    if (0 == _88)
    goto _jump56;
    bool _89 = false;
    bool _90 = true;
    bool _91 = _89 == _90;
    int64_t _92;
    // Computing bound for f
    if (_80 > 0) 
    goto _jump57;
    fail_assertion("non-positive loop bound");
    _jump57:;
    // Computing bound for g
    int64_t _93 = 466;
    if (_93 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    // Computing bound for h
    if (_80 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    _92 = 0;
    int64_t _94 = 0; // h
    int64_t _95 = 0; // g
    int64_t _96 = 0; // f
    _jump60:; // Begin body of loop
    int64_t _97 = 16;
    _92 += _97;
    _94++;
    if (_94 < _80)
    goto _jump60;
    _94 = 0;
    _95++;
    if (_95 < _93)
    goto _jump60;
    _95 = 0;
    _96++;
    if (_96 < _80)
    goto _jump60;
    // End body of loop
    bool _98 = _81 != _92;
    bool _99 = _91 != _98;
    _82 = _99;
    _jump56:;
    int64_t _100;
    if (!_82)
    goto _jump61;
    int64_t _101 = 72;
    int64_t _102 = -_101;
    _100 = _102;
    goto _jump62;
    _jump61:;
    bool _103 = _80 == _80;
    bool _104 = !_103;
    _a2_bool _105;
    if (!_104)
    goto _jump63;
    _a2_bool _106;
    // Computing bound for f
    _106.d0 = _80;
    if (_80 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing bound for g
    int64_t _107 = 348;
    _106.d1 = _107;
    if (_107 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= _80;
    _108 *= _107;
    _108 *= sizeof(bool);
    _106.data = jpl_alloc(_108);
    int64_t _109 = 0; // g
    int64_t _110 = 0; // f
    _jump66:; // Begin body of loop
    int64_t _111 = 311;
    if (_81 >= 0)
    goto _jump67;
    fail_assertion("negative array index");
    _jump67:;
    if (_81 < b.d0)
    goto _jump68;
    fail_assertion("index too large");
    _jump68:;
    if (_111 >= 0)
    goto _jump69;
    fail_assertion("negative array index");
    _jump69:;
    if (_111 < b.d1)
    goto _jump70;
    fail_assertion("index too large");
    _jump70:;
    int64_t _112 = 0;
    _112 *= b.d0;
    _112 += _81;
    _112 *= b.d1;
    _112 += _111;
    bool _113 = b.data[_112];
    int64_t _114 = 0;
    _114 *= _106.d0;
    _114 += _110;
    _114 *= _106.d1;
    _114 += _109;
    _106.data[_114] = _113;
    _109++;
    if (_109 < _107)
    goto _jump66;
    _109 = 0;
    _110++;
    if (_110 < _80)
    goto _jump66;
    // End body of loop
    _105 = _106;
    goto _jump71;
    _jump63:;
    _a2_bool _115;
    // Computing bound for f
    _115.d0 = _81;
    if (_81 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing bound for g
    int64_t _116 = 659;
    int64_t _117 = -_116;
    _115.d1 = _117;
    if (_117 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= _81;
    _118 *= _117;
    _118 *= sizeof(bool);
    _115.data = jpl_alloc(_118);
    int64_t _119 = 0; // g
    int64_t _120 = 0; // f
    _jump74:; // Begin body of loop
    bool _121 = false;
    int64_t _122 = 0;
    _122 *= _115.d0;
    _122 += _120;
    _122 *= _115.d1;
    _122 += _119;
    _115.data[_122] = _121;
    _119++;
    if (_119 < _117)
    goto _jump74;
    _119 = 0;
    _120++;
    if (_120 < _81)
    goto _jump74;
    // End body of loop
    _105 = _115;
    _jump71:;
    _a3_void_t _123;
    // Computing bound for f
    int64_t _124;
    // Computing bound for f
    int64_t _125 = 673;
    if (_125 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for g
    if (_80 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for h
    int64_t _126 = 981;
    if (_126 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    _124 = 0;
    int64_t _127 = 0; // h
    int64_t _128 = 0; // g
    int64_t _129 = 0; // f
    _jump78:; // Begin body of loop
    _124 += _129;
    _127++;
    if (_127 < _126)
    goto _jump78;
    _127 = 0;
    _128++;
    if (_128 < _80)
    goto _jump78;
    _128 = 0;
    _129++;
    if (_129 < _125)
    goto _jump78;
    // End body of loop
    _123.d0 = _124;
    if (_124 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing bound for g
    _123.d1 = _81;
    if (_81 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    // Computing bound for h
    _123.d2 = _81;
    if (_81 > 0) 
    goto _jump81;
    fail_assertion("non-positive loop bound");
    _jump81:;
    // Computing total size of heap memory to allocate
    int64_t _130 = 1;
    _130 *= _124;
    _130 *= _81;
    _130 *= _81;
    _130 *= sizeof(void_t);
    _123.data = jpl_alloc(_130);
    int64_t _131 = 0; // h
    int64_t _132 = 0; // g
    int64_t _133 = 0; // f
    _jump82:; // Begin body of loop
    int64_t _134 = 0;
    _134 *= _123.d0;
    _134 += _133;
    _134 *= _123.d1;
    _134 += _132;
    _134 *= _123.d2;
    _134 += _131;
    _123.data[_134] = c;
    _131++;
    if (_131 < _81)
    goto _jump82;
    _131 = 0;
    _132++;
    if (_132 < _81)
    goto _jump82;
    _132 = 0;
    _133++;
    if (_133 < _124)
    goto _jump82;
    // End body of loop
    int64_t _135 = 526;
    bool _136 = true;
    void_t _137;
    if (!_136)
    goto _jump83;
    _137 = c;
    goto _jump84;
    _jump83:;
    _137 = c;
    _jump84:;
    int64_t _138 = a(b, _137);
    int64_t _139 = 297;
    if (_135 >= 0)
    goto _jump85;
    fail_assertion("negative array index");
    _jump85:;
    if (_135 < _123.d0)
    goto _jump86;
    fail_assertion("index too large");
    _jump86:;
    if (_138 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_138 < _123.d1)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    if (_139 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (_139 < _123.d2)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    int64_t _140 = 0;
    _140 *= _123.d0;
    _140 += _135;
    _140 *= _123.d1;
    _140 += _138;
    _140 *= _123.d2;
    _140 += _139;
    void_t _141 = _123.data[_140];
    int64_t _142 = a(_105, _141);
    _100 = _142;
    _jump62:;
    _a1_int64_t _143;
    _143.d0 = 1;
    _143.data = jpl_alloc(sizeof(int64_t) * 1);
    _143.data[0] = _100;
    int64_t _144 = 0;
    _144 *= _0.d0;
    _144 += _81;
    _144 *= _0.d1;
    _144 += _80;
    _0.data[_144] = _143;
    _80++;
    if (_80 < _17)
    goto _jump49;
    _80 = 0;
    _81++;
    if (_81 < _16)
    goto _jump49;
    // End body of loop
    _a1_double _145;
    // Computing bound for g
    int64_t _146 = 451;
    int64_t _147 = _146 + _0.d0;
    bool _148 = _0.d1 < _147;
    _a2_int64_t _149;
    if (!_148)
    goto _jump91;
    _a2_int64_t _150;
    // Computing bound for g
    _150.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    // Computing bound for h
    int64_t _151 = 412;
    _150.d1 = _151;
    if (_151 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= _0.d0;
    _152 *= _151;
    _152 *= sizeof(int64_t);
    _150.data = jpl_alloc(_152);
    int64_t _153 = 0; // h
    int64_t _154 = 0; // g
    _jump94:; // Begin body of loop
    int64_t _155 = 319;
    int64_t _156 = 0;
    _156 *= _150.d0;
    _156 += _154;
    _156 *= _150.d1;
    _156 += _153;
    _150.data[_156] = _155;
    _153++;
    if (_153 < _151)
    goto _jump94;
    _153 = 0;
    _154++;
    if (_154 < _0.d0)
    goto _jump94;
    // End body of loop
    _149 = _150;
    goto _jump95;
    _jump91:;
    _a2_int64_t _157;
    // Computing bound for g
    _157.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing bound for h
    int64_t _158 = _0.d0 * _0.d1;
    _157.d1 = _158;
    if (_158 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _0.d0;
    _159 *= _158;
    _159 *= sizeof(int64_t);
    _157.data = jpl_alloc(_159);
    int64_t _160 = 0; // h
    int64_t _161 = 0; // g
    _jump98:; // Begin body of loop
    int64_t _162 = a(b, c);
    int64_t _163 = 0;
    _163 *= _157.d0;
    _163 += _161;
    _163 *= _157.d1;
    _163 += _160;
    _157.data[_163] = _162;
    _160++;
    if (_160 < _158)
    goto _jump98;
    _160 = 0;
    _161++;
    if (_161 < _0.d0)
    goto _jump98;
    // End body of loop
    _149 = _157;
    _jump95:;
    int64_t _164 = a(b, c);
    int64_t _165 = -_164;
    if (_165 >= 0)
    goto _jump99;
    fail_assertion("negative array index");
    _jump99:;
    if (_165 < _149.d0)
    goto _jump100;
    fail_assertion("index too large");
    _jump100:;
    if (_0.d1 >= 0)
    goto _jump101;
    fail_assertion("negative array index");
    _jump101:;
    if (_0.d1 < _149.d1)
    goto _jump102;
    fail_assertion("index too large");
    _jump102:;
    int64_t _166 = 0;
    _166 *= _149.d0;
    _166 += _165;
    _166 *= _149.d1;
    _166 += _0.d1;
    int64_t _167 = _149.data[_166];
    bool _168 = _0.d1 >= _167;
    int64_t _169;
    if (!_168)
    goto _jump103;
    _169 = _0.d0;
    goto _jump104;
    _jump103:;
    double _170 = 75.0;
    double _171 = 15.0;
    bool _172 = _170 == _171;
    _a1_bool _173;
    _173.d0 = 1;
    _173.data = jpl_alloc(sizeof(bool) * 1);
    _173.data[0] = _172;
    bool _174 = false;
    int64_t _175;
    if (!_174)
    goto _jump105;
    _175 = _0.d1;
    goto _jump106;
    _jump105:;
    _175 = _0.d0;
    _jump106:;
    if (_175 >= 0)
    goto _jump107;
    fail_assertion("negative array index");
    _jump107:;
    if (_175 < _173.d0)
    goto _jump108;
    fail_assertion("index too large");
    _jump108:;
    int64_t _176 = 0;
    _176 *= _173.d0;
    _176 += _175;
    bool _177 = _173.data[_176];
    _a2_int64_t _178;
    if (!_177)
    goto _jump109;
    _a2_int64_t _179;
    // Computing bound for g
    int64_t _180 = 872;
    _179.d0 = _180;
    if (_180 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing bound for h
    int64_t _181 = _0.d1 - _0.d1;
    int64_t _182 = -_181;
    _179.d1 = _182;
    if (_182 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= _180;
    _183 *= _182;
    _183 *= sizeof(int64_t);
    _179.data = jpl_alloc(_183);
    int64_t _184 = 0; // h
    int64_t _185 = 0; // g
    _jump112:; // Begin body of loop
    _a3_int64_t _186;
    // Computing bound for i
    _186.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    // Computing bound for j
    _186.d1 = _184;
    if (_184 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    // Computing bound for k
    _186.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= _0.d0;
    _187 *= _184;
    _187 *= _0.d1;
    _187 *= sizeof(int64_t);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // k
    int64_t _189 = 0; // j
    int64_t _190 = 0; // i
    _jump116:; // Begin body of loop
    int64_t _191 = 0;
    _191 *= _186.d0;
    _191 += _190;
    _191 *= _186.d1;
    _191 += _189;
    _191 *= _186.d2;
    _191 += _188;
    _186.data[_191] = _188;
    _188++;
    if (_188 < _0.d1)
    goto _jump116;
    _188 = 0;
    _189++;
    if (_189 < _184)
    goto _jump116;
    _189 = 0;
    _190++;
    if (_190 < _0.d0)
    goto _jump116;
    // End body of loop
    bool _192 = true;
    int64_t _193;
    if (!_192)
    goto _jump117;
    _193 = _184;
    goto _jump118;
    _jump117:;
    _193 = _0.d1;
    _jump118:;
    int64_t _194 = _0.d0 + _0.d1;
    int64_t _195 = _184 + _0.d0;
    if (_193 >= 0)
    goto _jump119;
    fail_assertion("negative array index");
    _jump119:;
    if (_193 < _186.d0)
    goto _jump120;
    fail_assertion("index too large");
    _jump120:;
    if (_194 >= 0)
    goto _jump121;
    fail_assertion("negative array index");
    _jump121:;
    if (_194 < _186.d1)
    goto _jump122;
    fail_assertion("index too large");
    _jump122:;
    if (_195 >= 0)
    goto _jump123;
    fail_assertion("negative array index");
    _jump123:;
    if (_195 < _186.d2)
    goto _jump124;
    fail_assertion("index too large");
    _jump124:;
    int64_t _196 = 0;
    _196 *= _186.d0;
    _196 += _193;
    _196 *= _186.d1;
    _196 += _194;
    _196 *= _186.d2;
    _196 += _195;
    int64_t _197 = _186.data[_196];
    int64_t _198 = 0;
    _198 *= _179.d0;
    _198 += _185;
    _198 *= _179.d1;
    _198 += _184;
    _179.data[_198] = _197;
    _184++;
    if (_184 < _182)
    goto _jump112;
    _184 = 0;
    _185++;
    if (_185 < _180)
    goto _jump112;
    // End body of loop
    _178 = _179;
    goto _jump125;
    _jump109:;
    bool _199 = true;
    _a2_int64_t _200;
    if (!_199)
    goto _jump126;
    _a2_int64_t _201;
    // Computing bound for g
    int64_t _202 = 709;
    _201.d0 = _202;
    if (_202 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for h
    int64_t _203;
    // Computing bound for g
    if (_0.d1 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    _203 = 0;
    int64_t _204 = 0; // g
    _jump129:; // Begin body of loop
    _203 += _204;
    _204++;
    if (_204 < _0.d1)
    goto _jump129;
    // End body of loop
    _201.d1 = _203;
    if (_203 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _202;
    _205 *= _203;
    _205 *= sizeof(int64_t);
    _201.data = jpl_alloc(_205);
    int64_t _206 = 0; // h
    int64_t _207 = 0; // g
    _jump131:; // Begin body of loop
    int64_t _208 = 0;
    _208 *= _201.d0;
    _208 += _207;
    _208 *= _201.d1;
    _208 += _206;
    _201.data[_208] = _206;
    _206++;
    if (_206 < _203)
    goto _jump131;
    _206 = 0;
    _207++;
    if (_207 < _202)
    goto _jump131;
    // End body of loop
    _200 = _201;
    goto _jump132;
    _jump126:;
    _a2_int64_t _209;
    // Computing bound for g
    int64_t _210 = 856;
    _209.d0 = _210;
    if (_210 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    // Computing bound for h
    int64_t _211 = 270;
    _209.d1 = _211;
    if (_211 > 0) 
    goto _jump134;
    fail_assertion("non-positive loop bound");
    _jump134:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= _210;
    _212 *= _211;
    _212 *= sizeof(int64_t);
    _209.data = jpl_alloc(_212);
    int64_t _213 = 0; // h
    int64_t _214 = 0; // g
    _jump135:; // Begin body of loop
    int64_t _215 = 0;
    _215 *= _209.d0;
    _215 += _214;
    _215 *= _209.d1;
    _215 += _213;
    _209.data[_215] = _0.d0;
    _213++;
    if (_213 < _211)
    goto _jump135;
    _213 = 0;
    _214++;
    if (_214 < _210)
    goto _jump135;
    // End body of loop
    _200 = _209;
    _jump132:;
    _178 = _200;
    _jump125:;
    int64_t _216;
    // Computing bound for g
    int64_t _217 = 521;
    int64_t _218 = _217 * _0.d0;
    if (_218 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    // Computing bound for h
    int64_t _219;
    // Computing bound for g
    if (_0.d0 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    _219 = 0;
    int64_t _220 = 0; // g
    _jump138:; // Begin body of loop
    int64_t _221;
    // Computing bound for h
    int64_t _222 = 359;
    if (_222 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing bound for i
    int64_t _223 = -_220;
    if (_223 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    _221 = 0;
    int64_t _224 = 0; // i
    int64_t _225 = 0; // h
    _jump141:; // Begin body of loop
    _221 += _0.d1;
    _224++;
    if (_224 < _223)
    goto _jump141;
    _224 = 0;
    _225++;
    if (_225 < _222)
    goto _jump141;
    // End body of loop
    _219 += _221;
    _220++;
    if (_220 < _0.d0)
    goto _jump138;
    // End body of loop
    if (_219 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    _216 = 0;
    int64_t _226 = 0; // h
    int64_t _227 = 0; // g
    _jump143:; // Begin body of loop
    int64_t _228 = 508;
    int64_t _229 = -_228;
    _216 += _229;
    _226++;
    if (_226 < _219)
    goto _jump143;
    _226 = 0;
    _227++;
    if (_227 < _218)
    goto _jump143;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump144;
    fail_assertion("negative array index");
    _jump144:;
    if (_0.d1 < _178.d0)
    goto _jump145;
    fail_assertion("index too large");
    _jump145:;
    if (_216 >= 0)
    goto _jump146;
    fail_assertion("negative array index");
    _jump146:;
    if (_216 < _178.d1)
    goto _jump147;
    fail_assertion("index too large");
    _jump147:;
    int64_t _230 = 0;
    _230 *= _178.d0;
    _230 += _0.d1;
    _230 *= _178.d1;
    _230 += _216;
    int64_t _231 = _178.data[_230];
    _169 = _231;
    _jump104:;
    _145.d0 = _169;
    if (_169 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= _169;
    _232 *= sizeof(double);
    _145.data = jpl_alloc(_232);
    int64_t _233 = 0; // g
    _jump149:; // Begin body of loop
    _a3_double _234;
    // Computing bound for h
    bool _235 = _0.d1 != _0.d0;
    _a2_bool _236;
    if (!_235)
    goto _jump150;
    _a2_bool _237;
    // Computing bound for h
    _237.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump151;
    fail_assertion("non-positive loop bound");
    _jump151:;
    // Computing bound for i
    _237.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing total size of heap memory to allocate
    int64_t _238 = 1;
    _238 *= _0.d1;
    _238 *= _0.d0;
    _238 *= sizeof(bool);
    _237.data = jpl_alloc(_238);
    int64_t _239 = 0; // i
    int64_t _240 = 0; // h
    _jump153:; // Begin body of loop
    bool _241 = false;
    int64_t _242 = 0;
    _242 *= _237.d0;
    _242 += _240;
    _242 *= _237.d1;
    _242 += _239;
    _237.data[_242] = _241;
    _239++;
    if (_239 < _0.d0)
    goto _jump153;
    _239 = 0;
    _240++;
    if (_240 < _0.d1)
    goto _jump153;
    // End body of loop
    _236 = _237;
    goto _jump154;
    _jump150:;
    _236 = b;
    _jump154:;
    int64_t _243 = a(_236, c);
    _234.d0 = _243;
    if (_243 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing bound for i
    int64_t _244;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    _244 = 0;
    int64_t _245 = 0; // h
    _jump157:; // Begin body of loop
    int64_t _246 = -_0.d0;
    _244 += _246;
    _245++;
    if (_245 < _0.d1)
    goto _jump157;
    // End body of loop
    _234.d1 = _244;
    if (_244 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    // Computing bound for j
    int64_t _247;
    // Computing bound for h
    int64_t _248 = a(b, c);
    if (_248 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing bound for i
    int64_t _249 = 184;
    int64_t _250 = _249 - _0.d0;
    if (_250 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    // Computing bound for j
    if (_233 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    _247 = 0;
    int64_t _251 = 0; // j
    int64_t _252 = 0; // i
    int64_t _253 = 0; // h
    _jump162:; // Begin body of loop
    _247 += _0.d1;
    _251++;
    if (_251 < _233)
    goto _jump162;
    _251 = 0;
    _252++;
    if (_252 < _250)
    goto _jump162;
    _252 = 0;
    _253++;
    if (_253 < _248)
    goto _jump162;
    // End body of loop
    _234.d2 = _247;
    if (_247 > 0) 
    goto _jump163;
    fail_assertion("non-positive loop bound");
    _jump163:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= _243;
    _254 *= _244;
    _254 *= _247;
    _254 *= sizeof(double);
    _234.data = jpl_alloc(_254);
    int64_t _255 = 0; // j
    int64_t _256 = 0; // i
    int64_t _257 = 0; // h
    _jump164:; // Begin body of loop
    int64_t _259 = 465;
    bool _260 = _259 >= _0.d0;
    bool _258 = _260;
    if (0 != _260)
    goto _jump165;
    bool _262 = false;
    bool _261 = _262;
    if (0 == _262)
    goto _jump166;
    bool _263 = false;
    _261 = _263;
    _jump166:;
    _258 = _261;
    _jump165:;
    double _264;
    if (!_258)
    goto _jump167;
    double _265 = 7.0;
    _264 = _265;
    goto _jump168;
    _jump167:;
    _a2_double _266;
    // Computing bound for k
    _266.d0 = _257;
    if (_257 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    // Computing bound for l
    _266.d1 = _255;
    if (_255 > 0) 
    goto _jump170;
    fail_assertion("non-positive loop bound");
    _jump170:;
    // Computing total size of heap memory to allocate
    int64_t _267 = 1;
    _267 *= _257;
    _267 *= _255;
    _267 *= sizeof(double);
    _266.data = jpl_alloc(_267);
    int64_t _268 = 0; // l
    int64_t _269 = 0; // k
    _jump171:; // Begin body of loop
    double _270 = 22.0;
    int64_t _271 = 0;
    _271 *= _266.d0;
    _271 += _269;
    _271 *= _266.d1;
    _271 += _268;
    _266.data[_271] = _270;
    _268++;
    if (_268 < _255)
    goto _jump171;
    _268 = 0;
    _269++;
    if (_269 < _257)
    goto _jump171;
    // End body of loop
    int64_t _272 = 547;
    if (_272 >= 0)
    goto _jump172;
    fail_assertion("negative array index");
    _jump172:;
    if (_272 < _266.d0)
    goto _jump173;
    fail_assertion("index too large");
    _jump173:;
    if (_0.d1 >= 0)
    goto _jump174;
    fail_assertion("negative array index");
    _jump174:;
    if (_0.d1 < _266.d1)
    goto _jump175;
    fail_assertion("index too large");
    _jump175:;
    int64_t _273 = 0;
    _273 *= _266.d0;
    _273 += _272;
    _273 *= _266.d1;
    _273 += _0.d1;
    double _274 = _266.data[_273];
    _264 = _274;
    _jump168:;
    int64_t _275 = 0;
    _275 *= _234.d0;
    _275 += _257;
    _275 *= _234.d1;
    _275 += _256;
    _275 *= _234.d2;
    _275 += _255;
    _234.data[_275] = _264;
    _255++;
    if (_255 < _247)
    goto _jump164;
    _255 = 0;
    _256++;
    if (_256 < _244)
    goto _jump164;
    _256 = 0;
    _257++;
    if (_257 < _243)
    goto _jump164;
    // End body of loop
    int64_t _276 = -_233;
    _a2__a2_bool _277;
    // Computing bound for h
    int64_t _278 = -_0.d0;
    _277.d0 = _278;
    if (_278 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    // Computing bound for i
    _277.d1 = _233;
    if (_233 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing total size of heap memory to allocate
    int64_t _279 = 1;
    _279 *= _278;
    _279 *= _233;
    _279 *= sizeof(_a2_bool);
    _277.data = jpl_alloc(_279);
    int64_t _280 = 0; // i
    int64_t _281 = 0; // h
    _jump178:; // Begin body of loop
    int64_t _282 = 0;
    _282 *= _277.d0;
    _282 += _281;
    _282 *= _277.d1;
    _282 += _280;
    _277.data[_282] = b;
    _280++;
    if (_280 < _233)
    goto _jump178;
    _280 = 0;
    _281++;
    if (_281 < _278)
    goto _jump178;
    // End body of loop
    int64_t _283 = -_0.d0;
    if (_0.d0 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_0.d0 < _277.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    if (_283 >= 0)
    goto _jump181;
    fail_assertion("negative array index");
    _jump181:;
    if (_283 < _277.d1)
    goto _jump182;
    fail_assertion("index too large");
    _jump182:;
    int64_t _284 = 0;
    _284 *= _277.d0;
    _284 += _0.d0;
    _284 *= _277.d1;
    _284 += _283;
    _a2_bool _285 = _277.data[_284];
    int64_t _286 = a(_285, c);
    if (_276 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (_276 < _234.d0)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    if (_233 >= 0)
    goto _jump185;
    fail_assertion("negative array index");
    _jump185:;
    if (_233 < _234.d1)
    goto _jump186;
    fail_assertion("index too large");
    _jump186:;
    if (_286 >= 0)
    goto _jump187;
    fail_assertion("negative array index");
    _jump187:;
    if (_286 < _234.d2)
    goto _jump188;
    fail_assertion("index too large");
    _jump188:;
    int64_t _287 = 0;
    _287 *= _234.d0;
    _287 += _276;
    _287 *= _234.d1;
    _287 += _233;
    _287 *= _234.d2;
    _287 += _286;
    double _288 = _234.data[_287];
    double _289;
    // Computing bound for h
    _a3_int64_t _290;
    // Computing bound for h
    _a3_int64_t _291;
    // Computing bound for h
    _291.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing bound for i
    int64_t _292 = 119;
    _291.d1 = _292;
    if (_292 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing bound for j
    _291.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump191;
    fail_assertion("non-positive loop bound");
    _jump191:;
    // Computing total size of heap memory to allocate
    int64_t _293 = 1;
    _293 *= _0.d0;
    _293 *= _292;
    _293 *= _0.d0;
    _293 *= sizeof(int64_t);
    _291.data = jpl_alloc(_293);
    int64_t _294 = 0; // j
    int64_t _295 = 0; // i
    int64_t _296 = 0; // h
    _jump192:; // Begin body of loop
    int64_t _297 = 0;
    _297 *= _291.d0;
    _297 += _296;
    _297 *= _291.d1;
    _297 += _295;
    _297 *= _291.d2;
    _297 += _294;
    _291.data[_297] = _295;
    _294++;
    if (_294 < _0.d0)
    goto _jump192;
    _294 = 0;
    _295++;
    if (_295 < _292)
    goto _jump192;
    _295 = 0;
    _296++;
    if (_296 < _0.d0)
    goto _jump192;
    // End body of loop
    int64_t _298 = -_0.d0;
    if (_0.d0 >= 0)
    goto _jump193;
    fail_assertion("negative array index");
    _jump193:;
    if (_0.d0 < _291.d0)
    goto _jump194;
    fail_assertion("index too large");
    _jump194:;
    if (_0.d0 >= 0)
    goto _jump195;
    fail_assertion("negative array index");
    _jump195:;
    if (_0.d0 < _291.d1)
    goto _jump196;
    fail_assertion("index too large");
    _jump196:;
    if (_298 >= 0)
    goto _jump197;
    fail_assertion("negative array index");
    _jump197:;
    if (_298 < _291.d2)
    goto _jump198;
    fail_assertion("index too large");
    _jump198:;
    int64_t _299 = 0;
    _299 *= _291.d0;
    _299 += _0.d0;
    _299 *= _291.d1;
    _299 += _0.d0;
    _299 *= _291.d2;
    _299 += _298;
    int64_t _300 = _291.data[_299];
    _290.d0 = _300;
    if (_300 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    // Computing bound for i
    int64_t _301 = a(b, c);
    int64_t _302 = -_301;
    _290.d1 = _302;
    if (_302 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing bound for j
    int64_t _303 = 988;
    _290.d2 = _303;
    if (_303 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing total size of heap memory to allocate
    int64_t _304 = 1;
    _304 *= _300;
    _304 *= _302;
    _304 *= _303;
    _304 *= sizeof(int64_t);
    _290.data = jpl_alloc(_304);
    int64_t _305 = 0; // j
    int64_t _306 = 0; // i
    int64_t _307 = 0; // h
    _jump202:; // Begin body of loop
    int64_t _308 = 0;
    _308 *= _290.d0;
    _308 += _307;
    _308 *= _290.d1;
    _308 += _306;
    _308 *= _290.d2;
    _308 += _305;
    _290.data[_308] = _0.d1;
    _305++;
    if (_305 < _303)
    goto _jump202;
    _305 = 0;
    _306++;
    if (_306 < _302)
    goto _jump202;
    _306 = 0;
    _307++;
    if (_307 < _300)
    goto _jump202;
    // End body of loop
    int64_t _309 = 549;
    int64_t _310 = _309 * _0.d0;
    _a1_int64_t _311;
    _311.d0 = 1;
    _311.data = jpl_alloc(sizeof(int64_t) * 1);
    _311.data[0] = _310;
    int64_t _312 = 69;
    if (_312 >= 0)
    goto _jump203;
    fail_assertion("negative array index");
    _jump203:;
    if (_312 < _311.d0)
    goto _jump204;
    fail_assertion("index too large");
    _jump204:;
    int64_t _313 = 0;
    _313 *= _311.d0;
    _313 += _312;
    int64_t _314 = _311.data[_313];
    bool _315 = false;
    void_t _316;
    if (!_315)
    goto _jump205;
    _316 = c;
    goto _jump206;
    _jump205:;
    _316 = c;
    _jump206:;
    int64_t _317 = a(b, _316);
    _a2_void_t _318;
    // Computing bound for h
    _318.d0 = _233;
    if (_233 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing bound for i
    _318.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= _233;
    _319 *= _0.d1;
    _319 *= sizeof(void_t);
    _318.data = jpl_alloc(_319);
    int64_t _320 = 0; // i
    int64_t _321 = 0; // h
    _jump209:; // Begin body of loop
    int64_t _322 = 0;
    _322 *= _318.d0;
    _322 += _321;
    _322 *= _318.d1;
    _322 += _320;
    _318.data[_322] = c;
    _320++;
    if (_320 < _0.d1)
    goto _jump209;
    _320 = 0;
    _321++;
    if (_321 < _233)
    goto _jump209;
    // End body of loop
    int64_t _323;
    // Computing bound for h
    if (_0.d0 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for i
    if (_233 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    _323 = 0;
    int64_t _324 = 0; // i
    int64_t _325 = 0; // h
    _jump212:; // Begin body of loop
    _323 += _0.d0;
    _324++;
    if (_324 < _233)
    goto _jump212;
    _324 = 0;
    _325++;
    if (_325 < _0.d0)
    goto _jump212;
    // End body of loop
    if (_323 >= 0)
    goto _jump213;
    fail_assertion("negative array index");
    _jump213:;
    if (_323 < _318.d0)
    goto _jump214;
    fail_assertion("index too large");
    _jump214:;
    if (_0.d1 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (_0.d1 < _318.d1)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    int64_t _326 = 0;
    _326 *= _318.d0;
    _326 += _323;
    _326 *= _318.d1;
    _326 += _0.d1;
    void_t _327 = _318.data[_326];
    int64_t _328 = a(b, _327);
    if (_314 >= 0)
    goto _jump217;
    fail_assertion("negative array index");
    _jump217:;
    if (_314 < _290.d0)
    goto _jump218;
    fail_assertion("index too large");
    _jump218:;
    if (_317 >= 0)
    goto _jump219;
    fail_assertion("negative array index");
    _jump219:;
    if (_317 < _290.d1)
    goto _jump220;
    fail_assertion("index too large");
    _jump220:;
    if (_328 >= 0)
    goto _jump221;
    fail_assertion("negative array index");
    _jump221:;
    if (_328 < _290.d2)
    goto _jump222;
    fail_assertion("index too large");
    _jump222:;
    int64_t _329 = 0;
    _329 *= _290.d0;
    _329 += _314;
    _329 *= _290.d1;
    _329 += _317;
    _329 *= _290.d2;
    _329 += _328;
    int64_t _330 = _290.data[_329];
    if (_330 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing bound for i
    int64_t _331 = 888;
    if (_331 > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    // Computing bound for j
    _a3_int64_t _332;
    // Computing bound for h
    int64_t _333 = a(b, c);
    int64_t _334 = _333 + _0.d0;
    _332.d0 = _334;
    if (_334 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for i
    int64_t _335 = 433;
    _332.d1 = _335;
    if (_335 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for j
    int64_t _336 = a(b, c);
    _332.d2 = _336;
    if (_336 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= _334;
    _337 *= _335;
    _337 *= _336;
    _337 *= sizeof(int64_t);
    _332.data = jpl_alloc(_337);
    int64_t _338 = 0; // j
    int64_t _339 = 0; // i
    int64_t _340 = 0; // h
    _jump228:; // Begin body of loop
    int64_t _341 = 0;
    _341 *= _332.d0;
    _341 += _340;
    _341 *= _332.d1;
    _341 += _339;
    _341 *= _332.d2;
    _341 += _338;
    _332.data[_341] = _0.d1;
    _338++;
    if (_338 < _336)
    goto _jump228;
    _338 = 0;
    _339++;
    if (_339 < _335)
    goto _jump228;
    _339 = 0;
    _340++;
    if (_340 < _334)
    goto _jump228;
    // End body of loop
    int64_t _342 = 671;
    int64_t _343 = a(b, c);
    int64_t _344 = _343 * _233;
    int64_t _345 = _0.d0 / _344;
    if (_233 >= 0)
    goto _jump229;
    fail_assertion("negative array index");
    _jump229:;
    if (_233 < _332.d0)
    goto _jump230;
    fail_assertion("index too large");
    _jump230:;
    if (_342 >= 0)
    goto _jump231;
    fail_assertion("negative array index");
    _jump231:;
    if (_342 < _332.d1)
    goto _jump232;
    fail_assertion("index too large");
    _jump232:;
    if (_345 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (_345 < _332.d2)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    int64_t _346 = 0;
    _346 *= _332.d0;
    _346 += _233;
    _346 *= _332.d1;
    _346 += _342;
    _346 *= _332.d2;
    _346 += _345;
    int64_t _347 = _332.data[_346];
    if (_347 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    _289 = 0;
    int64_t _348 = 0; // j
    int64_t _349 = 0; // i
    int64_t _350 = 0; // h
    _jump236:; // Begin body of loop
    bool _352 = true;
    bool _351 = _352;
    if (0 != _352)
    goto _jump237;
    bool _353 = false;
    _351 = _353;
    _jump237:;
    double _354;
    if (!_351)
    goto _jump238;
    double _355;
    // Computing bound for k
    int64_t _356 = 564;
    if (_356 > 0) 
    goto _jump239;
    fail_assertion("non-positive loop bound");
    _jump239:;
    _355 = 0;
    int64_t _357 = 0; // k
    _jump240:; // Begin body of loop
    double _358 = 31.0;
    _355 += _358;
    _357++;
    if (_357 < _356)
    goto _jump240;
    // End body of loop
    double _359 = -_355;
    _354 = _359;
    goto _jump241;
    _jump238:;
    double _360 = 78.0;
    _354 = _360;
    _jump241:;
    _289 += _354;
    _348++;
    if (_348 < _347)
    goto _jump236;
    _348 = 0;
    _349++;
    if (_349 < _331)
    goto _jump236;
    _349 = 0;
    _350++;
    if (_350 < _330)
    goto _jump236;
    // End body of loop
    double _361 = _288 * _289;
    int64_t _362 = 0;
    _362 *= _145.d0;
    _362 += _233;
    _145.data[_362] = _361;
    _233++;
    if (_233 < _169)
    goto _jump149;
    // End body of loop
    bool _363 = b.d0 == _0.d0;
    bool _364 = true;
    bool _365 = _363 != _364;
    bool _366 = !_365;
    bool _367;
    if (!_366)
    goto _jump242;
    bool _368 = false;
    _367 = _368;
    goto _jump243;
    _jump242:;
    double _369 = 46.0;
    double _370 = -_369;
    double _371 = 68.0;
    double _372 = -_371;
    bool _373 = _370 != _372;
    _367 = _373;
    _jump243:;
    _a2_bool _374;
    if (!_367)
    goto _jump244;
    _a1__a2_bool _375;
    // Computing bound for l
    int64_t _376 = -_0.d0;
    int64_t _377 = _0.d1 - _376;
    _375.d0 = _377;
    if (_377 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _378 = 1;
    _378 *= _377;
    _378 *= sizeof(_a2_bool);
    _375.data = jpl_alloc(_378);
    int64_t _379 = 0; // l
    _jump246:; // Begin body of loop
    _a2_bool _380;
    // Computing bound for m
    _380.d0 = b.d1;
    if (b.d1 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    // Computing bound for n
    _380.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump248;
    fail_assertion("non-positive loop bound");
    _jump248:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= b.d1;
    _381 *= _0.d0;
    _381 *= sizeof(bool);
    _380.data = jpl_alloc(_381);
    int64_t _382 = 0; // n
    int64_t _383 = 0; // m
    _jump249:; // Begin body of loop
    bool _384 = false;
    bool _385 = !_384;
    int64_t _386 = 0;
    _386 *= _380.d0;
    _386 += _383;
    _386 *= _380.d1;
    _386 += _382;
    _380.data[_386] = _385;
    _382++;
    if (_382 < _0.d0)
    goto _jump249;
    _382 = 0;
    _383++;
    if (_383 < b.d1)
    goto _jump249;
    // End body of loop
    int64_t _387 = 0;
    _387 *= _375.d0;
    _387 += _379;
    _375.data[_387] = _380;
    _379++;
    if (_379 < _377)
    goto _jump246;
    // End body of loop
    if (_145.d0 >= 0)
    goto _jump250;
    fail_assertion("negative array index");
    _jump250:;
    if (_145.d0 < _375.d0)
    goto _jump251;
    fail_assertion("index too large");
    _jump251:;
    int64_t _388 = 0;
    _388 *= _375.d0;
    _388 += _145.d0;
    _a2_bool _389 = _375.data[_388];
    _374 = _389;
    goto _jump252;
    _jump244:;
    bool _390 = true;
    _a2_bool _391;
    if (!_390)
    goto _jump253;
    _391 = b;
    goto _jump254;
    _jump253:;
    _391 = b;
    _jump254:;
    _374 = _391;
    _jump252:;
    _a1__a3_void_t _392;
    // Computing bound for l
    int64_t _393;
    // Computing bound for l
    if (_0.d1 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    _393 = 0;
    int64_t _394 = 0; // l
    _jump256:; // Begin body of loop
    _393 += b.d0;
    _394++;
    if (_394 < _0.d1)
    goto _jump256;
    // End body of loop
    int64_t _395 = _393 - b.d1;
    _392.d0 = _395;
    if (_395 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing total size of heap memory to allocate
    int64_t _396 = 1;
    _396 *= _395;
    _396 *= sizeof(_a3_void_t);
    _392.data = jpl_alloc(_396);
    int64_t _397 = 0; // l
    _jump258:; // Begin body of loop
    _a3_void_t _398;
    // Computing bound for m
    _398.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump259;
    fail_assertion("non-positive loop bound");
    _jump259:;
    // Computing bound for n
    int64_t _399;
    // Computing bound for m
    if (_145.d0 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    _399 = 0;
    int64_t _400 = 0; // m
    _jump261:; // Begin body of loop
    _399 += b.d1;
    _400++;
    if (_400 < _145.d0)
    goto _jump261;
    // End body of loop
    _398.d1 = _399;
    if (_399 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing bound for o
    _398.d2 = b.d0;
    if (b.d0 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing total size of heap memory to allocate
    int64_t _401 = 1;
    _401 *= _0.d0;
    _401 *= _399;
    _401 *= b.d0;
    _401 *= sizeof(void_t);
    _398.data = jpl_alloc(_401);
    int64_t _402 = 0; // o
    int64_t _403 = 0; // n
    int64_t _404 = 0; // m
    _jump264:; // Begin body of loop
    int64_t _405 = 0;
    _405 *= _398.d0;
    _405 += _404;
    _405 *= _398.d1;
    _405 += _403;
    _405 *= _398.d2;
    _405 += _402;
    _398.data[_405] = c;
    _402++;
    if (_402 < b.d0)
    goto _jump264;
    _402 = 0;
    _403++;
    if (_403 < _399)
    goto _jump264;
    _403 = 0;
    _404++;
    if (_404 < _0.d0)
    goto _jump264;
    // End body of loop
    int64_t _406 = 0;
    _406 *= _392.d0;
    _406 += _397;
    _392.data[_406] = _398;
    _397++;
    if (_397 < _395)
    goto _jump258;
    // End body of loop
    int64_t _407 = -b.d0;
    if (_407 >= 0)
    goto _jump265;
    fail_assertion("negative array index");
    _jump265:;
    if (_407 < _392.d0)
    goto _jump266;
    fail_assertion("index too large");
    _jump266:;
    int64_t _408 = 0;
    _408 *= _392.d0;
    _408 += _407;
    _a3_void_t _409 = _392.data[_408];
    if (b.d1 >= 0)
    goto _jump267;
    fail_assertion("negative array index");
    _jump267:;
    if (b.d1 < _409.d0)
    goto _jump268;
    fail_assertion("index too large");
    _jump268:;
    if (b.d1 >= 0)
    goto _jump269;
    fail_assertion("negative array index");
    _jump269:;
    if (b.d1 < _409.d1)
    goto _jump270;
    fail_assertion("index too large");
    _jump270:;
    if (_0.d0 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_0.d0 < _409.d2)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    int64_t _410 = 0;
    _410 *= _409.d0;
    _410 += b.d1;
    _410 *= _409.d1;
    _410 += b.d1;
    _410 *= _409.d2;
    _410 += _0.d0;
    void_t _411 = _409.data[_410];
    int64_t _412 = a(_374, _411);
    bool _413 = _412 <= b.d1;
    if (0 != _413)
    goto _jump273;
    fail_assertion("l");
    _jump273:;
    return b.d0;
}

void_t b(_a1_bool c, _a1_bool e) {
    _a2__a3_bool _0;
    // Computing bound for f
    _a1_bool _1;
    // Computing bound for f
    int64_t _2 = 466;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= sizeof(bool);
    _1.data = jpl_alloc(_3);
    int64_t _4 = 0; // f
    _jump275:; // Begin body of loop
    int64_t _5 = 534;
    int64_t _6 = 702;
    bool _7 = _5 >= _6;
    bool _8 = !_7;
    int64_t _9 = 0;
    _9 *= _1.d0;
    _9 += _4;
    _1.data[_9] = _8;
    _4++;
    if (_4 < _2)
    goto _jump275;
    // End body of loop
    int64_t _10 = 746;
    int64_t _11 = -_10;
    if (_11 >= 0)
    goto _jump276;
    fail_assertion("negative array index");
    _jump276:;
    if (_11 < _1.d0)
    goto _jump277;
    fail_assertion("index too large");
    _jump277:;
    int64_t _12 = 0;
    _12 *= _1.d0;
    _12 += _11;
    bool _13 = _1.data[_12];
    int64_t _14;
    if (!_13)
    goto _jump278;
    int64_t _15 = 51;
    bool _16 = true;
    bool _17;
    if (!_16)
    goto _jump279;
    bool _18 = false;
    _17 = _18;
    goto _jump280;
    _jump279:;
    bool _19 = true;
    _17 = _19;
    _jump280:;
    bool _20 = !_17;
    int64_t _21;
    if (!_20)
    goto _jump281;
    _21 = c.d0;
    goto _jump282;
    _jump281:;
    int64_t _22 = 330;
    int64_t _23 = 709;
    int64_t _24 = _22 - _23;
    _21 = _24;
    _jump282:;
    int64_t _25 = _15 % _21;
    _14 = _25;
    goto _jump283;
    _jump278:;
    int64_t _26 = 967;
    int64_t _27 = 898;
    int64_t _28 = _26 / _27;
    int64_t _29 = -c.d0;
    int64_t _30 = _29 * c.d0;
    int64_t _31 = _28 * _30;
    bool _32 = false;
    bool _33 = !_32;
    int64_t _34;
    if (!_33)
    goto _jump284;
    int64_t _35 = -c.d0;
    _34 = _35;
    goto _jump285;
    _jump284:;
    _34 = c.d0;
    _jump285:;
    int64_t _36 = _31 % _34;
    _14 = _36;
    _jump283:;
    int64_t _37 = -_14;
    _0.d0 = _37;
    if (_37 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing bound for g
    int64_t _38 = 85;
    int64_t _39 = -_38;
    _0.d1 = _39;
    if (_39 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= _37;
    _40 *= _39;
    _40 *= sizeof(_a3_bool);
    _0.data = jpl_alloc(_40);
    int64_t _41 = 0; // g
    int64_t _42 = 0; // f
    _jump288:; // Begin body of loop
    _a3_bool _43;
    // Computing bound for h
    bool _44 = true;
    bool _45 = !_44;
    int64_t _46;
    if (!_45)
    goto _jump289;
    int64_t _47;
    // Computing bound for h
    int64_t _48 = 207;
    int64_t _49 = _48 - c.d0;
    int64_t _50 = -_49;
    if (_50 > 0) 
    goto _jump290;
    fail_assertion("non-positive loop bound");
    _jump290:;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump291;
    fail_assertion("non-positive loop bound");
    _jump291:;
    _47 = 0;
    int64_t _51 = 0; // i
    int64_t _52 = 0; // h
    _jump292:; // Begin body of loop
    int64_t _53 = -_52;
    _47 += _53;
    _51++;
    if (_51 < c.d0)
    goto _jump292;
    _51 = 0;
    _52++;
    if (_52 < _50)
    goto _jump292;
    // End body of loop
    int64_t _54;
    // Computing bound for h
    if (_42 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    _54 = 0;
    int64_t _55 = 0; // h
    _jump294:; // Begin body of loop
    bool _56 = false;
    int64_t _57;
    if (!_56)
    goto _jump295;
    _57 = _41;
    goto _jump296;
    _jump295:;
    _57 = _41;
    _jump296:;
    _54 += _57;
    _55++;
    if (_55 < _42)
    goto _jump294;
    // End body of loop
    int64_t _58 = _47 / _54;
    _46 = _58;
    goto _jump297;
    _jump289:;
    double _59 = 30.0;
    double _60 = -_59;
    double _61 = -_60;
    double _62;
    // Computing bound for h
    int64_t _63 = 629;
    if (_63 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing bound for i
    if (_41 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    _62 = 0;
    int64_t _64 = 0; // j
    int64_t _65 = 0; // i
    int64_t _66 = 0; // h
    _jump301:; // Begin body of loop
    double _67 = 34.0;
    _62 += _67;
    _64++;
    if (_64 < c.d0)
    goto _jump301;
    _64 = 0;
    _65++;
    if (_65 < _41)
    goto _jump301;
    _65 = 0;
    _66++;
    if (_66 < _63)
    goto _jump301;
    // End body of loop
    bool _68 = _61 < _62;
    int64_t _69;
    if (!_68)
    goto _jump302;
    _69 = _42;
    goto _jump303;
    _jump302:;
    _69 = _42;
    _jump303:;
    _46 = _69;
    _jump297:;
    _43.d0 = _46;
    if (_46 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for i
    double _70 = 57.0;
    double _71 = -_70;
    double _72 = -_71;
    bool _73 = true;
    double _74;
    if (!_73)
    goto _jump305;
    double _75 = 36.0;
    _74 = _75;
    goto _jump306;
    _jump305:;
    double _76 = 85.0;
    _74 = _76;
    _jump306:;
    double _77 = -_74;
    double _78 = _72 + _77;
    bool _79 = _42 == c.d0;
    double _80;
    if (!_79)
    goto _jump307;
    double _81 = 34.0;
    double _82 = -_81;
    _80 = _82;
    goto _jump308;
    _jump307:;
    double _83 = 85.0;
    _80 = _83;
    _jump308:;
    double _84 = -_80;
    bool _85 = _78 == _84;
    int64_t _86;
    if (!_85)
    goto _jump309;
    int64_t _87 = 236;
    _86 = _87;
    goto _jump310;
    _jump309:;
    bool _89 = false;
    bool _90 = !_89;
    bool _88 = _90;
    if (0 == _90)
    goto _jump311;
    bool _91 = true;
    bool _92 = !_91;
    _88 = _92;
    _jump311:;
    _a3_int64_t _93;
    if (!_88)
    goto _jump312;
    _a3_int64_t _94;
    // Computing bound for h
    _94.d0 = _42;
    if (_42 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for i
    _94.d1 = _42;
    if (_42 > 0) 
    goto _jump314;
    fail_assertion("non-positive loop bound");
    _jump314:;
    // Computing bound for j
    int64_t _95 = c.d0 * _42;
    _94.d2 = _95;
    if (_95 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= _42;
    _96 *= _42;
    _96 *= _95;
    _96 *= sizeof(int64_t);
    _94.data = jpl_alloc(_96);
    int64_t _97 = 0; // j
    int64_t _98 = 0; // i
    int64_t _99 = 0; // h
    _jump316:; // Begin body of loop
    int64_t _100 = 656;
    int64_t _101 = _99 / _100;
    int64_t _102 = 0;
    _102 *= _94.d0;
    _102 += _99;
    _102 *= _94.d1;
    _102 += _98;
    _102 *= _94.d2;
    _102 += _97;
    _94.data[_102] = _101;
    _97++;
    if (_97 < _95)
    goto _jump316;
    _97 = 0;
    _98++;
    if (_98 < _42)
    goto _jump316;
    _98 = 0;
    _99++;
    if (_99 < _42)
    goto _jump316;
    // End body of loop
    _93 = _94;
    goto _jump317;
    _jump312:;
    _a3_int64_t _103;
    // Computing bound for h
    int64_t _104 = _42 * c.d0;
    _103.d0 = _104;
    if (_104 > 0) 
    goto _jump318;
    fail_assertion("non-positive loop bound");
    _jump318:;
    // Computing bound for i
    _103.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump319;
    fail_assertion("non-positive loop bound");
    _jump319:;
    // Computing bound for j
    int64_t _105;
    // Computing bound for h
    int64_t _106 = 894;
    if (_106 > 0) 
    goto _jump320;
    fail_assertion("non-positive loop bound");
    _jump320:;
    _105 = 0;
    int64_t _107 = 0; // h
    _jump321:; // Begin body of loop
    _105 += _107;
    _107++;
    if (_107 < _106)
    goto _jump321;
    // End body of loop
    _103.d2 = _105;
    if (_105 > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= _104;
    _108 *= c.d0;
    _108 *= _105;
    _108 *= sizeof(int64_t);
    _103.data = jpl_alloc(_108);
    int64_t _109 = 0; // j
    int64_t _110 = 0; // i
    int64_t _111 = 0; // h
    _jump323:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _103.d0;
    _112 += _111;
    _112 *= _103.d1;
    _112 += _110;
    _112 *= _103.d2;
    _112 += _109;
    _103.data[_112] = _42;
    _109++;
    if (_109 < _105)
    goto _jump323;
    _109 = 0;
    _110++;
    if (_110 < c.d0)
    goto _jump323;
    _110 = 0;
    _111++;
    if (_111 < _104)
    goto _jump323;
    // End body of loop
    _93 = _103;
    _jump317:;
    _a1_int64_t _113;
    // Computing bound for h
    _113.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= c.d0;
    _114 *= sizeof(int64_t);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // h
    _jump325:; // Begin body of loop
    int64_t _116 = -_42;
    int64_t _117 = 0;
    _117 *= _113.d0;
    _117 += _115;
    _113.data[_117] = _116;
    _115++;
    if (_115 < c.d0)
    goto _jump325;
    // End body of loop
    if (_41 >= 0)
    goto _jump326;
    fail_assertion("negative array index");
    _jump326:;
    if (_41 < _113.d0)
    goto _jump327;
    fail_assertion("index too large");
    _jump327:;
    int64_t _118 = 0;
    _118 *= _113.d0;
    _118 += _41;
    int64_t _119 = _113.data[_118];
    int64_t _120;
    // Computing bound for h
    int64_t _121 = _42 + c.d0;
    int64_t _122 = _121 % _42;
    if (_122 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    _120 = 0;
    int64_t _123 = 0; // h
    _jump329:; // Begin body of loop
    _120 += c.d0;
    _123++;
    if (_123 < _122)
    goto _jump329;
    // End body of loop
    int64_t _124;
    // Computing bound for h
    if (_42 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    _124 = 0;
    int64_t _125 = 0; // h
    _jump331:; // Begin body of loop
    _124 += _41;
    _125++;
    if (_125 < _42)
    goto _jump331;
    // End body of loop
    int64_t _126 = -_42;
    int64_t _127 = _124 % _126;
    if (_119 >= 0)
    goto _jump332;
    fail_assertion("negative array index");
    _jump332:;
    if (_119 < _93.d0)
    goto _jump333;
    fail_assertion("index too large");
    _jump333:;
    if (_120 >= 0)
    goto _jump334;
    fail_assertion("negative array index");
    _jump334:;
    if (_120 < _93.d1)
    goto _jump335;
    fail_assertion("index too large");
    _jump335:;
    if (_127 >= 0)
    goto _jump336;
    fail_assertion("negative array index");
    _jump336:;
    if (_127 < _93.d2)
    goto _jump337;
    fail_assertion("index too large");
    _jump337:;
    int64_t _128 = 0;
    _128 *= _93.d0;
    _128 += _119;
    _128 *= _93.d1;
    _128 += _120;
    _128 *= _93.d2;
    _128 += _127;
    int64_t _129 = _93.data[_128];
    _86 = _129;
    _jump310:;
    _43.d1 = _86;
    if (_86 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for j
    int64_t _130 = 67;
    _43.d2 = _130;
    if (_130 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= _46;
    _131 *= _86;
    _131 *= _130;
    _131 *= sizeof(bool);
    _43.data = jpl_alloc(_131);
    int64_t _132 = 0; // j
    int64_t _133 = 0; // i
    int64_t _134 = 0; // h
    _jump340:; // Begin body of loop
    double _135 = 88.0;
    double _136 = 84.0;
    _a1_double _137;
    _137.d0 = 2;
    _137.data = jpl_alloc(sizeof(double) * 2);
    _137.data[0] = _135;
    _137.data[1] = _136;
    if (c.d0 >= 0)
    goto _jump341;
    fail_assertion("negative array index");
    _jump341:;
    if (c.d0 < _137.d0)
    goto _jump342;
    fail_assertion("index too large");
    _jump342:;
    int64_t _138 = 0;
    _138 *= _137.d0;
    _138 += c.d0;
    double _139 = _137.data[_138];
    _a1_rgba _140;
    // Computing bound for k
    int64_t _141 = _42 * _41;
    _140.d0 = _141;
    if (_141 > 0) 
    goto _jump343;
    fail_assertion("non-positive loop bound");
    _jump343:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _141;
    _142 *= sizeof(rgba);
    _140.data = jpl_alloc(_142);
    int64_t _143 = 0; // k
    _jump344:; // Begin body of loop
    double _144 = 23.0;
    double _145 = 54.0;
    double _146 = 95.0;
    double _147 = 83.0;
    rgba _148 = { _144, _145, _146, _147 };
    int64_t _149 = 0;
    _149 *= _140.d0;
    _149 += _143;
    _140.data[_149] = _148;
    _143++;
    if (_143 < _141)
    goto _jump344;
    // End body of loop
    if (_42 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (_42 < _140.d0)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _150 = 0;
    _150 *= _140.d0;
    _150 += _42;
    rgba _151 = _140.data[_150];
    double _152 = _151.r;
    bool _153 = _139 == _152;
    int64_t _154 = 0;
    _154 *= _43.d0;
    _154 += _134;
    _154 *= _43.d1;
    _154 += _133;
    _154 *= _43.d2;
    _154 += _132;
    _43.data[_154] = _153;
    _132++;
    if (_132 < _130)
    goto _jump340;
    _132 = 0;
    _133++;
    if (_133 < _86)
    goto _jump340;
    _133 = 0;
    _134++;
    if (_134 < _46)
    goto _jump340;
    // End body of loop
    int64_t _155 = 0;
    _155 *= _0.d0;
    _155 += _42;
    _155 *= _0.d1;
    _155 += _41;
    _0.data[_155] = _43;
    _41++;
    if (_41 < _39)
    goto _jump288;
    _41 = 0;
    _42++;
    if (_42 < _37)
    goto _jump288;
    // End body of loop
    bool _156 = _0.d0 > c.d0;
    bool _157;
    if (!_156)
    goto _jump347;
    bool _158 = false;
    _157 = _158;
    goto _jump348;
    _jump347:;
    bool _159 = true;
    bool _160 = !_159;
    bool _161 = !_160;
    bool _162 = _0.d1 == _0.d1;
    bool _163 = !_162;
    bool _164 = true;
    int64_t _165;
    if (!_164)
    goto _jump349;
    int64_t _166 = 946;
    _165 = _166;
    goto _jump350;
    _jump349:;
    _165 = _0.d1;
    _jump350:;
    int64_t _167 = c.d0 * c.d0;
    bool _168 = _165 == _167;
    bool _169;
    if (!_168)
    goto _jump351;
    bool _170 = true;
    bool _171;
    if (!_170)
    goto _jump352;
    bool _172 = true;
    _171 = _172;
    goto _jump353;
    _jump352:;
    bool _174 = false;
    bool _173 = _174;
    if (0 == _174)
    goto _jump354;
    bool _175 = false;
    _173 = _175;
    _jump354:;
    _171 = _173;
    _jump353:;
    _169 = _171;
    goto _jump355;
    _jump351:;
    int64_t _176 = _0.d0 + _0.d1;
    bool _177 = _0.d0 >= _176;
    _169 = _177;
    _jump355:;
    _a1_bool _178;
    _178.d0 = 3;
    _178.data = jpl_alloc(sizeof(bool) * 3);
    _178.data[0] = _161;
    _178.data[1] = _163;
    _178.data[2] = _169;
    int64_t _179;
    // Computing bound for i
    int64_t _180 = -_0.d0;
    if (_180 > 0) 
    goto _jump356;
    fail_assertion("non-positive loop bound");
    _jump356:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    _179 = 0;
    int64_t _181 = 0; // j
    int64_t _182 = 0; // i
    _jump358:; // Begin body of loop
    _179 += _181;
    _181++;
    if (_181 < _0.d1)
    goto _jump358;
    _181 = 0;
    _182++;
    if (_182 < _180)
    goto _jump358;
    // End body of loop
    int64_t _183 = _179 * _0.d0;
    int64_t _184 = -_183;
    if (_184 >= 0)
    goto _jump359;
    fail_assertion("negative array index");
    _jump359:;
    if (_184 < _178.d0)
    goto _jump360;
    fail_assertion("index too large");
    _jump360:;
    int64_t _185 = 0;
    _185 *= _178.d0;
    _185 += _184;
    bool _186 = _178.data[_185];
    _157 = _186;
    _jump348:;
    void_t _187;
    if (!_157)
    goto _jump361;
    bool _188 = false;
    _a2_bool _189;
    if (!_188)
    goto _jump362;
    _a2_bool _190;
    // Computing bound for i
    _190.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for j
    int64_t _191;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    _191 = 0;
    int64_t _192 = 0; // j
    int64_t _193 = 0; // i
    _jump366:; // Begin body of loop
    _191 += _192;
    _192++;
    if (_192 < _0.d1)
    goto _jump366;
    _192 = 0;
    _193++;
    if (_193 < _0.d0)
    goto _jump366;
    // End body of loop
    _190.d1 = _191;
    if (_191 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= _0.d0;
    _194 *= _191;
    _194 *= sizeof(bool);
    _190.data = jpl_alloc(_194);
    int64_t _195 = 0; // j
    int64_t _196 = 0; // i
    _jump368:; // Begin body of loop
    bool _197 = true;
    double _198;
    if (!_197)
    goto _jump369;
    double _199 = 77.0;
    _198 = _199;
    goto _jump370;
    _jump369:;
    double _200 = 68.0;
    _198 = _200;
    _jump370:;
    double _201 = 54.0;
    bool _202 = _198 < _201;
    int64_t _203 = 0;
    _203 *= _190.d0;
    _203 += _196;
    _203 *= _190.d1;
    _203 += _195;
    _190.data[_203] = _202;
    _195++;
    if (_195 < _191)
    goto _jump368;
    _195 = 0;
    _196++;
    if (_196 < _0.d0)
    goto _jump368;
    // End body of loop
    _189 = _190;
    goto _jump371;
    _jump362:;
    _a2__a2_bool _204;
    // Computing bound for i
    int64_t _205 = -c.d0;
    _204.d0 = _205;
    if (_205 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    // Computing bound for j
    _204.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump373;
    fail_assertion("non-positive loop bound");
    _jump373:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= _205;
    _206 *= c.d0;
    _206 *= sizeof(_a2_bool);
    _204.data = jpl_alloc(_206);
    int64_t _207 = 0; // j
    int64_t _208 = 0; // i
    _jump374:; // Begin body of loop
    _a2_bool _209;
    // Computing bound for k
    _209.d0 = _207;
    if (_207 > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    // Computing bound for l
    _209.d1 = _207;
    if (_207 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= _207;
    _210 *= _207;
    _210 *= sizeof(bool);
    _209.data = jpl_alloc(_210);
    int64_t _211 = 0; // l
    int64_t _212 = 0; // k
    _jump377:; // Begin body of loop
    bool _213 = false;
    int64_t _214 = 0;
    _214 *= _209.d0;
    _214 += _212;
    _214 *= _209.d1;
    _214 += _211;
    _209.data[_214] = _213;
    _211++;
    if (_211 < _207)
    goto _jump377;
    _211 = 0;
    _212++;
    if (_212 < _207)
    goto _jump377;
    // End body of loop
    int64_t _215 = 0;
    _215 *= _204.d0;
    _215 += _208;
    _215 *= _204.d1;
    _215 += _207;
    _204.data[_215] = _209;
    _207++;
    if (_207 < c.d0)
    goto _jump374;
    _207 = 0;
    _208++;
    if (_208 < _205)
    goto _jump374;
    // End body of loop
    int64_t _216 = 393;
    if (_216 >= 0)
    goto _jump378;
    fail_assertion("negative array index");
    _jump378:;
    if (_216 < _204.d0)
    goto _jump379;
    fail_assertion("index too large");
    _jump379:;
    if (c.d0 >= 0)
    goto _jump380;
    fail_assertion("negative array index");
    _jump380:;
    if (c.d0 < _204.d1)
    goto _jump381;
    fail_assertion("index too large");
    _jump381:;
    int64_t _217 = 0;
    _217 *= _204.d0;
    _217 += _216;
    _217 *= _204.d1;
    _217 += c.d0;
    _a2_bool _218 = _204.data[_217];
    _189 = _218;
    _jump371:;
    int64_t _219;
    // Computing bound for i
    double _220 = 4.0;
    double _221;
    // Computing bound for i
    int64_t _222 = 96;
    if (_222 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    _221 = 0;
    int64_t _223 = 0; // j
    int64_t _224 = 0; // i
    _jump384:; // Begin body of loop
    double _225 = 20.0;
    _221 += _225;
    _223++;
    if (_223 < _0.d1)
    goto _jump384;
    _223 = 0;
    _224++;
    if (_224 < _222)
    goto _jump384;
    // End body of loop
    bool _226 = _220 == _221;
    int64_t _227;
    if (!_226)
    goto _jump385;
    _227 = _0.d0;
    goto _jump386;
    _jump385:;
    _227 = _0.d0;
    _jump386:;
    if (_227 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    _219 = 0;
    int64_t _228 = 0; // i
    _jump388:; // Begin body of loop
    _219 += _0.d0;
    _228++;
    if (_228 < _227)
    goto _jump388;
    // End body of loop
    if (_219 >= 0)
    goto _jump389;
    fail_assertion("negative array index");
    _jump389:;
    if (_219 < _189.d0)
    goto _jump390;
    fail_assertion("index too large");
    _jump390:;
    if (c.d0 >= 0)
    goto _jump391;
    fail_assertion("negative array index");
    _jump391:;
    if (c.d0 < _189.d1)
    goto _jump392;
    fail_assertion("index too large");
    _jump392:;
    int64_t _229 = 0;
    _229 *= _189.d0;
    _229 += _219;
    _229 *= _189.d1;
    _229 += c.d0;
    bool _230 = _189.data[_229];
    void_t _231;
    if (!_230)
    goto _jump393;
    void_t _232 = b(c, e);
    _231 = _232;
    goto _jump394;
    _jump393:;
    bool _233 = false;
    void_t _234;
    if (!_233)
    goto _jump395;
    if (_0.d1 >= 0)
    goto _jump396;
    fail_assertion("negative array index");
    _jump396:;
    if (_0.d1 < c.d0)
    goto _jump397;
    fail_assertion("index too large");
    _jump397:;
    int64_t _236 = 0;
    _236 *= c.d0;
    _236 += _0.d1;
    bool _237 = c.data[_236];
    bool _238 = !_237;
    bool _235 = _238;
    if (0 != _238)
    goto _jump398;
    int64_t _239 = 467;
    int64_t _240 = _239 / _0.d0;
    bool _241 = _0.d0 <= _240;
    _235 = _241;
    _jump398:;
    void_t _242;
    if (!_235)
    goto _jump399;
    bool _243 = true;
    _a1_bool _244;
    if (!_243)
    goto _jump400;
    _244 = e;
    goto _jump401;
    _jump400:;
    _244 = c;
    _jump401:;
    void_t _245 = b(_244, e);
    _242 = _245;
    goto _jump402;
    _jump399:;
    double _246;
    // Computing bound for i
    int64_t _247 = 370;
    if (_247 > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    _246 = 0;
    int64_t _248 = 0; // j
    int64_t _249 = 0; // i
    _jump405:; // Begin body of loop
    double _250 = 56.0;
    _246 += _250;
    _248++;
    if (_248 < _0.d1)
    goto _jump405;
    _248 = 0;
    _249++;
    if (_249 < _247)
    goto _jump405;
    // End body of loop
    double _251 = 71.0;
    bool _252 = _246 != _251;
    void_t _253;
    if (!_252)
    goto _jump406;
    bool _254 = true;
    void_t _255;
    if (!_254)
    goto _jump407;
    void_t _256 = b(c, c);
    _255 = _256;
    goto _jump408;
    _jump407:;
    void_t _257 = b(e, c);
    _255 = _257;
    _jump408:;
    _253 = _255;
    goto _jump409;
    _jump406:;
    bool _258 = false;
    _a1_bool _259;
    if (!_258)
    goto _jump410;
    _259 = e;
    goto _jump411;
    _jump410:;
    _259 = e;
    _jump411:;
    void_t _260 = b(_259, e);
    _253 = _260;
    _jump409:;
    _242 = _253;
    _jump402:;
    _234 = _242;
    goto _jump412;
    _jump395:;
    double _261 = 47.0;
    double _262 = 7.0;
    double _263 = _261 / _262;
    double _264 = 33.0;
    double _265 = _263 / _264;
    double _266 = 4.0;
    bool _267 = _265 <= _266;
    void_t _268;
    if (!_267)
    goto _jump413;
    void_t _269 = b(c, e);
    _268 = _269;
    goto _jump414;
    _jump413:;
    _a3__a1_bool _270;
    // Computing bound for i
    _270.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump415;
    fail_assertion("non-positive loop bound");
    _jump415:;
    // Computing bound for j
    _270.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for k
    _270.d2 = c.d0;
    if (c.d0 > 0) 
    goto _jump417;
    fail_assertion("non-positive loop bound");
    _jump417:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= _0.d1;
    _271 *= _0.d0;
    _271 *= c.d0;
    _271 *= sizeof(_a1_bool);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // k
    int64_t _273 = 0; // j
    int64_t _274 = 0; // i
    _jump418:; // Begin body of loop
    int64_t _275 = 0;
    _275 *= _270.d0;
    _275 += _274;
    _275 *= _270.d1;
    _275 += _273;
    _275 *= _270.d2;
    _275 += _272;
    _270.data[_275] = c;
    _272++;
    if (_272 < c.d0)
    goto _jump418;
    _272 = 0;
    _273++;
    if (_273 < _0.d0)
    goto _jump418;
    _273 = 0;
    _274++;
    if (_274 < _0.d1)
    goto _jump418;
    // End body of loop
    int64_t _276;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    _276 = 0;
    int64_t _277 = 0; // i
    _jump420:; // Begin body of loop
    _276 += _0.d0;
    _277++;
    if (_277 < _0.d0)
    goto _jump420;
    // End body of loop
    int64_t _278;
    // Computing bound for i
    int64_t _279 = 136;
    if (_279 > 0) 
    goto _jump421;
    fail_assertion("non-positive loop bound");
    _jump421:;
    _278 = 0;
    int64_t _280 = 0; // i
    _jump422:; // Begin body of loop
    _278 += _0.d0;
    _280++;
    if (_280 < _279)
    goto _jump422;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump423;
    fail_assertion("negative array index");
    _jump423:;
    if (_0.d1 < _270.d0)
    goto _jump424;
    fail_assertion("index too large");
    _jump424:;
    if (_276 >= 0)
    goto _jump425;
    fail_assertion("negative array index");
    _jump425:;
    if (_276 < _270.d1)
    goto _jump426;
    fail_assertion("index too large");
    _jump426:;
    if (_278 >= 0)
    goto _jump427;
    fail_assertion("negative array index");
    _jump427:;
    if (_278 < _270.d2)
    goto _jump428;
    fail_assertion("index too large");
    _jump428:;
    int64_t _281 = 0;
    _281 *= _270.d0;
    _281 += _0.d1;
    _281 *= _270.d1;
    _281 += _276;
    _281 *= _270.d2;
    _281 += _278;
    _a1_bool _282 = _270.data[_281];
    _a1_bool _283;
    // Computing bound for i
    int64_t _284 = 526;
    _283.d0 = _284;
    if (_284 > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    // Computing total size of heap memory to allocate
    int64_t _285 = 1;
    _285 *= _284;
    _285 *= sizeof(bool);
    _283.data = jpl_alloc(_285);
    int64_t _286 = 0; // i
    _jump430:; // Begin body of loop
    bool _287 = true;
    int64_t _288 = 0;
    _288 *= _283.d0;
    _288 += _286;
    _283.data[_288] = _287;
    _286++;
    if (_286 < _284)
    goto _jump430;
    // End body of loop
    void_t _289 = b(_282, _283);
    _268 = _289;
    _jump414:;
    _234 = _268;
    _jump412:;
    _231 = _234;
    _jump394:;
    _187 = _231;
    goto _jump431;
    _jump361:;
    bool _290 = true;
    bool _291 = !_290;
    _a2_void_t _292;
    if (!_291)
    goto _jump432;
    _a2_void_t _293;
    // Computing bound for i
    int64_t _294 = c.d0 % _0.d0;
    _293.d0 = _294;
    if (_294 > 0) 
    goto _jump433;
    fail_assertion("non-positive loop bound");
    _jump433:;
    // Computing bound for j
    int64_t _295 = 638;
    _293.d1 = _295;
    if (_295 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _294;
    _296 *= _295;
    _296 *= sizeof(void_t);
    _293.data = jpl_alloc(_296);
    int64_t _297 = 0; // j
    int64_t _298 = 0; // i
    _jump435:; // Begin body of loop
    _a1_void_t _299;
    // Computing bound for k
    int64_t _300 = _298 - _297;
    _299.d0 = _300;
    if (_300 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= _300;
    _301 *= sizeof(void_t);
    _299.data = jpl_alloc(_301);
    int64_t _302 = 0; // k
    _jump437:; // Begin body of loop
    void_t _303 = b(e, e);
    int64_t _304 = 0;
    _304 *= _299.d0;
    _304 += _302;
    _299.data[_304] = _303;
    _302++;
    if (_302 < _300)
    goto _jump437;
    // End body of loop
    int64_t _305 = 230;
    if (_305 >= 0)
    goto _jump438;
    fail_assertion("negative array index");
    _jump438:;
    if (_305 < _299.d0)
    goto _jump439;
    fail_assertion("index too large");
    _jump439:;
    int64_t _306 = 0;
    _306 *= _299.d0;
    _306 += _305;
    void_t _307 = _299.data[_306];
    int64_t _308 = 0;
    _308 *= _293.d0;
    _308 += _298;
    _308 *= _293.d1;
    _308 += _297;
    _293.data[_308] = _307;
    _297++;
    if (_297 < _295)
    goto _jump435;
    _297 = 0;
    _298++;
    if (_298 < _294)
    goto _jump435;
    // End body of loop
    _292 = _293;
    goto _jump440;
    _jump432:;
    _a2_void_t _309;
    // Computing bound for i
    _309.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump441;
    fail_assertion("non-positive loop bound");
    _jump441:;
    // Computing bound for j
    int64_t _310 = 946;
    bool _311 = false;
    int64_t _312;
    if (!_311)
    goto _jump442;
    int64_t _313 = 839;
    int64_t _314 = -_313;
    _312 = _314;
    goto _jump443;
    _jump442:;
    int64_t _315 = 101;
    _312 = _315;
    _jump443:;
    int64_t _316 = _310 * _312;
    _309.d1 = _316;
    if (_316 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= _0.d1;
    _317 *= _316;
    _317 *= sizeof(void_t);
    _309.data = jpl_alloc(_317);
    int64_t _318 = 0; // j
    int64_t _319 = 0; // i
    _jump445:; // Begin body of loop
    _a1_bool _320;
    // Computing bound for k
    _320.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= c.d0;
    _321 *= sizeof(bool);
    _320.data = jpl_alloc(_321);
    int64_t _322 = 0; // k
    _jump447:; // Begin body of loop
    bool _323 = true;
    int64_t _324 = 0;
    _324 *= _320.d0;
    _324 += _322;
    _320.data[_324] = _323;
    _322++;
    if (_322 < c.d0)
    goto _jump447;
    // End body of loop
    void_t _325 = b(c, _320);
    int64_t _326 = 0;
    _326 *= _309.d0;
    _326 += _319;
    _326 *= _309.d1;
    _326 += _318;
    _309.data[_326] = _325;
    _318++;
    if (_318 < _316)
    goto _jump445;
    _318 = 0;
    _319++;
    if (_319 < _0.d1)
    goto _jump445;
    // End body of loop
    _292 = _309;
    _jump440:;
    bool _327 = false;
    bool _328 = !_327;
    _a2_bool _329;
    if (!_328)
    goto _jump448;
    _a2_bool _330;
    // Computing bound for i
    _330.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for j
    _330.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= _0.d1;
    _331 *= _0.d1;
    _331 *= sizeof(bool);
    _330.data = jpl_alloc(_331);
    int64_t _332 = 0; // j
    int64_t _333 = 0; // i
    _jump451:; // Begin body of loop
    double _334 = 5.0;
    double _335 = 85.0;
    bool _336 = _334 != _335;
    int64_t _337 = 0;
    _337 *= _330.d0;
    _337 += _333;
    _337 *= _330.d1;
    _337 += _332;
    _330.data[_337] = _336;
    _332++;
    if (_332 < _0.d1)
    goto _jump451;
    _332 = 0;
    _333++;
    if (_333 < _0.d1)
    goto _jump451;
    // End body of loop
    _329 = _330;
    goto _jump452;
    _jump448:;
    _a2_bool _338;
    // Computing bound for i
    int64_t _339 = -_0.d1;
    _338.d0 = _339;
    if (_339 > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    // Computing bound for j
    _338.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing total size of heap memory to allocate
    int64_t _340 = 1;
    _340 *= _339;
    _340 *= _0.d0;
    _340 *= sizeof(bool);
    _338.data = jpl_alloc(_340);
    int64_t _341 = 0; // j
    int64_t _342 = 0; // i
    _jump455:; // Begin body of loop
    bool _343 = false;
    bool _344 = !_343;
    int64_t _345 = 0;
    _345 *= _338.d0;
    _345 += _342;
    _345 *= _338.d1;
    _345 += _341;
    _338.data[_345] = _344;
    _341++;
    if (_341 < _0.d0)
    goto _jump455;
    _341 = 0;
    _342++;
    if (_342 < _339)
    goto _jump455;
    // End body of loop
    _329 = _338;
    _jump452:;
    _a1_void_t _346;
    // Computing bound for i
    int64_t _347 = 889;
    int64_t _348 = _0.d0 / _347;
    _346.d0 = _348;
    if (_348 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= _348;
    _349 *= sizeof(void_t);
    _346.data = jpl_alloc(_349);
    int64_t _350 = 0; // i
    _jump457:; // Begin body of loop
    void_t _351 = b(c, e);
    int64_t _352 = 0;
    _352 *= _346.d0;
    _352 += _350;
    _346.data[_352] = _351;
    _350++;
    if (_350 < _348)
    goto _jump457;
    // End body of loop
    int64_t _353 = -_0.d0;
    int64_t _354 = _0.d1 % _353;
    if (_354 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_354 < _346.d0)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    int64_t _355 = 0;
    _355 *= _346.d0;
    _355 += _354;
    void_t _356 = _346.data[_355];
    int64_t _357 = a(_329, _356);
    int64_t _358;
    // Computing bound for i
    int64_t _359 = 351;
    int64_t _360;
    // Computing bound for i
    if (c.d0 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for k
    if (_0.d0 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    _360 = 0;
    int64_t _361 = 0; // k
    int64_t _362 = 0; // j
    int64_t _363 = 0; // i
    _jump463:; // Begin body of loop
    _360 += _363;
    _361++;
    if (_361 < _0.d0)
    goto _jump463;
    _361 = 0;
    _362++;
    if (_362 < _0.d1)
    goto _jump463;
    _362 = 0;
    _363++;
    if (_363 < c.d0)
    goto _jump463;
    // End body of loop
    _a1_int64_t _364;
    _364.d0 = 3;
    _364.data = jpl_alloc(sizeof(int64_t) * 3);
    _364.data[0] = _0.d1;
    _364.data[1] = _359;
    _364.data[2] = _360;
    if (_0.d0 >= 0)
    goto _jump464;
    fail_assertion("negative array index");
    _jump464:;
    if (_0.d0 < _364.d0)
    goto _jump465;
    fail_assertion("index too large");
    _jump465:;
    int64_t _365 = 0;
    _365 *= _364.d0;
    _365 += _0.d0;
    int64_t _366 = _364.data[_365];
    if (_366 > 0) 
    goto _jump466;
    fail_assertion("non-positive loop bound");
    _jump466:;
    // Computing bound for j
    int64_t _367;
    // Computing bound for i
    if (_0.d1 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    _367 = 0;
    int64_t _368 = 0; // i
    _jump468:; // Begin body of loop
    _367 += c.d0;
    _368++;
    if (_368 < _0.d1)
    goto _jump468;
    // End body of loop
    int64_t _369 = _367 / _0.d0;
    int64_t _370 = 688;
    int64_t _371 = _369 + _370;
    if (_371 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    _358 = 0;
    int64_t _372 = 0; // j
    int64_t _373 = 0; // i
    _jump470:; // Begin body of loop
    bool _374 = true;
    int64_t _375;
    if (!_374)
    goto _jump471;
    int64_t _376 = 981;
    _375 = _376;
    goto _jump472;
    _jump471:;
    int64_t _377 = 630;
    int64_t _378 = _377 + _0.d0;
    int64_t _379 = -_378;
    _375 = _379;
    _jump472:;
    _358 += _375;
    _372++;
    if (_372 < _371)
    goto _jump470;
    _372 = 0;
    _373++;
    if (_373 < _366)
    goto _jump470;
    // End body of loop
    int64_t _380 = _357 % _358;
    int64_t _381 = c.d0 % _0.d0;
    bool _382 = _381 != c.d0;
    bool _383 = !_382;
    _a2_bool _384;
    if (!_383)
    goto _jump473;
    _a3__a2_bool _385;
    // Computing bound for i
    int64_t _386 = _0.d0 - _0.d0;
    _385.d0 = _386;
    if (_386 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing bound for j
    int64_t _387 = 37;
    int64_t _388 = _387 / _0.d1;
    _385.d1 = _388;
    if (_388 > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing bound for k
    _385.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _386;
    _389 *= _388;
    _389 *= _0.d0;
    _389 *= sizeof(_a2_bool);
    _385.data = jpl_alloc(_389);
    int64_t _390 = 0; // k
    int64_t _391 = 0; // j
    int64_t _392 = 0; // i
    _jump477:; // Begin body of loop
    _a2_bool _393;
    // Computing bound for l
    _393.d0 = _391;
    if (_391 > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    // Computing bound for m
    _393.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing total size of heap memory to allocate
    int64_t _394 = 1;
    _394 *= _391;
    _394 *= _0.d1;
    _394 *= sizeof(bool);
    _393.data = jpl_alloc(_394);
    int64_t _395 = 0; // m
    int64_t _396 = 0; // l
    _jump480:; // Begin body of loop
    bool _397 = false;
    int64_t _398 = 0;
    _398 *= _393.d0;
    _398 += _396;
    _398 *= _393.d1;
    _398 += _395;
    _393.data[_398] = _397;
    _395++;
    if (_395 < _0.d1)
    goto _jump480;
    _395 = 0;
    _396++;
    if (_396 < _391)
    goto _jump480;
    // End body of loop
    int64_t _399 = 0;
    _399 *= _385.d0;
    _399 += _392;
    _399 *= _385.d1;
    _399 += _391;
    _399 *= _385.d2;
    _399 += _390;
    _385.data[_399] = _393;
    _390++;
    if (_390 < _0.d0)
    goto _jump477;
    _390 = 0;
    _391++;
    if (_391 < _388)
    goto _jump477;
    _391 = 0;
    _392++;
    if (_392 < _386)
    goto _jump477;
    // End body of loop
    if (_0.d0 >= 0)
    goto _jump481;
    fail_assertion("negative array index");
    _jump481:;
    if (_0.d0 < _385.d0)
    goto _jump482;
    fail_assertion("index too large");
    _jump482:;
    if (c.d0 >= 0)
    goto _jump483;
    fail_assertion("negative array index");
    _jump483:;
    if (c.d0 < _385.d1)
    goto _jump484;
    fail_assertion("index too large");
    _jump484:;
    if (c.d0 >= 0)
    goto _jump485;
    fail_assertion("negative array index");
    _jump485:;
    if (c.d0 < _385.d2)
    goto _jump486;
    fail_assertion("index too large");
    _jump486:;
    int64_t _400 = 0;
    _400 *= _385.d0;
    _400 += _0.d0;
    _400 *= _385.d1;
    _400 += c.d0;
    _400 *= _385.d2;
    _400 += c.d0;
    _a2_bool _401 = _385.data[_400];
    _384 = _401;
    goto _jump487;
    _jump473:;
    bool _402 = true;
    _a2_bool _403;
    if (!_402)
    goto _jump488;
    _a2_bool _404;
    // Computing bound for i
    bool _405 = true;
    int64_t _406;
    if (!_405)
    goto _jump489;
    _406 = _0.d1;
    goto _jump490;
    _jump489:;
    int64_t _407 = 23;
    _406 = _407;
    _jump490:;
    _404.d0 = _406;
    if (_406 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for j
    int64_t _408 = 979;
    _404.d1 = _408;
    if (_408 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    // Computing total size of heap memory to allocate
    int64_t _409 = 1;
    _409 *= _406;
    _409 *= _408;
    _409 *= sizeof(bool);
    _404.data = jpl_alloc(_409);
    int64_t _410 = 0; // j
    int64_t _411 = 0; // i
    _jump493:; // Begin body of loop
    bool _412 = _410 != _411;
    int64_t _413 = 0;
    _413 *= _404.d0;
    _413 += _411;
    _413 *= _404.d1;
    _413 += _410;
    _404.data[_413] = _412;
    _410++;
    if (_410 < _408)
    goto _jump493;
    _410 = 0;
    _411++;
    if (_411 < _406)
    goto _jump493;
    // End body of loop
    _403 = _404;
    goto _jump494;
    _jump488:;
    _a2_bool _414;
    // Computing bound for i
    int64_t _415 = 279;
    int64_t _416 = -_415;
    _414.d0 = _416;
    if (_416 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing bound for j
    int64_t _417 = 464;
    int64_t _418 = _0.d1 - _417;
    _414.d1 = _418;
    if (_418 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing total size of heap memory to allocate
    int64_t _419 = 1;
    _419 *= _416;
    _419 *= _418;
    _419 *= sizeof(bool);
    _414.data = jpl_alloc(_419);
    int64_t _420 = 0; // j
    int64_t _421 = 0; // i
    _jump497:; // Begin body of loop
    bool _422 = c.d0 < _0.d1;
    int64_t _423 = 0;
    _423 *= _414.d0;
    _423 += _421;
    _423 *= _414.d1;
    _423 += _420;
    _414.data[_423] = _422;
    _420++;
    if (_420 < _418)
    goto _jump497;
    _420 = 0;
    _421++;
    if (_421 < _416)
    goto _jump497;
    // End body of loop
    _403 = _414;
    _jump494:;
    _384 = _403;
    _jump487:;
    _a3_double _424;
    // Computing bound for i
    _424.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing bound for j
    _424.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing bound for k
    _424.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    // Computing total size of heap memory to allocate
    int64_t _425 = 1;
    _425 *= c.d0;
    _425 *= _0.d0;
    _425 *= _0.d1;
    _425 *= sizeof(double);
    _424.data = jpl_alloc(_425);
    int64_t _426 = 0; // k
    int64_t _427 = 0; // j
    int64_t _428 = 0; // i
    _jump501:; // Begin body of loop
    double _429 = 22.0;
    int64_t _430 = 0;
    _430 *= _424.d0;
    _430 += _428;
    _430 *= _424.d1;
    _430 += _427;
    _430 *= _424.d2;
    _430 += _426;
    _424.data[_430] = _429;
    _426++;
    if (_426 < _0.d1)
    goto _jump501;
    _426 = 0;
    _427++;
    if (_427 < _0.d0)
    goto _jump501;
    _427 = 0;
    _428++;
    if (_428 < c.d0)
    goto _jump501;
    // End body of loop
    int64_t _431;
    // Computing bound for i
    int64_t _432 = 526;
    if (_432 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    _431 = 0;
    int64_t _433 = 0; // i
    _jump503:; // Begin body of loop
    _431 += c.d0;
    _433++;
    if (_433 < _432)
    goto _jump503;
    // End body of loop
    int64_t _434 = 572;
    if (_431 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (_431 < _424.d0)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    if (_434 >= 0)
    goto _jump506;
    fail_assertion("negative array index");
    _jump506:;
    if (_434 < _424.d1)
    goto _jump507;
    fail_assertion("index too large");
    _jump507:;
    if (_0.d0 >= 0)
    goto _jump508;
    fail_assertion("negative array index");
    _jump508:;
    if (_0.d0 < _424.d2)
    goto _jump509;
    fail_assertion("index too large");
    _jump509:;
    int64_t _435 = 0;
    _435 *= _424.d0;
    _435 += _431;
    _435 *= _424.d1;
    _435 += _434;
    _435 *= _424.d2;
    _435 += _0.d0;
    double _436 = _424.data[_435];
    double _437 = 78.0;
    bool _438 = _436 > _437;
    void_t _439;
    if (!_438)
    goto _jump510;
    void_t _440 = b(e, c);
    _439 = _440;
    goto _jump511;
    _jump510:;
    bool _441 = false;
    _a1_bool _442;
    _442.d0 = 1;
    _442.data = jpl_alloc(sizeof(bool) * 1);
    _442.data[0] = _441;
    bool _443 = _0.d1 != c.d0;
    _a1_bool _444;
    if (!_443)
    goto _jump512;
    bool _445 = false;
    _a1_bool _446;
    if (!_445)
    goto _jump513;
    _446 = e;
    goto _jump514;
    _jump513:;
    _446 = c;
    _jump514:;
    _444 = _446;
    goto _jump515;
    _jump512:;
    _444 = c;
    _jump515:;
    void_t _447 = b(_442, _444);
    _439 = _447;
    _jump511:;
    int64_t _448 = a(_384, _439);
    if (_380 >= 0)
    goto _jump516;
    fail_assertion("negative array index");
    _jump516:;
    if (_380 < _292.d0)
    goto _jump517;
    fail_assertion("index too large");
    _jump517:;
    if (_448 >= 0)
    goto _jump518;
    fail_assertion("negative array index");
    _jump518:;
    if (_448 < _292.d1)
    goto _jump519;
    fail_assertion("index too large");
    _jump519:;
    int64_t _449 = 0;
    _449 *= _292.d0;
    _449 += _380;
    _449 *= _292.d1;
    _449 += _448;
    void_t _450 = _292.data[_449];
    _187 = _450;
    _jump431:;
    return _187;
    int64_t _451 = 53;
    _a1_bool _452;
    // Computing bound for j
    _452.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing total size of heap memory to allocate
    int64_t _453 = 1;
    _453 *= c.d0;
    _453 *= sizeof(bool);
    _452.data = jpl_alloc(_453);
    int64_t _454 = 0; // j
    _jump521:; // Begin body of loop
    double _455 = 69.0;
    double _456 = 4.0;
    bool _457 = _455 == _456;
    int64_t _458 = 0;
    _458 *= _452.d0;
    _458 += _454;
    _452.data[_458] = _457;
    _454++;
    if (_454 < c.d0)
    goto _jump521;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump522;
    fail_assertion("negative array index");
    _jump522:;
    if (_0.d1 < _452.d0)
    goto _jump523;
    fail_assertion("index too large");
    _jump523:;
    int64_t _459 = 0;
    _459 *= _452.d0;
    _459 += _0.d1;
    bool _460 = _452.data[_459];
    _a1_double _461;
    // Computing bound for j
    _461.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing total size of heap memory to allocate
    int64_t _462 = 1;
    _462 *= _0.d1;
    _462 *= sizeof(double);
    _461.data = jpl_alloc(_462);
    int64_t _463 = 0; // j
    _jump525:; // Begin body of loop
    double _464 = 31.0;
    int64_t _465 = 0;
    _465 *= _461.d0;
    _465 += _463;
    _461.data[_465] = _464;
    _463++;
    if (_463 < _0.d1)
    goto _jump525;
    // End body of loop
    int64_t _466;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump526;
    fail_assertion("non-positive loop bound");
    _jump526:;
    // Computing bound for k
    if (_0.d1 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    _466 = 0;
    int64_t _467 = 0; // k
    int64_t _468 = 0; // j
    _jump528:; // Begin body of loop
    _466 += _0.d0;
    _467++;
    if (_467 < _0.d1)
    goto _jump528;
    _467 = 0;
    _468++;
    if (_468 < c.d0)
    goto _jump528;
    // End body of loop
    if (_466 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (_466 < _461.d0)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    int64_t _469 = 0;
    _469 *= _461.d0;
    _469 += _466;
    double _470 = _461.data[_469];
    double _471 = 19.0;
    double _472 = -_471;
    double _473 = -_472;
    bool _474 = _470 == _473;
    bool _475 = _460 != _474;
    void_t _476;
    if (!_475)
    goto _jump531;
    bool _478 = false;
    bool _479 = !_478;
    bool _477 = _479;
    if (0 == _479)
    goto _jump532;
    int64_t _480 = 791;
    bool _481 = _0.d0 == _480;
    _477 = _481;
    _jump532:;
    _a1_bool _482;
    if (!_477)
    goto _jump533;
    _482 = e;
    goto _jump534;
    _jump533:;
    bool _483 = true;
    bool _484 = !_483;
    _a1_bool _485;
    _485.d0 = 1;
    _485.data = jpl_alloc(sizeof(bool) * 1);
    _485.data[0] = _484;
    _482 = _485;
    _jump534:;
    void_t _486 = b(_482, c);
    _476 = _486;
    goto _jump535;
    _jump531:;
    _a3_void_t _487;
    // Computing bound for j
    _487.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    // Computing bound for k
    _487.d1 = _451;
    if (_451 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for l
    _487.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _488 = 1;
    _488 *= _0.d0;
    _488 *= _451;
    _488 *= _0.d1;
    _488 *= sizeof(void_t);
    _487.data = jpl_alloc(_488);
    int64_t _489 = 0; // l
    int64_t _490 = 0; // k
    int64_t _491 = 0; // j
    _jump539:; // Begin body of loop
    void_t _492 = b(e, e);
    int64_t _493 = 0;
    _493 *= _487.d0;
    _493 += _491;
    _493 *= _487.d1;
    _493 += _490;
    _493 *= _487.d2;
    _493 += _489;
    _487.data[_493] = _492;
    _489++;
    if (_489 < _0.d1)
    goto _jump539;
    _489 = 0;
    _490++;
    if (_490 < _451)
    goto _jump539;
    _490 = 0;
    _491++;
    if (_491 < _0.d0)
    goto _jump539;
    // End body of loop
    bool _494 = true;
    bool _495 = false;
    bool _496 = _494 != _495;
    int64_t _497;
    if (!_496)
    goto _jump540;
    _497 = _451;
    goto _jump541;
    _jump540:;
    int64_t _498;
    // Computing bound for j
    if (_451 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    _498 = 0;
    int64_t _499 = 0; // j
    _jump543:; // Begin body of loop
    _498 += _0.d0;
    _499++;
    if (_499 < _451)
    goto _jump543;
    // End body of loop
    _497 = _498;
    _jump541:;
    if (_0.d0 >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (_0.d0 < _487.d0)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    if (_0.d0 >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (_0.d0 < _487.d1)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    if (_497 >= 0)
    goto _jump548;
    fail_assertion("negative array index");
    _jump548:;
    if (_497 < _487.d2)
    goto _jump549;
    fail_assertion("index too large");
    _jump549:;
    int64_t _500 = 0;
    _500 *= _487.d0;
    _500 += _0.d0;
    _500 *= _487.d1;
    _500 += _0.d0;
    _500 *= _487.d2;
    _500 += _497;
    void_t _501 = _487.data[_500];
    _476 = _501;
    _jump535:;
    _a1_void_t _502;
    _502.d0 = 1;
    _502.data = jpl_alloc(sizeof(void_t) * 1);
    _502.data[0] = _476;
    _a3_bool _503;
    // Computing bound for j
    bool _504 = true;
    int64_t _505;
    if (!_504)
    goto _jump550;
    int64_t _506 = -_451;
    _505 = _506;
    goto _jump551;
    _jump550:;
    _505 = c.d0;
    _jump551:;
    _503.d0 = _505;
    if (_505 > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    // Computing bound for k
    _503.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for l
    int64_t _507;
    // Computing bound for j
    if (_451 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for k
    if (_0.d1 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    _507 = 0;
    int64_t _508 = 0; // k
    int64_t _509 = 0; // j
    _jump556:; // Begin body of loop
    _507 += _508;
    _508++;
    if (_508 < _0.d1)
    goto _jump556;
    _508 = 0;
    _509++;
    if (_509 < _451)
    goto _jump556;
    // End body of loop
    _503.d2 = _507;
    if (_507 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing total size of heap memory to allocate
    int64_t _510 = 1;
    _510 *= _505;
    _510 *= _0.d1;
    _510 *= _507;
    _510 *= sizeof(bool);
    _503.data = jpl_alloc(_510);
    int64_t _511 = 0; // l
    int64_t _512 = 0; // k
    int64_t _513 = 0; // j
    _jump558:; // Begin body of loop
    double _515 = 92.0;
    double _516 = 60.0;
    bool _517 = _515 > _516;
    bool _514 = _517;
    if (0 != _517)
    goto _jump559;
    bool _518 = true;
    bool _519 = !_518;
    _514 = _519;
    _jump559:;
    int64_t _520 = 0;
    _520 *= _503.d0;
    _520 += _513;
    _520 *= _503.d1;
    _520 += _512;
    _520 *= _503.d2;
    _520 += _511;
    _503.data[_520] = _514;
    _511++;
    if (_511 < _507)
    goto _jump558;
    _511 = 0;
    _512++;
    if (_512 < _0.d1)
    goto _jump558;
    _512 = 0;
    _513++;
    if (_513 < _505)
    goto _jump558;
    // End body of loop
    int64_t _521;
    // Computing bound for j
    int64_t _522;
    // Computing bound for j
    if (_0.d0 > 0) 
    goto _jump560;
    fail_assertion("non-positive loop bound");
    _jump560:;
    // Computing bound for k
    int64_t _523;
    // Computing bound for j
    int64_t _524 = 319;
    if (_524 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    _523 = 0;
    int64_t _525 = 0; // j
    _jump562:; // Begin body of loop
    _523 += _451;
    _525++;
    if (_525 < _524)
    goto _jump562;
    // End body of loop
    if (_523 > 0) 
    goto _jump563;
    fail_assertion("non-positive loop bound");
    _jump563:;
    _522 = 0;
    int64_t _526 = 0; // k
    int64_t _527 = 0; // j
    _jump564:; // Begin body of loop
    int64_t _528 = 696;
    int64_t _529 = -_528;
    _522 += _529;
    _526++;
    if (_526 < _523)
    goto _jump564;
    _526 = 0;
    _527++;
    if (_527 < _0.d0)
    goto _jump564;
    // End body of loop
    if (_522 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing bound for k
    _a3_int64_t _530;
    // Computing bound for j
    _530.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump566;
    fail_assertion("non-positive loop bound");
    _jump566:;
    // Computing bound for k
    _530.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump567;
    fail_assertion("non-positive loop bound");
    _jump567:;
    // Computing bound for l
    _530.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump568;
    fail_assertion("non-positive loop bound");
    _jump568:;
    // Computing total size of heap memory to allocate
    int64_t _531 = 1;
    _531 *= _0.d1;
    _531 *= _0.d0;
    _531 *= _0.d1;
    _531 *= sizeof(int64_t);
    _530.data = jpl_alloc(_531);
    int64_t _532 = 0; // l
    int64_t _533 = 0; // k
    int64_t _534 = 0; // j
    _jump569:; // Begin body of loop
    int64_t _535 = 0;
    _535 *= _530.d0;
    _535 += _534;
    _535 *= _530.d1;
    _535 += _533;
    _535 *= _530.d2;
    _535 += _532;
    _530.data[_535] = _451;
    _532++;
    if (_532 < _0.d1)
    goto _jump569;
    _532 = 0;
    _533++;
    if (_533 < _0.d0)
    goto _jump569;
    _533 = 0;
    _534++;
    if (_534 < _0.d1)
    goto _jump569;
    // End body of loop
    int64_t _536 = 26;
    int64_t _537 = _451 + _0.d1;
    int64_t _538 = 873;
    int64_t _539 = _538 / _451;
    if (_536 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (_536 < _530.d0)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    if (_537 >= 0)
    goto _jump572;
    fail_assertion("negative array index");
    _jump572:;
    if (_537 < _530.d1)
    goto _jump573;
    fail_assertion("index too large");
    _jump573:;
    if (_539 >= 0)
    goto _jump574;
    fail_assertion("negative array index");
    _jump574:;
    if (_539 < _530.d2)
    goto _jump575;
    fail_assertion("index too large");
    _jump575:;
    int64_t _540 = 0;
    _540 *= _530.d0;
    _540 += _536;
    _540 *= _530.d1;
    _540 += _537;
    _540 *= _530.d2;
    _540 += _539;
    int64_t _541 = _530.data[_540];
    if (_541 > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing bound for l
    if (_0.d1 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    _521 = 0;
    int64_t _542 = 0; // l
    int64_t _543 = 0; // k
    int64_t _544 = 0; // j
    _jump578:; // Begin body of loop
    int64_t _545 = -_0.d1;
    _521 += _545;
    _542++;
    if (_542 < _0.d1)
    goto _jump578;
    _542 = 0;
    _543++;
    if (_543 < _541)
    goto _jump578;
    _543 = 0;
    _544++;
    if (_544 < _522)
    goto _jump578;
    // End body of loop
    int64_t _546;
    // Computing bound for j
    int64_t _547 = 351;
    int64_t _548 = -_547;
    if (_548 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for k
    if (_0.d1 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    // Computing bound for l
    int64_t _549 = 958;
    int64_t _550 = _0.d0 % _549;
    if (_550 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    _546 = 0;
    int64_t _551 = 0; // l
    int64_t _552 = 0; // k
    int64_t _553 = 0; // j
    _jump582:; // Begin body of loop
    int64_t _554 = 495;
    _546 += _554;
    _551++;
    if (_551 < _550)
    goto _jump582;
    _551 = 0;
    _552++;
    if (_552 < _0.d1)
    goto _jump582;
    _552 = 0;
    _553++;
    if (_553 < _548)
    goto _jump582;
    // End body of loop
    if (_521 >= 0)
    goto _jump583;
    fail_assertion("negative array index");
    _jump583:;
    if (_521 < _503.d0)
    goto _jump584;
    fail_assertion("index too large");
    _jump584:;
    if (_546 >= 0)
    goto _jump585;
    fail_assertion("negative array index");
    _jump585:;
    if (_546 < _503.d1)
    goto _jump586;
    fail_assertion("index too large");
    _jump586:;
    if (_451 >= 0)
    goto _jump587;
    fail_assertion("negative array index");
    _jump587:;
    if (_451 < _503.d2)
    goto _jump588;
    fail_assertion("index too large");
    _jump588:;
    int64_t _555 = 0;
    _555 *= _503.d0;
    _555 += _521;
    _555 *= _503.d1;
    _555 += _546;
    _555 *= _503.d2;
    _555 += _451;
    bool _556 = _503.data[_555];
    bool _557;
    if (!_556)
    goto _jump589;
    bool _558 = false;
    _557 = _558;
    goto _jump590;
    _jump589:;
    bool _560 = true;
    bool _559 = _560;
    if (0 != _560)
    goto _jump591;
    bool _561 = c.d0 > _451;
    bool _562;
    if (!_561)
    goto _jump592;
    int64_t _563 = 898;
    int64_t _564 = -_563;
    int64_t _565 = -c.d0;
    bool _566 = _564 <= _565;
    _562 = _566;
    goto _jump593;
    _jump592:;
    bool _567 = false;
    _562 = _567;
    _jump593:;
    _559 = _562;
    _jump591:;
    _557 = _559;
    _jump590:;
    int64_t _568;
    if (!_557)
    goto _jump594;
    _568 = _0.d0;
    goto _jump595;
    _jump594:;
    _a1_bool _569;
    // Computing bound for j
    _569.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    // Computing total size of heap memory to allocate
    int64_t _570 = 1;
    _570 *= _0.d1;
    _570 *= sizeof(bool);
    _569.data = jpl_alloc(_570);
    int64_t _571 = 0; // j
    _jump597:; // Begin body of loop
    bool _572 = true;
    int64_t _573 = 0;
    _573 *= _569.d0;
    _573 += _571;
    _569.data[_573] = _572;
    _571++;
    if (_571 < _0.d1)
    goto _jump597;
    // End body of loop
    int64_t _574 = 979;
    if (_574 >= 0)
    goto _jump598;
    fail_assertion("negative array index");
    _jump598:;
    if (_574 < _569.d0)
    goto _jump599;
    fail_assertion("index too large");
    _jump599:;
    int64_t _575 = 0;
    _575 *= _569.d0;
    _575 += _574;
    bool _576 = _569.data[_575];
    _a2_bool _577;
    if (!_576)
    goto _jump600;
    _a2_bool _578;
    // Computing bound for j
    _578.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    // Computing bound for k
    _a2_int64_t _579;
    // Computing bound for j
    _579.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing bound for k
    int64_t _580 = 769;
    _579.d1 = _580;
    if (_580 > 0) 
    goto _jump603;
    fail_assertion("non-positive loop bound");
    _jump603:;
    // Computing total size of heap memory to allocate
    int64_t _581 = 1;
    _581 *= c.d0;
    _581 *= _580;
    _581 *= sizeof(int64_t);
    _579.data = jpl_alloc(_581);
    int64_t _582 = 0; // k
    int64_t _583 = 0; // j
    _jump604:; // Begin body of loop
    int64_t _584 = 0;
    _584 *= _579.d0;
    _584 += _583;
    _584 *= _579.d1;
    _584 += _582;
    _579.data[_584] = c.d0;
    _582++;
    if (_582 < _580)
    goto _jump604;
    _582 = 0;
    _583++;
    if (_583 < c.d0)
    goto _jump604;
    // End body of loop
    int64_t _585;
    // Computing bound for j
    if (c.d0 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for k
    if (_0.d1 > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    _585 = 0;
    int64_t _586 = 0; // k
    int64_t _587 = 0; // j
    _jump607:; // Begin body of loop
    _585 += _0.d0;
    _586++;
    if (_586 < _0.d1)
    goto _jump607;
    _586 = 0;
    _587++;
    if (_587 < c.d0)
    goto _jump607;
    // End body of loop
    if (_451 >= 0)
    goto _jump608;
    fail_assertion("negative array index");
    _jump608:;
    if (_451 < _579.d0)
    goto _jump609;
    fail_assertion("index too large");
    _jump609:;
    if (_585 >= 0)
    goto _jump610;
    fail_assertion("negative array index");
    _jump610:;
    if (_585 < _579.d1)
    goto _jump611;
    fail_assertion("index too large");
    _jump611:;
    int64_t _588 = 0;
    _588 *= _579.d0;
    _588 += _451;
    _588 *= _579.d1;
    _588 += _585;
    int64_t _589 = _579.data[_588];
    _578.d1 = _589;
    if (_589 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing total size of heap memory to allocate
    int64_t _590 = 1;
    _590 *= c.d0;
    _590 *= _589;
    _590 *= sizeof(bool);
    _578.data = jpl_alloc(_590);
    int64_t _591 = 0; // k
    int64_t _592 = 0; // j
    _jump613:; // Begin body of loop
    bool _593 = false;
    bool _594;
    if (!_593)
    goto _jump614;
    bool _595 = false;
    _594 = _595;
    goto _jump615;
    _jump614:;
    bool _596 = true;
    _594 = _596;
    _jump615:;
    bool _597 = !_594;
    int64_t _598 = 0;
    _598 *= _578.d0;
    _598 += _592;
    _598 *= _578.d1;
    _598 += _591;
    _578.data[_598] = _597;
    _591++;
    if (_591 < _589)
    goto _jump613;
    _591 = 0;
    _592++;
    if (_592 < c.d0)
    goto _jump613;
    // End body of loop
    _577 = _578;
    goto _jump616;
    _jump600:;
    _a2_bool _599;
    // Computing bound for j
    _599.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    // Computing bound for k
    _599.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    // Computing total size of heap memory to allocate
    int64_t _600 = 1;
    _600 *= c.d0;
    _600 *= c.d0;
    _600 *= sizeof(bool);
    _599.data = jpl_alloc(_600);
    int64_t _601 = 0; // k
    int64_t _602 = 0; // j
    _jump619:; // Begin body of loop
    if (_0.d1 >= 0)
    goto _jump620;
    fail_assertion("negative array index");
    _jump620:;
    if (_0.d1 < c.d0)
    goto _jump621;
    fail_assertion("index too large");
    _jump621:;
    int64_t _603 = 0;
    _603 *= c.d0;
    _603 += _0.d1;
    bool _604 = c.data[_603];
    int64_t _605 = 348;
    bool _606 = _601 < _605;
    bool _607 = _604 == _606;
    int64_t _608 = 0;
    _608 *= _599.d0;
    _608 += _602;
    _608 *= _599.d1;
    _608 += _601;
    _599.data[_608] = _607;
    _601++;
    if (_601 < c.d0)
    goto _jump619;
    _601 = 0;
    _602++;
    if (_602 < c.d0)
    goto _jump619;
    // End body of loop
    _577 = _599;
    _jump616:;
    bool _609 = true;
    bool _610 = !_609;
    bool _611 = !_610;
    _a3_void_t _612;
    if (!_611)
    goto _jump622;
    _a3_void_t _613;
    // Computing bound for j
    int64_t _614;
    // Computing bound for j
    int64_t _615 = 953;
    if (_615 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    _614 = 0;
    int64_t _616 = 0; // j
    _jump624:; // Begin body of loop
    _614 += _0.d1;
    _616++;
    if (_616 < _615)
    goto _jump624;
    // End body of loop
    _613.d0 = _614;
    if (_614 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for k
    int64_t _617 = 973;
    _613.d1 = _617;
    if (_617 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    // Computing bound for l
    _613.d2 = _451;
    if (_451 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    // Computing total size of heap memory to allocate
    int64_t _618 = 1;
    _618 *= _614;
    _618 *= _617;
    _618 *= _451;
    _618 *= sizeof(void_t);
    _613.data = jpl_alloc(_618);
    int64_t _619 = 0; // l
    int64_t _620 = 0; // k
    int64_t _621 = 0; // j
    _jump628:; // Begin body of loop
    void_t _622 = b(e, e);
    int64_t _623 = 0;
    _623 *= _613.d0;
    _623 += _621;
    _623 *= _613.d1;
    _623 += _620;
    _623 *= _613.d2;
    _623 += _619;
    _613.data[_623] = _622;
    _619++;
    if (_619 < _451)
    goto _jump628;
    _619 = 0;
    _620++;
    if (_620 < _617)
    goto _jump628;
    _620 = 0;
    _621++;
    if (_621 < _614)
    goto _jump628;
    // End body of loop
    _612 = _613;
    goto _jump629;
    _jump622:;
    _a3_void_t _624;
    // Computing bound for j
    bool _625 = true;
    int64_t _626;
    if (!_625)
    goto _jump630;
    _626 = _0.d1;
    goto _jump631;
    _jump630:;
    _626 = _451;
    _jump631:;
    _624.d0 = _626;
    if (_626 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for k
    _624.d1 = _451;
    if (_451 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing bound for l
    _624.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing total size of heap memory to allocate
    int64_t _627 = 1;
    _627 *= _626;
    _627 *= _451;
    _627 *= _0.d0;
    _627 *= sizeof(void_t);
    _624.data = jpl_alloc(_627);
    int64_t _628 = 0; // l
    int64_t _629 = 0; // k
    int64_t _630 = 0; // j
    _jump635:; // Begin body of loop
    void_t _631 = b(c, e);
    int64_t _632 = 0;
    _632 *= _624.d0;
    _632 += _630;
    _632 *= _624.d1;
    _632 += _629;
    _632 *= _624.d2;
    _632 += _628;
    _624.data[_632] = _631;
    _628++;
    if (_628 < _0.d0)
    goto _jump635;
    _628 = 0;
    _629++;
    if (_629 < _451)
    goto _jump635;
    _629 = 0;
    _630++;
    if (_630 < _626)
    goto _jump635;
    // End body of loop
    _612 = _624;
    _jump629:;
    int64_t _633 = 359;
    int64_t _634;
    // Computing bound for j
    if (_0.d0 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    _634 = 0;
    int64_t _635 = 0; // j
    _jump637:; // Begin body of loop
    int64_t _636 = -c.d0;
    _634 += _636;
    _635++;
    if (_635 < _0.d0)
    goto _jump637;
    // End body of loop
    bool _637 = false;
    int64_t _638;
    if (!_637)
    goto _jump638;
    _638 = c.d0;
    goto _jump639;
    _jump638:;
    int64_t _639 = 117;
    int64_t _640 = _639 % c.d0;
    int64_t _641 = -_640;
    _638 = _641;
    _jump639:;
    if (_633 >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (_633 < _612.d0)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    if (_634 >= 0)
    goto _jump642;
    fail_assertion("negative array index");
    _jump642:;
    if (_634 < _612.d1)
    goto _jump643;
    fail_assertion("index too large");
    _jump643:;
    if (_638 >= 0)
    goto _jump644;
    fail_assertion("negative array index");
    _jump644:;
    if (_638 < _612.d2)
    goto _jump645;
    fail_assertion("index too large");
    _jump645:;
    int64_t _642 = 0;
    _642 *= _612.d0;
    _642 += _633;
    _642 *= _612.d1;
    _642 += _634;
    _642 *= _612.d2;
    _642 += _638;
    void_t _643 = _612.data[_642];
    int64_t _644 = a(_577, _643);
    _568 = _644;
    _jump595:;
    if (_568 >= 0)
    goto _jump646;
    fail_assertion("negative array index");
    _jump646:;
    if (_568 < _502.d0)
    goto _jump647;
    fail_assertion("index too large");
    _jump647:;
    int64_t _645 = 0;
    _645 *= _502.d0;
    _645 += _568;
    void_t _646 = _502.data[_645];
    return _646;
    bool _647 = true;
    if (0 != _647)
    goto _jump648;
    fail_assertion("j");
    _jump648:;
    _a1_void_t _648;
    // Computing bound for l
    int64_t _649;
    // Computing bound for l
    int64_t _650 = -_0.d1;
    if (_650 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    // Computing bound for m
    bool _651 = true;
    bool _652 = !_651;
    int64_t _653;
    if (!_652)
    goto _jump650;
    _653 = _451;
    goto _jump651;
    _jump650:;
    int64_t _654;
    // Computing bound for l
    int64_t _655 = 280;
    if (_655 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    _654 = 0;
    int64_t _656 = 0; // l
    _jump653:; // Begin body of loop
    _654 += e.d0;
    _656++;
    if (_656 < _655)
    goto _jump653;
    // End body of loop
    _653 = _654;
    _jump651:;
    int64_t _657 = -_653;
    bool _658 = true;
    bool _659 = false;
    bool _660 = _658 != _659;
    bool _661 = !_660;
    int64_t _662;
    if (!_661)
    goto _jump654;
    _662 = c.d0;
    goto _jump655;
    _jump654:;
    _662 = e.d0;
    _jump655:;
    int64_t _663 = _657 + _662;
    if (_663 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing bound for n
    if (_0.d1 > 0) 
    goto _jump657;
    fail_assertion("non-positive loop bound");
    _jump657:;
    _649 = 0;
    int64_t _664 = 0; // n
    int64_t _665 = 0; // m
    int64_t _666 = 0; // l
    _jump658:; // Begin body of loop
    bool _667 = false;
    bool _668 = !_667;
    _a2_bool _669;
    if (!_668)
    goto _jump659;
    _a2_bool _670;
    // Computing bound for o
    _670.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for p
    _670.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing total size of heap memory to allocate
    int64_t _671 = 1;
    _671 *= e.d0;
    _671 *= c.d0;
    _671 *= sizeof(bool);
    _670.data = jpl_alloc(_671);
    int64_t _672 = 0; // p
    int64_t _673 = 0; // o
    _jump662:; // Begin body of loop
    bool _674 = true;
    int64_t _675 = 0;
    _675 *= _670.d0;
    _675 += _673;
    _675 *= _670.d1;
    _675 += _672;
    _670.data[_675] = _674;
    _672++;
    if (_672 < c.d0)
    goto _jump662;
    _672 = 0;
    _673++;
    if (_673 < e.d0)
    goto _jump662;
    // End body of loop
    _669 = _670;
    goto _jump663;
    _jump659:;
    _a2_bool _676;
    // Computing bound for o
    _676.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for p
    _676.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing total size of heap memory to allocate
    int64_t _677 = 1;
    _677 *= e.d0;
    _677 *= _0.d0;
    _677 *= sizeof(bool);
    _676.data = jpl_alloc(_677);
    int64_t _678 = 0; // p
    int64_t _679 = 0; // o
    _jump666:; // Begin body of loop
    bool _680 = true;
    int64_t _681 = 0;
    _681 *= _676.d0;
    _681 += _679;
    _681 *= _676.d1;
    _681 += _678;
    _676.data[_681] = _680;
    _678++;
    if (_678 < _0.d0)
    goto _jump666;
    _678 = 0;
    _679++;
    if (_679 < e.d0)
    goto _jump666;
    // End body of loop
    _669 = _676;
    _jump663:;
    bool _683 = false;
    bool _682 = _683;
    if (0 == _683)
    goto _jump667;
    bool _684 = true;
    _682 = _684;
    _jump667:;
    void_t _685;
    if (!_682)
    goto _jump668;
    void_t _686 = b(e, c);
    _685 = _686;
    goto _jump669;
    _jump668:;
    void_t _687 = b(e, e);
    _685 = _687;
    _jump669:;
    int64_t _688 = a(_669, _685);
    int64_t _689 = -_688;
    _649 += _689;
    _664++;
    if (_664 < _0.d1)
    goto _jump658;
    _664 = 0;
    _665++;
    if (_665 < _663)
    goto _jump658;
    _665 = 0;
    _666++;
    if (_666 < _650)
    goto _jump658;
    // End body of loop
    _648.d0 = _649;
    if (_649 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    // Computing total size of heap memory to allocate
    int64_t _690 = 1;
    _690 *= _649;
    _690 *= sizeof(void_t);
    _648.data = jpl_alloc(_690);
    int64_t _691 = 0; // l
    _jump671:; // Begin body of loop
    double _692 = 33.0;
    double _693 = 26.0;
    double _694 = 22.0;
    double _695 = _693 / _694;
    bool _696 = _692 > _695;
    double _698 = 29.0;
    double _699 = 29.0;
    bool _700 = _698 >= _699;
    bool _701 = _0.d1 <= _451;
    bool _702 = _700 == _701;
    bool _697 = _702;
    if (0 != _702)
    goto _jump672;
    if (_0.d1 >= 0)
    goto _jump673;
    fail_assertion("negative array index");
    _jump673:;
    if (_0.d1 < e.d0)
    goto _jump674;
    fail_assertion("index too large");
    _jump674:;
    int64_t _703 = 0;
    _703 *= e.d0;
    _703 += _0.d1;
    bool _704 = e.data[_703];
    _697 = _704;
    _jump672:;
    _a1_bool _705;
    _705.d0 = 2;
    _705.data = jpl_alloc(sizeof(bool) * 2);
    _705.data[0] = _696;
    _705.data[1] = _697;
    void_t _706 = b(e, _705);
    int64_t _707 = 0;
    _707 *= _648.d0;
    _707 += _691;
    _648.data[_707] = _706;
    _691++;
    if (_691 < _649)
    goto _jump671;
    // End body of loop
    int64_t _708 = 243;
    if (_708 >= 0)
    goto _jump675;
    fail_assertion("negative array index");
    _jump675:;
    if (_708 < _648.d0)
    goto _jump676;
    fail_assertion("index too large");
    _jump676:;
    int64_t _709 = 0;
    _709 *= _648.d0;
    _709 += _708;
    void_t _710 = _648.data[_709];
    return _710;
}

rgba m(_a2__a2_int64_t n, int64_t q, _a3_bool r) {
    _a3_bool _0;
    // Computing bound for y
    _0.d0 = j;
    if (j > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    // Computing bound for z
    int64_t _1;
    // Computing bound for y
    int64_t _2 = 603;
    if (_2 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    _1 = 0;
    int64_t _3 = 0; // y
    _jump1138:; // Begin body of loop
    _1 += k;
    _3++;
    if (_3 < _2)
    goto _jump1138;
    // End body of loop
    _0.d1 = _1;
    if (_1 > 0) 
    goto _jump1139;
    fail_assertion("non-positive loop bound");
    _jump1139:;
    // Computing bound for A
    int64_t _4;
    // Computing bound for y
    if (n.d1 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    // Computing bound for z
    if (r.d1 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    _4 = 0;
    int64_t _5 = 0; // z
    int64_t _6 = 0; // y
    _jump1142:; // Begin body of loop
    _4 += n.d1;
    _5++;
    if (_5 < r.d1)
    goto _jump1142;
    _5 = 0;
    _6++;
    if (_6 < n.d1)
    goto _jump1142;
    // End body of loop
    _0.d2 = _4;
    if (_4 > 0) 
    goto _jump1143;
    fail_assertion("non-positive loop bound");
    _jump1143:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= j;
    _7 *= _1;
    _7 *= _4;
    _7 *= sizeof(bool);
    _0.data = jpl_alloc(_7);
    int64_t _8 = 0; // A
    int64_t _9 = 0; // z
    int64_t _10 = 0; // y
    _jump1144:; // Begin body of loop
    double _11 = 34.0;
    double _12 = 73.0;
    bool _13 = _11 >= _12;
    _a1_bool _14;
    _14.d0 = 1;
    _14.data = jpl_alloc(sizeof(bool) * 1);
    _14.data[0] = _13;
    if (_8 >= 0)
    goto _jump1145;
    fail_assertion("negative array index");
    _jump1145:;
    if (_8 < _14.d0)
    goto _jump1146;
    fail_assertion("index too large");
    _jump1146:;
    int64_t _15 = 0;
    _15 *= _14.d0;
    _15 += _8;
    bool _16 = _14.data[_15];
    bool _17;
    if (!_16)
    goto _jump1147;
    _a1_bool _18;
    // Computing bound for B
    _18.d0 = h;
    if (h > 0) 
    goto _jump1148;
    fail_assertion("non-positive loop bound");
    _jump1148:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= h;
    _19 *= sizeof(bool);
    _18.data = jpl_alloc(_19);
    int64_t _20 = 0; // B
    _jump1149:; // Begin body of loop
    bool _21 = true;
    bool _22 = !_21;
    int64_t _23 = 0;
    _23 *= _18.d0;
    _23 += _20;
    _18.data[_23] = _22;
    _20++;
    if (_20 < h)
    goto _jump1149;
    // End body of loop
    if (r.d2 >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (r.d2 < _18.d0)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _24 = 0;
    _24 *= _18.d0;
    _24 += r.d2;
    bool _25 = _18.data[_24];
    _17 = _25;
    goto _jump1152;
    _jump1147:;
    bool _26 = false;
    bool _27;
    if (!_26)
    goto _jump1153;
    if (q >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (q < r.d0)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    if (r.d1 >= 0)
    goto _jump1156;
    fail_assertion("negative array index");
    _jump1156:;
    if (r.d1 < r.d1)
    goto _jump1157;
    fail_assertion("index too large");
    _jump1157:;
    if (n.d0 >= 0)
    goto _jump1158;
    fail_assertion("negative array index");
    _jump1158:;
    if (n.d0 < r.d2)
    goto _jump1159;
    fail_assertion("index too large");
    _jump1159:;
    int64_t _28 = 0;
    _28 *= r.d0;
    _28 += q;
    _28 *= r.d1;
    _28 += r.d1;
    _28 *= r.d2;
    _28 += n.d0;
    bool _29 = r.data[_28];
    bool _30;
    if (!_29)
    goto _jump1160;
    bool _31 = false;
    _30 = _31;
    goto _jump1161;
    _jump1160:;
    int64_t _32 = 181;
    bool _33 = r.d2 != _32;
    _30 = _33;
    _jump1161:;
    _27 = _30;
    goto _jump1162;
    _jump1153:;
    bool _34 = false;
    bool _35 = !_34;
    _27 = _35;
    _jump1162:;
    _17 = _27;
    _jump1152:;
    bool _36;
    if (!_17)
    goto _jump1163;
    bool _37 = true;
    bool _38 = !_37;
    int64_t _39;
    if (!_38)
    goto _jump1164;
    _39 = _10;
    goto _jump1165;
    _jump1164:;
    _39 = q;
    _jump1165:;
    bool _40 = _39 != q;
    bool _41 = !_40;
    _36 = _41;
    goto _jump1166;
    _jump1163:;
    bool _42 = false;
    bool _43 = !_42;
    bool _44 = n.d0 != n.d1;
    bool _45 = _43 != _44;
    _a1_bool _46;
    if (!_45)
    goto _jump1167;
    _a1_bool _47;
    // Computing bound for B
    bool _48 = true;
    int64_t _49;
    if (!_48)
    goto _jump1168;
    _49 = n.d1;
    goto _jump1169;
    _jump1168:;
    _49 = n.d1;
    _jump1169:;
    _47.d0 = _49;
    if (_49 > 0) 
    goto _jump1170;
    fail_assertion("non-positive loop bound");
    _jump1170:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _49;
    _50 *= sizeof(bool);
    _47.data = jpl_alloc(_50);
    int64_t _51 = 0; // B
    _jump1171:; // Begin body of loop
    bool _52 = n.d1 > _10;
    int64_t _53 = 0;
    _53 *= _47.d0;
    _53 += _51;
    _47.data[_53] = _52;
    _51++;
    if (_51 < _49)
    goto _jump1171;
    // End body of loop
    _46 = _47;
    goto _jump1172;
    _jump1167:;
    _a1_bool _54;
    // Computing bound for B
    _54.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump1173;
    fail_assertion("non-positive loop bound");
    _jump1173:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= r.d0;
    _55 *= sizeof(bool);
    _54.data = jpl_alloc(_55);
    int64_t _56 = 0; // B
    _jump1174:; // Begin body of loop
    bool _57 = true;
    bool _58 = true;
    bool _59 = _57 != _58;
    int64_t _60 = 0;
    _60 *= _54.d0;
    _60 += _56;
    _54.data[_60] = _59;
    _56++;
    if (_56 < r.d0)
    goto _jump1174;
    // End body of loop
    _46 = _54;
    _jump1172:;
    if (r.d0 >= 0)
    goto _jump1175;
    fail_assertion("negative array index");
    _jump1175:;
    if (r.d0 < _46.d0)
    goto _jump1176;
    fail_assertion("index too large");
    _jump1176:;
    int64_t _61 = 0;
    _61 *= _46.d0;
    _61 += r.d0;
    bool _62 = _46.data[_61];
    _36 = _62;
    _jump1166:;
    int64_t _63 = 0;
    _63 *= _0.d0;
    _63 += _10;
    _63 *= _0.d1;
    _63 += _9;
    _63 *= _0.d2;
    _63 += _8;
    _0.data[_63] = _36;
    _8++;
    if (_8 < _4)
    goto _jump1144;
    _8 = 0;
    _9++;
    if (_9 < _1)
    goto _jump1144;
    _9 = 0;
    _10++;
    if (_10 < j)
    goto _jump1144;
    // End body of loop
    int64_t _64 = -r.d0;
    int64_t _65 = _64 / g;
    if (g >= 0)
    goto _jump1177;
    fail_assertion("negative array index");
    _jump1177:;
    if (g < _0.d0)
    goto _jump1178;
    fail_assertion("index too large");
    _jump1178:;
    if (_65 >= 0)
    goto _jump1179;
    fail_assertion("negative array index");
    _jump1179:;
    if (_65 < _0.d1)
    goto _jump1180;
    fail_assertion("index too large");
    _jump1180:;
    if (r.d1 >= 0)
    goto _jump1181;
    fail_assertion("negative array index");
    _jump1181:;
    if (r.d1 < _0.d2)
    goto _jump1182;
    fail_assertion("index too large");
    _jump1182:;
    int64_t _66 = 0;
    _66 *= _0.d0;
    _66 += g;
    _66 *= _0.d1;
    _66 += _65;
    _66 *= _0.d2;
    _66 += r.d1;
    bool _67 = _0.data[_66];
    if (0 != _67)
    goto _jump1183;
    fail_assertion("y");
    _jump1183:;
    bool _68 = true;
    bool _69;
    if (!_68)
    goto _jump1184;
    bool _70 = n.d0 <= n.d0;
    _69 = _70;
    goto _jump1185;
    _jump1184:;
    bool _71 = true;
    bool _72 = !_71;
    _69 = _72;
    _jump1185:;
    double _73;
    if (!_69)
    goto _jump1186;
    double _74 = 71.0;
    double _75;
    // Computing bound for y
    if (n.d0 > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    // Computing bound for z
    if (h > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    _75 = 0;
    int64_t _76 = 0; // z
    int64_t _77 = 0; // y
    _jump1189:; // Begin body of loop
    double _78 = 45.0;
    _75 += _78;
    _76++;
    if (_76 < h)
    goto _jump1189;
    _76 = 0;
    _77++;
    if (_77 < n.d0)
    goto _jump1189;
    // End body of loop
    double _79 = _74 - _75;
    _73 = _79;
    goto _jump1190;
    _jump1186:;
    int64_t _80 = 332;
    rgba _81 = m(n, _80, r);
    double _82 = _81.g;
    _73 = _82;
    _jump1190:;
    _a1_bool _83;
    // Computing bound for y
    _83.d0 = q;
    if (q > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= q;
    _84 *= sizeof(bool);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // y
    _jump1192:; // Begin body of loop
    bool _86 = r.d0 > r.d1;
    int64_t _87 = 0;
    _87 *= _83.d0;
    _87 += _85;
    _83.data[_87] = _86;
    _85++;
    if (_85 < q)
    goto _jump1192;
    // End body of loop
    if (r.d2 >= 0)
    goto _jump1193;
    fail_assertion("negative array index");
    _jump1193:;
    if (r.d2 < _83.d0)
    goto _jump1194;
    fail_assertion("index too large");
    _jump1194:;
    int64_t _88 = 0;
    _88 *= _83.d0;
    _88 += r.d2;
    bool _89 = _83.data[_88];
    double _90;
    if (!_89)
    goto _jump1195;
    double _91;
    // Computing bound for y
    if (n.d0 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for z
    if (n.d0 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing bound for A
    bool _92 = false;
    bool _93 = !_92;
    int64_t _94;
    if (!_93)
    goto _jump1198;
    _94 = n.d1;
    goto _jump1199;
    _jump1198:;
    _94 = r.d0;
    _jump1199:;
    if (_94 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    _91 = 0;
    int64_t _95 = 0; // A
    int64_t _96 = 0; // z
    int64_t _97 = 0; // y
    _jump1201:; // Begin body of loop
    _a2_double _98;
    // Computing bound for B
    _98.d0 = g;
    if (g > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for C
    _98.d1 = n.d0;
    if (n.d0 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= g;
    _99 *= n.d0;
    _99 *= sizeof(double);
    _98.data = jpl_alloc(_99);
    int64_t _100 = 0; // C
    int64_t _101 = 0; // B
    _jump1204:; // Begin body of loop
    double _102 = 49.0;
    int64_t _103 = 0;
    _103 *= _98.d0;
    _103 += _101;
    _103 *= _98.d1;
    _103 += _100;
    _98.data[_103] = _102;
    _100++;
    if (_100 < n.d0)
    goto _jump1204;
    _100 = 0;
    _101++;
    if (_101 < g)
    goto _jump1204;
    // End body of loop
    if (n.d1 >= 0)
    goto _jump1205;
    fail_assertion("negative array index");
    _jump1205:;
    if (n.d1 < _98.d0)
    goto _jump1206;
    fail_assertion("index too large");
    _jump1206:;
    if (j >= 0)
    goto _jump1207;
    fail_assertion("negative array index");
    _jump1207:;
    if (j < _98.d1)
    goto _jump1208;
    fail_assertion("index too large");
    _jump1208:;
    int64_t _104 = 0;
    _104 *= _98.d0;
    _104 += n.d1;
    _104 *= _98.d1;
    _104 += j;
    double _105 = _98.data[_104];
    _91 += _105;
    _95++;
    if (_95 < _94)
    goto _jump1201;
    _95 = 0;
    _96++;
    if (_96 < n.d0)
    goto _jump1201;
    _96 = 0;
    _97++;
    if (_97 < n.d0)
    goto _jump1201;
    // End body of loop
    _90 = _91;
    goto _jump1209;
    _jump1195:;
    double _106 = 57.0;
    _90 = _106;
    _jump1209:;
    bool _107 = _73 == _90;
    bool _108;
    if (!_107)
    goto _jump1210;
    int64_t _109 = h + h;
    bool _110 = _109 == n.d1;
    _108 = _110;
    goto _jump1211;
    _jump1210:;
    bool _113 = g < n.d0;
    bool _112 = _113;
    if (0 != _113)
    goto _jump1212;
    bool _114 = true;
    _112 = _114;
    _jump1212:;
    bool _111 = _112;
    if (0 == _112)
    goto _jump1213;
    bool _115 = false;
    bool _116;
    if (!_115)
    goto _jump1214;
    bool _117 = h > n.d0;
    _116 = _117;
    goto _jump1215;
    _jump1214:;
    double _118 = 23.0;
    double _119 = 9.0;
    bool _120 = _118 == _119;
    _116 = _120;
    _jump1215:;
    _111 = _116;
    _jump1213:;
    bool _121 = !_111;
    bool _122 = !_121;
    _108 = _122;
    _jump1211:;
    rgba _123;
    if (!_108)
    goto _jump1216;
    bool _124 = true;
    bool _125 = !_124;
    bool _126 = !_125;
    _a2__a3__a2__a2_int64_t _127;
    if (!_126)
    goto _jump1217;
    _a2__a3__a2__a2_int64_t _128;
    // Computing bound for y
    _128.d0 = n.d1;
    if (n.d1 > 0) 
    goto _jump1218;
    fail_assertion("non-positive loop bound");
    _jump1218:;
    // Computing bound for z
    _128.d1 = j;
    if (j > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= n.d1;
    _129 *= j;
    _129 *= sizeof(_a3__a2__a2_int64_t);
    _128.data = jpl_alloc(_129);
    int64_t _130 = 0; // z
    int64_t _131 = 0; // y
    _jump1220:; // Begin body of loop
    _a3__a2__a2_int64_t _132;
    // Computing bound for A
    _132.d0 = _131;
    if (_131 > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing bound for B
    _132.d1 = n.d1;
    if (n.d1 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for C
    _132.d2 = j;
    if (j > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _131;
    _133 *= n.d1;
    _133 *= j;
    _133 *= sizeof(_a2__a2_int64_t);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // C
    int64_t _135 = 0; // B
    int64_t _136 = 0; // A
    _jump1224:; // Begin body of loop
    int64_t _137 = 0;
    _137 *= _132.d0;
    _137 += _136;
    _137 *= _132.d1;
    _137 += _135;
    _137 *= _132.d2;
    _137 += _134;
    _132.data[_137] = n;
    _134++;
    if (_134 < j)
    goto _jump1224;
    _134 = 0;
    _135++;
    if (_135 < n.d1)
    goto _jump1224;
    _135 = 0;
    _136++;
    if (_136 < _131)
    goto _jump1224;
    // End body of loop
    int64_t _138 = 0;
    _138 *= _128.d0;
    _138 += _131;
    _138 *= _128.d1;
    _138 += _130;
    _128.data[_138] = _132;
    _130++;
    if (_130 < j)
    goto _jump1220;
    _130 = 0;
    _131++;
    if (_131 < n.d1)
    goto _jump1220;
    // End body of loop
    _127 = _128;
    goto _jump1225;
    _jump1217:;
    _a2__a3__a2__a2_int64_t _139;
    // Computing bound for y
    _139.d0 = j;
    if (j > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for z
    bool _140 = false;
    int64_t _141;
    if (!_140)
    goto _jump1227;
    _141 = q;
    goto _jump1228;
    _jump1227:;
    _141 = k;
    _jump1228:;
    _139.d1 = _141;
    if (_141 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= j;
    _142 *= _141;
    _142 *= sizeof(_a3__a2__a2_int64_t);
    _139.data = jpl_alloc(_142);
    int64_t _143 = 0; // z
    int64_t _144 = 0; // y
    _jump1230:; // Begin body of loop
    _a3__a2__a2_int64_t _145;
    // Computing bound for A
    _145.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump1231;
    fail_assertion("non-positive loop bound");
    _jump1231:;
    // Computing bound for B
    _145.d1 = _144;
    if (_144 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    // Computing bound for C
    _145.d2 = n.d0;
    if (n.d0 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= r.d0;
    _146 *= _144;
    _146 *= n.d0;
    _146 *= sizeof(_a2__a2_int64_t);
    _145.data = jpl_alloc(_146);
    int64_t _147 = 0; // C
    int64_t _148 = 0; // B
    int64_t _149 = 0; // A
    _jump1234:; // Begin body of loop
    int64_t _150 = 0;
    _150 *= _145.d0;
    _150 += _149;
    _150 *= _145.d1;
    _150 += _148;
    _150 *= _145.d2;
    _150 += _147;
    _145.data[_150] = n;
    _147++;
    if (_147 < n.d0)
    goto _jump1234;
    _147 = 0;
    _148++;
    if (_148 < _144)
    goto _jump1234;
    _148 = 0;
    _149++;
    if (_149 < r.d0)
    goto _jump1234;
    // End body of loop
    int64_t _151 = 0;
    _151 *= _139.d0;
    _151 += _144;
    _151 *= _139.d1;
    _151 += _143;
    _139.data[_151] = _145;
    _143++;
    if (_143 < _141)
    goto _jump1230;
    _143 = 0;
    _144++;
    if (_144 < j)
    goto _jump1230;
    // End body of loop
    _127 = _139;
    _jump1225:;
    if (q >= 0)
    goto _jump1235;
    fail_assertion("negative array index");
    _jump1235:;
    if (q < _127.d0)
    goto _jump1236;
    fail_assertion("index too large");
    _jump1236:;
    if (n.d0 >= 0)
    goto _jump1237;
    fail_assertion("negative array index");
    _jump1237:;
    if (n.d0 < _127.d1)
    goto _jump1238;
    fail_assertion("index too large");
    _jump1238:;
    int64_t _152 = 0;
    _152 *= _127.d0;
    _152 += q;
    _152 *= _127.d1;
    _152 += n.d0;
    _a3__a2__a2_int64_t _153 = _127.data[_152];
    int64_t _154;
    // Computing bound for y
    int64_t _155;
    // Computing bound for y
    int64_t _156 = 806;
    if (k >= 0)
    goto _jump1239;
    fail_assertion("negative array index");
    _jump1239:;
    if (k < i.d0)
    goto _jump1240;
    fail_assertion("index too large");
    _jump1240:;
    if (_156 >= 0)
    goto _jump1241;
    fail_assertion("negative array index");
    _jump1241:;
    if (_156 < i.d1)
    goto _jump1242;
    fail_assertion("index too large");
    _jump1242:;
    int64_t _157 = 0;
    _157 *= i.d0;
    _157 += k;
    _157 *= i.d1;
    _157 += _156;
    int64_t _158 = i.data[_157];
    if (_158 > 0) 
    goto _jump1243;
    fail_assertion("non-positive loop bound");
    _jump1243:;
    // Computing bound for z
    if (n.d1 > 0) 
    goto _jump1244;
    fail_assertion("non-positive loop bound");
    _jump1244:;
    _155 = 0;
    int64_t _159 = 0; // z
    int64_t _160 = 0; // y
    _jump1245:; // Begin body of loop
    _155 += r.d1;
    _159++;
    if (_159 < n.d1)
    goto _jump1245;
    _159 = 0;
    _160++;
    if (_160 < _158)
    goto _jump1245;
    // End body of loop
    if (_155 > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    _154 = 0;
    int64_t _161 = 0; // y
    _jump1247:; // Begin body of loop
    _154 += h;
    _161++;
    if (_161 < _155)
    goto _jump1247;
    // End body of loop
    int64_t _162 = r.d2 % g;
    if (_154 >= 0)
    goto _jump1248;
    fail_assertion("negative array index");
    _jump1248:;
    if (_154 < _153.d0)
    goto _jump1249;
    fail_assertion("index too large");
    _jump1249:;
    if (n.d1 >= 0)
    goto _jump1250;
    fail_assertion("negative array index");
    _jump1250:;
    if (n.d1 < _153.d1)
    goto _jump1251;
    fail_assertion("index too large");
    _jump1251:;
    if (_162 >= 0)
    goto _jump1252;
    fail_assertion("negative array index");
    _jump1252:;
    if (_162 < _153.d2)
    goto _jump1253;
    fail_assertion("index too large");
    _jump1253:;
    int64_t _163 = 0;
    _163 *= _153.d0;
    _163 += _154;
    _163 *= _153.d1;
    _163 += n.d1;
    _163 *= _153.d2;
    _163 += _162;
    _a2__a2_int64_t _164 = _153.data[_163];
    _a3_bool _165;
    // Computing bound for y
    _165.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    // Computing bound for z
    _165.d1 = f;
    if (f > 0) 
    goto _jump1255;
    fail_assertion("non-positive loop bound");
    _jump1255:;
    // Computing bound for A
    int64_t _166 = n.d0 * n.d0;
    _165.d2 = _166;
    if (_166 > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= n.d0;
    _167 *= f;
    _167 *= _166;
    _167 *= sizeof(bool);
    _165.data = jpl_alloc(_167);
    int64_t _168 = 0; // A
    int64_t _169 = 0; // z
    int64_t _170 = 0; // y
    _jump1257:; // Begin body of loop
    bool _172 = _168 != g;
    bool _171 = _172;
    if (0 == _172)
    goto _jump1258;
    bool _173 = true;
    bool _174 = !_173;
    _171 = _174;
    _jump1258:;
    bool _175 = !_171;
    bool _176 = !_175;
    int64_t _177 = 0;
    _177 *= _165.d0;
    _177 += _170;
    _177 *= _165.d1;
    _177 += _169;
    _177 *= _165.d2;
    _177 += _168;
    _165.data[_177] = _176;
    _168++;
    if (_168 < _166)
    goto _jump1257;
    _168 = 0;
    _169++;
    if (_169 < f)
    goto _jump1257;
    _169 = 0;
    _170++;
    if (_170 < n.d0)
    goto _jump1257;
    // End body of loop
    rgba _178 = m(_164, n.d0, _165);
    _123 = _178;
    goto _jump1259;
    _jump1216:;
    bool _179 = false;
    rgba _180;
    if (!_179)
    goto _jump1260;
    int64_t _181 = -r.d0;
    bool _182 = r.d2 > _181;
    double _183;
    if (!_182)
    goto _jump1261;
    double _184 = 90.0;
    double _185 = 51.0;
    double _186 = 56.0;
    if (n.d1 >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (n.d1 < c.d0)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    int64_t _187 = 0;
    _187 *= c.d0;
    _187 += n.d1;
    double _188 = c.data[_187];
    rgba _189 = { _184, _185, _186, _188 };
    double _190 = _189.r;
    _183 = _190;
    goto _jump1264;
    _jump1261:;
    _a2__a2_int64_t _191;
    // Computing bound for y
    _191.d0 = j;
    if (j > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    // Computing bound for z
    int64_t _192 = 229;
    _191.d1 = _192;
    if (_192 > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= j;
    _193 *= _192;
    _193 *= sizeof(_a2_int64_t);
    _191.data = jpl_alloc(_193);
    int64_t _194 = 0; // z
    int64_t _195 = 0; // y
    _jump1267:; // Begin body of loop
    int64_t _196 = 0;
    _196 *= _191.d0;
    _196 += _195;
    _196 *= _191.d1;
    _196 += _194;
    _191.data[_196] = i;
    _194++;
    if (_194 < _192)
    goto _jump1267;
    _194 = 0;
    _195++;
    if (_195 < j)
    goto _jump1267;
    // End body of loop
    _a3_bool _197;
    // Computing bound for y
    _197.d0 = r.d2;
    if (r.d2 > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    // Computing bound for z
    _197.d1 = r.d2;
    if (r.d2 > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    // Computing bound for A
    _197.d2 = k;
    if (k > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    // Computing total size of heap memory to allocate
    int64_t _198 = 1;
    _198 *= r.d2;
    _198 *= r.d2;
    _198 *= k;
    _198 *= sizeof(bool);
    _197.data = jpl_alloc(_198);
    int64_t _199 = 0; // A
    int64_t _200 = 0; // z
    int64_t _201 = 0; // y
    _jump1271:; // Begin body of loop
    bool _202 = true;
    int64_t _203 = 0;
    _203 *= _197.d0;
    _203 += _201;
    _203 *= _197.d1;
    _203 += _200;
    _203 *= _197.d2;
    _203 += _199;
    _197.data[_203] = _202;
    _199++;
    if (_199 < k)
    goto _jump1271;
    _199 = 0;
    _200++;
    if (_200 < r.d2)
    goto _jump1271;
    _200 = 0;
    _201++;
    if (_201 < r.d2)
    goto _jump1271;
    // End body of loop
    rgba _204 = m(_191, h, _197);
    double _205 = _204.g;
    _183 = _205;
    _jump1264:;
    int64_t _206;
    // Computing bound for y
    if (k > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for z
    int64_t _207 = h * r.d0;
    if (_207 > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    _206 = 0;
    int64_t _208 = 0; // z
    int64_t _209 = 0; // y
    _jump1274:; // Begin body of loop
    _206 += h;
    _208++;
    if (_208 < _207)
    goto _jump1274;
    _208 = 0;
    _209++;
    if (_209 < k)
    goto _jump1274;
    // End body of loop
    bool _210 = _206 >= n.d1;
    double _211;
    if (!_210)
    goto _jump1275;
    _a3_double _212;
    // Computing bound for y
    _212.d0 = r.d2;
    if (r.d2 > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    // Computing bound for z
    _212.d1 = g;
    if (g > 0) 
    goto _jump1277;
    fail_assertion("non-positive loop bound");
    _jump1277:;
    // Computing bound for A
    _212.d2 = h;
    if (h > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= r.d2;
    _213 *= g;
    _213 *= h;
    _213 *= sizeof(double);
    _212.data = jpl_alloc(_213);
    int64_t _214 = 0; // A
    int64_t _215 = 0; // z
    int64_t _216 = 0; // y
    _jump1279:; // Begin body of loop
    double _217 = 43.0;
    double _218 = -_217;
    int64_t _219 = 0;
    _219 *= _212.d0;
    _219 += _216;
    _219 *= _212.d1;
    _219 += _215;
    _219 *= _212.d2;
    _219 += _214;
    _212.data[_219] = _218;
    _214++;
    if (_214 < h)
    goto _jump1279;
    _214 = 0;
    _215++;
    if (_215 < g)
    goto _jump1279;
    _215 = 0;
    _216++;
    if (_216 < r.d2)
    goto _jump1279;
    // End body of loop
    int64_t _220 = 416;
    int64_t _221;
    // Computing bound for y
    int64_t _222 = 211;
    if (_222 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    _221 = 0;
    int64_t _223 = 0; // y
    _jump1281:; // Begin body of loop
    _221 += n.d0;
    _223++;
    if (_223 < _222)
    goto _jump1281;
    // End body of loop
    int64_t _224 = _221 * n.d1;
    if (n.d1 >= 0)
    goto _jump1282;
    fail_assertion("negative array index");
    _jump1282:;
    if (n.d1 < _212.d0)
    goto _jump1283;
    fail_assertion("index too large");
    _jump1283:;
    if (_220 >= 0)
    goto _jump1284;
    fail_assertion("negative array index");
    _jump1284:;
    if (_220 < _212.d1)
    goto _jump1285;
    fail_assertion("index too large");
    _jump1285:;
    if (_224 >= 0)
    goto _jump1286;
    fail_assertion("negative array index");
    _jump1286:;
    if (_224 < _212.d2)
    goto _jump1287;
    fail_assertion("index too large");
    _jump1287:;
    int64_t _225 = 0;
    _225 *= _212.d0;
    _225 += n.d1;
    _225 *= _212.d1;
    _225 += _220;
    _225 *= _212.d2;
    _225 += _224;
    double _226 = _212.data[_225];
    _211 = _226;
    goto _jump1288;
    _jump1275:;
    double _227;
    // Computing bound for y
    if (r.d1 > 0) 
    goto _jump1289;
    fail_assertion("non-positive loop bound");
    _jump1289:;
    // Computing bound for z
    int64_t _228 = f / n.d0;
    if (_228 > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    _227 = 0;
    int64_t _229 = 0; // z
    int64_t _230 = 0; // y
    _jump1291:; // Begin body of loop
    double _231;
    // Computing bound for A
    if (r.d1 > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing bound for B
    if (_230 > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing bound for C
    if (q > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    _231 = 0;
    int64_t _232 = 0; // C
    int64_t _233 = 0; // B
    int64_t _234 = 0; // A
    _jump1295:; // Begin body of loop
    double _235 = 84.0;
    _231 += _235;
    _232++;
    if (_232 < q)
    goto _jump1295;
    _232 = 0;
    _233++;
    if (_233 < _230)
    goto _jump1295;
    _233 = 0;
    _234++;
    if (_234 < r.d1)
    goto _jump1295;
    // End body of loop
    _227 += _231;
    _229++;
    if (_229 < _228)
    goto _jump1291;
    _229 = 0;
    _230++;
    if (_230 < r.d1)
    goto _jump1291;
    // End body of loop
    double _236 = -_227;
    _211 = _236;
    _jump1288:;
    _a1_rgba _237;
    // Computing bound for y
    _237.d0 = r.d1;
    if (r.d1 > 0) 
    goto _jump1296;
    fail_assertion("non-positive loop bound");
    _jump1296:;
    // Computing total size of heap memory to allocate
    int64_t _238 = 1;
    _238 *= r.d1;
    _238 *= sizeof(rgba);
    _237.data = jpl_alloc(_238);
    int64_t _239 = 0; // y
    _jump1297:; // Begin body of loop
    rgba _240 = m(n, n.d1, r);
    int64_t _241 = 0;
    _241 *= _237.d0;
    _241 += _239;
    _237.data[_241] = _240;
    _239++;
    if (_239 < r.d1)
    goto _jump1297;
    // End body of loop
    if (q >= 0)
    goto _jump1298;
    fail_assertion("negative array index");
    _jump1298:;
    if (q < _237.d0)
    goto _jump1299;
    fail_assertion("index too large");
    _jump1299:;
    int64_t _242 = 0;
    _242 *= _237.d0;
    _242 += q;
    rgba _243 = _237.data[_242];
    double _244 = _243.r;
    _a3_double _245;
    // Computing bound for y
    _245.d0 = r.d1;
    if (r.d1 > 0) 
    goto _jump1300;
    fail_assertion("non-positive loop bound");
    _jump1300:;
    // Computing bound for z
    int64_t _246;
    // Computing bound for y
    if (n.d0 > 0) 
    goto _jump1301;
    fail_assertion("non-positive loop bound");
    _jump1301:;
    // Computing bound for z
    if (j > 0) 
    goto _jump1302;
    fail_assertion("non-positive loop bound");
    _jump1302:;
    // Computing bound for A
    if (q > 0) 
    goto _jump1303;
    fail_assertion("non-positive loop bound");
    _jump1303:;
    _246 = 0;
    int64_t _247 = 0; // A
    int64_t _248 = 0; // z
    int64_t _249 = 0; // y
    _jump1304:; // Begin body of loop
    _246 += g;
    _247++;
    if (_247 < q)
    goto _jump1304;
    _247 = 0;
    _248++;
    if (_248 < j)
    goto _jump1304;
    _248 = 0;
    _249++;
    if (_249 < n.d0)
    goto _jump1304;
    // End body of loop
    _245.d1 = _246;
    if (_246 > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing bound for A
    _245.d2 = r.d1;
    if (r.d1 > 0) 
    goto _jump1306;
    fail_assertion("non-positive loop bound");
    _jump1306:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= r.d1;
    _250 *= _246;
    _250 *= r.d1;
    _250 *= sizeof(double);
    _245.data = jpl_alloc(_250);
    int64_t _251 = 0; // A
    int64_t _252 = 0; // z
    int64_t _253 = 0; // y
    _jump1307:; // Begin body of loop
    double _254 = 47.0;
    int64_t _255 = 0;
    _255 *= _245.d0;
    _255 += _253;
    _255 *= _245.d1;
    _255 += _252;
    _255 *= _245.d2;
    _255 += _251;
    _245.data[_255] = _254;
    _251++;
    if (_251 < r.d1)
    goto _jump1307;
    _251 = 0;
    _252++;
    if (_252 < _246)
    goto _jump1307;
    _252 = 0;
    _253++;
    if (_253 < r.d1)
    goto _jump1307;
    // End body of loop
    bool _256 = true;
    bool _257 = !_256;
    int64_t _258;
    if (!_257)
    goto _jump1308;
    _258 = h;
    goto _jump1309;
    _jump1308:;
    _258 = g;
    _jump1309:;
    if (n.d0 >= 0)
    goto _jump1310;
    fail_assertion("negative array index");
    _jump1310:;
    if (n.d0 < _245.d0)
    goto _jump1311;
    fail_assertion("index too large");
    _jump1311:;
    if (n.d0 >= 0)
    goto _jump1312;
    fail_assertion("negative array index");
    _jump1312:;
    if (n.d0 < _245.d1)
    goto _jump1313;
    fail_assertion("index too large");
    _jump1313:;
    if (_258 >= 0)
    goto _jump1314;
    fail_assertion("negative array index");
    _jump1314:;
    if (_258 < _245.d2)
    goto _jump1315;
    fail_assertion("index too large");
    _jump1315:;
    int64_t _259 = 0;
    _259 *= _245.d0;
    _259 += n.d0;
    _259 *= _245.d1;
    _259 += n.d0;
    _259 *= _245.d2;
    _259 += _258;
    double _260 = _245.data[_259];
    double _261 = -_260;
    rgba _262 = { _183, _211, _244, _261 };
    _180 = _262;
    goto _jump1316;
    _jump1260:;
    _a1__a2__a2_int64_t _263;
    // Computing bound for y
    _263.d0 = r.d2;
    if (r.d2 > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= r.d2;
    _264 *= sizeof(_a2__a2_int64_t);
    _263.data = jpl_alloc(_264);
    int64_t _265 = 0; // y
    _jump1318:; // Begin body of loop
    int64_t _266 = 0;
    _266 *= _263.d0;
    _266 += _265;
    _263.data[_266] = n;
    _265++;
    if (_265 < r.d2)
    goto _jump1318;
    // End body of loop
    if (h >= 0)
    goto _jump1319;
    fail_assertion("negative array index");
    _jump1319:;
    if (h < _263.d0)
    goto _jump1320;
    fail_assertion("index too large");
    _jump1320:;
    int64_t _267 = 0;
    _267 *= _263.d0;
    _267 += h;
    _a2__a2_int64_t _268 = _263.data[_267];
    _a3_bool _269;
    // Computing bound for y
    _269.d0 = n.d1;
    if (n.d1 > 0) 
    goto _jump1321;
    fail_assertion("non-positive loop bound");
    _jump1321:;
    // Computing bound for z
    _269.d1 = j;
    if (j > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing bound for A
    _269.d2 = f;
    if (f > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    // Computing total size of heap memory to allocate
    int64_t _270 = 1;
    _270 *= n.d1;
    _270 *= j;
    _270 *= f;
    _270 *= sizeof(bool);
    _269.data = jpl_alloc(_270);
    int64_t _271 = 0; // A
    int64_t _272 = 0; // z
    int64_t _273 = 0; // y
    _jump1324:; // Begin body of loop
    bool _275 = true;
    bool _276 = !_275;
    bool _274 = _276;
    if (0 != _276)
    goto _jump1325;
    bool _277 = k > _273;
    _274 = _277;
    _jump1325:;
    int64_t _278 = 0;
    _278 *= _269.d0;
    _278 += _273;
    _278 *= _269.d1;
    _278 += _272;
    _278 *= _269.d2;
    _278 += _271;
    _269.data[_278] = _274;
    _271++;
    if (_271 < f)
    goto _jump1324;
    _271 = 0;
    _272++;
    if (_272 < j)
    goto _jump1324;
    _272 = 0;
    _273++;
    if (_273 < n.d1)
    goto _jump1324;
    // End body of loop
    rgba _279 = m(_268, f, _269);
    _180 = _279;
    _jump1316:;
    _123 = _180;
    _jump1259:;
    return _123;
    _a1_int64_t _280;
    _280.d0 = 1;
    _280.data = jpl_alloc(sizeof(int64_t) * 1);
    _280.data[0] = n.d0;
    _a3_rgba _281;
    // Computing bound for D
    _a3_bool _282;
    // Computing bound for D
    _282.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    // Computing bound for E
    _282.d1 = n.d0;
    if (n.d0 > 0) 
    goto _jump1327;
    fail_assertion("non-positive loop bound");
    _jump1327:;
    // Computing bound for F
    _282.d2 = j;
    if (j > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    // Computing total size of heap memory to allocate
    int64_t _283 = 1;
    _283 *= r.d0;
    _283 *= n.d0;
    _283 *= j;
    _283 *= sizeof(bool);
    _282.data = jpl_alloc(_283);
    int64_t _284 = 0; // F
    int64_t _285 = 0; // E
    int64_t _286 = 0; // D
    _jump1329:; // Begin body of loop
    bool _287 = false;
    int64_t _288 = 0;
    _288 *= _282.d0;
    _288 += _286;
    _288 *= _282.d1;
    _288 += _285;
    _288 *= _282.d2;
    _288 += _284;
    _282.data[_288] = _287;
    _284++;
    if (_284 < j)
    goto _jump1329;
    _284 = 0;
    _285++;
    if (_285 < n.d0)
    goto _jump1329;
    _285 = 0;
    _286++;
    if (_286 < r.d0)
    goto _jump1329;
    // End body of loop
    int64_t _289;
    // Computing bound for D
    if (k > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    // Computing bound for E
    if (n.d0 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    _289 = 0;
    int64_t _290 = 0; // E
    int64_t _291 = 0; // D
    _jump1332:; // Begin body of loop
    _289 += _291;
    _290++;
    if (_290 < n.d0)
    goto _jump1332;
    _290 = 0;
    _291++;
    if (_291 < k)
    goto _jump1332;
    // End body of loop
    int64_t _292 = _289 + n.d1;
    if (n.d1 >= 0)
    goto _jump1333;
    fail_assertion("negative array index");
    _jump1333:;
    if (n.d1 < _282.d0)
    goto _jump1334;
    fail_assertion("index too large");
    _jump1334:;
    if (_292 >= 0)
    goto _jump1335;
    fail_assertion("negative array index");
    _jump1335:;
    if (_292 < _282.d1)
    goto _jump1336;
    fail_assertion("index too large");
    _jump1336:;
    if (g >= 0)
    goto _jump1337;
    fail_assertion("negative array index");
    _jump1337:;
    if (g < _282.d2)
    goto _jump1338;
    fail_assertion("index too large");
    _jump1338:;
    int64_t _293 = 0;
    _293 *= _282.d0;
    _293 += n.d1;
    _293 *= _282.d1;
    _293 += _292;
    _293 *= _282.d2;
    _293 += g;
    bool _294 = _282.data[_293];
    _a2_bool _295;
    if (!_294)
    goto _jump1339;
    _a2_bool _296;
    // Computing bound for D
    int64_t _297 = 194;
    int64_t _298 = k % _297;
    if (_298 >= 0)
    goto _jump1340;
    fail_assertion("negative array index");
    _jump1340:;
    if (_298 < _280.d0)
    goto _jump1341;
    fail_assertion("index too large");
    _jump1341:;
    int64_t _299 = 0;
    _299 *= _280.d0;
    _299 += _298;
    int64_t _300 = _280.data[_299];
    _296.d0 = _300;
    if (_300 > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    // Computing bound for E
    _296.d1 = g;
    if (g > 0) 
    goto _jump1343;
    fail_assertion("non-positive loop bound");
    _jump1343:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= _300;
    _301 *= g;
    _301 *= sizeof(bool);
    _296.data = jpl_alloc(_301);
    int64_t _302 = 0; // E
    int64_t _303 = 0; // D
    _jump1344:; // Begin body of loop
    bool _305 = k < q;
    bool _304 = _305;
    if (0 == _305)
    goto _jump1345;
    bool _306 = true;
    _304 = _306;
    _jump1345:;
    int64_t _307 = 0;
    _307 *= _296.d0;
    _307 += _303;
    _307 *= _296.d1;
    _307 += _302;
    _296.data[_307] = _304;
    _302++;
    if (_302 < g)
    goto _jump1344;
    _302 = 0;
    _303++;
    if (_303 < _300)
    goto _jump1344;
    // End body of loop
    _295 = _296;
    goto _jump1346;
    _jump1339:;
    _a2_bool _308;
    // Computing bound for D
    _308.d0 = n.d1;
    if (n.d1 > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing bound for E
    _308.d1 = r.d1;
    if (r.d1 > 0) 
    goto _jump1348;
    fail_assertion("non-positive loop bound");
    _jump1348:;
    // Computing total size of heap memory to allocate
    int64_t _309 = 1;
    _309 *= n.d1;
    _309 *= r.d1;
    _309 *= sizeof(bool);
    _308.data = jpl_alloc(_309);
    int64_t _310 = 0; // E
    int64_t _311 = 0; // D
    _jump1349:; // Begin body of loop
    bool _312 = r.d1 > k;
    bool _313;
    if (!_312)
    goto _jump1350;
    bool _315 = true;
    bool _314 = _315;
    if (0 == _315)
    goto _jump1351;
    bool _316 = false;
    _314 = _316;
    _jump1351:;
    _313 = _314;
    goto _jump1352;
    _jump1350:;
    bool _317 = _310 > q;
    _313 = _317;
    _jump1352:;
    int64_t _318 = 0;
    _318 *= _308.d0;
    _318 += _311;
    _318 *= _308.d1;
    _318 += _310;
    _308.data[_318] = _313;
    _310++;
    if (_310 < r.d1)
    goto _jump1349;
    _310 = 0;
    _311++;
    if (_311 < n.d1)
    goto _jump1349;
    // End body of loop
    _295 = _308;
    _jump1346:;
    double _320 = 30.0;
    double _321 = 4.0;
    bool _322 = _320 < _321;
    bool _319 = _322;
    if (0 != _322)
    goto _jump1353;
    bool _323 = n.d0 <= h;
    _319 = _323;
    _jump1353:;
    _a2_bool _324;
    // Computing bound for D
    _324.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1354;
    fail_assertion("non-positive loop bound");
    _jump1354:;
    // Computing bound for E
    _324.d1 = n.d1;
    if (n.d1 > 0) 
    goto _jump1355;
    fail_assertion("non-positive loop bound");
    _jump1355:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= n.d0;
    _325 *= n.d1;
    _325 *= sizeof(bool);
    _324.data = jpl_alloc(_325);
    int64_t _326 = 0; // E
    int64_t _327 = 0; // D
    _jump1356:; // Begin body of loop
    bool _328 = false;
    int64_t _329 = 0;
    _329 *= _324.d0;
    _329 += _327;
    _329 *= _324.d1;
    _329 += _326;
    _324.data[_329] = _328;
    _326++;
    if (_326 < n.d1)
    goto _jump1356;
    _326 = 0;
    _327++;
    if (_327 < n.d0)
    goto _jump1356;
    // End body of loop
    if (q >= 0)
    goto _jump1357;
    fail_assertion("negative array index");
    _jump1357:;
    if (q < _324.d0)
    goto _jump1358;
    fail_assertion("index too large");
    _jump1358:;
    if (n.d0 >= 0)
    goto _jump1359;
    fail_assertion("negative array index");
    _jump1359:;
    if (n.d0 < _324.d1)
    goto _jump1360;
    fail_assertion("index too large");
    _jump1360:;
    int64_t _330 = 0;
    _330 *= _324.d0;
    _330 += q;
    _330 *= _324.d1;
    _330 += n.d0;
    bool _331 = _324.data[_330];
    bool _332 = false;
    _a1_bool _333;
    _333.d0 = 3;
    _333.data = jpl_alloc(sizeof(bool) * 3);
    _333.data[0] = _319;
    _333.data[1] = _331;
    _333.data[2] = _332;
    double _334 = 40.0;
    double _335 = 74.0;
    bool _336 = _334 > _335;
    bool _337;
    if (!_336)
    goto _jump1361;
    bool _338 = j < f;
    _337 = _338;
    goto _jump1362;
    _jump1361:;
    bool _339 = true;
    _337 = _339;
    _jump1362:;
    _a1_bool _340;
    _340.d0 = 1;
    _340.data = jpl_alloc(sizeof(bool) * 1);
    _340.data[0] = _337;
    void_t _341 = b(_333, _340);
    int64_t _342 = a(_295, _341);
    _281.d0 = _342;
    if (_342 > 0) 
    goto _jump1363;
    fail_assertion("non-positive loop bound");
    _jump1363:;
    // Computing bound for E
    bool _343 = true;
    bool _344;
    if (!_343)
    goto _jump1364;
    bool _345 = true;
    _344 = _345;
    goto _jump1365;
    _jump1364:;
    if (n.d0 >= 0)
    goto _jump1366;
    fail_assertion("negative array index");
    _jump1366:;
    if (n.d0 < r.d0)
    goto _jump1367;
    fail_assertion("index too large");
    _jump1367:;
    if (r.d2 >= 0)
    goto _jump1368;
    fail_assertion("negative array index");
    _jump1368:;
    if (r.d2 < r.d1)
    goto _jump1369;
    fail_assertion("index too large");
    _jump1369:;
    if (n.d0 >= 0)
    goto _jump1370;
    fail_assertion("negative array index");
    _jump1370:;
    if (n.d0 < r.d2)
    goto _jump1371;
    fail_assertion("index too large");
    _jump1371:;
    int64_t _346 = 0;
    _346 *= r.d0;
    _346 += n.d0;
    _346 *= r.d1;
    _346 += r.d2;
    _346 *= r.d2;
    _346 += n.d0;
    bool _347 = r.data[_346];
    _344 = _347;
    _jump1365:;
    bool _348;
    if (!_344)
    goto _jump1372;
    int64_t _349 = -r.d0;
    if (_349 >= 0)
    goto _jump1373;
    fail_assertion("negative array index");
    _jump1373:;
    if (_349 < r.d0)
    goto _jump1374;
    fail_assertion("index too large");
    _jump1374:;
    if (q >= 0)
    goto _jump1375;
    fail_assertion("negative array index");
    _jump1375:;
    if (q < r.d1)
    goto _jump1376;
    fail_assertion("index too large");
    _jump1376:;
    if (f >= 0)
    goto _jump1377;
    fail_assertion("negative array index");
    _jump1377:;
    if (f < r.d2)
    goto _jump1378;
    fail_assertion("index too large");
    _jump1378:;
    int64_t _350 = 0;
    _350 *= r.d0;
    _350 += _349;
    _350 *= r.d1;
    _350 += q;
    _350 *= r.d2;
    _350 += f;
    bool _351 = r.data[_350];
    _348 = _351;
    goto _jump1379;
    _jump1372:;
    double _352 = 13.0;
    double _353;
    // Computing bound for D
    if (n.d1 > 0) 
    goto _jump1380;
    fail_assertion("non-positive loop bound");
    _jump1380:;
    // Computing bound for E
    if (r.d2 > 0) 
    goto _jump1381;
    fail_assertion("non-positive loop bound");
    _jump1381:;
    // Computing bound for F
    int64_t _354 = 647;
    if (_354 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    _353 = 0;
    int64_t _355 = 0; // F
    int64_t _356 = 0; // E
    int64_t _357 = 0; // D
    _jump1383:; // Begin body of loop
    double _358 = 1.0;
    _353 += _358;
    _355++;
    if (_355 < _354)
    goto _jump1383;
    _355 = 0;
    _356++;
    if (_356 < r.d2)
    goto _jump1383;
    _356 = 0;
    _357++;
    if (_357 < n.d1)
    goto _jump1383;
    // End body of loop
    bool _359 = _352 == _353;
    _348 = _359;
    _jump1379:;
    _a2_bool _360;
    if (!_348)
    goto _jump1384;
    _a2_bool _361;
    // Computing bound for D
    _361.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1385;
    fail_assertion("non-positive loop bound");
    _jump1385:;
    // Computing bound for E
    bool _362 = true;
    _a3_int64_t _363;
    if (!_362)
    goto _jump1386;
    _363 = e;
    goto _jump1387;
    _jump1386:;
    _363 = e;
    _jump1387:;
    if (n.d1 >= 0)
    goto _jump1388;
    fail_assertion("negative array index");
    _jump1388:;
    if (n.d1 < _363.d0)
    goto _jump1389;
    fail_assertion("index too large");
    _jump1389:;
    if (n.d0 >= 0)
    goto _jump1390;
    fail_assertion("negative array index");
    _jump1390:;
    if (n.d0 < _363.d1)
    goto _jump1391;
    fail_assertion("index too large");
    _jump1391:;
    if (r.d2 >= 0)
    goto _jump1392;
    fail_assertion("negative array index");
    _jump1392:;
    if (r.d2 < _363.d2)
    goto _jump1393;
    fail_assertion("index too large");
    _jump1393:;
    int64_t _364 = 0;
    _364 *= _363.d0;
    _364 += n.d1;
    _364 *= _363.d1;
    _364 += n.d0;
    _364 *= _363.d2;
    _364 += r.d2;
    int64_t _365 = _363.data[_364];
    _361.d1 = _365;
    if (_365 > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing total size of heap memory to allocate
    int64_t _366 = 1;
    _366 *= n.d0;
    _366 *= _365;
    _366 *= sizeof(bool);
    _361.data = jpl_alloc(_366);
    int64_t _367 = 0; // E
    int64_t _368 = 0; // D
    _jump1395:; // Begin body of loop
    bool _370 = true;
    bool _369 = _370;
    if (0 == _370)
    goto _jump1396;
    bool _371 = true;
    _369 = _371;
    _jump1396:;
    int64_t _372 = 0;
    _372 *= _361.d0;
    _372 += _368;
    _372 *= _361.d1;
    _372 += _367;
    _361.data[_372] = _369;
    _367++;
    if (_367 < _365)
    goto _jump1395;
    _367 = 0;
    _368++;
    if (_368 < n.d0)
    goto _jump1395;
    // End body of loop
    _360 = _361;
    goto _jump1397;
    _jump1384:;
    bool _373 = n.d1 <= k;
    bool _374 = !_373;
    _a2_bool _375;
    if (!_374)
    goto _jump1398;
    _a2_bool _376;
    // Computing bound for D
    _376.d0 = f;
    if (f > 0) 
    goto _jump1399;
    fail_assertion("non-positive loop bound");
    _jump1399:;
    // Computing bound for E
    _376.d1 = n.d0;
    if (n.d0 > 0) 
    goto _jump1400;
    fail_assertion("non-positive loop bound");
    _jump1400:;
    // Computing total size of heap memory to allocate
    int64_t _377 = 1;
    _377 *= f;
    _377 *= n.d0;
    _377 *= sizeof(bool);
    _376.data = jpl_alloc(_377);
    int64_t _378 = 0; // E
    int64_t _379 = 0; // D
    _jump1401:; // Begin body of loop
    bool _380 = h <= _378;
    int64_t _381 = 0;
    _381 *= _376.d0;
    _381 += _379;
    _381 *= _376.d1;
    _381 += _378;
    _376.data[_381] = _380;
    _378++;
    if (_378 < n.d0)
    goto _jump1401;
    _378 = 0;
    _379++;
    if (_379 < f)
    goto _jump1401;
    // End body of loop
    _375 = _376;
    goto _jump1402;
    _jump1398:;
    _a2_bool _382;
    // Computing bound for D
    int64_t _383 = -n.d1;
    _382.d0 = _383;
    if (_383 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    // Computing bound for E
    _382.d1 = r.d1;
    if (r.d1 > 0) 
    goto _jump1404;
    fail_assertion("non-positive loop bound");
    _jump1404:;
    // Computing total size of heap memory to allocate
    int64_t _384 = 1;
    _384 *= _383;
    _384 *= r.d1;
    _384 *= sizeof(bool);
    _382.data = jpl_alloc(_384);
    int64_t _385 = 0; // E
    int64_t _386 = 0; // D
    _jump1405:; // Begin body of loop
    bool _387 = n.d1 >= n.d0;
    int64_t _388 = 0;
    _388 *= _382.d0;
    _388 += _386;
    _388 *= _382.d1;
    _388 += _385;
    _382.data[_388] = _387;
    _385++;
    if (_385 < r.d1)
    goto _jump1405;
    _385 = 0;
    _386++;
    if (_386 < _383)
    goto _jump1405;
    // End body of loop
    _375 = _382;
    _jump1402:;
    _360 = _375;
    _jump1397:;
    _a3__a1_bool _389;
    // Computing bound for D
    int64_t _390 = 385;
    _389.d0 = _390;
    if (_390 > 0) 
    goto _jump1406;
    fail_assertion("non-positive loop bound");
    _jump1406:;
    // Computing bound for E
    int64_t _391 = 652;
    _389.d1 = _391;
    if (_391 > 0) 
    goto _jump1407;
    fail_assertion("non-positive loop bound");
    _jump1407:;
    // Computing bound for F
    _389.d2 = k;
    if (k > 0) 
    goto _jump1408;
    fail_assertion("non-positive loop bound");
    _jump1408:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= _390;
    _392 *= _391;
    _392 *= k;
    _392 *= sizeof(_a1_bool);
    _389.data = jpl_alloc(_392);
    int64_t _393 = 0; // F
    int64_t _394 = 0; // E
    int64_t _395 = 0; // D
    _jump1409:; // Begin body of loop
    _a1_bool _396;
    // Computing bound for G
    _396.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1410;
    fail_assertion("non-positive loop bound");
    _jump1410:;
    // Computing total size of heap memory to allocate
    int64_t _397 = 1;
    _397 *= n.d0;
    _397 *= sizeof(bool);
    _396.data = jpl_alloc(_397);
    int64_t _398 = 0; // G
    _jump1411:; // Begin body of loop
    bool _399 = false;
    int64_t _400 = 0;
    _400 *= _396.d0;
    _400 += _398;
    _396.data[_400] = _399;
    _398++;
    if (_398 < n.d0)
    goto _jump1411;
    // End body of loop
    int64_t _401 = 0;
    _401 *= _389.d0;
    _401 += _395;
    _401 *= _389.d1;
    _401 += _394;
    _401 *= _389.d2;
    _401 += _393;
    _389.data[_401] = _396;
    _393++;
    if (_393 < k)
    goto _jump1409;
    _393 = 0;
    _394++;
    if (_394 < _391)
    goto _jump1409;
    _394 = 0;
    _395++;
    if (_395 < _390)
    goto _jump1409;
    // End body of loop
    if (n.d0 >= 0)
    goto _jump1412;
    fail_assertion("negative array index");
    _jump1412:;
    if (n.d0 < _389.d0)
    goto _jump1413;
    fail_assertion("index too large");
    _jump1413:;
    if (n.d0 >= 0)
    goto _jump1414;
    fail_assertion("negative array index");
    _jump1414:;
    if (n.d0 < _389.d1)
    goto _jump1415;
    fail_assertion("index too large");
    _jump1415:;
    if (g >= 0)
    goto _jump1416;
    fail_assertion("negative array index");
    _jump1416:;
    if (g < _389.d2)
    goto _jump1417;
    fail_assertion("index too large");
    _jump1417:;
    int64_t _402 = 0;
    _402 *= _389.d0;
    _402 += n.d0;
    _402 *= _389.d1;
    _402 += n.d0;
    _402 *= _389.d2;
    _402 += g;
    _a1_bool _403 = _389.data[_402];
    bool _404 = true;
    bool _405 = !_404;
    int64_t _406 = 289;
    bool _407 = _406 != g;
    double _408;
    // Computing bound for D
    if (n.d0 > 0) 
    goto _jump1418;
    fail_assertion("non-positive loop bound");
    _jump1418:;
    _408 = 0;
    int64_t _409 = 0; // D
    _jump1419:; // Begin body of loop
    double _410 = 83.0;
    _408 += _410;
    _409++;
    if (_409 < n.d0)
    goto _jump1419;
    // End body of loop
    double _411 = 4.0;
    double _412 = -_411;
    bool _413 = _408 >= _412;
    _a1_bool _414;
    _414.d0 = 3;
    _414.data = jpl_alloc(sizeof(bool) * 3);
    _414.data[0] = _405;
    _414.data[1] = _407;
    _414.data[2] = _413;
    void_t _415 = b(_403, _414);
    int64_t _416 = a(_360, _415);
    _281.d1 = _416;
    if (_416 > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing bound for F
    _281.d2 = g;
    if (g > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    // Computing total size of heap memory to allocate
    int64_t _417 = 1;
    _417 *= _342;
    _417 *= _416;
    _417 *= g;
    _417 *= sizeof(rgba);
    _281.data = jpl_alloc(_417);
    int64_t _418 = 0; // F
    int64_t _419 = 0; // E
    int64_t _420 = 0; // D
    _jump1422:; // Begin body of loop
    bool _421 = _419 != j;
    double _422 = 81.0;
    double _423 = 54.0;
    bool _424 = _422 == _423;
    bool _425 = !_424;
    bool _426 = _421 != _425;
    _a2__a2_int64_t _427;
    if (!_426)
    goto _jump1423;
    _a2__a2_int64_t _428;
    // Computing bound for G
    _428.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1424;
    fail_assertion("non-positive loop bound");
    _jump1424:;
    // Computing bound for H
    _428.d1 = _418;
    if (_418 > 0) 
    goto _jump1425;
    fail_assertion("non-positive loop bound");
    _jump1425:;
    // Computing total size of heap memory to allocate
    int64_t _429 = 1;
    _429 *= n.d0;
    _429 *= _418;
    _429 *= sizeof(_a2_int64_t);
    _428.data = jpl_alloc(_429);
    int64_t _430 = 0; // H
    int64_t _431 = 0; // G
    _jump1426:; // Begin body of loop
    if (n.d0 >= 0)
    goto _jump1427;
    fail_assertion("negative array index");
    _jump1427:;
    if (n.d0 < n.d0)
    goto _jump1428;
    fail_assertion("index too large");
    _jump1428:;
    if (g >= 0)
    goto _jump1429;
    fail_assertion("negative array index");
    _jump1429:;
    if (g < n.d1)
    goto _jump1430;
    fail_assertion("index too large");
    _jump1430:;
    int64_t _432 = 0;
    _432 *= n.d0;
    _432 += n.d0;
    _432 *= n.d1;
    _432 += g;
    _a2_int64_t _433 = n.data[_432];
    int64_t _434 = 0;
    _434 *= _428.d0;
    _434 += _431;
    _434 *= _428.d1;
    _434 += _430;
    _428.data[_434] = _433;
    _430++;
    if (_430 < _418)
    goto _jump1426;
    _430 = 0;
    _431++;
    if (_431 < n.d0)
    goto _jump1426;
    // End body of loop
    _427 = _428;
    goto _jump1431;
    _jump1423:;
    _a2__a2_int64_t _435;
    // Computing bound for G
    _435.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1432;
    fail_assertion("non-positive loop bound");
    _jump1432:;
    // Computing bound for H
    _435.d1 = r.d2;
    if (r.d2 > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing total size of heap memory to allocate
    int64_t _436 = 1;
    _436 *= n.d0;
    _436 *= r.d2;
    _436 *= sizeof(_a2_int64_t);
    _435.data = jpl_alloc(_436);
    int64_t _437 = 0; // H
    int64_t _438 = 0; // G
    _jump1434:; // Begin body of loop
    int64_t _439 = 0;
    _439 *= _435.d0;
    _439 += _438;
    _439 *= _435.d1;
    _439 += _437;
    _435.data[_439] = i;
    _437++;
    if (_437 < r.d2)
    goto _jump1434;
    _437 = 0;
    _438++;
    if (_438 < n.d0)
    goto _jump1434;
    // End body of loop
    _427 = _435;
    _jump1431:;
    int64_t _440 = 346;
    _a3__a3_bool _441;
    // Computing bound for G
    _441.d0 = f;
    if (f > 0) 
    goto _jump1435;
    fail_assertion("non-positive loop bound");
    _jump1435:;
    // Computing bound for H
    int64_t _442;
    // Computing bound for G
    if (n.d1 > 0) 
    goto _jump1436;
    fail_assertion("non-positive loop bound");
    _jump1436:;
    _442 = 0;
    int64_t _443 = 0; // G
    _jump1437:; // Begin body of loop
    _442 += n.d0;
    _443++;
    if (_443 < n.d1)
    goto _jump1437;
    // End body of loop
    _441.d1 = _442;
    if (_442 > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    // Computing bound for I
    _441.d2 = _418;
    if (_418 > 0) 
    goto _jump1439;
    fail_assertion("non-positive loop bound");
    _jump1439:;
    // Computing total size of heap memory to allocate
    int64_t _444 = 1;
    _444 *= f;
    _444 *= _442;
    _444 *= _418;
    _444 *= sizeof(_a3_bool);
    _441.data = jpl_alloc(_444);
    int64_t _445 = 0; // I
    int64_t _446 = 0; // H
    int64_t _447 = 0; // G
    _jump1440:; // Begin body of loop
    bool _448 = true;
    bool _449 = !_448;
    _a3_bool _450;
    if (!_449)
    goto _jump1441;
    _450 = r;
    goto _jump1442;
    _jump1441:;
    _450 = r;
    _jump1442:;
    int64_t _451 = 0;
    _451 *= _441.d0;
    _451 += _447;
    _451 *= _441.d1;
    _451 += _446;
    _451 *= _441.d2;
    _451 += _445;
    _441.data[_451] = _450;
    _445++;
    if (_445 < _418)
    goto _jump1440;
    _445 = 0;
    _446++;
    if (_446 < _442)
    goto _jump1440;
    _446 = 0;
    _447++;
    if (_447 < f)
    goto _jump1440;
    // End body of loop
    _a1_int64_t _452;
    // Computing bound for G
    _452.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1443;
    fail_assertion("non-positive loop bound");
    _jump1443:;
    // Computing total size of heap memory to allocate
    int64_t _453 = 1;
    _453 *= n.d0;
    _453 *= sizeof(int64_t);
    _452.data = jpl_alloc(_453);
    int64_t _454 = 0; // G
    _jump1444:; // Begin body of loop
    int64_t _455 = 0;
    _455 *= _452.d0;
    _455 += _454;
    _452.data[_455] = j;
    _454++;
    if (_454 < n.d0)
    goto _jump1444;
    // End body of loop
    if (r.d2 >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (r.d2 < _452.d0)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    int64_t _456 = 0;
    _456 *= _452.d0;
    _456 += r.d2;
    int64_t _457 = _452.data[_456];
    if (q >= 0)
    goto _jump1447;
    fail_assertion("negative array index");
    _jump1447:;
    if (q < _441.d0)
    goto _jump1448;
    fail_assertion("index too large");
    _jump1448:;
    if (_457 >= 0)
    goto _jump1449;
    fail_assertion("negative array index");
    _jump1449:;
    if (_457 < _441.d1)
    goto _jump1450;
    fail_assertion("index too large");
    _jump1450:;
    if (g >= 0)
    goto _jump1451;
    fail_assertion("negative array index");
    _jump1451:;
    if (g < _441.d2)
    goto _jump1452;
    fail_assertion("index too large");
    _jump1452:;
    int64_t _458 = 0;
    _458 *= _441.d0;
    _458 += q;
    _458 *= _441.d1;
    _458 += _457;
    _458 *= _441.d2;
    _458 += g;
    _a3_bool _459 = _441.data[_458];
    rgba _460 = m(_427, _440, _459);
    int64_t _461 = 0;
    _461 *= _281.d0;
    _461 += _420;
    _461 *= _281.d1;
    _461 += _419;
    _461 *= _281.d2;
    _461 += _418;
    _281.data[_461] = _460;
    _418++;
    if (_418 < g)
    goto _jump1422;
    _418 = 0;
    _419++;
    if (_419 < _416)
    goto _jump1422;
    _419 = 0;
    _420++;
    if (_420 < _342)
    goto _jump1422;
    // End body of loop
    int64_t _462;
    // Computing bound for D
    double _463 = 73.0;
    if (k >= 0)
    goto _jump1453;
    fail_assertion("negative array index");
    _jump1453:;
    if (k < l.d0)
    goto _jump1454;
    fail_assertion("index too large");
    _jump1454:;
    int64_t _464 = 0;
    _464 *= l.d0;
    _464 += k;
    double _465 = l.data[_464];
    bool _466 = _463 != _465;
    int64_t _467;
    if (!_466)
    goto _jump1455;
    _467 = n.d0;
    goto _jump1456;
    _jump1455:;
    _467 = n.d0;
    _jump1456:;
    bool _468 = _467 == g;
    int64_t _469;
    if (!_468)
    goto _jump1457;
    _469 = g;
    goto _jump1458;
    _jump1457:;
    _a3_int64_t _470;
    // Computing bound for D
    _470.d0 = f;
    if (f > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    // Computing bound for E
    _470.d1 = r.d1;
    if (r.d1 > 0) 
    goto _jump1460;
    fail_assertion("non-positive loop bound");
    _jump1460:;
    // Computing bound for F
    int64_t _471 = n.d1 * n.d0;
    _470.d2 = _471;
    if (_471 > 0) 
    goto _jump1461;
    fail_assertion("non-positive loop bound");
    _jump1461:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= f;
    _472 *= r.d1;
    _472 *= _471;
    _472 *= sizeof(int64_t);
    _470.data = jpl_alloc(_472);
    int64_t _473 = 0; // F
    int64_t _474 = 0; // E
    int64_t _475 = 0; // D
    _jump1462:; // Begin body of loop
    bool _476 = true;
    int64_t _477;
    if (!_476)
    goto _jump1463;
    int64_t _478;
    // Computing bound for G
    if (r.d1 > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing bound for H
    if (r.d2 > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    // Computing bound for I
    if (_474 > 0) 
    goto _jump1466;
    fail_assertion("non-positive loop bound");
    _jump1466:;
    _478 = 0;
    int64_t _479 = 0; // I
    int64_t _480 = 0; // H
    int64_t _481 = 0; // G
    _jump1467:; // Begin body of loop
    _478 += q;
    _479++;
    if (_479 < _474)
    goto _jump1467;
    _479 = 0;
    _480++;
    if (_480 < r.d2)
    goto _jump1467;
    _480 = 0;
    _481++;
    if (_481 < r.d1)
    goto _jump1467;
    // End body of loop
    _477 = _478;
    goto _jump1468;
    _jump1463:;
    int64_t _482 = 738;
    _477 = _482;
    _jump1468:;
    int64_t _483 = 0;
    _483 *= _470.d0;
    _483 += _475;
    _483 *= _470.d1;
    _483 += _474;
    _483 *= _470.d2;
    _483 += _473;
    _470.data[_483] = _477;
    _473++;
    if (_473 < _471)
    goto _jump1462;
    _473 = 0;
    _474++;
    if (_474 < r.d1)
    goto _jump1462;
    _474 = 0;
    _475++;
    if (_475 < f)
    goto _jump1462;
    // End body of loop
    if (r.d2 >= 0)
    goto _jump1469;
    fail_assertion("negative array index");
    _jump1469:;
    if (r.d2 < _470.d0)
    goto _jump1470;
    fail_assertion("index too large");
    _jump1470:;
    if (j >= 0)
    goto _jump1471;
    fail_assertion("negative array index");
    _jump1471:;
    if (j < _470.d1)
    goto _jump1472;
    fail_assertion("index too large");
    _jump1472:;
    if (n.d0 >= 0)
    goto _jump1473;
    fail_assertion("negative array index");
    _jump1473:;
    if (n.d0 < _470.d2)
    goto _jump1474;
    fail_assertion("index too large");
    _jump1474:;
    int64_t _484 = 0;
    _484 *= _470.d0;
    _484 += r.d2;
    _484 *= _470.d1;
    _484 += j;
    _484 *= _470.d2;
    _484 += n.d0;
    int64_t _485 = _470.data[_484];
    _469 = _485;
    _jump1458:;
    if (_469 > 0) 
    goto _jump1475;
    fail_assertion("non-positive loop bound");
    _jump1475:;
    _462 = 0;
    int64_t _486 = 0; // D
    _jump1476:; // Begin body of loop
    _462 += g;
    _486++;
    if (_486 < _469)
    goto _jump1476;
    // End body of loop
    if (_462 >= 0)
    goto _jump1477;
    fail_assertion("negative array index");
    _jump1477:;
    if (_462 < _281.d0)
    goto _jump1478;
    fail_assertion("index too large");
    _jump1478:;
    if (r.d2 >= 0)
    goto _jump1479;
    fail_assertion("negative array index");
    _jump1479:;
    if (r.d2 < _281.d1)
    goto _jump1480;
    fail_assertion("index too large");
    _jump1480:;
    if (n.d1 >= 0)
    goto _jump1481;
    fail_assertion("negative array index");
    _jump1481:;
    if (n.d1 < _281.d2)
    goto _jump1482;
    fail_assertion("index too large");
    _jump1482:;
    int64_t _487 = 0;
    _487 *= _281.d0;
    _487 += _462;
    _487 *= _281.d1;
    _487 += r.d2;
    _487 *= _281.d2;
    _487 += n.d1;
    rgba _488 = _281.data[_487];
    return _488;
}

bool n(_a3_double o) {
    bool _2 = n(o);
    _a3_bool _3;
    if (!_2)
    goto _jump1483;
    bool _4 = o.d2 < h;
    _a3_bool _5;
    if (!_4)
    goto _jump1484;
    _a3_bool _6;
    // Computing bound for z
    _6.d0 = o.d2;
    if (o.d2 > 0) 
    goto _jump1485;
    fail_assertion("non-positive loop bound");
    _jump1485:;
    // Computing bound for A
    _6.d1 = g;
    if (g > 0) 
    goto _jump1486;
    fail_assertion("non-positive loop bound");
    _jump1486:;
    // Computing bound for B
    _6.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump1487;
    fail_assertion("non-positive loop bound");
    _jump1487:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= o.d2;
    _7 *= g;
    _7 *= o.d1;
    _7 *= sizeof(bool);
    _6.data = jpl_alloc(_7);
    int64_t _8 = 0; // B
    int64_t _9 = 0; // A
    int64_t _10 = 0; // z
    _jump1488:; // Begin body of loop
    bool _11 = f <= c.d0;
    int64_t _12 = 0;
    _12 *= _6.d0;
    _12 += _10;
    _12 *= _6.d1;
    _12 += _9;
    _12 *= _6.d2;
    _12 += _8;
    _6.data[_12] = _11;
    _8++;
    if (_8 < o.d1)
    goto _jump1488;
    _8 = 0;
    _9++;
    if (_9 < g)
    goto _jump1488;
    _9 = 0;
    _10++;
    if (_10 < o.d2)
    goto _jump1488;
    // End body of loop
    _5 = _6;
    goto _jump1489;
    _jump1484:;
    _a3_bool _13;
    // Computing bound for z
    _13.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1490;
    fail_assertion("non-positive loop bound");
    _jump1490:;
    // Computing bound for A
    int64_t _14 = -i.d0;
    _13.d1 = _14;
    if (_14 > 0) 
    goto _jump1491;
    fail_assertion("non-positive loop bound");
    _jump1491:;
    // Computing bound for B
    _13.d2 = h;
    if (h > 0) 
    goto _jump1492;
    fail_assertion("non-positive loop bound");
    _jump1492:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= i.d1;
    _15 *= _14;
    _15 *= h;
    _15 *= sizeof(bool);
    _13.data = jpl_alloc(_15);
    int64_t _16 = 0; // B
    int64_t _17 = 0; // A
    int64_t _18 = 0; // z
    _jump1493:; // Begin body of loop
    bool _19 = false;
    int64_t _20 = 0;
    _20 *= _13.d0;
    _20 += _18;
    _20 *= _13.d1;
    _20 += _17;
    _20 *= _13.d2;
    _20 += _16;
    _13.data[_20] = _19;
    _16++;
    if (_16 < h)
    goto _jump1493;
    _16 = 0;
    _17++;
    if (_17 < _14)
    goto _jump1493;
    _17 = 0;
    _18++;
    if (_18 < i.d1)
    goto _jump1493;
    // End body of loop
    _5 = _13;
    _jump1489:;
    _3 = _5;
    goto _jump1494;
    _jump1483:;
    _a3_bool _21;
    // Computing bound for z
    _21.d0 = o.d1;
    if (o.d1 > 0) 
    goto _jump1495;
    fail_assertion("non-positive loop bound");
    _jump1495:;
    // Computing bound for A
    bool _22 = true;
    bool _23 = false;
    bool _24 = _22 == _23;
    int64_t _25;
    if (!_24)
    goto _jump1496;
    _25 = i.d0;
    goto _jump1497;
    _jump1496:;
    _25 = g;
    _jump1497:;
    _21.d1 = _25;
    if (_25 > 0) 
    goto _jump1498;
    fail_assertion("non-positive loop bound");
    _jump1498:;
    // Computing bound for B
    int64_t _26 = i.d0 % j;
    _21.d2 = _26;
    if (_26 > 0) 
    goto _jump1499;
    fail_assertion("non-positive loop bound");
    _jump1499:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= o.d1;
    _27 *= _25;
    _27 *= _26;
    _27 *= sizeof(bool);
    _21.data = jpl_alloc(_27);
    int64_t _28 = 0; // B
    int64_t _29 = 0; // A
    int64_t _30 = 0; // z
    _jump1500:; // Begin body of loop
    bool _31 = true;
    int64_t _32;
    if (!_31)
    goto _jump1501;
    _32 = c.d0;
    goto _jump1502;
    _jump1501:;
    _32 = k;
    _jump1502:;
    bool _33 = _32 >= _30;
    int64_t _34 = 0;
    _34 *= _21.d0;
    _34 += _30;
    _34 *= _21.d1;
    _34 += _29;
    _34 *= _21.d2;
    _34 += _28;
    _21.data[_34] = _33;
    _28++;
    if (_28 < _26)
    goto _jump1500;
    _28 = 0;
    _29++;
    if (_29 < _25)
    goto _jump1500;
    _29 = 0;
    _30++;
    if (_30 < o.d1)
    goto _jump1500;
    // End body of loop
    _3 = _21;
    _jump1494:;
    int64_t _35 = 337;
    if (c.d0 >= 0)
    goto _jump1503;
    fail_assertion("negative array index");
    _jump1503:;
    if (c.d0 < _3.d0)
    goto _jump1504;
    fail_assertion("index too large");
    _jump1504:;
    if (_35 >= 0)
    goto _jump1505;
    fail_assertion("negative array index");
    _jump1505:;
    if (_35 < _3.d1)
    goto _jump1506;
    fail_assertion("index too large");
    _jump1506:;
    if (c.d0 >= 0)
    goto _jump1507;
    fail_assertion("negative array index");
    _jump1507:;
    if (c.d0 < _3.d2)
    goto _jump1508;
    fail_assertion("index too large");
    _jump1508:;
    int64_t _36 = 0;
    _36 *= _3.d0;
    _36 += c.d0;
    _36 *= _3.d1;
    _36 += _35;
    _36 *= _3.d2;
    _36 += c.d0;
    bool _37 = _3.data[_36];
    bool _1 = _37;
    if (0 != _37)
    goto _jump1509;
    bool _38 = false;
    _1 = _38;
    _jump1509:;
    bool _0 = _1;
    if (0 != _1)
    goto _jump1510;
    int64_t _39 = -i.d0;
    int64_t _40 = 848;
    bool _41 = _39 == _40;
    _0 = _41;
    _jump1510:;
    return _0;
    bool _42 = n(o);
    if (0 != _42)
    goto _jump1511;
    fail_assertion("A");
    _jump1511:;
    bool _43 = true;
    double _44;
    if (!_43)
    goto _jump1512;
    bool _45 = true;
    _a3_double _46;
    if (!_45)
    goto _jump1513;
    _46 = o;
    goto _jump1514;
    _jump1513:;
    _46 = o;
    _jump1514:;
    int64_t _47 = 90;
    if (o.d2 >= 0)
    goto _jump1515;
    fail_assertion("negative array index");
    _jump1515:;
    if (o.d2 < e.d0)
    goto _jump1516;
    fail_assertion("index too large");
    _jump1516:;
    if (_47 >= 0)
    goto _jump1517;
    fail_assertion("negative array index");
    _jump1517:;
    if (_47 < e.d1)
    goto _jump1518;
    fail_assertion("index too large");
    _jump1518:;
    if (k >= 0)
    goto _jump1519;
    fail_assertion("negative array index");
    _jump1519:;
    if (k < e.d2)
    goto _jump1520;
    fail_assertion("index too large");
    _jump1520:;
    int64_t _48 = 0;
    _48 *= e.d0;
    _48 += o.d2;
    _48 *= e.d1;
    _48 += _47;
    _48 *= e.d2;
    _48 += k;
    int64_t _49 = e.data[_48];
    if (c.d0 >= 0)
    goto _jump1521;
    fail_assertion("negative array index");
    _jump1521:;
    if (c.d0 < _46.d0)
    goto _jump1522;
    fail_assertion("index too large");
    _jump1522:;
    if (_49 >= 0)
    goto _jump1523;
    fail_assertion("negative array index");
    _jump1523:;
    if (_49 < _46.d1)
    goto _jump1524;
    fail_assertion("index too large");
    _jump1524:;
    if (o.d2 >= 0)
    goto _jump1525;
    fail_assertion("negative array index");
    _jump1525:;
    if (o.d2 < _46.d2)
    goto _jump1526;
    fail_assertion("index too large");
    _jump1526:;
    int64_t _50 = 0;
    _50 *= _46.d0;
    _50 += c.d0;
    _50 *= _46.d1;
    _50 += _49;
    _50 *= _46.d2;
    _50 += o.d2;
    double _51 = _46.data[_50];
    double _52 = -_51;
    double _53;
    // Computing bound for A
    int64_t _54 = -g;
    if (_54 > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    _53 = 0;
    int64_t _55 = 0; // A
    _jump1528:; // Begin body of loop
    double _56 = 24.0;
    _53 += _56;
    _55++;
    if (_55 < _54)
    goto _jump1528;
    // End body of loop
    double _57;
    // Computing bound for A
    if (j > 0) 
    goto _jump1529;
    fail_assertion("non-positive loop bound");
    _jump1529:;
    // Computing bound for B
    int64_t _58 = 136;
    if (_58 > 0) 
    goto _jump1530;
    fail_assertion("non-positive loop bound");
    _jump1530:;
    _57 = 0;
    int64_t _59 = 0; // B
    int64_t _60 = 0; // A
    _jump1531:; // Begin body of loop
    if (o.d2 >= 0)
    goto _jump1532;
    fail_assertion("negative array index");
    _jump1532:;
    if (o.d2 < c.d0)
    goto _jump1533;
    fail_assertion("index too large");
    _jump1533:;
    int64_t _61 = 0;
    _61 *= c.d0;
    _61 += o.d2;
    double _62 = c.data[_61];
    _57 += _62;
    _59++;
    if (_59 < _58)
    goto _jump1531;
    _59 = 0;
    _60++;
    if (_60 < j)
    goto _jump1531;
    // End body of loop
    double _63 = _53 - _57;
    _a2_double _64;
    // Computing bound for A
    _64.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    // Computing bound for B
    _64.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1535;
    fail_assertion("non-positive loop bound");
    _jump1535:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= c.d0;
    _65 *= i.d0;
    _65 *= sizeof(double);
    _64.data = jpl_alloc(_65);
    int64_t _66 = 0; // B
    int64_t _67 = 0; // A
    _jump1536:; // Begin body of loop
    double _68 = 76.0;
    double _69 = -_68;
    int64_t _70 = 0;
    _70 *= _64.d0;
    _70 += _67;
    _70 *= _64.d1;
    _70 += _66;
    _64.data[_70] = _69;
    _66++;
    if (_66 < i.d0)
    goto _jump1536;
    _66 = 0;
    _67++;
    if (_67 < c.d0)
    goto _jump1536;
    // End body of loop
    if (h >= 0)
    goto _jump1537;
    fail_assertion("negative array index");
    _jump1537:;
    if (h < _64.d0)
    goto _jump1538;
    fail_assertion("index too large");
    _jump1538:;
    if (g >= 0)
    goto _jump1539;
    fail_assertion("negative array index");
    _jump1539:;
    if (g < _64.d1)
    goto _jump1540;
    fail_assertion("index too large");
    _jump1540:;
    int64_t _71 = 0;
    _71 *= _64.d0;
    _71 += h;
    _71 *= _64.d1;
    _71 += g;
    double _72 = _64.data[_71];
    int64_t _73 = 194;
    if (f >= 0)
    goto _jump1541;
    fail_assertion("negative array index");
    _jump1541:;
    if (f < o.d0)
    goto _jump1542;
    fail_assertion("index too large");
    _jump1542:;
    if (_73 >= 0)
    goto _jump1543;
    fail_assertion("negative array index");
    _jump1543:;
    if (_73 < o.d1)
    goto _jump1544;
    fail_assertion("index too large");
    _jump1544:;
    if (k >= 0)
    goto _jump1545;
    fail_assertion("negative array index");
    _jump1545:;
    if (k < o.d2)
    goto _jump1546;
    fail_assertion("index too large");
    _jump1546:;
    int64_t _74 = 0;
    _74 *= o.d0;
    _74 += f;
    _74 *= o.d1;
    _74 += _73;
    _74 *= o.d2;
    _74 += k;
    double _75 = o.data[_74];
    rgba _76 = { _52, _63, _72, _75 };
    double _77 = _76.b;
    _44 = _77;
    goto _jump1547;
    _jump1512:;
    bool _79 = o.d0 <= i.d0;
    bool _80 = false;
    bool _81 = !_80;
    bool _82 = _79 == _81;
    bool _78 = _82;
    if (0 != _82)
    goto _jump1548;
    bool _83 = n(o);
    _78 = _83;
    _jump1548:;
    double _84;
    if (!_78)
    goto _jump1549;
    bool _85 = false;
    double _86;
    if (!_85)
    goto _jump1550;
    double _87 = 77.0;
    double _88 = 0.0;
    double _89 = _87 / _88;
    _86 = _89;
    goto _jump1551;
    _jump1550:;
    double _90 = 14.0;
    _86 = _90;
    _jump1551:;
    double _91;
    // Computing bound for A
    if (o.d1 > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing bound for B
    if (f > 0) 
    goto _jump1553;
    fail_assertion("non-positive loop bound");
    _jump1553:;
    // Computing bound for C
    if (g > 0) 
    goto _jump1554;
    fail_assertion("non-positive loop bound");
    _jump1554:;
    _91 = 0;
    int64_t _92 = 0; // C
    int64_t _93 = 0; // B
    int64_t _94 = 0; // A
    _jump1555:; // Begin body of loop
    double _95 = 85.0;
    _91 += _95;
    _92++;
    if (_92 < g)
    goto _jump1555;
    _92 = 0;
    _93++;
    if (_93 < f)
    goto _jump1555;
    _93 = 0;
    _94++;
    if (_94 < o.d1)
    goto _jump1555;
    // End body of loop
    double _96 = -_91;
    double _97 = fmod(_86, _96);
    _84 = _97;
    goto _jump1556;
    _jump1549:;
    double _98 = 66.0;
    _84 = _98;
    _jump1556:;
    double _99 = -_84;
    _44 = _99;
    _jump1547:;
    bool _100 = false;
    double _101;
    if (!_100)
    goto _jump1557;
    double _102 = 58.0;
    _101 = _102;
    goto _jump1558;
    _jump1557:;
    double _103 = 96.0;
    _101 = _103;
    _jump1558:;
    double _104;
    // Computing bound for A
    if (o.d1 > 0) 
    goto _jump1559;
    fail_assertion("non-positive loop bound");
    _jump1559:;
    // Computing bound for B
    if (g > 0) 
    goto _jump1560;
    fail_assertion("non-positive loop bound");
    _jump1560:;
    // Computing bound for C
    if (o.d0 > 0) 
    goto _jump1561;
    fail_assertion("non-positive loop bound");
    _jump1561:;
    _104 = 0;
    int64_t _105 = 0; // C
    int64_t _106 = 0; // B
    int64_t _107 = 0; // A
    _jump1562:; // Begin body of loop
    double _108 = 59.0;
    _104 += _108;
    _105++;
    if (_105 < o.d0)
    goto _jump1562;
    _105 = 0;
    _106++;
    if (_106 < g)
    goto _jump1562;
    _106 = 0;
    _107++;
    if (_107 < o.d1)
    goto _jump1562;
    // End body of loop
    int64_t _109 = 180;
    if (_109 >= 0)
    goto _jump1563;
    fail_assertion("negative array index");
    _jump1563:;
    if (_109 < c.d0)
    goto _jump1564;
    fail_assertion("index too large");
    _jump1564:;
    int64_t _110 = 0;
    _110 *= c.d0;
    _110 += _109;
    double _111 = c.data[_110];
    double _112 = _104 - _111;
    bool _113 = _101 <= _112;
    _a2_double _114;
    if (!_113)
    goto _jump1565;
    _a2_double _115;
    // Computing bound for A
    _115.d0 = h;
    if (h > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    // Computing bound for B
    int64_t _116 = 870;
    int64_t _117 = -_116;
    _115.d1 = _117;
    if (_117 > 0) 
    goto _jump1567;
    fail_assertion("non-positive loop bound");
    _jump1567:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= h;
    _118 *= _117;
    _118 *= sizeof(double);
    _115.data = jpl_alloc(_118);
    int64_t _119 = 0; // B
    int64_t _120 = 0; // A
    _jump1568:; // Begin body of loop
    int64_t _121 = i.d0 - i.d0;
    if (_121 >= 0)
    goto _jump1569;
    fail_assertion("negative array index");
    _jump1569:;
    if (_121 < o.d0)
    goto _jump1570;
    fail_assertion("index too large");
    _jump1570:;
    if (k >= 0)
    goto _jump1571;
    fail_assertion("negative array index");
    _jump1571:;
    if (k < o.d1)
    goto _jump1572;
    fail_assertion("index too large");
    _jump1572:;
    if (_120 >= 0)
    goto _jump1573;
    fail_assertion("negative array index");
    _jump1573:;
    if (_120 < o.d2)
    goto _jump1574;
    fail_assertion("index too large");
    _jump1574:;
    int64_t _122 = 0;
    _122 *= o.d0;
    _122 += _121;
    _122 *= o.d1;
    _122 += k;
    _122 *= o.d2;
    _122 += _120;
    double _123 = o.data[_122];
    int64_t _124 = 0;
    _124 *= _115.d0;
    _124 += _120;
    _124 *= _115.d1;
    _124 += _119;
    _115.data[_124] = _123;
    _119++;
    if (_119 < _117)
    goto _jump1568;
    _119 = 0;
    _120++;
    if (_120 < h)
    goto _jump1568;
    // End body of loop
    _114 = _115;
    goto _jump1575;
    _jump1565:;
    _a2_double _125;
    // Computing bound for A
    _125.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    // Computing bound for B
    _125.d1 = k;
    if (k > 0) 
    goto _jump1577;
    fail_assertion("non-positive loop bound");
    _jump1577:;
    // Computing total size of heap memory to allocate
    int64_t _126 = 1;
    _126 *= i.d0;
    _126 *= k;
    _126 *= sizeof(double);
    _125.data = jpl_alloc(_126);
    int64_t _127 = 0; // B
    int64_t _128 = 0; // A
    _jump1578:; // Begin body of loop
    double _129 = 10.0;
    int64_t _130 = 0;
    _130 *= _125.d0;
    _130 += _128;
    _130 *= _125.d1;
    _130 += _127;
    _125.data[_130] = _129;
    _127++;
    if (_127 < k)
    goto _jump1578;
    _127 = 0;
    _128++;
    if (_128 < i.d0)
    goto _jump1578;
    // End body of loop
    _114 = _125;
    _jump1575:;
    if (o.d2 >= 0)
    goto _jump1579;
    fail_assertion("negative array index");
    _jump1579:;
    if (o.d2 < _114.d0)
    goto _jump1580;
    fail_assertion("index too large");
    _jump1580:;
    if (o.d2 >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (o.d2 < _114.d1)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    int64_t _131 = 0;
    _131 *= _114.d0;
    _131 += o.d2;
    _131 *= _114.d1;
    _131 += o.d2;
    double _132 = _114.data[_131];
    double _133 = 33.0;
    double _134 = 54.0;
    bool _135 = n(o);
    double _136;
    if (!_135)
    goto _jump1583;
    double _137 = 94.0;
    _136 = _137;
    goto _jump1584;
    _jump1583:;
    double _138 = 59.0;
    _136 = _138;
    _jump1584:;
    double _139 = _134 * _136;
    double _140 = _133 + _139;
    _a2_double _141;
    // Computing bound for A
    _141.d0 = h;
    if (h > 0) 
    goto _jump1585;
    fail_assertion("non-positive loop bound");
    _jump1585:;
    // Computing bound for B
    _141.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump1586;
    fail_assertion("non-positive loop bound");
    _jump1586:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= h;
    _142 *= c.d0;
    _142 *= sizeof(double);
    _141.data = jpl_alloc(_142);
    int64_t _143 = 0; // B
    int64_t _144 = 0; // A
    _jump1587:; // Begin body of loop
    double _145 = 33.0;
    int64_t _146 = 0;
    _146 *= _141.d0;
    _146 += _144;
    _146 *= _141.d1;
    _146 += _143;
    _141.data[_146] = _145;
    _143++;
    if (_143 < c.d0)
    goto _jump1587;
    _143 = 0;
    _144++;
    if (_144 < h)
    goto _jump1587;
    // End body of loop
    if (o.d2 >= 0)
    goto _jump1588;
    fail_assertion("negative array index");
    _jump1588:;
    if (o.d2 < _141.d0)
    goto _jump1589;
    fail_assertion("index too large");
    _jump1589:;
    if (i.d0 >= 0)
    goto _jump1590;
    fail_assertion("negative array index");
    _jump1590:;
    if (i.d0 < _141.d1)
    goto _jump1591;
    fail_assertion("index too large");
    _jump1591:;
    int64_t _147 = 0;
    _147 *= _141.d0;
    _147 += o.d2;
    _147 *= _141.d1;
    _147 += i.d0;
    double _148 = _141.data[_147];
    double _149 = _140 + _148;
    double _150 = _132 - _149;
    bool _151 = _44 == _150;
    return _151;
}

rgba o(_a3_double p, bool q, int64_t r) {
    _a3_double _0;
    // Computing bound for s
    _0.d0 = h;
    if (h > 0) 
    goto _jump1592;
    fail_assertion("non-positive loop bound");
    _jump1592:;
    // Computing bound for t
    int64_t _1;
    // Computing bound for s
    if (k > 0) 
    goto _jump1593;
    fail_assertion("non-positive loop bound");
    _jump1593:;
    _1 = 0;
    int64_t _2 = 0; // s
    _jump1594:; // Begin body of loop
    int64_t _3 = 946;
    int64_t _4 = _3 / k;
    _1 += _4;
    _2++;
    if (_2 < k)
    goto _jump1594;
    // End body of loop
    int64_t _5 = -_1;
    _0.d1 = _5;
    if (_5 > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing bound for u
    _0.d2 = r;
    if (r > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= h;
    _6 *= _5;
    _6 *= r;
    _6 *= sizeof(double);
    _0.data = jpl_alloc(_6);
    int64_t _7 = 0; // u
    int64_t _8 = 0; // t
    int64_t _9 = 0; // s
    _jump1597:; // Begin body of loop
    _a2__a2_int64_t _10;
    if (!q)
    goto _jump1598;
    _a2__a2_int64_t _11;
    // Computing bound for v
    int64_t _12 = k - j;
    _11.d0 = _12;
    if (_12 > 0) 
    goto _jump1599;
    fail_assertion("non-positive loop bound");
    _jump1599:;
    // Computing bound for w
    _11.d1 = j;
    if (j > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _12;
    _13 *= j;
    _13 *= sizeof(_a2_int64_t);
    _11.data = jpl_alloc(_13);
    int64_t _14 = 0; // w
    int64_t _15 = 0; // v
    _jump1601:; // Begin body of loop
    int64_t _16 = 0;
    _16 *= _11.d0;
    _16 += _15;
    _16 *= _11.d1;
    _16 += _14;
    _11.data[_16] = i;
    _14++;
    if (_14 < j)
    goto _jump1601;
    _14 = 0;
    _15++;
    if (_15 < _12)
    goto _jump1601;
    // End body of loop
    _10 = _11;
    goto _jump1602;
    _jump1598:;
    _a2__a2_int64_t _17;
    // Computing bound for v
    int64_t _18;
    // Computing bound for v
    if (_8 > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    // Computing bound for w
    if (f > 0) 
    goto _jump1604;
    fail_assertion("non-positive loop bound");
    _jump1604:;
    _18 = 0;
    int64_t _19 = 0; // w
    int64_t _20 = 0; // v
    _jump1605:; // Begin body of loop
    _18 += k;
    _19++;
    if (_19 < f)
    goto _jump1605;
    _19 = 0;
    _20++;
    if (_20 < _8)
    goto _jump1605;
    // End body of loop
    _17.d0 = _18;
    if (_18 > 0) 
    goto _jump1606;
    fail_assertion("non-positive loop bound");
    _jump1606:;
    // Computing bound for w
    bool _21 = false;
    int64_t _22;
    if (!_21)
    goto _jump1607;
    _22 = _7;
    goto _jump1608;
    _jump1607:;
    int64_t _23 = 365;
    _22 = _23;
    _jump1608:;
    _17.d1 = _22;
    if (_22 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= _18;
    _24 *= _22;
    _24 *= sizeof(_a2_int64_t);
    _17.data = jpl_alloc(_24);
    int64_t _25 = 0; // w
    int64_t _26 = 0; // v
    _jump1610:; // Begin body of loop
    int64_t _27 = 0;
    _27 *= _17.d0;
    _27 += _26;
    _27 *= _17.d1;
    _27 += _25;
    _17.data[_27] = i;
    _25++;
    if (_25 < _22)
    goto _jump1610;
    _25 = 0;
    _26++;
    if (_26 < _18)
    goto _jump1610;
    // End body of loop
    _10 = _17;
    _jump1602:;
    int64_t _28 = _7 - _8;
    _a3_bool _29;
    // Computing bound for v
    _29.d0 = _9;
    if (_9 > 0) 
    goto _jump1611;
    fail_assertion("non-positive loop bound");
    _jump1611:;
    // Computing bound for w
    _29.d1 = h;
    if (h > 0) 
    goto _jump1612;
    fail_assertion("non-positive loop bound");
    _jump1612:;
    // Computing bound for x
    _29.d2 = _9;
    if (_9 > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _9;
    _30 *= h;
    _30 *= _9;
    _30 *= sizeof(bool);
    _29.data = jpl_alloc(_30);
    int64_t _31 = 0; // x
    int64_t _32 = 0; // w
    int64_t _33 = 0; // v
    _jump1614:; // Begin body of loop
    int64_t _34 = -_31;
    bool _35 = _9 == _34;
    int64_t _36 = 0;
    _36 *= _29.d0;
    _36 += _33;
    _36 *= _29.d1;
    _36 += _32;
    _36 *= _29.d2;
    _36 += _31;
    _29.data[_36] = _35;
    _31++;
    if (_31 < _9)
    goto _jump1614;
    _31 = 0;
    _32++;
    if (_32 < h)
    goto _jump1614;
    _32 = 0;
    _33++;
    if (_33 < _9)
    goto _jump1614;
    // End body of loop
    rgba _37 = m(_10, _28, _29);
    double _38 = _37.r;
    int64_t _39 = 0;
    _39 *= _0.d0;
    _39 += _9;
    _39 *= _0.d1;
    _39 += _8;
    _39 *= _0.d2;
    _39 += _7;
    _0.data[_39] = _38;
    _7++;
    if (_7 < r)
    goto _jump1597;
    _7 = 0;
    _8++;
    if (_8 < _5)
    goto _jump1597;
    _8 = 0;
    _9++;
    if (_9 < h)
    goto _jump1597;
    // End body of loop
    bool _40 = true;
    _a2_bool _41;
    // Computing bound for s
    _41.d0 = g;
    if (g > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    // Computing bound for t
    _41.d1 = k;
    if (k > 0) 
    goto _jump1616;
    fail_assertion("non-positive loop bound");
    _jump1616:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= g;
    _42 *= k;
    _42 *= sizeof(bool);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // t
    int64_t _44 = 0; // s
    _jump1617:; // Begin body of loop
    int64_t _45 = -_43;
    bool _46 = g < _45;
    int64_t _47 = 0;
    _47 *= _41.d0;
    _47 += _44;
    _47 *= _41.d1;
    _47 += _43;
    _41.data[_47] = _46;
    _43++;
    if (_43 < k)
    goto _jump1617;
    _43 = 0;
    _44++;
    if (_44 < g)
    goto _jump1617;
    // End body of loop
    bool _48 = q;
    if (0 == q)
    goto _jump1618;
    _48 = q;
    _jump1618:;
    int64_t _49;
    if (!_48)
    goto _jump1619;
    _49 = g;
    goto _jump1620;
    _jump1619:;
    _49 = f;
    _jump1620:;
    if (_49 >= 0)
    goto _jump1621;
    fail_assertion("negative array index");
    _jump1621:;
    if (_49 < _41.d0)
    goto _jump1622;
    fail_assertion("index too large");
    _jump1622:;
    if (k >= 0)
    goto _jump1623;
    fail_assertion("negative array index");
    _jump1623:;
    if (k < _41.d1)
    goto _jump1624;
    fail_assertion("index too large");
    _jump1624:;
    int64_t _50 = 0;
    _50 *= _41.d0;
    _50 += _49;
    _50 *= _41.d1;
    _50 += k;
    bool _51 = _41.data[_50];
    int64_t _52;
    if (!_51)
    goto _jump1625;
    _a2_bool _53;
    if (!q)
    goto _jump1626;
    _a2_bool _54;
    // Computing bound for s
    _54.d0 = h;
    if (h > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing bound for t
    _54.d1 = k;
    if (k > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= h;
    _55 *= k;
    _55 *= sizeof(bool);
    _54.data = jpl_alloc(_55);
    int64_t _56 = 0; // t
    int64_t _57 = 0; // s
    _jump1629:; // Begin body of loop
    int64_t _58 = 0;
    _58 *= _54.d0;
    _58 += _57;
    _58 *= _54.d1;
    _58 += _56;
    _54.data[_58] = q;
    _56++;
    if (_56 < k)
    goto _jump1629;
    _56 = 0;
    _57++;
    if (_57 < h)
    goto _jump1629;
    // End body of loop
    _53 = _54;
    goto _jump1630;
    _jump1626:;
    _a2_bool _59;
    // Computing bound for s
    _59.d0 = j;
    if (j > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing bound for t
    _59.d1 = g;
    if (g > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= j;
    _60 *= g;
    _60 *= sizeof(bool);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // t
    int64_t _62 = 0; // s
    _jump1633:; // Begin body of loop
    bool _63 = true;
    int64_t _64 = 0;
    _64 *= _59.d0;
    _64 += _62;
    _64 *= _59.d1;
    _64 += _61;
    _59.data[_64] = _63;
    _61++;
    if (_61 < g)
    goto _jump1633;
    _61 = 0;
    _62++;
    if (_62 < j)
    goto _jump1633;
    // End body of loop
    _53 = _59;
    _jump1630:;
    int64_t _65 = 175;
    int64_t _66 = _65 / h;
    if (g >= 0)
    goto _jump1634;
    fail_assertion("negative array index");
    _jump1634:;
    if (g < _53.d0)
    goto _jump1635;
    fail_assertion("index too large");
    _jump1635:;
    if (_66 >= 0)
    goto _jump1636;
    fail_assertion("negative array index");
    _jump1636:;
    if (_66 < _53.d1)
    goto _jump1637;
    fail_assertion("index too large");
    _jump1637:;
    int64_t _67 = 0;
    _67 *= _53.d0;
    _67 += g;
    _67 *= _53.d1;
    _67 += _66;
    bool _68 = _53.data[_67];
    int64_t _69;
    if (!_68)
    goto _jump1638;
    int64_t _70 = -f;
    _69 = _70;
    goto _jump1639;
    _jump1638:;
    int64_t _71;
    // Computing bound for s
    int64_t _72 = 878;
    int64_t _73 = -_72;
    if (_73 > 0) 
    goto _jump1640;
    fail_assertion("non-positive loop bound");
    _jump1640:;
    // Computing bound for t
    int64_t _74 = -g;
    if (_74 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    _71 = 0;
    int64_t _75 = 0; // t
    int64_t _76 = 0; // s
    _jump1642:; // Begin body of loop
    _71 += k;
    _75++;
    if (_75 < _74)
    goto _jump1642;
    _75 = 0;
    _76++;
    if (_76 < _73)
    goto _jump1642;
    // End body of loop
    _69 = _71;
    _jump1639:;
    _52 = _69;
    goto _jump1643;
    _jump1625:;
    int64_t _77;
    // Computing bound for s
    if (f > 0) 
    goto _jump1644;
    fail_assertion("non-positive loop bound");
    _jump1644:;
    // Computing bound for t
    int64_t _78 = g % g;
    int64_t _79 = -_78;
    int64_t _80 = k - _79;
    if (_80 > 0) 
    goto _jump1645;
    fail_assertion("non-positive loop bound");
    _jump1645:;
    _77 = 0;
    int64_t _81 = 0; // t
    int64_t _82 = 0; // s
    _jump1646:; // Begin body of loop
    int64_t _83 = 242;
    int64_t _84 = _83 / _82;
    int64_t _85 = -_84;
    int64_t _86 = -_85;
    _77 += _86;
    _81++;
    if (_81 < _80)
    goto _jump1646;
    _81 = 0;
    _82++;
    if (_82 < f)
    goto _jump1646;
    // End body of loop
    _52 = _77;
    _jump1643:;
    int64_t _87 = -_52;
    rgba _88 = o(_0, _40, _87);
    return _88;
    double _90;
    // Computing bound for s
    int64_t _91 = 360;
    if (_91 > 0) 
    goto _jump1647;
    fail_assertion("non-positive loop bound");
    _jump1647:;
    _90 = 0;
    int64_t _92 = 0; // s
    _jump1648:; // Begin body of loop
    double _93 = 82.0;
    _90 += _93;
    _92++;
    if (_92 < _91)
    goto _jump1648;
    // End body of loop
    if (r >= 0)
    goto _jump1649;
    fail_assertion("negative array index");
    _jump1649:;
    if (r < l.d0)
    goto _jump1650;
    fail_assertion("index too large");
    _jump1650:;
    int64_t _94 = 0;
    _94 *= l.d0;
    _94 += r;
    double _95 = l.data[_94];
    bool _96 = _90 < _95;
    _a3__a3_double _97;
    if (!_96)
    goto _jump1651;
    _a3__a3_double _98;
    // Computing bound for s
    int64_t _99 = -k;
    _98.d0 = _99;
    if (_99 > 0) 
    goto _jump1652;
    fail_assertion("non-positive loop bound");
    _jump1652:;
    // Computing bound for t
    _98.d1 = h;
    if (h > 0) 
    goto _jump1653;
    fail_assertion("non-positive loop bound");
    _jump1653:;
    // Computing bound for u
    int64_t _100;
    // Computing bound for s
    if (r > 0) 
    goto _jump1654;
    fail_assertion("non-positive loop bound");
    _jump1654:;
    _100 = 0;
    int64_t _101 = 0; // s
    _jump1655:; // Begin body of loop
    _100 += h;
    _101++;
    if (_101 < r)
    goto _jump1655;
    // End body of loop
    _98.d2 = _100;
    if (_100 > 0) 
    goto _jump1656;
    fail_assertion("non-positive loop bound");
    _jump1656:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= _99;
    _102 *= h;
    _102 *= _100;
    _102 *= sizeof(_a3_double);
    _98.data = jpl_alloc(_102);
    int64_t _103 = 0; // u
    int64_t _104 = 0; // t
    int64_t _105 = 0; // s
    _jump1657:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _98.d0;
    _106 += _105;
    _106 *= _98.d1;
    _106 += _104;
    _106 *= _98.d2;
    _106 += _103;
    _98.data[_106] = p;
    _103++;
    if (_103 < _100)
    goto _jump1657;
    _103 = 0;
    _104++;
    if (_104 < h)
    goto _jump1657;
    _104 = 0;
    _105++;
    if (_105 < _99)
    goto _jump1657;
    // End body of loop
    _97 = _98;
    goto _jump1658;
    _jump1651:;
    _a3__a3_double _107;
    // Computing bound for s
    int64_t _108;
    if (!q)
    goto _jump1659;
    int64_t _109 = 667;
    _108 = _109;
    goto _jump1660;
    _jump1659:;
    _108 = j;
    _jump1660:;
    _107.d0 = _108;
    if (_108 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing bound for t
    int64_t _110 = f * k;
    _107.d1 = _110;
    if (_110 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    // Computing bound for u
    int64_t _111 = 152;
    _107.d2 = _111;
    if (_111 > 0) 
    goto _jump1663;
    fail_assertion("non-positive loop bound");
    _jump1663:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _108;
    _112 *= _110;
    _112 *= _111;
    _112 *= sizeof(_a3_double);
    _107.data = jpl_alloc(_112);
    int64_t _113 = 0; // u
    int64_t _114 = 0; // t
    int64_t _115 = 0; // s
    _jump1664:; // Begin body of loop
    int64_t _116 = 0;
    _116 *= _107.d0;
    _116 += _115;
    _116 *= _107.d1;
    _116 += _114;
    _116 *= _107.d2;
    _116 += _113;
    _107.data[_116] = p;
    _113++;
    if (_113 < _111)
    goto _jump1664;
    _113 = 0;
    _114++;
    if (_114 < _110)
    goto _jump1664;
    _114 = 0;
    _115++;
    if (_115 < _108)
    goto _jump1664;
    // End body of loop
    _97 = _107;
    _jump1658:;
    int64_t _117 = 598;
    if (_117 >= 0)
    goto _jump1665;
    fail_assertion("negative array index");
    _jump1665:;
    if (_117 < _97.d0)
    goto _jump1666;
    fail_assertion("index too large");
    _jump1666:;
    if (h >= 0)
    goto _jump1667;
    fail_assertion("negative array index");
    _jump1667:;
    if (h < _97.d1)
    goto _jump1668;
    fail_assertion("index too large");
    _jump1668:;
    if (r >= 0)
    goto _jump1669;
    fail_assertion("negative array index");
    _jump1669:;
    if (r < _97.d2)
    goto _jump1670;
    fail_assertion("index too large");
    _jump1670:;
    int64_t _118 = 0;
    _118 *= _97.d0;
    _118 += _117;
    _118 *= _97.d1;
    _118 += h;
    _118 *= _97.d2;
    _118 += r;
    _a3_double _119 = _97.data[_118];
    bool _120 = n(_119);
    bool _89 = _120;
    if (0 != _120)
    goto _jump1671;
    _89 = q;
    _jump1671:;
    bool _121;
    if (!_89)
    goto _jump1672;
    _121 = q;
    goto _jump1673;
    _jump1672:;
    bool _122 = k == h;
    _121 = _122;
    _jump1673:;
    if (0 != _121)
    goto _jump1674;
    fail_assertion("s");
    _jump1674:;
    int64_t _123 = 575;
    double _125;
    // Computing bound for t
    if (h > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    // Computing bound for u
    if (_123 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing bound for v
    if (j > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    _125 = 0;
    int64_t _126 = 0; // v
    int64_t _127 = 0; // u
    int64_t _128 = 0; // t
    _jump1678:; // Begin body of loop
    double _129 = 99.0;
    if (k >= 0)
    goto _jump1679;
    fail_assertion("negative array index");
    _jump1679:;
    if (k < c.d0)
    goto _jump1680;
    fail_assertion("index too large");
    _jump1680:;
    int64_t _130 = 0;
    _130 *= c.d0;
    _130 += k;
    double _131 = c.data[_130];
    double _132 = -_131;
    double _133 = _129 * _132;
    _125 += _133;
    _126++;
    if (_126 < j)
    goto _jump1678;
    _126 = 0;
    _127++;
    if (_127 < _123)
    goto _jump1678;
    _127 = 0;
    _128++;
    if (_128 < h)
    goto _jump1678;
    // End body of loop
    double _134 = -_125;
    double _135 = 55.0;
    bool _136 = false;
    double _137;
    if (!_136)
    goto _jump1681;
    double _138 = 13.0;
    _137 = _138;
    goto _jump1682;
    _jump1681:;
    double _139 = 32.0;
    _137 = _139;
    _jump1682:;
    int64_t _140 = 6;
    if (k >= 0)
    goto _jump1683;
    fail_assertion("negative array index");
    _jump1683:;
    if (k < p.d0)
    goto _jump1684;
    fail_assertion("index too large");
    _jump1684:;
    if (_140 >= 0)
    goto _jump1685;
    fail_assertion("negative array index");
    _jump1685:;
    if (_140 < p.d1)
    goto _jump1686;
    fail_assertion("index too large");
    _jump1686:;
    if (_123 >= 0)
    goto _jump1687;
    fail_assertion("negative array index");
    _jump1687:;
    if (_123 < p.d2)
    goto _jump1688;
    fail_assertion("index too large");
    _jump1688:;
    int64_t _141 = 0;
    _141 *= p.d0;
    _141 += k;
    _141 *= p.d1;
    _141 += _140;
    _141 *= p.d2;
    _141 += _123;
    double _142 = p.data[_141];
    double _143 = _137 / _142;
    double _144;
    // Computing bound for t
    if (k > 0) 
    goto _jump1689;
    fail_assertion("non-positive loop bound");
    _jump1689:;
    // Computing bound for u
    int64_t _145 = 805;
    if (_145 > 0) 
    goto _jump1690;
    fail_assertion("non-positive loop bound");
    _jump1690:;
    // Computing bound for v
    if (j > 0) 
    goto _jump1691;
    fail_assertion("non-positive loop bound");
    _jump1691:;
    _144 = 0;
    int64_t _146 = 0; // v
    int64_t _147 = 0; // u
    int64_t _148 = 0; // t
    _jump1692:; // Begin body of loop
    double _149 = 64.0;
    _144 += _149;
    _146++;
    if (_146 < j)
    goto _jump1692;
    _146 = 0;
    _147++;
    if (_147 < _145)
    goto _jump1692;
    _147 = 0;
    _148++;
    if (_148 < k)
    goto _jump1692;
    // End body of loop
    double _150 = _143 - _144;
    double _151 = -_150;
    double _152 = _135 + _151;
    bool _153 = _134 < _152;
    bool _124 = _153;
    if (0 == _153)
    goto _jump1693;
    int64_t _155 = k - r;
    if (r >= 0)
    goto _jump1694;
    fail_assertion("negative array index");
    _jump1694:;
    if (r < e.d0)
    goto _jump1695;
    fail_assertion("index too large");
    _jump1695:;
    if (_155 >= 0)
    goto _jump1696;
    fail_assertion("negative array index");
    _jump1696:;
    if (_155 < e.d1)
    goto _jump1697;
    fail_assertion("index too large");
    _jump1697:;
    if (h >= 0)
    goto _jump1698;
    fail_assertion("negative array index");
    _jump1698:;
    if (h < e.d2)
    goto _jump1699;
    fail_assertion("index too large");
    _jump1699:;
    int64_t _156 = 0;
    _156 *= e.d0;
    _156 += r;
    _156 *= e.d1;
    _156 += _155;
    _156 *= e.d2;
    _156 += h;
    int64_t _157 = e.data[_156];
    bool _158 = _123 == _157;
    bool _154 = _158;
    if (0 == _158)
    goto _jump1700;
    bool _160 = n(p);
    bool _159 = _160;
    if (0 == _160)
    goto _jump1701;
    _159 = q;
    _jump1701:;
    _154 = _159;
    _jump1700:;
    bool _161 = !_154;
    _124 = _161;
    _jump1693:;
    if (0 != _124)
    goto _jump1702;
    fail_assertion("t");
    _jump1702:;
    bool _162 = k <= k;
    double _163 = 46.0;
    double _164 = -_163;
    double _165 = 61.0;
    bool _166 = _164 != _165;
    rgba _167;
    if (!_166)
    goto _jump1703;
    _a2__a3_double _168;
    // Computing bound for v
    _168.d0 = _123;
    if (_123 > 0) 
    goto _jump1704;
    fail_assertion("non-positive loop bound");
    _jump1704:;
    // Computing bound for w
    _168.d1 = g;
    if (g > 0) 
    goto _jump1705;
    fail_assertion("non-positive loop bound");
    _jump1705:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= _123;
    _169 *= g;
    _169 *= sizeof(_a3_double);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // w
    int64_t _171 = 0; // v
    _jump1706:; // Begin body of loop
    _a1__a3_double _172;
    _172.d0 = 2;
    _172.data = jpl_alloc(sizeof(_a3_double) * 2);
    _172.data[0] = p;
    _172.data[1] = p;
    if (_123 >= 0)
    goto _jump1707;
    fail_assertion("negative array index");
    _jump1707:;
    if (_123 < _172.d0)
    goto _jump1708;
    fail_assertion("index too large");
    _jump1708:;
    int64_t _173 = 0;
    _173 *= _172.d0;
    _173 += _123;
    _a3_double _174 = _172.data[_173];
    int64_t _175 = 0;
    _175 *= _168.d0;
    _175 += _171;
    _175 *= _168.d1;
    _175 += _170;
    _168.data[_175] = _174;
    _170++;
    if (_170 < g)
    goto _jump1706;
    _170 = 0;
    _171++;
    if (_171 < _123)
    goto _jump1706;
    // End body of loop
    int64_t _176;
    // Computing bound for v
    int64_t _177;
    // Computing bound for v
    if (f > 0) 
    goto _jump1709;
    fail_assertion("non-positive loop bound");
    _jump1709:;
    // Computing bound for w
    if (f > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    // Computing bound for x
    int64_t _178;
    if (!q)
    goto _jump1711;
    _178 = k;
    goto _jump1712;
    _jump1711:;
    _178 = g;
    _jump1712:;
    if (_178 > 0) 
    goto _jump1713;
    fail_assertion("non-positive loop bound");
    _jump1713:;
    _177 = 0;
    int64_t _179 = 0; // x
    int64_t _180 = 0; // w
    int64_t _181 = 0; // v
    _jump1714:; // Begin body of loop
    _177 += h;
    _179++;
    if (_179 < _178)
    goto _jump1714;
    _179 = 0;
    _180++;
    if (_180 < f)
    goto _jump1714;
    _180 = 0;
    _181++;
    if (_181 < f)
    goto _jump1714;
    // End body of loop
    int64_t _182 = -_177;
    if (_182 > 0) 
    goto _jump1715;
    fail_assertion("non-positive loop bound");
    _jump1715:;
    _176 = 0;
    int64_t _183 = 0; // v
    _jump1716:; // Begin body of loop
    _176 += f;
    _183++;
    if (_183 < _182)
    goto _jump1716;
    // End body of loop
    int64_t _184 = g + g;
    int64_t _185 = -_184;
    if (_176 >= 0)
    goto _jump1717;
    fail_assertion("negative array index");
    _jump1717:;
    if (_176 < _168.d0)
    goto _jump1718;
    fail_assertion("index too large");
    _jump1718:;
    if (_185 >= 0)
    goto _jump1719;
    fail_assertion("negative array index");
    _jump1719:;
    if (_185 < _168.d1)
    goto _jump1720;
    fail_assertion("index too large");
    _jump1720:;
    int64_t _186 = 0;
    _186 *= _168.d0;
    _186 += _176;
    _186 *= _168.d1;
    _186 += _185;
    _a3_double _187 = _168.data[_186];
    bool _188 = k <= k;
    bool _189 = true;
    bool _190;
    if (!_189)
    goto _jump1721;
    bool _191 = false;
    _190 = _191;
    goto _jump1722;
    _jump1721:;
    _190 = _162;
    _jump1722:;
    _a2_int64_t _192;
    if (!_190)
    goto _jump1723;
    _192 = i;
    goto _jump1724;
    _jump1723:;
    _192 = i;
    _jump1724:;
    int64_t _193 = j / j;
    int64_t _194 = _193 / f;
    if (_194 >= 0)
    goto _jump1725;
    fail_assertion("negative array index");
    _jump1725:;
    if (_194 < _192.d0)
    goto _jump1726;
    fail_assertion("index too large");
    _jump1726:;
    if (r >= 0)
    goto _jump1727;
    fail_assertion("negative array index");
    _jump1727:;
    if (r < _192.d1)
    goto _jump1728;
    fail_assertion("index too large");
    _jump1728:;
    int64_t _195 = 0;
    _195 *= _192.d0;
    _195 += _194;
    _195 *= _192.d1;
    _195 += r;
    int64_t _196 = _192.data[_195];
    int64_t _197 = _196 % j;
    int64_t _198 = -_197;
    rgba _199 = o(_187, _188, _198);
    _167 = _199;
    goto _jump1729;
    _jump1703:;
    _a1__a2__a2_int64_t _200;
    // Computing bound for v
    int64_t _201;
    // Computing bound for v
    if (k > 0) 
    goto _jump1730;
    fail_assertion("non-positive loop bound");
    _jump1730:;
    // Computing bound for w
    int64_t _202 = 460;
    if (_202 > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    _201 = 0;
    int64_t _203 = 0; // w
    int64_t _204 = 0; // v
    _jump1732:; // Begin body of loop
    _201 += _123;
    _203++;
    if (_203 < _202)
    goto _jump1732;
    _203 = 0;
    _204++;
    if (_204 < k)
    goto _jump1732;
    // End body of loop
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump1733;
    fail_assertion("non-positive loop bound");
    _jump1733:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _201;
    _205 *= sizeof(_a2__a2_int64_t);
    _200.data = jpl_alloc(_205);
    int64_t _206 = 0; // v
    _jump1734:; // Begin body of loop
    _a2__a2_int64_t _207;
    // Computing bound for w
    int64_t _208;
    // Computing bound for w
    if (j > 0) 
    goto _jump1735;
    fail_assertion("non-positive loop bound");
    _jump1735:;
    // Computing bound for x
    if (h > 0) 
    goto _jump1736;
    fail_assertion("non-positive loop bound");
    _jump1736:;
    // Computing bound for y
    if (h > 0) 
    goto _jump1737;
    fail_assertion("non-positive loop bound");
    _jump1737:;
    _208 = 0;
    int64_t _209 = 0; // y
    int64_t _210 = 0; // x
    int64_t _211 = 0; // w
    _jump1738:; // Begin body of loop
    _208 += r;
    _209++;
    if (_209 < h)
    goto _jump1738;
    _209 = 0;
    _210++;
    if (_210 < h)
    goto _jump1738;
    _210 = 0;
    _211++;
    if (_211 < j)
    goto _jump1738;
    // End body of loop
    _207.d0 = _208;
    if (_208 > 0) 
    goto _jump1739;
    fail_assertion("non-positive loop bound");
    _jump1739:;
    // Computing bound for x
    _a2_int64_t _212;
    // Computing bound for w
    _212.d0 = k;
    if (k > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing bound for x
    _212.d1 = g;
    if (g > 0) 
    goto _jump1741;
    fail_assertion("non-positive loop bound");
    _jump1741:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= k;
    _213 *= g;
    _213 *= sizeof(int64_t);
    _212.data = jpl_alloc(_213);
    int64_t _214 = 0; // x
    int64_t _215 = 0; // w
    _jump1742:; // Begin body of loop
    int64_t _216 = 0;
    _216 *= _212.d0;
    _216 += _215;
    _216 *= _212.d1;
    _216 += _214;
    _212.data[_216] = g;
    _214++;
    if (_214 < g)
    goto _jump1742;
    _214 = 0;
    _215++;
    if (_215 < k)
    goto _jump1742;
    // End body of loop
    if (f >= 0)
    goto _jump1743;
    fail_assertion("negative array index");
    _jump1743:;
    if (f < _212.d0)
    goto _jump1744;
    fail_assertion("index too large");
    _jump1744:;
    if (_206 >= 0)
    goto _jump1745;
    fail_assertion("negative array index");
    _jump1745:;
    if (_206 < _212.d1)
    goto _jump1746;
    fail_assertion("index too large");
    _jump1746:;
    int64_t _217 = 0;
    _217 *= _212.d0;
    _217 += f;
    _217 *= _212.d1;
    _217 += _206;
    int64_t _218 = _212.data[_217];
    _207.d1 = _218;
    if (_218 > 0) 
    goto _jump1747;
    fail_assertion("non-positive loop bound");
    _jump1747:;
    // Computing total size of heap memory to allocate
    int64_t _219 = 1;
    _219 *= _208;
    _219 *= _218;
    _219 *= sizeof(_a2_int64_t);
    _207.data = jpl_alloc(_219);
    int64_t _220 = 0; // x
    int64_t _221 = 0; // w
    _jump1748:; // Begin body of loop
    _a2_int64_t _222;
    // Computing bound for y
    _222.d0 = _221;
    if (_221 > 0) 
    goto _jump1749;
    fail_assertion("non-positive loop bound");
    _jump1749:;
    // Computing bound for z
    int64_t _223 = j + k;
    _222.d1 = _223;
    if (_223 > 0) 
    goto _jump1750;
    fail_assertion("non-positive loop bound");
    _jump1750:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= _221;
    _224 *= _223;
    _224 *= sizeof(int64_t);
    _222.data = jpl_alloc(_224);
    int64_t _225 = 0; // z
    int64_t _226 = 0; // y
    _jump1751:; // Begin body of loop
    int64_t _227 = 0;
    _227 *= _222.d0;
    _227 += _226;
    _227 *= _222.d1;
    _227 += _225;
    _222.data[_227] = _226;
    _225++;
    if (_225 < _223)
    goto _jump1751;
    _225 = 0;
    _226++;
    if (_226 < _221)
    goto _jump1751;
    // End body of loop
    int64_t _228 = 0;
    _228 *= _207.d0;
    _228 += _221;
    _228 *= _207.d1;
    _228 += _220;
    _207.data[_228] = _222;
    _220++;
    if (_220 < _218)
    goto _jump1748;
    _220 = 0;
    _221++;
    if (_221 < _208)
    goto _jump1748;
    // End body of loop
    int64_t _229 = 0;
    _229 *= _200.d0;
    _229 += _206;
    _200.data[_229] = _207;
    _206++;
    if (_206 < _201)
    goto _jump1734;
    // End body of loop
    int64_t _230 = f / j;
    if (_230 >= 0)
    goto _jump1752;
    fail_assertion("negative array index");
    _jump1752:;
    if (_230 < _200.d0)
    goto _jump1753;
    fail_assertion("index too large");
    _jump1753:;
    int64_t _231 = 0;
    _231 *= _200.d0;
    _231 += _230;
    _a2__a2_int64_t _232 = _200.data[_231];
    _a3_bool _233;
    // Computing bound for v
    _233.d0 = r;
    if (r > 0) 
    goto _jump1754;
    fail_assertion("non-positive loop bound");
    _jump1754:;
    // Computing bound for w
    _233.d1 = j;
    if (j > 0) 
    goto _jump1755;
    fail_assertion("non-positive loop bound");
    _jump1755:;
    // Computing bound for x
    int64_t _234 = g + k;
    _233.d2 = _234;
    if (_234 > 0) 
    goto _jump1756;
    fail_assertion("non-positive loop bound");
    _jump1756:;
    // Computing total size of heap memory to allocate
    int64_t _235 = 1;
    _235 *= r;
    _235 *= j;
    _235 *= _234;
    _235 *= sizeof(bool);
    _233.data = jpl_alloc(_235);
    int64_t _236 = 0; // x
    int64_t _237 = 0; // w
    int64_t _238 = 0; // v
    _jump1757:; // Begin body of loop
    int64_t _239 = 487;
    int64_t _240 = -_239;
    rgba _241 = o(p, _162, _240);
    double _242 = _241.a;
    _a3__a1_double _243;
    // Computing bound for y
    _243.d0 = f;
    if (f > 0) 
    goto _jump1758;
    fail_assertion("non-positive loop bound");
    _jump1758:;
    // Computing bound for z
    _243.d1 = f;
    if (f > 0) 
    goto _jump1759;
    fail_assertion("non-positive loop bound");
    _jump1759:;
    // Computing bound for A
    _243.d2 = r;
    if (r > 0) 
    goto _jump1760;
    fail_assertion("non-positive loop bound");
    _jump1760:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= f;
    _244 *= f;
    _244 *= r;
    _244 *= sizeof(_a1_double);
    _243.data = jpl_alloc(_244);
    int64_t _245 = 0; // A
    int64_t _246 = 0; // z
    int64_t _247 = 0; // y
    _jump1761:; // Begin body of loop
    int64_t _248 = 0;
    _248 *= _243.d0;
    _248 += _247;
    _248 *= _243.d1;
    _248 += _246;
    _248 *= _243.d2;
    _248 += _245;
    _243.data[_248] = c;
    _245++;
    if (_245 < r)
    goto _jump1761;
    _245 = 0;
    _246++;
    if (_246 < f)
    goto _jump1761;
    _246 = 0;
    _247++;
    if (_247 < f)
    goto _jump1761;
    // End body of loop
    int64_t _249 = 425;
    int64_t _250 = 937;
    if (_249 >= 0)
    goto _jump1762;
    fail_assertion("negative array index");
    _jump1762:;
    if (_249 < _243.d0)
    goto _jump1763;
    fail_assertion("index too large");
    _jump1763:;
    if (g >= 0)
    goto _jump1764;
    fail_assertion("negative array index");
    _jump1764:;
    if (g < _243.d1)
    goto _jump1765;
    fail_assertion("index too large");
    _jump1765:;
    if (_250 >= 0)
    goto _jump1766;
    fail_assertion("negative array index");
    _jump1766:;
    if (_250 < _243.d2)
    goto _jump1767;
    fail_assertion("index too large");
    _jump1767:;
    int64_t _251 = 0;
    _251 *= _243.d0;
    _251 += _249;
    _251 *= _243.d1;
    _251 += g;
    _251 *= _243.d2;
    _251 += _250;
    _a1_double _252 = _243.data[_251];
    int64_t _253;
    // Computing bound for y
    int64_t _254;
    if (!q)
    goto _jump1768;
    _254 = _237;
    goto _jump1769;
    _jump1768:;
    _254 = r;
    _jump1769:;
    if (_254 > 0) 
    goto _jump1770;
    fail_assertion("non-positive loop bound");
    _jump1770:;
    // Computing bound for z
    if (j > 0) 
    goto _jump1771;
    fail_assertion("non-positive loop bound");
    _jump1771:;
    _253 = 0;
    int64_t _255 = 0; // z
    int64_t _256 = 0; // y
    _jump1772:; // Begin body of loop
    _253 += f;
    _255++;
    if (_255 < j)
    goto _jump1772;
    _255 = 0;
    _256++;
    if (_256 < _254)
    goto _jump1772;
    // End body of loop
    if (_253 >= 0)
    goto _jump1773;
    fail_assertion("negative array index");
    _jump1773:;
    if (_253 < _252.d0)
    goto _jump1774;
    fail_assertion("index too large");
    _jump1774:;
    int64_t _257 = 0;
    _257 *= _252.d0;
    _257 += _253;
    double _258 = _252.data[_257];
    bool _259 = _242 > _258;
    int64_t _260 = 0;
    _260 *= _233.d0;
    _260 += _238;
    _260 *= _233.d1;
    _260 += _237;
    _260 *= _233.d2;
    _260 += _236;
    _233.data[_260] = _259;
    _236++;
    if (_236 < _234)
    goto _jump1757;
    _236 = 0;
    _237++;
    if (_237 < j)
    goto _jump1757;
    _237 = 0;
    _238++;
    if (_238 < r)
    goto _jump1757;
    // End body of loop
    rgba _261 = m(_232, f, _233);
    _167 = _261;
    _jump1729:;
    return _167;
}

double s(_a3_double t, bool x, _a2_int64_t y) {
    bool _0 = false;
    bool _1 = y.d0 <= j;
    bool _2;
    if (!_1)
    goto _jump1944;
    bool _3 = t.d0 > j;
    _2 = _3;
    goto _jump1945;
    _jump1944:;
    _a3_double _4;
    // Computing bound for H
    _4.d0 = y.d0;
    if (y.d0 > 0) 
    goto _jump1946;
    fail_assertion("non-positive loop bound");
    _jump1946:;
    // Computing bound for I
    int64_t _5 = -q;
    _4.d1 = _5;
    if (_5 > 0) 
    goto _jump1947;
    fail_assertion("non-positive loop bound");
    _jump1947:;
    // Computing bound for J
    int64_t _6;
    // Computing bound for H
    if (y.d1 > 0) 
    goto _jump1948;
    fail_assertion("non-positive loop bound");
    _jump1948:;
    // Computing bound for I
    int64_t _7 = 316;
    if (_7 > 0) 
    goto _jump1949;
    fail_assertion("non-positive loop bound");
    _jump1949:;
    _6 = 0;
    int64_t _8 = 0; // I
    int64_t _9 = 0; // H
    _jump1950:; // Begin body of loop
    _6 += y.d0;
    _8++;
    if (_8 < _7)
    goto _jump1950;
    _8 = 0;
    _9++;
    if (_9 < y.d1)
    goto _jump1950;
    // End body of loop
    _4.d2 = _6;
    if (_6 > 0) 
    goto _jump1951;
    fail_assertion("non-positive loop bound");
    _jump1951:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= y.d0;
    _10 *= _5;
    _10 *= _6;
    _10 *= sizeof(double);
    _4.data = jpl_alloc(_10);
    int64_t _11 = 0; // J
    int64_t _12 = 0; // I
    int64_t _13 = 0; // H
    _jump1952:; // Begin body of loop
    double _14 = 83.0;
    bool _15;
    if (!_0)
    goto _jump1953;
    _15 = x;
    goto _jump1954;
    _jump1953:;
    _15 = _0;
    _jump1954:;
    double _16 = s(t, _15, p);
    double _17 = _14 / _16;
    int64_t _18 = 0;
    _18 *= _4.d0;
    _18 += _13;
    _18 *= _4.d1;
    _18 += _12;
    _18 *= _4.d2;
    _18 += _11;
    _4.data[_18] = _17;
    _11++;
    if (_11 < _6)
    goto _jump1952;
    _11 = 0;
    _12++;
    if (_12 < _5)
    goto _jump1952;
    _12 = 0;
    _13++;
    if (_13 < y.d0)
    goto _jump1952;
    // End body of loop
    bool _19 = n(_4);
    _2 = _19;
    _jump1945:;
    bool _20;
    if (!_2)
    goto _jump1955;
    bool _21 = true;
    _20 = _21;
    goto _jump1956;
    _jump1955:;
    _20 = _0;
    _jump1956:;
    if (0 != _20)
    goto _jump1957;
    fail_assertion("H");
    _jump1957:;
    _a3__a1_double _22;
    if (!x)
    goto _jump1958;
    _a3__a1_double _23;
    // Computing bound for J
    bool _24 = true;
    _a3_int64_t _25;
    if (!_24)
    goto _jump1959;
    _25 = e;
    goto _jump1960;
    _jump1959:;
    _a3_int64_t _26;
    // Computing bound for J
    _26.d0 = k;
    if (k > 0) 
    goto _jump1961;
    fail_assertion("non-positive loop bound");
    _jump1961:;
    // Computing bound for K
    _26.d1 = h;
    if (h > 0) 
    goto _jump1962;
    fail_assertion("non-positive loop bound");
    _jump1962:;
    // Computing bound for L
    _26.d2 = t.d1;
    if (t.d1 > 0) 
    goto _jump1963;
    fail_assertion("non-positive loop bound");
    _jump1963:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= k;
    _27 *= h;
    _27 *= t.d1;
    _27 *= sizeof(int64_t);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // L
    int64_t _29 = 0; // K
    int64_t _30 = 0; // J
    _jump1964:; // Begin body of loop
    int64_t _31 = 0;
    _31 *= _26.d0;
    _31 += _30;
    _31 *= _26.d1;
    _31 += _29;
    _31 *= _26.d2;
    _31 += _28;
    _26.data[_31] = t.d1;
    _28++;
    if (_28 < t.d1)
    goto _jump1964;
    _28 = 0;
    _29++;
    if (_29 < h)
    goto _jump1964;
    _29 = 0;
    _30++;
    if (_30 < k)
    goto _jump1964;
    // End body of loop
    _25 = _26;
    _jump1960:;
    if (g >= 0)
    goto _jump1965;
    fail_assertion("negative array index");
    _jump1965:;
    if (g < _25.d0)
    goto _jump1966;
    fail_assertion("index too large");
    _jump1966:;
    if (r >= 0)
    goto _jump1967;
    fail_assertion("negative array index");
    _jump1967:;
    if (r < _25.d1)
    goto _jump1968;
    fail_assertion("index too large");
    _jump1968:;
    if (t.d1 >= 0)
    goto _jump1969;
    fail_assertion("negative array index");
    _jump1969:;
    if (t.d1 < _25.d2)
    goto _jump1970;
    fail_assertion("index too large");
    _jump1970:;
    int64_t _32 = 0;
    _32 *= _25.d0;
    _32 += g;
    _32 *= _25.d1;
    _32 += r;
    _32 *= _25.d2;
    _32 += t.d1;
    int64_t _33 = _25.data[_32];
    _23.d0 = _33;
    if (_33 > 0) 
    goto _jump1971;
    fail_assertion("non-positive loop bound");
    _jump1971:;
    // Computing bound for K
    _23.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump1972;
    fail_assertion("non-positive loop bound");
    _jump1972:;
    // Computing bound for L
    int64_t _34;
    // Computing bound for J
    int64_t _35 = 795;
    if (_35 > 0) 
    goto _jump1973;
    fail_assertion("non-positive loop bound");
    _jump1973:;
    _34 = 0;
    int64_t _36 = 0; // J
    _jump1974:; // Begin body of loop
    _34 += k;
    _36++;
    if (_36 < _35)
    goto _jump1974;
    // End body of loop
    _23.d2 = _34;
    if (_34 > 0) 
    goto _jump1975;
    fail_assertion("non-positive loop bound");
    _jump1975:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _33;
    _37 *= d.d0;
    _37 *= _34;
    _37 *= sizeof(_a1_double);
    _23.data = jpl_alloc(_37);
    int64_t _38 = 0; // L
    int64_t _39 = 0; // K
    int64_t _40 = 0; // J
    _jump1976:; // Begin body of loop
    int64_t _41 = 0;
    _41 *= _23.d0;
    _41 += _40;
    _41 *= _23.d1;
    _41 += _39;
    _41 *= _23.d2;
    _41 += _38;
    _23.data[_41] = l;
    _38++;
    if (_38 < _34)
    goto _jump1976;
    _38 = 0;
    _39++;
    if (_39 < d.d0)
    goto _jump1976;
    _39 = 0;
    _40++;
    if (_40 < _33)
    goto _jump1976;
    // End body of loop
    _22 = _23;
    goto _jump1977;
    _jump1958:;
    _a3__a1_double _42;
    // Computing bound for J
    int64_t _43;
    // Computing bound for J
    int64_t _44;
    // Computing bound for J
    int64_t _45;
    // Computing bound for J
    if (y.d0 > 0) 
    goto _jump1978;
    fail_assertion("non-positive loop bound");
    _jump1978:;
    // Computing bound for K
    if (j > 0) 
    goto _jump1979;
    fail_assertion("non-positive loop bound");
    _jump1979:;
    _45 = 0;
    int64_t _46 = 0; // K
    int64_t _47 = 0; // J
    _jump1980:; // Begin body of loop
    _45 += g;
    _46++;
    if (_46 < j)
    goto _jump1980;
    _46 = 0;
    _47++;
    if (_47 < y.d0)
    goto _jump1980;
    // End body of loop
    if (_45 > 0) 
    goto _jump1981;
    fail_assertion("non-positive loop bound");
    _jump1981:;
    _44 = 0;
    int64_t _48 = 0; // J
    _jump1982:; // Begin body of loop
    _44 += g;
    _48++;
    if (_48 < _45)
    goto _jump1982;
    // End body of loop
    if (_44 > 0) 
    goto _jump1983;
    fail_assertion("non-positive loop bound");
    _jump1983:;
    // Computing bound for K
    if (y.d0 > 0) 
    goto _jump1984;
    fail_assertion("non-positive loop bound");
    _jump1984:;
    // Computing bound for L
    int64_t _49;
    // Computing bound for J
    if (f > 0) 
    goto _jump1985;
    fail_assertion("non-positive loop bound");
    _jump1985:;
    // Computing bound for K
    if (f > 0) 
    goto _jump1986;
    fail_assertion("non-positive loop bound");
    _jump1986:;
    _49 = 0;
    int64_t _50 = 0; // K
    int64_t _51 = 0; // J
    _jump1987:; // Begin body of loop
    _49 += y.d0;
    _50++;
    if (_50 < f)
    goto _jump1987;
    _50 = 0;
    _51++;
    if (_51 < f)
    goto _jump1987;
    // End body of loop
    if (_49 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    _43 = 0;
    int64_t _52 = 0; // L
    int64_t _53 = 0; // K
    int64_t _54 = 0; // J
    _jump1989:; // Begin body of loop
    _43 += _53;
    _52++;
    if (_52 < _49)
    goto _jump1989;
    _52 = 0;
    _53++;
    if (_53 < y.d0)
    goto _jump1989;
    _53 = 0;
    _54++;
    if (_54 < _44)
    goto _jump1989;
    // End body of loop
    _42.d0 = _43;
    if (_43 > 0) 
    goto _jump1990;
    fail_assertion("non-positive loop bound");
    _jump1990:;
    // Computing bound for K
    _42.d1 = j;
    if (j > 0) 
    goto _jump1991;
    fail_assertion("non-positive loop bound");
    _jump1991:;
    // Computing bound for L
    _42.d2 = h;
    if (h > 0) 
    goto _jump1992;
    fail_assertion("non-positive loop bound");
    _jump1992:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= _43;
    _55 *= j;
    _55 *= h;
    _55 *= sizeof(_a1_double);
    _42.data = jpl_alloc(_55);
    int64_t _56 = 0; // L
    int64_t _57 = 0; // K
    int64_t _58 = 0; // J
    _jump1993:; // Begin body of loop
    int64_t _59 = 0;
    _59 *= _42.d0;
    _59 += _58;
    _59 *= _42.d1;
    _59 += _57;
    _59 *= _42.d2;
    _59 += _56;
    _42.data[_59] = d;
    _56++;
    if (_56 < h)
    goto _jump1993;
    _56 = 0;
    _57++;
    if (_57 < j)
    goto _jump1993;
    _57 = 0;
    _58++;
    if (_58 < _43)
    goto _jump1993;
    // End body of loop
    _22 = _42;
    _jump1977:;
    if (t.d2 >= 0)
    goto _jump1994;
    fail_assertion("negative array index");
    _jump1994:;
    if (t.d2 < _22.d0)
    goto _jump1995;
    fail_assertion("index too large");
    _jump1995:;
    if (r >= 0)
    goto _jump1996;
    fail_assertion("negative array index");
    _jump1996:;
    if (r < _22.d1)
    goto _jump1997;
    fail_assertion("index too large");
    _jump1997:;
    if (g >= 0)
    goto _jump1998;
    fail_assertion("negative array index");
    _jump1998:;
    if (g < _22.d2)
    goto _jump1999;
    fail_assertion("index too large");
    _jump1999:;
    int64_t _60 = 0;
    _60 *= _22.d0;
    _60 += t.d2;
    _60 *= _22.d1;
    _60 += r;
    _60 *= _22.d2;
    _60 += g;
    _a1_double _61 = _22.data[_60];
    _a2__a3_bool _62;
    // Computing bound for J
    _62.d0 = y.d1;
    if (y.d1 > 0) 
    goto _jump2000;
    fail_assertion("non-positive loop bound");
    _jump2000:;
    // Computing bound for K
    _62.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump2001;
    fail_assertion("non-positive loop bound");
    _jump2001:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= y.d1;
    _63 *= d.d0;
    _63 *= sizeof(_a3_bool);
    _62.data = jpl_alloc(_63);
    int64_t _64 = 0; // K
    int64_t _65 = 0; // J
    _jump2002:; // Begin body of loop
    _a3_bool _66;
    // Computing bound for L
    _66.d0 = y.d0;
    if (y.d0 > 0) 
    goto _jump2003;
    fail_assertion("non-positive loop bound");
    _jump2003:;
    // Computing bound for M
    int64_t _67 = 212;
    _66.d1 = _67;
    if (_67 > 0) 
    goto _jump2004;
    fail_assertion("non-positive loop bound");
    _jump2004:;
    // Computing bound for N
    int64_t _68 = 283;
    _66.d2 = _68;
    if (_68 > 0) 
    goto _jump2005;
    fail_assertion("non-positive loop bound");
    _jump2005:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= y.d0;
    _69 *= _67;
    _69 *= _68;
    _69 *= sizeof(bool);
    _66.data = jpl_alloc(_69);
    int64_t _70 = 0; // N
    int64_t _71 = 0; // M
    int64_t _72 = 0; // L
    _jump2006:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _66.d0;
    _73 += _72;
    _73 *= _66.d1;
    _73 += _71;
    _73 *= _66.d2;
    _73 += _70;
    _66.data[_73] = _0;
    _70++;
    if (_70 < _68)
    goto _jump2006;
    _70 = 0;
    _71++;
    if (_71 < _67)
    goto _jump2006;
    _71 = 0;
    _72++;
    if (_72 < y.d0)
    goto _jump2006;
    // End body of loop
    int64_t _74 = 0;
    _74 *= _62.d0;
    _74 += _65;
    _74 *= _62.d1;
    _74 += _64;
    _62.data[_74] = _66;
    _64++;
    if (_64 < d.d0)
    goto _jump2002;
    _64 = 0;
    _65++;
    if (_65 < y.d1)
    goto _jump2002;
    // End body of loop
    int64_t _75;
    // Computing bound for J
    if (d.d0 > 0) 
    goto _jump2007;
    fail_assertion("non-positive loop bound");
    _jump2007:;
    // Computing bound for K
    if (j > 0) 
    goto _jump2008;
    fail_assertion("non-positive loop bound");
    _jump2008:;
    // Computing bound for L
    bool _76 = true;
    int64_t _77;
    if (!_76)
    goto _jump2009;
    _77 = t.d2;
    goto _jump2010;
    _jump2009:;
    _77 = q;
    _jump2010:;
    if (_77 > 0) 
    goto _jump2011;
    fail_assertion("non-positive loop bound");
    _jump2011:;
    _75 = 0;
    int64_t _78 = 0; // L
    int64_t _79 = 0; // K
    int64_t _80 = 0; // J
    _jump2012:; // Begin body of loop
    _75 += _80;
    _78++;
    if (_78 < _77)
    goto _jump2012;
    _78 = 0;
    _79++;
    if (_79 < j)
    goto _jump2012;
    _79 = 0;
    _80++;
    if (_80 < d.d0)
    goto _jump2012;
    // End body of loop
    if (r >= 0)
    goto _jump2013;
    fail_assertion("negative array index");
    _jump2013:;
    if (r < _62.d0)
    goto _jump2014;
    fail_assertion("index too large");
    _jump2014:;
    if (_75 >= 0)
    goto _jump2015;
    fail_assertion("negative array index");
    _jump2015:;
    if (_75 < _62.d1)
    goto _jump2016;
    fail_assertion("index too large");
    _jump2016:;
    int64_t _81 = 0;
    _81 *= _62.d0;
    _81 += r;
    _81 *= _62.d1;
    _81 += _75;
    _a3_bool _82 = _62.data[_81];
    _a3_int64_t _83;
    // Computing bound for J
    _83.d0 = y.d1;
    if (y.d1 > 0) 
    goto _jump2017;
    fail_assertion("non-positive loop bound");
    _jump2017:;
    // Computing bound for K
    _83.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump2018;
    fail_assertion("non-positive loop bound");
    _jump2018:;
    // Computing bound for L
    _83.d2 = t.d1;
    if (t.d1 > 0) 
    goto _jump2019;
    fail_assertion("non-positive loop bound");
    _jump2019:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= y.d1;
    _84 *= d.d0;
    _84 *= t.d1;
    _84 *= sizeof(int64_t);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // L
    int64_t _86 = 0; // K
    int64_t _87 = 0; // J
    _jump2020:; // Begin body of loop
    int64_t _88 = 0;
    _88 *= _83.d0;
    _88 += _87;
    _88 *= _83.d1;
    _88 += _86;
    _88 *= _83.d2;
    _88 += _85;
    _83.data[_88] = _87;
    _85++;
    if (_85 < t.d1)
    goto _jump2020;
    _85 = 0;
    _86++;
    if (_86 < d.d0)
    goto _jump2020;
    _86 = 0;
    _87++;
    if (_87 < y.d1)
    goto _jump2020;
    // End body of loop
    int64_t _89 = 548;
    int64_t _90 = -t.d2;
    if (d.d0 >= 0)
    goto _jump2021;
    fail_assertion("negative array index");
    _jump2021:;
    if (d.d0 < _83.d0)
    goto _jump2022;
    fail_assertion("index too large");
    _jump2022:;
    if (_89 >= 0)
    goto _jump2023;
    fail_assertion("negative array index");
    _jump2023:;
    if (_89 < _83.d1)
    goto _jump2024;
    fail_assertion("index too large");
    _jump2024:;
    if (_90 >= 0)
    goto _jump2025;
    fail_assertion("negative array index");
    _jump2025:;
    if (_90 < _83.d2)
    goto _jump2026;
    fail_assertion("index too large");
    _jump2026:;
    int64_t _91 = 0;
    _91 *= _83.d0;
    _91 += d.d0;
    _91 *= _83.d1;
    _91 += _89;
    _91 *= _83.d2;
    _91 += _90;
    int64_t _92 = _83.data[_91];
    int64_t _93;
    // Computing bound for J
    int64_t _94;
    // Computing bound for J
    int64_t _95 = -r;
    if (_95 > 0) 
    goto _jump2027;
    fail_assertion("non-positive loop bound");
    _jump2027:;
    // Computing bound for K
    bool _96 = true;
    int64_t _97;
    if (!_96)
    goto _jump2028;
    _97 = g;
    goto _jump2029;
    _jump2028:;
    _97 = y.d0;
    _jump2029:;
    if (_97 > 0) 
    goto _jump2030;
    fail_assertion("non-positive loop bound");
    _jump2030:;
    // Computing bound for L
    if (d.d0 > 0) 
    goto _jump2031;
    fail_assertion("non-positive loop bound");
    _jump2031:;
    _94 = 0;
    int64_t _98 = 0; // L
    int64_t _99 = 0; // K
    int64_t _100 = 0; // J
    _jump2032:; // Begin body of loop
    _94 += t.d0;
    _98++;
    if (_98 < d.d0)
    goto _jump2032;
    _98 = 0;
    _99++;
    if (_99 < _97)
    goto _jump2032;
    _99 = 0;
    _100++;
    if (_100 < _95)
    goto _jump2032;
    // End body of loop
    if (_94 > 0) 
    goto _jump2033;
    fail_assertion("non-positive loop bound");
    _jump2033:;
    _93 = 0;
    int64_t _101 = 0; // J
    _jump2034:; // Begin body of loop
    _93 += t.d2;
    _101++;
    if (_101 < _94)
    goto _jump2034;
    // End body of loop
    if (_92 >= 0)
    goto _jump2035;
    fail_assertion("negative array index");
    _jump2035:;
    if (_92 < _82.d0)
    goto _jump2036;
    fail_assertion("index too large");
    _jump2036:;
    if (_93 >= 0)
    goto _jump2037;
    fail_assertion("negative array index");
    _jump2037:;
    if (_93 < _82.d1)
    goto _jump2038;
    fail_assertion("index too large");
    _jump2038:;
    if (y.d0 >= 0)
    goto _jump2039;
    fail_assertion("negative array index");
    _jump2039:;
    if (y.d0 < _82.d2)
    goto _jump2040;
    fail_assertion("index too large");
    _jump2040:;
    int64_t _102 = 0;
    _102 *= _82.d0;
    _102 += _92;
    _102 *= _82.d1;
    _102 += _93;
    _102 *= _82.d2;
    _102 += y.d0;
    bool _103 = _82.data[_102];
    _a2_bool _104;
    if (!_103)
    goto _jump2041;
    bool _106 = true;
    bool _105 = _106;
    if (0 == _106)
    goto _jump2042;
    _105 = x;
    _jump2042:;
    _a3_double _107;
    if (!_105)
    goto _jump2043;
    _107 = t;
    goto _jump2044;
    _jump2043:;
    _107 = t;
    _jump2044:;
    bool _108 = n(_107);
    _a2_bool _109;
    if (!_108)
    goto _jump2045;
    _a1__a2_bool _110;
    // Computing bound for J
    _110.d0 = y.d1;
    if (y.d1 > 0) 
    goto _jump2046;
    fail_assertion("non-positive loop bound");
    _jump2046:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= y.d1;
    _111 *= sizeof(_a2_bool);
    _110.data = jpl_alloc(_111);
    int64_t _112 = 0; // J
    _jump2047:; // Begin body of loop
    _a2_bool _113;
    // Computing bound for K
    _113.d0 = t.d1;
    if (t.d1 > 0) 
    goto _jump2048;
    fail_assertion("non-positive loop bound");
    _jump2048:;
    // Computing bound for L
    _113.d1 = t.d2;
    if (t.d2 > 0) 
    goto _jump2049;
    fail_assertion("non-positive loop bound");
    _jump2049:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= t.d1;
    _114 *= t.d2;
    _114 *= sizeof(bool);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // L
    int64_t _116 = 0; // K
    _jump2050:; // Begin body of loop
    bool _117 = false;
    int64_t _118 = 0;
    _118 *= _113.d0;
    _118 += _116;
    _118 *= _113.d1;
    _118 += _115;
    _113.data[_118] = _117;
    _115++;
    if (_115 < t.d2)
    goto _jump2050;
    _115 = 0;
    _116++;
    if (_116 < t.d1)
    goto _jump2050;
    // End body of loop
    int64_t _119 = 0;
    _119 *= _110.d0;
    _119 += _112;
    _110.data[_119] = _113;
    _112++;
    if (_112 < y.d1)
    goto _jump2047;
    // End body of loop
    if (g >= 0)
    goto _jump2051;
    fail_assertion("negative array index");
    _jump2051:;
    if (g < _110.d0)
    goto _jump2052;
    fail_assertion("index too large");
    _jump2052:;
    int64_t _120 = 0;
    _120 *= _110.d0;
    _120 += g;
    _a2_bool _121 = _110.data[_120];
    _109 = _121;
    goto _jump2053;
    _jump2045:;
    _a2_bool _122;
    // Computing bound for J
    _122.d0 = q;
    if (q > 0) 
    goto _jump2054;
    fail_assertion("non-positive loop bound");
    _jump2054:;
    // Computing bound for K
    _122.d1 = k;
    if (k > 0) 
    goto _jump2055;
    fail_assertion("non-positive loop bound");
    _jump2055:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= q;
    _123 *= k;
    _123 *= sizeof(bool);
    _122.data = jpl_alloc(_123);
    int64_t _124 = 0; // K
    int64_t _125 = 0; // J
    _jump2056:; // Begin body of loop
    int64_t _126 = 0;
    _126 *= _122.d0;
    _126 += _125;
    _126 *= _122.d1;
    _126 += _124;
    _122.data[_126] = x;
    _124++;
    if (_124 < k)
    goto _jump2056;
    _124 = 0;
    _125++;
    if (_125 < q)
    goto _jump2056;
    // End body of loop
    _109 = _122;
    _jump2053:;
    _104 = _109;
    goto _jump2057;
    _jump2041:;
    _a2_bool _127;
    // Computing bound for J
    _127.d0 = t.d1;
    if (t.d1 > 0) 
    goto _jump2058;
    fail_assertion("non-positive loop bound");
    _jump2058:;
    // Computing bound for K
    int64_t _128 = 632;
    _127.d1 = _128;
    if (_128 > 0) 
    goto _jump2059;
    fail_assertion("non-positive loop bound");
    _jump2059:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= t.d1;
    _129 *= _128;
    _129 *= sizeof(bool);
    _127.data = jpl_alloc(_129);
    int64_t _130 = 0; // K
    int64_t _131 = 0; // J
    _jump2060:; // Begin body of loop
    bool _132 = true;
    int64_t _133 = 0;
    _133 *= _127.d0;
    _133 += _131;
    _133 *= _127.d1;
    _133 += _130;
    _127.data[_133] = _132;
    _130++;
    if (_130 < _128)
    goto _jump2060;
    _130 = 0;
    _131++;
    if (_131 < t.d1)
    goto _jump2060;
    // End body of loop
    _104 = _127;
    _jump2057:;
    bool _134 = true;
    bool _135 = !_134;
    _a3__a3_double _136;
    // Computing bound for J
    _136.d0 = q;
    if (q > 0) 
    goto _jump2061;
    fail_assertion("non-positive loop bound");
    _jump2061:;
    // Computing bound for K
    _136.d1 = q;
    if (q > 0) 
    goto _jump2062;
    fail_assertion("non-positive loop bound");
    _jump2062:;
    // Computing bound for L
    _136.d2 = y.d0;
    if (y.d0 > 0) 
    goto _jump2063;
    fail_assertion("non-positive loop bound");
    _jump2063:;
    // Computing total size of heap memory to allocate
    int64_t _137 = 1;
    _137 *= q;
    _137 *= q;
    _137 *= y.d0;
    _137 *= sizeof(_a3_double);
    _136.data = jpl_alloc(_137);
    int64_t _138 = 0; // L
    int64_t _139 = 0; // K
    int64_t _140 = 0; // J
    _jump2064:; // Begin body of loop
    int64_t _141 = 0;
    _141 *= _136.d0;
    _141 += _140;
    _141 *= _136.d1;
    _141 += _139;
    _141 *= _136.d2;
    _141 += _138;
    _136.data[_141] = t;
    _138++;
    if (_138 < y.d0)
    goto _jump2064;
    _138 = 0;
    _139++;
    if (_139 < q)
    goto _jump2064;
    _139 = 0;
    _140++;
    if (_140 < q)
    goto _jump2064;
    // End body of loop
    int64_t _142 = k + r;
    if (d.d0 >= 0)
    goto _jump2065;
    fail_assertion("negative array index");
    _jump2065:;
    if (d.d0 < _136.d0)
    goto _jump2066;
    fail_assertion("index too large");
    _jump2066:;
    if (f >= 0)
    goto _jump2067;
    fail_assertion("negative array index");
    _jump2067:;
    if (f < _136.d1)
    goto _jump2068;
    fail_assertion("index too large");
    _jump2068:;
    if (_142 >= 0)
    goto _jump2069;
    fail_assertion("negative array index");
    _jump2069:;
    if (_142 < _136.d2)
    goto _jump2070;
    fail_assertion("index too large");
    _jump2070:;
    int64_t _143 = 0;
    _143 *= _136.d0;
    _143 += d.d0;
    _143 *= _136.d1;
    _143 += f;
    _143 *= _136.d2;
    _143 += _142;
    _a3_double _144 = _136.data[_143];
    bool _145 = n(_144);
    _a1_bool _146;
    _146.d0 = 2;
    _146.data = jpl_alloc(sizeof(bool) * 2);
    _146.data[0] = _135;
    _146.data[1] = _145;
    _a2__a1_bool _147;
    // Computing bound for J
    _147.d0 = y.d0;
    if (y.d0 > 0) 
    goto _jump2071;
    fail_assertion("non-positive loop bound");
    _jump2071:;
    // Computing bound for K
    int64_t _148;
    // Computing bound for J
    if (t.d0 > 0) 
    goto _jump2072;
    fail_assertion("non-positive loop bound");
    _jump2072:;
    _148 = 0;
    int64_t _149 = 0; // J
    _jump2073:; // Begin body of loop
    _148 += _149;
    _149++;
    if (_149 < t.d0)
    goto _jump2073;
    // End body of loop
    _147.d1 = _148;
    if (_148 > 0) 
    goto _jump2074;
    fail_assertion("non-positive loop bound");
    _jump2074:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= y.d0;
    _150 *= _148;
    _150 *= sizeof(_a1_bool);
    _147.data = jpl_alloc(_150);
    int64_t _151 = 0; // K
    int64_t _152 = 0; // J
    _jump2075:; // Begin body of loop
    _a1_bool _153;
    // Computing bound for L
    _153.d0 = _152;
    if (_152 > 0) 
    goto _jump2076;
    fail_assertion("non-positive loop bound");
    _jump2076:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= _152;
    _154 *= sizeof(bool);
    _153.data = jpl_alloc(_154);
    int64_t _155 = 0; // L
    _jump2077:; // Begin body of loop
    bool _156 = _0;
    if (0 != _0)
    goto _jump2078;
    _156 = x;
    _jump2078:;
    int64_t _157 = 0;
    _157 *= _153.d0;
    _157 += _155;
    _153.data[_157] = _156;
    _155++;
    if (_155 < _152)
    goto _jump2077;
    // End body of loop
    int64_t _158 = 0;
    _158 *= _147.d0;
    _158 += _152;
    _158 *= _147.d1;
    _158 += _151;
    _147.data[_158] = _153;
    _151++;
    if (_151 < _148)
    goto _jump2075;
    _151 = 0;
    _152++;
    if (_152 < y.d0)
    goto _jump2075;
    // End body of loop
    if (y.d0 >= 0)
    goto _jump2079;
    fail_assertion("negative array index");
    _jump2079:;
    if (y.d0 < _147.d0)
    goto _jump2080;
    fail_assertion("index too large");
    _jump2080:;
    if (t.d1 >= 0)
    goto _jump2081;
    fail_assertion("negative array index");
    _jump2081:;
    if (t.d1 < _147.d1)
    goto _jump2082;
    fail_assertion("index too large");
    _jump2082:;
    int64_t _159 = 0;
    _159 *= _147.d0;
    _159 += y.d0;
    _159 *= _147.d1;
    _159 += t.d1;
    _a1_bool _160 = _147.data[_159];
    void_t _161 = b(_146, _160);
    int64_t _162 = a(_104, _161);
    if (_162 >= 0)
    goto _jump2083;
    fail_assertion("negative array index");
    _jump2083:;
    if (_162 < _61.d0)
    goto _jump2084;
    fail_assertion("index too large");
    _jump2084:;
    int64_t _163 = 0;
    _163 *= _61.d0;
    _163 += _162;
    double _164 = _61.data[_163];
    return _164;
}

rgba y(_a2_bool z) {
    _a3_double _0;
    // Computing bound for C
    _0.d0 = v;
    if (v > 0) 
    goto _jump2288;
    fail_assertion("non-positive loop bound");
    _jump2288:;
    // Computing bound for D
    _0.d1 = q;
    if (q > 0) 
    goto _jump2289;
    fail_assertion("non-positive loop bound");
    _jump2289:;
    // Computing bound for E
    int64_t _1 = 315;
    int64_t _2 = _1 / z.d1;
    _0.d2 = _2;
    if (_2 > 0) 
    goto _jump2290;
    fail_assertion("non-positive loop bound");
    _jump2290:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= v;
    _3 *= q;
    _3 *= _2;
    _3 *= sizeof(double);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // E
    int64_t _5 = 0; // D
    int64_t _6 = 0; // C
    _jump2291:; // Begin body of loop
    double _7;
    // Computing bound for F
    int64_t _8 = 539;
    if (_8 > 0) 
    goto _jump2292;
    fail_assertion("non-positive loop bound");
    _jump2292:;
    // Computing bound for G
    if (j > 0) 
    goto _jump2293;
    fail_assertion("non-positive loop bound");
    _jump2293:;
    // Computing bound for H
    if (v > 0) 
    goto _jump2294;
    fail_assertion("non-positive loop bound");
    _jump2294:;
    _7 = 0;
    int64_t _9 = 0; // H
    int64_t _10 = 0; // G
    int64_t _11 = 0; // F
    _jump2295:; // Begin body of loop
    double _12 = 17.0;
    _7 += _12;
    _9++;
    if (_9 < v)
    goto _jump2295;
    _9 = 0;
    _10++;
    if (_10 < j)
    goto _jump2295;
    _10 = 0;
    _11++;
    if (_11 < _8)
    goto _jump2295;
    // End body of loop
    int64_t _13 = 0;
    _13 *= _0.d0;
    _13 += _6;
    _13 *= _0.d1;
    _13 += _5;
    _13 *= _0.d2;
    _13 += _4;
    _0.data[_13] = _7;
    _4++;
    if (_4 < _2)
    goto _jump2291;
    _4 = 0;
    _5++;
    if (_5 < q)
    goto _jump2291;
    _5 = 0;
    _6++;
    if (_6 < v)
    goto _jump2291;
    // End body of loop
    bool _14 = n(_0);
    bool _15 = !_14;
    _a2_bool _16;
    if (!_15)
    goto _jump2296;
    _a3_bool _17;
    // Computing bound for C
    _17.d0 = v;
    if (v > 0) 
    goto _jump2297;
    fail_assertion("non-positive loop bound");
    _jump2297:;
    // Computing bound for D
    _17.d1 = r;
    if (r > 0) 
    goto _jump2298;
    fail_assertion("non-positive loop bound");
    _jump2298:;
    // Computing bound for E
    int64_t _18 = -x;
    _17.d2 = _18;
    if (_18 > 0) 
    goto _jump2299;
    fail_assertion("non-positive loop bound");
    _jump2299:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= v;
    _19 *= r;
    _19 *= _18;
    _19 *= sizeof(bool);
    _17.data = jpl_alloc(_19);
    int64_t _20 = 0; // E
    int64_t _21 = 0; // D
    int64_t _22 = 0; // C
    _jump2300:; // Begin body of loop
    double _24 = 34.0;
    double _25 = 81.0;
    bool _26 = _24 < _25;
    bool _23 = _26;
    if (0 == _26)
    goto _jump2301;
    double _27 = 20.0;
    double _28 = 66.0;
    bool _29 = _27 <= _28;
    _23 = _29;
    _jump2301:;
    int64_t _30 = 0;
    _30 *= _17.d0;
    _30 += _22;
    _30 *= _17.d1;
    _30 += _21;
    _30 *= _17.d2;
    _30 += _20;
    _17.data[_30] = _23;
    _20++;
    if (_20 < _18)
    goto _jump2300;
    _20 = 0;
    _21++;
    if (_21 < r)
    goto _jump2300;
    _21 = 0;
    _22++;
    if (_22 < v)
    goto _jump2300;
    // End body of loop
    if (z.d0 >= 0)
    goto _jump2302;
    fail_assertion("negative array index");
    _jump2302:;
    if (z.d0 < _17.d0)
    goto _jump2303;
    fail_assertion("index too large");
    _jump2303:;
    if (z.d0 >= 0)
    goto _jump2304;
    fail_assertion("negative array index");
    _jump2304:;
    if (z.d0 < _17.d1)
    goto _jump2305;
    fail_assertion("index too large");
    _jump2305:;
    if (q >= 0)
    goto _jump2306;
    fail_assertion("negative array index");
    _jump2306:;
    if (q < _17.d2)
    goto _jump2307;
    fail_assertion("index too large");
    _jump2307:;
    int64_t _31 = 0;
    _31 *= _17.d0;
    _31 += z.d0;
    _31 *= _17.d1;
    _31 += z.d0;
    _31 *= _17.d2;
    _31 += q;
    bool _32 = _17.data[_31];
    _a2_bool _33;
    if (!_32)
    goto _jump2308;
    bool _34 = true;
    _a2_bool _35;
    if (!_34)
    goto _jump2309;
    _35 = z;
    goto _jump2310;
    _jump2309:;
    _35 = z;
    _jump2310:;
    _33 = _35;
    goto _jump2311;
    _jump2308:;
    _a1__a2_bool _36;
    _36.d0 = 1;
    _36.data = jpl_alloc(sizeof(_a2_bool) * 1);
    _36.data[0] = z;
    if (h >= 0)
    goto _jump2312;
    fail_assertion("negative array index");
    _jump2312:;
    if (h < i.d0)
    goto _jump2313;
    fail_assertion("index too large");
    _jump2313:;
    if (v >= 0)
    goto _jump2314;
    fail_assertion("negative array index");
    _jump2314:;
    if (v < i.d1)
    goto _jump2315;
    fail_assertion("index too large");
    _jump2315:;
    int64_t _37 = 0;
    _37 *= i.d0;
    _37 += h;
    _37 *= i.d1;
    _37 += v;
    int64_t _38 = i.data[_37];
    if (_38 >= 0)
    goto _jump2316;
    fail_assertion("negative array index");
    _jump2316:;
    if (_38 < _36.d0)
    goto _jump2317;
    fail_assertion("index too large");
    _jump2317:;
    int64_t _39 = 0;
    _39 *= _36.d0;
    _39 += _38;
    _a2_bool _40 = _36.data[_39];
    bool _41 = g != j;
    _a2_bool _42;
    if (!_41)
    goto _jump2318;
    _42 = z;
    goto _jump2319;
    _jump2318:;
    _42 = z;
    _jump2319:;
    _a1__a2_bool _43;
    _43.d0 = 2;
    _43.data = jpl_alloc(sizeof(_a2_bool) * 2);
    _43.data[0] = _40;
    _43.data[1] = _42;
    if (r >= 0)
    goto _jump2320;
    fail_assertion("negative array index");
    _jump2320:;
    if (r < _43.d0)
    goto _jump2321;
    fail_assertion("index too large");
    _jump2321:;
    int64_t _44 = 0;
    _44 *= _43.d0;
    _44 += r;
    _a2_bool _45 = _43.data[_44];
    _33 = _45;
    _jump2311:;
    _16 = _33;
    goto _jump2322;
    _jump2296:;
    _a2_bool _46;
    // Computing bound for C
    _46.d0 = z.d1;
    if (z.d1 > 0) 
    goto _jump2323;
    fail_assertion("non-positive loop bound");
    _jump2323:;
    // Computing bound for D
    _46.d1 = u;
    if (u > 0) 
    goto _jump2324;
    fail_assertion("non-positive loop bound");
    _jump2324:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= z.d1;
    _47 *= u;
    _47 *= sizeof(bool);
    _46.data = jpl_alloc(_47);
    int64_t _48 = 0; // D
    int64_t _49 = 0; // C
    _jump2325:; // Begin body of loop
    int64_t _50 = -f;
    bool _51 = _48 <= _50;
    int64_t _52 = 0;
    _52 *= _46.d0;
    _52 += _49;
    _52 *= _46.d1;
    _52 += _48;
    _46.data[_52] = _51;
    _48++;
    if (_48 < u)
    goto _jump2325;
    _48 = 0;
    _49++;
    if (_49 < z.d1)
    goto _jump2325;
    // End body of loop
    _16 = _46;
    _jump2322:;
    rgba _53 = y(_16);
    return _53;
    if (r >= 0)
    goto _jump2326;
    fail_assertion("negative array index");
    _jump2326:;
    if (r < c.d0)
    goto _jump2327;
    fail_assertion("index too large");
    _jump2327:;
    int64_t _54 = 0;
    _54 *= c.d0;
    _54 += r;
    double _55 = c.data[_54];
    _a3_double _56;
    // Computing bound for C
    _56.d0 = j;
    if (j > 0) 
    goto _jump2328;
    fail_assertion("non-positive loop bound");
    _jump2328:;
    // Computing bound for D
    _56.d1 = h;
    if (h > 0) 
    goto _jump2329;
    fail_assertion("non-positive loop bound");
    _jump2329:;
    // Computing bound for E
    int64_t _57 = 961;
    _56.d2 = _57;
    if (_57 > 0) 
    goto _jump2330;
    fail_assertion("non-positive loop bound");
    _jump2330:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= j;
    _58 *= h;
    _58 *= _57;
    _58 *= sizeof(double);
    _56.data = jpl_alloc(_58);
    int64_t _59 = 0; // E
    int64_t _60 = 0; // D
    int64_t _61 = 0; // C
    _jump2331:; // Begin body of loop
    double _62 = 50.0;
    int64_t _63 = 0;
    _63 *= _56.d0;
    _63 += _61;
    _63 *= _56.d1;
    _63 += _60;
    _63 *= _56.d2;
    _63 += _59;
    _56.data[_63] = _62;
    _59++;
    if (_59 < _57)
    goto _jump2331;
    _59 = 0;
    _60++;
    if (_60 < h)
    goto _jump2331;
    _60 = 0;
    _61++;
    if (_61 < j)
    goto _jump2331;
    // End body of loop
    bool _64 = false;
    double _65 = s(_56, _64, i);
    double _66;
    // Computing bound for C
    int64_t _67 = -x;
    if (_67 > 0) 
    goto _jump2332;
    fail_assertion("non-positive loop bound");
    _jump2332:;
    // Computing bound for D
    if (j > 0) 
    goto _jump2333;
    fail_assertion("non-positive loop bound");
    _jump2333:;
    _66 = 0;
    int64_t _68 = 0; // D
    int64_t _69 = 0; // C
    _jump2334:; // Begin body of loop
    double _70 = 54.0;
    _66 += _70;
    _68++;
    if (_68 < j)
    goto _jump2334;
    _68 = 0;
    _69++;
    if (_69 < _67)
    goto _jump2334;
    // End body of loop
    double _71 = _65 / _66;
    if (z.d0 >= 0)
    goto _jump2335;
    fail_assertion("negative array index");
    _jump2335:;
    if (z.d0 < w.d0)
    goto _jump2336;
    fail_assertion("index too large");
    _jump2336:;
    int64_t _72 = 0;
    _72 *= w.d0;
    _72 += z.d0;
    double _73 = w.data[_72];
    double _74 = 90.0;
    double _75 = _73 * _74;
    bool _76 = _71 < _75;
    double _77;
    if (!_76)
    goto _jump2337;
    double _78;
    // Computing bound for C
    int64_t _79 = z.d0 + g;
    if (_79 > 0) 
    goto _jump2338;
    fail_assertion("non-positive loop bound");
    _jump2338:;
    // Computing bound for D
    if (h > 0) 
    goto _jump2339;
    fail_assertion("non-positive loop bound");
    _jump2339:;
    // Computing bound for E
    int64_t _80;
    // Computing bound for C
    if (j > 0) 
    goto _jump2340;
    fail_assertion("non-positive loop bound");
    _jump2340:;
    // Computing bound for D
    if (k > 0) 
    goto _jump2341;
    fail_assertion("non-positive loop bound");
    _jump2341:;
    // Computing bound for E
    if (h > 0) 
    goto _jump2342;
    fail_assertion("non-positive loop bound");
    _jump2342:;
    _80 = 0;
    int64_t _81 = 0; // E
    int64_t _82 = 0; // D
    int64_t _83 = 0; // C
    _jump2343:; // Begin body of loop
    _80 += v;
    _81++;
    if (_81 < h)
    goto _jump2343;
    _81 = 0;
    _82++;
    if (_82 < k)
    goto _jump2343;
    _82 = 0;
    _83++;
    if (_83 < j)
    goto _jump2343;
    // End body of loop
    if (_80 > 0) 
    goto _jump2344;
    fail_assertion("non-positive loop bound");
    _jump2344:;
    _78 = 0;
    int64_t _84 = 0; // E
    int64_t _85 = 0; // D
    int64_t _86 = 0; // C
    _jump2345:; // Begin body of loop
    bool _87 = false;
    double _88;
    if (!_87)
    goto _jump2346;
    double _89 = 59.0;
    _88 = _89;
    goto _jump2347;
    _jump2346:;
    double _90 = 75.0;
    _88 = _90;
    _jump2347:;
    _78 += _88;
    _84++;
    if (_84 < _80)
    goto _jump2345;
    _84 = 0;
    _85++;
    if (_85 < h)
    goto _jump2345;
    _85 = 0;
    _86++;
    if (_86 < _79)
    goto _jump2345;
    // End body of loop
    double _91 = -_78;
    bool _92 = false;
    _a2_double _93;
    if (!_92)
    goto _jump2348;
    _a2_double _94;
    // Computing bound for C
    _94.d0 = j;
    if (j > 0) 
    goto _jump2349;
    fail_assertion("non-positive loop bound");
    _jump2349:;
    // Computing bound for D
    _94.d1 = j;
    if (j > 0) 
    goto _jump2350;
    fail_assertion("non-positive loop bound");
    _jump2350:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= j;
    _95 *= j;
    _95 *= sizeof(double);
    _94.data = jpl_alloc(_95);
    int64_t _96 = 0; // D
    int64_t _97 = 0; // C
    _jump2351:; // Begin body of loop
    double _98 = 6.0;
    int64_t _99 = 0;
    _99 *= _94.d0;
    _99 += _97;
    _99 *= _94.d1;
    _99 += _96;
    _94.data[_99] = _98;
    _96++;
    if (_96 < j)
    goto _jump2351;
    _96 = 0;
    _97++;
    if (_97 < j)
    goto _jump2351;
    // End body of loop
    _93 = _94;
    goto _jump2352;
    _jump2348:;
    _a2_double _100;
    // Computing bound for C
    _100.d0 = v;
    if (v > 0) 
    goto _jump2353;
    fail_assertion("non-positive loop bound");
    _jump2353:;
    // Computing bound for D
    _100.d1 = u;
    if (u > 0) 
    goto _jump2354;
    fail_assertion("non-positive loop bound");
    _jump2354:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= v;
    _101 *= u;
    _101 *= sizeof(double);
    _100.data = jpl_alloc(_101);
    int64_t _102 = 0; // D
    int64_t _103 = 0; // C
    _jump2355:; // Begin body of loop
    double _104 = 43.0;
    int64_t _105 = 0;
    _105 *= _100.d0;
    _105 += _103;
    _105 *= _100.d1;
    _105 += _102;
    _100.data[_105] = _104;
    _102++;
    if (_102 < u)
    goto _jump2355;
    _102 = 0;
    _103++;
    if (_103 < v)
    goto _jump2355;
    // End body of loop
    _93 = _100;
    _jump2352:;
    _a2_int64_t _106;
    // Computing bound for C
    _106.d0 = h;
    if (h > 0) 
    goto _jump2356;
    fail_assertion("non-positive loop bound");
    _jump2356:;
    // Computing bound for D
    _106.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2357;
    fail_assertion("non-positive loop bound");
    _jump2357:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= h;
    _107 *= z.d0;
    _107 *= sizeof(int64_t);
    _106.data = jpl_alloc(_107);
    int64_t _108 = 0; // D
    int64_t _109 = 0; // C
    _jump2358:; // Begin body of loop
    int64_t _110 = 0;
    _110 *= _106.d0;
    _110 += _109;
    _110 *= _106.d1;
    _110 += _108;
    _106.data[_110] = j;
    _108++;
    if (_108 < z.d0)
    goto _jump2358;
    _108 = 0;
    _109++;
    if (_109 < h)
    goto _jump2358;
    // End body of loop
    if (h >= 0)
    goto _jump2359;
    fail_assertion("negative array index");
    _jump2359:;
    if (h < _106.d0)
    goto _jump2360;
    fail_assertion("index too large");
    _jump2360:;
    if (u >= 0)
    goto _jump2361;
    fail_assertion("negative array index");
    _jump2361:;
    if (u < _106.d1)
    goto _jump2362;
    fail_assertion("index too large");
    _jump2362:;
    int64_t _111 = 0;
    _111 *= _106.d0;
    _111 += h;
    _111 *= _106.d1;
    _111 += u;
    int64_t _112 = _106.data[_111];
    int64_t _113 = -k;
    if (_112 >= 0)
    goto _jump2363;
    fail_assertion("negative array index");
    _jump2363:;
    if (_112 < _93.d0)
    goto _jump2364;
    fail_assertion("index too large");
    _jump2364:;
    if (_113 >= 0)
    goto _jump2365;
    fail_assertion("negative array index");
    _jump2365:;
    if (_113 < _93.d1)
    goto _jump2366;
    fail_assertion("index too large");
    _jump2366:;
    int64_t _114 = 0;
    _114 *= _93.d0;
    _114 += _112;
    _114 *= _93.d1;
    _114 += _113;
    double _115 = _93.data[_114];
    double _116 = _91 + _115;
    _77 = _116;
    goto _jump2367;
    _jump2337:;
    bool _117 = true;
    bool _118 = !_117;
    _a2__a2_int64_t _119;
    if (!_118)
    goto _jump2368;
    _a2__a2_int64_t _120;
    // Computing bound for C
    _120.d0 = r;
    if (r > 0) 
    goto _jump2369;
    fail_assertion("non-positive loop bound");
    _jump2369:;
    // Computing bound for D
    _120.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2370;
    fail_assertion("non-positive loop bound");
    _jump2370:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= r;
    _121 *= z.d0;
    _121 *= sizeof(_a2_int64_t);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // D
    int64_t _123 = 0; // C
    _jump2371:; // Begin body of loop
    int64_t _124 = 0;
    _124 *= _120.d0;
    _124 += _123;
    _124 *= _120.d1;
    _124 += _122;
    _120.data[_124] = i;
    _122++;
    if (_122 < z.d0)
    goto _jump2371;
    _122 = 0;
    _123++;
    if (_123 < r)
    goto _jump2371;
    // End body of loop
    _119 = _120;
    goto _jump2372;
    _jump2368:;
    _a2__a2_int64_t _125;
    // Computing bound for C
    _125.d0 = v;
    if (v > 0) 
    goto _jump2373;
    fail_assertion("non-positive loop bound");
    _jump2373:;
    // Computing bound for D
    int64_t _126 = 579;
    _125.d1 = _126;
    if (_126 > 0) 
    goto _jump2374;
    fail_assertion("non-positive loop bound");
    _jump2374:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= v;
    _127 *= _126;
    _127 *= sizeof(_a2_int64_t);
    _125.data = jpl_alloc(_127);
    int64_t _128 = 0; // D
    int64_t _129 = 0; // C
    _jump2375:; // Begin body of loop
    int64_t _130 = 0;
    _130 *= _125.d0;
    _130 += _129;
    _130 *= _125.d1;
    _130 += _128;
    _125.data[_130] = t;
    _128++;
    if (_128 < _126)
    goto _jump2375;
    _128 = 0;
    _129++;
    if (_129 < v)
    goto _jump2375;
    // End body of loop
    _119 = _125;
    _jump2372:;
    _a3_bool _131;
    // Computing bound for C
    int64_t _132;
    // Computing bound for C
    if (k > 0) 
    goto _jump2376;
    fail_assertion("non-positive loop bound");
    _jump2376:;
    // Computing bound for D
    if (f > 0) 
    goto _jump2377;
    fail_assertion("non-positive loop bound");
    _jump2377:;
    _132 = 0;
    int64_t _133 = 0; // D
    int64_t _134 = 0; // C
    _jump2378:; // Begin body of loop
    _132 += r;
    _133++;
    if (_133 < f)
    goto _jump2378;
    _133 = 0;
    _134++;
    if (_134 < k)
    goto _jump2378;
    // End body of loop
    _131.d0 = _132;
    if (_132 > 0) 
    goto _jump2379;
    fail_assertion("non-positive loop bound");
    _jump2379:;
    // Computing bound for D
    int64_t _135 = -r;
    _131.d1 = _135;
    if (_135 > 0) 
    goto _jump2380;
    fail_assertion("non-positive loop bound");
    _jump2380:;
    // Computing bound for E
    _131.d2 = q;
    if (q > 0) 
    goto _jump2381;
    fail_assertion("non-positive loop bound");
    _jump2381:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _132;
    _136 *= _135;
    _136 *= q;
    _136 *= sizeof(bool);
    _131.data = jpl_alloc(_136);
    int64_t _137 = 0; // E
    int64_t _138 = 0; // D
    int64_t _139 = 0; // C
    _jump2382:; // Begin body of loop
    bool _141 = true;
    bool _140 = _141;
    if (0 != _141)
    goto _jump2383;
    bool _142 = true;
    _140 = _142;
    _jump2383:;
    int64_t _143 = 0;
    _143 *= _131.d0;
    _143 += _139;
    _143 *= _131.d1;
    _143 += _138;
    _143 *= _131.d2;
    _143 += _137;
    _131.data[_143] = _140;
    _137++;
    if (_137 < q)
    goto _jump2382;
    _137 = 0;
    _138++;
    if (_138 < _135)
    goto _jump2382;
    _138 = 0;
    _139++;
    if (_139 < _132)
    goto _jump2382;
    // End body of loop
    rgba _144 = m(_119, j, _131);
    double _145 = _144.b;
    _77 = _145;
    _jump2367:;
    double _146;
    // Computing bound for C
    int64_t _147;
    // Computing bound for C
    if (g > 0) 
    goto _jump2384;
    fail_assertion("non-positive loop bound");
    _jump2384:;
    _147 = 0;
    int64_t _148 = 0; // C
    _jump2385:; // Begin body of loop
    _147 += _148;
    _148++;
    if (_148 < g)
    goto _jump2385;
    // End body of loop
    int64_t _149 = _147 / h;
    if (_149 > 0) 
    goto _jump2386;
    fail_assertion("non-positive loop bound");
    _jump2386:;
    _146 = 0;
    int64_t _150 = 0; // C
    _jump2387:; // Begin body of loop
    double _151 = 33.0;
    double _152 = -_151;
    _146 += _152;
    _150++;
    if (_150 < _149)
    goto _jump2387;
    // End body of loop
    double _153 = _77 * _146;
    double _154 = _55 * _153;
    bool _155 = false;
    bool _156 = true;
    bool _157;
    if (!_156)
    goto _jump2388;
    bool _159 = true;
    bool _158 = _159;
    if (0 != _159)
    goto _jump2389;
    bool _160 = true;
    _158 = _160;
    _jump2389:;
    _157 = _158;
    goto _jump2390;
    _jump2388:;
    int64_t _161 = q % z.d0;
    bool _162 = g != _161;
    _157 = _162;
    _jump2390:;
    bool _163 = _155 != _157;
    _a2__a3_double _164;
    if (!_163)
    goto _jump2391;
    _a2__a3_double _165;
    // Computing bound for D
    _165.d0 = q;
    if (q > 0) 
    goto _jump2392;
    fail_assertion("non-positive loop bound");
    _jump2392:;
    // Computing bound for E
    _165.d1 = j;
    if (j > 0) 
    goto _jump2393;
    fail_assertion("non-positive loop bound");
    _jump2393:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= q;
    _166 *= j;
    _166 *= sizeof(_a3_double);
    _165.data = jpl_alloc(_166);
    int64_t _167 = 0; // E
    int64_t _168 = 0; // D
    _jump2394:; // Begin body of loop
    double _169 = 56.0;
    bool _170 = _154 > _169;
    _a3_double _171;
    if (!_170)
    goto _jump2395;
    _a3_double _172;
    // Computing bound for F
    _172.d0 = z.d0;
    if (z.d0 > 0) 
    goto _jump2396;
    fail_assertion("non-positive loop bound");
    _jump2396:;
    // Computing bound for G
    _172.d1 = x;
    if (x > 0) 
    goto _jump2397;
    fail_assertion("non-positive loop bound");
    _jump2397:;
    // Computing bound for H
    _172.d2 = v;
    if (v > 0) 
    goto _jump2398;
    fail_assertion("non-positive loop bound");
    _jump2398:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= z.d0;
    _173 *= x;
    _173 *= v;
    _173 *= sizeof(double);
    _172.data = jpl_alloc(_173);
    int64_t _174 = 0; // H
    int64_t _175 = 0; // G
    int64_t _176 = 0; // F
    _jump2399:; // Begin body of loop
    double _177 = 32.0;
    int64_t _178 = 0;
    _178 *= _172.d0;
    _178 += _176;
    _178 *= _172.d1;
    _178 += _175;
    _178 *= _172.d2;
    _178 += _174;
    _172.data[_178] = _177;
    _174++;
    if (_174 < v)
    goto _jump2399;
    _174 = 0;
    _175++;
    if (_175 < x)
    goto _jump2399;
    _175 = 0;
    _176++;
    if (_176 < z.d0)
    goto _jump2399;
    // End body of loop
    _171 = _172;
    goto _jump2400;
    _jump2395:;
    bool _179 = false;
    _a3_double _180;
    if (!_179)
    goto _jump2401;
    _a3_double _181;
    // Computing bound for F
    _181.d0 = z.d0;
    if (z.d0 > 0) 
    goto _jump2402;
    fail_assertion("non-positive loop bound");
    _jump2402:;
    // Computing bound for G
    _181.d1 = q;
    if (q > 0) 
    goto _jump2403;
    fail_assertion("non-positive loop bound");
    _jump2403:;
    // Computing bound for H
    _181.d2 = f;
    if (f > 0) 
    goto _jump2404;
    fail_assertion("non-positive loop bound");
    _jump2404:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= z.d0;
    _182 *= q;
    _182 *= f;
    _182 *= sizeof(double);
    _181.data = jpl_alloc(_182);
    int64_t _183 = 0; // H
    int64_t _184 = 0; // G
    int64_t _185 = 0; // F
    _jump2405:; // Begin body of loop
    int64_t _186 = 0;
    _186 *= _181.d0;
    _186 += _185;
    _186 *= _181.d1;
    _186 += _184;
    _186 *= _181.d2;
    _186 += _183;
    _181.data[_186] = _154;
    _183++;
    if (_183 < f)
    goto _jump2405;
    _183 = 0;
    _184++;
    if (_184 < q)
    goto _jump2405;
    _184 = 0;
    _185++;
    if (_185 < z.d0)
    goto _jump2405;
    // End body of loop
    _180 = _181;
    goto _jump2406;
    _jump2401:;
    _a3_double _187;
    // Computing bound for F
    int64_t _188 = 836;
    _187.d0 = _188;
    if (_188 > 0) 
    goto _jump2407;
    fail_assertion("non-positive loop bound");
    _jump2407:;
    // Computing bound for G
    _187.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2408;
    fail_assertion("non-positive loop bound");
    _jump2408:;
    // Computing bound for H
    _187.d2 = g;
    if (g > 0) 
    goto _jump2409;
    fail_assertion("non-positive loop bound");
    _jump2409:;
    // Computing total size of heap memory to allocate
    int64_t _189 = 1;
    _189 *= _188;
    _189 *= z.d0;
    _189 *= g;
    _189 *= sizeof(double);
    _187.data = jpl_alloc(_189);
    int64_t _190 = 0; // H
    int64_t _191 = 0; // G
    int64_t _192 = 0; // F
    _jump2410:; // Begin body of loop
    double _193 = 94.0;
    int64_t _194 = 0;
    _194 *= _187.d0;
    _194 += _192;
    _194 *= _187.d1;
    _194 += _191;
    _194 *= _187.d2;
    _194 += _190;
    _187.data[_194] = _193;
    _190++;
    if (_190 < g)
    goto _jump2410;
    _190 = 0;
    _191++;
    if (_191 < z.d0)
    goto _jump2410;
    _191 = 0;
    _192++;
    if (_192 < _188)
    goto _jump2410;
    // End body of loop
    _180 = _187;
    _jump2406:;
    _171 = _180;
    _jump2400:;
    int64_t _195 = 0;
    _195 *= _165.d0;
    _195 += _168;
    _195 *= _165.d1;
    _195 += _167;
    _165.data[_195] = _171;
    _167++;
    if (_167 < j)
    goto _jump2394;
    _167 = 0;
    _168++;
    if (_168 < q)
    goto _jump2394;
    // End body of loop
    _164 = _165;
    goto _jump2411;
    _jump2391:;
    _a2__a3_double _196;
    // Computing bound for D
    int64_t _197 = 448;
    _196.d0 = _197;
    if (_197 > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    // Computing bound for E
    _196.d1 = u;
    if (u > 0) 
    goto _jump2413;
    fail_assertion("non-positive loop bound");
    _jump2413:;
    // Computing total size of heap memory to allocate
    int64_t _198 = 1;
    _198 *= _197;
    _198 *= u;
    _198 *= sizeof(_a3_double);
    _196.data = jpl_alloc(_198);
    int64_t _199 = 0; // E
    int64_t _200 = 0; // D
    _jump2414:; // Begin body of loop
    _a3_double _201;
    // Computing bound for F
    _201.d0 = v;
    if (v > 0) 
    goto _jump2415;
    fail_assertion("non-positive loop bound");
    _jump2415:;
    // Computing bound for G
    _201.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2416;
    fail_assertion("non-positive loop bound");
    _jump2416:;
    // Computing bound for H
    _201.d2 = j;
    if (j > 0) 
    goto _jump2417;
    fail_assertion("non-positive loop bound");
    _jump2417:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= v;
    _202 *= z.d0;
    _202 *= j;
    _202 *= sizeof(double);
    _201.data = jpl_alloc(_202);
    int64_t _203 = 0; // H
    int64_t _204 = 0; // G
    int64_t _205 = 0; // F
    _jump2418:; // Begin body of loop
    int64_t _206 = 0;
    _206 *= _201.d0;
    _206 += _205;
    _206 *= _201.d1;
    _206 += _204;
    _206 *= _201.d2;
    _206 += _203;
    _201.data[_206] = _154;
    _203++;
    if (_203 < j)
    goto _jump2418;
    _203 = 0;
    _204++;
    if (_204 < z.d0)
    goto _jump2418;
    _204 = 0;
    _205++;
    if (_205 < v)
    goto _jump2418;
    // End body of loop
    int64_t _207 = 0;
    _207 *= _196.d0;
    _207 += _200;
    _207 *= _196.d1;
    _207 += _199;
    _196.data[_207] = _201;
    _199++;
    if (_199 < u)
    goto _jump2414;
    _199 = 0;
    _200++;
    if (_200 < _197)
    goto _jump2414;
    // End body of loop
    _a2__a3_double _208;
    // Computing bound for D
    int64_t _209 = -z.d0;
    _208.d0 = _209;
    if (_209 > 0) 
    goto _jump2419;
    fail_assertion("non-positive loop bound");
    _jump2419:;
    // Computing bound for E
    _208.d1 = j;
    if (j > 0) 
    goto _jump2420;
    fail_assertion("non-positive loop bound");
    _jump2420:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= _209;
    _210 *= j;
    _210 *= sizeof(_a3_double);
    _208.data = jpl_alloc(_210);
    int64_t _211 = 0; // E
    int64_t _212 = 0; // D
    _jump2421:; // Begin body of loop
    _a3_double _213;
    // Computing bound for F
    _213.d0 = j;
    if (j > 0) 
    goto _jump2422;
    fail_assertion("non-positive loop bound");
    _jump2422:;
    // Computing bound for G
    _213.d1 = r;
    if (r > 0) 
    goto _jump2423;
    fail_assertion("non-positive loop bound");
    _jump2423:;
    // Computing bound for H
    _213.d2 = k;
    if (k > 0) 
    goto _jump2424;
    fail_assertion("non-positive loop bound");
    _jump2424:;
    // Computing total size of heap memory to allocate
    int64_t _214 = 1;
    _214 *= j;
    _214 *= r;
    _214 *= k;
    _214 *= sizeof(double);
    _213.data = jpl_alloc(_214);
    int64_t _215 = 0; // H
    int64_t _216 = 0; // G
    int64_t _217 = 0; // F
    _jump2425:; // Begin body of loop
    int64_t _218 = 0;
    _218 *= _213.d0;
    _218 += _217;
    _218 *= _213.d1;
    _218 += _216;
    _218 *= _213.d2;
    _218 += _215;
    _213.data[_218] = _154;
    _215++;
    if (_215 < k)
    goto _jump2425;
    _215 = 0;
    _216++;
    if (_216 < r)
    goto _jump2425;
    _216 = 0;
    _217++;
    if (_217 < j)
    goto _jump2425;
    // End body of loop
    int64_t _219 = 0;
    _219 *= _208.d0;
    _219 += _212;
    _219 *= _208.d1;
    _219 += _211;
    _208.data[_219] = _213;
    _211++;
    if (_211 < j)
    goto _jump2421;
    _211 = 0;
    _212++;
    if (_212 < _209)
    goto _jump2421;
    // End body of loop
    _a2__a3_double _220;
    // Computing bound for D
    _220.d0 = z.d0;
    if (z.d0 > 0) 
    goto _jump2426;
    fail_assertion("non-positive loop bound");
    _jump2426:;
    // Computing bound for E
    _220.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2427;
    fail_assertion("non-positive loop bound");
    _jump2427:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= z.d0;
    _221 *= z.d0;
    _221 *= sizeof(_a3_double);
    _220.data = jpl_alloc(_221);
    int64_t _222 = 0; // E
    int64_t _223 = 0; // D
    _jump2428:; // Begin body of loop
    _a3_double _224;
    // Computing bound for F
    int64_t _225 = 96;
    _224.d0 = _225;
    if (_225 > 0) 
    goto _jump2429;
    fail_assertion("non-positive loop bound");
    _jump2429:;
    // Computing bound for G
    _224.d1 = x;
    if (x > 0) 
    goto _jump2430;
    fail_assertion("non-positive loop bound");
    _jump2430:;
    // Computing bound for H
    _224.d2 = _222;
    if (_222 > 0) 
    goto _jump2431;
    fail_assertion("non-positive loop bound");
    _jump2431:;
    // Computing total size of heap memory to allocate
    int64_t _226 = 1;
    _226 *= _225;
    _226 *= x;
    _226 *= _222;
    _226 *= sizeof(double);
    _224.data = jpl_alloc(_226);
    int64_t _227 = 0; // H
    int64_t _228 = 0; // G
    int64_t _229 = 0; // F
    _jump2432:; // Begin body of loop
    double _230 = 13.0;
    int64_t _231 = 0;
    _231 *= _224.d0;
    _231 += _229;
    _231 *= _224.d1;
    _231 += _228;
    _231 *= _224.d2;
    _231 += _227;
    _224.data[_231] = _230;
    _227++;
    if (_227 < _222)
    goto _jump2432;
    _227 = 0;
    _228++;
    if (_228 < x)
    goto _jump2432;
    _228 = 0;
    _229++;
    if (_229 < _225)
    goto _jump2432;
    // End body of loop
    int64_t _232 = 0;
    _232 *= _220.d0;
    _232 += _223;
    _232 *= _220.d1;
    _232 += _222;
    _220.data[_232] = _224;
    _222++;
    if (_222 < z.d0)
    goto _jump2428;
    _222 = 0;
    _223++;
    if (_223 < z.d0)
    goto _jump2428;
    // End body of loop
    _a1__a2__a3_double _233;
    _233.d0 = 3;
    _233.data = jpl_alloc(sizeof(_a2__a3_double) * 3);
    _233.data[0] = _196;
    _233.data[1] = _208;
    _233.data[2] = _220;
    if (r >= 0)
    goto _jump2433;
    fail_assertion("negative array index");
    _jump2433:;
    if (r < _233.d0)
    goto _jump2434;
    fail_assertion("index too large");
    _jump2434:;
    int64_t _234 = 0;
    _234 *= _233.d0;
    _234 += r;
    _a2__a3_double _235 = _233.data[_234];
    _164 = _235;
    _jump2411:;
    int64_t _236 = -q;
    if (h >= 0)
    goto _jump2435;
    fail_assertion("negative array index");
    _jump2435:;
    if (h < _164.d0)
    goto _jump2436;
    fail_assertion("index too large");
    _jump2436:;
    if (_236 >= 0)
    goto _jump2437;
    fail_assertion("negative array index");
    _jump2437:;
    if (_236 < _164.d1)
    goto _jump2438;
    fail_assertion("index too large");
    _jump2438:;
    int64_t _237 = 0;
    _237 *= _164.d0;
    _237 += h;
    _237 *= _164.d1;
    _237 += _236;
    _a3_double _238 = _164.data[_237];
    _a3_double _239;
    // Computing bound for D
    _239.d0 = x;
    if (x > 0) 
    goto _jump2439;
    fail_assertion("non-positive loop bound");
    _jump2439:;
    // Computing bound for E
    _239.d1 = v;
    if (v > 0) 
    goto _jump2440;
    fail_assertion("non-positive loop bound");
    _jump2440:;
    // Computing bound for F
    int64_t _240 = -k;
    bool _241 = _240 == j;
    int64_t _242;
    if (!_241)
    goto _jump2441;
    _242 = r;
    goto _jump2442;
    _jump2441:;
    _242 = z.d0;
    _jump2442:;
    _239.d2 = _242;
    if (_242 > 0) 
    goto _jump2443;
    fail_assertion("non-positive loop bound");
    _jump2443:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= x;
    _243 *= v;
    _243 *= _242;
    _243 *= sizeof(double);
    _239.data = jpl_alloc(_243);
    int64_t _244 = 0; // F
    int64_t _245 = 0; // E
    int64_t _246 = 0; // D
    _jump2444:; // Begin body of loop
    double _247 = 76.0;
    int64_t _248 = 0;
    _248 *= _239.d0;
    _248 += _246;
    _248 *= _239.d1;
    _248 += _245;
    _248 *= _239.d2;
    _248 += _244;
    _239.data[_248] = _247;
    _244++;
    if (_244 < _242)
    goto _jump2444;
    _244 = 0;
    _245++;
    if (_245 < v)
    goto _jump2444;
    _245 = 0;
    _246++;
    if (_246 < x)
    goto _jump2444;
    // End body of loop
    bool _249 = n(_239);
    rgba _250 = o(_238, _249, h);
    return _250;
    _a2_bool _251;
    // Computing bound for D
    int64_t _252 = 341;
    _251.d0 = _252;
    if (_252 > 0) 
    goto _jump2445;
    fail_assertion("non-positive loop bound");
    _jump2445:;
    // Computing bound for E
    _251.d1 = k;
    if (k > 0) 
    goto _jump2446;
    fail_assertion("non-positive loop bound");
    _jump2446:;
    // Computing total size of heap memory to allocate
    int64_t _253 = 1;
    _253 *= _252;
    _253 *= k;
    _253 *= sizeof(bool);
    _251.data = jpl_alloc(_253);
    int64_t _254 = 0; // E
    int64_t _255 = 0; // D
    _jump2447:; // Begin body of loop
    bool _256 = true;
    int64_t _257 = 0;
    _257 *= _251.d0;
    _257 += _255;
    _257 *= _251.d1;
    _257 += _254;
    _251.data[_257] = _256;
    _254++;
    if (_254 < k)
    goto _jump2447;
    _254 = 0;
    _255++;
    if (_255 < _252)
    goto _jump2447;
    // End body of loop
    if (g >= 0)
    goto _jump2448;
    fail_assertion("negative array index");
    _jump2448:;
    if (g < _251.d0)
    goto _jump2449;
    fail_assertion("index too large");
    _jump2449:;
    if (z.d0 >= 0)
    goto _jump2450;
    fail_assertion("negative array index");
    _jump2450:;
    if (z.d0 < _251.d1)
    goto _jump2451;
    fail_assertion("index too large");
    _jump2451:;
    int64_t _258 = 0;
    _258 *= _251.d0;
    _258 += g;
    _258 *= _251.d1;
    _258 += z.d0;
    bool _259 = _251.data[_258];
    _a3_double _260;
    if (!_259)
    goto _jump2452;
    bool _263 = j < r;
    bool _262 = _263;
    if (0 != _263)
    goto _jump2453;
    _a3_double _264;
    // Computing bound for D
    _264.d0 = f;
    if (f > 0) 
    goto _jump2454;
    fail_assertion("non-positive loop bound");
    _jump2454:;
    // Computing bound for E
    _264.d1 = r;
    if (r > 0) 
    goto _jump2455;
    fail_assertion("non-positive loop bound");
    _jump2455:;
    // Computing bound for F
    _264.d2 = h;
    if (h > 0) 
    goto _jump2456;
    fail_assertion("non-positive loop bound");
    _jump2456:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= f;
    _265 *= r;
    _265 *= h;
    _265 *= sizeof(double);
    _264.data = jpl_alloc(_265);
    int64_t _266 = 0; // F
    int64_t _267 = 0; // E
    int64_t _268 = 0; // D
    _jump2457:; // Begin body of loop
    double _269 = 76.0;
    int64_t _270 = 0;
    _270 *= _264.d0;
    _270 += _268;
    _270 *= _264.d1;
    _270 += _267;
    _270 *= _264.d2;
    _270 += _266;
    _264.data[_270] = _269;
    _266++;
    if (_266 < h)
    goto _jump2457;
    _266 = 0;
    _267++;
    if (_267 < r)
    goto _jump2457;
    _267 = 0;
    _268++;
    if (_268 < f)
    goto _jump2457;
    // End body of loop
    bool _271 = n(_264);
    _262 = _271;
    _jump2453:;
    bool _261 = _262;
    if (0 != _262)
    goto _jump2458;
    bool _272 = r < g;
    _a3_double _273;
    if (!_272)
    goto _jump2459;
    _a3_double _274;
    // Computing bound for D
    int64_t _275 = 31;
    _274.d0 = _275;
    if (_275 > 0) 
    goto _jump2460;
    fail_assertion("non-positive loop bound");
    _jump2460:;
    // Computing bound for E
    _274.d1 = q;
    if (q > 0) 
    goto _jump2461;
    fail_assertion("non-positive loop bound");
    _jump2461:;
    // Computing bound for F
    _274.d2 = j;
    if (j > 0) 
    goto _jump2462;
    fail_assertion("non-positive loop bound");
    _jump2462:;
    // Computing total size of heap memory to allocate
    int64_t _276 = 1;
    _276 *= _275;
    _276 *= q;
    _276 *= j;
    _276 *= sizeof(double);
    _274.data = jpl_alloc(_276);
    int64_t _277 = 0; // F
    int64_t _278 = 0; // E
    int64_t _279 = 0; // D
    _jump2463:; // Begin body of loop
    double _280 = 9.0;
    int64_t _281 = 0;
    _281 *= _274.d0;
    _281 += _279;
    _281 *= _274.d1;
    _281 += _278;
    _281 *= _274.d2;
    _281 += _277;
    _274.data[_281] = _280;
    _277++;
    if (_277 < j)
    goto _jump2463;
    _277 = 0;
    _278++;
    if (_278 < q)
    goto _jump2463;
    _278 = 0;
    _279++;
    if (_279 < _275)
    goto _jump2463;
    // End body of loop
    _273 = _274;
    goto _jump2464;
    _jump2459:;
    _a3_double _282;
    // Computing bound for D
    int64_t _283 = 941;
    _282.d0 = _283;
    if (_283 > 0) 
    goto _jump2465;
    fail_assertion("non-positive loop bound");
    _jump2465:;
    // Computing bound for E
    _282.d1 = u;
    if (u > 0) 
    goto _jump2466;
    fail_assertion("non-positive loop bound");
    _jump2466:;
    // Computing bound for F
    _282.d2 = q;
    if (q > 0) 
    goto _jump2467;
    fail_assertion("non-positive loop bound");
    _jump2467:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _283;
    _284 *= u;
    _284 *= q;
    _284 *= sizeof(double);
    _282.data = jpl_alloc(_284);
    int64_t _285 = 0; // F
    int64_t _286 = 0; // E
    int64_t _287 = 0; // D
    _jump2468:; // Begin body of loop
    int64_t _288 = 0;
    _288 *= _282.d0;
    _288 += _287;
    _288 *= _282.d1;
    _288 += _286;
    _288 *= _282.d2;
    _288 += _285;
    _282.data[_288] = _154;
    _285++;
    if (_285 < q)
    goto _jump2468;
    _285 = 0;
    _286++;
    if (_286 < u)
    goto _jump2468;
    _286 = 0;
    _287++;
    if (_287 < _283)
    goto _jump2468;
    // End body of loop
    _273 = _282;
    _jump2464:;
    bool _289 = n(_273);
    _261 = _289;
    _jump2458:;
    _a3_double _290;
    if (!_261)
    goto _jump2469;
    _a3_double _291;
    // Computing bound for D
    _291.d0 = f;
    if (f > 0) 
    goto _jump2470;
    fail_assertion("non-positive loop bound");
    _jump2470:;
    // Computing bound for E
    _291.d1 = j;
    if (j > 0) 
    goto _jump2471;
    fail_assertion("non-positive loop bound");
    _jump2471:;
    // Computing bound for F
    _291.d2 = r;
    if (r > 0) 
    goto _jump2472;
    fail_assertion("non-positive loop bound");
    _jump2472:;
    // Computing total size of heap memory to allocate
    int64_t _292 = 1;
    _292 *= f;
    _292 *= j;
    _292 *= r;
    _292 *= sizeof(double);
    _291.data = jpl_alloc(_292);
    int64_t _293 = 0; // F
    int64_t _294 = 0; // E
    int64_t _295 = 0; // D
    _jump2473:; // Begin body of loop
    double _296;
    // Computing bound for G
    int64_t _297;
    // Computing bound for G
    if (x > 0) 
    goto _jump2474;
    fail_assertion("non-positive loop bound");
    _jump2474:;
    _297 = 0;
    int64_t _298 = 0; // G
    _jump2475:; // Begin body of loop
    _297 += _293;
    _298++;
    if (_298 < x)
    goto _jump2475;
    // End body of loop
    if (_297 > 0) 
    goto _jump2476;
    fail_assertion("non-positive loop bound");
    _jump2476:;
    // Computing bound for H
    if (v > 0) 
    goto _jump2477;
    fail_assertion("non-positive loop bound");
    _jump2477:;
    // Computing bound for I
    if (x > 0) 
    goto _jump2478;
    fail_assertion("non-positive loop bound");
    _jump2478:;
    _296 = 0;
    int64_t _299 = 0; // I
    int64_t _300 = 0; // H
    int64_t _301 = 0; // G
    _jump2479:; // Begin body of loop
    double _302 = 29.0;
    _296 += _302;
    _299++;
    if (_299 < x)
    goto _jump2479;
    _299 = 0;
    _300++;
    if (_300 < v)
    goto _jump2479;
    _300 = 0;
    _301++;
    if (_301 < _297)
    goto _jump2479;
    // End body of loop
    double _303 = -_296;
    int64_t _304 = 0;
    _304 *= _291.d0;
    _304 += _295;
    _304 *= _291.d1;
    _304 += _294;
    _304 *= _291.d2;
    _304 += _293;
    _291.data[_304] = _303;
    _293++;
    if (_293 < r)
    goto _jump2473;
    _293 = 0;
    _294++;
    if (_294 < j)
    goto _jump2473;
    _294 = 0;
    _295++;
    if (_295 < f)
    goto _jump2473;
    // End body of loop
    _290 = _291;
    goto _jump2480;
    _jump2469:;
    _a3__a3_double _305;
    // Computing bound for D
    _305.d0 = r;
    if (r > 0) 
    goto _jump2481;
    fail_assertion("non-positive loop bound");
    _jump2481:;
    // Computing bound for E
    _305.d1 = v;
    if (v > 0) 
    goto _jump2482;
    fail_assertion("non-positive loop bound");
    _jump2482:;
    // Computing bound for F
    _305.d2 = r;
    if (r > 0) 
    goto _jump2483;
    fail_assertion("non-positive loop bound");
    _jump2483:;
    // Computing total size of heap memory to allocate
    int64_t _306 = 1;
    _306 *= r;
    _306 *= v;
    _306 *= r;
    _306 *= sizeof(_a3_double);
    _305.data = jpl_alloc(_306);
    int64_t _307 = 0; // F
    int64_t _308 = 0; // E
    int64_t _309 = 0; // D
    _jump2484:; // Begin body of loop
    bool _310 = true;
    _a3_double _311;
    if (!_310)
    goto _jump2485;
    _a3_double _312;
    // Computing bound for G
    _312.d0 = _309;
    if (_309 > 0) 
    goto _jump2486;
    fail_assertion("non-positive loop bound");
    _jump2486:;
    // Computing bound for H
    _312.d1 = g;
    if (g > 0) 
    goto _jump2487;
    fail_assertion("non-positive loop bound");
    _jump2487:;
    // Computing bound for I
    _312.d2 = j;
    if (j > 0) 
    goto _jump2488;
    fail_assertion("non-positive loop bound");
    _jump2488:;
    // Computing total size of heap memory to allocate
    int64_t _313 = 1;
    _313 *= _309;
    _313 *= g;
    _313 *= j;
    _313 *= sizeof(double);
    _312.data = jpl_alloc(_313);
    int64_t _314 = 0; // I
    int64_t _315 = 0; // H
    int64_t _316 = 0; // G
    _jump2489:; // Begin body of loop
    double _317 = 69.0;
    int64_t _318 = 0;
    _318 *= _312.d0;
    _318 += _316;
    _318 *= _312.d1;
    _318 += _315;
    _318 *= _312.d2;
    _318 += _314;
    _312.data[_318] = _317;
    _314++;
    if (_314 < j)
    goto _jump2489;
    _314 = 0;
    _315++;
    if (_315 < g)
    goto _jump2489;
    _315 = 0;
    _316++;
    if (_316 < _309)
    goto _jump2489;
    // End body of loop
    _311 = _312;
    goto _jump2490;
    _jump2485:;
    _a3_double _319;
    // Computing bound for G
    _319.d0 = r;
    if (r > 0) 
    goto _jump2491;
    fail_assertion("non-positive loop bound");
    _jump2491:;
    // Computing bound for H
    int64_t _320 = 907;
    _319.d1 = _320;
    if (_320 > 0) 
    goto _jump2492;
    fail_assertion("non-positive loop bound");
    _jump2492:;
    // Computing bound for I
    _319.d2 = z.d0;
    if (z.d0 > 0) 
    goto _jump2493;
    fail_assertion("non-positive loop bound");
    _jump2493:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= r;
    _321 *= _320;
    _321 *= z.d0;
    _321 *= sizeof(double);
    _319.data = jpl_alloc(_321);
    int64_t _322 = 0; // I
    int64_t _323 = 0; // H
    int64_t _324 = 0; // G
    _jump2494:; // Begin body of loop
    int64_t _325 = 0;
    _325 *= _319.d0;
    _325 += _324;
    _325 *= _319.d1;
    _325 += _323;
    _325 *= _319.d2;
    _325 += _322;
    _319.data[_325] = _154;
    _322++;
    if (_322 < z.d0)
    goto _jump2494;
    _322 = 0;
    _323++;
    if (_323 < _320)
    goto _jump2494;
    _323 = 0;
    _324++;
    if (_324 < r)
    goto _jump2494;
    // End body of loop
    _311 = _319;
    _jump2490:;
    int64_t _326 = 0;
    _326 *= _305.d0;
    _326 += _309;
    _326 *= _305.d1;
    _326 += _308;
    _326 *= _305.d2;
    _326 += _307;
    _305.data[_326] = _311;
    _307++;
    if (_307 < r)
    goto _jump2484;
    _307 = 0;
    _308++;
    if (_308 < v)
    goto _jump2484;
    _308 = 0;
    _309++;
    if (_309 < r)
    goto _jump2484;
    // End body of loop
    _a1__a2_bool _327;
    // Computing bound for D
    int64_t _328 = 720;
    _327.d0 = _328;
    if (_328 > 0) 
    goto _jump2495;
    fail_assertion("non-positive loop bound");
    _jump2495:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _328;
    _329 *= sizeof(_a2_bool);
    _327.data = jpl_alloc(_329);
    int64_t _330 = 0; // D
    _jump2496:; // Begin body of loop
    int64_t _331 = 0;
    _331 *= _327.d0;
    _331 += _330;
    _327.data[_331] = z;
    _330++;
    if (_330 < _328)
    goto _jump2496;
    // End body of loop
    int64_t _332 = 242;
    if (_332 >= 0)
    goto _jump2497;
    fail_assertion("negative array index");
    _jump2497:;
    if (_332 < _327.d0)
    goto _jump2498;
    fail_assertion("index too large");
    _jump2498:;
    int64_t _333 = 0;
    _333 *= _327.d0;
    _333 += _332;
    _a2_bool _334 = _327.data[_333];
    _a1_bool _335;
    // Computing bound for D
    _335.d0 = f;
    if (f > 0) 
    goto _jump2499;
    fail_assertion("non-positive loop bound");
    _jump2499:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= f;
    _336 *= sizeof(bool);
    _335.data = jpl_alloc(_336);
    int64_t _337 = 0; // D
    _jump2500:; // Begin body of loop
    bool _338 = true;
    int64_t _339 = 0;
    _339 *= _335.d0;
    _339 += _337;
    _335.data[_339] = _338;
    _337++;
    if (_337 < f)
    goto _jump2500;
    // End body of loop
    _a1_bool _340;
    // Computing bound for D
    int64_t _341 = 528;
    _340.d0 = _341;
    if (_341 > 0) 
    goto _jump2501;
    fail_assertion("non-positive loop bound");
    _jump2501:;
    // Computing total size of heap memory to allocate
    int64_t _342 = 1;
    _342 *= _341;
    _342 *= sizeof(bool);
    _340.data = jpl_alloc(_342);
    int64_t _343 = 0; // D
    _jump2502:; // Begin body of loop
    bool _344 = true;
    int64_t _345 = 0;
    _345 *= _340.d0;
    _345 += _343;
    _340.data[_345] = _344;
    _343++;
    if (_343 < _341)
    goto _jump2502;
    // End body of loop
    void_t _346 = b(_335, _340);
    int64_t _347 = a(_334, _346);
    if (q >= 0)
    goto _jump2503;
    fail_assertion("negative array index");
    _jump2503:;
    if (q < _305.d0)
    goto _jump2504;
    fail_assertion("index too large");
    _jump2504:;
    if (_347 >= 0)
    goto _jump2505;
    fail_assertion("negative array index");
    _jump2505:;
    if (_347 < _305.d1)
    goto _jump2506;
    fail_assertion("index too large");
    _jump2506:;
    if (g >= 0)
    goto _jump2507;
    fail_assertion("negative array index");
    _jump2507:;
    if (g < _305.d2)
    goto _jump2508;
    fail_assertion("index too large");
    _jump2508:;
    int64_t _348 = 0;
    _348 *= _305.d0;
    _348 += q;
    _348 *= _305.d1;
    _348 += _347;
    _348 *= _305.d2;
    _348 += g;
    _a3_double _349 = _305.data[_348];
    _290 = _349;
    _jump2480:;
    _260 = _290;
    goto _jump2509;
    _jump2452:;
    _a3_double _350;
    // Computing bound for D
    _350.d0 = k;
    if (k > 0) 
    goto _jump2510;
    fail_assertion("non-positive loop bound");
    _jump2510:;
    // Computing bound for E
    _350.d1 = v;
    if (v > 0) 
    goto _jump2511;
    fail_assertion("non-positive loop bound");
    _jump2511:;
    // Computing bound for F
    _350.d2 = h;
    if (h > 0) 
    goto _jump2512;
    fail_assertion("non-positive loop bound");
    _jump2512:;
    // Computing total size of heap memory to allocate
    int64_t _351 = 1;
    _351 *= k;
    _351 *= v;
    _351 *= h;
    _351 *= sizeof(double);
    _350.data = jpl_alloc(_351);
    int64_t _352 = 0; // F
    int64_t _353 = 0; // E
    int64_t _354 = 0; // D
    _jump2513:; // Begin body of loop
    bool _355 = true;
    double _356;
    if (!_355)
    goto _jump2514;
    double _357;
    // Computing bound for G
    if (j > 0) 
    goto _jump2515;
    fail_assertion("non-positive loop bound");
    _jump2515:;
    // Computing bound for H
    if (_352 > 0) 
    goto _jump2516;
    fail_assertion("non-positive loop bound");
    _jump2516:;
    _357 = 0;
    int64_t _358 = 0; // H
    int64_t _359 = 0; // G
    _jump2517:; // Begin body of loop
    double _360 = 54.0;
    _357 += _360;
    _358++;
    if (_358 < _352)
    goto _jump2517;
    _358 = 0;
    _359++;
    if (_359 < j)
    goto _jump2517;
    // End body of loop
    _356 = _357;
    goto _jump2518;
    _jump2514:;
    double _361 = 58.0;
    _356 = _361;
    _jump2518:;
    int64_t _362 = 0;
    _362 *= _350.d0;
    _362 += _354;
    _362 *= _350.d1;
    _362 += _353;
    _362 *= _350.d2;
    _362 += _352;
    _350.data[_362] = _356;
    _352++;
    if (_352 < h)
    goto _jump2513;
    _352 = 0;
    _353++;
    if (_353 < v)
    goto _jump2513;
    _353 = 0;
    _354++;
    if (_354 < k)
    goto _jump2513;
    // End body of loop
    bool _363 = n(_350);
    _a3_double _364;
    if (!_363)
    goto _jump2519;
    _a3_double _365;
    // Computing bound for D
    _365.d0 = j;
    if (j > 0) 
    goto _jump2520;
    fail_assertion("non-positive loop bound");
    _jump2520:;
    // Computing bound for E
    _365.d1 = v;
    if (v > 0) 
    goto _jump2521;
    fail_assertion("non-positive loop bound");
    _jump2521:;
    // Computing bound for F
    _365.d2 = j;
    if (j > 0) 
    goto _jump2522;
    fail_assertion("non-positive loop bound");
    _jump2522:;
    // Computing total size of heap memory to allocate
    int64_t _366 = 1;
    _366 *= j;
    _366 *= v;
    _366 *= j;
    _366 *= sizeof(double);
    _365.data = jpl_alloc(_366);
    int64_t _367 = 0; // F
    int64_t _368 = 0; // E
    int64_t _369 = 0; // D
    _jump2523:; // Begin body of loop
    double _370 = 26.0;
    double _371 = -_370;
    int64_t _372 = 0;
    _372 *= _365.d0;
    _372 += _369;
    _372 *= _365.d1;
    _372 += _368;
    _372 *= _365.d2;
    _372 += _367;
    _365.data[_372] = _371;
    _367++;
    if (_367 < j)
    goto _jump2523;
    _367 = 0;
    _368++;
    if (_368 < v)
    goto _jump2523;
    _368 = 0;
    _369++;
    if (_369 < j)
    goto _jump2523;
    // End body of loop
    _364 = _365;
    goto _jump2524;
    _jump2519:;
    bool _373 = false;
    double _374;
    // Computing bound for D
    if (q > 0) 
    goto _jump2525;
    fail_assertion("non-positive loop bound");
    _jump2525:;
    // Computing bound for E
    if (u > 0) 
    goto _jump2526;
    fail_assertion("non-positive loop bound");
    _jump2526:;
    _374 = 0;
    int64_t _375 = 0; // E
    int64_t _376 = 0; // D
    _jump2527:; // Begin body of loop
    double _377 = 75.0;
    _374 += _377;
    _375++;
    if (_375 < u)
    goto _jump2527;
    _375 = 0;
    _376++;
    if (_376 < q)
    goto _jump2527;
    // End body of loop
    bool _378 = _374 >= _154;
    bool _379 = _373 == _378;
    _a3_double _380;
    if (!_379)
    goto _jump2528;
    bool _381 = true;
    _a3_double _382;
    if (!_381)
    goto _jump2529;
    _a3_double _383;
    // Computing bound for D
    int64_t _384 = z.d1 / q;
    _383.d0 = _384;
    if (_384 > 0) 
    goto _jump2530;
    fail_assertion("non-positive loop bound");
    _jump2530:;
    // Computing bound for E
    _383.d1 = q;
    if (q > 0) 
    goto _jump2531;
    fail_assertion("non-positive loop bound");
    _jump2531:;
    // Computing bound for F
    _383.d2 = q;
    if (q > 0) 
    goto _jump2532;
    fail_assertion("non-positive loop bound");
    _jump2532:;
    // Computing total size of heap memory to allocate
    int64_t _385 = 1;
    _385 *= _384;
    _385 *= q;
    _385 *= q;
    _385 *= sizeof(double);
    _383.data = jpl_alloc(_385);
    int64_t _386 = 0; // F
    int64_t _387 = 0; // E
    int64_t _388 = 0; // D
    _jump2533:; // Begin body of loop
    double _389;
    // Computing bound for G
    if (_386 > 0) 
    goto _jump2534;
    fail_assertion("non-positive loop bound");
    _jump2534:;
    // Computing bound for H
    if (q > 0) 
    goto _jump2535;
    fail_assertion("non-positive loop bound");
    _jump2535:;
    // Computing bound for I
    int64_t _390 = 339;
    if (_390 > 0) 
    goto _jump2536;
    fail_assertion("non-positive loop bound");
    _jump2536:;
    _389 = 0;
    int64_t _391 = 0; // I
    int64_t _392 = 0; // H
    int64_t _393 = 0; // G
    _jump2537:; // Begin body of loop
    double _394 = 91.0;
    _389 += _394;
    _391++;
    if (_391 < _390)
    goto _jump2537;
    _391 = 0;
    _392++;
    if (_392 < q)
    goto _jump2537;
    _392 = 0;
    _393++;
    if (_393 < _386)
    goto _jump2537;
    // End body of loop
    int64_t _395 = 0;
    _395 *= _383.d0;
    _395 += _388;
    _395 *= _383.d1;
    _395 += _387;
    _395 *= _383.d2;
    _395 += _386;
    _383.data[_395] = _389;
    _386++;
    if (_386 < q)
    goto _jump2533;
    _386 = 0;
    _387++;
    if (_387 < q)
    goto _jump2533;
    _387 = 0;
    _388++;
    if (_388 < _384)
    goto _jump2533;
    // End body of loop
    _382 = _383;
    goto _jump2538;
    _jump2529:;
    _a3_double _396;
    // Computing bound for D
    _396.d0 = f;
    if (f > 0) 
    goto _jump2539;
    fail_assertion("non-positive loop bound");
    _jump2539:;
    // Computing bound for E
    _396.d1 = g;
    if (g > 0) 
    goto _jump2540;
    fail_assertion("non-positive loop bound");
    _jump2540:;
    // Computing bound for F
    _396.d2 = k;
    if (k > 0) 
    goto _jump2541;
    fail_assertion("non-positive loop bound");
    _jump2541:;
    // Computing total size of heap memory to allocate
    int64_t _397 = 1;
    _397 *= f;
    _397 *= g;
    _397 *= k;
    _397 *= sizeof(double);
    _396.data = jpl_alloc(_397);
    int64_t _398 = 0; // F
    int64_t _399 = 0; // E
    int64_t _400 = 0; // D
    _jump2542:; // Begin body of loop
    double _401 = 15.0;
    int64_t _402 = 0;
    _402 *= _396.d0;
    _402 += _400;
    _402 *= _396.d1;
    _402 += _399;
    _402 *= _396.d2;
    _402 += _398;
    _396.data[_402] = _401;
    _398++;
    if (_398 < k)
    goto _jump2542;
    _398 = 0;
    _399++;
    if (_399 < g)
    goto _jump2542;
    _399 = 0;
    _400++;
    if (_400 < f)
    goto _jump2542;
    // End body of loop
    _382 = _396;
    _jump2538:;
    _380 = _382;
    goto _jump2543;
    _jump2528:;
    _a2__a3_double _403;
    // Computing bound for D
    _403.d0 = g;
    if (g > 0) 
    goto _jump2544;
    fail_assertion("non-positive loop bound");
    _jump2544:;
    // Computing bound for E
    _403.d1 = h;
    if (h > 0) 
    goto _jump2545;
    fail_assertion("non-positive loop bound");
    _jump2545:;
    // Computing total size of heap memory to allocate
    int64_t _404 = 1;
    _404 *= g;
    _404 *= h;
    _404 *= sizeof(_a3_double);
    _403.data = jpl_alloc(_404);
    int64_t _405 = 0; // E
    int64_t _406 = 0; // D
    _jump2546:; // Begin body of loop
    _a3_double _407;
    // Computing bound for F
    _407.d0 = r;
    if (r > 0) 
    goto _jump2547;
    fail_assertion("non-positive loop bound");
    _jump2547:;
    // Computing bound for G
    _407.d1 = _406;
    if (_406 > 0) 
    goto _jump2548;
    fail_assertion("non-positive loop bound");
    _jump2548:;
    // Computing bound for H
    _407.d2 = u;
    if (u > 0) 
    goto _jump2549;
    fail_assertion("non-positive loop bound");
    _jump2549:;
    // Computing total size of heap memory to allocate
    int64_t _408 = 1;
    _408 *= r;
    _408 *= _406;
    _408 *= u;
    _408 *= sizeof(double);
    _407.data = jpl_alloc(_408);
    int64_t _409 = 0; // H
    int64_t _410 = 0; // G
    int64_t _411 = 0; // F
    _jump2550:; // Begin body of loop
    double _412 = 26.0;
    int64_t _413 = 0;
    _413 *= _407.d0;
    _413 += _411;
    _413 *= _407.d1;
    _413 += _410;
    _413 *= _407.d2;
    _413 += _409;
    _407.data[_413] = _412;
    _409++;
    if (_409 < u)
    goto _jump2550;
    _409 = 0;
    _410++;
    if (_410 < _406)
    goto _jump2550;
    _410 = 0;
    _411++;
    if (_411 < r)
    goto _jump2550;
    // End body of loop
    int64_t _414 = 0;
    _414 *= _403.d0;
    _414 += _406;
    _414 *= _403.d1;
    _414 += _405;
    _403.data[_414] = _407;
    _405++;
    if (_405 < h)
    goto _jump2546;
    _405 = 0;
    _406++;
    if (_406 < g)
    goto _jump2546;
    // End body of loop
    if (j >= 0)
    goto _jump2551;
    fail_assertion("negative array index");
    _jump2551:;
    if (j < _403.d0)
    goto _jump2552;
    fail_assertion("index too large");
    _jump2552:;
    if (k >= 0)
    goto _jump2553;
    fail_assertion("negative array index");
    _jump2553:;
    if (k < _403.d1)
    goto _jump2554;
    fail_assertion("index too large");
    _jump2554:;
    int64_t _415 = 0;
    _415 *= _403.d0;
    _415 += j;
    _415 *= _403.d1;
    _415 += k;
    _a3_double _416 = _403.data[_415];
    _380 = _416;
    _jump2543:;
    _364 = _380;
    _jump2524:;
    _260 = _364;
    _jump2509:;
    bool _417 = n(_260);
    if (0 != _417)
    goto _jump2555;
    fail_assertion("D");
    _jump2555:;
    bool _419 = _154 > _154;
    bool _418 = _419;
    if (0 == _419)
    goto _jump2556;
    bool _420 = false;
    bool _421 = !_420;
    _418 = _421;
    _jump2556:;
    bool _422;
    if (!_418)
    goto _jump2557;
    bool _423 = f == g;
    _422 = _423;
    goto _jump2558;
    _jump2557:;
    double _425 = 29.0;
    bool _426 = _154 != _425;
    bool _424 = _426;
    if (0 != _426)
    goto _jump2559;
    bool _427 = true;
    _424 = _427;
    _jump2559:;
    _422 = _424;
    _jump2558:;
    bool _428;
    if (!_422)
    goto _jump2560;
    _a2_bool _429;
    // Computing bound for D
    int64_t _430 = -g;
    _429.d0 = _430;
    if (_430 > 0) 
    goto _jump2561;
    fail_assertion("non-positive loop bound");
    _jump2561:;
    // Computing bound for E
    bool _431 = false;
    int64_t _432;
    if (!_431)
    goto _jump2562;
    _432 = g;
    goto _jump2563;
    _jump2562:;
    int64_t _433 = 828;
    _432 = _433;
    _jump2563:;
    _429.d1 = _432;
    if (_432 > 0) 
    goto _jump2564;
    fail_assertion("non-positive loop bound");
    _jump2564:;
    // Computing total size of heap memory to allocate
    int64_t _434 = 1;
    _434 *= _430;
    _434 *= _432;
    _434 *= sizeof(bool);
    _429.data = jpl_alloc(_434);
    int64_t _435 = 0; // E
    int64_t _436 = 0; // D
    _jump2565:; // Begin body of loop
    bool _437 = z.d0 != g;
    int64_t _438 = 0;
    _438 *= _429.d0;
    _438 += _436;
    _438 *= _429.d1;
    _438 += _435;
    _429.data[_438] = _437;
    _435++;
    if (_435 < _432)
    goto _jump2565;
    _435 = 0;
    _436++;
    if (_436 < _430)
    goto _jump2565;
    // End body of loop
    if (j >= 0)
    goto _jump2566;
    fail_assertion("negative array index");
    _jump2566:;
    if (j < _429.d0)
    goto _jump2567;
    fail_assertion("index too large");
    _jump2567:;
    if (u >= 0)
    goto _jump2568;
    fail_assertion("negative array index");
    _jump2568:;
    if (u < _429.d1)
    goto _jump2569;
    fail_assertion("index too large");
    _jump2569:;
    int64_t _439 = 0;
    _439 *= _429.d0;
    _439 += j;
    _439 *= _429.d1;
    _439 += u;
    bool _440 = _429.data[_439];
    _428 = _440;
    goto _jump2570;
    _jump2560:;
    bool _441 = true;
    _428 = _441;
    _jump2570:;
    bool _442 = !_428;
    _a2__a3_int64_t _443;
    if (!_442)
    goto _jump2571;
    double _444;
    // Computing bound for D
    if (v > 0) 
    goto _jump2572;
    fail_assertion("non-positive loop bound");
    _jump2572:;
    // Computing bound for E
    int64_t _445;
    // Computing bound for D
    int64_t _446 = -z.d0;
    if (_446 > 0) 
    goto _jump2573;
    fail_assertion("non-positive loop bound");
    _jump2573:;
    // Computing bound for E
    if (g > 0) 
    goto _jump2574;
    fail_assertion("non-positive loop bound");
    _jump2574:;
    // Computing bound for F
    int64_t _447 = -u;
    if (_447 > 0) 
    goto _jump2575;
    fail_assertion("non-positive loop bound");
    _jump2575:;
    _445 = 0;
    int64_t _448 = 0; // F
    int64_t _449 = 0; // E
    int64_t _450 = 0; // D
    _jump2576:; // Begin body of loop
    int64_t _451;
    // Computing bound for G
    if (r > 0) 
    goto _jump2577;
    fail_assertion("non-positive loop bound");
    _jump2577:;
    // Computing bound for H
    if (g > 0) 
    goto _jump2578;
    fail_assertion("non-positive loop bound");
    _jump2578:;
    _451 = 0;
    int64_t _452 = 0; // H
    int64_t _453 = 0; // G
    _jump2579:; // Begin body of loop
    _451 += x;
    _452++;
    if (_452 < g)
    goto _jump2579;
    _452 = 0;
    _453++;
    if (_453 < r)
    goto _jump2579;
    // End body of loop
    _445 += _451;
    _448++;
    if (_448 < _447)
    goto _jump2576;
    _448 = 0;
    _449++;
    if (_449 < g)
    goto _jump2576;
    _449 = 0;
    _450++;
    if (_450 < _446)
    goto _jump2576;
    // End body of loop
    if (_445 > 0) 
    goto _jump2580;
    fail_assertion("non-positive loop bound");
    _jump2580:;
    _444 = 0;
    int64_t _454 = 0; // E
    int64_t _455 = 0; // D
    _jump2581:; // Begin body of loop
    _444 += _154;
    _454++;
    if (_454 < _445)
    goto _jump2581;
    _454 = 0;
    _455++;
    if (_455 < v)
    goto _jump2581;
    // End body of loop
    double _456;
    // Computing bound for D
    if (f > 0) 
    goto _jump2582;
    fail_assertion("non-positive loop bound");
    _jump2582:;
    // Computing bound for E
    if (g > 0) 
    goto _jump2583;
    fail_assertion("non-positive loop bound");
    _jump2583:;
    _456 = 0;
    int64_t _457 = 0; // E
    int64_t _458 = 0; // D
    _jump2584:; // Begin body of loop
    _456 += _154;
    _457++;
    if (_457 < g)
    goto _jump2584;
    _457 = 0;
    _458++;
    if (_458 < f)
    goto _jump2584;
    // End body of loop
    bool _459 = _444 >= _456;
    _a2__a3_int64_t _460;
    if (!_459)
    goto _jump2585;
    _a2__a3_int64_t _461;
    // Computing bound for D
    int64_t _462 = 595;
    int64_t _463 = -_462;
    _461.d0 = _463;
    if (_463 > 0) 
    goto _jump2586;
    fail_assertion("non-positive loop bound");
    _jump2586:;
    // Computing bound for E
    _461.d1 = x;
    if (x > 0) 
    goto _jump2587;
    fail_assertion("non-positive loop bound");
    _jump2587:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= _463;
    _464 *= x;
    _464 *= sizeof(_a3_int64_t);
    _461.data = jpl_alloc(_464);
    int64_t _465 = 0; // E
    int64_t _466 = 0; // D
    _jump2588:; // Begin body of loop
    int64_t _467 = 0;
    _467 *= _461.d0;
    _467 += _466;
    _467 *= _461.d1;
    _467 += _465;
    _461.data[_467] = e;
    _465++;
    if (_465 < x)
    goto _jump2588;
    _465 = 0;
    _466++;
    if (_466 < _463)
    goto _jump2588;
    // End body of loop
    _a1__a2__a3_int64_t _468;
    _468.d0 = 1;
    _468.data = jpl_alloc(sizeof(_a2__a3_int64_t) * 1);
    _468.data[0] = _461;
    if (x >= 0)
    goto _jump2589;
    fail_assertion("negative array index");
    _jump2589:;
    if (x < _468.d0)
    goto _jump2590;
    fail_assertion("index too large");
    _jump2590:;
    int64_t _469 = 0;
    _469 *= _468.d0;
    _469 += x;
    _a2__a3_int64_t _470 = _468.data[_469];
    _460 = _470;
    goto _jump2591;
    _jump2585:;
    _a1__a2__a3_int64_t _471;
    // Computing bound for D
    _471.d0 = k;
    if (k > 0) 
    goto _jump2592;
    fail_assertion("non-positive loop bound");
    _jump2592:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= k;
    _472 *= sizeof(_a2__a3_int64_t);
    _471.data = jpl_alloc(_472);
    int64_t _473 = 0; // D
    _jump2593:; // Begin body of loop
    _a2__a3_int64_t _474;
    // Computing bound for E
    _474.d0 = j;
    if (j > 0) 
    goto _jump2594;
    fail_assertion("non-positive loop bound");
    _jump2594:;
    // Computing bound for F
    _474.d1 = v;
    if (v > 0) 
    goto _jump2595;
    fail_assertion("non-positive loop bound");
    _jump2595:;
    // Computing total size of heap memory to allocate
    int64_t _475 = 1;
    _475 *= j;
    _475 *= v;
    _475 *= sizeof(_a3_int64_t);
    _474.data = jpl_alloc(_475);
    int64_t _476 = 0; // F
    int64_t _477 = 0; // E
    _jump2596:; // Begin body of loop
    int64_t _478 = 0;
    _478 *= _474.d0;
    _478 += _477;
    _478 *= _474.d1;
    _478 += _476;
    _474.data[_478] = e;
    _476++;
    if (_476 < v)
    goto _jump2596;
    _476 = 0;
    _477++;
    if (_477 < j)
    goto _jump2596;
    // End body of loop
    int64_t _479 = 0;
    _479 *= _471.d0;
    _479 += _473;
    _471.data[_479] = _474;
    _473++;
    if (_473 < k)
    goto _jump2593;
    // End body of loop
    int64_t _480;
    // Computing bound for D
    _a1_int64_t _481;
    _481.d0 = 3;
    _481.data = jpl_alloc(sizeof(int64_t) * 3);
    _481.data[0] = v;
    _481.data[1] = u;
    _481.data[2] = q;
    if (v >= 0)
    goto _jump2597;
    fail_assertion("negative array index");
    _jump2597:;
    if (v < _481.d0)
    goto _jump2598;
    fail_assertion("index too large");
    _jump2598:;
    int64_t _482 = 0;
    _482 *= _481.d0;
    _482 += v;
    int64_t _483 = _481.data[_482];
    if (_483 > 0) 
    goto _jump2599;
    fail_assertion("non-positive loop bound");
    _jump2599:;
    _480 = 0;
    int64_t _484 = 0; // D
    _jump2600:; // Begin body of loop
    _480 += x;
    _484++;
    if (_484 < _483)
    goto _jump2600;
    // End body of loop
    if (_480 >= 0)
    goto _jump2601;
    fail_assertion("negative array index");
    _jump2601:;
    if (_480 < _471.d0)
    goto _jump2602;
    fail_assertion("index too large");
    _jump2602:;
    int64_t _485 = 0;
    _485 *= _471.d0;
    _485 += _480;
    _a2__a3_int64_t _486 = _471.data[_485];
    _460 = _486;
    _jump2591:;
    _443 = _460;
    goto _jump2603;
    _jump2571:;
    bool _487 = false;
    _a2__a3_int64_t _488;
    if (!_487)
    goto _jump2604;
    _a1__a2__a3_int64_t _489;
    // Computing bound for D
    _489.d0 = g;
    if (g > 0) 
    goto _jump2605;
    fail_assertion("non-positive loop bound");
    _jump2605:;
    // Computing total size of heap memory to allocate
    int64_t _490 = 1;
    _490 *= g;
    _490 *= sizeof(_a2__a3_int64_t);
    _489.data = jpl_alloc(_490);
    int64_t _491 = 0; // D
    _jump2606:; // Begin body of loop
    _a2__a3_int64_t _492;
    // Computing bound for E
    _492.d0 = j;
    if (j > 0) 
    goto _jump2607;
    fail_assertion("non-positive loop bound");
    _jump2607:;
    // Computing bound for F
    int64_t _493;
    // Computing bound for E
    if (_491 > 0) 
    goto _jump2608;
    fail_assertion("non-positive loop bound");
    _jump2608:;
    // Computing bound for F
    if (k > 0) 
    goto _jump2609;
    fail_assertion("non-positive loop bound");
    _jump2609:;
    // Computing bound for G
    if (z.d0 > 0) 
    goto _jump2610;
    fail_assertion("non-positive loop bound");
    _jump2610:;
    _493 = 0;
    int64_t _494 = 0; // G
    int64_t _495 = 0; // F
    int64_t _496 = 0; // E
    _jump2611:; // Begin body of loop
    _493 += k;
    _494++;
    if (_494 < z.d0)
    goto _jump2611;
    _494 = 0;
    _495++;
    if (_495 < k)
    goto _jump2611;
    _495 = 0;
    _496++;
    if (_496 < _491)
    goto _jump2611;
    // End body of loop
    _492.d1 = _493;
    if (_493 > 0) 
    goto _jump2612;
    fail_assertion("non-positive loop bound");
    _jump2612:;
    // Computing total size of heap memory to allocate
    int64_t _497 = 1;
    _497 *= j;
    _497 *= _493;
    _497 *= sizeof(_a3_int64_t);
    _492.data = jpl_alloc(_497);
    int64_t _498 = 0; // F
    int64_t _499 = 0; // E
    _jump2613:; // Begin body of loop
    _a3_int64_t _500;
    // Computing bound for G
    _500.d0 = z.d0;
    if (z.d0 > 0) 
    goto _jump2614;
    fail_assertion("non-positive loop bound");
    _jump2614:;
    // Computing bound for H
    _500.d1 = j;
    if (j > 0) 
    goto _jump2615;
    fail_assertion("non-positive loop bound");
    _jump2615:;
    // Computing bound for I
    _500.d2 = z.d1;
    if (z.d1 > 0) 
    goto _jump2616;
    fail_assertion("non-positive loop bound");
    _jump2616:;
    // Computing total size of heap memory to allocate
    int64_t _501 = 1;
    _501 *= z.d0;
    _501 *= j;
    _501 *= z.d1;
    _501 *= sizeof(int64_t);
    _500.data = jpl_alloc(_501);
    int64_t _502 = 0; // I
    int64_t _503 = 0; // H
    int64_t _504 = 0; // G
    _jump2617:; // Begin body of loop
    int64_t _505 = 0;
    _505 *= _500.d0;
    _505 += _504;
    _505 *= _500.d1;
    _505 += _503;
    _505 *= _500.d2;
    _505 += _502;
    _500.data[_505] = h;
    _502++;
    if (_502 < z.d1)
    goto _jump2617;
    _502 = 0;
    _503++;
    if (_503 < j)
    goto _jump2617;
    _503 = 0;
    _504++;
    if (_504 < z.d0)
    goto _jump2617;
    // End body of loop
    int64_t _506 = 0;
    _506 *= _492.d0;
    _506 += _499;
    _506 *= _492.d1;
    _506 += _498;
    _492.data[_506] = _500;
    _498++;
    if (_498 < _493)
    goto _jump2613;
    _498 = 0;
    _499++;
    if (_499 < j)
    goto _jump2613;
    // End body of loop
    int64_t _507 = 0;
    _507 *= _489.d0;
    _507 += _491;
    _489.data[_507] = _492;
    _491++;
    if (_491 < g)
    goto _jump2606;
    // End body of loop
    if (j >= 0)
    goto _jump2618;
    fail_assertion("negative array index");
    _jump2618:;
    if (j < _489.d0)
    goto _jump2619;
    fail_assertion("index too large");
    _jump2619:;
    int64_t _508 = 0;
    _508 *= _489.d0;
    _508 += j;
    _a2__a3_int64_t _509 = _489.data[_508];
    _488 = _509;
    goto _jump2620;
    _jump2604:;
    _a2__a2__a3_int64_t _510;
    // Computing bound for D
    _510.d0 = r;
    if (r > 0) 
    goto _jump2621;
    fail_assertion("non-positive loop bound");
    _jump2621:;
    // Computing bound for E
    _510.d1 = h;
    if (h > 0) 
    goto _jump2622;
    fail_assertion("non-positive loop bound");
    _jump2622:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= r;
    _511 *= h;
    _511 *= sizeof(_a2__a3_int64_t);
    _510.data = jpl_alloc(_511);
    int64_t _512 = 0; // E
    int64_t _513 = 0; // D
    _jump2623:; // Begin body of loop
    _a2__a3_int64_t _514;
    // Computing bound for F
    _514.d0 = _512;
    if (_512 > 0) 
    goto _jump2624;
    fail_assertion("non-positive loop bound");
    _jump2624:;
    // Computing bound for G
    int64_t _515 = _512 - r;
    _514.d1 = _515;
    if (_515 > 0) 
    goto _jump2625;
    fail_assertion("non-positive loop bound");
    _jump2625:;
    // Computing total size of heap memory to allocate
    int64_t _516 = 1;
    _516 *= _512;
    _516 *= _515;
    _516 *= sizeof(_a3_int64_t);
    _514.data = jpl_alloc(_516);
    int64_t _517 = 0; // G
    int64_t _518 = 0; // F
    _jump2626:; // Begin body of loop
    _a3_int64_t _519;
    // Computing bound for H
    _519.d0 = v;
    if (v > 0) 
    goto _jump2627;
    fail_assertion("non-positive loop bound");
    _jump2627:;
    // Computing bound for I
    _519.d1 = x;
    if (x > 0) 
    goto _jump2628;
    fail_assertion("non-positive loop bound");
    _jump2628:;
    // Computing bound for J
    _519.d2 = _513;
    if (_513 > 0) 
    goto _jump2629;
    fail_assertion("non-positive loop bound");
    _jump2629:;
    // Computing total size of heap memory to allocate
    int64_t _520 = 1;
    _520 *= v;
    _520 *= x;
    _520 *= _513;
    _520 *= sizeof(int64_t);
    _519.data = jpl_alloc(_520);
    int64_t _521 = 0; // J
    int64_t _522 = 0; // I
    int64_t _523 = 0; // H
    _jump2630:; // Begin body of loop
    int64_t _524 = 0;
    _524 *= _519.d0;
    _524 += _523;
    _524 *= _519.d1;
    _524 += _522;
    _524 *= _519.d2;
    _524 += _521;
    _519.data[_524] = _518;
    _521++;
    if (_521 < _513)
    goto _jump2630;
    _521 = 0;
    _522++;
    if (_522 < x)
    goto _jump2630;
    _522 = 0;
    _523++;
    if (_523 < v)
    goto _jump2630;
    // End body of loop
    int64_t _525 = 0;
    _525 *= _514.d0;
    _525 += _518;
    _525 *= _514.d1;
    _525 += _517;
    _514.data[_525] = _519;
    _517++;
    if (_517 < _515)
    goto _jump2626;
    _517 = 0;
    _518++;
    if (_518 < _512)
    goto _jump2626;
    // End body of loop
    int64_t _526 = 0;
    _526 *= _510.d0;
    _526 += _513;
    _526 *= _510.d1;
    _526 += _512;
    _510.data[_526] = _514;
    _512++;
    if (_512 < h)
    goto _jump2623;
    _512 = 0;
    _513++;
    if (_513 < r)
    goto _jump2623;
    // End body of loop
    int64_t _527 = -h;
    if (g >= 0)
    goto _jump2631;
    fail_assertion("negative array index");
    _jump2631:;
    if (g < _510.d0)
    goto _jump2632;
    fail_assertion("index too large");
    _jump2632:;
    if (_527 >= 0)
    goto _jump2633;
    fail_assertion("negative array index");
    _jump2633:;
    if (_527 < _510.d1)
    goto _jump2634;
    fail_assertion("index too large");
    _jump2634:;
    int64_t _528 = 0;
    _528 *= _510.d0;
    _528 += g;
    _528 *= _510.d1;
    _528 += _527;
    _a2__a3_int64_t _529 = _510.data[_528];
    _488 = _529;
    _jump2620:;
    _443 = _488;
    _jump2603:;
    if (f >= 0)
    goto _jump2635;
    fail_assertion("negative array index");
    _jump2635:;
    if (f < _443.d0)
    goto _jump2636;
    fail_assertion("index too large");
    _jump2636:;
    if (v >= 0)
    goto _jump2637;
    fail_assertion("negative array index");
    _jump2637:;
    if (v < _443.d1)
    goto _jump2638;
    fail_assertion("index too large");
    _jump2638:;
    int64_t _530 = 0;
    _530 *= _443.d0;
    _530 += f;
    _530 *= _443.d1;
    _530 += v;
    _a3_int64_t _531 = _443.data[_530];
    double _532 = 32.0;
    bool _533 = _532 <= _154;
    if (0 != _533)
    goto _jump2639;
    fail_assertion("H");
    _jump2639:;
    _a1__a2__a2_int64_t _534;
    // Computing bound for H
    int64_t _535 = -x;
    _534.d0 = _535;
    if (_535 > 0) 
    goto _jump2640;
    fail_assertion("non-positive loop bound");
    _jump2640:;
    // Computing total size of heap memory to allocate
    int64_t _536 = 1;
    _536 *= _535;
    _536 *= sizeof(_a2__a2_int64_t);
    _534.data = jpl_alloc(_536);
    int64_t _537 = 0; // H
    _jump2641:; // Begin body of loop
    double _538 = -_154;
    bool _539 = _538 < _154;
    bool _541 = false;
    bool _542 = true;
    bool _543 = _541 != _542;
    bool _540 = _543;
    if (0 == _543)
    goto _jump2642;
    bool _544 = true;
    _540 = _544;
    _jump2642:;
    bool _545 = _539 == _540;
    _a2__a2_int64_t _546;
    if (!_545)
    goto _jump2643;
    _a2__a2__a2_int64_t _547;
    // Computing bound for I
    _547.d0 = j;
    if (j > 0) 
    goto _jump2644;
    fail_assertion("non-positive loop bound");
    _jump2644:;
    // Computing bound for J
    _547.d1 = u;
    if (u > 0) 
    goto _jump2645;
    fail_assertion("non-positive loop bound");
    _jump2645:;
    // Computing total size of heap memory to allocate
    int64_t _548 = 1;
    _548 *= j;
    _548 *= u;
    _548 *= sizeof(_a2__a2_int64_t);
    _547.data = jpl_alloc(_548);
    int64_t _549 = 0; // J
    int64_t _550 = 0; // I
    _jump2646:; // Begin body of loop
    _a2__a2_int64_t _551;
    // Computing bound for K
    _551.d0 = _531.d1;
    if (_531.d1 > 0) 
    goto _jump2647;
    fail_assertion("non-positive loop bound");
    _jump2647:;
    // Computing bound for L
    _551.d1 = f;
    if (f > 0) 
    goto _jump2648;
    fail_assertion("non-positive loop bound");
    _jump2648:;
    // Computing total size of heap memory to allocate
    int64_t _552 = 1;
    _552 *= _531.d1;
    _552 *= f;
    _552 *= sizeof(_a2_int64_t);
    _551.data = jpl_alloc(_552);
    int64_t _553 = 0; // L
    int64_t _554 = 0; // K
    _jump2649:; // Begin body of loop
    int64_t _555 = 0;
    _555 *= _551.d0;
    _555 += _554;
    _555 *= _551.d1;
    _555 += _553;
    _551.data[_555] = p;
    _553++;
    if (_553 < f)
    goto _jump2649;
    _553 = 0;
    _554++;
    if (_554 < _531.d1)
    goto _jump2649;
    // End body of loop
    int64_t _556 = 0;
    _556 *= _547.d0;
    _556 += _550;
    _556 *= _547.d1;
    _556 += _549;
    _547.data[_556] = _551;
    _549++;
    if (_549 < u)
    goto _jump2646;
    _549 = 0;
    _550++;
    if (_550 < j)
    goto _jump2646;
    // End body of loop
    int64_t _557 = -g;
    if (_557 >= 0)
    goto _jump2650;
    fail_assertion("negative array index");
    _jump2650:;
    if (_557 < _547.d0)
    goto _jump2651;
    fail_assertion("index too large");
    _jump2651:;
    if (j >= 0)
    goto _jump2652;
    fail_assertion("negative array index");
    _jump2652:;
    if (j < _547.d1)
    goto _jump2653;
    fail_assertion("index too large");
    _jump2653:;
    int64_t _558 = 0;
    _558 *= _547.d0;
    _558 += _557;
    _558 *= _547.d1;
    _558 += j;
    _a2__a2_int64_t _559 = _547.data[_558];
    _546 = _559;
    goto _jump2654;
    _jump2643:;
    _a2__a2_int64_t _560;
    // Computing bound for I
    _560.d0 = _531.d2;
    if (_531.d2 > 0) 
    goto _jump2655;
    fail_assertion("non-positive loop bound");
    _jump2655:;
    // Computing bound for J
    int64_t _561;
    // Computing bound for I
    int64_t _562 = u * q;
    if (_562 > 0) 
    goto _jump2656;
    fail_assertion("non-positive loop bound");
    _jump2656:;
    // Computing bound for J
    int64_t _563;
    // Computing bound for I
    if (v > 0) 
    goto _jump2657;
    fail_assertion("non-positive loop bound");
    _jump2657:;
    _563 = 0;
    int64_t _564 = 0; // I
    _jump2658:; // Begin body of loop
    _563 += _564;
    _564++;
    if (_564 < v)
    goto _jump2658;
    // End body of loop
    if (_563 > 0) 
    goto _jump2659;
    fail_assertion("non-positive loop bound");
    _jump2659:;
    // Computing bound for K
    int64_t _565 = z.d1 - g;
    if (_565 > 0) 
    goto _jump2660;
    fail_assertion("non-positive loop bound");
    _jump2660:;
    _561 = 0;
    int64_t _566 = 0; // K
    int64_t _567 = 0; // J
    int64_t _568 = 0; // I
    _jump2661:; // Begin body of loop
    _561 += h;
    _566++;
    if (_566 < _565)
    goto _jump2661;
    _566 = 0;
    _567++;
    if (_567 < _563)
    goto _jump2661;
    _567 = 0;
    _568++;
    if (_568 < _562)
    goto _jump2661;
    // End body of loop
    _560.d1 = _561;
    if (_561 > 0) 
    goto _jump2662;
    fail_assertion("non-positive loop bound");
    _jump2662:;
    // Computing total size of heap memory to allocate
    int64_t _569 = 1;
    _569 *= _531.d2;
    _569 *= _561;
    _569 *= sizeof(_a2_int64_t);
    _560.data = jpl_alloc(_569);
    int64_t _570 = 0; // J
    int64_t _571 = 0; // I
    _jump2663:; // Begin body of loop
    _a2__a2_int64_t _572;
    // Computing bound for K
    _572.d0 = q;
    if (q > 0) 
    goto _jump2664;
    fail_assertion("non-positive loop bound");
    _jump2664:;
    // Computing bound for L
    _572.d1 = _571;
    if (_571 > 0) 
    goto _jump2665;
    fail_assertion("non-positive loop bound");
    _jump2665:;
    // Computing total size of heap memory to allocate
    int64_t _573 = 1;
    _573 *= q;
    _573 *= _571;
    _573 *= sizeof(_a2_int64_t);
    _572.data = jpl_alloc(_573);
    int64_t _574 = 0; // L
    int64_t _575 = 0; // K
    _jump2666:; // Begin body of loop
    int64_t _576 = 0;
    _576 *= _572.d0;
    _576 += _575;
    _576 *= _572.d1;
    _576 += _574;
    _572.data[_576] = t;
    _574++;
    if (_574 < _571)
    goto _jump2666;
    _574 = 0;
    _575++;
    if (_575 < q)
    goto _jump2666;
    // End body of loop
    int64_t _577 = 510;
    int64_t _578 = -_577;
    if (_578 >= 0)
    goto _jump2667;
    fail_assertion("negative array index");
    _jump2667:;
    if (_578 < _572.d0)
    goto _jump2668;
    fail_assertion("index too large");
    _jump2668:;
    if (z.d1 >= 0)
    goto _jump2669;
    fail_assertion("negative array index");
    _jump2669:;
    if (z.d1 < _572.d1)
    goto _jump2670;
    fail_assertion("index too large");
    _jump2670:;
    int64_t _579 = 0;
    _579 *= _572.d0;
    _579 += _578;
    _579 *= _572.d1;
    _579 += z.d1;
    _a2_int64_t _580 = _572.data[_579];
    int64_t _581 = 0;
    _581 *= _560.d0;
    _581 += _571;
    _581 *= _560.d1;
    _581 += _570;
    _560.data[_581] = _580;
    _570++;
    if (_570 < _561)
    goto _jump2663;
    _570 = 0;
    _571++;
    if (_571 < _531.d2)
    goto _jump2663;
    // End body of loop
    _546 = _560;
    _jump2654:;
    int64_t _582 = 0;
    _582 *= _534.d0;
    _582 += _537;
    _534.data[_582] = _546;
    _537++;
    if (_537 < _535)
    goto _jump2641;
    // End body of loop
    if (h >= 0)
    goto _jump2671;
    fail_assertion("negative array index");
    _jump2671:;
    if (h < _534.d0)
    goto _jump2672;
    fail_assertion("index too large");
    _jump2672:;
    int64_t _583 = 0;
    _583 *= _534.d0;
    _583 += h;
    _a2__a2_int64_t _584 = _534.data[_583];
    bool _585 = true;
    _a3_double _586;
    if (!_585)
    goto _jump2673;
    _a3_double _587;
    // Computing bound for H
    _a1_int64_t _588;
    _588.d0 = 3;
    _588.data = jpl_alloc(sizeof(int64_t) * 3);
    _588.data[0] = z.d0;
    _588.data[1] = q;
    _588.data[2] = v;
    int64_t _589 = -_531.d0;
    if (_589 >= 0)
    goto _jump2674;
    fail_assertion("negative array index");
    _jump2674:;
    if (_589 < _588.d0)
    goto _jump2675;
    fail_assertion("index too large");
    _jump2675:;
    int64_t _590 = 0;
    _590 *= _588.d0;
    _590 += _589;
    int64_t _591 = _588.data[_590];
    _587.d0 = _591;
    if (_591 > 0) 
    goto _jump2676;
    fail_assertion("non-positive loop bound");
    _jump2676:;
    // Computing bound for I
    _587.d1 = k;
    if (k > 0) 
    goto _jump2677;
    fail_assertion("non-positive loop bound");
    _jump2677:;
    // Computing bound for J
    _587.d2 = z.d0;
    if (z.d0 > 0) 
    goto _jump2678;
    fail_assertion("non-positive loop bound");
    _jump2678:;
    // Computing total size of heap memory to allocate
    int64_t _592 = 1;
    _592 *= _591;
    _592 *= k;
    _592 *= z.d0;
    _592 *= sizeof(double);
    _587.data = jpl_alloc(_592);
    int64_t _593 = 0; // J
    int64_t _594 = 0; // I
    int64_t _595 = 0; // H
    _jump2679:; // Begin body of loop
    double _596 = 9.0;
    double _597 = _154 / _596;
    int64_t _598 = 0;
    _598 *= _587.d0;
    _598 += _595;
    _598 *= _587.d1;
    _598 += _594;
    _598 *= _587.d2;
    _598 += _593;
    _587.data[_598] = _597;
    _593++;
    if (_593 < z.d0)
    goto _jump2679;
    _593 = 0;
    _594++;
    if (_594 < k)
    goto _jump2679;
    _594 = 0;
    _595++;
    if (_595 < _591)
    goto _jump2679;
    // End body of loop
    _586 = _587;
    goto _jump2680;
    _jump2673:;
    _a3_double _599;
    // Computing bound for H
    int64_t _600 = -j;
    _599.d0 = _600;
    if (_600 > 0) 
    goto _jump2681;
    fail_assertion("non-positive loop bound");
    _jump2681:;
    // Computing bound for I
    _a1_int64_t _601;
    // Computing bound for H
    _601.d0 = _531.d1;
    if (_531.d1 > 0) 
    goto _jump2682;
    fail_assertion("non-positive loop bound");
    _jump2682:;
    // Computing total size of heap memory to allocate
    int64_t _602 = 1;
    _602 *= _531.d1;
    _602 *= sizeof(int64_t);
    _601.data = jpl_alloc(_602);
    int64_t _603 = 0; // H
    _jump2683:; // Begin body of loop
    int64_t _604 = 0;
    _604 *= _601.d0;
    _604 += _603;
    _601.data[_604] = f;
    _603++;
    if (_603 < _531.d1)
    goto _jump2683;
    // End body of loop
    int64_t _605 = 490;
    if (_605 >= 0)
    goto _jump2684;
    fail_assertion("negative array index");
    _jump2684:;
    if (_605 < _601.d0)
    goto _jump2685;
    fail_assertion("index too large");
    _jump2685:;
    int64_t _606 = 0;
    _606 *= _601.d0;
    _606 += _605;
    int64_t _607 = _601.data[_606];
    _599.d1 = _607;
    if (_607 > 0) 
    goto _jump2686;
    fail_assertion("non-positive loop bound");
    _jump2686:;
    // Computing bound for J
    _599.d2 = v;
    if (v > 0) 
    goto _jump2687;
    fail_assertion("non-positive loop bound");
    _jump2687:;
    // Computing total size of heap memory to allocate
    int64_t _608 = 1;
    _608 *= _600;
    _608 *= _607;
    _608 *= v;
    _608 *= sizeof(double);
    _599.data = jpl_alloc(_608);
    int64_t _609 = 0; // J
    int64_t _610 = 0; // I
    int64_t _611 = 0; // H
    _jump2688:; // Begin body of loop
    double _612 = 56.0;
    int64_t _613 = 0;
    _613 *= _599.d0;
    _613 += _611;
    _613 *= _599.d1;
    _613 += _610;
    _613 *= _599.d2;
    _613 += _609;
    _599.data[_613] = _612;
    _609++;
    if (_609 < v)
    goto _jump2688;
    _609 = 0;
    _610++;
    if (_610 < _607)
    goto _jump2688;
    _610 = 0;
    _611++;
    if (_611 < _600)
    goto _jump2688;
    // End body of loop
    _586 = _599;
    _jump2680:;
    bool _614 = n(_586);
    _a3_bool _615;
    if (!_614)
    goto _jump2689;
    double _617 = 82.0;
    double _618;
    // Computing bound for H
    if (r > 0) 
    goto _jump2690;
    fail_assertion("non-positive loop bound");
    _jump2690:;
    // Computing bound for I
    if (_531.d2 > 0) 
    goto _jump2691;
    fail_assertion("non-positive loop bound");
    _jump2691:;
    _618 = 0;
    int64_t _619 = 0; // I
    int64_t _620 = 0; // H
    _jump2692:; // Begin body of loop
    double _621;
    // Computing bound for J
    if (_531.d0 > 0) 
    goto _jump2693;
    fail_assertion("non-positive loop bound");
    _jump2693:;
    _621 = 0;
    int64_t _622 = 0; // J
    _jump2694:; // Begin body of loop
    double _623 = 76.0;
    _621 += _623;
    _622++;
    if (_622 < _531.d0)
    goto _jump2694;
    // End body of loop
    _618 += _621;
    _619++;
    if (_619 < _531.d2)
    goto _jump2692;
    _619 = 0;
    _620++;
    if (_620 < r)
    goto _jump2692;
    // End body of loop
    bool _624 = _617 > _618;
    bool _616 = _624;
    if (0 == _624)
    goto _jump2695;
    _a3_double _625;
    // Computing bound for H
    _625.d0 = g;
    if (g > 0) 
    goto _jump2696;
    fail_assertion("non-positive loop bound");
    _jump2696:;
    // Computing bound for I
    _625.d1 = _531.d0;
    if (_531.d0 > 0) 
    goto _jump2697;
    fail_assertion("non-positive loop bound");
    _jump2697:;
    // Computing bound for J
    _625.d2 = _531.d1;
    if (_531.d1 > 0) 
    goto _jump2698;
    fail_assertion("non-positive loop bound");
    _jump2698:;
    // Computing total size of heap memory to allocate
    int64_t _626 = 1;
    _626 *= g;
    _626 *= _531.d0;
    _626 *= _531.d1;
    _626 *= sizeof(double);
    _625.data = jpl_alloc(_626);
    int64_t _627 = 0; // J
    int64_t _628 = 0; // I
    int64_t _629 = 0; // H
    _jump2699:; // Begin body of loop
    double _630 = 99.0;
    int64_t _631 = 0;
    _631 *= _625.d0;
    _631 += _629;
    _631 *= _625.d1;
    _631 += _628;
    _631 *= _625.d2;
    _631 += _627;
    _625.data[_631] = _630;
    _627++;
    if (_627 < _531.d1)
    goto _jump2699;
    _627 = 0;
    _628++;
    if (_628 < _531.d0)
    goto _jump2699;
    _628 = 0;
    _629++;
    if (_629 < g)
    goto _jump2699;
    // End body of loop
    bool _632 = n(_625);
    bool _633;
    if (!_632)
    goto _jump2700;
    bool _634 = _154 >= _154;
    _633 = _634;
    goto _jump2701;
    _jump2700:;
    bool _635 = true;
    _633 = _635;
    _jump2701:;
    _616 = _633;
    _jump2695:;
    _a3_bool _636;
    if (!_616)
    goto _jump2702;
    int64_t _637 = q * g;
    int64_t _638 = 798;
    if (_637 >= 0)
    goto _jump2703;
    fail_assertion("negative array index");
    _jump2703:;
    if (_637 < z.d0)
    goto _jump2704;
    fail_assertion("index too large");
    _jump2704:;
    if (_638 >= 0)
    goto _jump2705;
    fail_assertion("negative array index");
    _jump2705:;
    if (_638 < z.d1)
    goto _jump2706;
    fail_assertion("index too large");
    _jump2706:;
    int64_t _639 = 0;
    _639 *= z.d0;
    _639 += _637;
    _639 *= z.d1;
    _639 += _638;
    bool _640 = z.data[_639];
    bool _641 = !_640;
    _a3_bool _642;
    if (!_641)
    goto _jump2707;
    bool _644 = false;
    bool _643 = _644;
    if (0 != _644)
    goto _jump2708;
    bool _645 = j == k;
    _643 = _645;
    _jump2708:;
    _a3_bool _646;
    if (!_643)
    goto _jump2709;
    _a3_bool _647;
    // Computing bound for H
    _647.d0 = x;
    if (x > 0) 
    goto _jump2710;
    fail_assertion("non-positive loop bound");
    _jump2710:;
    // Computing bound for I
    _647.d1 = _531.d0;
    if (_531.d0 > 0) 
    goto _jump2711;
    fail_assertion("non-positive loop bound");
    _jump2711:;
    // Computing bound for J
    int64_t _648;
    // Computing bound for H
    if (u > 0) 
    goto _jump2712;
    fail_assertion("non-positive loop bound");
    _jump2712:;
    // Computing bound for I
    if (k > 0) 
    goto _jump2713;
    fail_assertion("non-positive loop bound");
    _jump2713:;
    // Computing bound for J
    if (k > 0) 
    goto _jump2714;
    fail_assertion("non-positive loop bound");
    _jump2714:;
    _648 = 0;
    int64_t _649 = 0; // J
    int64_t _650 = 0; // I
    int64_t _651 = 0; // H
    _jump2715:; // Begin body of loop
    _648 += g;
    _649++;
    if (_649 < k)
    goto _jump2715;
    _649 = 0;
    _650++;
    if (_650 < k)
    goto _jump2715;
    _650 = 0;
    _651++;
    if (_651 < u)
    goto _jump2715;
    // End body of loop
    _647.d2 = _648;
    if (_648 > 0) 
    goto _jump2716;
    fail_assertion("non-positive loop bound");
    _jump2716:;
    // Computing total size of heap memory to allocate
    int64_t _652 = 1;
    _652 *= x;
    _652 *= _531.d0;
    _652 *= _648;
    _652 *= sizeof(bool);
    _647.data = jpl_alloc(_652);
    int64_t _653 = 0; // J
    int64_t _654 = 0; // I
    int64_t _655 = 0; // H
    _jump2717:; // Begin body of loop
    bool _656 = false;
    bool _657 = !_656;
    int64_t _658 = 0;
    _658 *= _647.d0;
    _658 += _655;
    _658 *= _647.d1;
    _658 += _654;
    _658 *= _647.d2;
    _658 += _653;
    _647.data[_658] = _657;
    _653++;
    if (_653 < _648)
    goto _jump2717;
    _653 = 0;
    _654++;
    if (_654 < _531.d0)
    goto _jump2717;
    _654 = 0;
    _655++;
    if (_655 < x)
    goto _jump2717;
    // End body of loop
    _646 = _647;
    goto _jump2718;
    _jump2709:;
    _a3_bool _659;
    // Computing bound for H
    _659.d0 = v;
    if (v > 0) 
    goto _jump2719;
    fail_assertion("non-positive loop bound");
    _jump2719:;
    // Computing bound for I
    _659.d1 = z.d1;
    if (z.d1 > 0) 
    goto _jump2720;
    fail_assertion("non-positive loop bound");
    _jump2720:;
    // Computing bound for J
    _659.d2 = r;
    if (r > 0) 
    goto _jump2721;
    fail_assertion("non-positive loop bound");
    _jump2721:;
    // Computing total size of heap memory to allocate
    int64_t _660 = 1;
    _660 *= v;
    _660 *= z.d1;
    _660 *= r;
    _660 *= sizeof(bool);
    _659.data = jpl_alloc(_660);
    int64_t _661 = 0; // J
    int64_t _662 = 0; // I
    int64_t _663 = 0; // H
    _jump2722:; // Begin body of loop
    bool _664 = false;
    bool _665 = !_664;
    int64_t _666 = 0;
    _666 *= _659.d0;
    _666 += _663;
    _666 *= _659.d1;
    _666 += _662;
    _666 *= _659.d2;
    _666 += _661;
    _659.data[_666] = _665;
    _661++;
    if (_661 < r)
    goto _jump2722;
    _661 = 0;
    _662++;
    if (_662 < z.d1)
    goto _jump2722;
    _662 = 0;
    _663++;
    if (_663 < v)
    goto _jump2722;
    // End body of loop
    _646 = _659;
    _jump2718:;
    _642 = _646;
    goto _jump2723;
    _jump2707:;
    bool _667 = true;
    _a3_bool _668;
    if (!_667)
    goto _jump2724;
    _a3_bool _669;
    // Computing bound for H
    _669.d0 = _531.d2;
    if (_531.d2 > 0) 
    goto _jump2725;
    fail_assertion("non-positive loop bound");
    _jump2725:;
    // Computing bound for I
    _669.d1 = j;
    if (j > 0) 
    goto _jump2726;
    fail_assertion("non-positive loop bound");
    _jump2726:;
    // Computing bound for J
    _669.d2 = f;
    if (f > 0) 
    goto _jump2727;
    fail_assertion("non-positive loop bound");
    _jump2727:;
    // Computing total size of heap memory to allocate
    int64_t _670 = 1;
    _670 *= _531.d2;
    _670 *= j;
    _670 *= f;
    _670 *= sizeof(bool);
    _669.data = jpl_alloc(_670);
    int64_t _671 = 0; // J
    int64_t _672 = 0; // I
    int64_t _673 = 0; // H
    _jump2728:; // Begin body of loop
    bool _674 = z.d1 < k;
    int64_t _675 = 0;
    _675 *= _669.d0;
    _675 += _673;
    _675 *= _669.d1;
    _675 += _672;
    _675 *= _669.d2;
    _675 += _671;
    _669.data[_675] = _674;
    _671++;
    if (_671 < f)
    goto _jump2728;
    _671 = 0;
    _672++;
    if (_672 < j)
    goto _jump2728;
    _672 = 0;
    _673++;
    if (_673 < _531.d2)
    goto _jump2728;
    // End body of loop
    _668 = _669;
    goto _jump2729;
    _jump2724:;
    _a3_bool _676;
    // Computing bound for H
    _676.d0 = _531.d1;
    if (_531.d1 > 0) 
    goto _jump2730;
    fail_assertion("non-positive loop bound");
    _jump2730:;
    // Computing bound for I
    _676.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2731;
    fail_assertion("non-positive loop bound");
    _jump2731:;
    // Computing bound for J
    _676.d2 = _531.d0;
    if (_531.d0 > 0) 
    goto _jump2732;
    fail_assertion("non-positive loop bound");
    _jump2732:;
    // Computing total size of heap memory to allocate
    int64_t _677 = 1;
    _677 *= _531.d1;
    _677 *= z.d0;
    _677 *= _531.d0;
    _677 *= sizeof(bool);
    _676.data = jpl_alloc(_677);
    int64_t _678 = 0; // J
    int64_t _679 = 0; // I
    int64_t _680 = 0; // H
    _jump2733:; // Begin body of loop
    if (v >= 0)
    goto _jump2734;
    fail_assertion("negative array index");
    _jump2734:;
    if (v < z.d0)
    goto _jump2735;
    fail_assertion("index too large");
    _jump2735:;
    if (_678 >= 0)
    goto _jump2736;
    fail_assertion("negative array index");
    _jump2736:;
    if (_678 < z.d1)
    goto _jump2737;
    fail_assertion("index too large");
    _jump2737:;
    int64_t _681 = 0;
    _681 *= z.d0;
    _681 += v;
    _681 *= z.d1;
    _681 += _678;
    bool _682 = z.data[_681];
    int64_t _683 = 0;
    _683 *= _676.d0;
    _683 += _680;
    _683 *= _676.d1;
    _683 += _679;
    _683 *= _676.d2;
    _683 += _678;
    _676.data[_683] = _682;
    _678++;
    if (_678 < _531.d0)
    goto _jump2733;
    _678 = 0;
    _679++;
    if (_679 < z.d0)
    goto _jump2733;
    _679 = 0;
    _680++;
    if (_680 < _531.d1)
    goto _jump2733;
    // End body of loop
    _668 = _676;
    _jump2729:;
    _642 = _668;
    _jump2723:;
    _636 = _642;
    goto _jump2738;
    _jump2702:;
    _a3__a3_bool _684;
    // Computing bound for H
    _684.d0 = x;
    if (x > 0) 
    goto _jump2739;
    fail_assertion("non-positive loop bound");
    _jump2739:;
    // Computing bound for I
    _684.d1 = _531.d0;
    if (_531.d0 > 0) 
    goto _jump2740;
    fail_assertion("non-positive loop bound");
    _jump2740:;
    // Computing bound for J
    _684.d2 = _531.d2;
    if (_531.d2 > 0) 
    goto _jump2741;
    fail_assertion("non-positive loop bound");
    _jump2741:;
    // Computing total size of heap memory to allocate
    int64_t _685 = 1;
    _685 *= x;
    _685 *= _531.d0;
    _685 *= _531.d2;
    _685 *= sizeof(_a3_bool);
    _684.data = jpl_alloc(_685);
    int64_t _686 = 0; // J
    int64_t _687 = 0; // I
    int64_t _688 = 0; // H
    _jump2742:; // Begin body of loop
    _a3_bool _689;
    // Computing bound for K
    _689.d0 = v;
    if (v > 0) 
    goto _jump2743;
    fail_assertion("non-positive loop bound");
    _jump2743:;
    // Computing bound for L
    _689.d1 = q;
    if (q > 0) 
    goto _jump2744;
    fail_assertion("non-positive loop bound");
    _jump2744:;
    // Computing bound for M
    _689.d2 = _688;
    if (_688 > 0) 
    goto _jump2745;
    fail_assertion("non-positive loop bound");
    _jump2745:;
    // Computing total size of heap memory to allocate
    int64_t _690 = 1;
    _690 *= v;
    _690 *= q;
    _690 *= _688;
    _690 *= sizeof(bool);
    _689.data = jpl_alloc(_690);
    int64_t _691 = 0; // M
    int64_t _692 = 0; // L
    int64_t _693 = 0; // K
    _jump2746:; // Begin body of loop
    bool _694 = true;
    bool _695 = !_694;
    int64_t _696 = 0;
    _696 *= _689.d0;
    _696 += _693;
    _696 *= _689.d1;
    _696 += _692;
    _696 *= _689.d2;
    _696 += _691;
    _689.data[_696] = _695;
    _691++;
    if (_691 < _688)
    goto _jump2746;
    _691 = 0;
    _692++;
    if (_692 < q)
    goto _jump2746;
    _692 = 0;
    _693++;
    if (_693 < v)
    goto _jump2746;
    // End body of loop
    int64_t _697 = 0;
    _697 *= _684.d0;
    _697 += _688;
    _697 *= _684.d1;
    _697 += _687;
    _697 *= _684.d2;
    _697 += _686;
    _684.data[_697] = _689;
    _686++;
    if (_686 < _531.d2)
    goto _jump2742;
    _686 = 0;
    _687++;
    if (_687 < _531.d0)
    goto _jump2742;
    _687 = 0;
    _688++;
    if (_688 < x)
    goto _jump2742;
    // End body of loop
    bool _698 = true;
    int64_t _699;
    if (!_698)
    goto _jump2747;
    _699 = q;
    goto _jump2748;
    _jump2747:;
    int64_t _700 = 264;
    _699 = _700;
    _jump2748:;
    if (q >= 0)
    goto _jump2749;
    fail_assertion("negative array index");
    _jump2749:;
    if (q < _684.d0)
    goto _jump2750;
    fail_assertion("index too large");
    _jump2750:;
    if (_699 >= 0)
    goto _jump2751;
    fail_assertion("negative array index");
    _jump2751:;
    if (_699 < _684.d1)
    goto _jump2752;
    fail_assertion("index too large");
    _jump2752:;
    if (z.d0 >= 0)
    goto _jump2753;
    fail_assertion("negative array index");
    _jump2753:;
    if (z.d0 < _684.d2)
    goto _jump2754;
    fail_assertion("index too large");
    _jump2754:;
    int64_t _701 = 0;
    _701 *= _684.d0;
    _701 += q;
    _701 *= _684.d1;
    _701 += _699;
    _701 *= _684.d2;
    _701 += z.d0;
    _a3_bool _702 = _684.data[_701];
    _636 = _702;
    _jump2738:;
    _615 = _636;
    goto _jump2755;
    _jump2689:;
    bool _703 = z.d1 == z.d0;
    _a3_bool _704;
    if (!_703)
    goto _jump2756;
    bool _705 = false;
    _a2__a3_bool _706;
    if (!_705)
    goto _jump2757;
    _a2__a3_bool _707;
    // Computing bound for H
    _707.d0 = r;
    if (r > 0) 
    goto _jump2758;
    fail_assertion("non-positive loop bound");
    _jump2758:;
    // Computing bound for I
    _707.d1 = r;
    if (r > 0) 
    goto _jump2759;
    fail_assertion("non-positive loop bound");
    _jump2759:;
    // Computing total size of heap memory to allocate
    int64_t _708 = 1;
    _708 *= r;
    _708 *= r;
    _708 *= sizeof(_a3_bool);
    _707.data = jpl_alloc(_708);
    int64_t _709 = 0; // I
    int64_t _710 = 0; // H
    _jump2760:; // Begin body of loop
    _a3_bool _711;
    // Computing bound for J
    _711.d0 = v;
    if (v > 0) 
    goto _jump2761;
    fail_assertion("non-positive loop bound");
    _jump2761:;
    // Computing bound for K
    _711.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump2762;
    fail_assertion("non-positive loop bound");
    _jump2762:;
    // Computing bound for L
    _711.d2 = _709;
    if (_709 > 0) 
    goto _jump2763;
    fail_assertion("non-positive loop bound");
    _jump2763:;
    // Computing total size of heap memory to allocate
    int64_t _712 = 1;
    _712 *= v;
    _712 *= z.d0;
    _712 *= _709;
    _712 *= sizeof(bool);
    _711.data = jpl_alloc(_712);
    int64_t _713 = 0; // L
    int64_t _714 = 0; // K
    int64_t _715 = 0; // J
    _jump2764:; // Begin body of loop
    bool _716 = false;
    int64_t _717 = 0;
    _717 *= _711.d0;
    _717 += _715;
    _717 *= _711.d1;
    _717 += _714;
    _717 *= _711.d2;
    _717 += _713;
    _711.data[_717] = _716;
    _713++;
    if (_713 < _709)
    goto _jump2764;
    _713 = 0;
    _714++;
    if (_714 < z.d0)
    goto _jump2764;
    _714 = 0;
    _715++;
    if (_715 < v)
    goto _jump2764;
    // End body of loop
    int64_t _718 = 0;
    _718 *= _707.d0;
    _718 += _710;
    _718 *= _707.d1;
    _718 += _709;
    _707.data[_718] = _711;
    _709++;
    if (_709 < r)
    goto _jump2760;
    _709 = 0;
    _710++;
    if (_710 < r)
    goto _jump2760;
    // End body of loop
    _706 = _707;
    goto _jump2765;
    _jump2757:;
    _a2__a3_bool _719;
    // Computing bound for H
    bool _720 = false;
    int64_t _721;
    if (!_720)
    goto _jump2766;
    _721 = g;
    goto _jump2767;
    _jump2766:;
    _721 = z.d0;
    _jump2767:;
    _719.d0 = _721;
    if (_721 > 0) 
    goto _jump2768;
    fail_assertion("non-positive loop bound");
    _jump2768:;
    // Computing bound for I
    _719.d1 = g;
    if (g > 0) 
    goto _jump2769;
    fail_assertion("non-positive loop bound");
    _jump2769:;
    // Computing total size of heap memory to allocate
    int64_t _722 = 1;
    _722 *= _721;
    _722 *= g;
    _722 *= sizeof(_a3_bool);
    _719.data = jpl_alloc(_722);
    int64_t _723 = 0; // I
    int64_t _724 = 0; // H
    _jump2770:; // Begin body of loop
    _a3_bool _725;
    // Computing bound for J
    _725.d0 = v;
    if (v > 0) 
    goto _jump2771;
    fail_assertion("non-positive loop bound");
    _jump2771:;
    // Computing bound for K
    _725.d1 = _723;
    if (_723 > 0) 
    goto _jump2772;
    fail_assertion("non-positive loop bound");
    _jump2772:;
    // Computing bound for L
    _725.d2 = k;
    if (k > 0) 
    goto _jump2773;
    fail_assertion("non-positive loop bound");
    _jump2773:;
    // Computing total size of heap memory to allocate
    int64_t _726 = 1;
    _726 *= v;
    _726 *= _723;
    _726 *= k;
    _726 *= sizeof(bool);
    _725.data = jpl_alloc(_726);
    int64_t _727 = 0; // L
    int64_t _728 = 0; // K
    int64_t _729 = 0; // J
    _jump2774:; // Begin body of loop
    bool _730 = true;
    int64_t _731 = 0;
    _731 *= _725.d0;
    _731 += _729;
    _731 *= _725.d1;
    _731 += _728;
    _731 *= _725.d2;
    _731 += _727;
    _725.data[_731] = _730;
    _727++;
    if (_727 < k)
    goto _jump2774;
    _727 = 0;
    _728++;
    if (_728 < _723)
    goto _jump2774;
    _728 = 0;
    _729++;
    if (_729 < v)
    goto _jump2774;
    // End body of loop
    int64_t _732 = 0;
    _732 *= _719.d0;
    _732 += _724;
    _732 *= _719.d1;
    _732 += _723;
    _719.data[_732] = _725;
    _723++;
    if (_723 < g)
    goto _jump2770;
    _723 = 0;
    _724++;
    if (_724 < _721)
    goto _jump2770;
    // End body of loop
    _706 = _719;
    _jump2765:;
    if (g >= 0)
    goto _jump2775;
    fail_assertion("negative array index");
    _jump2775:;
    if (g < p.d0)
    goto _jump2776;
    fail_assertion("index too large");
    _jump2776:;
    if (j >= 0)
    goto _jump2777;
    fail_assertion("negative array index");
    _jump2777:;
    if (j < p.d1)
    goto _jump2778;
    fail_assertion("index too large");
    _jump2778:;
    int64_t _733 = 0;
    _733 *= p.d0;
    _733 += g;
    _733 *= p.d1;
    _733 += j;
    int64_t _734 = p.data[_733];
    if (_734 >= 0)
    goto _jump2779;
    fail_assertion("negative array index");
    _jump2779:;
    if (_734 < _706.d0)
    goto _jump2780;
    fail_assertion("index too large");
    _jump2780:;
    if (q >= 0)
    goto _jump2781;
    fail_assertion("negative array index");
    _jump2781:;
    if (q < _706.d1)
    goto _jump2782;
    fail_assertion("index too large");
    _jump2782:;
    int64_t _735 = 0;
    _735 *= _706.d0;
    _735 += _734;
    _735 *= _706.d1;
    _735 += q;
    _a3_bool _736 = _706.data[_735];
    _704 = _736;
    goto _jump2783;
    _jump2756:;
    _a3_bool _737;
    // Computing bound for H
    _737.d0 = u;
    if (u > 0) 
    goto _jump2784;
    fail_assertion("non-positive loop bound");
    _jump2784:;
    // Computing bound for I
    _737.d1 = v;
    if (v > 0) 
    goto _jump2785;
    fail_assertion("non-positive loop bound");
    _jump2785:;
    // Computing bound for J
    _737.d2 = _531.d2;
    if (_531.d2 > 0) 
    goto _jump2786;
    fail_assertion("non-positive loop bound");
    _jump2786:;
    // Computing total size of heap memory to allocate
    int64_t _738 = 1;
    _738 *= u;
    _738 *= v;
    _738 *= _531.d2;
    _738 *= sizeof(bool);
    _737.data = jpl_alloc(_738);
    int64_t _739 = 0; // J
    int64_t _740 = 0; // I
    int64_t _741 = 0; // H
    _jump2787:; // Begin body of loop
    double _742 = 87.0;
    double _743 = -_742;
    double _744 = 45.0;
    bool _745 = _743 == _744;
    bool _746;
    if (!_745)
    goto _jump2788;
    bool _747 = true;
    bool _748 = false;
    bool _749 = _747 != _748;
    _746 = _749;
    goto _jump2789;
    _jump2788:;
    bool _750 = _531.d2 <= r;
    bool _751;
    if (!_750)
    goto _jump2790;
    bool _753 = true;
    bool _752 = _753;
    if (0 != _753)
    goto _jump2791;
    bool _754 = true;
    _752 = _754;
    _jump2791:;
    _751 = _752;
    goto _jump2792;
    _jump2790:;
    bool _755 = true;
    _751 = _755;
    _jump2792:;
    _746 = _751;
    _jump2789:;
    int64_t _756 = 0;
    _756 *= _737.d0;
    _756 += _741;
    _756 *= _737.d1;
    _756 += _740;
    _756 *= _737.d2;
    _756 += _739;
    _737.data[_756] = _746;
    _739++;
    if (_739 < _531.d2)
    goto _jump2787;
    _739 = 0;
    _740++;
    if (_740 < v)
    goto _jump2787;
    _740 = 0;
    _741++;
    if (_741 < u)
    goto _jump2787;
    // End body of loop
    _704 = _737;
    _jump2783:;
    _615 = _704;
    _jump2755:;
    rgba _757 = m(_584, u, _615);
    return _757;
}

void_t z(_a3_double A, _a2_double E, _a2__a3_void_t H) {
    bool _0 = true;
    void_t _1;
    if (!_0)
    goto _jump2793;
    bool _2 = true;
    _a3_bool _3;
    // Computing bound for M
    int64_t _4 = -k;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump2794;
    fail_assertion("non-positive loop bound");
    _jump2794:;
    // Computing bound for N
    _3.d1 = q;
    if (q > 0) 
    goto _jump2795;
    fail_assertion("non-positive loop bound");
    _jump2795:;
    // Computing bound for O
    _3.d2 = u;
    if (u > 0) 
    goto _jump2796;
    fail_assertion("non-positive loop bound");
    _jump2796:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _4;
    _5 *= q;
    _5 *= u;
    _5 *= sizeof(bool);
    _3.data = jpl_alloc(_5);
    int64_t _6 = 0; // O
    int64_t _7 = 0; // N
    int64_t _8 = 0; // M
    _jump2797:; // Begin body of loop
    bool _9 = false;
    int64_t _10 = 0;
    _10 *= _3.d0;
    _10 += _8;
    _10 *= _3.d1;
    _10 += _7;
    _10 *= _3.d2;
    _10 += _6;
    _3.data[_10] = _9;
    _6++;
    if (_6 < u)
    goto _jump2797;
    _6 = 0;
    _7++;
    if (_7 < q)
    goto _jump2797;
    _7 = 0;
    _8++;
    if (_8 < _4)
    goto _jump2797;
    // End body of loop
    if (E.d1 >= 0)
    goto _jump2798;
    fail_assertion("negative array index");
    _jump2798:;
    if (E.d1 < _3.d0)
    goto _jump2799;
    fail_assertion("index too large");
    _jump2799:;
    if (i.d1 >= 0)
    goto _jump2800;
    fail_assertion("negative array index");
    _jump2800:;
    if (i.d1 < _3.d1)
    goto _jump2801;
    fail_assertion("index too large");
    _jump2801:;
    if (k >= 0)
    goto _jump2802;
    fail_assertion("negative array index");
    _jump2802:;
    if (k < _3.d2)
    goto _jump2803;
    fail_assertion("index too large");
    _jump2803:;
    int64_t _11 = 0;
    _11 *= _3.d0;
    _11 += E.d1;
    _11 *= _3.d1;
    _11 += i.d1;
    _11 *= _3.d2;
    _11 += k;
    bool _12 = _3.data[_11];
    _a1_bool _13;
    _13.d0 = 2;
    _13.data = jpl_alloc(sizeof(bool) * 2);
    _13.data[0] = _2;
    _13.data[1] = _12;
    bool _14 = true;
    bool _15 = true;
    bool _16;
    if (!_15)
    goto _jump2804;
    bool _17 = false;
    _16 = _17;
    goto _jump2805;
    _jump2804:;
    bool _18 = false;
    bool _19 = !_18;
    _16 = _19;
    _jump2805:;
    bool _20 = _14 != _16;
    bool _21 = !_20;
    _a1_bool _22;
    if (!_21)
    goto _jump2806;
    _a1_bool _23;
    // Computing bound for M
    _23.d0 = v;
    if (v > 0) 
    goto _jump2807;
    fail_assertion("non-positive loop bound");
    _jump2807:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= v;
    _24 *= sizeof(bool);
    _23.data = jpl_alloc(_24);
    int64_t _25 = 0; // M
    _jump2808:; // Begin body of loop
    bool _27 = false;
    bool _26 = _27;
    if (0 != _27)
    goto _jump2809;
    bool _28 = n(A);
    _26 = _28;
    _jump2809:;
    bool _29;
    if (!_26)
    goto _jump2810;
    bool _30 = n(A);
    _29 = _30;
    goto _jump2811;
    _jump2810:;
    bool _31 = q == E.d0;
    bool _32 = !_31;
    _29 = _32;
    _jump2811:;
    int64_t _33 = 0;
    _33 *= _23.d0;
    _33 += _25;
    _23.data[_33] = _29;
    _25++;
    if (_25 < v)
    goto _jump2808;
    // End body of loop
    _22 = _23;
    goto _jump2812;
    _jump2806:;
    _a3_bool _34;
    // Computing bound for M
    _34.d0 = f;
    if (f > 0) 
    goto _jump2813;
    fail_assertion("non-positive loop bound");
    _jump2813:;
    // Computing bound for N
    _34.d1 = r;
    if (r > 0) 
    goto _jump2814;
    fail_assertion("non-positive loop bound");
    _jump2814:;
    // Computing bound for O
    _34.d2 = E.d1;
    if (E.d1 > 0) 
    goto _jump2815;
    fail_assertion("non-positive loop bound");
    _jump2815:;
    // Computing total size of heap memory to allocate
    int64_t _35 = 1;
    _35 *= f;
    _35 *= r;
    _35 *= E.d1;
    _35 *= sizeof(bool);
    _34.data = jpl_alloc(_35);
    int64_t _36 = 0; // O
    int64_t _37 = 0; // N
    int64_t _38 = 0; // M
    _jump2816:; // Begin body of loop
    bool _39 = E.d0 < r;
    int64_t _40 = 0;
    _40 *= _34.d0;
    _40 += _38;
    _40 *= _34.d1;
    _40 += _37;
    _40 *= _34.d2;
    _40 += _36;
    _34.data[_40] = _39;
    _36++;
    if (_36 < E.d1)
    goto _jump2816;
    _36 = 0;
    _37++;
    if (_37 < r)
    goto _jump2816;
    _37 = 0;
    _38++;
    if (_38 < f)
    goto _jump2816;
    // End body of loop
    int64_t _41;
    // Computing bound for M
    if (k > 0) 
    goto _jump2817;
    fail_assertion("non-positive loop bound");
    _jump2817:;
    // Computing bound for N
    if (A.d2 > 0) 
    goto _jump2818;
    fail_assertion("non-positive loop bound");
    _jump2818:;
    // Computing bound for O
    if (j > 0) 
    goto _jump2819;
    fail_assertion("non-positive loop bound");
    _jump2819:;
    _41 = 0;
    int64_t _42 = 0; // O
    int64_t _43 = 0; // N
    int64_t _44 = 0; // M
    _jump2820:; // Begin body of loop
    int64_t _45;
    // Computing bound for P
    int64_t _46 = 264;
    if (_46 > 0) 
    goto _jump2821;
    fail_assertion("non-positive loop bound");
    _jump2821:;
    // Computing bound for Q
    if (j > 0) 
    goto _jump2822;
    fail_assertion("non-positive loop bound");
    _jump2822:;
    _45 = 0;
    int64_t _47 = 0; // Q
    int64_t _48 = 0; // P
    _jump2823:; // Begin body of loop
    _45 += _47;
    _47++;
    if (_47 < j)
    goto _jump2823;
    _47 = 0;
    _48++;
    if (_48 < _46)
    goto _jump2823;
    // End body of loop
    _41 += _45;
    _42++;
    if (_42 < j)
    goto _jump2820;
    _42 = 0;
    _43++;
    if (_43 < A.d2)
    goto _jump2820;
    _43 = 0;
    _44++;
    if (_44 < k)
    goto _jump2820;
    // End body of loop
    if (_41 >= 0)
    goto _jump2824;
    fail_assertion("negative array index");
    _jump2824:;
    if (_41 < _34.d0)
    goto _jump2825;
    fail_assertion("index too large");
    _jump2825:;
    if (E.d1 >= 0)
    goto _jump2826;
    fail_assertion("negative array index");
    _jump2826:;
    if (E.d1 < _34.d1)
    goto _jump2827;
    fail_assertion("index too large");
    _jump2827:;
    if (A.d2 >= 0)
    goto _jump2828;
    fail_assertion("negative array index");
    _jump2828:;
    if (A.d2 < _34.d2)
    goto _jump2829;
    fail_assertion("index too large");
    _jump2829:;
    int64_t _49 = 0;
    _49 *= _34.d0;
    _49 += _41;
    _49 *= _34.d1;
    _49 += E.d1;
    _49 *= _34.d2;
    _49 += A.d2;
    bool _50 = _34.data[_49];
    _a1_bool _51;
    if (!_50)
    goto _jump2830;
    _a3_bool _52;
    // Computing bound for M
    _52.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump2831;
    fail_assertion("non-positive loop bound");
    _jump2831:;
    // Computing bound for N
    _52.d1 = q;
    if (q > 0) 
    goto _jump2832;
    fail_assertion("non-positive loop bound");
    _jump2832:;
    // Computing bound for O
    _52.d2 = q;
    if (q > 0) 
    goto _jump2833;
    fail_assertion("non-positive loop bound");
    _jump2833:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= i.d1;
    _53 *= q;
    _53 *= q;
    _53 *= sizeof(bool);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // O
    int64_t _55 = 0; // N
    int64_t _56 = 0; // M
    _jump2834:; // Begin body of loop
    bool _57 = false;
    int64_t _58 = 0;
    _58 *= _52.d0;
    _58 += _56;
    _58 *= _52.d1;
    _58 += _55;
    _58 *= _52.d2;
    _58 += _54;
    _52.data[_58] = _57;
    _54++;
    if (_54 < q)
    goto _jump2834;
    _54 = 0;
    _55++;
    if (_55 < q)
    goto _jump2834;
    _55 = 0;
    _56++;
    if (_56 < i.d1)
    goto _jump2834;
    // End body of loop
    int64_t _59 = -A.d2;
    if (g >= 0)
    goto _jump2835;
    fail_assertion("negative array index");
    _jump2835:;
    if (g < _52.d0)
    goto _jump2836;
    fail_assertion("index too large");
    _jump2836:;
    if (h >= 0)
    goto _jump2837;
    fail_assertion("negative array index");
    _jump2837:;
    if (h < _52.d1)
    goto _jump2838;
    fail_assertion("index too large");
    _jump2838:;
    if (_59 >= 0)
    goto _jump2839;
    fail_assertion("negative array index");
    _jump2839:;
    if (_59 < _52.d2)
    goto _jump2840;
    fail_assertion("index too large");
    _jump2840:;
    int64_t _60 = 0;
    _60 *= _52.d0;
    _60 += g;
    _60 *= _52.d1;
    _60 += h;
    _60 *= _52.d2;
    _60 += _59;
    bool _61 = _52.data[_60];
    bool _62 = n(A);
    bool _63 = !_62;
    bool _64 = i.d1 != A.d0;
    _a1_bool _65;
    _65.d0 = 3;
    _65.data = jpl_alloc(sizeof(bool) * 3);
    _65.data[0] = _61;
    _65.data[1] = _63;
    _65.data[2] = _64;
    _51 = _65;
    goto _jump2841;
    _jump2830:;
    bool _66 = n(A);
    _a2_bool _67;
    // Computing bound for M
    _67.d0 = A.d2;
    if (A.d2 > 0) 
    goto _jump2842;
    fail_assertion("non-positive loop bound");
    _jump2842:;
    // Computing bound for N
    _67.d1 = u;
    if (u > 0) 
    goto _jump2843;
    fail_assertion("non-positive loop bound");
    _jump2843:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= A.d2;
    _68 *= u;
    _68 *= sizeof(bool);
    _67.data = jpl_alloc(_68);
    int64_t _69 = 0; // N
    int64_t _70 = 0; // M
    _jump2844:; // Begin body of loop
    bool _71 = false;
    int64_t _72 = 0;
    _72 *= _67.d0;
    _72 += _70;
    _72 *= _67.d1;
    _72 += _69;
    _67.data[_72] = _71;
    _69++;
    if (_69 < u)
    goto _jump2844;
    _69 = 0;
    _70++;
    if (_70 < A.d2)
    goto _jump2844;
    // End body of loop
    int64_t _73 = f * r;
    if (_73 >= 0)
    goto _jump2845;
    fail_assertion("negative array index");
    _jump2845:;
    if (_73 < _67.d0)
    goto _jump2846;
    fail_assertion("index too large");
    _jump2846:;
    if (g >= 0)
    goto _jump2847;
    fail_assertion("negative array index");
    _jump2847:;
    if (g < _67.d1)
    goto _jump2848;
    fail_assertion("index too large");
    _jump2848:;
    int64_t _74 = 0;
    _74 *= _67.d0;
    _74 += _73;
    _74 *= _67.d1;
    _74 += g;
    bool _75 = _67.data[_74];
    _a1_bool _76;
    _76.d0 = 2;
    _76.data = jpl_alloc(sizeof(bool) * 2);
    _76.data[0] = _66;
    _76.data[1] = _75;
    _51 = _76;
    _jump2841:;
    _22 = _51;
    _jump2812:;
    void_t _77 = b(_13, _22);
    _1 = _77;
    goto _jump2849;
    _jump2793:;
    _a1__a2_void_t _78;
    // Computing bound for M
    _78.d0 = g;
    if (g > 0) 
    goto _jump2850;
    fail_assertion("non-positive loop bound");
    _jump2850:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= g;
    _79 *= sizeof(_a2_void_t);
    _78.data = jpl_alloc(_79);
    int64_t _80 = 0; // M
    _jump2851:; // Begin body of loop
    _a2_void_t _81;
    // Computing bound for N
    int64_t _82;
    // Computing bound for N
    if (g > 0) 
    goto _jump2852;
    fail_assertion("non-positive loop bound");
    _jump2852:;
    // Computing bound for O
    int64_t _83;
    // Computing bound for N
    if (E.d0 > 0) 
    goto _jump2853;
    fail_assertion("non-positive loop bound");
    _jump2853:;
    // Computing bound for O
    if (v > 0) 
    goto _jump2854;
    fail_assertion("non-positive loop bound");
    _jump2854:;
    _83 = 0;
    int64_t _84 = 0; // O
    int64_t _85 = 0; // N
    _jump2855:; // Begin body of loop
    _83 += h;
    _84++;
    if (_84 < v)
    goto _jump2855;
    _84 = 0;
    _85++;
    if (_85 < E.d0)
    goto _jump2855;
    // End body of loop
    if (_83 > 0) 
    goto _jump2856;
    fail_assertion("non-positive loop bound");
    _jump2856:;
    _82 = 0;
    int64_t _86 = 0; // O
    int64_t _87 = 0; // N
    _jump2857:; // Begin body of loop
    _82 += _80;
    _86++;
    if (_86 < _83)
    goto _jump2857;
    _86 = 0;
    _87++;
    if (_87 < g)
    goto _jump2857;
    // End body of loop
    _81.d0 = _82;
    if (_82 > 0) 
    goto _jump2858;
    fail_assertion("non-positive loop bound");
    _jump2858:;
    // Computing bound for O
    _81.d1 = A.d1;
    if (A.d1 > 0) 
    goto _jump2859;
    fail_assertion("non-positive loop bound");
    _jump2859:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= _82;
    _88 *= A.d1;
    _88 *= sizeof(void_t);
    _81.data = jpl_alloc(_88);
    int64_t _89 = 0; // O
    int64_t _90 = 0; // N
    _jump2860:; // Begin body of loop
    void_t _91 = z(A, E, H);
    int64_t _92 = 0;
    _92 *= _81.d0;
    _92 += _90;
    _92 *= _81.d1;
    _92 += _89;
    _81.data[_92] = _91;
    _89++;
    if (_89 < A.d1)
    goto _jump2860;
    _89 = 0;
    _90++;
    if (_90 < _82)
    goto _jump2860;
    // End body of loop
    int64_t _93 = 0;
    _93 *= _78.d0;
    _93 += _80;
    _78.data[_93] = _81;
    _80++;
    if (_80 < g)
    goto _jump2851;
    // End body of loop
    if (i.d1 >= 0)
    goto _jump2861;
    fail_assertion("negative array index");
    _jump2861:;
    if (i.d1 < _78.d0)
    goto _jump2862;
    fail_assertion("index too large");
    _jump2862:;
    int64_t _94 = 0;
    _94 *= _78.d0;
    _94 += i.d1;
    _a2_void_t _95 = _78.data[_94];
    if (E.d0 >= 0)
    goto _jump2863;
    fail_assertion("negative array index");
    _jump2863:;
    if (E.d0 < _95.d0)
    goto _jump2864;
    fail_assertion("index too large");
    _jump2864:;
    if (x >= 0)
    goto _jump2865;
    fail_assertion("negative array index");
    _jump2865:;
    if (x < _95.d1)
    goto _jump2866;
    fail_assertion("index too large");
    _jump2866:;
    int64_t _96 = 0;
    _96 *= _95.d0;
    _96 += E.d0;
    _96 *= _95.d1;
    _96 += x;
    void_t _97 = _95.data[_96];
    _1 = _97;
    _jump2849:;
    return _1;
    bool _98 = n(A);
    bool _99 = !_98;
    _a3__a3_double _100;
    if (!_99)
    goto _jump2867;
    _a3__a3_double _101;
    // Computing bound for M
    _101.d0 = r;
    if (r > 0) 
    goto _jump2868;
    fail_assertion("non-positive loop bound");
    _jump2868:;
    // Computing bound for N
    int64_t _102 = -r;
    _101.d1 = _102;
    if (_102 > 0) 
    goto _jump2869;
    fail_assertion("non-positive loop bound");
    _jump2869:;
    // Computing bound for O
    _101.d2 = v;
    if (v > 0) 
    goto _jump2870;
    fail_assertion("non-positive loop bound");
    _jump2870:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= r;
    _103 *= _102;
    _103 *= v;
    _103 *= sizeof(_a3_double);
    _101.data = jpl_alloc(_103);
    int64_t _104 = 0; // O
    int64_t _105 = 0; // N
    int64_t _106 = 0; // M
    _jump2871:; // Begin body of loop
    int64_t _107 = 0;
    _107 *= _101.d0;
    _107 += _106;
    _107 *= _101.d1;
    _107 += _105;
    _107 *= _101.d2;
    _107 += _104;
    _101.data[_107] = A;
    _104++;
    if (_104 < v)
    goto _jump2871;
    _104 = 0;
    _105++;
    if (_105 < _102)
    goto _jump2871;
    _105 = 0;
    _106++;
    if (_106 < r)
    goto _jump2871;
    // End body of loop
    _100 = _101;
    goto _jump2872;
    _jump2867:;
    _a2__a3__a3_double _108;
    // Computing bound for M
    int64_t _109;
    // Computing bound for M
    if (j > 0) 
    goto _jump2873;
    fail_assertion("non-positive loop bound");
    _jump2873:;
    // Computing bound for N
    if (q > 0) 
    goto _jump2874;
    fail_assertion("non-positive loop bound");
    _jump2874:;
    _109 = 0;
    int64_t _110 = 0; // N
    int64_t _111 = 0; // M
    _jump2875:; // Begin body of loop
    _109 += v;
    _110++;
    if (_110 < q)
    goto _jump2875;
    _110 = 0;
    _111++;
    if (_111 < j)
    goto _jump2875;
    // End body of loop
    _108.d0 = _109;
    if (_109 > 0) 
    goto _jump2876;
    fail_assertion("non-positive loop bound");
    _jump2876:;
    // Computing bound for N
    _108.d1 = u;
    if (u > 0) 
    goto _jump2877;
    fail_assertion("non-positive loop bound");
    _jump2877:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _109;
    _112 *= u;
    _112 *= sizeof(_a3__a3_double);
    _108.data = jpl_alloc(_112);
    int64_t _113 = 0; // N
    int64_t _114 = 0; // M
    _jump2878:; // Begin body of loop
    _a3__a3_double _115;
    // Computing bound for O
    _115.d0 = q;
    if (q > 0) 
    goto _jump2879;
    fail_assertion("non-positive loop bound");
    _jump2879:;
    // Computing bound for P
    _115.d1 = _113;
    if (_113 > 0) 
    goto _jump2880;
    fail_assertion("non-positive loop bound");
    _jump2880:;
    // Computing bound for Q
    _115.d2 = E.d0;
    if (E.d0 > 0) 
    goto _jump2881;
    fail_assertion("non-positive loop bound");
    _jump2881:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= q;
    _116 *= _113;
    _116 *= E.d0;
    _116 *= sizeof(_a3_double);
    _115.data = jpl_alloc(_116);
    int64_t _117 = 0; // Q
    int64_t _118 = 0; // P
    int64_t _119 = 0; // O
    _jump2882:; // Begin body of loop
    int64_t _120 = 0;
    _120 *= _115.d0;
    _120 += _119;
    _120 *= _115.d1;
    _120 += _118;
    _120 *= _115.d2;
    _120 += _117;
    _115.data[_120] = A;
    _117++;
    if (_117 < E.d0)
    goto _jump2882;
    _117 = 0;
    _118++;
    if (_118 < _113)
    goto _jump2882;
    _118 = 0;
    _119++;
    if (_119 < q)
    goto _jump2882;
    // End body of loop
    int64_t _121 = 0;
    _121 *= _108.d0;
    _121 += _114;
    _121 *= _108.d1;
    _121 += _113;
    _108.data[_121] = _115;
    _113++;
    if (_113 < u)
    goto _jump2878;
    _113 = 0;
    _114++;
    if (_114 < _109)
    goto _jump2878;
    // End body of loop
    int64_t _122 = u + k;
    if (f >= 0)
    goto _jump2883;
    fail_assertion("negative array index");
    _jump2883:;
    if (f < _108.d0)
    goto _jump2884;
    fail_assertion("index too large");
    _jump2884:;
    if (_122 >= 0)
    goto _jump2885;
    fail_assertion("negative array index");
    _jump2885:;
    if (_122 < _108.d1)
    goto _jump2886;
    fail_assertion("index too large");
    _jump2886:;
    int64_t _123 = 0;
    _123 *= _108.d0;
    _123 += f;
    _123 *= _108.d1;
    _123 += _122;
    _a3__a3_double _124 = _108.data[_123];
    _100 = _124;
    _jump2872:;
    if (q >= 0)
    goto _jump2887;
    fail_assertion("negative array index");
    _jump2887:;
    if (q < _100.d0)
    goto _jump2888;
    fail_assertion("index too large");
    _jump2888:;
    if (E.d1 >= 0)
    goto _jump2889;
    fail_assertion("negative array index");
    _jump2889:;
    if (E.d1 < _100.d1)
    goto _jump2890;
    fail_assertion("index too large");
    _jump2890:;
    if (x >= 0)
    goto _jump2891;
    fail_assertion("negative array index");
    _jump2891:;
    if (x < _100.d2)
    goto _jump2892;
    fail_assertion("index too large");
    _jump2892:;
    int64_t _125 = 0;
    _125 *= _100.d0;
    _125 += q;
    _125 *= _100.d1;
    _125 += E.d1;
    _125 *= _100.d2;
    _125 += x;
    _a3_double _126 = _100.data[_125];
    bool _127 = n(_126);
    void_t _128;
    if (!_127)
    goto _jump2893;
    _a3_double _130;
    // Computing bound for M
    _130.d0 = g;
    if (g > 0) 
    goto _jump2894;
    fail_assertion("non-positive loop bound");
    _jump2894:;
    // Computing bound for N
    _130.d1 = v;
    if (v > 0) 
    goto _jump2895;
    fail_assertion("non-positive loop bound");
    _jump2895:;
    // Computing bound for O
    _130.d2 = j;
    if (j > 0) 
    goto _jump2896;
    fail_assertion("non-positive loop bound");
    _jump2896:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= g;
    _131 *= v;
    _131 *= j;
    _131 *= sizeof(double);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // O
    int64_t _133 = 0; // N
    int64_t _134 = 0; // M
    _jump2897:; // Begin body of loop
    double _135 = 36.0;
    int64_t _136 = 0;
    _136 *= _130.d0;
    _136 += _134;
    _136 *= _130.d1;
    _136 += _133;
    _136 *= _130.d2;
    _136 += _132;
    _130.data[_136] = _135;
    _132++;
    if (_132 < j)
    goto _jump2897;
    _132 = 0;
    _133++;
    if (_133 < v)
    goto _jump2897;
    _133 = 0;
    _134++;
    if (_134 < g)
    goto _jump2897;
    // End body of loop
    bool _137 = n(_130);
    bool _129 = _137;
    if (0 == _137)
    goto _jump2898;
    _a3_double _138;
    // Computing bound for M
    _138.d0 = r;
    if (r > 0) 
    goto _jump2899;
    fail_assertion("non-positive loop bound");
    _jump2899:;
    // Computing bound for N
    _138.d1 = k;
    if (k > 0) 
    goto _jump2900;
    fail_assertion("non-positive loop bound");
    _jump2900:;
    // Computing bound for O
    _138.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump2901;
    fail_assertion("non-positive loop bound");
    _jump2901:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= r;
    _139 *= k;
    _139 *= i.d1;
    _139 *= sizeof(double);
    _138.data = jpl_alloc(_139);
    int64_t _140 = 0; // O
    int64_t _141 = 0; // N
    int64_t _142 = 0; // M
    _jump2902:; // Begin body of loop
    double _143 = 94.0;
    int64_t _144 = 0;
    _144 *= _138.d0;
    _144 += _142;
    _144 *= _138.d1;
    _144 += _141;
    _144 *= _138.d2;
    _144 += _140;
    _138.data[_144] = _143;
    _140++;
    if (_140 < i.d1)
    goto _jump2902;
    _140 = 0;
    _141++;
    if (_141 < k)
    goto _jump2902;
    _141 = 0;
    _142++;
    if (_142 < r)
    goto _jump2902;
    // End body of loop
    bool _145 = n(_138);
    bool _146 = !_145;
    _129 = _146;
    _jump2898:;
    _a3_double _147;
    if (!_129)
    goto _jump2903;
    _a3__a3_double _148;
    // Computing bound for M
    _148.d0 = E.d0;
    if (E.d0 > 0) 
    goto _jump2904;
    fail_assertion("non-positive loop bound");
    _jump2904:;
    // Computing bound for N
    _148.d1 = h;
    if (h > 0) 
    goto _jump2905;
    fail_assertion("non-positive loop bound");
    _jump2905:;
    // Computing bound for O
    _148.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump2906;
    fail_assertion("non-positive loop bound");
    _jump2906:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= E.d0;
    _149 *= h;
    _149 *= i.d1;
    _149 *= sizeof(_a3_double);
    _148.data = jpl_alloc(_149);
    int64_t _150 = 0; // O
    int64_t _151 = 0; // N
    int64_t _152 = 0; // M
    _jump2907:; // Begin body of loop
    _a3_double _153;
    // Computing bound for P
    _153.d0 = u;
    if (u > 0) 
    goto _jump2908;
    fail_assertion("non-positive loop bound");
    _jump2908:;
    // Computing bound for Q
    _153.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump2909;
    fail_assertion("non-positive loop bound");
    _jump2909:;
    // Computing bound for R
    int64_t _154 = j + q;
    _153.d2 = _154;
    if (_154 > 0) 
    goto _jump2910;
    fail_assertion("non-positive loop bound");
    _jump2910:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= u;
    _155 *= i.d0;
    _155 *= _154;
    _155 *= sizeof(double);
    _153.data = jpl_alloc(_155);
    int64_t _156 = 0; // R
    int64_t _157 = 0; // Q
    int64_t _158 = 0; // P
    _jump2911:; // Begin body of loop
    if (A.d2 >= 0)
    goto _jump2912;
    fail_assertion("negative array index");
    _jump2912:;
    if (A.d2 < E.d0)
    goto _jump2913;
    fail_assertion("index too large");
    _jump2913:;
    if (A.d0 >= 0)
    goto _jump2914;
    fail_assertion("negative array index");
    _jump2914:;
    if (A.d0 < E.d1)
    goto _jump2915;
    fail_assertion("index too large");
    _jump2915:;
    int64_t _159 = 0;
    _159 *= E.d0;
    _159 += A.d2;
    _159 *= E.d1;
    _159 += A.d0;
    double _160 = E.data[_159];
    int64_t _161 = 0;
    _161 *= _153.d0;
    _161 += _158;
    _161 *= _153.d1;
    _161 += _157;
    _161 *= _153.d2;
    _161 += _156;
    _153.data[_161] = _160;
    _156++;
    if (_156 < _154)
    goto _jump2911;
    _156 = 0;
    _157++;
    if (_157 < i.d0)
    goto _jump2911;
    _157 = 0;
    _158++;
    if (_158 < u)
    goto _jump2911;
    // End body of loop
    int64_t _162 = 0;
    _162 *= _148.d0;
    _162 += _152;
    _162 *= _148.d1;
    _162 += _151;
    _162 *= _148.d2;
    _162 += _150;
    _148.data[_162] = _153;
    _150++;
    if (_150 < i.d1)
    goto _jump2907;
    _150 = 0;
    _151++;
    if (_151 < h)
    goto _jump2907;
    _151 = 0;
    _152++;
    if (_152 < E.d0)
    goto _jump2907;
    // End body of loop
    int64_t _163 = -u;
    int64_t _164 = i.d1 * i.d0;
    if (_163 >= 0)
    goto _jump2916;
    fail_assertion("negative array index");
    _jump2916:;
    if (_163 < _148.d0)
    goto _jump2917;
    fail_assertion("index too large");
    _jump2917:;
    if (_164 >= 0)
    goto _jump2918;
    fail_assertion("negative array index");
    _jump2918:;
    if (_164 < _148.d1)
    goto _jump2919;
    fail_assertion("index too large");
    _jump2919:;
    if (u >= 0)
    goto _jump2920;
    fail_assertion("negative array index");
    _jump2920:;
    if (u < _148.d2)
    goto _jump2921;
    fail_assertion("index too large");
    _jump2921:;
    int64_t _165 = 0;
    _165 *= _148.d0;
    _165 += _163;
    _165 *= _148.d1;
    _165 += _164;
    _165 *= _148.d2;
    _165 += u;
    _a3_double _166 = _148.data[_165];
    _147 = _166;
    goto _jump2922;
    _jump2903:;
    bool _167 = false;
    bool _168 = !_167;
    _a3_double _169;
    if (!_168)
    goto _jump2923;
    _a3_double _170;
    // Computing bound for M
    _170.d0 = E.d1;
    if (E.d1 > 0) 
    goto _jump2924;
    fail_assertion("non-positive loop bound");
    _jump2924:;
    // Computing bound for N
    _170.d1 = E.d0;
    if (E.d0 > 0) 
    goto _jump2925;
    fail_assertion("non-positive loop bound");
    _jump2925:;
    // Computing bound for O
    _170.d2 = h;
    if (h > 0) 
    goto _jump2926;
    fail_assertion("non-positive loop bound");
    _jump2926:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= E.d1;
    _171 *= E.d0;
    _171 *= h;
    _171 *= sizeof(double);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // O
    int64_t _173 = 0; // N
    int64_t _174 = 0; // M
    _jump2927:; // Begin body of loop
    double _175 = 26.0;
    int64_t _176 = 0;
    _176 *= _170.d0;
    _176 += _174;
    _176 *= _170.d1;
    _176 += _173;
    _176 *= _170.d2;
    _176 += _172;
    _170.data[_176] = _175;
    _172++;
    if (_172 < h)
    goto _jump2927;
    _172 = 0;
    _173++;
    if (_173 < E.d0)
    goto _jump2927;
    _173 = 0;
    _174++;
    if (_174 < E.d1)
    goto _jump2927;
    // End body of loop
    _169 = _170;
    goto _jump2928;
    _jump2923:;
    _a3_double _177;
    // Computing bound for M
    _177.d0 = u;
    if (u > 0) 
    goto _jump2929;
    fail_assertion("non-positive loop bound");
    _jump2929:;
    // Computing bound for N
    _177.d1 = A.d0;
    if (A.d0 > 0) 
    goto _jump2930;
    fail_assertion("non-positive loop bound");
    _jump2930:;
    // Computing bound for O
    _177.d2 = k;
    if (k > 0) 
    goto _jump2931;
    fail_assertion("non-positive loop bound");
    _jump2931:;
    // Computing total size of heap memory to allocate
    int64_t _178 = 1;
    _178 *= u;
    _178 *= A.d0;
    _178 *= k;
    _178 *= sizeof(double);
    _177.data = jpl_alloc(_178);
    int64_t _179 = 0; // O
    int64_t _180 = 0; // N
    int64_t _181 = 0; // M
    _jump2932:; // Begin body of loop
    bool _182 = n(A);
    double _183;
    if (!_182)
    goto _jump2933;
    if (_181 >= 0)
    goto _jump2934;
    fail_assertion("negative array index");
    _jump2934:;
    if (_181 < E.d0)
    goto _jump2935;
    fail_assertion("index too large");
    _jump2935:;
    if (E.d1 >= 0)
    goto _jump2936;
    fail_assertion("negative array index");
    _jump2936:;
    if (E.d1 < E.d1)
    goto _jump2937;
    fail_assertion("index too large");
    _jump2937:;
    int64_t _184 = 0;
    _184 *= E.d0;
    _184 += _181;
    _184 *= E.d1;
    _184 += E.d1;
    double _185 = E.data[_184];
    _183 = _185;
    goto _jump2938;
    _jump2933:;
    if (A.d1 >= 0)
    goto _jump2939;
    fail_assertion("negative array index");
    _jump2939:;
    if (A.d1 < A.d0)
    goto _jump2940;
    fail_assertion("index too large");
    _jump2940:;
    if (A.d1 >= 0)
    goto _jump2941;
    fail_assertion("negative array index");
    _jump2941:;
    if (A.d1 < A.d1)
    goto _jump2942;
    fail_assertion("index too large");
    _jump2942:;
    if (E.d1 >= 0)
    goto _jump2943;
    fail_assertion("negative array index");
    _jump2943:;
    if (E.d1 < A.d2)
    goto _jump2944;
    fail_assertion("index too large");
    _jump2944:;
    int64_t _186 = 0;
    _186 *= A.d0;
    _186 += A.d1;
    _186 *= A.d1;
    _186 += A.d1;
    _186 *= A.d2;
    _186 += E.d1;
    double _187 = A.data[_186];
    _183 = _187;
    _jump2938:;
    int64_t _188 = 0;
    _188 *= _177.d0;
    _188 += _181;
    _188 *= _177.d1;
    _188 += _180;
    _188 *= _177.d2;
    _188 += _179;
    _177.data[_188] = _183;
    _179++;
    if (_179 < k)
    goto _jump2932;
    _179 = 0;
    _180++;
    if (_180 < A.d0)
    goto _jump2932;
    _180 = 0;
    _181++;
    if (_181 < u)
    goto _jump2932;
    // End body of loop
    _169 = _177;
    _jump2928:;
    _147 = _169;
    _jump2922:;
    _a2_double _189;
    // Computing bound for M
    _189.d0 = x;
    if (x > 0) 
    goto _jump2945;
    fail_assertion("non-positive loop bound");
    _jump2945:;
    // Computing bound for N
    _189.d1 = h;
    if (h > 0) 
    goto _jump2946;
    fail_assertion("non-positive loop bound");
    _jump2946:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= x;
    _190 *= h;
    _190 *= sizeof(double);
    _189.data = jpl_alloc(_190);
    int64_t _191 = 0; // N
    int64_t _192 = 0; // M
    _jump2947:; // Begin body of loop
    double _193;
    // Computing bound for O
    if (A.d0 > 0) 
    goto _jump2948;
    fail_assertion("non-positive loop bound");
    _jump2948:;
    _193 = 0;
    int64_t _194 = 0; // O
    _jump2949:; // Begin body of loop
    double _195 = 97.0;
    _193 += _195;
    _194++;
    if (_194 < A.d0)
    goto _jump2949;
    // End body of loop
    double _196;
    // Computing bound for O
    int64_t _197 = 573;
    if (_197 > 0) 
    goto _jump2950;
    fail_assertion("non-positive loop bound");
    _jump2950:;
    _196 = 0;
    int64_t _198 = 0; // O
    _jump2951:; // Begin body of loop
    _a3_double _199;
    // Computing bound for P
    _199.d0 = j;
    if (j > 0) 
    goto _jump2952;
    fail_assertion("non-positive loop bound");
    _jump2952:;
    // Computing bound for Q
    _199.d1 = r;
    if (r > 0) 
    goto _jump2953;
    fail_assertion("non-positive loop bound");
    _jump2953:;
    // Computing bound for R
    _199.d2 = A.d2;
    if (A.d2 > 0) 
    goto _jump2954;
    fail_assertion("non-positive loop bound");
    _jump2954:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= j;
    _200 *= r;
    _200 *= A.d2;
    _200 *= sizeof(double);
    _199.data = jpl_alloc(_200);
    int64_t _201 = 0; // R
    int64_t _202 = 0; // Q
    int64_t _203 = 0; // P
    _jump2955:; // Begin body of loop
    double _204 = 42.0;
    int64_t _205 = 0;
    _205 *= _199.d0;
    _205 += _203;
    _205 *= _199.d1;
    _205 += _202;
    _205 *= _199.d2;
    _205 += _201;
    _199.data[_205] = _204;
    _201++;
    if (_201 < A.d2)
    goto _jump2955;
    _201 = 0;
    _202++;
    if (_202 < r)
    goto _jump2955;
    _202 = 0;
    _203++;
    if (_203 < j)
    goto _jump2955;
    // End body of loop
    bool _206 = h <= v;
    double _207 = s(_199, _206, i);
    _196 += _207;
    _198++;
    if (_198 < _197)
    goto _jump2951;
    // End body of loop
    double _208 = _193 + _196;
    int64_t _209 = 0;
    _209 *= _189.d0;
    _209 += _192;
    _209 *= _189.d1;
    _209 += _191;
    _189.data[_209] = _208;
    _191++;
    if (_191 < h)
    goto _jump2947;
    _191 = 0;
    _192++;
    if (_192 < x)
    goto _jump2947;
    // End body of loop
    void_t _210 = z(_147, _189, H);
    _128 = _210;
    goto _jump2956;
    _jump2893:;
    _a1_bool _211;
    // Computing bound for M
    _211.d0 = v;
    if (v > 0) 
    goto _jump2957;
    fail_assertion("non-positive loop bound");
    _jump2957:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= v;
    _212 *= sizeof(bool);
    _211.data = jpl_alloc(_212);
    int64_t _213 = 0; // M
    _jump2958:; // Begin body of loop
    _a1_int64_t _215;
    // Computing bound for N
    _215.d0 = h;
    if (h > 0) 
    goto _jump2959;
    fail_assertion("non-positive loop bound");
    _jump2959:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= h;
    _216 *= sizeof(int64_t);
    _215.data = jpl_alloc(_216);
    int64_t _217 = 0; // N
    _jump2960:; // Begin body of loop
    int64_t _218 = 0;
    _218 *= _215.d0;
    _218 += _217;
    _215.data[_218] = A.d2;
    _217++;
    if (_217 < h)
    goto _jump2960;
    // End body of loop
    if (_213 >= 0)
    goto _jump2961;
    fail_assertion("negative array index");
    _jump2961:;
    if (_213 < _215.d0)
    goto _jump2962;
    fail_assertion("index too large");
    _jump2962:;
    int64_t _219 = 0;
    _219 *= _215.d0;
    _219 += _213;
    int64_t _220 = _215.data[_219];
    bool _221 = _220 <= q;
    bool _214 = _221;
    if (0 != _221)
    goto _jump2963;
    double _222 = 57.0;
    double _223 = 90.0;
    double _224 = _222 - _223;
    double _225 = 10.0;
    bool _226 = _224 >= _225;
    bool _227;
    if (!_226)
    goto _jump2964;
    _a3_bool _228;
    // Computing bound for N
    _228.d0 = h;
    if (h > 0) 
    goto _jump2965;
    fail_assertion("non-positive loop bound");
    _jump2965:;
    // Computing bound for O
    _228.d1 = x;
    if (x > 0) 
    goto _jump2966;
    fail_assertion("non-positive loop bound");
    _jump2966:;
    // Computing bound for P
    _228.d2 = q;
    if (q > 0) 
    goto _jump2967;
    fail_assertion("non-positive loop bound");
    _jump2967:;
    // Computing total size of heap memory to allocate
    int64_t _229 = 1;
    _229 *= h;
    _229 *= x;
    _229 *= q;
    _229 *= sizeof(bool);
    _228.data = jpl_alloc(_229);
    int64_t _230 = 0; // P
    int64_t _231 = 0; // O
    int64_t _232 = 0; // N
    _jump2968:; // Begin body of loop
    bool _233 = false;
    int64_t _234 = 0;
    _234 *= _228.d0;
    _234 += _232;
    _234 *= _228.d1;
    _234 += _231;
    _234 *= _228.d2;
    _234 += _230;
    _228.data[_234] = _233;
    _230++;
    if (_230 < q)
    goto _jump2968;
    _230 = 0;
    _231++;
    if (_231 < x)
    goto _jump2968;
    _231 = 0;
    _232++;
    if (_232 < h)
    goto _jump2968;
    // End body of loop
    int64_t _235 = 883;
    int64_t _236 = -_235;
    int64_t _237 = i.d0 * h;
    if (E.d0 >= 0)
    goto _jump2969;
    fail_assertion("negative array index");
    _jump2969:;
    if (E.d0 < _228.d0)
    goto _jump2970;
    fail_assertion("index too large");
    _jump2970:;
    if (_236 >= 0)
    goto _jump2971;
    fail_assertion("negative array index");
    _jump2971:;
    if (_236 < _228.d1)
    goto _jump2972;
    fail_assertion("index too large");
    _jump2972:;
    if (_237 >= 0)
    goto _jump2973;
    fail_assertion("negative array index");
    _jump2973:;
    if (_237 < _228.d2)
    goto _jump2974;
    fail_assertion("index too large");
    _jump2974:;
    int64_t _238 = 0;
    _238 *= _228.d0;
    _238 += E.d0;
    _238 *= _228.d1;
    _238 += _236;
    _238 *= _228.d2;
    _238 += _237;
    bool _239 = _228.data[_238];
    _227 = _239;
    goto _jump2975;
    _jump2964:;
    int64_t _240 = 249;
    bool _241 = E.d0 != _240;
    bool _242 = !_241;
    _227 = _242;
    _jump2975:;
    _214 = _227;
    _jump2963:;
    int64_t _243 = 0;
    _243 *= _211.d0;
    _243 += _213;
    _211.data[_243] = _214;
    _213++;
    if (_213 < v)
    goto _jump2958;
    // End body of loop
    bool _244 = true;
    bool _245 = !_244;
    bool _246 = !_245;
    int64_t _247;
    if (!_246)
    goto _jump2976;
    _247 = k;
    goto _jump2977;
    _jump2976:;
    _247 = q;
    _jump2977:;
    bool _249 = true;
    bool _250 = !_249;
    bool _248 = _250;
    if (0 == _250)
    goto _jump2978;
    bool _251 = n(A);
    _248 = _251;
    _jump2978:;
    int64_t _252;
    if (!_248)
    goto _jump2979;
    int64_t _253 = 180;
    if (_253 >= 0)
    goto _jump2980;
    fail_assertion("negative array index");
    _jump2980:;
    if (_253 < i.d0)
    goto _jump2981;
    fail_assertion("index too large");
    _jump2981:;
    if (u >= 0)
    goto _jump2982;
    fail_assertion("negative array index");
    _jump2982:;
    if (u < i.d1)
    goto _jump2983;
    fail_assertion("index too large");
    _jump2983:;
    int64_t _254 = 0;
    _254 *= i.d0;
    _254 += _253;
    _254 *= i.d1;
    _254 += u;
    int64_t _255 = i.data[_254];
    _252 = _255;
    goto _jump2984;
    _jump2979:;
    int64_t _256 = 869;
    _252 = _256;
    _jump2984:;
    bool _257 = _247 < _252;
    bool _259 = true;
    _a3_double _260;
    if (!_259)
    goto _jump2985;
    _260 = A;
    goto _jump2986;
    _jump2985:;
    _260 = A;
    _jump2986:;
    bool _261 = n(_260);
    bool _262 = !_261;
    bool _258 = _262;
    if (0 != _262)
    goto _jump2987;
    bool _263 = x <= j;
    bool _264 = true;
    bool _265 = _263 == _264;
    bool _266 = !_265;
    _258 = _266;
    _jump2987:;
    _a1_bool _267;
    _267.d0 = 2;
    _267.data = jpl_alloc(sizeof(bool) * 2);
    _267.data[0] = _257;
    _267.data[1] = _258;
    void_t _268 = b(_211, _267);
    _128 = _268;
    _jump2956:;
    return _128;
    _a1_rgba _269;
    // Computing bound for M
    _269.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump2988;
    fail_assertion("non-positive loop bound");
    _jump2988:;
    // Computing total size of heap memory to allocate
    int64_t _270 = 1;
    _270 *= i.d1;
    _270 *= sizeof(rgba);
    _269.data = jpl_alloc(_270);
    int64_t _271 = 0; // M
    _jump2989:; // Begin body of loop
    bool _272 = true;
    bool _273;
    if (!_272)
    goto _jump2990;
    bool _275 = j != v;
    bool _274 = _275;
    if (0 != _275)
    goto _jump2991;
    bool _276 = true;
    bool _277 = !_276;
    _274 = _277;
    _jump2991:;
    _273 = _274;
    goto _jump2992;
    _jump2990:;
    bool _278 = j > A.d1;
    _273 = _278;
    _jump2992:;
    bool _279;
    if (!_273)
    goto _jump2993;
    bool _281 = n(A);
    bool _280 = _281;
    if (0 != _281)
    goto _jump2994;
    bool _282 = false;
    _280 = _282;
    _jump2994:;
    _279 = _280;
    goto _jump2995;
    _jump2993:;
    bool _283 = E.d0 < A.d1;
    bool _284;
    if (!_283)
    goto _jump2996;
    bool _285 = E.d0 <= A.d1;
    bool _286 = !_285;
    _284 = _286;
    goto _jump2997;
    _jump2996:;
    bool _287 = true;
    double _288 = s(A, _287, i);
    if (x >= 0)
    goto _jump2998;
    fail_assertion("negative array index");
    _jump2998:;
    if (x < c.d0)
    goto _jump2999;
    fail_assertion("index too large");
    _jump2999:;
    int64_t _289 = 0;
    _289 *= c.d0;
    _289 += x;
    double _290 = c.data[_289];
    bool _291 = _288 == _290;
    _284 = _291;
    _jump2997:;
    _279 = _284;
    _jump2995:;
    _a2__a2_int64_t _292;
    if (!_279)
    goto _jump3000;
    _a2__a2_int64_t _293;
    // Computing bound for N
    _a1_int64_t _294;
    _294.d0 = 1;
    _294.data = jpl_alloc(sizeof(int64_t) * 1);
    _294.data[0] = i.d1;
    if (f >= 0)
    goto _jump3001;
    fail_assertion("negative array index");
    _jump3001:;
    if (f < _294.d0)
    goto _jump3002;
    fail_assertion("index too large");
    _jump3002:;
    int64_t _295 = 0;
    _295 *= _294.d0;
    _295 += f;
    int64_t _296 = _294.data[_295];
    int64_t _297 = g / _296;
    _293.d0 = _297;
    if (_297 > 0) 
    goto _jump3003;
    fail_assertion("non-positive loop bound");
    _jump3003:;
    // Computing bound for O
    _293.d1 = j;
    if (j > 0) 
    goto _jump3004;
    fail_assertion("non-positive loop bound");
    _jump3004:;
    // Computing total size of heap memory to allocate
    int64_t _298 = 1;
    _298 *= _297;
    _298 *= j;
    _298 *= sizeof(_a2_int64_t);
    _293.data = jpl_alloc(_298);
    int64_t _299 = 0; // O
    int64_t _300 = 0; // N
    _jump3005:; // Begin body of loop
    _a2_int64_t _301;
    // Computing bound for P
    _301.d0 = _300;
    if (_300 > 0) 
    goto _jump3006;
    fail_assertion("non-positive loop bound");
    _jump3006:;
    // Computing bound for Q
    _301.d1 = r;
    if (r > 0) 
    goto _jump3007;
    fail_assertion("non-positive loop bound");
    _jump3007:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _300;
    _302 *= r;
    _302 *= sizeof(int64_t);
    _301.data = jpl_alloc(_302);
    int64_t _303 = 0; // Q
    int64_t _304 = 0; // P
    _jump3008:; // Begin body of loop
    int64_t _305 = 0;
    _305 *= _301.d0;
    _305 += _304;
    _305 *= _301.d1;
    _305 += _303;
    _301.data[_305] = h;
    _303++;
    if (_303 < r)
    goto _jump3008;
    _303 = 0;
    _304++;
    if (_304 < _300)
    goto _jump3008;
    // End body of loop
    int64_t _306 = 0;
    _306 *= _293.d0;
    _306 += _300;
    _306 *= _293.d1;
    _306 += _299;
    _293.data[_306] = _301;
    _299++;
    if (_299 < j)
    goto _jump3005;
    _299 = 0;
    _300++;
    if (_300 < _297)
    goto _jump3005;
    // End body of loop
    _292 = _293;
    goto _jump3009;
    _jump3000:;
    _a2__a2_int64_t _307;
    // Computing bound for N
    int64_t _308;
    // Computing bound for N
    if (A.d2 > 0) 
    goto _jump3010;
    fail_assertion("non-positive loop bound");
    _jump3010:;
    // Computing bound for O
    if (j > 0) 
    goto _jump3011;
    fail_assertion("non-positive loop bound");
    _jump3011:;
    _308 = 0;
    int64_t _309 = 0; // O
    int64_t _310 = 0; // N
    _jump3012:; // Begin body of loop
    _308 += x;
    _309++;
    if (_309 < j)
    goto _jump3012;
    _309 = 0;
    _310++;
    if (_310 < A.d2)
    goto _jump3012;
    // End body of loop
    _307.d0 = _308;
    if (_308 > 0) 
    goto _jump3013;
    fail_assertion("non-positive loop bound");
    _jump3013:;
    // Computing bound for O
    int64_t _311;
    // Computing bound for N
    if (A.d2 > 0) 
    goto _jump3014;
    fail_assertion("non-positive loop bound");
    _jump3014:;
    // Computing bound for O
    if (u > 0) 
    goto _jump3015;
    fail_assertion("non-positive loop bound");
    _jump3015:;
    // Computing bound for P
    if (k > 0) 
    goto _jump3016;
    fail_assertion("non-positive loop bound");
    _jump3016:;
    _311 = 0;
    int64_t _312 = 0; // P
    int64_t _313 = 0; // O
    int64_t _314 = 0; // N
    _jump3017:; // Begin body of loop
    int64_t _315;
    // Computing bound for Q
    if (g > 0) 
    goto _jump3018;
    fail_assertion("non-positive loop bound");
    _jump3018:;
    // Computing bound for R
    if (A.d0 > 0) 
    goto _jump3019;
    fail_assertion("non-positive loop bound");
    _jump3019:;
    // Computing bound for S
    if (r > 0) 
    goto _jump3020;
    fail_assertion("non-positive loop bound");
    _jump3020:;
    _315 = 0;
    int64_t _316 = 0; // S
    int64_t _317 = 0; // R
    int64_t _318 = 0; // Q
    _jump3021:; // Begin body of loop
    _315 += _318;
    _316++;
    if (_316 < r)
    goto _jump3021;
    _316 = 0;
    _317++;
    if (_317 < A.d0)
    goto _jump3021;
    _317 = 0;
    _318++;
    if (_318 < g)
    goto _jump3021;
    // End body of loop
    _311 += _315;
    _312++;
    if (_312 < k)
    goto _jump3017;
    _312 = 0;
    _313++;
    if (_313 < u)
    goto _jump3017;
    _313 = 0;
    _314++;
    if (_314 < A.d2)
    goto _jump3017;
    // End body of loop
    int64_t _319 = i.d1 / _311;
    _307.d1 = _319;
    if (_319 > 0) 
    goto _jump3022;
    fail_assertion("non-positive loop bound");
    _jump3022:;
    // Computing total size of heap memory to allocate
    int64_t _320 = 1;
    _320 *= _308;
    _320 *= _319;
    _320 *= sizeof(_a2_int64_t);
    _307.data = jpl_alloc(_320);
    int64_t _321 = 0; // O
    int64_t _322 = 0; // N
    _jump3023:; // Begin body of loop
    int64_t _323 = 0;
    _323 *= _307.d0;
    _323 += _322;
    _323 *= _307.d1;
    _323 += _321;
    _307.data[_323] = i;
    _321++;
    if (_321 < _319)
    goto _jump3023;
    _321 = 0;
    _322++;
    if (_322 < _308)
    goto _jump3023;
    // End body of loop
    _292 = _307;
    _jump3009:;
    int64_t _324;
    // Computing bound for N
    if (u > 0) 
    goto _jump3024;
    fail_assertion("non-positive loop bound");
    _jump3024:;
    // Computing bound for O
    if (g > 0) 
    goto _jump3025;
    fail_assertion("non-positive loop bound");
    _jump3025:;
    // Computing bound for P
    if (u > 0) 
    goto _jump3026;
    fail_assertion("non-positive loop bound");
    _jump3026:;
    _324 = 0;
    int64_t _325 = 0; // P
    int64_t _326 = 0; // O
    int64_t _327 = 0; // N
    _jump3027:; // Begin body of loop
    _324 += i.d0;
    _325++;
    if (_325 < u)
    goto _jump3027;
    _325 = 0;
    _326++;
    if (_326 < g)
    goto _jump3027;
    _326 = 0;
    _327++;
    if (_327 < u)
    goto _jump3027;
    // End body of loop
    int64_t _328 = _324 * j;
    _a1__a3_bool _329;
    // Computing bound for N
    _329.d0 = v;
    if (v > 0) 
    goto _jump3028;
    fail_assertion("non-positive loop bound");
    _jump3028:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= v;
    _330 *= sizeof(_a3_bool);
    _329.data = jpl_alloc(_330);
    int64_t _331 = 0; // N
    _jump3029:; // Begin body of loop
    _a3_bool _332;
    // Computing bound for O
    _332.d0 = u;
    if (u > 0) 
    goto _jump3030;
    fail_assertion("non-positive loop bound");
    _jump3030:;
    // Computing bound for P
    _332.d1 = j;
    if (j > 0) 
    goto _jump3031;
    fail_assertion("non-positive loop bound");
    _jump3031:;
    // Computing bound for Q
    _332.d2 = r;
    if (r > 0) 
    goto _jump3032;
    fail_assertion("non-positive loop bound");
    _jump3032:;
    // Computing total size of heap memory to allocate
    int64_t _333 = 1;
    _333 *= u;
    _333 *= j;
    _333 *= r;
    _333 *= sizeof(bool);
    _332.data = jpl_alloc(_333);
    int64_t _334 = 0; // Q
    int64_t _335 = 0; // P
    int64_t _336 = 0; // O
    _jump3033:; // Begin body of loop
    bool _337 = false;
    int64_t _338;
    if (!_337)
    goto _jump3034;
    _338 = _331;
    goto _jump3035;
    _jump3034:;
    _338 = _271;
    _jump3035:;
    bool _339 = _338 <= E.d0;
    int64_t _340 = 0;
    _340 *= _332.d0;
    _340 += _336;
    _340 *= _332.d1;
    _340 += _335;
    _340 *= _332.d2;
    _340 += _334;
    _332.data[_340] = _339;
    _334++;
    if (_334 < r)
    goto _jump3033;
    _334 = 0;
    _335++;
    if (_335 < j)
    goto _jump3033;
    _335 = 0;
    _336++;
    if (_336 < u)
    goto _jump3033;
    // End body of loop
    int64_t _341 = 0;
    _341 *= _329.d0;
    _341 += _331;
    _329.data[_341] = _332;
    _331++;
    if (_331 < v)
    goto _jump3029;
    // End body of loop
    if (j >= 0)
    goto _jump3036;
    fail_assertion("negative array index");
    _jump3036:;
    if (j < _329.d0)
    goto _jump3037;
    fail_assertion("index too large");
    _jump3037:;
    int64_t _342 = 0;
    _342 *= _329.d0;
    _342 += j;
    _a3_bool _343 = _329.data[_342];
    rgba _344 = m(_292, _328, _343);
    int64_t _345 = 0;
    _345 *= _269.d0;
    _345 += _271;
    _269.data[_345] = _344;
    _271++;
    if (_271 < i.d1)
    goto _jump2989;
    // End body of loop
    bool _346 = n(A);
    bool _347;
    if (!_346)
    goto _jump3038;
    _a3_bool _348;
    // Computing bound for P
    _348.d0 = v;
    if (v > 0) 
    goto _jump3039;
    fail_assertion("non-positive loop bound");
    _jump3039:;
    // Computing bound for Q
    _348.d1 = x;
    if (x > 0) 
    goto _jump3040;
    fail_assertion("non-positive loop bound");
    _jump3040:;
    // Computing bound for R
    _348.d2 = g;
    if (g > 0) 
    goto _jump3041;
    fail_assertion("non-positive loop bound");
    _jump3041:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= v;
    _349 *= x;
    _349 *= g;
    _349 *= sizeof(bool);
    _348.data = jpl_alloc(_349);
    int64_t _350 = 0; // R
    int64_t _351 = 0; // Q
    int64_t _352 = 0; // P
    _jump3042:; // Begin body of loop
    bool _353 = false;
    int64_t _354 = 0;
    _354 *= _348.d0;
    _354 += _352;
    _354 *= _348.d1;
    _354 += _351;
    _354 *= _348.d2;
    _354 += _350;
    _348.data[_354] = _353;
    _350++;
    if (_350 < g)
    goto _jump3042;
    _350 = 0;
    _351++;
    if (_351 < x)
    goto _jump3042;
    _351 = 0;
    _352++;
    if (_352 < v)
    goto _jump3042;
    // End body of loop
    int64_t _355 = -E.d1;
    if (_355 >= 0)
    goto _jump3043;
    fail_assertion("negative array index");
    _jump3043:;
    if (_355 < _348.d0)
    goto _jump3044;
    fail_assertion("index too large");
    _jump3044:;
    if (g >= 0)
    goto _jump3045;
    fail_assertion("negative array index");
    _jump3045:;
    if (g < _348.d1)
    goto _jump3046;
    fail_assertion("index too large");
    _jump3046:;
    if (A.d0 >= 0)
    goto _jump3047;
    fail_assertion("negative array index");
    _jump3047:;
    if (A.d0 < _348.d2)
    goto _jump3048;
    fail_assertion("index too large");
    _jump3048:;
    int64_t _356 = 0;
    _356 *= _348.d0;
    _356 += _355;
    _356 *= _348.d1;
    _356 += g;
    _356 *= _348.d2;
    _356 += A.d0;
    bool _357 = _348.data[_356];
    _347 = _357;
    goto _jump3049;
    _jump3038:;
    bool _358 = r == v;
    _347 = _358;
    _jump3049:;
    bool _359 = !_347;
    bool _360;
    if (!_359)
    goto _jump3050;
    bool _362 = false;
    bool _361 = _362;
    if (0 == _362)
    goto _jump3051;
    int64_t _363 = -g;
    bool _364 = _363 >= u;
    bool _365 = !_364;
    _361 = _365;
    _jump3051:;
    _360 = _361;
    goto _jump3052;
    _jump3050:;
    int64_t _366 = -j;
    if (f >= 0)
    goto _jump3053;
    fail_assertion("negative array index");
    _jump3053:;
    if (f < A.d0)
    goto _jump3054;
    fail_assertion("index too large");
    _jump3054:;
    if (j >= 0)
    goto _jump3055;
    fail_assertion("negative array index");
    _jump3055:;
    if (j < A.d1)
    goto _jump3056;
    fail_assertion("index too large");
    _jump3056:;
    if (_366 >= 0)
    goto _jump3057;
    fail_assertion("negative array index");
    _jump3057:;
    if (_366 < A.d2)
    goto _jump3058;
    fail_assertion("index too large");
    _jump3058:;
    int64_t _367 = 0;
    _367 *= A.d0;
    _367 += f;
    _367 *= A.d1;
    _367 += j;
    _367 *= A.d2;
    _367 += _366;
    double _368 = A.data[_367];
    bool _369 = E.d1 == j;
    double _370;
    if (!_369)
    goto _jump3059;
    double _371 = 53.0;
    _370 = _371;
    goto _jump3060;
    _jump3059:;
    bool _372 = false;
    double _373;
    if (!_372)
    goto _jump3061;
    double _374 = 79.0;
    _373 = _374;
    goto _jump3062;
    _jump3061:;
    double _375 = 57.0;
    _373 = _375;
    _jump3062:;
    _370 = _373;
    _jump3060:;
    double _376 = _368 / _370;
    bool _378 = false;
    bool _379 = !_378;
    bool _377 = _379;
    if (0 == _379)
    goto _jump3063;
    bool _380 = true;
    _377 = _380;
    _jump3063:;
    double _381;
    if (!_377)
    goto _jump3064;
    double _382;
    // Computing bound for P
    int64_t _383 = j - u;
    if (_383 > 0) 
    goto _jump3065;
    fail_assertion("non-positive loop bound");
    _jump3065:;
    _382 = 0;
    int64_t _384 = 0; // P
    _jump3066:; // Begin body of loop
    if (x >= 0)
    goto _jump3067;
    fail_assertion("negative array index");
    _jump3067:;
    if (x < E.d0)
    goto _jump3068;
    fail_assertion("index too large");
    _jump3068:;
    if (x >= 0)
    goto _jump3069;
    fail_assertion("negative array index");
    _jump3069:;
    if (x < E.d1)
    goto _jump3070;
    fail_assertion("index too large");
    _jump3070:;
    int64_t _385 = 0;
    _385 *= E.d0;
    _385 += x;
    _385 *= E.d1;
    _385 += x;
    double _386 = E.data[_385];
    _382 += _386;
    _384++;
    if (_384 < _383)
    goto _jump3066;
    // End body of loop
    _381 = _382;
    goto _jump3071;
    _jump3064:;
    double _387 = 16.0;
    _381 = _387;
    _jump3071:;
    bool _388 = _376 == _381;
    _360 = _388;
    _jump3052:;
    _a3_void_t _389;
    if (!_360)
    goto _jump3072;
    _a3_void_t _390;
    // Computing bound for P
    _390.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump3073;
    fail_assertion("non-positive loop bound");
    _jump3073:;
    // Computing bound for Q
    if (A.d2 >= 0)
    goto _jump3074;
    fail_assertion("negative array index");
    _jump3074:;
    if (A.d2 < p.d0)
    goto _jump3075;
    fail_assertion("index too large");
    _jump3075:;
    if (r >= 0)
    goto _jump3076;
    fail_assertion("negative array index");
    _jump3076:;
    if (r < p.d1)
    goto _jump3077;
    fail_assertion("index too large");
    _jump3077:;
    int64_t _391 = 0;
    _391 *= p.d0;
    _391 += A.d2;
    _391 *= p.d1;
    _391 += r;
    int64_t _392 = p.data[_391];
    _a2__a3_int64_t _393;
    // Computing bound for P
    _393.d0 = k;
    if (k > 0) 
    goto _jump3078;
    fail_assertion("non-positive loop bound");
    _jump3078:;
    // Computing bound for Q
    _393.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump3079;
    fail_assertion("non-positive loop bound");
    _jump3079:;
    // Computing total size of heap memory to allocate
    int64_t _394 = 1;
    _394 *= k;
    _394 *= i.d1;
    _394 *= sizeof(_a3_int64_t);
    _393.data = jpl_alloc(_394);
    int64_t _395 = 0; // Q
    int64_t _396 = 0; // P
    _jump3080:; // Begin body of loop
    int64_t _397 = 0;
    _397 *= _393.d0;
    _397 += _396;
    _397 *= _393.d1;
    _397 += _395;
    _393.data[_397] = e;
    _395++;
    if (_395 < i.d1)
    goto _jump3080;
    _395 = 0;
    _396++;
    if (_396 < k)
    goto _jump3080;
    // End body of loop
    if (k >= 0)
    goto _jump3081;
    fail_assertion("negative array index");
    _jump3081:;
    if (k < _393.d0)
    goto _jump3082;
    fail_assertion("index too large");
    _jump3082:;
    if (A.d2 >= 0)
    goto _jump3083;
    fail_assertion("negative array index");
    _jump3083:;
    if (A.d2 < _393.d1)
    goto _jump3084;
    fail_assertion("index too large");
    _jump3084:;
    int64_t _398 = 0;
    _398 *= _393.d0;
    _398 += k;
    _398 *= _393.d1;
    _398 += A.d2;
    _a3_int64_t _399 = _393.data[_398];
    if (i.d0 >= 0)
    goto _jump3085;
    fail_assertion("negative array index");
    _jump3085:;
    if (i.d0 < _399.d0)
    goto _jump3086;
    fail_assertion("index too large");
    _jump3086:;
    if (r >= 0)
    goto _jump3087;
    fail_assertion("negative array index");
    _jump3087:;
    if (r < _399.d1)
    goto _jump3088;
    fail_assertion("index too large");
    _jump3088:;
    if (f >= 0)
    goto _jump3089;
    fail_assertion("negative array index");
    _jump3089:;
    if (f < _399.d2)
    goto _jump3090;
    fail_assertion("index too large");
    _jump3090:;
    int64_t _400 = 0;
    _400 *= _399.d0;
    _400 += i.d0;
    _400 *= _399.d1;
    _400 += r;
    _400 *= _399.d2;
    _400 += f;
    int64_t _401 = _399.data[_400];
    int64_t _402 = _392 - _401;
    _390.d1 = _402;
    if (_402 > 0) 
    goto _jump3091;
    fail_assertion("non-positive loop bound");
    _jump3091:;
    // Computing bound for R
    _390.d2 = g;
    if (g > 0) 
    goto _jump3092;
    fail_assertion("non-positive loop bound");
    _jump3092:;
    // Computing total size of heap memory to allocate
    int64_t _403 = 1;
    _403 *= i.d0;
    _403 *= _402;
    _403 *= g;
    _403 *= sizeof(void_t);
    _390.data = jpl_alloc(_403);
    int64_t _404 = 0; // R
    int64_t _405 = 0; // Q
    int64_t _406 = 0; // P
    _jump3093:; // Begin body of loop
    bool _407 = false;
    _a1_bool _408;
    if (!_407)
    goto _jump3094;
    _a1_bool _409;
    // Computing bound for S
    _409.d0 = q;
    if (q > 0) 
    goto _jump3095;
    fail_assertion("non-positive loop bound");
    _jump3095:;
    // Computing total size of heap memory to allocate
    int64_t _410 = 1;
    _410 *= q;
    _410 *= sizeof(bool);
    _409.data = jpl_alloc(_410);
    int64_t _411 = 0; // S
    _jump3096:; // Begin body of loop
    bool _412 = _404 != x;
    int64_t _413 = 0;
    _413 *= _409.d0;
    _413 += _411;
    _409.data[_413] = _412;
    _411++;
    if (_411 < q)
    goto _jump3096;
    // End body of loop
    _408 = _409;
    goto _jump3097;
    _jump3094:;
    bool _414 = false;
    bool _415 = false;
    bool _416 = !_415;
    _a1_bool _417;
    _417.d0 = 2;
    _417.data = jpl_alloc(sizeof(bool) * 2);
    _417.data[0] = _414;
    _417.data[1] = _416;
    _408 = _417;
    _jump3097:;
    _a2_bool _418;
    // Computing bound for S
    _418.d0 = q;
    if (q > 0) 
    goto _jump3098;
    fail_assertion("non-positive loop bound");
    _jump3098:;
    // Computing bound for T
    _418.d1 = E.d0;
    if (E.d0 > 0) 
    goto _jump3099;
    fail_assertion("non-positive loop bound");
    _jump3099:;
    // Computing total size of heap memory to allocate
    int64_t _419 = 1;
    _419 *= q;
    _419 *= E.d0;
    _419 *= sizeof(bool);
    _418.data = jpl_alloc(_419);
    int64_t _420 = 0; // T
    int64_t _421 = 0; // S
    _jump3100:; // Begin body of loop
    bool _422 = true;
    int64_t _423 = 0;
    _423 *= _418.d0;
    _423 += _421;
    _423 *= _418.d1;
    _423 += _420;
    _418.data[_423] = _422;
    _420++;
    if (_420 < E.d0)
    goto _jump3100;
    _420 = 0;
    _421++;
    if (_421 < q)
    goto _jump3100;
    // End body of loop
    int64_t _424 = 921;
    int64_t _425 = -_424;
    if (_425 >= 0)
    goto _jump3101;
    fail_assertion("negative array index");
    _jump3101:;
    if (_425 < _418.d0)
    goto _jump3102;
    fail_assertion("index too large");
    _jump3102:;
    if (g >= 0)
    goto _jump3103;
    fail_assertion("negative array index");
    _jump3103:;
    if (g < _418.d1)
    goto _jump3104;
    fail_assertion("index too large");
    _jump3104:;
    int64_t _426 = 0;
    _426 *= _418.d0;
    _426 += _425;
    _426 *= _418.d1;
    _426 += g;
    bool _427 = _418.data[_426];
    _a1_bool _428;
    if (!_427)
    goto _jump3105;
    bool _430 = true;
    bool _429 = _430;
    if (0 != _430)
    goto _jump3106;
    bool _431 = true;
    _429 = _431;
    _jump3106:;
    bool _432 = true;
    _a1_bool _433;
    _433.d0 = 2;
    _433.data = jpl_alloc(sizeof(bool) * 2);
    _433.data[0] = _429;
    _433.data[1] = _432;
    _428 = _433;
    goto _jump3107;
    _jump3105:;
    bool _434 = true;
    bool _435 = n(A);
    _a1_bool _436;
    _436.d0 = 2;
    _436.data = jpl_alloc(sizeof(bool) * 2);
    _436.data[0] = _434;
    _436.data[1] = _435;
    _428 = _436;
    _jump3107:;
    void_t _437 = b(_408, _428);
    int64_t _438 = 0;
    _438 *= _390.d0;
    _438 += _406;
    _438 *= _390.d1;
    _438 += _405;
    _438 *= _390.d2;
    _438 += _404;
    _390.data[_438] = _437;
    _404++;
    if (_404 < g)
    goto _jump3093;
    _404 = 0;
    _405++;
    if (_405 < _402)
    goto _jump3093;
    _405 = 0;
    _406++;
    if (_406 < i.d0)
    goto _jump3093;
    // End body of loop
    _389 = _390;
    goto _jump3108;
    _jump3072:;
    bool _440 = true;
    bool _439 = _440;
    if (0 != _440)
    goto _jump3109;
    bool _441 = false;
    _439 = _441;
    _jump3109:;
    bool _442 = !_439;
    bool _443;
    if (!_442)
    goto _jump3110;
    _a3_bool _444;
    // Computing bound for P
    _444.d0 = h;
    if (h > 0) 
    goto _jump3111;
    fail_assertion("non-positive loop bound");
    _jump3111:;
    // Computing bound for Q
    _444.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump3112;
    fail_assertion("non-positive loop bound");
    _jump3112:;
    // Computing bound for R
    _444.d2 = h;
    if (h > 0) 
    goto _jump3113;
    fail_assertion("non-positive loop bound");
    _jump3113:;
    // Computing total size of heap memory to allocate
    int64_t _445 = 1;
    _445 *= h;
    _445 *= i.d0;
    _445 *= h;
    _445 *= sizeof(bool);
    _444.data = jpl_alloc(_445);
    int64_t _446 = 0; // R
    int64_t _447 = 0; // Q
    int64_t _448 = 0; // P
    _jump3114:; // Begin body of loop
    bool _449 = true;
    int64_t _450 = 0;
    _450 *= _444.d0;
    _450 += _448;
    _450 *= _444.d1;
    _450 += _447;
    _450 *= _444.d2;
    _450 += _446;
    _444.data[_450] = _449;
    _446++;
    if (_446 < h)
    goto _jump3114;
    _446 = 0;
    _447++;
    if (_447 < i.d0)
    goto _jump3114;
    _447 = 0;
    _448++;
    if (_448 < h)
    goto _jump3114;
    // End body of loop
    if (v >= 0)
    goto _jump3115;
    fail_assertion("negative array index");
    _jump3115:;
    if (v < _444.d0)
    goto _jump3116;
    fail_assertion("index too large");
    _jump3116:;
    if (r >= 0)
    goto _jump3117;
    fail_assertion("negative array index");
    _jump3117:;
    if (r < _444.d1)
    goto _jump3118;
    fail_assertion("index too large");
    _jump3118:;
    if (q >= 0)
    goto _jump3119;
    fail_assertion("negative array index");
    _jump3119:;
    if (q < _444.d2)
    goto _jump3120;
    fail_assertion("index too large");
    _jump3120:;
    int64_t _451 = 0;
    _451 *= _444.d0;
    _451 += v;
    _451 *= _444.d1;
    _451 += r;
    _451 *= _444.d2;
    _451 += q;
    bool _452 = _444.data[_451];
    _443 = _452;
    goto _jump3121;
    _jump3110:;
    if (A.d1 >= 0)
    goto _jump3122;
    fail_assertion("negative array index");
    _jump3122:;
    if (A.d1 < E.d0)
    goto _jump3123;
    fail_assertion("index too large");
    _jump3123:;
    if (i.d0 >= 0)
    goto _jump3124;
    fail_assertion("negative array index");
    _jump3124:;
    if (i.d0 < E.d1)
    goto _jump3125;
    fail_assertion("index too large");
    _jump3125:;
    int64_t _453 = 0;
    _453 *= E.d0;
    _453 += A.d1;
    _453 *= E.d1;
    _453 += i.d0;
    double _454 = E.data[_453];
    if (j >= 0)
    goto _jump3126;
    fail_assertion("negative array index");
    _jump3126:;
    if (j < A.d0)
    goto _jump3127;
    fail_assertion("index too large");
    _jump3127:;
    if (u >= 0)
    goto _jump3128;
    fail_assertion("negative array index");
    _jump3128:;
    if (u < A.d1)
    goto _jump3129;
    fail_assertion("index too large");
    _jump3129:;
    if (_269.d0 >= 0)
    goto _jump3130;
    fail_assertion("negative array index");
    _jump3130:;
    if (_269.d0 < A.d2)
    goto _jump3131;
    fail_assertion("index too large");
    _jump3131:;
    int64_t _455 = 0;
    _455 *= A.d0;
    _455 += j;
    _455 *= A.d1;
    _455 += u;
    _455 *= A.d2;
    _455 += _269.d0;
    double _456 = A.data[_455];
    bool _457 = _454 > _456;
    _443 = _457;
    _jump3121:;
    bool _458;
    if (!_443)
    goto _jump3132;
    bool _459 = n(A);
    bool _460;
    if (!_459)
    goto _jump3133;
    bool _461 = n(A);
    bool _462;
    if (!_461)
    goto _jump3134;
    bool _463 = g >= f;
    _462 = _463;
    goto _jump3135;
    _jump3134:;
    bool _464 = f == i.d0;
    _462 = _464;
    _jump3135:;
    _460 = _462;
    goto _jump3136;
    _jump3133:;
    bool _465 = false;
    _460 = _465;
    _jump3136:;
    _458 = _460;
    goto _jump3137;
    _jump3132:;
    double _466 = 81.0;
    double _467 = 53.0;
    bool _468 = _466 <= _467;
    _458 = _468;
    _jump3137:;
    _a3_void_t _469;
    if (!_458)
    goto _jump3138;
    bool _470 = _269.d0 != x;
    double _471 = 35.0;
    double _472 = 50.0;
    bool _473 = _471 < _472;
    bool _474 = E.d1 != A.d1;
    _a1_bool _475;
    _475.d0 = 3;
    _475.data = jpl_alloc(sizeof(bool) * 3);
    _475.data[0] = _470;
    _475.data[1] = _473;
    _475.data[2] = _474;
    if (g >= 0)
    goto _jump3139;
    fail_assertion("negative array index");
    _jump3139:;
    if (g < _475.d0)
    goto _jump3140;
    fail_assertion("index too large");
    _jump3140:;
    int64_t _476 = 0;
    _476 *= _475.d0;
    _476 += g;
    bool _477 = _475.data[_476];
    _a3_void_t _478;
    if (!_477)
    goto _jump3141;
    _a2__a2__a3_void_t _479;
    // Computing bound for P
    _479.d0 = r;
    if (r > 0) 
    goto _jump3142;
    fail_assertion("non-positive loop bound");
    _jump3142:;
    // Computing bound for Q
    _479.d1 = v;
    if (v > 0) 
    goto _jump3143;
    fail_assertion("non-positive loop bound");
    _jump3143:;
    // Computing total size of heap memory to allocate
    int64_t _480 = 1;
    _480 *= r;
    _480 *= v;
    _480 *= sizeof(_a2__a3_void_t);
    _479.data = jpl_alloc(_480);
    int64_t _481 = 0; // Q
    int64_t _482 = 0; // P
    _jump3144:; // Begin body of loop
    int64_t _483 = 0;
    _483 *= _479.d0;
    _483 += _482;
    _483 *= _479.d1;
    _483 += _481;
    _479.data[_483] = H;
    _481++;
    if (_481 < v)
    goto _jump3144;
    _481 = 0;
    _482++;
    if (_482 < r)
    goto _jump3144;
    // End body of loop
    if (f >= 0)
    goto _jump3145;
    fail_assertion("negative array index");
    _jump3145:;
    if (f < _479.d0)
    goto _jump3146;
    fail_assertion("index too large");
    _jump3146:;
    if (E.d0 >= 0)
    goto _jump3147;
    fail_assertion("negative array index");
    _jump3147:;
    if (E.d0 < _479.d1)
    goto _jump3148;
    fail_assertion("index too large");
    _jump3148:;
    int64_t _484 = 0;
    _484 *= _479.d0;
    _484 += f;
    _484 *= _479.d1;
    _484 += E.d0;
    _a2__a3_void_t _485 = _479.data[_484];
    int64_t _486;
    // Computing bound for P
    if (A.d0 > 0) 
    goto _jump3149;
    fail_assertion("non-positive loop bound");
    _jump3149:;
    // Computing bound for Q
    if (E.d1 > 0) 
    goto _jump3150;
    fail_assertion("non-positive loop bound");
    _jump3150:;
    _486 = 0;
    int64_t _487 = 0; // Q
    int64_t _488 = 0; // P
    _jump3151:; // Begin body of loop
    _486 += r;
    _487++;
    if (_487 < E.d1)
    goto _jump3151;
    _487 = 0;
    _488++;
    if (_488 < A.d0)
    goto _jump3151;
    // End body of loop
    if (_486 >= 0)
    goto _jump3152;
    fail_assertion("negative array index");
    _jump3152:;
    if (_486 < _485.d0)
    goto _jump3153;
    fail_assertion("index too large");
    _jump3153:;
    if (x >= 0)
    goto _jump3154;
    fail_assertion("negative array index");
    _jump3154:;
    if (x < _485.d1)
    goto _jump3155;
    fail_assertion("index too large");
    _jump3155:;
    int64_t _489 = 0;
    _489 *= _485.d0;
    _489 += _486;
    _489 *= _485.d1;
    _489 += x;
    _a3_void_t _490 = _485.data[_489];
    _478 = _490;
    goto _jump3156;
    _jump3141:;
    _a1__a3_void_t _491;
    // Computing bound for P
    _491.d0 = E.d1;
    if (E.d1 > 0) 
    goto _jump3157;
    fail_assertion("non-positive loop bound");
    _jump3157:;
    // Computing total size of heap memory to allocate
    int64_t _492 = 1;
    _492 *= E.d1;
    _492 *= sizeof(_a3_void_t);
    _491.data = jpl_alloc(_492);
    int64_t _493 = 0; // P
    _jump3158:; // Begin body of loop
    if (g >= 0)
    goto _jump3159;
    fail_assertion("negative array index");
    _jump3159:;
    if (g < H.d0)
    goto _jump3160;
    fail_assertion("index too large");
    _jump3160:;
    if (i.d0 >= 0)
    goto _jump3161;
    fail_assertion("negative array index");
    _jump3161:;
    if (i.d0 < H.d1)
    goto _jump3162;
    fail_assertion("index too large");
    _jump3162:;
    int64_t _494 = 0;
    _494 *= H.d0;
    _494 += g;
    _494 *= H.d1;
    _494 += i.d0;
    _a3_void_t _495 = H.data[_494];
    int64_t _496 = 0;
    _496 *= _491.d0;
    _496 += _493;
    _491.data[_496] = _495;
    _493++;
    if (_493 < E.d1)
    goto _jump3158;
    // End body of loop
    if (i.d1 >= 0)
    goto _jump3163;
    fail_assertion("negative array index");
    _jump3163:;
    if (i.d1 < _491.d0)
    goto _jump3164;
    fail_assertion("index too large");
    _jump3164:;
    int64_t _497 = 0;
    _497 *= _491.d0;
    _497 += i.d1;
    _a3_void_t _498 = _491.data[_497];
    _478 = _498;
    _jump3156:;
    _469 = _478;
    goto _jump3165;
    _jump3138:;
    _a3_void_t _499;
    // Computing bound for P
    bool _500 = false;
    int64_t _501;
    if (!_500)
    goto _jump3166;
    _501 = j;
    goto _jump3167;
    _jump3166:;
    int64_t _502 = -k;
    _501 = _502;
    _jump3167:;
    int64_t _503 = i.d0 / _501;
    _499.d0 = _503;
    if (_503 > 0) 
    goto _jump3168;
    fail_assertion("non-positive loop bound");
    _jump3168:;
    // Computing bound for Q
    _499.d1 = k;
    if (k > 0) 
    goto _jump3169;
    fail_assertion("non-positive loop bound");
    _jump3169:;
    // Computing bound for R
    _499.d2 = A.d1;
    if (A.d1 > 0) 
    goto _jump3170;
    fail_assertion("non-positive loop bound");
    _jump3170:;
    // Computing total size of heap memory to allocate
    int64_t _504 = 1;
    _504 *= _503;
    _504 *= k;
    _504 *= A.d1;
    _504 *= sizeof(void_t);
    _499.data = jpl_alloc(_504);
    int64_t _505 = 0; // R
    int64_t _506 = 0; // Q
    int64_t _507 = 0; // P
    _jump3171:; // Begin body of loop
    bool _508 = false;
    _a3_double _509;
    if (!_508)
    goto _jump3172;
    _509 = A;
    goto _jump3173;
    _jump3172:;
    _509 = A;
    _jump3173:;
    _a2_double _510;
    // Computing bound for S
    _510.d0 = x;
    if (x > 0) 
    goto _jump3174;
    fail_assertion("non-positive loop bound");
    _jump3174:;
    // Computing bound for T
    _510.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump3175;
    fail_assertion("non-positive loop bound");
    _jump3175:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= x;
    _511 *= i.d1;
    _511 *= sizeof(double);
    _510.data = jpl_alloc(_511);
    int64_t _512 = 0; // T
    int64_t _513 = 0; // S
    _jump3176:; // Begin body of loop
    double _514 = 70.0;
    int64_t _515 = 0;
    _515 *= _510.d0;
    _515 += _513;
    _515 *= _510.d1;
    _515 += _512;
    _510.data[_515] = _514;
    _512++;
    if (_512 < i.d1)
    goto _jump3176;
    _512 = 0;
    _513++;
    if (_513 < x)
    goto _jump3176;
    // End body of loop
    _a2__a3_void_t _516;
    // Computing bound for S
    _516.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump3177;
    fail_assertion("non-positive loop bound");
    _jump3177:;
    // Computing bound for T
    _516.d1 = A.d0;
    if (A.d0 > 0) 
    goto _jump3178;
    fail_assertion("non-positive loop bound");
    _jump3178:;
    // Computing total size of heap memory to allocate
    int64_t _517 = 1;
    _517 *= i.d0;
    _517 *= A.d0;
    _517 *= sizeof(_a3_void_t);
    _516.data = jpl_alloc(_517);
    int64_t _518 = 0; // T
    int64_t _519 = 0; // S
    _jump3179:; // Begin body of loop
    if (E.d1 >= 0)
    goto _jump3180;
    fail_assertion("negative array index");
    _jump3180:;
    if (E.d1 < H.d0)
    goto _jump3181;
    fail_assertion("index too large");
    _jump3181:;
    if (x >= 0)
    goto _jump3182;
    fail_assertion("negative array index");
    _jump3182:;
    if (x < H.d1)
    goto _jump3183;
    fail_assertion("index too large");
    _jump3183:;
    int64_t _520 = 0;
    _520 *= H.d0;
    _520 += E.d1;
    _520 *= H.d1;
    _520 += x;
    _a3_void_t _521 = H.data[_520];
    int64_t _522 = 0;
    _522 *= _516.d0;
    _522 += _519;
    _522 *= _516.d1;
    _522 += _518;
    _516.data[_522] = _521;
    _518++;
    if (_518 < A.d0)
    goto _jump3179;
    _518 = 0;
    _519++;
    if (_519 < i.d0)
    goto _jump3179;
    // End body of loop
    void_t _523 = z(_509, _510, _516);
    int64_t _524 = 0;
    _524 *= _499.d0;
    _524 += _507;
    _524 *= _499.d1;
    _524 += _506;
    _524 *= _499.d2;
    _524 += _505;
    _499.data[_524] = _523;
    _505++;
    if (_505 < A.d1)
    goto _jump3171;
    _505 = 0;
    _506++;
    if (_506 < k)
    goto _jump3171;
    _506 = 0;
    _507++;
    if (_507 < _503)
    goto _jump3171;
    // End body of loop
    _469 = _499;
    _jump3165:;
    _389 = _469;
    _jump3108:;
    int64_t _525 = i.d1 * u;
    if (_525 >= 0)
    goto _jump3184;
    fail_assertion("negative array index");
    _jump3184:;
    if (_525 < _389.d0)
    goto _jump3185;
    fail_assertion("index too large");
    _jump3185:;
    if (E.d0 >= 0)
    goto _jump3186;
    fail_assertion("negative array index");
    _jump3186:;
    if (E.d0 < _389.d1)
    goto _jump3187;
    fail_assertion("index too large");
    _jump3187:;
    if (i.d1 >= 0)
    goto _jump3188;
    fail_assertion("negative array index");
    _jump3188:;
    if (i.d1 < _389.d2)
    goto _jump3189;
    fail_assertion("index too large");
    _jump3189:;
    int64_t _526 = 0;
    _526 *= _389.d0;
    _526 += _525;
    _526 *= _389.d1;
    _526 += E.d0;
    _526 *= _389.d2;
    _526 += i.d1;
    void_t _527 = _389.data[_526];
    return _527;
}

_a3__a2_void_t C(void_t D) {
    _a3__a1_bool _0;
    // Computing bound for E
    _0.d0 = x;
    if (x > 0) 
    goto _jump3213;
    fail_assertion("non-positive loop bound");
    _jump3213:;
    // Computing bound for F
    bool _2 = false;
    bool _1 = _2;
    if (0 == _2)
    goto _jump3214;
    bool _3 = true;
    _1 = _3;
    _jump3214:;
    int64_t _4;
    if (!_1)
    goto _jump3215;
    int64_t _5;
    // Computing bound for E
    if (r > 0) 
    goto _jump3216;
    fail_assertion("non-positive loop bound");
    _jump3216:;
    // Computing bound for F
    if (x > 0) 
    goto _jump3217;
    fail_assertion("non-positive loop bound");
    _jump3217:;
    _5 = 0;
    int64_t _6 = 0; // F
    int64_t _7 = 0; // E
    _jump3218:; // Begin body of loop
    _5 += q;
    _6++;
    if (_6 < x)
    goto _jump3218;
    _6 = 0;
    _7++;
    if (_7 < r)
    goto _jump3218;
    // End body of loop
    int64_t _8 = -r;
    int64_t _9 = _5 * _8;
    _4 = _9;
    goto _jump3219;
    _jump3215:;
    int64_t _10 = 553;
    int64_t _11 = _10 / x;
    _4 = _11;
    _jump3219:;
    _0.d1 = _4;
    if (_4 > 0) 
    goto _jump3220;
    fail_assertion("non-positive loop bound");
    _jump3220:;
    // Computing bound for G
    _a2_int64_t _12;
    // Computing bound for E
    int64_t _13;
    // Computing bound for E
    if (k > 0) 
    goto _jump3221;
    fail_assertion("non-positive loop bound");
    _jump3221:;
    // Computing bound for F
    if (u > 0) 
    goto _jump3222;
    fail_assertion("non-positive loop bound");
    _jump3222:;
    _13 = 0;
    int64_t _14 = 0; // F
    int64_t _15 = 0; // E
    _jump3223:; // Begin body of loop
    _13 += v;
    _14++;
    if (_14 < u)
    goto _jump3223;
    _14 = 0;
    _15++;
    if (_15 < k)
    goto _jump3223;
    // End body of loop
    _12.d0 = _13;
    if (_13 > 0) 
    goto _jump3224;
    fail_assertion("non-positive loop bound");
    _jump3224:;
    // Computing bound for F
    _12.d1 = g;
    if (g > 0) 
    goto _jump3225;
    fail_assertion("non-positive loop bound");
    _jump3225:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _13;
    _16 *= g;
    _16 *= sizeof(int64_t);
    _12.data = jpl_alloc(_16);
    int64_t _17 = 0; // F
    int64_t _18 = 0; // E
    _jump3226:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _12.d0;
    _19 += _18;
    _19 *= _12.d1;
    _19 += _17;
    _12.data[_19] = f;
    _17++;
    if (_17 < g)
    goto _jump3226;
    _17 = 0;
    _18++;
    if (_18 < _13)
    goto _jump3226;
    // End body of loop
    if (g >= 0)
    goto _jump3227;
    fail_assertion("negative array index");
    _jump3227:;
    if (g < _12.d0)
    goto _jump3228;
    fail_assertion("index too large");
    _jump3228:;
    if (q >= 0)
    goto _jump3229;
    fail_assertion("negative array index");
    _jump3229:;
    if (q < _12.d1)
    goto _jump3230;
    fail_assertion("index too large");
    _jump3230:;
    int64_t _20 = 0;
    _20 *= _12.d0;
    _20 += g;
    _20 *= _12.d1;
    _20 += q;
    int64_t _21 = _12.data[_20];
    _0.d2 = _21;
    if (_21 > 0) 
    goto _jump3231;
    fail_assertion("non-positive loop bound");
    _jump3231:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= x;
    _22 *= _4;
    _22 *= _21;
    _22 *= sizeof(_a1_bool);
    _0.data = jpl_alloc(_22);
    int64_t _23 = 0; // G
    int64_t _24 = 0; // F
    int64_t _25 = 0; // E
    _jump3232:; // Begin body of loop
    _a1_bool _26;
    // Computing bound for H
    _26.d0 = f;
    if (f > 0) 
    goto _jump3233;
    fail_assertion("non-positive loop bound");
    _jump3233:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= f;
    _27 *= sizeof(bool);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // H
    _jump3234:; // Begin body of loop
    bool _29 = h == _24;
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += _28;
    _26.data[_30] = _29;
    _28++;
    if (_28 < f)
    goto _jump3234;
    // End body of loop
    int64_t _31 = 0;
    _31 *= _0.d0;
    _31 += _25;
    _31 *= _0.d1;
    _31 += _24;
    _31 *= _0.d2;
    _31 += _23;
    _0.data[_31] = _26;
    _23++;
    if (_23 < _21)
    goto _jump3232;
    _23 = 0;
    _24++;
    if (_24 < _4)
    goto _jump3232;
    _24 = 0;
    _25++;
    if (_25 < x)
    goto _jump3232;
    // End body of loop
    if (q >= 0)
    goto _jump3235;
    fail_assertion("negative array index");
    _jump3235:;
    if (q < _0.d0)
    goto _jump3236;
    fail_assertion("index too large");
    _jump3236:;
    if (r >= 0)
    goto _jump3237;
    fail_assertion("negative array index");
    _jump3237:;
    if (r < _0.d1)
    goto _jump3238;
    fail_assertion("index too large");
    _jump3238:;
    if (x >= 0)
    goto _jump3239;
    fail_assertion("negative array index");
    _jump3239:;
    if (x < _0.d2)
    goto _jump3240;
    fail_assertion("index too large");
    _jump3240:;
    int64_t _32 = 0;
    _32 *= _0.d0;
    _32 += q;
    _32 *= _0.d1;
    _32 += r;
    _32 *= _0.d2;
    _32 += x;
    _a1_bool _33 = _0.data[_32];
    _a1__a1_bool _34;
    // Computing bound for E
    bool _35 = true;
    _a1_int64_t _36;
    if (!_35)
    goto _jump3241;
    _a1_int64_t _37;
    // Computing bound for E
    _37.d0 = u;
    if (u > 0) 
    goto _jump3242;
    fail_assertion("non-positive loop bound");
    _jump3242:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= u;
    _38 *= sizeof(int64_t);
    _37.data = jpl_alloc(_38);
    int64_t _39 = 0; // E
    _jump3243:; // Begin body of loop
    int64_t _40 = 0;
    _40 *= _37.d0;
    _40 += _39;
    _37.data[_40] = r;
    _39++;
    if (_39 < u)
    goto _jump3243;
    // End body of loop
    _36 = _37;
    goto _jump3244;
    _jump3241:;
    _a1_int64_t _41;
    // Computing bound for E
    _41.d0 = k;
    if (k > 0) 
    goto _jump3245;
    fail_assertion("non-positive loop bound");
    _jump3245:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= k;
    _42 *= sizeof(int64_t);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // E
    _jump3246:; // Begin body of loop
    int64_t _44 = 0;
    _44 *= _41.d0;
    _44 += _43;
    _41.data[_44] = r;
    _43++;
    if (_43 < k)
    goto _jump3246;
    // End body of loop
    _36 = _41;
    _jump3244:;
    if (v >= 0)
    goto _jump3247;
    fail_assertion("negative array index");
    _jump3247:;
    if (v < _36.d0)
    goto _jump3248;
    fail_assertion("index too large");
    _jump3248:;
    int64_t _45 = 0;
    _45 *= _36.d0;
    _45 += v;
    int64_t _46 = _36.data[_45];
    _34.d0 = _46;
    if (_46 > 0) 
    goto _jump3249;
    fail_assertion("non-positive loop bound");
    _jump3249:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= _46;
    _47 *= sizeof(_a1_bool);
    _34.data = jpl_alloc(_47);
    int64_t _48 = 0; // E
    _jump3250:; // Begin body of loop
    bool _49 = true;
    bool _50;
    if (!_49)
    goto _jump3251;
    bool _51 = false;
    _50 = _51;
    goto _jump3252;
    _jump3251:;
    bool _52 = true;
    _50 = _52;
    _jump3252:;
    bool _53 = _48 <= k;
    bool _54 = _50 != _53;
    _a1_bool _55;
    if (!_54)
    goto _jump3253;
    _a1_bool _56;
    // Computing bound for F
    _56.d0 = r;
    if (r > 0) 
    goto _jump3254;
    fail_assertion("non-positive loop bound");
    _jump3254:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= r;
    _57 *= sizeof(bool);
    _56.data = jpl_alloc(_57);
    int64_t _58 = 0; // F
    _jump3255:; // Begin body of loop
    bool _60 = true;
    bool _59 = _60;
    if (0 == _60)
    goto _jump3256;
    bool _61 = false;
    _59 = _61;
    _jump3256:;
    int64_t _62 = 0;
    _62 *= _56.d0;
    _62 += _58;
    _56.data[_62] = _59;
    _58++;
    if (_58 < r)
    goto _jump3255;
    // End body of loop
    _55 = _56;
    goto _jump3257;
    _jump3253:;
    _a1_bool _63;
    // Computing bound for F
    _63.d0 = _48;
    if (_48 > 0) 
    goto _jump3258;
    fail_assertion("non-positive loop bound");
    _jump3258:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= _48;
    _64 *= sizeof(bool);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // F
    _jump3259:; // Begin body of loop
    int64_t _66 = 971;
    bool _67 = _66 <= v;
    int64_t _68 = 0;
    _68 *= _63.d0;
    _68 += _65;
    _63.data[_68] = _67;
    _65++;
    if (_65 < _48)
    goto _jump3259;
    // End body of loop
    _55 = _63;
    _jump3257:;
    int64_t _69 = 0;
    _69 *= _34.d0;
    _69 += _48;
    _34.data[_69] = _55;
    _48++;
    if (_48 < _46)
    goto _jump3250;
    // End body of loop
    if (h >= 0)
    goto _jump3260;
    fail_assertion("negative array index");
    _jump3260:;
    if (h < _34.d0)
    goto _jump3261;
    fail_assertion("index too large");
    _jump3261:;
    int64_t _70 = 0;
    _70 *= _34.d0;
    _70 += h;
    _a1_bool _71 = _34.data[_70];
    void_t _72 = b(_33, _71);
    _a3__a2_void_t _73 = C(_72);
    return _73;
    _a1__a1_double _74;
    // Computing bound for E
    double _75 = 20.0;
    _a3_double _76;
    // Computing bound for E
    _76.d0 = g;
    if (g > 0) 
    goto _jump3262;
    fail_assertion("non-positive loop bound");
    _jump3262:;
    // Computing bound for F
    _76.d1 = k;
    if (k > 0) 
    goto _jump3263;
    fail_assertion("non-positive loop bound");
    _jump3263:;
    // Computing bound for G
    _76.d2 = r;
    if (r > 0) 
    goto _jump3264;
    fail_assertion("non-positive loop bound");
    _jump3264:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= g;
    _77 *= k;
    _77 *= r;
    _77 *= sizeof(double);
    _76.data = jpl_alloc(_77);
    int64_t _78 = 0; // G
    int64_t _79 = 0; // F
    int64_t _80 = 0; // E
    _jump3265:; // Begin body of loop
    double _81 = 15.0;
    int64_t _82 = 0;
    _82 *= _76.d0;
    _82 += _80;
    _82 *= _76.d1;
    _82 += _79;
    _82 *= _76.d2;
    _82 += _78;
    _76.data[_82] = _81;
    _78++;
    if (_78 < r)
    goto _jump3265;
    _78 = 0;
    _79++;
    if (_79 < k)
    goto _jump3265;
    _79 = 0;
    _80++;
    if (_80 < g)
    goto _jump3265;
    // End body of loop
    bool _83 = true;
    bool _84 = !_83;
    double _85;
    if (!_84)
    goto _jump3266;
    double _86 = 43.0;
    _85 = _86;
    goto _jump3267;
    _jump3266:;
    double _87 = 54.0;
    double _88 = -_87;
    _85 = _88;
    _jump3267:;
    double _89 = 84.0;
    double _90 = 27.0;
    double _91 = _89 * _90;
    bool _92 = _85 > _91;
    double _93 = s(_76, _92, i);
    bool _94 = _75 == _93;
    int64_t _95;
    if (!_94)
    goto _jump3268;
    _95 = j;
    goto _jump3269;
    _jump3268:;
    _95 = r;
    _jump3269:;
    _74.d0 = _95;
    if (_95 > 0) 
    goto _jump3270;
    fail_assertion("non-positive loop bound");
    _jump3270:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= _95;
    _96 *= sizeof(_a1_double);
    _74.data = jpl_alloc(_96);
    int64_t _97 = 0; // E
    _jump3271:; // Begin body of loop
    int64_t _98 = 0;
    _98 *= _74.d0;
    _98 += _97;
    _74.data[_98] = l;
    _97++;
    if (_97 < _95)
    goto _jump3271;
    // End body of loop
    bool _99 = v == h;
    if (0 != _99)
    goto _jump3272;
    fail_assertion("G");
    _jump3272:;
    _a3__a3_double _100;
    // Computing bound for G
    _100.d0 = x;
    if (x > 0) 
    goto _jump3273;
    fail_assertion("non-positive loop bound");
    _jump3273:;
    // Computing bound for H
    _100.d1 = g;
    if (g > 0) 
    goto _jump3274;
    fail_assertion("non-positive loop bound");
    _jump3274:;
    // Computing bound for I
    bool _102 = _74.d0 != x;
    bool _101 = _102;
    if (0 != _102)
    goto _jump3275;
    bool _103 = false;
    bool _104 = !_103;
    _101 = _104;
    _jump3275:;
    int64_t _105;
    if (!_101)
    goto _jump3276;
    int64_t _106;
    // Computing bound for G
    if (g > 0) 
    goto _jump3277;
    fail_assertion("non-positive loop bound");
    _jump3277:;
    // Computing bound for H
    if (u > 0) 
    goto _jump3278;
    fail_assertion("non-positive loop bound");
    _jump3278:;
    _106 = 0;
    int64_t _107 = 0; // H
    int64_t _108 = 0; // G
    _jump3279:; // Begin body of loop
    int64_t _109 = -j;
    _106 += _109;
    _107++;
    if (_107 < u)
    goto _jump3279;
    _107 = 0;
    _108++;
    if (_108 < g)
    goto _jump3279;
    // End body of loop
    _105 = _106;
    goto _jump3280;
    _jump3276:;
    _a2_bool _110;
    // Computing bound for G
    _110.d0 = x;
    if (x > 0) 
    goto _jump3281;
    fail_assertion("non-positive loop bound");
    _jump3281:;
    // Computing bound for H
    _110.d1 = q;
    if (q > 0) 
    goto _jump3282;
    fail_assertion("non-positive loop bound");
    _jump3282:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= x;
    _111 *= q;
    _111 *= sizeof(bool);
    _110.data = jpl_alloc(_111);
    int64_t _112 = 0; // H
    int64_t _113 = 0; // G
    _jump3283:; // Begin body of loop
    bool _114 = false;
    int64_t _115 = 0;
    _115 *= _110.d0;
    _115 += _113;
    _115 *= _110.d1;
    _115 += _112;
    _110.data[_115] = _114;
    _112++;
    if (_112 < q)
    goto _jump3283;
    _112 = 0;
    _113++;
    if (_113 < x)
    goto _jump3283;
    // End body of loop
    int64_t _116 = a(_110, D);
    _105 = _116;
    _jump3280:;
    _100.d2 = _105;
    if (_105 > 0) 
    goto _jump3284;
    fail_assertion("non-positive loop bound");
    _jump3284:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= x;
    _117 *= g;
    _117 *= _105;
    _117 *= sizeof(_a3_double);
    _100.data = jpl_alloc(_117);
    int64_t _118 = 0; // I
    int64_t _119 = 0; // H
    int64_t _120 = 0; // G
    _jump3285:; // Begin body of loop
    bool _121 = f != _119;
    _a3_double _122;
    if (!_121)
    goto _jump3286;
    _a3_double _123;
    // Computing bound for J
    _123.d0 = g;
    if (g > 0) 
    goto _jump3287;
    fail_assertion("non-positive loop bound");
    _jump3287:;
    // Computing bound for K
    _123.d1 = g;
    if (g > 0) 
    goto _jump3288;
    fail_assertion("non-positive loop bound");
    _jump3288:;
    // Computing bound for L
    _123.d2 = v;
    if (v > 0) 
    goto _jump3289;
    fail_assertion("non-positive loop bound");
    _jump3289:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= g;
    _124 *= g;
    _124 *= v;
    _124 *= sizeof(double);
    _123.data = jpl_alloc(_124);
    int64_t _125 = 0; // L
    int64_t _126 = 0; // K
    int64_t _127 = 0; // J
    _jump3290:; // Begin body of loop
    int64_t _128 = 700;
    if (_128 >= 0)
    goto _jump3291;
    fail_assertion("negative array index");
    _jump3291:;
    if (_128 < l.d0)
    goto _jump3292;
    fail_assertion("index too large");
    _jump3292:;
    int64_t _129 = 0;
    _129 *= l.d0;
    _129 += _128;
    double _130 = l.data[_129];
    int64_t _131 = 0;
    _131 *= _123.d0;
    _131 += _127;
    _131 *= _123.d1;
    _131 += _126;
    _131 *= _123.d2;
    _131 += _125;
    _123.data[_131] = _130;
    _125++;
    if (_125 < v)
    goto _jump3290;
    _125 = 0;
    _126++;
    if (_126 < g)
    goto _jump3290;
    _126 = 0;
    _127++;
    if (_127 < g)
    goto _jump3290;
    // End body of loop
    _122 = _123;
    goto _jump3293;
    _jump3286:;
    _a3_double _132;
    // Computing bound for J
    _132.d0 = j;
    if (j > 0) 
    goto _jump3294;
    fail_assertion("non-positive loop bound");
    _jump3294:;
    // Computing bound for K
    _132.d1 = _74.d0;
    if (_74.d0 > 0) 
    goto _jump3295;
    fail_assertion("non-positive loop bound");
    _jump3295:;
    // Computing bound for L
    int64_t _133;
    // Computing bound for J
    if (r > 0) 
    goto _jump3296;
    fail_assertion("non-positive loop bound");
    _jump3296:;
    // Computing bound for K
    if (x > 0) 
    goto _jump3297;
    fail_assertion("non-positive loop bound");
    _jump3297:;
    _133 = 0;
    int64_t _134 = 0; // K
    int64_t _135 = 0; // J
    _jump3298:; // Begin body of loop
    _133 += u;
    _134++;
    if (_134 < x)
    goto _jump3298;
    _134 = 0;
    _135++;
    if (_135 < r)
    goto _jump3298;
    // End body of loop
    _132.d2 = _133;
    if (_133 > 0) 
    goto _jump3299;
    fail_assertion("non-positive loop bound");
    _jump3299:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= j;
    _136 *= _74.d0;
    _136 *= _133;
    _136 *= sizeof(double);
    _132.data = jpl_alloc(_136);
    int64_t _137 = 0; // L
    int64_t _138 = 0; // K
    int64_t _139 = 0; // J
    _jump3300:; // Begin body of loop
    double _140;
    // Computing bound for M
    if (u > 0) 
    goto _jump3301;
    fail_assertion("non-positive loop bound");
    _jump3301:;
    _140 = 0;
    int64_t _141 = 0; // M
    _jump3302:; // Begin body of loop
    double _142 = 94.0;
    _140 += _142;
    _141++;
    if (_141 < u)
    goto _jump3302;
    // End body of loop
    int64_t _143 = 0;
    _143 *= _132.d0;
    _143 += _139;
    _143 *= _132.d1;
    _143 += _138;
    _143 *= _132.d2;
    _143 += _137;
    _132.data[_143] = _140;
    _137++;
    if (_137 < _133)
    goto _jump3300;
    _137 = 0;
    _138++;
    if (_138 < _74.d0)
    goto _jump3300;
    _138 = 0;
    _139++;
    if (_139 < j)
    goto _jump3300;
    // End body of loop
    _122 = _132;
    _jump3293:;
    int64_t _144 = 0;
    _144 *= _100.d0;
    _144 += _120;
    _144 *= _100.d1;
    _144 += _119;
    _144 *= _100.d2;
    _144 += _118;
    _100.data[_144] = _122;
    _118++;
    if (_118 < _105)
    goto _jump3285;
    _118 = 0;
    _119++;
    if (_119 < g)
    goto _jump3285;
    _119 = 0;
    _120++;
    if (_120 < x)
    goto _jump3285;
    // End body of loop
    _a2_bool _145;
    // Computing bound for G
    _145.d0 = g;
    if (g > 0) 
    goto _jump3303;
    fail_assertion("non-positive loop bound");
    _jump3303:;
    // Computing bound for H
    _145.d1 = f;
    if (f > 0) 
    goto _jump3304;
    fail_assertion("non-positive loop bound");
    _jump3304:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= g;
    _146 *= f;
    _146 *= sizeof(bool);
    _145.data = jpl_alloc(_146);
    int64_t _147 = 0; // H
    int64_t _148 = 0; // G
    _jump3305:; // Begin body of loop
    bool _149 = false;
    int64_t _150 = 0;
    _150 *= _145.d0;
    _150 += _148;
    _150 *= _145.d1;
    _150 += _147;
    _145.data[_150] = _149;
    _147++;
    if (_147 < f)
    goto _jump3305;
    _147 = 0;
    _148++;
    if (_148 < g)
    goto _jump3305;
    // End body of loop
    int64_t _151 = a(_145, D);
    if (_151 >= 0)
    goto _jump3306;
    fail_assertion("negative array index");
    _jump3306:;
    if (_151 < _100.d0)
    goto _jump3307;
    fail_assertion("index too large");
    _jump3307:;
    if (f >= 0)
    goto _jump3308;
    fail_assertion("negative array index");
    _jump3308:;
    if (f < _100.d1)
    goto _jump3309;
    fail_assertion("index too large");
    _jump3309:;
    if (f >= 0)
    goto _jump3310;
    fail_assertion("negative array index");
    _jump3310:;
    if (f < _100.d2)
    goto _jump3311;
    fail_assertion("index too large");
    _jump3311:;
    int64_t _152 = 0;
    _152 *= _100.d0;
    _152 += _151;
    _152 *= _100.d1;
    _152 += f;
    _152 *= _100.d2;
    _152 += f;
    _a3_double _153 = _100.data[_152];
    bool _154 = true;
    _a2_double _155;
    if (!_154)
    goto _jump3312;
    bool _156 = false;
    bool _157 = !_156;
    bool _158 = false;
    bool _159 = _157 != _158;
    _a2_double _160;
    if (!_159)
    goto _jump3313;
    bool _161 = false;
    _a2_double _162;
    if (!_161)
    goto _jump3314;
    _a2_double _163;
    // Computing bound for G
    _163.d0 = k;
    if (k > 0) 
    goto _jump3315;
    fail_assertion("non-positive loop bound");
    _jump3315:;
    // Computing bound for H
    _163.d1 = x;
    if (x > 0) 
    goto _jump3316;
    fail_assertion("non-positive loop bound");
    _jump3316:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= k;
    _164 *= x;
    _164 *= sizeof(double);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // H
    int64_t _166 = 0; // G
    _jump3317:; // Begin body of loop
    double _167 = 95.0;
    double _168 = -_167;
    int64_t _169 = 0;
    _169 *= _163.d0;
    _169 += _166;
    _169 *= _163.d1;
    _169 += _165;
    _163.data[_169] = _168;
    _165++;
    if (_165 < x)
    goto _jump3317;
    _165 = 0;
    _166++;
    if (_166 < k)
    goto _jump3317;
    // End body of loop
    _162 = _163;
    goto _jump3318;
    _jump3314:;
    _a2_double _170;
    // Computing bound for G
    int64_t _171 = f * r;
    _170.d0 = _171;
    if (_171 > 0) 
    goto _jump3319;
    fail_assertion("non-positive loop bound");
    _jump3319:;
    // Computing bound for H
    _170.d1 = r;
    if (r > 0) 
    goto _jump3320;
    fail_assertion("non-positive loop bound");
    _jump3320:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= _171;
    _172 *= r;
    _172 *= sizeof(double);
    _170.data = jpl_alloc(_172);
    int64_t _173 = 0; // H
    int64_t _174 = 0; // G
    _jump3321:; // Begin body of loop
    double _175 = 19.0;
    int64_t _176 = 0;
    _176 *= _170.d0;
    _176 += _174;
    _176 *= _170.d1;
    _176 += _173;
    _170.data[_176] = _175;
    _173++;
    if (_173 < r)
    goto _jump3321;
    _173 = 0;
    _174++;
    if (_174 < _171)
    goto _jump3321;
    // End body of loop
    _162 = _170;
    _jump3318:;
    _160 = _162;
    goto _jump3322;
    _jump3313:;
    _a2_double _177;
    // Computing bound for G
    _177.d0 = _74.d0;
    if (_74.d0 > 0) 
    goto _jump3323;
    fail_assertion("non-positive loop bound");
    _jump3323:;
    // Computing bound for H
    int64_t _178;
    // Computing bound for G
    int64_t _179 = 134;
    if (_179 > 0) 
    goto _jump3324;
    fail_assertion("non-positive loop bound");
    _jump3324:;
    _178 = 0;
    int64_t _180 = 0; // G
    _jump3325:; // Begin body of loop
    int64_t _181 = 461;
    _178 += _181;
    _180++;
    if (_180 < _179)
    goto _jump3325;
    // End body of loop
    _177.d1 = _178;
    if (_178 > 0) 
    goto _jump3326;
    fail_assertion("non-positive loop bound");
    _jump3326:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= _74.d0;
    _182 *= _178;
    _182 *= sizeof(double);
    _177.data = jpl_alloc(_182);
    int64_t _183 = 0; // H
    int64_t _184 = 0; // G
    _jump3327:; // Begin body of loop
    int64_t _185 = 358;
    if (_185 >= 0)
    goto _jump3328;
    fail_assertion("negative array index");
    _jump3328:;
    if (_185 < B.d0)
    goto _jump3329;
    fail_assertion("index too large");
    _jump3329:;
    int64_t _186 = 0;
    _186 *= B.d0;
    _186 += _185;
    double _187 = B.data[_186];
    if (_184 >= 0)
    goto _jump3330;
    fail_assertion("negative array index");
    _jump3330:;
    if (_184 < c.d0)
    goto _jump3331;
    fail_assertion("index too large");
    _jump3331:;
    int64_t _188 = 0;
    _188 *= c.d0;
    _188 += _184;
    double _189 = c.data[_188];
    double _190 = _187 * _189;
    int64_t _191 = 0;
    _191 *= _177.d0;
    _191 += _184;
    _191 *= _177.d1;
    _191 += _183;
    _177.data[_191] = _190;
    _183++;
    if (_183 < _178)
    goto _jump3327;
    _183 = 0;
    _184++;
    if (_184 < _74.d0)
    goto _jump3327;
    // End body of loop
    _160 = _177;
    _jump3322:;
    _155 = _160;
    goto _jump3332;
    _jump3312:;
    _a2_double _192;
    // Computing bound for G
    _192.d0 = u;
    if (u > 0) 
    goto _jump3333;
    fail_assertion("non-positive loop bound");
    _jump3333:;
    // Computing bound for H
    int64_t _193 = -u;
    _192.d1 = _193;
    if (_193 > 0) 
    goto _jump3334;
    fail_assertion("non-positive loop bound");
    _jump3334:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= u;
    _194 *= _193;
    _194 *= sizeof(double);
    _192.data = jpl_alloc(_194);
    int64_t _195 = 0; // H
    int64_t _196 = 0; // G
    _jump3335:; // Begin body of loop
    double _197 = 61.0;
    int64_t _198 = 0;
    _198 *= _192.d0;
    _198 += _196;
    _198 *= _192.d1;
    _198 += _195;
    _192.data[_198] = _197;
    _195++;
    if (_195 < _193)
    goto _jump3335;
    _195 = 0;
    _196++;
    if (_196 < u)
    goto _jump3335;
    // End body of loop
    _155 = _192;
    _jump3332:;
    _a2__a3_void_t _199;
    // Computing bound for G
    int64_t _200 = 113;
    int64_t _201 = 671;
    bool _202 = _200 != _201;
    int64_t _203;
    if (!_202)
    goto _jump3336;
    bool _204 = r == f;
    bool _205 = true;
    bool _206 = _204 != _205;
    int64_t _207;
    if (!_206)
    goto _jump3337;
    int64_t _208 = k + v;
    _207 = _208;
    goto _jump3338;
    _jump3337:;
    _207 = g;
    _jump3338:;
    _203 = _207;
    goto _jump3339;
    _jump3336:;
    _203 = q;
    _jump3339:;
    _199.d0 = _203;
    if (_203 > 0) 
    goto _jump3340;
    fail_assertion("non-positive loop bound");
    _jump3340:;
    // Computing bound for H
    _199.d1 = k;
    if (k > 0) 
    goto _jump3341;
    fail_assertion("non-positive loop bound");
    _jump3341:;
    // Computing total size of heap memory to allocate
    int64_t _209 = 1;
    _209 *= _203;
    _209 *= k;
    _209 *= sizeof(_a3_void_t);
    _199.data = jpl_alloc(_209);
    int64_t _210 = 0; // H
    int64_t _211 = 0; // G
    _jump3342:; // Begin body of loop
    bool _212 = false;
    _a3_void_t _213;
    if (!_212)
    goto _jump3343;
    _a2_bool _214;
    // Computing bound for I
    _214.d0 = f;
    if (f > 0) 
    goto _jump3344;
    fail_assertion("non-positive loop bound");
    _jump3344:;
    // Computing bound for J
    _214.d1 = v;
    if (v > 0) 
    goto _jump3345;
    fail_assertion("non-positive loop bound");
    _jump3345:;
    // Computing total size of heap memory to allocate
    int64_t _215 = 1;
    _215 *= f;
    _215 *= v;
    _215 *= sizeof(bool);
    _214.data = jpl_alloc(_215);
    int64_t _216 = 0; // J
    int64_t _217 = 0; // I
    _jump3346:; // Begin body of loop
    bool _218 = true;
    int64_t _219 = 0;
    _219 *= _214.d0;
    _219 += _217;
    _219 *= _214.d1;
    _219 += _216;
    _214.data[_219] = _218;
    _216++;
    if (_216 < v)
    goto _jump3346;
    _216 = 0;
    _217++;
    if (_217 < f)
    goto _jump3346;
    // End body of loop
    int64_t _220 = 982;
    if (x >= 0)
    goto _jump3347;
    fail_assertion("negative array index");
    _jump3347:;
    if (x < _214.d0)
    goto _jump3348;
    fail_assertion("index too large");
    _jump3348:;
    if (_220 >= 0)
    goto _jump3349;
    fail_assertion("negative array index");
    _jump3349:;
    if (_220 < _214.d1)
    goto _jump3350;
    fail_assertion("index too large");
    _jump3350:;
    int64_t _221 = 0;
    _221 *= _214.d0;
    _221 += x;
    _221 *= _214.d1;
    _221 += _220;
    bool _222 = _214.data[_221];
    _a3_void_t _223;
    if (!_222)
    goto _jump3351;
    _a3_void_t _224;
    // Computing bound for I
    _224.d0 = j;
    if (j > 0) 
    goto _jump3352;
    fail_assertion("non-positive loop bound");
    _jump3352:;
    // Computing bound for J
    int64_t _225;
    // Computing bound for I
    if (q > 0) 
    goto _jump3353;
    fail_assertion("non-positive loop bound");
    _jump3353:;
    // Computing bound for J
    if (k > 0) 
    goto _jump3354;
    fail_assertion("non-positive loop bound");
    _jump3354:;
    _225 = 0;
    int64_t _226 = 0; // J
    int64_t _227 = 0; // I
    _jump3355:; // Begin body of loop
    _225 += f;
    _226++;
    if (_226 < k)
    goto _jump3355;
    _226 = 0;
    _227++;
    if (_227 < q)
    goto _jump3355;
    // End body of loop
    _224.d1 = _225;
    if (_225 > 0) 
    goto _jump3356;
    fail_assertion("non-positive loop bound");
    _jump3356:;
    // Computing bound for K
    _224.d2 = r;
    if (r > 0) 
    goto _jump3357;
    fail_assertion("non-positive loop bound");
    _jump3357:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= j;
    _228 *= _225;
    _228 *= r;
    _228 *= sizeof(void_t);
    _224.data = jpl_alloc(_228);
    int64_t _229 = 0; // K
    int64_t _230 = 0; // J
    int64_t _231 = 0; // I
    _jump3358:; // Begin body of loop
    int64_t _232 = 0;
    _232 *= _224.d0;
    _232 += _231;
    _232 *= _224.d1;
    _232 += _230;
    _232 *= _224.d2;
    _232 += _229;
    _224.data[_232] = D;
    _229++;
    if (_229 < r)
    goto _jump3358;
    _229 = 0;
    _230++;
    if (_230 < _225)
    goto _jump3358;
    _230 = 0;
    _231++;
    if (_231 < j)
    goto _jump3358;
    // End body of loop
    _223 = _224;
    goto _jump3359;
    _jump3351:;
    _a3_void_t _233;
    // Computing bound for I
    _233.d0 = q;
    if (q > 0) 
    goto _jump3360;
    fail_assertion("non-positive loop bound");
    _jump3360:;
    // Computing bound for J
    _233.d1 = u;
    if (u > 0) 
    goto _jump3361;
    fail_assertion("non-positive loop bound");
    _jump3361:;
    // Computing bound for K
    _233.d2 = x;
    if (x > 0) 
    goto _jump3362;
    fail_assertion("non-positive loop bound");
    _jump3362:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= q;
    _234 *= u;
    _234 *= x;
    _234 *= sizeof(void_t);
    _233.data = jpl_alloc(_234);
    int64_t _235 = 0; // K
    int64_t _236 = 0; // J
    int64_t _237 = 0; // I
    _jump3363:; // Begin body of loop
    int64_t _238 = 0;
    _238 *= _233.d0;
    _238 += _237;
    _238 *= _233.d1;
    _238 += _236;
    _238 *= _233.d2;
    _238 += _235;
    _233.data[_238] = D;
    _235++;
    if (_235 < x)
    goto _jump3363;
    _235 = 0;
    _236++;
    if (_236 < u)
    goto _jump3363;
    _236 = 0;
    _237++;
    if (_237 < q)
    goto _jump3363;
    // End body of loop
    _223 = _233;
    _jump3359:;
    _213 = _223;
    goto _jump3364;
    _jump3343:;
    bool _239 = g > r;
    bool _240 = !_239;
    _a3_void_t _241;
    if (!_240)
    goto _jump3365;
    _a3_void_t _242;
    // Computing bound for I
    _242.d0 = g;
    if (g > 0) 
    goto _jump3366;
    fail_assertion("non-positive loop bound");
    _jump3366:;
    // Computing bound for J
    if (u >= 0)
    goto _jump3367;
    fail_assertion("negative array index");
    _jump3367:;
    if (u < i.d0)
    goto _jump3368;
    fail_assertion("index too large");
    _jump3368:;
    if (f >= 0)
    goto _jump3369;
    fail_assertion("negative array index");
    _jump3369:;
    if (f < i.d1)
    goto _jump3370;
    fail_assertion("index too large");
    _jump3370:;
    int64_t _243 = 0;
    _243 *= i.d0;
    _243 += u;
    _243 *= i.d1;
    _243 += f;
    int64_t _244 = i.data[_243];
    _242.d1 = _244;
    if (_244 > 0) 
    goto _jump3371;
    fail_assertion("non-positive loop bound");
    _jump3371:;
    // Computing bound for K
    int64_t _245 = r * _74.d0;
    _242.d2 = _245;
    if (_245 > 0) 
    goto _jump3372;
    fail_assertion("non-positive loop bound");
    _jump3372:;
    // Computing total size of heap memory to allocate
    int64_t _246 = 1;
    _246 *= g;
    _246 *= _244;
    _246 *= _245;
    _246 *= sizeof(void_t);
    _242.data = jpl_alloc(_246);
    int64_t _247 = 0; // K
    int64_t _248 = 0; // J
    int64_t _249 = 0; // I
    _jump3373:; // Begin body of loop
    int64_t _250 = 0;
    _250 *= _242.d0;
    _250 += _249;
    _250 *= _242.d1;
    _250 += _248;
    _250 *= _242.d2;
    _250 += _247;
    _242.data[_250] = D;
    _247++;
    if (_247 < _245)
    goto _jump3373;
    _247 = 0;
    _248++;
    if (_248 < _244)
    goto _jump3373;
    _248 = 0;
    _249++;
    if (_249 < g)
    goto _jump3373;
    // End body of loop
    _241 = _242;
    goto _jump3374;
    _jump3365:;
    bool _251 = false;
    bool _252 = true;
    bool _253 = _251 != _252;
    _a3_void_t _254;
    if (!_253)
    goto _jump3375;
    _a3_void_t _255;
    // Computing bound for I
    _255.d0 = v;
    if (v > 0) 
    goto _jump3376;
    fail_assertion("non-positive loop bound");
    _jump3376:;
    // Computing bound for J
    _255.d1 = _211;
    if (_211 > 0) 
    goto _jump3377;
    fail_assertion("non-positive loop bound");
    _jump3377:;
    // Computing bound for K
    _255.d2 = _210;
    if (_210 > 0) 
    goto _jump3378;
    fail_assertion("non-positive loop bound");
    _jump3378:;
    // Computing total size of heap memory to allocate
    int64_t _256 = 1;
    _256 *= v;
    _256 *= _211;
    _256 *= _210;
    _256 *= sizeof(void_t);
    _255.data = jpl_alloc(_256);
    int64_t _257 = 0; // K
    int64_t _258 = 0; // J
    int64_t _259 = 0; // I
    _jump3379:; // Begin body of loop
    int64_t _260 = 0;
    _260 *= _255.d0;
    _260 += _259;
    _260 *= _255.d1;
    _260 += _258;
    _260 *= _255.d2;
    _260 += _257;
    _255.data[_260] = D;
    _257++;
    if (_257 < _210)
    goto _jump3379;
    _257 = 0;
    _258++;
    if (_258 < _211)
    goto _jump3379;
    _258 = 0;
    _259++;
    if (_259 < v)
    goto _jump3379;
    // End body of loop
    _254 = _255;
    goto _jump3380;
    _jump3375:;
    _a3_void_t _261;
    // Computing bound for I
    _261.d0 = k;
    if (k > 0) 
    goto _jump3381;
    fail_assertion("non-positive loop bound");
    _jump3381:;
    // Computing bound for J
    _261.d1 = f;
    if (f > 0) 
    goto _jump3382;
    fail_assertion("non-positive loop bound");
    _jump3382:;
    // Computing bound for K
    int64_t _262 = 197;
    _261.d2 = _262;
    if (_262 > 0) 
    goto _jump3383;
    fail_assertion("non-positive loop bound");
    _jump3383:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= k;
    _263 *= f;
    _263 *= _262;
    _263 *= sizeof(void_t);
    _261.data = jpl_alloc(_263);
    int64_t _264 = 0; // K
    int64_t _265 = 0; // J
    int64_t _266 = 0; // I
    _jump3384:; // Begin body of loop
    int64_t _267 = 0;
    _267 *= _261.d0;
    _267 += _266;
    _267 *= _261.d1;
    _267 += _265;
    _267 *= _261.d2;
    _267 += _264;
    _261.data[_267] = D;
    _264++;
    if (_264 < _262)
    goto _jump3384;
    _264 = 0;
    _265++;
    if (_265 < f)
    goto _jump3384;
    _265 = 0;
    _266++;
    if (_266 < k)
    goto _jump3384;
    // End body of loop
    _254 = _261;
    _jump3380:;
    _241 = _254;
    _jump3374:;
    _213 = _241;
    _jump3364:;
    int64_t _268 = 0;
    _268 *= _199.d0;
    _268 += _211;
    _268 *= _199.d1;
    _268 += _210;
    _199.data[_268] = _213;
    _210++;
    if (_210 < k)
    goto _jump3342;
    _210 = 0;
    _211++;
    if (_211 < _203)
    goto _jump3342;
    // End body of loop
    void_t _269 = z(_153, _155, _199);
    _a3__a2_void_t _270 = C(_269);
    return _270;
    int64_t _271 = -h;
    _a3__a2__a3_bool _272;
    // Computing bound for H
    _272.d0 = v;
    if (v > 0) 
    goto _jump3385;
    fail_assertion("non-positive loop bound");
    _jump3385:;
    // Computing bound for I
    _272.d1 = k;
    if (k > 0) 
    goto _jump3386;
    fail_assertion("non-positive loop bound");
    _jump3386:;
    // Computing bound for J
    _272.d2 = q;
    if (q > 0) 
    goto _jump3387;
    fail_assertion("non-positive loop bound");
    _jump3387:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= v;
    _273 *= k;
    _273 *= q;
    _273 *= sizeof(_a2__a3_bool);
    _272.data = jpl_alloc(_273);
    int64_t _274 = 0; // J
    int64_t _275 = 0; // I
    int64_t _276 = 0; // H
    _jump3388:; // Begin body of loop
    _a2__a3_bool _277;
    // Computing bound for K
    _277.d0 = f;
    if (f > 0) 
    goto _jump3389;
    fail_assertion("non-positive loop bound");
    _jump3389:;
    // Computing bound for L
    _277.d1 = _74.d0;
    if (_74.d0 > 0) 
    goto _jump3390;
    fail_assertion("non-positive loop bound");
    _jump3390:;
    // Computing total size of heap memory to allocate
    int64_t _278 = 1;
    _278 *= f;
    _278 *= _74.d0;
    _278 *= sizeof(_a3_bool);
    _277.data = jpl_alloc(_278);
    int64_t _279 = 0; // L
    int64_t _280 = 0; // K
    _jump3391:; // Begin body of loop
    _a3_bool _281;
    // Computing bound for M
    _281.d0 = x;
    if (x > 0) 
    goto _jump3392;
    fail_assertion("non-positive loop bound");
    _jump3392:;
    // Computing bound for N
    _281.d1 = u;
    if (u > 0) 
    goto _jump3393;
    fail_assertion("non-positive loop bound");
    _jump3393:;
    // Computing bound for O
    _281.d2 = _74.d0;
    if (_74.d0 > 0) 
    goto _jump3394;
    fail_assertion("non-positive loop bound");
    _jump3394:;
    // Computing total size of heap memory to allocate
    int64_t _282 = 1;
    _282 *= x;
    _282 *= u;
    _282 *= _74.d0;
    _282 *= sizeof(bool);
    _281.data = jpl_alloc(_282);
    int64_t _283 = 0; // O
    int64_t _284 = 0; // N
    int64_t _285 = 0; // M
    _jump3395:; // Begin body of loop
    bool _286 = true;
    int64_t _287 = 0;
    _287 *= _281.d0;
    _287 += _285;
    _287 *= _281.d1;
    _287 += _284;
    _287 *= _281.d2;
    _287 += _283;
    _281.data[_287] = _286;
    _283++;
    if (_283 < _74.d0)
    goto _jump3395;
    _283 = 0;
    _284++;
    if (_284 < u)
    goto _jump3395;
    _284 = 0;
    _285++;
    if (_285 < x)
    goto _jump3395;
    // End body of loop
    int64_t _288 = 0;
    _288 *= _277.d0;
    _288 += _280;
    _288 *= _277.d1;
    _288 += _279;
    _277.data[_288] = _281;
    _279++;
    if (_279 < _74.d0)
    goto _jump3391;
    _279 = 0;
    _280++;
    if (_280 < f)
    goto _jump3391;
    // End body of loop
    int64_t _289 = 0;
    _289 *= _272.d0;
    _289 += _276;
    _289 *= _272.d1;
    _289 += _275;
    _289 *= _272.d2;
    _289 += _274;
    _272.data[_289] = _277;
    _274++;
    if (_274 < q)
    goto _jump3388;
    _274 = 0;
    _275++;
    if (_275 < k)
    goto _jump3388;
    _275 = 0;
    _276++;
    if (_276 < v)
    goto _jump3388;
    // End body of loop
    int64_t _290 = 444;
    int64_t _291 = -_290;
    bool _292 = q < _291;
    int64_t _293;
    if (!_292)
    goto _jump3396;
    _293 = _271;
    goto _jump3397;
    _jump3396:;
    _293 = f;
    _jump3397:;
    if (_293 >= 0)
    goto _jump3398;
    fail_assertion("negative array index");
    _jump3398:;
    if (_293 < _272.d0)
    goto _jump3399;
    fail_assertion("index too large");
    _jump3399:;
    if (g >= 0)
    goto _jump3400;
    fail_assertion("negative array index");
    _jump3400:;
    if (g < _272.d1)
    goto _jump3401;
    fail_assertion("index too large");
    _jump3401:;
    if (g >= 0)
    goto _jump3402;
    fail_assertion("negative array index");
    _jump3402:;
    if (g < _272.d2)
    goto _jump3403;
    fail_assertion("index too large");
    _jump3403:;
    int64_t _294 = 0;
    _294 *= _272.d0;
    _294 += _293;
    _294 *= _272.d1;
    _294 += g;
    _294 *= _272.d2;
    _294 += g;
    _a2__a3_bool _295 = _272.data[_294];
    int64_t _296;
    // Computing bound for H
    if (x > 0) 
    goto _jump3404;
    fail_assertion("non-positive loop bound");
    _jump3404:;
    // Computing bound for I
    if (q > 0) 
    goto _jump3405;
    fail_assertion("non-positive loop bound");
    _jump3405:;
    _296 = 0;
    int64_t _297 = 0; // I
    int64_t _298 = 0; // H
    _jump3406:; // Begin body of loop
    _296 += j;
    _297++;
    if (_297 < q)
    goto _jump3406;
    _297 = 0;
    _298++;
    if (_298 < x)
    goto _jump3406;
    // End body of loop
    if (_296 >= 0)
    goto _jump3407;
    fail_assertion("negative array index");
    _jump3407:;
    if (_296 < _295.d0)
    goto _jump3408;
    fail_assertion("index too large");
    _jump3408:;
    if (k >= 0)
    goto _jump3409;
    fail_assertion("negative array index");
    _jump3409:;
    if (k < _295.d1)
    goto _jump3410;
    fail_assertion("index too large");
    _jump3410:;
    int64_t _299 = 0;
    _299 *= _295.d0;
    _299 += _296;
    _299 *= _295.d1;
    _299 += k;
    _a3_bool _300 = _295.data[_299];
    _a3_double _301;
    // Computing bound for H
    _301.d0 = h;
    if (h > 0) 
    goto _jump3411;
    fail_assertion("non-positive loop bound");
    _jump3411:;
    // Computing bound for I
    _301.d1 = _74.d0;
    if (_74.d0 > 0) 
    goto _jump3412;
    fail_assertion("non-positive loop bound");
    _jump3412:;
    // Computing bound for J
    _301.d2 = u;
    if (u > 0) 
    goto _jump3413;
    fail_assertion("non-positive loop bound");
    _jump3413:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= h;
    _302 *= _74.d0;
    _302 *= u;
    _302 *= sizeof(double);
    _301.data = jpl_alloc(_302);
    int64_t _303 = 0; // J
    int64_t _304 = 0; // I
    int64_t _305 = 0; // H
    _jump3414:; // Begin body of loop
    double _306 = 59.0;
    double _307 = -_306;
    int64_t _308 = 0;
    _308 *= _301.d0;
    _308 += _305;
    _308 *= _301.d1;
    _308 += _304;
    _308 *= _301.d2;
    _308 += _303;
    _301.data[_308] = _307;
    _303++;
    if (_303 < u)
    goto _jump3414;
    _303 = 0;
    _304++;
    if (_304 < _74.d0)
    goto _jump3414;
    _304 = 0;
    _305++;
    if (_305 < h)
    goto _jump3414;
    // End body of loop
    bool _309 = n(_301);
    _a2_bool _310;
    if (!_309)
    goto _jump3415;
    _a3__a2_bool _311;
    // Computing bound for H
    _311.d0 = u;
    if (u > 0) 
    goto _jump3416;
    fail_assertion("non-positive loop bound");
    _jump3416:;
    // Computing bound for I
    _311.d1 = _271;
    if (_271 > 0) 
    goto _jump3417;
    fail_assertion("non-positive loop bound");
    _jump3417:;
    // Computing bound for J
    int64_t _312 = 221;
    _311.d2 = _312;
    if (_312 > 0) 
    goto _jump3418;
    fail_assertion("non-positive loop bound");
    _jump3418:;
    // Computing total size of heap memory to allocate
    int64_t _313 = 1;
    _313 *= u;
    _313 *= _271;
    _313 *= _312;
    _313 *= sizeof(_a2_bool);
    _311.data = jpl_alloc(_313);
    int64_t _314 = 0; // J
    int64_t _315 = 0; // I
    int64_t _316 = 0; // H
    _jump3419:; // Begin body of loop
    _a2_bool _317;
    // Computing bound for K
    _317.d0 = r;
    if (r > 0) 
    goto _jump3420;
    fail_assertion("non-positive loop bound");
    _jump3420:;
    // Computing bound for L
    int64_t _318 = 931;
    _317.d1 = _318;
    if (_318 > 0) 
    goto _jump3421;
    fail_assertion("non-positive loop bound");
    _jump3421:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= r;
    _319 *= _318;
    _319 *= sizeof(bool);
    _317.data = jpl_alloc(_319);
    int64_t _320 = 0; // L
    int64_t _321 = 0; // K
    _jump3422:; // Begin body of loop
    bool _322 = true;
    int64_t _323 = 0;
    _323 *= _317.d0;
    _323 += _321;
    _323 *= _317.d1;
    _323 += _320;
    _317.data[_323] = _322;
    _320++;
    if (_320 < _318)
    goto _jump3422;
    _320 = 0;
    _321++;
    if (_321 < r)
    goto _jump3422;
    // End body of loop
    int64_t _324 = 0;
    _324 *= _311.d0;
    _324 += _316;
    _324 *= _311.d1;
    _324 += _315;
    _324 *= _311.d2;
    _324 += _314;
    _311.data[_324] = _317;
    _314++;
    if (_314 < _312)
    goto _jump3419;
    _314 = 0;
    _315++;
    if (_315 < _271)
    goto _jump3419;
    _315 = 0;
    _316++;
    if (_316 < u)
    goto _jump3419;
    // End body of loop
    int64_t _325;
    // Computing bound for H
    if (f > 0) 
    goto _jump3423;
    fail_assertion("non-positive loop bound");
    _jump3423:;
    _325 = 0;
    int64_t _326 = 0; // H
    _jump3424:; // Begin body of loop
    _325 += x;
    _326++;
    if (_326 < f)
    goto _jump3424;
    // End body of loop
    if (r >= 0)
    goto _jump3425;
    fail_assertion("negative array index");
    _jump3425:;
    if (r < _311.d0)
    goto _jump3426;
    fail_assertion("index too large");
    _jump3426:;
    if (q >= 0)
    goto _jump3427;
    fail_assertion("negative array index");
    _jump3427:;
    if (q < _311.d1)
    goto _jump3428;
    fail_assertion("index too large");
    _jump3428:;
    if (_325 >= 0)
    goto _jump3429;
    fail_assertion("negative array index");
    _jump3429:;
    if (_325 < _311.d2)
    goto _jump3430;
    fail_assertion("index too large");
    _jump3430:;
    int64_t _327 = 0;
    _327 *= _311.d0;
    _327 += r;
    _327 *= _311.d1;
    _327 += q;
    _327 *= _311.d2;
    _327 += _325;
    _a2_bool _328 = _311.data[_327];
    _310 = _328;
    goto _jump3431;
    _jump3415:;
    _a2_bool _329;
    // Computing bound for H
    _329.d0 = _271;
    if (_271 > 0) 
    goto _jump3432;
    fail_assertion("non-positive loop bound");
    _jump3432:;
    // Computing bound for I
    _329.d1 = j;
    if (j > 0) 
    goto _jump3433;
    fail_assertion("non-positive loop bound");
    _jump3433:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= _271;
    _330 *= j;
    _330 *= sizeof(bool);
    _329.data = jpl_alloc(_330);
    int64_t _331 = 0; // I
    int64_t _332 = 0; // H
    _jump3434:; // Begin body of loop
    bool _333 = q == _331;
    int64_t _334 = 0;
    _334 *= _329.d0;
    _334 += _332;
    _334 *= _329.d1;
    _334 += _331;
    _329.data[_334] = _333;
    _331++;
    if (_331 < j)
    goto _jump3434;
    _331 = 0;
    _332++;
    if (_332 < _271)
    goto _jump3434;
    // End body of loop
    _310 = _329;
    _jump3431:;
    _a3_double _335;
    // Computing bound for H
    _335.d0 = _74.d0;
    if (_74.d0 > 0) 
    goto _jump3435;
    fail_assertion("non-positive loop bound");
    _jump3435:;
    // Computing bound for I
    _335.d1 = k;
    if (k > 0) 
    goto _jump3436;
    fail_assertion("non-positive loop bound");
    _jump3436:;
    // Computing bound for J
    _335.d2 = r;
    if (r > 0) 
    goto _jump3437;
    fail_assertion("non-positive loop bound");
    _jump3437:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _74.d0;
    _336 *= k;
    _336 *= r;
    _336 *= sizeof(double);
    _335.data = jpl_alloc(_336);
    int64_t _337 = 0; // J
    int64_t _338 = 0; // I
    int64_t _339 = 0; // H
    _jump3438:; // Begin body of loop
    _a1_double _340;
    // Computing bound for K
    _340.d0 = _271;
    if (_271 > 0) 
    goto _jump3439;
    fail_assertion("non-positive loop bound");
    _jump3439:;
    // Computing total size of heap memory to allocate
    int64_t _341 = 1;
    _341 *= _271;
    _341 *= sizeof(double);
    _340.data = jpl_alloc(_341);
    int64_t _342 = 0; // K
    _jump3440:; // Begin body of loop
    double _343 = 14.0;
    int64_t _344 = 0;
    _344 *= _340.d0;
    _344 += _342;
    _340.data[_344] = _343;
    _342++;
    if (_342 < _271)
    goto _jump3440;
    // End body of loop
    if (_337 >= 0)
    goto _jump3441;
    fail_assertion("negative array index");
    _jump3441:;
    if (_337 < _340.d0)
    goto _jump3442;
    fail_assertion("index too large");
    _jump3442:;
    int64_t _345 = 0;
    _345 *= _340.d0;
    _345 += _337;
    double _346 = _340.data[_345];
    int64_t _347 = 0;
    _347 *= _335.d0;
    _347 += _339;
    _347 *= _335.d1;
    _347 += _338;
    _347 *= _335.d2;
    _347 += _337;
    _335.data[_347] = _346;
    _337++;
    if (_337 < r)
    goto _jump3438;
    _337 = 0;
    _338++;
    if (_338 < k)
    goto _jump3438;
    _338 = 0;
    _339++;
    if (_339 < _74.d0)
    goto _jump3438;
    // End body of loop
    _a3_double _348;
    // Computing bound for H
    _348.d0 = f;
    if (f > 0) 
    goto _jump3443;
    fail_assertion("non-positive loop bound");
    _jump3443:;
    // Computing bound for I
    _348.d1 = k;
    if (k > 0) 
    goto _jump3444;
    fail_assertion("non-positive loop bound");
    _jump3444:;
    // Computing bound for J
    _348.d2 = f;
    if (f > 0) 
    goto _jump3445;
    fail_assertion("non-positive loop bound");
    _jump3445:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= f;
    _349 *= k;
    _349 *= f;
    _349 *= sizeof(double);
    _348.data = jpl_alloc(_349);
    int64_t _350 = 0; // J
    int64_t _351 = 0; // I
    int64_t _352 = 0; // H
    _jump3446:; // Begin body of loop
    double _353 = 23.0;
    int64_t _354 = 0;
    _354 *= _348.d0;
    _354 += _352;
    _354 *= _348.d1;
    _354 += _351;
    _354 *= _348.d2;
    _354 += _350;
    _348.data[_354] = _353;
    _350++;
    if (_350 < f)
    goto _jump3446;
    _350 = 0;
    _351++;
    if (_351 < k)
    goto _jump3446;
    _351 = 0;
    _352++;
    if (_352 < f)
    goto _jump3446;
    // End body of loop
    bool _355 = n(_348);
    _a2_double _356;
    if (!_355)
    goto _jump3447;
    _a2_double _357;
    // Computing bound for H
    _357.d0 = _271;
    if (_271 > 0) 
    goto _jump3448;
    fail_assertion("non-positive loop bound");
    _jump3448:;
    // Computing bound for I
    int64_t _358 = 777;
    _357.d1 = _358;
    if (_358 > 0) 
    goto _jump3449;
    fail_assertion("non-positive loop bound");
    _jump3449:;
    // Computing total size of heap memory to allocate
    int64_t _359 = 1;
    _359 *= _271;
    _359 *= _358;
    _359 *= sizeof(double);
    _357.data = jpl_alloc(_359);
    int64_t _360 = 0; // I
    int64_t _361 = 0; // H
    _jump3450:; // Begin body of loop
    double _362;
    // Computing bound for J
    int64_t _363 = 748;
    if (_363 > 0) 
    goto _jump3451;
    fail_assertion("non-positive loop bound");
    _jump3451:;
    // Computing bound for K
    if (_74.d0 > 0) 
    goto _jump3452;
    fail_assertion("non-positive loop bound");
    _jump3452:;
    _362 = 0;
    int64_t _364 = 0; // K
    int64_t _365 = 0; // J
    _jump3453:; // Begin body of loop
    double _366 = 55.0;
    _362 += _366;
    _364++;
    if (_364 < _74.d0)
    goto _jump3453;
    _364 = 0;
    _365++;
    if (_365 < _363)
    goto _jump3453;
    // End body of loop
    int64_t _367 = 0;
    _367 *= _357.d0;
    _367 += _361;
    _367 *= _357.d1;
    _367 += _360;
    _357.data[_367] = _362;
    _360++;
    if (_360 < _358)
    goto _jump3450;
    _360 = 0;
    _361++;
    if (_361 < _271)
    goto _jump3450;
    // End body of loop
    _356 = _357;
    goto _jump3454;
    _jump3447:;
    _a2_double _368;
    // Computing bound for H
    _368.d0 = r;
    if (r > 0) 
    goto _jump3455;
    fail_assertion("non-positive loop bound");
    _jump3455:;
    // Computing bound for I
    _368.d1 = x;
    if (x > 0) 
    goto _jump3456;
    fail_assertion("non-positive loop bound");
    _jump3456:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= r;
    _369 *= x;
    _369 *= sizeof(double);
    _368.data = jpl_alloc(_369);
    int64_t _370 = 0; // I
    int64_t _371 = 0; // H
    _jump3457:; // Begin body of loop
    double _372 = 1.0;
    int64_t _373 = 0;
    _373 *= _368.d0;
    _373 += _371;
    _373 *= _368.d1;
    _373 += _370;
    _368.data[_373] = _372;
    _370++;
    if (_370 < x)
    goto _jump3457;
    _370 = 0;
    _371++;
    if (_371 < r)
    goto _jump3457;
    // End body of loop
    _356 = _368;
    _jump3454:;
    double _374 = 2.0;
    double _375 = 95.0;
    bool _376 = _374 != _375;
    _a2__a3_void_t _377;
    if (!_376)
    goto _jump3458;
    _a2__a3_void_t _378;
    // Computing bound for H
    if (k >= 0)
    goto _jump3459;
    fail_assertion("negative array index");
    _jump3459:;
    if (k < e.d0)
    goto _jump3460;
    fail_assertion("index too large");
    _jump3460:;
    if (h >= 0)
    goto _jump3461;
    fail_assertion("negative array index");
    _jump3461:;
    if (h < e.d1)
    goto _jump3462;
    fail_assertion("index too large");
    _jump3462:;
    if (r >= 0)
    goto _jump3463;
    fail_assertion("negative array index");
    _jump3463:;
    if (r < e.d2)
    goto _jump3464;
    fail_assertion("index too large");
    _jump3464:;
    int64_t _379 = 0;
    _379 *= e.d0;
    _379 += k;
    _379 *= e.d1;
    _379 += h;
    _379 *= e.d2;
    _379 += r;
    int64_t _380 = e.data[_379];
    _378.d0 = _380;
    if (_380 > 0) 
    goto _jump3465;
    fail_assertion("non-positive loop bound");
    _jump3465:;
    // Computing bound for I
    _378.d1 = x;
    if (x > 0) 
    goto _jump3466;
    fail_assertion("non-positive loop bound");
    _jump3466:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= _380;
    _381 *= x;
    _381 *= sizeof(_a3_void_t);
    _378.data = jpl_alloc(_381);
    int64_t _382 = 0; // I
    int64_t _383 = 0; // H
    _jump3467:; // Begin body of loop
    _a3_void_t _384;
    // Computing bound for J
    _384.d0 = j;
    if (j > 0) 
    goto _jump3468;
    fail_assertion("non-positive loop bound");
    _jump3468:;
    // Computing bound for K
    _384.d1 = _382;
    if (_382 > 0) 
    goto _jump3469;
    fail_assertion("non-positive loop bound");
    _jump3469:;
    // Computing bound for L
    _384.d2 = r;
    if (r > 0) 
    goto _jump3470;
    fail_assertion("non-positive loop bound");
    _jump3470:;
    // Computing total size of heap memory to allocate
    int64_t _385 = 1;
    _385 *= j;
    _385 *= _382;
    _385 *= r;
    _385 *= sizeof(void_t);
    _384.data = jpl_alloc(_385);
    int64_t _386 = 0; // L
    int64_t _387 = 0; // K
    int64_t _388 = 0; // J
    _jump3471:; // Begin body of loop
    int64_t _389 = 0;
    _389 *= _384.d0;
    _389 += _388;
    _389 *= _384.d1;
    _389 += _387;
    _389 *= _384.d2;
    _389 += _386;
    _384.data[_389] = D;
    _386++;
    if (_386 < r)
    goto _jump3471;
    _386 = 0;
    _387++;
    if (_387 < _382)
    goto _jump3471;
    _387 = 0;
    _388++;
    if (_388 < j)
    goto _jump3471;
    // End body of loop
    int64_t _390 = 0;
    _390 *= _378.d0;
    _390 += _383;
    _390 *= _378.d1;
    _390 += _382;
    _378.data[_390] = _384;
    _382++;
    if (_382 < x)
    goto _jump3467;
    _382 = 0;
    _383++;
    if (_383 < _380)
    goto _jump3467;
    // End body of loop
    _377 = _378;
    goto _jump3472;
    _jump3458:;
    _a2__a3_void_t _391;
    // Computing bound for H
    int64_t _392 = 703;
    _391.d0 = _392;
    if (_392 > 0) 
    goto _jump3473;
    fail_assertion("non-positive loop bound");
    _jump3473:;
    // Computing bound for I
    _391.d1 = g;
    if (g > 0) 
    goto _jump3474;
    fail_assertion("non-positive loop bound");
    _jump3474:;
    // Computing total size of heap memory to allocate
    int64_t _393 = 1;
    _393 *= _392;
    _393 *= g;
    _393 *= sizeof(_a3_void_t);
    _391.data = jpl_alloc(_393);
    int64_t _394 = 0; // I
    int64_t _395 = 0; // H
    _jump3475:; // Begin body of loop
    _a3_void_t _396;
    // Computing bound for J
    _396.d0 = _271;
    if (_271 > 0) 
    goto _jump3476;
    fail_assertion("non-positive loop bound");
    _jump3476:;
    // Computing bound for K
    _396.d1 = x;
    if (x > 0) 
    goto _jump3477;
    fail_assertion("non-positive loop bound");
    _jump3477:;
    // Computing bound for L
    _396.d2 = f;
    if (f > 0) 
    goto _jump3478;
    fail_assertion("non-positive loop bound");
    _jump3478:;
    // Computing total size of heap memory to allocate
    int64_t _397 = 1;
    _397 *= _271;
    _397 *= x;
    _397 *= f;
    _397 *= sizeof(void_t);
    _396.data = jpl_alloc(_397);
    int64_t _398 = 0; // L
    int64_t _399 = 0; // K
    int64_t _400 = 0; // J
    _jump3479:; // Begin body of loop
    int64_t _401 = 0;
    _401 *= _396.d0;
    _401 += _400;
    _401 *= _396.d1;
    _401 += _399;
    _401 *= _396.d2;
    _401 += _398;
    _396.data[_401] = D;
    _398++;
    if (_398 < f)
    goto _jump3479;
    _398 = 0;
    _399++;
    if (_399 < x)
    goto _jump3479;
    _399 = 0;
    _400++;
    if (_400 < _271)
    goto _jump3479;
    // End body of loop
    int64_t _402 = 0;
    _402 *= _391.d0;
    _402 += _395;
    _402 *= _391.d1;
    _402 += _394;
    _391.data[_402] = _396;
    _394++;
    if (_394 < g)
    goto _jump3475;
    _394 = 0;
    _395++;
    if (_395 < _392)
    goto _jump3475;
    // End body of loop
    _377 = _391;
    _jump3472:;
    void_t _403 = z(_335, _356, _377);
    int64_t _404 = a(_310, _403);
    if (f >= 0)
    goto _jump3480;
    fail_assertion("negative array index");
    _jump3480:;
    if (f < _300.d0)
    goto _jump3481;
    fail_assertion("index too large");
    _jump3481:;
    if (_404 >= 0)
    goto _jump3482;
    fail_assertion("negative array index");
    _jump3482:;
    if (_404 < _300.d1)
    goto _jump3483;
    fail_assertion("index too large");
    _jump3483:;
    if (_271 >= 0)
    goto _jump3484;
    fail_assertion("negative array index");
    _jump3484:;
    if (_271 < _300.d2)
    goto _jump3485;
    fail_assertion("index too large");
    _jump3485:;
    int64_t _405 = 0;
    _405 *= _300.d0;
    _405 += f;
    _405 *= _300.d1;
    _405 += _404;
    _405 *= _300.d2;
    _405 += _271;
    bool _406 = _300.data[_405];
    _a1_double _407;
    if (!_406)
    goto _jump3486;
    _407 = c;
    goto _jump3487;
    _jump3486:;
    _407 = B;
    _jump3487:;
    _a1__a1_bool _408;
    // Computing bound for J
    _408.d0 = q;
    if (q > 0) 
    goto _jump3488;
    fail_assertion("non-positive loop bound");
    _jump3488:;
    // Computing total size of heap memory to allocate
    int64_t _409 = 1;
    _409 *= q;
    _409 *= sizeof(_a1_bool);
    _408.data = jpl_alloc(_409);
    int64_t _410 = 0; // J
    _jump3489:; // Begin body of loop
    _a1_bool _411;
    // Computing bound for K
    _411.d0 = _271;
    if (_271 > 0) 
    goto _jump3490;
    fail_assertion("non-positive loop bound");
    _jump3490:;
    // Computing total size of heap memory to allocate
    int64_t _412 = 1;
    _412 *= _271;
    _412 *= sizeof(bool);
    _411.data = jpl_alloc(_412);
    int64_t _413 = 0; // K
    _jump3491:; // Begin body of loop
    double _414 = 48.0;
    double _415 = -_414;
    if (_271 >= 0)
    goto _jump3492;
    fail_assertion("negative array index");
    _jump3492:;
    if (_271 < B.d0)
    goto _jump3493;
    fail_assertion("index too large");
    _jump3493:;
    int64_t _416 = 0;
    _416 *= B.d0;
    _416 += _271;
    double _417 = B.data[_416];
    bool _418 = _415 >= _417;
    int64_t _419 = 0;
    _419 *= _411.d0;
    _419 += _413;
    _411.data[_419] = _418;
    _413++;
    if (_413 < _271)
    goto _jump3491;
    // End body of loop
    int64_t _420 = 0;
    _420 *= _408.d0;
    _420 += _410;
    _408.data[_420] = _411;
    _410++;
    if (_410 < q)
    goto _jump3489;
    // End body of loop
    _a2_bool _421;
    // Computing bound for J
    _421.d0 = x;
    if (x > 0) 
    goto _jump3494;
    fail_assertion("non-positive loop bound");
    _jump3494:;
    // Computing bound for K
    _421.d1 = j;
    if (j > 0) 
    goto _jump3495;
    fail_assertion("non-positive loop bound");
    _jump3495:;
    // Computing total size of heap memory to allocate
    int64_t _422 = 1;
    _422 *= x;
    _422 *= j;
    _422 *= sizeof(bool);
    _421.data = jpl_alloc(_422);
    int64_t _423 = 0; // K
    int64_t _424 = 0; // J
    _jump3496:; // Begin body of loop
    bool _425 = true;
    bool _426 = !_425;
    int64_t _427 = 0;
    _427 *= _421.d0;
    _427 += _424;
    _427 *= _421.d1;
    _427 += _423;
    _421.data[_427] = _426;
    _423++;
    if (_423 < j)
    goto _jump3496;
    _423 = 0;
    _424++;
    if (_424 < x)
    goto _jump3496;
    // End body of loop
    bool _428 = true;
    bool _429 = f != k;
    _a1_bool _430;
    _430.d0 = 2;
    _430.data = jpl_alloc(sizeof(bool) * 2);
    _430.data[0] = _428;
    _430.data[1] = _429;
    bool _431 = true;
    bool _432 = _271 < q;
    _a1_bool _433;
    _433.d0 = 2;
    _433.data = jpl_alloc(sizeof(bool) * 2);
    _433.data[0] = _431;
    _433.data[1] = _432;
    void_t _434 = b(_430, _433);
    int64_t _435 = a(_421, _434);
    if (_435 >= 0)
    goto _jump3497;
    fail_assertion("negative array index");
    _jump3497:;
    if (_435 < _408.d0)
    goto _jump3498;
    fail_assertion("index too large");
    _jump3498:;
    int64_t _436 = 0;
    _436 *= _408.d0;
    _436 += _435;
    _a1_bool _437 = _408.data[_436];
    bool _439 = false;
    bool _438 = _439;
    if (0 != _439)
    goto _jump3499;
    bool _440 = true;
    _438 = _440;
    _jump3499:;
    bool _441 = u >= q;
    int64_t _442;
    // Computing bound for J
    if (q > 0) 
    goto _jump3500;
    fail_assertion("non-positive loop bound");
    _jump3500:;
    // Computing bound for K
    if (k > 0) 
    goto _jump3501;
    fail_assertion("non-positive loop bound");
    _jump3501:;
    _442 = 0;
    int64_t _443 = 0; // K
    int64_t _444 = 0; // J
    _jump3502:; // Begin body of loop
    _442 += _444;
    _443++;
    if (_443 < k)
    goto _jump3502;
    _443 = 0;
    _444++;
    if (_444 < q)
    goto _jump3502;
    // End body of loop
    bool _445 = h <= _442;
    bool _446 = _441 == _445;
    bool _447 = _438 == _446;
    _a3_double _448;
    // Computing bound for J
    _448.d0 = j;
    if (j > 0) 
    goto _jump3503;
    fail_assertion("non-positive loop bound");
    _jump3503:;
    // Computing bound for K
    _448.d1 = _407.d0;
    if (_407.d0 > 0) 
    goto _jump3504;
    fail_assertion("non-positive loop bound");
    _jump3504:;
    // Computing bound for L
    int64_t _449 = -j;
    _448.d2 = _449;
    if (_449 > 0) 
    goto _jump3505;
    fail_assertion("non-positive loop bound");
    _jump3505:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= j;
    _450 *= _407.d0;
    _450 *= _449;
    _450 *= sizeof(double);
    _448.data = jpl_alloc(_450);
    int64_t _451 = 0; // L
    int64_t _452 = 0; // K
    int64_t _453 = 0; // J
    _jump3506:; // Begin body of loop
    double _454 = A.r;
    int64_t _455 = 0;
    _455 *= _448.d0;
    _455 += _453;
    _455 *= _448.d1;
    _455 += _452;
    _455 *= _448.d2;
    _455 += _451;
    _448.data[_455] = _454;
    _451++;
    if (_451 < _449)
    goto _jump3506;
    _451 = 0;
    _452++;
    if (_452 < _407.d0)
    goto _jump3506;
    _452 = 0;
    _453++;
    if (_453 < j)
    goto _jump3506;
    // End body of loop
    bool _456 = false;
    int64_t _457;
    if (!_456)
    goto _jump3507;
    _457 = k;
    goto _jump3508;
    _jump3507:;
    _457 = v;
    _jump3508:;
    int64_t _458 = 959;
    if (_458 >= 0)
    goto _jump3509;
    fail_assertion("negative array index");
    _jump3509:;
    if (_458 < i.d0)
    goto _jump3510;
    fail_assertion("index too large");
    _jump3510:;
    if (u >= 0)
    goto _jump3511;
    fail_assertion("negative array index");
    _jump3511:;
    if (u < i.d1)
    goto _jump3512;
    fail_assertion("index too large");
    _jump3512:;
    int64_t _459 = 0;
    _459 *= i.d0;
    _459 += _458;
    _459 *= i.d1;
    _459 += u;
    int64_t _460 = i.data[_459];
    if (_457 >= 0)
    goto _jump3513;
    fail_assertion("negative array index");
    _jump3513:;
    if (_457 < _448.d0)
    goto _jump3514;
    fail_assertion("index too large");
    _jump3514:;
    if (_407.d0 >= 0)
    goto _jump3515;
    fail_assertion("negative array index");
    _jump3515:;
    if (_407.d0 < _448.d1)
    goto _jump3516;
    fail_assertion("index too large");
    _jump3516:;
    if (_460 >= 0)
    goto _jump3517;
    fail_assertion("negative array index");
    _jump3517:;
    if (_460 < _448.d2)
    goto _jump3518;
    fail_assertion("index too large");
    _jump3518:;
    int64_t _461 = 0;
    _461 *= _448.d0;
    _461 += _457;
    _461 *= _448.d1;
    _461 += _407.d0;
    _461 *= _448.d2;
    _461 += _460;
    double _462 = _448.data[_461];
    _a2__a2_int64_t _463;
    // Computing bound for J
    _463.d0 = h;
    if (h > 0) 
    goto _jump3519;
    fail_assertion("non-positive loop bound");
    _jump3519:;
    // Computing bound for K
    _463.d1 = x;
    if (x > 0) 
    goto _jump3520;
    fail_assertion("non-positive loop bound");
    _jump3520:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= h;
    _464 *= x;
    _464 *= sizeof(_a2_int64_t);
    _463.data = jpl_alloc(_464);
    int64_t _465 = 0; // K
    int64_t _466 = 0; // J
    _jump3521:; // Begin body of loop
    int64_t _467 = 0;
    _467 *= _463.d0;
    _467 += _466;
    _467 *= _463.d1;
    _467 += _465;
    _463.data[_467] = t;
    _465++;
    if (_465 < x)
    goto _jump3521;
    _465 = 0;
    _466++;
    if (_466 < h)
    goto _jump3521;
    // End body of loop
    _a3_bool _468;
    // Computing bound for J
    _468.d0 = v;
    if (v > 0) 
    goto _jump3522;
    fail_assertion("non-positive loop bound");
    _jump3522:;
    // Computing bound for K
    _468.d1 = x;
    if (x > 0) 
    goto _jump3523;
    fail_assertion("non-positive loop bound");
    _jump3523:;
    // Computing bound for L
    _468.d2 = _407.d0;
    if (_407.d0 > 0) 
    goto _jump3524;
    fail_assertion("non-positive loop bound");
    _jump3524:;
    // Computing total size of heap memory to allocate
    int64_t _469 = 1;
    _469 *= v;
    _469 *= x;
    _469 *= _407.d0;
    _469 *= sizeof(bool);
    _468.data = jpl_alloc(_469);
    int64_t _470 = 0; // L
    int64_t _471 = 0; // K
    int64_t _472 = 0; // J
    _jump3525:; // Begin body of loop
    bool _473 = true;
    int64_t _474 = 0;
    _474 *= _468.d0;
    _474 += _472;
    _474 *= _468.d1;
    _474 += _471;
    _474 *= _468.d2;
    _474 += _470;
    _468.data[_474] = _473;
    _470++;
    if (_470 < _407.d0)
    goto _jump3525;
    _470 = 0;
    _471++;
    if (_471 < x)
    goto _jump3525;
    _471 = 0;
    _472++;
    if (_472 < v)
    goto _jump3525;
    // End body of loop
    rgba _475 = m(_463, v, _468);
    double _476 = _475.g;
    bool _477 = _462 > _476;
    _a1_bool _478;
    _478.d0 = 2;
    _478.data = jpl_alloc(sizeof(bool) * 2);
    _478.data[0] = _447;
    _478.data[1] = _477;
    void_t _479 = b(_437, _478);
    _a3__a2_void_t _480 = C(_479);
    return _480;
}

bool F(int64_t G, rgba H) {
    _a1_bool _0;
    // Computing bound for K
    _0.d0 = f;
    if (f > 0) 
    goto _jump3538;
    fail_assertion("non-positive loop bound");
    _jump3538:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= f;
    _1 *= sizeof(bool);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // K
    _jump3539:; // Begin body of loop
    int64_t _3;
    // Computing bound for L
    if (v > 0) 
    goto _jump3540;
    fail_assertion("non-positive loop bound");
    _jump3540:;
    // Computing bound for M
    if (E > 0) 
    goto _jump3541;
    fail_assertion("non-positive loop bound");
    _jump3541:;
    _3 = 0;
    int64_t _4 = 0; // M
    int64_t _5 = 0; // L
    _jump3542:; // Begin body of loop
    _3 += k;
    _4++;
    if (_4 < E)
    goto _jump3542;
    _4 = 0;
    _5++;
    if (_5 < v)
    goto _jump3542;
    // End body of loop
    bool _6 = _3 < E;
    int64_t _7 = 0;
    _7 *= _0.d0;
    _7 += _2;
    _0.data[_7] = _6;
    _2++;
    if (_2 < f)
    goto _jump3539;
    // End body of loop
    if (u >= 0)
    goto _jump3543;
    fail_assertion("negative array index");
    _jump3543:;
    if (u < _0.d0)
    goto _jump3544;
    fail_assertion("index too large");
    _jump3544:;
    int64_t _8 = 0;
    _8 *= _0.d0;
    _8 += u;
    bool _9 = _0.data[_8];
    _a3_int64_t _10;
    if (!_9)
    goto _jump3545;
    _10 = e;
    goto _jump3546;
    _jump3545:;
    _10 = e;
    _jump3546:;
    bool _11 = true;
    if (0 != _11)
    goto _jump3547;
    fail_assertion("O");
    _jump3547:;
    bool _12 = false;
    _a1_double _13;
    if (!_12)
    goto _jump3548;
    _13 = d;
    goto _jump3549;
    _jump3548:;
    _13 = c;
    _jump3549:;
    if (_10.d1 >= 0)
    goto _jump3550;
    fail_assertion("negative array index");
    _jump3550:;
    if (_10.d1 < _13.d0)
    goto _jump3551;
    fail_assertion("index too large");
    _jump3551:;
    int64_t _14 = 0;
    _14 *= _13.d0;
    _14 += _10.d1;
    double _15 = _13.data[_14];
    bool _16 = c.d0 > _10.d1;
    double _17;
    if (!_16)
    goto _jump3552;
    double _18;
    // Computing bound for Q
    if (v > 0) 
    goto _jump3553;
    fail_assertion("non-positive loop bound");
    _jump3553:;
    // Computing bound for R
    if (c.d0 > 0) 
    goto _jump3554;
    fail_assertion("non-positive loop bound");
    _jump3554:;
    _18 = 0;
    int64_t _19 = 0; // R
    int64_t _20 = 0; // Q
    _jump3555:; // Begin body of loop
    double _21 = 11.0;
    _18 += _21;
    _19++;
    if (_19 < c.d0)
    goto _jump3555;
    _19 = 0;
    _20++;
    if (_20 < v)
    goto _jump3555;
    // End body of loop
    double _22 = -_18;
    _17 = _22;
    goto _jump3556;
    _jump3552:;
    if (_10.d0 >= 0)
    goto _jump3557;
    fail_assertion("negative array index");
    _jump3557:;
    if (_10.d0 < B.d0)
    goto _jump3558;
    fail_assertion("index too large");
    _jump3558:;
    int64_t _23 = 0;
    _23 *= B.d0;
    _23 += _10.d0;
    double _24 = B.data[_23];
    if (x >= 0)
    goto _jump3559;
    fail_assertion("negative array index");
    _jump3559:;
    if (x < w.d0)
    goto _jump3560;
    fail_assertion("index too large");
    _jump3560:;
    int64_t _25 = 0;
    _25 *= w.d0;
    _25 += x;
    double _26 = w.data[_25];
    double _27 = _24 * _26;
    _17 = _27;
    _jump3556:;
    _a2_double _28;
    // Computing bound for Q
    int64_t _29 = 660;
    _28.d0 = _29;
    if (_29 > 0) 
    goto _jump3561;
    fail_assertion("non-positive loop bound");
    _jump3561:;
    // Computing bound for R
    _28.d1 = j;
    if (j > 0) 
    goto _jump3562;
    fail_assertion("non-positive loop bound");
    _jump3562:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _29;
    _30 *= j;
    _30 *= sizeof(double);
    _28.data = jpl_alloc(_30);
    int64_t _31 = 0; // R
    int64_t _32 = 0; // Q
    _jump3563:; // Begin body of loop
    double _33;
    // Computing bound for S
    if (E > 0) 
    goto _jump3564;
    fail_assertion("non-positive loop bound");
    _jump3564:;
    _33 = 0;
    int64_t _34 = 0; // S
    _jump3565:; // Begin body of loop
    double _35 = 24.0;
    _33 += _35;
    _34++;
    if (_34 < E)
    goto _jump3565;
    // End body of loop
    int64_t _36 = 0;
    _36 *= _28.d0;
    _36 += _32;
    _36 *= _28.d1;
    _36 += _31;
    _28.data[_36] = _33;
    _31++;
    if (_31 < j)
    goto _jump3563;
    _31 = 0;
    _32++;
    if (_32 < _29)
    goto _jump3563;
    // End body of loop
    int64_t _37 = -v;
    if (_37 >= 0)
    goto _jump3566;
    fail_assertion("negative array index");
    _jump3566:;
    if (_37 < _28.d0)
    goto _jump3567;
    fail_assertion("index too large");
    _jump3567:;
    if (v >= 0)
    goto _jump3568;
    fail_assertion("negative array index");
    _jump3568:;
    if (v < _28.d1)
    goto _jump3569;
    fail_assertion("index too large");
    _jump3569:;
    int64_t _38 = 0;
    _38 *= _28.d0;
    _38 += _37;
    _38 *= _28.d1;
    _38 += v;
    double _39 = _28.data[_38];
    double _40 = _17 / _39;
    bool _41 = _15 < _40;
    _a3_double _42;
    if (!_41)
    goto _jump3570;
    if (G >= 0)
    goto _jump3571;
    fail_assertion("negative array index");
    _jump3571:;
    if (G < c.d0)
    goto _jump3572;
    fail_assertion("index too large");
    _jump3572:;
    int64_t _43 = 0;
    _43 *= c.d0;
    _43 += G;
    double _44 = c.data[_43];
    double _45 = -_44;
    double _46;
    // Computing bound for Q
    if (_10.d2 > 0) 
    goto _jump3573;
    fail_assertion("non-positive loop bound");
    _jump3573:;
    // Computing bound for R
    if (E > 0) 
    goto _jump3574;
    fail_assertion("non-positive loop bound");
    _jump3574:;
    _46 = 0;
    int64_t _47 = 0; // R
    int64_t _48 = 0; // Q
    _jump3575:; // Begin body of loop
    double _49;
    // Computing bound for S
    if (E > 0) 
    goto _jump3576;
    fail_assertion("non-positive loop bound");
    _jump3576:;
    // Computing bound for T
    if (_10.d0 > 0) 
    goto _jump3577;
    fail_assertion("non-positive loop bound");
    _jump3577:;
    _49 = 0;
    int64_t _50 = 0; // T
    int64_t _51 = 0; // S
    _jump3578:; // Begin body of loop
    double _52;
    // Computing bound for U
    if (u > 0) 
    goto _jump3579;
    fail_assertion("non-positive loop bound");
    _jump3579:;
    _52 = 0;
    int64_t _53 = 0; // U
    _jump3580:; // Begin body of loop
    double _54 = 48.0;
    _52 += _54;
    _53++;
    if (_53 < u)
    goto _jump3580;
    // End body of loop
    _49 += _52;
    _50++;
    if (_50 < _10.d0)
    goto _jump3578;
    _50 = 0;
    _51++;
    if (_51 < E)
    goto _jump3578;
    // End body of loop
    _46 += _49;
    _47++;
    if (_47 < E)
    goto _jump3575;
    _47 = 0;
    _48++;
    if (_48 < _10.d2)
    goto _jump3575;
    // End body of loop
    bool _55 = _45 <= _46;
    _a3_double _56;
    if (!_55)
    goto _jump3581;
    _a3_double _57;
    // Computing bound for Q
    bool _58 = F(h, H);
    int64_t _59;
    if (!_58)
    goto _jump3582;
    _59 = v;
    goto _jump3583;
    _jump3582:;
    int64_t _60 = -v;
    _59 = _60;
    _jump3583:;
    _57.d0 = _59;
    if (_59 > 0) 
    goto _jump3584;
    fail_assertion("non-positive loop bound");
    _jump3584:;
    // Computing bound for R
    _57.d1 = g;
    if (g > 0) 
    goto _jump3585;
    fail_assertion("non-positive loop bound");
    _jump3585:;
    // Computing bound for S
    _57.d2 = _10.d2;
    if (_10.d2 > 0) 
    goto _jump3586;
    fail_assertion("non-positive loop bound");
    _jump3586:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= _59;
    _61 *= g;
    _61 *= _10.d2;
    _61 *= sizeof(double);
    _57.data = jpl_alloc(_61);
    int64_t _62 = 0; // S
    int64_t _63 = 0; // R
    int64_t _64 = 0; // Q
    _jump3587:; // Begin body of loop
    double _65 = H.a;
    double _66 = H.a;
    double _67 = fmod(_65, _66);
    int64_t _68 = 0;
    _68 *= _57.d0;
    _68 += _64;
    _68 *= _57.d1;
    _68 += _63;
    _68 *= _57.d2;
    _68 += _62;
    _57.data[_68] = _67;
    _62++;
    if (_62 < _10.d2)
    goto _jump3587;
    _62 = 0;
    _63++;
    if (_63 < g)
    goto _jump3587;
    _63 = 0;
    _64++;
    if (_64 < _59)
    goto _jump3587;
    // End body of loop
    _56 = _57;
    goto _jump3588;
    _jump3581:;
    _a3_double _69;
    // Computing bound for Q
    _69.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump3589;
    fail_assertion("non-positive loop bound");
    _jump3589:;
    // Computing bound for R
    _69.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump3590;
    fail_assertion("non-positive loop bound");
    _jump3590:;
    // Computing bound for S
    _69.d2 = q;
    if (q > 0) 
    goto _jump3591;
    fail_assertion("non-positive loop bound");
    _jump3591:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= c.d0;
    _70 *= c.d0;
    _70 *= q;
    _70 *= sizeof(double);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // S
    int64_t _72 = 0; // R
    int64_t _73 = 0; // Q
    _jump3592:; // Begin body of loop
    if (G >= 0)
    goto _jump3593;
    fail_assertion("negative array index");
    _jump3593:;
    if (G < d.d0)
    goto _jump3594;
    fail_assertion("index too large");
    _jump3594:;
    int64_t _74 = 0;
    _74 *= d.d0;
    _74 += G;
    double _75 = d.data[_74];
    int64_t _76 = 0;
    _76 *= _69.d0;
    _76 += _73;
    _76 *= _69.d1;
    _76 += _72;
    _76 *= _69.d2;
    _76 += _71;
    _69.data[_76] = _75;
    _71++;
    if (_71 < q)
    goto _jump3592;
    _71 = 0;
    _72++;
    if (_72 < c.d0)
    goto _jump3592;
    _72 = 0;
    _73++;
    if (_73 < c.d0)
    goto _jump3592;
    // End body of loop
    _56 = _69;
    _jump3588:;
    _42 = _56;
    goto _jump3595;
    _jump3570:;
    _a3__a3_double _77;
    // Computing bound for Q
    int64_t _78 = 161;
    _77.d0 = _78;
    if (_78 > 0) 
    goto _jump3596;
    fail_assertion("non-positive loop bound");
    _jump3596:;
    // Computing bound for R
    _77.d1 = _10.d0;
    if (_10.d0 > 0) 
    goto _jump3597;
    fail_assertion("non-positive loop bound");
    _jump3597:;
    // Computing bound for S
    _77.d2 = v;
    if (v > 0) 
    goto _jump3598;
    fail_assertion("non-positive loop bound");
    _jump3598:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= _78;
    _79 *= _10.d0;
    _79 *= v;
    _79 *= sizeof(_a3_double);
    _77.data = jpl_alloc(_79);
    int64_t _80 = 0; // S
    int64_t _81 = 0; // R
    int64_t _82 = 0; // Q
    _jump3599:; // Begin body of loop
    _a3_double _83;
    // Computing bound for T
    _83.d0 = r;
    if (r > 0) 
    goto _jump3600;
    fail_assertion("non-positive loop bound");
    _jump3600:;
    // Computing bound for U
    _83.d1 = h;
    if (h > 0) 
    goto _jump3601;
    fail_assertion("non-positive loop bound");
    _jump3601:;
    // Computing bound for V
    _83.d2 = v;
    if (v > 0) 
    goto _jump3602;
    fail_assertion("non-positive loop bound");
    _jump3602:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= r;
    _84 *= h;
    _84 *= v;
    _84 *= sizeof(double);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // V
    int64_t _86 = 0; // U
    int64_t _87 = 0; // T
    _jump3603:; // Begin body of loop
    double _88 = 76.0;
    int64_t _89 = 0;
    _89 *= _83.d0;
    _89 += _87;
    _89 *= _83.d1;
    _89 += _86;
    _89 *= _83.d2;
    _89 += _85;
    _83.data[_89] = _88;
    _85++;
    if (_85 < v)
    goto _jump3603;
    _85 = 0;
    _86++;
    if (_86 < h)
    goto _jump3603;
    _86 = 0;
    _87++;
    if (_87 < r)
    goto _jump3603;
    // End body of loop
    int64_t _90 = 0;
    _90 *= _77.d0;
    _90 += _82;
    _90 *= _77.d1;
    _90 += _81;
    _90 *= _77.d2;
    _90 += _80;
    _77.data[_90] = _83;
    _80++;
    if (_80 < v)
    goto _jump3599;
    _80 = 0;
    _81++;
    if (_81 < _10.d0)
    goto _jump3599;
    _81 = 0;
    _82++;
    if (_82 < _78)
    goto _jump3599;
    // End body of loop
    int64_t _91 = -_10.d0;
    if (_10.d1 >= 0)
    goto _jump3604;
    fail_assertion("negative array index");
    _jump3604:;
    if (_10.d1 < _77.d0)
    goto _jump3605;
    fail_assertion("index too large");
    _jump3605:;
    if (_91 >= 0)
    goto _jump3606;
    fail_assertion("negative array index");
    _jump3606:;
    if (_91 < _77.d1)
    goto _jump3607;
    fail_assertion("index too large");
    _jump3607:;
    if (v >= 0)
    goto _jump3608;
    fail_assertion("negative array index");
    _jump3608:;
    if (v < _77.d2)
    goto _jump3609;
    fail_assertion("index too large");
    _jump3609:;
    int64_t _92 = 0;
    _92 *= _77.d0;
    _92 += _10.d1;
    _92 *= _77.d1;
    _92 += _91;
    _92 *= _77.d2;
    _92 += v;
    _a3_double _93 = _77.data[_92];
    bool _94 = n(_93);
    _a3_double _95;
    if (!_94)
    goto _jump3610;
    _a3__a3_double _96;
    // Computing bound for Q
    _96.d0 = _10.d2;
    if (_10.d2 > 0) 
    goto _jump3611;
    fail_assertion("non-positive loop bound");
    _jump3611:;
    // Computing bound for R
    int64_t _97 = -r;
    if (_97 >= 0)
    goto _jump3612;
    fail_assertion("negative array index");
    _jump3612:;
    if (_97 < e.d0)
    goto _jump3613;
    fail_assertion("index too large");
    _jump3613:;
    if (h >= 0)
    goto _jump3614;
    fail_assertion("negative array index");
    _jump3614:;
    if (h < e.d1)
    goto _jump3615;
    fail_assertion("index too large");
    _jump3615:;
    if (f >= 0)
    goto _jump3616;
    fail_assertion("negative array index");
    _jump3616:;
    if (f < e.d2)
    goto _jump3617;
    fail_assertion("index too large");
    _jump3617:;
    int64_t _98 = 0;
    _98 *= e.d0;
    _98 += _97;
    _98 *= e.d1;
    _98 += h;
    _98 *= e.d2;
    _98 += f;
    int64_t _99 = e.data[_98];
    _96.d1 = _99;
    if (_99 > 0) 
    goto _jump3618;
    fail_assertion("non-positive loop bound");
    _jump3618:;
    // Computing bound for S
    _96.d2 = j;
    if (j > 0) 
    goto _jump3619;
    fail_assertion("non-positive loop bound");
    _jump3619:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= _10.d2;
    _100 *= _99;
    _100 *= j;
    _100 *= sizeof(_a3_double);
    _96.data = jpl_alloc(_100);
    int64_t _101 = 0; // S
    int64_t _102 = 0; // R
    int64_t _103 = 0; // Q
    _jump3620:; // Begin body of loop
    _a3_double _104;
    // Computing bound for T
    _104.d0 = G;
    if (G > 0) 
    goto _jump3621;
    fail_assertion("non-positive loop bound");
    _jump3621:;
    // Computing bound for U
    _104.d1 = q;
    if (q > 0) 
    goto _jump3622;
    fail_assertion("non-positive loop bound");
    _jump3622:;
    // Computing bound for V
    _104.d2 = c.d0;
    if (c.d0 > 0) 
    goto _jump3623;
    fail_assertion("non-positive loop bound");
    _jump3623:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= G;
    _105 *= q;
    _105 *= c.d0;
    _105 *= sizeof(double);
    _104.data = jpl_alloc(_105);
    int64_t _106 = 0; // V
    int64_t _107 = 0; // U
    int64_t _108 = 0; // T
    _jump3624:; // Begin body of loop
    double _109 = 44.0;
    int64_t _110 = 0;
    _110 *= _104.d0;
    _110 += _108;
    _110 *= _104.d1;
    _110 += _107;
    _110 *= _104.d2;
    _110 += _106;
    _104.data[_110] = _109;
    _106++;
    if (_106 < c.d0)
    goto _jump3624;
    _106 = 0;
    _107++;
    if (_107 < q)
    goto _jump3624;
    _107 = 0;
    _108++;
    if (_108 < G)
    goto _jump3624;
    // End body of loop
    int64_t _111 = 0;
    _111 *= _96.d0;
    _111 += _103;
    _111 *= _96.d1;
    _111 += _102;
    _111 *= _96.d2;
    _111 += _101;
    _96.data[_111] = _104;
    _101++;
    if (_101 < j)
    goto _jump3620;
    _101 = 0;
    _102++;
    if (_102 < _99)
    goto _jump3620;
    _102 = 0;
    _103++;
    if (_103 < _10.d2)
    goto _jump3620;
    // End body of loop
    int64_t _112 = -k;
    bool _113 = q > _112;
    int64_t _114;
    if (!_113)
    goto _jump3625;
    int64_t _115;
    // Computing bound for Q
    if (k >= 0)
    goto _jump3626;
    fail_assertion("negative array index");
    _jump3626:;
    if (k < _10.d0)
    goto _jump3627;
    fail_assertion("index too large");
    _jump3627:;
    if (j >= 0)
    goto _jump3628;
    fail_assertion("negative array index");
    _jump3628:;
    if (j < _10.d1)
    goto _jump3629;
    fail_assertion("index too large");
    _jump3629:;
    if (G >= 0)
    goto _jump3630;
    fail_assertion("negative array index");
    _jump3630:;
    if (G < _10.d2)
    goto _jump3631;
    fail_assertion("index too large");
    _jump3631:;
    int64_t _116 = 0;
    _116 *= _10.d0;
    _116 += k;
    _116 *= _10.d1;
    _116 += j;
    _116 *= _10.d2;
    _116 += G;
    int64_t _117 = _10.data[_116];
    if (_117 > 0) 
    goto _jump3632;
    fail_assertion("non-positive loop bound");
    _jump3632:;
    _115 = 0;
    int64_t _118 = 0; // Q
    _jump3633:; // Begin body of loop
    int64_t _119 = -u;
    _115 += _119;
    _118++;
    if (_118 < _117)
    goto _jump3633;
    // End body of loop
    _114 = _115;
    goto _jump3634;
    _jump3625:;
    _114 = _10.d1;
    _jump3634:;
    if (v >= 0)
    goto _jump3635;
    fail_assertion("negative array index");
    _jump3635:;
    if (v < _96.d0)
    goto _jump3636;
    fail_assertion("index too large");
    _jump3636:;
    if (h >= 0)
    goto _jump3637;
    fail_assertion("negative array index");
    _jump3637:;
    if (h < _96.d1)
    goto _jump3638;
    fail_assertion("index too large");
    _jump3638:;
    if (_114 >= 0)
    goto _jump3639;
    fail_assertion("negative array index");
    _jump3639:;
    if (_114 < _96.d2)
    goto _jump3640;
    fail_assertion("index too large");
    _jump3640:;
    int64_t _120 = 0;
    _120 *= _96.d0;
    _120 += v;
    _120 *= _96.d1;
    _120 += h;
    _120 *= _96.d2;
    _120 += _114;
    _a3_double _121 = _96.data[_120];
    _95 = _121;
    goto _jump3641;
    _jump3610:;
    _a3_double _122;
    // Computing bound for Q
    _122.d0 = _10.d0;
    if (_10.d0 > 0) 
    goto _jump3642;
    fail_assertion("non-positive loop bound");
    _jump3642:;
    // Computing bound for R
    _122.d1 = x;
    if (x > 0) 
    goto _jump3643;
    fail_assertion("non-positive loop bound");
    _jump3643:;
    // Computing bound for S
    _122.d2 = q;
    if (q > 0) 
    goto _jump3644;
    fail_assertion("non-positive loop bound");
    _jump3644:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= _10.d0;
    _123 *= x;
    _123 *= q;
    _123 *= sizeof(double);
    _122.data = jpl_alloc(_123);
    int64_t _124 = 0; // S
    int64_t _125 = 0; // R
    int64_t _126 = 0; // Q
    _jump3645:; // Begin body of loop
    _a3_double _127;
    // Computing bound for T
    _127.d0 = G;
    if (G > 0) 
    goto _jump3646;
    fail_assertion("non-positive loop bound");
    _jump3646:;
    // Computing bound for U
    int64_t _128 = 203;
    _127.d1 = _128;
    if (_128 > 0) 
    goto _jump3647;
    fail_assertion("non-positive loop bound");
    _jump3647:;
    // Computing bound for V
    _127.d2 = _125;
    if (_125 > 0) 
    goto _jump3648;
    fail_assertion("non-positive loop bound");
    _jump3648:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= G;
    _129 *= _128;
    _129 *= _125;
    _129 *= sizeof(double);
    _127.data = jpl_alloc(_129);
    int64_t _130 = 0; // V
    int64_t _131 = 0; // U
    int64_t _132 = 0; // T
    _jump3649:; // Begin body of loop
    double _133 = 24.0;
    int64_t _134 = 0;
    _134 *= _127.d0;
    _134 += _132;
    _134 *= _127.d1;
    _134 += _131;
    _134 *= _127.d2;
    _134 += _130;
    _127.data[_134] = _133;
    _130++;
    if (_130 < _125)
    goto _jump3649;
    _130 = 0;
    _131++;
    if (_131 < _128)
    goto _jump3649;
    _131 = 0;
    _132++;
    if (_132 < G)
    goto _jump3649;
    // End body of loop
    bool _135 = F(_10.d0, H);
    double _136 = s(_127, _135, p);
    int64_t _137 = 0;
    _137 *= _122.d0;
    _137 += _126;
    _137 *= _122.d1;
    _137 += _125;
    _137 *= _122.d2;
    _137 += _124;
    _122.data[_137] = _136;
    _124++;
    if (_124 < q)
    goto _jump3645;
    _124 = 0;
    _125++;
    if (_125 < x)
    goto _jump3645;
    _125 = 0;
    _126++;
    if (_126 < _10.d0)
    goto _jump3645;
    // End body of loop
    _95 = _122;
    _jump3641:;
    _42 = _95;
    _jump3595:;
    _a3_double _138;
    // Computing bound for Q
    _138.d0 = u;
    if (u > 0) 
    goto _jump3650;
    fail_assertion("non-positive loop bound");
    _jump3650:;
    // Computing bound for R
    _138.d1 = q;
    if (q > 0) 
    goto _jump3651;
    fail_assertion("non-positive loop bound");
    _jump3651:;
    // Computing bound for S
    _138.d2 = E;
    if (E > 0) 
    goto _jump3652;
    fail_assertion("non-positive loop bound");
    _jump3652:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= u;
    _139 *= q;
    _139 *= E;
    _139 *= sizeof(double);
    _138.data = jpl_alloc(_139);
    int64_t _140 = 0; // S
    int64_t _141 = 0; // R
    int64_t _142 = 0; // Q
    _jump3653:; // Begin body of loop
    _a3_double _143;
    // Computing bound for T
    _143.d0 = g;
    if (g > 0) 
    goto _jump3654;
    fail_assertion("non-positive loop bound");
    _jump3654:;
    // Computing bound for U
    _143.d1 = r;
    if (r > 0) 
    goto _jump3655;
    fail_assertion("non-positive loop bound");
    _jump3655:;
    // Computing bound for V
    _143.d2 = _10.d2;
    if (_10.d2 > 0) 
    goto _jump3656;
    fail_assertion("non-positive loop bound");
    _jump3656:;
    // Computing total size of heap memory to allocate
    int64_t _144 = 1;
    _144 *= g;
    _144 *= r;
    _144 *= _10.d2;
    _144 *= sizeof(double);
    _143.data = jpl_alloc(_144);
    int64_t _145 = 0; // V
    int64_t _146 = 0; // U
    int64_t _147 = 0; // T
    _jump3657:; // Begin body of loop
    if (f >= 0)
    goto _jump3658;
    fail_assertion("negative array index");
    _jump3658:;
    if (f < d.d0)
    goto _jump3659;
    fail_assertion("index too large");
    _jump3659:;
    int64_t _148 = 0;
    _148 *= d.d0;
    _148 += f;
    double _149 = d.data[_148];
    int64_t _150 = 0;
    _150 *= _143.d0;
    _150 += _147;
    _150 *= _143.d1;
    _150 += _146;
    _150 *= _143.d2;
    _150 += _145;
    _143.data[_150] = _149;
    _145++;
    if (_145 < _10.d2)
    goto _jump3657;
    _145 = 0;
    _146++;
    if (_146 < r)
    goto _jump3657;
    _146 = 0;
    _147++;
    if (_147 < g)
    goto _jump3657;
    // End body of loop
    bool _151 = n(_143);
    double _152;
    if (!_151)
    goto _jump3660;
    bool _154 = true;
    bool _153 = _154;
    if (0 != _154)
    goto _jump3661;
    bool _155 = true;
    _153 = _155;
    _jump3661:;
    double _156;
    if (!_153)
    goto _jump3662;
    double _157;
    // Computing bound for T
    if (_10.d2 > 0) 
    goto _jump3663;
    fail_assertion("non-positive loop bound");
    _jump3663:;
    // Computing bound for U
    if (c.d0 > 0) 
    goto _jump3664;
    fail_assertion("non-positive loop bound");
    _jump3664:;
    _157 = 0;
    int64_t _158 = 0; // U
    int64_t _159 = 0; // T
    _jump3665:; // Begin body of loop
    double _160 = 49.0;
    _157 += _160;
    _158++;
    if (_158 < c.d0)
    goto _jump3665;
    _158 = 0;
    _159++;
    if (_159 < _10.d2)
    goto _jump3665;
    // End body of loop
    _156 = _157;
    goto _jump3666;
    _jump3662:;
    double _161 = H.g;
    _156 = _161;
    _jump3666:;
    double _162 = -_156;
    _152 = _162;
    goto _jump3667;
    _jump3660:;
    double _163 = 86.0;
    _152 = _163;
    _jump3667:;
    int64_t _164 = 0;
    _164 *= _138.d0;
    _164 += _142;
    _164 *= _138.d1;
    _164 += _141;
    _164 *= _138.d2;
    _164 += _140;
    _138.data[_164] = _152;
    _140++;
    if (_140 < E)
    goto _jump3653;
    _140 = 0;
    _141++;
    if (_141 < q)
    goto _jump3653;
    _141 = 0;
    _142++;
    if (_142 < u)
    goto _jump3653;
    // End body of loop
    bool _165 = n(_138);
    rgba _166 = o(_42, _165, r);
    double _167 = 40.0;
    double _168;
    // Computing bound for R
    if (k > 0) 
    goto _jump3668;
    fail_assertion("non-positive loop bound");
    _jump3668:;
    _168 = 0;
    int64_t _169 = 0; // R
    _jump3669:; // Begin body of loop
    double _170 = H.b;
    _168 += _170;
    _169++;
    if (_169 < k)
    goto _jump3669;
    // End body of loop
    double _171 = 44.0;
    bool _172 = false;
    double _173;
    if (!_172)
    goto _jump3670;
    double _174 = 87.0;
    _173 = _174;
    goto _jump3671;
    _jump3670:;
    double _175 = 61.0;
    double _176 = -_175;
    double _177 = -_176;
    _173 = _177;
    _jump3671:;
    bool _179 = true;
    bool _178 = _179;
    if (0 == _179)
    goto _jump3672;
    bool _180 = F(_10.d1, _166);
    _178 = _180;
    _jump3672:;
    double _181;
    if (!_178)
    goto _jump3673;
    double _182;
    // Computing bound for R
    if (_10.d1 > 0) 
    goto _jump3674;
    fail_assertion("non-positive loop bound");
    _jump3674:;
    // Computing bound for S
    if (G > 0) 
    goto _jump3675;
    fail_assertion("non-positive loop bound");
    _jump3675:;
    // Computing bound for T
    if (_10.d1 > 0) 
    goto _jump3676;
    fail_assertion("non-positive loop bound");
    _jump3676:;
    _182 = 0;
    int64_t _183 = 0; // T
    int64_t _184 = 0; // S
    int64_t _185 = 0; // R
    _jump3677:; // Begin body of loop
    double _186 = 0.0;
    _182 += _186;
    _183++;
    if (_183 < _10.d1)
    goto _jump3677;
    _183 = 0;
    _184++;
    if (_184 < G)
    goto _jump3677;
    _184 = 0;
    _185++;
    if (_185 < _10.d1)
    goto _jump3677;
    // End body of loop
    double _187 = H.b;
    double _188 = _182 * _187;
    _181 = _188;
    goto _jump3678;
    _jump3673:;
    double _189;
    // Computing bound for R
    if (u > 0) 
    goto _jump3679;
    fail_assertion("non-positive loop bound");
    _jump3679:;
    // Computing bound for S
    if (c.d0 > 0) 
    goto _jump3680;
    fail_assertion("non-positive loop bound");
    _jump3680:;
    _189 = 0;
    int64_t _190 = 0; // S
    int64_t _191 = 0; // R
    _jump3681:; // Begin body of loop
    if (G >= 0)
    goto _jump3682;
    fail_assertion("negative array index");
    _jump3682:;
    if (G < c.d0)
    goto _jump3683;
    fail_assertion("index too large");
    _jump3683:;
    int64_t _192 = 0;
    _192 *= c.d0;
    _192 += G;
    double _193 = c.data[_192];
    _189 += _193;
    _190++;
    if (_190 < c.d0)
    goto _jump3681;
    _190 = 0;
    _191++;
    if (_191 < u)
    goto _jump3681;
    // End body of loop
    _181 = _189;
    _jump3678:;
    rgba _194 = { _168, _171, _173, _181 };
    double _195 = _194.a;
    bool _196 = _167 == _195;
    bool _197;
    if (!_196)
    goto _jump3684;
    _a1_int64_t _198;
    // Computing bound for R
    _198.d0 = f;
    if (f > 0) 
    goto _jump3685;
    fail_assertion("non-positive loop bound");
    _jump3685:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= f;
    _199 *= sizeof(int64_t);
    _198.data = jpl_alloc(_199);
    int64_t _200 = 0; // R
    _jump3686:; // Begin body of loop
    int64_t _201 = 0;
    _201 *= _198.d0;
    _201 += _200;
    _198.data[_201] = k;
    _200++;
    if (_200 < f)
    goto _jump3686;
    // End body of loop
    if (j >= 0)
    goto _jump3687;
    fail_assertion("negative array index");
    _jump3687:;
    if (j < _198.d0)
    goto _jump3688;
    fail_assertion("index too large");
    _jump3688:;
    int64_t _202 = 0;
    _202 *= _198.d0;
    _202 += j;
    int64_t _203 = _198.data[_202];
    bool _204 = F(_203, H);
    bool _205;
    if (!_204)
    goto _jump3689;
    bool _206 = false;
    bool _207;
    if (!_206)
    goto _jump3690;
    double _208 = _166.r;
    double _209 = 93.0;
    double _210 = 27.0;
    double _211 = _209 + _210;
    bool _212 = _208 == _211;
    _207 = _212;
    goto _jump3691;
    _jump3690:;
    bool _213 = true;
    bool _214 = true;
    _a1_bool _215;
    _215.d0 = 2;
    _215.data = jpl_alloc(sizeof(bool) * 2);
    _215.data[0] = _213;
    _215.data[1] = _214;
    if (j >= 0)
    goto _jump3692;
    fail_assertion("negative array index");
    _jump3692:;
    if (j < _215.d0)
    goto _jump3693;
    fail_assertion("index too large");
    _jump3693:;
    int64_t _216 = 0;
    _216 *= _215.d0;
    _216 += j;
    bool _217 = _215.data[_216];
    _207 = _217;
    _jump3691:;
    _205 = _207;
    goto _jump3694;
    _jump3689:;
    bool _218 = u <= _10.d1;
    bool _219 = !_218;
    bool _220;
    if (!_219)
    goto _jump3695;
    double _222 = 17.0;
    double _223 = 30.0;
    bool _224 = _222 <= _223;
    bool _221 = _224;
    if (0 != _224)
    goto _jump3696;
    int64_t _225 = 28;
    bool _226 = _225 > E;
    _221 = _226;
    _jump3696:;
    _220 = _221;
    goto _jump3697;
    _jump3695:;
    bool _227 = F(_10.d1, A);
    bool _228;
    if (!_227)
    goto _jump3698;
    bool _229 = F(k, _166);
    _228 = _229;
    goto _jump3699;
    _jump3698:;
    bool _230 = F(j, H);
    _228 = _230;
    _jump3699:;
    _220 = _228;
    _jump3697:;
    _205 = _220;
    _jump3694:;
    _a3_double _231;
    if (!_205)
    goto _jump3700;
    _a3_double _232;
    // Computing bound for R
    _232.d0 = j;
    if (j > 0) 
    goto _jump3701;
    fail_assertion("non-positive loop bound");
    _jump3701:;
    // Computing bound for S
    _232.d1 = E;
    if (E > 0) 
    goto _jump3702;
    fail_assertion("non-positive loop bound");
    _jump3702:;
    // Computing bound for T
    _232.d2 = j;
    if (j > 0) 
    goto _jump3703;
    fail_assertion("non-positive loop bound");
    _jump3703:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= j;
    _233 *= E;
    _233 *= j;
    _233 *= sizeof(double);
    _232.data = jpl_alloc(_233);
    int64_t _234 = 0; // T
    int64_t _235 = 0; // S
    int64_t _236 = 0; // R
    _jump3704:; // Begin body of loop
    _a1_rgba _237;
    _237.d0 = 2;
    _237.data = jpl_alloc(sizeof(rgba) * 2);
    _237.data[0] = H;
    _237.data[1] = _166;
    if (_10.d0 >= 0)
    goto _jump3705;
    fail_assertion("negative array index");
    _jump3705:;
    if (_10.d0 < _237.d0)
    goto _jump3706;
    fail_assertion("index too large");
    _jump3706:;
    int64_t _238 = 0;
    _238 *= _237.d0;
    _238 += _10.d0;
    rgba _239 = _237.data[_238];
    double _240 = _239.r;
    int64_t _241 = 0;
    _241 *= _232.d0;
    _241 += _236;
    _241 *= _232.d1;
    _241 += _235;
    _241 *= _232.d2;
    _241 += _234;
    _232.data[_241] = _240;
    _234++;
    if (_234 < j)
    goto _jump3704;
    _234 = 0;
    _235++;
    if (_235 < E)
    goto _jump3704;
    _235 = 0;
    _236++;
    if (_236 < j)
    goto _jump3704;
    // End body of loop
    _231 = _232;
    goto _jump3707;
    _jump3700:;
    _a3__a3_double _242;
    // Computing bound for R
    _242.d0 = v;
    if (v > 0) 
    goto _jump3708;
    fail_assertion("non-positive loop bound");
    _jump3708:;
    // Computing bound for S
    _242.d1 = u;
    if (u > 0) 
    goto _jump3709;
    fail_assertion("non-positive loop bound");
    _jump3709:;
    // Computing bound for T
    _242.d2 = f;
    if (f > 0) 
    goto _jump3710;
    fail_assertion("non-positive loop bound");
    _jump3710:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= v;
    _243 *= u;
    _243 *= f;
    _243 *= sizeof(_a3_double);
    _242.data = jpl_alloc(_243);
    int64_t _244 = 0; // T
    int64_t _245 = 0; // S
    int64_t _246 = 0; // R
    _jump3711:; // Begin body of loop
    _a3_double _247;
    // Computing bound for U
    int64_t _248 = -G;
    _247.d0 = _248;
    if (_248 > 0) 
    goto _jump3712;
    fail_assertion("non-positive loop bound");
    _jump3712:;
    // Computing bound for V
    _247.d1 = _10.d1;
    if (_10.d1 > 0) 
    goto _jump3713;
    fail_assertion("non-positive loop bound");
    _jump3713:;
    // Computing bound for W
    _247.d2 = g;
    if (g > 0) 
    goto _jump3714;
    fail_assertion("non-positive loop bound");
    _jump3714:;
    // Computing total size of heap memory to allocate
    int64_t _249 = 1;
    _249 *= _248;
    _249 *= _10.d1;
    _249 *= g;
    _249 *= sizeof(double);
    _247.data = jpl_alloc(_249);
    int64_t _250 = 0; // W
    int64_t _251 = 0; // V
    int64_t _252 = 0; // U
    _jump3715:; // Begin body of loop
    double _253 = A.g;
    int64_t _254 = 0;
    _254 *= _247.d0;
    _254 += _252;
    _254 *= _247.d1;
    _254 += _251;
    _254 *= _247.d2;
    _254 += _250;
    _247.data[_254] = _253;
    _250++;
    if (_250 < g)
    goto _jump3715;
    _250 = 0;
    _251++;
    if (_251 < _10.d1)
    goto _jump3715;
    _251 = 0;
    _252++;
    if (_252 < _248)
    goto _jump3715;
    // End body of loop
    int64_t _255 = 0;
    _255 *= _242.d0;
    _255 += _246;
    _255 *= _242.d1;
    _255 += _245;
    _255 *= _242.d2;
    _255 += _244;
    _242.data[_255] = _247;
    _244++;
    if (_244 < f)
    goto _jump3711;
    _244 = 0;
    _245++;
    if (_245 < u)
    goto _jump3711;
    _245 = 0;
    _246++;
    if (_246 < v)
    goto _jump3711;
    // End body of loop
    if (_10.d2 >= 0)
    goto _jump3716;
    fail_assertion("negative array index");
    _jump3716:;
    if (_10.d2 < _242.d0)
    goto _jump3717;
    fail_assertion("index too large");
    _jump3717:;
    if (g >= 0)
    goto _jump3718;
    fail_assertion("negative array index");
    _jump3718:;
    if (g < _242.d1)
    goto _jump3719;
    fail_assertion("index too large");
    _jump3719:;
    if (r >= 0)
    goto _jump3720;
    fail_assertion("negative array index");
    _jump3720:;
    if (r < _242.d2)
    goto _jump3721;
    fail_assertion("index too large");
    _jump3721:;
    int64_t _256 = 0;
    _256 *= _242.d0;
    _256 += _10.d2;
    _256 *= _242.d1;
    _256 += g;
    _256 *= _242.d2;
    _256 += r;
    _a3_double _257 = _242.data[_256];
    _231 = _257;
    _jump3707:;
    bool _258 = n(_231);
    _197 = _258;
    goto _jump3722;
    _jump3684:;
    bool _259 = F(_10.d2, H);
    _197 = _259;
    _jump3722:;
    return _197;
}

void jpl_main(struct args args) {
    double _0 = 94.0;
    double _1 = 34.0;
    bool _2 = _0 < _1;
    _a1__a2__a1_double _3;
    if (!_2)
    goto _jump677;
    _a1__a2__a1_double _4;
    // Computing bound for c
    int64_t _5 = 798;
    int64_t _6 = 266;
    int64_t _7 = 347;
    _a1_int64_t _8;
    _8.d0 = 3;
    _8.data = jpl_alloc(sizeof(int64_t) * 3);
    _8.data[0] = _5;
    _8.data[1] = _6;
    _8.data[2] = _7;
    int64_t _9 = 445;
    int64_t _10 = -_9;
    int64_t _11 = -_10;
    if (_11 >= 0)
    goto _jump678;
    fail_assertion("negative array index");
    _jump678:;
    if (_11 < _8.d0)
    goto _jump679;
    fail_assertion("index too large");
    _jump679:;
    int64_t _12 = 0;
    _12 *= _8.d0;
    _12 += _11;
    int64_t _13 = _8.data[_12];
    _4.d0 = _13;
    if (_13 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _13;
    _14 *= sizeof(_a2__a1_double);
    _4.data = jpl_alloc(_14);
    int64_t _15 = 0; // c
    _jump681:; // Begin body of loop
    _a2__a1_double _16;
    // Computing bound for d
    _16.d0 = _15;
    if (_15 > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing bound for e
    int64_t _17 = 721;
    int64_t _18 = -_17;
    int64_t _19 = 640;
    int64_t _20 = 110;
    int64_t _21 = _19 % _20;
    int64_t _22 = _18 + _21;
    _16.d1 = _22;
    if (_22 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= _15;
    _23 *= _22;
    _23 *= sizeof(_a1_double);
    _16.data = jpl_alloc(_23);
    int64_t _24 = 0; // e
    int64_t _25 = 0; // d
    _jump684:; // Begin body of loop
    _a1_double _26;
    // Computing bound for f
    int64_t _27 = 194;
    _26.d0 = _27;
    if (_27 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing total size of heap memory to allocate
    int64_t _28 = 1;
    _28 *= _27;
    _28 *= sizeof(double);
    _26.data = jpl_alloc(_28);
    int64_t _29 = 0; // f
    _jump686:; // Begin body of loop
    double _30 = 76.0;
    int64_t _31 = 0;
    _31 *= _26.d0;
    _31 += _29;
    _26.data[_31] = _30;
    _29++;
    if (_29 < _27)
    goto _jump686;
    // End body of loop
    int64_t _32 = 0;
    _32 *= _16.d0;
    _32 += _25;
    _32 *= _16.d1;
    _32 += _24;
    _16.data[_32] = _26;
    _24++;
    if (_24 < _22)
    goto _jump684;
    _24 = 0;
    _25++;
    if (_25 < _15)
    goto _jump684;
    // End body of loop
    int64_t _33 = 0;
    _33 *= _4.d0;
    _33 += _15;
    _4.data[_33] = _16;
    _15++;
    if (_15 < _13)
    goto _jump681;
    // End body of loop
    _3 = _4;
    goto _jump687;
    _jump677:;
    _a2__a1_double _34;
    // Computing bound for c
    int64_t _35;
    // Computing bound for c
    int64_t _36 = 734;
    if (_36 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for d
    int64_t _37 = 495;
    if (_37 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing bound for e
    bool _38 = false;
    int64_t _39;
    if (!_38)
    goto _jump690;
    int64_t _40 = 223;
    _39 = _40;
    goto _jump691;
    _jump690:;
    int64_t _41 = 691;
    _39 = _41;
    _jump691:;
    if (_39 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    _35 = 0;
    int64_t _42 = 0; // e
    int64_t _43 = 0; // d
    int64_t _44 = 0; // c
    _jump693:; // Begin body of loop
    int64_t _45 = 21;
    _35 += _45;
    _42++;
    if (_42 < _39)
    goto _jump693;
    _42 = 0;
    _43++;
    if (_43 < _37)
    goto _jump693;
    _43 = 0;
    _44++;
    if (_44 < _36)
    goto _jump693;
    // End body of loop
    _34.d0 = _35;
    if (_35 > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    // Computing bound for d
    int64_t _46 = 796;
    _34.d1 = _46;
    if (_46 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= _35;
    _47 *= _46;
    _47 *= sizeof(_a1_double);
    _34.data = jpl_alloc(_47);
    int64_t _48 = 0; // d
    int64_t _49 = 0; // c
    _jump696:; // Begin body of loop
    _a1_double _50;
    // Computing bound for e
    int64_t _51 = _49 % _48;
    _50.d0 = _51;
    if (_51 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= _51;
    _52 *= sizeof(double);
    _50.data = jpl_alloc(_52);
    int64_t _53 = 0; // e
    _jump698:; // Begin body of loop
    double _54 = 32.0;
    int64_t _55 = 0;
    _55 *= _50.d0;
    _55 += _53;
    _50.data[_55] = _54;
    _53++;
    if (_53 < _51)
    goto _jump698;
    // End body of loop
    int64_t _56 = 0;
    _56 *= _34.d0;
    _56 += _49;
    _56 *= _34.d1;
    _56 += _48;
    _34.data[_56] = _50;
    _48++;
    if (_48 < _46)
    goto _jump696;
    _48 = 0;
    _49++;
    if (_49 < _35)
    goto _jump696;
    // End body of loop
    _a1__a2__a1_double _57;
    _57.d0 = 1;
    _57.data = jpl_alloc(sizeof(_a2__a1_double) * 1);
    _57.data[0] = _34;
    _3 = _57;
    _jump687:;
    int64_t _58;
    // Computing bound for c
    int64_t _59;
    // Computing bound for c
    int64_t _60 = 504;
    if (_60 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    // Computing bound for d
    int64_t _61;
    // Computing bound for c
    int64_t _62 = 949;
    if (_62 > 0) 
    goto _jump700;
    fail_assertion("non-positive loop bound");
    _jump700:;
    _61 = 0;
    int64_t _63 = 0; // c
    _jump701:; // Begin body of loop
    int64_t _64 = 398;
    int64_t _65 = -_64;
    _61 += _65;
    _63++;
    if (_63 < _62)
    goto _jump701;
    // End body of loop
    if (_61 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    _59 = 0;
    int64_t _66 = 0; // d
    int64_t _67 = 0; // c
    _jump703:; // Begin body of loop
    int64_t _68;
    // Computing bound for e
    if (_66 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    _68 = 0;
    int64_t _69 = 0; // e
    _jump705:; // Begin body of loop
    int64_t _70 = 678;
    int64_t _71 = -_70;
    _68 += _71;
    _69++;
    if (_69 < _66)
    goto _jump705;
    // End body of loop
    _59 += _68;
    _66++;
    if (_66 < _61)
    goto _jump703;
    _66 = 0;
    _67++;
    if (_67 < _60)
    goto _jump703;
    // End body of loop
    int64_t _72 = 275;
    int64_t _73 = _59 - _72;
    if (_73 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    // Computing bound for d
    bool _74 = true;
    bool _75 = !_74;
    int64_t _76;
    if (!_75)
    goto _jump707;
    int64_t _77 = 538;
    _76 = _77;
    goto _jump708;
    _jump707:;
    int64_t _78 = 678;
    _76 = _78;
    _jump708:;
    int64_t _79 = -_76;
    int64_t _80 = -_79;
    if (_80 > 0) 
    goto _jump709;
    fail_assertion("non-positive loop bound");
    _jump709:;
    // Computing bound for e
    int64_t _81;
    // Computing bound for c
    bool _82 = true;
    int64_t _83;
    if (!_82)
    goto _jump710;
    int64_t _84 = 952;
    int64_t _85 = 712;
    int64_t _86 = -_85;
    int64_t _87 = _84 + _86;
    _83 = _87;
    goto _jump711;
    _jump710:;
    int64_t _88 = 650;
    int64_t _89 = 868;
    int64_t _90 = _88 / _89;
    int64_t _91 = -_90;
    _83 = _91;
    _jump711:;
    if (_83 > 0) 
    goto _jump712;
    fail_assertion("non-positive loop bound");
    _jump712:;
    // Computing bound for d
    int64_t _92 = 224;
    int64_t _93 = -_92;
    int64_t _94 = 926;
    int64_t _95 = -_94;
    int64_t _96 = _93 + _95;
    int64_t _97;
    // Computing bound for c
    int64_t _98 = 288;
    if (_98 > 0) 
    goto _jump713;
    fail_assertion("non-positive loop bound");
    _jump713:;
    // Computing bound for d
    int64_t _99 = 587;
    if (_99 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for e
    int64_t _100 = 877;
    int64_t _101 = -_100;
    if (_101 > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    _97 = 0;
    int64_t _102 = 0; // e
    int64_t _103 = 0; // d
    int64_t _104 = 0; // c
    _jump716:; // Begin body of loop
    _97 += _103;
    _102++;
    if (_102 < _101)
    goto _jump716;
    _102 = 0;
    _103++;
    if (_103 < _99)
    goto _jump716;
    _103 = 0;
    _104++;
    if (_104 < _98)
    goto _jump716;
    // End body of loop
    int64_t _105 = _96 % _97;
    if (_105 > 0) 
    goto _jump717;
    fail_assertion("non-positive loop bound");
    _jump717:;
    _81 = 0;
    int64_t _106 = 0; // d
    int64_t _107 = 0; // c
    _jump718:; // Begin body of loop
    int64_t _108;
    // Computing bound for e
    int64_t _109 = 438;
    int64_t _110 = 354;
    bool _111 = _109 > _110;
    int64_t _112;
    if (!_111)
    goto _jump719;
    int64_t _113 = 428;
    _112 = _113;
    goto _jump720;
    _jump719:;
    int64_t _114 = 971;
    int64_t _115 = _114 * _107;
    _112 = _115;
    _jump720:;
    if (_112 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for f
    _a2_int64_t _116;
    // Computing bound for e
    _116.d0 = _107;
    if (_107 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing bound for f
    _116.d1 = _107;
    if (_107 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= _107;
    _117 *= _107;
    _117 *= sizeof(int64_t);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // f
    int64_t _119 = 0; // e
    _jump724:; // Begin body of loop
    int64_t _120 = 0;
    _120 *= _116.d0;
    _120 += _119;
    _120 *= _116.d1;
    _120 += _118;
    _116.data[_120] = _107;
    _118++;
    if (_118 < _107)
    goto _jump724;
    _118 = 0;
    _119++;
    if (_119 < _107)
    goto _jump724;
    // End body of loop
    int64_t _121 = -_106;
    int64_t _122 = -_107;
    if (_121 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_121 < _116.d0)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    if (_122 >= 0)
    goto _jump727;
    fail_assertion("negative array index");
    _jump727:;
    if (_122 < _116.d1)
    goto _jump728;
    fail_assertion("index too large");
    _jump728:;
    int64_t _123 = 0;
    _123 *= _116.d0;
    _123 += _121;
    _123 *= _116.d1;
    _123 += _122;
    int64_t _124 = _116.data[_123];
    if (_124 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing bound for g
    bool _125 = true;
    int64_t _126;
    if (!_125)
    goto _jump730;
    _126 = _107;
    goto _jump731;
    _jump730:;
    _126 = _107;
    _jump731:;
    int64_t _127 = -_126;
    if (_127 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    _108 = 0;
    int64_t _128 = 0; // g
    int64_t _129 = 0; // f
    int64_t _130 = 0; // e
    _jump733:; // Begin body of loop
    bool _131 = _130 > _128;
    int64_t _132;
    if (!_131)
    goto _jump734;
    _132 = _128;
    goto _jump735;
    _jump734:;
    _132 = _128;
    _jump735:;
    _108 += _132;
    _128++;
    if (_128 < _127)
    goto _jump733;
    _128 = 0;
    _129++;
    if (_129 < _124)
    goto _jump733;
    _129 = 0;
    _130++;
    if (_130 < _112)
    goto _jump733;
    // End body of loop
    _81 += _108;
    _106++;
    if (_106 < _105)
    goto _jump718;
    _106 = 0;
    _107++;
    if (_107 < _83)
    goto _jump718;
    // End body of loop
    if (_81 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    _58 = 0;
    int64_t _133 = 0; // e
    int64_t _134 = 0; // d
    int64_t _135 = 0; // c
    _jump737:; // Begin body of loop
    bool _137 = false;
    bool _138 = true;
    bool _139 = _137 == _138;
    bool _136 = _139;
    if (0 == _139)
    goto _jump738;
    bool _140 = true;
    _136 = _140;
    _jump738:;
    _a2_int64_t _141;
    if (!_136)
    goto _jump739;
    bool _142 = false;
    _a2_int64_t _143;
    if (!_142)
    goto _jump740;
    _a2_int64_t _144;
    // Computing bound for f
    _144.d0 = _133;
    if (_133 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for g
    int64_t _145 = 406;
    _144.d1 = _145;
    if (_145 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _133;
    _146 *= _145;
    _146 *= sizeof(int64_t);
    _144.data = jpl_alloc(_146);
    int64_t _147 = 0; // g
    int64_t _148 = 0; // f
    _jump743:; // Begin body of loop
    int64_t _149 = 0;
    _149 *= _144.d0;
    _149 += _148;
    _149 *= _144.d1;
    _149 += _147;
    _144.data[_149] = _148;
    _147++;
    if (_147 < _145)
    goto _jump743;
    _147 = 0;
    _148++;
    if (_148 < _133)
    goto _jump743;
    // End body of loop
    _143 = _144;
    goto _jump744;
    _jump740:;
    _a2_int64_t _150;
    // Computing bound for f
    _150.d0 = _134;
    if (_134 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing bound for g
    _150.d1 = _135;
    if (_135 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= _134;
    _151 *= _135;
    _151 *= sizeof(int64_t);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // g
    int64_t _153 = 0; // f
    _jump747:; // Begin body of loop
    int64_t _154 = 0;
    _154 *= _150.d0;
    _154 += _153;
    _154 *= _150.d1;
    _154 += _152;
    _150.data[_154] = _133;
    _152++;
    if (_152 < _135)
    goto _jump747;
    _152 = 0;
    _153++;
    if (_153 < _134)
    goto _jump747;
    // End body of loop
    _143 = _150;
    _jump744:;
    _141 = _143;
    goto _jump748;
    _jump739:;
    _a2_int64_t _155;
    // Computing bound for f
    int64_t _156 = _133 % _135;
    _155.d0 = _156;
    if (_156 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing bound for g
    bool _157 = true;
    int64_t _158;
    if (!_157)
    goto _jump750;
    _158 = _133;
    goto _jump751;
    _jump750:;
    _158 = _133;
    _jump751:;
    _155.d1 = _158;
    if (_158 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _156;
    _159 *= _158;
    _159 *= sizeof(int64_t);
    _155.data = jpl_alloc(_159);
    int64_t _160 = 0; // g
    int64_t _161 = 0; // f
    _jump753:; // Begin body of loop
    int64_t _162 = 74;
    int64_t _163 = 102;
    int64_t _164 = _162 / _163;
    int64_t _165 = 0;
    _165 *= _155.d0;
    _165 += _161;
    _165 *= _155.d1;
    _165 += _160;
    _155.data[_165] = _164;
    _160++;
    if (_160 < _158)
    goto _jump753;
    _160 = 0;
    _161++;
    if (_161 < _156)
    goto _jump753;
    // End body of loop
    _141 = _155;
    _jump748:;
    int64_t _166 = 91;
    int64_t _167;
    // Computing bound for f
    if (_134 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    _167 = 0;
    int64_t _168 = 0; // f
    _jump755:; // Begin body of loop
    _167 += _135;
    _168++;
    if (_168 < _134)
    goto _jump755;
    // End body of loop
    if (_166 >= 0)
    goto _jump756;
    fail_assertion("negative array index");
    _jump756:;
    if (_166 < _141.d0)
    goto _jump757;
    fail_assertion("index too large");
    _jump757:;
    if (_167 >= 0)
    goto _jump758;
    fail_assertion("negative array index");
    _jump758:;
    if (_167 < _141.d1)
    goto _jump759;
    fail_assertion("index too large");
    _jump759:;
    int64_t _169 = 0;
    _169 *= _141.d0;
    _169 += _166;
    _169 *= _141.d1;
    _169 += _167;
    int64_t _170 = _141.data[_169];
    _58 += _170;
    _133++;
    if (_133 < _81)
    goto _jump737;
    _133 = 0;
    _134++;
    if (_134 < _80)
    goto _jump737;
    _134 = 0;
    _135++;
    if (_135 < _73)
    goto _jump737;
    // End body of loop
    if (_58 >= 0)
    goto _jump760;
    fail_assertion("negative array index");
    _jump760:;
    if (_58 < _3.d0)
    goto _jump761;
    fail_assertion("index too large");
    _jump761:;
    int64_t _171 = 0;
    _171 *= _3.d0;
    _171 += _58;
    _a2__a1_double _172 = _3.data[_171];
    int64_t _173 = 66;
    int64_t _174 = -_173;
    int64_t _175;
    // Computing bound for c
    bool _176 = false;
    bool _177 = !_176;
    int64_t _178;
    if (!_177)
    goto _jump762;
    int64_t _179 = 325;
    int64_t _180 = 514;
    int64_t _181 = _179 / _180;
    _178 = _181;
    goto _jump763;
    _jump762:;
    int64_t _182 = 359;
    _178 = _182;
    _jump763:;
    int64_t _183 = -_178;
    if (_183 > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    _175 = 0;
    int64_t _184 = 0; // c
    _jump765:; // Begin body of loop
    bool _185 = true;
    bool _186 = true;
    bool _187;
    if (!_186)
    goto _jump766;
    bool _188 = false;
    _187 = _188;
    goto _jump767;
    _jump766:;
    bool _189 = false;
    _187 = _189;
    _jump767:;
    bool _190 = _185 == _187;
    bool _191;
    if (!_190)
    goto _jump768;
    bool _192 = true;
    _191 = _192;
    goto _jump769;
    _jump768:;
    int64_t _193 = 968;
    int64_t _194 = -_184;
    bool _195 = _193 < _194;
    _191 = _195;
    _jump769:;
    _a1_int64_t _196;
    if (!_191)
    goto _jump770;
    _a1_int64_t _197;
    // Computing bound for d
    _a1_int64_t _198;
    // Computing bound for d
    int64_t _199 = 710;
    _198.d0 = _199;
    if (_199 > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= _199;
    _200 *= sizeof(int64_t);
    _198.data = jpl_alloc(_200);
    int64_t _201 = 0; // d
    _jump772:; // Begin body of loop
    int64_t _202 = 0;
    _202 *= _198.d0;
    _202 += _201;
    _198.data[_202] = _184;
    _201++;
    if (_201 < _199)
    goto _jump772;
    // End body of loop
    if (_184 >= 0)
    goto _jump773;
    fail_assertion("negative array index");
    _jump773:;
    if (_184 < _198.d0)
    goto _jump774;
    fail_assertion("index too large");
    _jump774:;
    int64_t _203 = 0;
    _203 *= _198.d0;
    _203 += _184;
    int64_t _204 = _198.data[_203];
    _197.d0 = _204;
    if (_204 > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _204;
    _205 *= sizeof(int64_t);
    _197.data = jpl_alloc(_205);
    int64_t _206 = 0; // d
    _jump776:; // Begin body of loop
    int64_t _207 = 628;
    int64_t _208 = 0;
    _208 *= _197.d0;
    _208 += _206;
    _197.data[_208] = _207;
    _206++;
    if (_206 < _204)
    goto _jump776;
    // End body of loop
    _196 = _197;
    goto _jump777;
    _jump770:;
    bool _209 = false;
    bool _210 = !_209;
    int64_t _211;
    if (!_210)
    goto _jump778;
    int64_t _212 = -_184;
    _211 = _212;
    goto _jump779;
    _jump778:;
    int64_t _213 = 705;
    int64_t _214 = -_213;
    _211 = _214;
    _jump779:;
    _a1_int64_t _215;
    _215.d0 = 1;
    _215.data = jpl_alloc(sizeof(int64_t) * 1);
    _215.data[0] = _211;
    _196 = _215;
    _jump777:;
    if (_184 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_184 < _196.d0)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _216 = 0;
    _216 *= _196.d0;
    _216 += _184;
    int64_t _217 = _196.data[_216];
    _175 += _217;
    _184++;
    if (_184 < _183)
    goto _jump765;
    // End body of loop
    if (_174 >= 0)
    goto _jump782;
    fail_assertion("negative array index");
    _jump782:;
    if (_174 < _172.d0)
    goto _jump783;
    fail_assertion("index too large");
    _jump783:;
    if (_175 >= 0)
    goto _jump784;
    fail_assertion("negative array index");
    _jump784:;
    if (_175 < _172.d1)
    goto _jump785;
    fail_assertion("index too large");
    _jump785:;
    int64_t _218 = 0;
    _218 *= _172.d0;
    _218 += _174;
    _218 *= _172.d1;
    _218 += _175;
    _a1_double _219 = _172.data[_218];
    double _221;
    // Computing bound for d
    int64_t _222 = 305;
    _a1_int64_t _223;
    _223.d0 = 1;
    _223.data = jpl_alloc(sizeof(int64_t) * 1);
    _223.data[0] = _222;
    int64_t _224 = 906;
    int64_t _225 = -_224;
    if (_225 >= 0)
    goto _jump786;
    fail_assertion("negative array index");
    _jump786:;
    if (_225 < _223.d0)
    goto _jump787;
    fail_assertion("index too large");
    _jump787:;
    int64_t _226 = 0;
    _226 *= _223.d0;
    _226 += _225;
    int64_t _227 = _223.data[_226];
    int64_t _228 = -_227;
    if (_228 > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    _221 = 0;
    int64_t _229 = 0; // d
    _jump789:; // Begin body of loop
    double _230;
    // Computing bound for e
    int64_t _231 = 760;
    int64_t _232 = -_231;
    int64_t _233 = -_232;
    if (_233 > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for f
    if (_229 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for g
    int64_t _234 = 869;
    if (_234 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    _230 = 0;
    int64_t _235 = 0; // g
    int64_t _236 = 0; // f
    int64_t _237 = 0; // e
    _jump793:; // Begin body of loop
    double _238 = 77.0;
    double _239 = -_238;
    _230 += _239;
    _235++;
    if (_235 < _234)
    goto _jump793;
    _235 = 0;
    _236++;
    if (_236 < _229)
    goto _jump793;
    _236 = 0;
    _237++;
    if (_237 < _233)
    goto _jump793;
    // End body of loop
    _221 += _230;
    _229++;
    if (_229 < _228)
    goto _jump789;
    // End body of loop
    double _240 = 40.0;
    double _241 = 61.0;
    double _242 = -_241;
    double _243 = _240 - _242;
    double _244 = -_243;
    int64_t _245 = 507;
    int64_t _246 = -_245;
    if (_246 >= 0)
    goto _jump794;
    fail_assertion("negative array index");
    _jump794:;
    if (_246 < _219.d0)
    goto _jump795;
    fail_assertion("index too large");
    _jump795:;
    int64_t _247 = 0;
    _247 *= _219.d0;
    _247 += _246;
    double _248 = _219.data[_247];
    double _249 = _244 * _248;
    bool _250 = _221 <= _249;
    bool _220 = _250;
    if (0 != _250)
    goto _jump796;
    double _253 = 54.0;
    double _254 = 80.0;
    bool _255 = _253 <= _254;
    bool _252 = _255;
    if (0 == _255)
    goto _jump797;
    double _256 = 29.0;
    double _257 = 4.0;
    bool _258 = _256 > _257;
    _252 = _258;
    _jump797:;
    bool _259;
    if (!_252)
    goto _jump798;
    bool _260 = false;
    double _261;
    if (!_260)
    goto _jump799;
    double _262 = 41.0;
    _261 = _262;
    goto _jump800;
    _jump799:;
    double _263 = 92.0;
    _261 = _263;
    _jump800:;
    double _264 = 31.0;
    bool _265 = _261 == _264;
    bool _266;
    if (!_265)
    goto _jump801;
    bool _267 = true;
    bool _268 = !_267;
    _266 = _268;
    goto _jump802;
    _jump801:;
    bool _269 = true;
    bool _270 = false;
    bool _271 = _269 == _270;
    _266 = _271;
    _jump802:;
    _259 = _266;
    goto _jump803;
    _jump798:;
    bool _272 = true;
    bool _273 = !_272;
    bool _274 = false;
    bool _275 = _273 != _274;
    _259 = _275;
    _jump803:;
    bool _251 = _259;
    if (0 != _259)
    goto _jump804;
    int64_t _277 = 738;
    int64_t _278 = 593;
    bool _279 = _277 == _278;
    bool _276 = _279;
    if (0 != _279)
    goto _jump805;
    double _280 = 74.0;
    double _281 = -_280;
    double _282 = 28.0;
    bool _283 = _281 >= _282;
    _276 = _283;
    _jump805:;
    _251 = _276;
    _jump804:;
    _220 = _251;
    _jump796:;
    _a1_double _284;
    if (!_220)
    goto _jump806;
    _284 = _219;
    goto _jump807;
    _jump806:;
    bool _285 = false;
    _a1_double _286;
    if (!_285)
    goto _jump808;
    double _287 = 74.0;
    double _288;
    // Computing bound for d
    int64_t _289 = 267;
    int64_t _290 = -_289;
    int64_t _291 = 83;
    int64_t _292 = _290 - _291;
    if (_292 > 0) 
    goto _jump809;
    fail_assertion("non-positive loop bound");
    _jump809:;
    // Computing bound for e
    int64_t _293 = 525;
    if (_293 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    _288 = 0;
    int64_t _294 = 0; // e
    int64_t _295 = 0; // d
    _jump811:; // Begin body of loop
    double _296;
    // Computing bound for f
    int64_t _297 = 893;
    if (_297 > 0) 
    goto _jump812;
    fail_assertion("non-positive loop bound");
    _jump812:;
    // Computing bound for g
    int64_t _298 = 889;
    if (_298 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    _296 = 0;
    int64_t _299 = 0; // g
    int64_t _300 = 0; // f
    _jump814:; // Begin body of loop
    double _301 = 69.0;
    _296 += _301;
    _299++;
    if (_299 < _298)
    goto _jump814;
    _299 = 0;
    _300++;
    if (_300 < _297)
    goto _jump814;
    // End body of loop
    _288 += _296;
    _294++;
    if (_294 < _293)
    goto _jump811;
    _294 = 0;
    _295++;
    if (_295 < _292)
    goto _jump811;
    // End body of loop
    double _302 = _287 - _288;
    _a1_double _303;
    _303.d0 = 1;
    _303.data = jpl_alloc(sizeof(double) * 1);
    _303.data[0] = _302;
    _286 = _303;
    goto _jump815;
    _jump808:;
    _286 = _219;
    _jump815:;
    _284 = _286;
    _jump807:;
    double _306 = 66.0;
    double _307 = -_306;
    bool _308 = true;
    double _309;
    if (!_308)
    goto _jump816;
    double _310 = 60.0;
    double _311 = -_310;
    _309 = _311;
    goto _jump817;
    _jump816:;
    double _312 = 61.0;
    _309 = _312;
    _jump817:;
    bool _313 = _307 != _309;
    bool _314;
    if (!_313)
    goto _jump818;
    bool _315 = true;
    bool _316 = !_315;
    _314 = _316;
    goto _jump819;
    _jump818:;
    bool _317 = true;
    _314 = _317;
    _jump819:;
    bool _305 = _314;
    if (0 == _314)
    goto _jump820;
    bool _318 = false;
    bool _319 = !_318;
    bool _320 = false;
    bool _321 = _319 != _320;
    bool _322;
    if (!_321)
    goto _jump821;
    bool _323 = false;
    _322 = _323;
    goto _jump822;
    _jump821:;
    double _324;
    // Computing bound for e
    int64_t _325 = 533;
    if (_325 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing bound for f
    int64_t _326 = 846;
    if (_326 > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    // Computing bound for g
    int64_t _327 = 764;
    if (_327 > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    _324 = 0;
    int64_t _328 = 0; // g
    int64_t _329 = 0; // f
    int64_t _330 = 0; // e
    _jump826:; // Begin body of loop
    double _331 = 84.0;
    _324 += _331;
    _328++;
    if (_328 < _327)
    goto _jump826;
    _328 = 0;
    _329++;
    if (_329 < _326)
    goto _jump826;
    _329 = 0;
    _330++;
    if (_330 < _325)
    goto _jump826;
    // End body of loop
    double _332 = 8.0;
    double _333 = -_332;
    bool _334 = _324 == _333;
    bool _335 = false;
    bool _336;
    if (!_335)
    goto _jump827;
    int64_t _337 = 119;
    int64_t _338 = 80;
    bool _339 = _337 < _338;
    _336 = _339;
    goto _jump828;
    _jump827:;
    bool _340 = true;
    bool _341 = true;
    bool _342 = _340 == _341;
    _336 = _342;
    _jump828:;
    bool _343 = _334 != _336;
    _322 = _343;
    _jump822:;
    _305 = _322;
    _jump820:;
    bool _304 = _305;
    if (0 == _305)
    goto _jump829;
    bool _344 = false;
    _304 = _344;
    _jump829:;
    _a3_int64_t _345;
    if (!_304)
    goto _jump830;
    _a3_int64_t _346;
    // Computing bound for e
    int64_t _347 = 645;
    _346.d0 = _347;
    if (_347 > 0) 
    goto _jump831;
    fail_assertion("non-positive loop bound");
    _jump831:;
    // Computing bound for f
    bool _348 = true;
    bool _349 = false;
    bool _350 = !_349;
    bool _351;
    if (!_350)
    goto _jump832;
    double _352 = 20.0;
    double _353 = 84.0;
    bool _354 = _352 != _353;
    bool _355 = true;
    bool _356 = !_355;
    bool _357 = _354 != _356;
    _351 = _357;
    goto _jump833;
    _jump832:;
    bool _358 = false;
    bool _359 = !_358;
    _351 = _359;
    _jump833:;
    bool _360 = _348 != _351;
    int64_t _361;
    if (!_360)
    goto _jump834;
    bool _362 = false;
    int64_t _363;
    if (!_362)
    goto _jump835;
    int64_t _364 = 708;
    int64_t _365 = -_364;
    int64_t _366 = -_365;
    _363 = _366;
    goto _jump836;
    _jump835:;
    int64_t _367 = 991;
    int64_t _368 = 292;
    int64_t _369 = _367 + _368;
    _363 = _369;
    _jump836:;
    int64_t _370 = -_363;
    _361 = _370;
    goto _jump837;
    _jump834:;
    bool _371 = false;
    bool _372;
    if (!_371)
    goto _jump838;
    bool _373 = false;
    _372 = _373;
    goto _jump839;
    _jump838:;
    int64_t _374 = 634;
    if (_374 >= 0)
    goto _jump840;
    fail_assertion("negative array index");
    _jump840:;
    if (_374 < _284.d0)
    goto _jump841;
    fail_assertion("index too large");
    _jump841:;
    int64_t _375 = 0;
    _375 *= _284.d0;
    _375 += _374;
    double _376 = _284.data[_375];
    double _377 = 20.0;
    bool _378 = _376 == _377;
    _372 = _378;
    _jump839:;
    int64_t _379;
    if (!_372)
    goto _jump842;
    int64_t _380 = 204;
    _379 = _380;
    goto _jump843;
    _jump842:;
    bool _381 = true;
    _a1_int64_t _382;
    if (!_381)
    goto _jump844;
    _a1_int64_t _383;
    // Computing bound for e
    int64_t _384 = 725;
    _383.d0 = _384;
    if (_384 > 0) 
    goto _jump845;
    fail_assertion("non-positive loop bound");
    _jump845:;
    // Computing total size of heap memory to allocate
    int64_t _385 = 1;
    _385 *= _384;
    _385 *= sizeof(int64_t);
    _383.data = jpl_alloc(_385);
    int64_t _386 = 0; // e
    _jump846:; // Begin body of loop
    int64_t _387 = 0;
    _387 *= _383.d0;
    _387 += _386;
    _383.data[_387] = _386;
    _386++;
    if (_386 < _384)
    goto _jump846;
    // End body of loop
    _382 = _383;
    goto _jump847;
    _jump844:;
    _a1_int64_t _388;
    // Computing bound for e
    int64_t _389 = 732;
    _388.d0 = _389;
    if (_389 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing total size of heap memory to allocate
    int64_t _390 = 1;
    _390 *= _389;
    _390 *= sizeof(int64_t);
    _388.data = jpl_alloc(_390);
    int64_t _391 = 0; // e
    _jump849:; // Begin body of loop
    int64_t _392 = 0;
    _392 *= _388.d0;
    _392 += _391;
    _388.data[_392] = _391;
    _391++;
    if (_391 < _389)
    goto _jump849;
    // End body of loop
    _382 = _388;
    _jump847:;
    int64_t _393 = 829;
    int64_t _394 = -_393;
    int64_t _395 = -_394;
    if (_395 >= 0)
    goto _jump850;
    fail_assertion("negative array index");
    _jump850:;
    if (_395 < _382.d0)
    goto _jump851;
    fail_assertion("index too large");
    _jump851:;
    int64_t _396 = 0;
    _396 *= _382.d0;
    _396 += _395;
    int64_t _397 = _382.data[_396];
    _379 = _397;
    _jump843:;
    _361 = _379;
    _jump837:;
    _346.d1 = _361;
    if (_361 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for g
    int64_t _398;
    // Computing bound for e
    _a3_int64_t _399;
    // Computing bound for e
    int64_t _400 = 457;
    _399.d0 = _400;
    if (_400 > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing bound for f
    int64_t _401 = 205;
    int64_t _402 = -_401;
    _399.d1 = _402;
    if (_402 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing bound for g
    int64_t _403 = 486;
    _399.d2 = _403;
    if (_403 > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    // Computing total size of heap memory to allocate
    int64_t _404 = 1;
    _404 *= _400;
    _404 *= _402;
    _404 *= _403;
    _404 *= sizeof(int64_t);
    _399.data = jpl_alloc(_404);
    int64_t _405 = 0; // g
    int64_t _406 = 0; // f
    int64_t _407 = 0; // e
    _jump856:; // Begin body of loop
    int64_t _408 = 0;
    _408 *= _399.d0;
    _408 += _407;
    _408 *= _399.d1;
    _408 += _406;
    _408 *= _399.d2;
    _408 += _405;
    _399.data[_408] = _405;
    _405++;
    if (_405 < _403)
    goto _jump856;
    _405 = 0;
    _406++;
    if (_406 < _402)
    goto _jump856;
    _406 = 0;
    _407++;
    if (_407 < _400)
    goto _jump856;
    // End body of loop
    int64_t _409;
    // Computing bound for e
    int64_t _410 = 771;
    if (_410 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    _409 = 0;
    int64_t _411 = 0; // e
    _jump858:; // Begin body of loop
    int64_t _412 = 659;
    _409 += _412;
    _411++;
    if (_411 < _410)
    goto _jump858;
    // End body of loop
    int64_t _413 = 838;
    int64_t _414 = -_413;
    int64_t _415 = 464;
    if (_409 >= 0)
    goto _jump859;
    fail_assertion("negative array index");
    _jump859:;
    if (_409 < _399.d0)
    goto _jump860;
    fail_assertion("index too large");
    _jump860:;
    if (_414 >= 0)
    goto _jump861;
    fail_assertion("negative array index");
    _jump861:;
    if (_414 < _399.d1)
    goto _jump862;
    fail_assertion("index too large");
    _jump862:;
    if (_415 >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (_415 < _399.d2)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    int64_t _416 = 0;
    _416 *= _399.d0;
    _416 += _409;
    _416 *= _399.d1;
    _416 += _414;
    _416 *= _399.d2;
    _416 += _415;
    int64_t _417 = _399.data[_416];
    if (_417 > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    _398 = 0;
    int64_t _418 = 0; // e
    _jump866:; // Begin body of loop
    int64_t _419 = 352;
    int64_t _420 = _418 + _419;
    int64_t _421 = -_420;
    _398 += _421;
    _418++;
    if (_418 < _417)
    goto _jump866;
    // End body of loop
    _346.d2 = _398;
    if (_398 > 0) 
    goto _jump867;
    fail_assertion("non-positive loop bound");
    _jump867:;
    // Computing total size of heap memory to allocate
    int64_t _422 = 1;
    _422 *= _347;
    _422 *= _361;
    _422 *= _398;
    _422 *= sizeof(int64_t);
    _346.data = jpl_alloc(_422);
    int64_t _423 = 0; // g
    int64_t _424 = 0; // f
    int64_t _425 = 0; // e
    _jump868:; // Begin body of loop
    int64_t _426 = 0;
    _426 *= _346.d0;
    _426 += _425;
    _426 *= _346.d1;
    _426 += _424;
    _426 *= _346.d2;
    _426 += _423;
    _346.data[_426] = _423;
    _423++;
    if (_423 < _398)
    goto _jump868;
    _423 = 0;
    _424++;
    if (_424 < _361)
    goto _jump868;
    _424 = 0;
    _425++;
    if (_425 < _347)
    goto _jump868;
    // End body of loop
    _345 = _346;
    goto _jump869;
    _jump830:;
    int64_t _427;
    // Computing bound for e
    int64_t _428 = 323;
    if (_428 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    // Computing bound for f
    int64_t _429 = 223;
    int64_t _430 = 274;
    int64_t _431 = _429 - _430;
    if (_431 > 0) 
    goto _jump871;
    fail_assertion("non-positive loop bound");
    _jump871:;
    _427 = 0;
    int64_t _432 = 0; // f
    int64_t _433 = 0; // e
    _jump872:; // Begin body of loop
    int64_t _434 = 622;
    _427 += _434;
    _432++;
    if (_432 < _431)
    goto _jump872;
    _432 = 0;
    _433++;
    if (_433 < _428)
    goto _jump872;
    // End body of loop
    if (_427 >= 0)
    goto _jump873;
    fail_assertion("negative array index");
    _jump873:;
    if (_427 < _284.d0)
    goto _jump874;
    fail_assertion("index too large");
    _jump874:;
    int64_t _435 = 0;
    _435 *= _284.d0;
    _435 += _427;
    double _436 = _284.data[_435];
    bool _439 = true;
    bool _438 = _439;
    if (0 != _439)
    goto _jump875;
    bool _440 = false;
    _438 = _440;
    _jump875:;
    bool _437 = _438;
    if (0 != _438)
    goto _jump876;
    double _441 = 34.0;
    double _442 = 31.0;
    bool _443 = _441 <= _442;
    _437 = _443;
    _jump876:;
    double _444;
    if (!_437)
    goto _jump877;
    double _445 = 25.0;
    _444 = _445;
    goto _jump878;
    _jump877:;
    double _446 = 57.0;
    _444 = _446;
    _jump878:;
    bool _447 = _436 != _444;
    _a2__a3_int64_t _448;
    if (!_447)
    goto _jump879;
    _a2__a3_int64_t _449;
    // Computing bound for e
    int64_t _450;
    // Computing bound for e
    int64_t _451 = 326;
    if (_451 > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    _450 = 0;
    int64_t _452 = 0; // e
    _jump881:; // Begin body of loop
    _450 += _452;
    _452++;
    if (_452 < _451)
    goto _jump881;
    // End body of loop
    int64_t _453 = -_450;
    int64_t _454 = -_453;
    _449.d0 = _454;
    if (_454 > 0) 
    goto _jump882;
    fail_assertion("non-positive loop bound");
    _jump882:;
    // Computing bound for f
    bool _456 = true;
    bool _457 = !_456;
    bool _455 = _457;
    if (0 == _457)
    goto _jump883;
    bool _458 = false;
    bool _459;
    if (!_458)
    goto _jump884;
    bool _460 = true;
    _459 = _460;
    goto _jump885;
    _jump884:;
    bool _461 = false;
    _459 = _461;
    _jump885:;
    _455 = _459;
    _jump883:;
    int64_t _462;
    if (!_455)
    goto _jump886;
    int64_t _463 = 741;
    _462 = _463;
    goto _jump887;
    _jump886:;
    int64_t _464 = 39;
    int64_t _465 = -_464;
    int64_t _466 = -_465;
    _462 = _466;
    _jump887:;
    _449.d1 = _462;
    if (_462 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    // Computing total size of heap memory to allocate
    int64_t _467 = 1;
    _467 *= _454;
    _467 *= _462;
    _467 *= sizeof(_a3_int64_t);
    _449.data = jpl_alloc(_467);
    int64_t _468 = 0; // f
    int64_t _469 = 0; // e
    _jump889:; // Begin body of loop
    _a3_int64_t _470;
    // Computing bound for g
    _a2_int64_t _471;
    // Computing bound for g
    _471.d0 = _468;
    if (_468 > 0) 
    goto _jump890;
    fail_assertion("non-positive loop bound");
    _jump890:;
    // Computing bound for h
    _471.d1 = _468;
    if (_468 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _468;
    _472 *= _468;
    _472 *= sizeof(int64_t);
    _471.data = jpl_alloc(_472);
    int64_t _473 = 0; // h
    int64_t _474 = 0; // g
    _jump892:; // Begin body of loop
    int64_t _475 = 0;
    _475 *= _471.d0;
    _475 += _474;
    _475 *= _471.d1;
    _475 += _473;
    _471.data[_475] = _474;
    _473++;
    if (_473 < _468)
    goto _jump892;
    _473 = 0;
    _474++;
    if (_474 < _468)
    goto _jump892;
    // End body of loop
    int64_t _476 = _469 * _469;
    int64_t _477 = -_469;
    if (_476 >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (_476 < _471.d0)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    if (_477 >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (_477 < _471.d1)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    int64_t _478 = 0;
    _478 *= _471.d0;
    _478 += _476;
    _478 *= _471.d1;
    _478 += _477;
    int64_t _479 = _471.data[_478];
    _470.d0 = _479;
    if (_479 > 0) 
    goto _jump897;
    fail_assertion("non-positive loop bound");
    _jump897:;
    // Computing bound for h
    bool _480 = false;
    int64_t _481;
    if (!_480)
    goto _jump898;
    int64_t _482 = 358;
    _481 = _482;
    goto _jump899;
    _jump898:;
    int64_t _483 = 877;
    _481 = _483;
    _jump899:;
    _470.d1 = _481;
    if (_481 > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for i
    int64_t _484;
    // Computing bound for g
    int64_t _485 = 477;
    int64_t _486 = -_485;
    if (_486 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    _484 = 0;
    int64_t _487 = 0; // g
    _jump902:; // Begin body of loop
    bool _488 = false;
    int64_t _489;
    if (!_488)
    goto _jump903;
    _489 = _469;
    goto _jump904;
    _jump903:;
    _489 = _487;
    _jump904:;
    _484 += _489;
    _487++;
    if (_487 < _486)
    goto _jump902;
    // End body of loop
    _470.d2 = _484;
    if (_484 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing total size of heap memory to allocate
    int64_t _490 = 1;
    _490 *= _479;
    _490 *= _481;
    _490 *= _484;
    _490 *= sizeof(int64_t);
    _470.data = jpl_alloc(_490);
    int64_t _491 = 0; // i
    int64_t _492 = 0; // h
    int64_t _493 = 0; // g
    _jump906:; // Begin body of loop
    int64_t _494 = 0;
    _494 *= _470.d0;
    _494 += _493;
    _494 *= _470.d1;
    _494 += _492;
    _494 *= _470.d2;
    _494 += _491;
    _470.data[_494] = _469;
    _491++;
    if (_491 < _484)
    goto _jump906;
    _491 = 0;
    _492++;
    if (_492 < _481)
    goto _jump906;
    _492 = 0;
    _493++;
    if (_493 < _479)
    goto _jump906;
    // End body of loop
    int64_t _495 = 0;
    _495 *= _449.d0;
    _495 += _469;
    _495 *= _449.d1;
    _495 += _468;
    _449.data[_495] = _470;
    _468++;
    if (_468 < _462)
    goto _jump889;
    _468 = 0;
    _469++;
    if (_469 < _454)
    goto _jump889;
    // End body of loop
    _448 = _449;
    goto _jump907;
    _jump879:;
    _a2__a3_int64_t _496;
    // Computing bound for e
    bool _497 = true;
    bool _498 = !_497;
    int64_t _499;
    if (!_498)
    goto _jump908;
    int64_t _500 = 51;
    int64_t _501 = -_500;
    _499 = _501;
    goto _jump909;
    _jump908:;
    int64_t _502 = 750;
    int64_t _503 = 386;
    int64_t _504 = _502 / _503;
    _499 = _504;
    _jump909:;
    _496.d0 = _499;
    if (_499 > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for f
    int64_t _505 = 185;
    int64_t _506 = -_505;
    _496.d1 = _506;
    if (_506 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing total size of heap memory to allocate
    int64_t _507 = 1;
    _507 *= _499;
    _507 *= _506;
    _507 *= sizeof(_a3_int64_t);
    _496.data = jpl_alloc(_507);
    int64_t _508 = 0; // f
    int64_t _509 = 0; // e
    _jump912:; // Begin body of loop
    _a3_int64_t _510;
    // Computing bound for g
    int64_t _511 = 522;
    _510.d0 = _511;
    if (_511 > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    // Computing bound for h
    int64_t _512 = -_508;
    int64_t _513 = -_512;
    _510.d1 = _513;
    if (_513 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing bound for i
    int64_t _514 = -_509;
    int64_t _515 = 483;
    int64_t _516 = _514 + _515;
    _510.d2 = _516;
    if (_516 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing total size of heap memory to allocate
    int64_t _517 = 1;
    _517 *= _511;
    _517 *= _513;
    _517 *= _516;
    _517 *= sizeof(int64_t);
    _510.data = jpl_alloc(_517);
    int64_t _518 = 0; // i
    int64_t _519 = 0; // h
    int64_t _520 = 0; // g
    _jump916:; // Begin body of loop
    int64_t _521 = 516;
    int64_t _522 = -_521;
    int64_t _523 = 0;
    _523 *= _510.d0;
    _523 += _520;
    _523 *= _510.d1;
    _523 += _519;
    _523 *= _510.d2;
    _523 += _518;
    _510.data[_523] = _522;
    _518++;
    if (_518 < _516)
    goto _jump916;
    _518 = 0;
    _519++;
    if (_519 < _513)
    goto _jump916;
    _519 = 0;
    _520++;
    if (_520 < _511)
    goto _jump916;
    // End body of loop
    int64_t _524 = 0;
    _524 *= _496.d0;
    _524 += _509;
    _524 *= _496.d1;
    _524 += _508;
    _496.data[_524] = _510;
    _508++;
    if (_508 < _506)
    goto _jump912;
    _508 = 0;
    _509++;
    if (_509 < _499)
    goto _jump912;
    // End body of loop
    _448 = _496;
    _jump907:;
    int64_t _525;
    // Computing bound for e
    int64_t _526;
    // Computing bound for e
    int64_t _527 = 865;
    int64_t _528 = -_527;
    if (_528 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    _526 = 0;
    int64_t _529 = 0; // e
    _jump918:; // Begin body of loop
    int64_t _530 = 267;
    int64_t _531 = -_530;
    _526 += _531;
    _529++;
    if (_529 < _528)
    goto _jump918;
    // End body of loop
    _a1_int64_t _532;
    _532.d0 = 1;
    _532.data = jpl_alloc(sizeof(int64_t) * 1);
    _532.data[0] = _526;
    _a1_int64_t _533;
    // Computing bound for e
    int64_t _534 = 523;
    _533.d0 = _534;
    if (_534 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    // Computing total size of heap memory to allocate
    int64_t _535 = 1;
    _535 *= _534;
    _535 *= sizeof(int64_t);
    _533.data = jpl_alloc(_535);
    int64_t _536 = 0; // e
    _jump920:; // Begin body of loop
    int64_t _537 = 0;
    _537 *= _533.d0;
    _537 += _536;
    _533.data[_537] = _536;
    _536++;
    if (_536 < _534)
    goto _jump920;
    // End body of loop
    int64_t _538;
    // Computing bound for e
    int64_t _539 = 161;
    if (_539 > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    _538 = 0;
    int64_t _540 = 0; // e
    _jump922:; // Begin body of loop
    _538 += _540;
    _540++;
    if (_540 < _539)
    goto _jump922;
    // End body of loop
    if (_538 >= 0)
    goto _jump923;
    fail_assertion("negative array index");
    _jump923:;
    if (_538 < _533.d0)
    goto _jump924;
    fail_assertion("index too large");
    _jump924:;
    int64_t _541 = 0;
    _541 *= _533.d0;
    _541 += _538;
    int64_t _542 = _533.data[_541];
    if (_542 >= 0)
    goto _jump925;
    fail_assertion("negative array index");
    _jump925:;
    if (_542 < _532.d0)
    goto _jump926;
    fail_assertion("index too large");
    _jump926:;
    int64_t _543 = 0;
    _543 *= _532.d0;
    _543 += _542;
    int64_t _544 = _532.data[_543];
    if (_544 > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    _525 = 0;
    int64_t _545 = 0; // e
    _jump928:; // Begin body of loop
    bool _546 = false;
    int64_t _547;
    if (!_546)
    goto _jump929;
    int64_t _548 = -_545;
    _547 = _548;
    goto _jump930;
    _jump929:;
    int64_t _549;
    // Computing bound for f
    int64_t _550 = 996;
    if (_550 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for g
    if (_545 > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    _549 = 0;
    int64_t _551 = 0; // g
    int64_t _552 = 0; // f
    _jump933:; // Begin body of loop
    _549 += _551;
    _551++;
    if (_551 < _545)
    goto _jump933;
    _551 = 0;
    _552++;
    if (_552 < _550)
    goto _jump933;
    // End body of loop
    int64_t _553 = -_549;
    _547 = _553;
    _jump930:;
    _525 += _547;
    _545++;
    if (_545 < _544)
    goto _jump928;
    // End body of loop
    _a2_bool _554;
    // Computing bound for e
    int64_t _555 = 31;
    int64_t _556 = -_555;
    _554.d0 = _556;
    if (_556 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for f
    bool _557 = true;
    bool _558 = !_557;
    int64_t _559;
    if (!_558)
    goto _jump935;
    int64_t _560 = 935;
    _559 = _560;
    goto _jump936;
    _jump935:;
    bool _562 = false;
    bool _561 = _562;
    if (0 != _562)
    goto _jump937;
    bool _563 = true;
    _561 = _563;
    _jump937:;
    int64_t _564;
    if (!_561)
    goto _jump938;
    int64_t _565 = 615;
    _564 = _565;
    goto _jump939;
    _jump938:;
    int64_t _566 = 736;
    int64_t _567 = -_566;
    _564 = _567;
    _jump939:;
    _559 = _564;
    _jump936:;
    _554.d1 = _559;
    if (_559 > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    // Computing total size of heap memory to allocate
    int64_t _568 = 1;
    _568 *= _556;
    _568 *= _559;
    _568 *= sizeof(bool);
    _554.data = jpl_alloc(_568);
    int64_t _569 = 0; // f
    int64_t _570 = 0; // e
    _jump941:; // Begin body of loop
    _a2_bool _571;
    // Computing bound for g
    int64_t _572 = -_569;
    _571.d0 = _572;
    if (_572 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing bound for h
    int64_t _573 = 452;
    _571.d1 = _573;
    if (_573 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    // Computing total size of heap memory to allocate
    int64_t _574 = 1;
    _574 *= _572;
    _574 *= _573;
    _574 *= sizeof(bool);
    _571.data = jpl_alloc(_574);
    int64_t _575 = 0; // h
    int64_t _576 = 0; // g
    _jump944:; // Begin body of loop
    bool _577 = true;
    int64_t _578 = 0;
    _578 *= _571.d0;
    _578 += _576;
    _578 *= _571.d1;
    _578 += _575;
    _571.data[_578] = _577;
    _575++;
    if (_575 < _573)
    goto _jump944;
    _575 = 0;
    _576++;
    if (_576 < _572)
    goto _jump944;
    // End body of loop
    bool _579 = false;
    int64_t _580;
    if (!_579)
    goto _jump945;
    _580 = _569;
    goto _jump946;
    _jump945:;
    int64_t _581;
    // Computing bound for g
    if (_569 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    _581 = 0;
    int64_t _582 = 0; // g
    _jump948:; // Begin body of loop
    _581 += _582;
    _582++;
    if (_582 < _569)
    goto _jump948;
    // End body of loop
    _580 = _581;
    _jump946:;
    int64_t _583 = -_570;
    int64_t _584;
    // Computing bound for g
    if (_570 > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    // Computing bound for h
    if (_569 > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing bound for i
    if (_570 > 0) 
    goto _jump951;
    fail_assertion("non-positive loop bound");
    _jump951:;
    _584 = 0;
    int64_t _585 = 0; // i
    int64_t _586 = 0; // h
    int64_t _587 = 0; // g
    _jump952:; // Begin body of loop
    _584 += _586;
    _585++;
    if (_585 < _570)
    goto _jump952;
    _585 = 0;
    _586++;
    if (_586 < _569)
    goto _jump952;
    _586 = 0;
    _587++;
    if (_587 < _570)
    goto _jump952;
    // End body of loop
    int64_t _588 = _583 * _584;
    if (_580 >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (_580 < _571.d0)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    if (_588 >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (_588 < _571.d1)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    int64_t _589 = 0;
    _589 *= _571.d0;
    _589 += _580;
    _589 *= _571.d1;
    _589 += _588;
    bool _590 = _571.data[_589];
    int64_t _591 = 0;
    _591 *= _554.d0;
    _591 += _570;
    _591 *= _554.d1;
    _591 += _569;
    _554.data[_591] = _590;
    _569++;
    if (_569 < _559)
    goto _jump941;
    _569 = 0;
    _570++;
    if (_570 < _556)
    goto _jump941;
    // End body of loop
    bool _592 = true;
    int64_t _593 = 805;
    int64_t _594 = 346;
    bool _595 = _593 < _594;
    bool _596 = false;
    _a1_bool _597;
    _597.d0 = 3;
    _597.data = jpl_alloc(sizeof(bool) * 3);
    _597.data[0] = _592;
    _597.data[1] = _595;
    _597.data[2] = _596;
    bool _598 = true;
    bool _599 = !_598;
    _a1_bool _600;
    if (!_599)
    goto _jump957;
    bool _601 = true;
    bool _602 = !_601;
    _a1_bool _603;
    _603.d0 = 1;
    _603.data = jpl_alloc(sizeof(bool) * 1);
    _603.data[0] = _602;
    _600 = _603;
    goto _jump958;
    _jump957:;
    bool _604 = false;
    _a1_bool _605;
    _605.d0 = 1;
    _605.data = jpl_alloc(sizeof(bool) * 1);
    _605.data[0] = _604;
    _600 = _605;
    _jump958:;
    void_t _606 = b(_597, _600);
    int64_t _607 = a(_554, _606);
    if (_525 >= 0)
    goto _jump959;
    fail_assertion("negative array index");
    _jump959:;
    if (_525 < _448.d0)
    goto _jump960;
    fail_assertion("index too large");
    _jump960:;
    if (_607 >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (_607 < _448.d1)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    int64_t _608 = 0;
    _608 *= _448.d0;
    _608 += _525;
    _608 *= _448.d1;
    _608 += _607;
    _a3_int64_t _609 = _448.data[_608];
    _345 = _609;
    _jump869:;
    _a2__a1__a1__a2_int64_t _610;
    // Computing bound for i
    _610.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    // Computing bound for j
    bool _611 = _345.d0 > _345.d0;
    bool _612 = !_611;
    int64_t _613;
    if (!_612)
    goto _jump964;
    _a3_int64_t _614;
    // Computing bound for i
    _614.d0 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing bound for j
    int64_t _615 = 729;
    _614.d1 = _615;
    if (_615 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing bound for k
    _614.d2 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump967;
    fail_assertion("non-positive loop bound");
    _jump967:;
    // Computing total size of heap memory to allocate
    int64_t _616 = 1;
    _616 *= _345.d0;
    _616 *= _615;
    _616 *= _345.d0;
    _616 *= sizeof(int64_t);
    _614.data = jpl_alloc(_616);
    int64_t _617 = 0; // k
    int64_t _618 = 0; // j
    int64_t _619 = 0; // i
    _jump968:; // Begin body of loop
    int64_t _620 = 0;
    _620 *= _614.d0;
    _620 += _619;
    _620 *= _614.d1;
    _620 += _618;
    _620 *= _614.d2;
    _620 += _617;
    _614.data[_620] = _345.d2;
    _617++;
    if (_617 < _345.d0)
    goto _jump968;
    _617 = 0;
    _618++;
    if (_618 < _615)
    goto _jump968;
    _618 = 0;
    _619++;
    if (_619 < _345.d0)
    goto _jump968;
    // End body of loop
    int64_t _621 = 192;
    if (_345.d2 >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (_345.d2 < _614.d0)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    if (_621 >= 0)
    goto _jump971;
    fail_assertion("negative array index");
    _jump971:;
    if (_621 < _614.d1)
    goto _jump972;
    fail_assertion("index too large");
    _jump972:;
    if (_345.d2 >= 0)
    goto _jump973;
    fail_assertion("negative array index");
    _jump973:;
    if (_345.d2 < _614.d2)
    goto _jump974;
    fail_assertion("index too large");
    _jump974:;
    int64_t _622 = 0;
    _622 *= _614.d0;
    _622 += _345.d2;
    _622 *= _614.d1;
    _622 += _621;
    _622 *= _614.d2;
    _622 += _345.d2;
    int64_t _623 = _614.data[_622];
    _613 = _623;
    goto _jump975;
    _jump964:;
    _613 = _345.d0;
    _jump975:;
    _610.d1 = _613;
    if (_613 > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    // Computing total size of heap memory to allocate
    int64_t _624 = 1;
    _624 *= _345.d2;
    _624 *= _613;
    _624 *= sizeof(_a1__a1__a2_int64_t);
    _610.data = jpl_alloc(_624);
    int64_t _625 = 0; // j
    int64_t _626 = 0; // i
    _jump977:; // Begin body of loop
    _a1__a2_int64_t _627;
    // Computing bound for k
    int64_t _628 = 299;
    _627.d0 = _628;
    if (_628 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing total size of heap memory to allocate
    int64_t _629 = 1;
    _629 *= _628;
    _629 *= sizeof(_a2_int64_t);
    _627.data = jpl_alloc(_629);
    int64_t _630 = 0; // k
    _jump979:; // Begin body of loop
    _a2_int64_t _631;
    // Computing bound for l
    _631.d0 = _626;
    if (_626 > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing bound for m
    _631.d1 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    // Computing total size of heap memory to allocate
    int64_t _632 = 1;
    _632 *= _626;
    _632 *= _345.d1;
    _632 *= sizeof(int64_t);
    _631.data = jpl_alloc(_632);
    int64_t _633 = 0; // m
    int64_t _634 = 0; // l
    _jump982:; // Begin body of loop
    int64_t _635 = 0;
    _635 *= _631.d0;
    _635 += _634;
    _635 *= _631.d1;
    _635 += _633;
    _631.data[_635] = _630;
    _633++;
    if (_633 < _345.d1)
    goto _jump982;
    _633 = 0;
    _634++;
    if (_634 < _626)
    goto _jump982;
    // End body of loop
    int64_t _636 = 0;
    _636 *= _627.d0;
    _636 += _630;
    _627.data[_636] = _631;
    _630++;
    if (_630 < _628)
    goto _jump979;
    // End body of loop
    _a1__a2_int64_t _637;
    // Computing bound for k
    _637.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing total size of heap memory to allocate
    int64_t _638 = 1;
    _638 *= _345.d2;
    _638 *= sizeof(_a2_int64_t);
    _637.data = jpl_alloc(_638);
    int64_t _639 = 0; // k
    _jump984:; // Begin body of loop
    _a2_int64_t _640;
    // Computing bound for l
    _640.d0 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    // Computing bound for m
    _640.d1 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump986;
    fail_assertion("non-positive loop bound");
    _jump986:;
    // Computing total size of heap memory to allocate
    int64_t _641 = 1;
    _641 *= _345.d0;
    _641 *= _345.d1;
    _641 *= sizeof(int64_t);
    _640.data = jpl_alloc(_641);
    int64_t _642 = 0; // m
    int64_t _643 = 0; // l
    _jump987:; // Begin body of loop
    int64_t _644 = 0;
    _644 *= _640.d0;
    _644 += _643;
    _644 *= _640.d1;
    _644 += _642;
    _640.data[_644] = _643;
    _642++;
    if (_642 < _345.d1)
    goto _jump987;
    _642 = 0;
    _643++;
    if (_643 < _345.d0)
    goto _jump987;
    // End body of loop
    int64_t _645 = 0;
    _645 *= _637.d0;
    _645 += _639;
    _637.data[_645] = _640;
    _639++;
    if (_639 < _345.d2)
    goto _jump984;
    // End body of loop
    _a1__a2_int64_t _646;
    // Computing bound for k
    int64_t _647 = _345.d2 % _345.d2;
    _646.d0 = _647;
    if (_647 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing total size of heap memory to allocate
    int64_t _648 = 1;
    _648 *= _647;
    _648 *= sizeof(_a2_int64_t);
    _646.data = jpl_alloc(_648);
    int64_t _649 = 0; // k
    _jump989:; // Begin body of loop
    _a2_int64_t _650;
    // Computing bound for l
    _650.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump990;
    fail_assertion("non-positive loop bound");
    _jump990:;
    // Computing bound for m
    _650.d1 = _625;
    if (_625 > 0) 
    goto _jump991;
    fail_assertion("non-positive loop bound");
    _jump991:;
    // Computing total size of heap memory to allocate
    int64_t _651 = 1;
    _651 *= _345.d1;
    _651 *= _625;
    _651 *= sizeof(int64_t);
    _650.data = jpl_alloc(_651);
    int64_t _652 = 0; // m
    int64_t _653 = 0; // l
    _jump992:; // Begin body of loop
    int64_t _654 = 0;
    _654 *= _650.d0;
    _654 += _653;
    _654 *= _650.d1;
    _654 += _652;
    _650.data[_654] = _625;
    _652++;
    if (_652 < _625)
    goto _jump992;
    _652 = 0;
    _653++;
    if (_653 < _345.d1)
    goto _jump992;
    // End body of loop
    int64_t _655 = 0;
    _655 *= _646.d0;
    _655 += _649;
    _646.data[_655] = _650;
    _649++;
    if (_649 < _647)
    goto _jump989;
    // End body of loop
    _a1__a1__a2_int64_t _656;
    _656.d0 = 3;
    _656.data = jpl_alloc(sizeof(_a1__a2_int64_t) * 3);
    _656.data[0] = _627;
    _656.data[1] = _637;
    _656.data[2] = _646;
    int64_t _657 = 0;
    _657 *= _610.d0;
    _657 += _626;
    _657 *= _610.d1;
    _657 += _625;
    _610.data[_657] = _656;
    _625++;
    if (_625 < _613)
    goto _jump977;
    _625 = 0;
    _626++;
    if (_626 < _345.d2)
    goto _jump977;
    // End body of loop
    bool _659 = true;
    bool _660 = false;
    bool _661 = _659 == _660;
    bool _658 = _661;
    if (0 != _661)
    goto _jump993;
    bool _662 = false;
    _658 = _662;
    _jump993:;
    bool _663;
    if (!_658)
    goto _jump994;
    bool _664 = _345.d1 >= _345.d1;
    bool _665 = !_664;
    _663 = _665;
    goto _jump995;
    _jump994:;
    bool _666 = true;
    bool _667;
    if (!_666)
    goto _jump996;
    bool _668 = true;
    _667 = _668;
    goto _jump997;
    _jump996:;
    bool _669 = true;
    _667 = _669;
    _jump997:;
    bool _670 = true;
    bool _671 = _667 == _670;
    _663 = _671;
    _jump995:;
    int64_t _672;
    if (!_663)
    goto _jump998;
    _672 = _345.d1;
    goto _jump999;
    _jump998:;
    int64_t _673;
    // Computing bound for i
    int64_t _674 = -_345.d1;
    int64_t _675 = -_674;
    if (_675 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for j
    if (_345.d2 > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    _673 = 0;
    int64_t _676 = 0; // j
    int64_t _677 = 0; // i
    _jump1002:; // Begin body of loop
    int64_t _678 = _676 / _345.d1;
    _673 += _678;
    _676++;
    if (_676 < _345.d2)
    goto _jump1002;
    _676 = 0;
    _677++;
    if (_677 < _675)
    goto _jump1002;
    // End body of loop
    _672 = _673;
    _jump999:;
    int64_t _679 = 442;
    if (_672 >= 0)
    goto _jump1003;
    fail_assertion("negative array index");
    _jump1003:;
    if (_672 < _610.d0)
    goto _jump1004;
    fail_assertion("index too large");
    _jump1004:;
    if (_679 >= 0)
    goto _jump1005;
    fail_assertion("negative array index");
    _jump1005:;
    if (_679 < _610.d1)
    goto _jump1006;
    fail_assertion("index too large");
    _jump1006:;
    int64_t _680 = 0;
    _680 *= _610.d0;
    _680 += _672;
    _680 *= _610.d1;
    _680 += _679;
    _a1__a1__a2_int64_t _681 = _610.data[_680];
    int64_t _682 = 44;
    if (_682 >= 0)
    goto _jump1007;
    fail_assertion("negative array index");
    _jump1007:;
    if (_682 < _681.d0)
    goto _jump1008;
    fail_assertion("index too large");
    _jump1008:;
    int64_t _683 = 0;
    _683 *= _681.d0;
    _683 += _682;
    _a1__a2_int64_t _684 = _681.data[_683];
    _a2_int64_t _685;
    // Computing bound for i
    _685.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing bound for j
    _a3_int64_t _686;
    // Computing bound for i
    _686.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for j
    _686.d1 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    // Computing bound for k
    int64_t _687 = 297;
    _686.d2 = _687;
    if (_687 > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    // Computing total size of heap memory to allocate
    int64_t _688 = 1;
    _688 *= _345.d1;
    _688 *= _345.d2;
    _688 *= _687;
    _688 *= sizeof(int64_t);
    _686.data = jpl_alloc(_688);
    int64_t _689 = 0; // k
    int64_t _690 = 0; // j
    int64_t _691 = 0; // i
    _jump1013:; // Begin body of loop
    int64_t _692 = 0;
    _692 *= _686.d0;
    _692 += _691;
    _692 *= _686.d1;
    _692 += _690;
    _692 *= _686.d2;
    _692 += _689;
    _686.data[_692] = _345.d2;
    _689++;
    if (_689 < _687)
    goto _jump1013;
    _689 = 0;
    _690++;
    if (_690 < _345.d2)
    goto _jump1013;
    _690 = 0;
    _691++;
    if (_691 < _345.d1)
    goto _jump1013;
    // End body of loop
    if (_345.d0 >= 0)
    goto _jump1014;
    fail_assertion("negative array index");
    _jump1014:;
    if (_345.d0 < _686.d0)
    goto _jump1015;
    fail_assertion("index too large");
    _jump1015:;
    if (_345.d2 >= 0)
    goto _jump1016;
    fail_assertion("negative array index");
    _jump1016:;
    if (_345.d2 < _686.d1)
    goto _jump1017;
    fail_assertion("index too large");
    _jump1017:;
    if (_345.d1 >= 0)
    goto _jump1018;
    fail_assertion("negative array index");
    _jump1018:;
    if (_345.d1 < _686.d2)
    goto _jump1019;
    fail_assertion("index too large");
    _jump1019:;
    int64_t _693 = 0;
    _693 *= _686.d0;
    _693 += _345.d0;
    _693 *= _686.d1;
    _693 += _345.d2;
    _693 *= _686.d2;
    _693 += _345.d1;
    int64_t _694 = _686.data[_693];
    _685.d1 = _694;
    if (_694 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing total size of heap memory to allocate
    int64_t _695 = 1;
    _695 *= _345.d2;
    _695 *= _694;
    _695 *= sizeof(int64_t);
    _685.data = jpl_alloc(_695);
    int64_t _696 = 0; // j
    int64_t _697 = 0; // i
    _jump1021:; // Begin body of loop
    int64_t _698 = 0;
    _698 *= _685.d0;
    _698 += _697;
    _698 *= _685.d1;
    _698 += _696;
    _685.data[_698] = _696;
    _696++;
    if (_696 < _694)
    goto _jump1021;
    _696 = 0;
    _697++;
    if (_697 < _345.d2)
    goto _jump1021;
    // End body of loop
    int64_t _699 = -_345.d1;
    int64_t _700 = 814;
    if (_699 >= 0)
    goto _jump1022;
    fail_assertion("negative array index");
    _jump1022:;
    if (_699 < _685.d0)
    goto _jump1023;
    fail_assertion("index too large");
    _jump1023:;
    if (_700 >= 0)
    goto _jump1024;
    fail_assertion("negative array index");
    _jump1024:;
    if (_700 < _685.d1)
    goto _jump1025;
    fail_assertion("index too large");
    _jump1025:;
    int64_t _701 = 0;
    _701 *= _685.d0;
    _701 += _699;
    _701 *= _685.d1;
    _701 += _700;
    int64_t _702 = _685.data[_701];
    bool _703 = false;
    int64_t _704;
    if (!_703)
    goto _jump1026;
    int64_t _705 = -_345.d0;
    _704 = _705;
    goto _jump1027;
    _jump1026:;
    int64_t _706 = -_345.d2;
    int64_t _707 = _345.d1 / _345.d1;
    int64_t _708 = 475;
    if (_706 >= 0)
    goto _jump1028;
    fail_assertion("negative array index");
    _jump1028:;
    if (_706 < _345.d0)
    goto _jump1029;
    fail_assertion("index too large");
    _jump1029:;
    if (_707 >= 0)
    goto _jump1030;
    fail_assertion("negative array index");
    _jump1030:;
    if (_707 < _345.d1)
    goto _jump1031;
    fail_assertion("index too large");
    _jump1031:;
    if (_708 >= 0)
    goto _jump1032;
    fail_assertion("negative array index");
    _jump1032:;
    if (_708 < _345.d2)
    goto _jump1033;
    fail_assertion("index too large");
    _jump1033:;
    int64_t _709 = 0;
    _709 *= _345.d0;
    _709 += _706;
    _709 *= _345.d1;
    _709 += _707;
    _709 *= _345.d2;
    _709 += _708;
    int64_t _710 = _345.data[_709];
    _704 = _710;
    _jump1027:;
    int64_t _711;
    // Computing bound for i
    _a1_int64_t _712;
    _712.d0 = 2;
    _712.data = jpl_alloc(sizeof(int64_t) * 2);
    _712.data[0] = _345.d2;
    _712.data[1] = _345.d2;
    int64_t _713 = 962;
    int64_t _714 = _713 / _345.d1;
    if (_714 >= 0)
    goto _jump1034;
    fail_assertion("negative array index");
    _jump1034:;
    if (_714 < _712.d0)
    goto _jump1035;
    fail_assertion("index too large");
    _jump1035:;
    int64_t _715 = 0;
    _715 *= _712.d0;
    _715 += _714;
    int64_t _716 = _712.data[_715];
    if (_716 > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    // Computing bound for j
    int64_t _717 = -_345.d1;
    if (_717 > 0) 
    goto _jump1037;
    fail_assertion("non-positive loop bound");
    _jump1037:;
    // Computing bound for k
    int64_t _718 = 585;
    if (_718 > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    _711 = 0;
    int64_t _719 = 0; // k
    int64_t _720 = 0; // j
    int64_t _721 = 0; // i
    _jump1039:; // Begin body of loop
    _711 += _345.d1;
    _719++;
    if (_719 < _718)
    goto _jump1039;
    _719 = 0;
    _720++;
    if (_720 < _717)
    goto _jump1039;
    _720 = 0;
    _721++;
    if (_721 < _716)
    goto _jump1039;
    // End body of loop
    int64_t _722 = _704 % _711;
    int64_t _723 = _702 * _722;
    int64_t _724 = -_723;
    if (_724 >= 0)
    goto _jump1040;
    fail_assertion("negative array index");
    _jump1040:;
    if (_724 < _684.d0)
    goto _jump1041;
    fail_assertion("index too large");
    _jump1041:;
    int64_t _725 = 0;
    _725 *= _684.d0;
    _725 += _724;
    _a2_int64_t _726 = _684.data[_725];
    double _727 = get_time();
    int64_t _728 = 994;
    int64_t _729 = _345.d2 + _728;
    int64_t _730 = -_729;
    show("(IntType)", &_730);
    double _731 = get_time();
    print_time(_731 - _727);
    bool _732 = false;
    bool _733 = !_732;
    bool _734 = !_733;
    bool _735 = !_734;
    _a2_bool _736;
    if (!_735)
    goto _jump1042;
    _a2_bool _737;
    // Computing bound for l
    _737.d0 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing bound for m
    _737.d1 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1044;
    fail_assertion("non-positive loop bound");
    _jump1044:;
    // Computing total size of heap memory to allocate
    int64_t _738 = 1;
    _738 *= _726.d0;
    _738 *= _726.d1;
    _738 *= sizeof(bool);
    _737.data = jpl_alloc(_738);
    int64_t _739 = 0; // m
    int64_t _740 = 0; // l
    _jump1045:; // Begin body of loop
    bool _741 = false;
    bool _742 = !_741;
    bool _743;
    if (!_742)
    goto _jump1046;
    bool _744 = _345.d2 != _740;
    _743 = _744;
    goto _jump1047;
    _jump1046:;
    bool _745 = true;
    _743 = _745;
    _jump1047:;
    int64_t _746 = 0;
    _746 *= _737.d0;
    _746 += _740;
    _746 *= _737.d1;
    _746 += _739;
    _737.data[_746] = _743;
    _739++;
    if (_739 < _726.d1)
    goto _jump1045;
    _739 = 0;
    _740++;
    if (_740 < _726.d0)
    goto _jump1045;
    // End body of loop
    _736 = _737;
    goto _jump1048;
    _jump1042:;
    _a2_bool _747;
    // Computing bound for l
    int64_t _748 = 188;
    _747.d0 = _748;
    if (_748 > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing bound for m
    int64_t _749 = 816;
    _747.d1 = _749;
    if (_749 > 0) 
    goto _jump1050;
    fail_assertion("non-positive loop bound");
    _jump1050:;
    // Computing total size of heap memory to allocate
    int64_t _750 = 1;
    _750 *= _748;
    _750 *= _749;
    _750 *= sizeof(bool);
    _747.data = jpl_alloc(_750);
    int64_t _751 = 0; // m
    int64_t _752 = 0; // l
    _jump1051:; // Begin body of loop
    bool _753 = false;
    bool _754 = !_753;
    int64_t _755 = 0;
    _755 *= _747.d0;
    _755 += _752;
    _755 *= _747.d1;
    _755 += _751;
    _747.data[_755] = _754;
    _751++;
    if (_751 < _749)
    goto _jump1051;
    _751 = 0;
    _752++;
    if (_752 < _748)
    goto _jump1051;
    // End body of loop
    _736 = _747;
    _jump1048:;
    _a3_int64_t _756;
    // Computing bound for l
    int64_t _757 = _726.d0 % _726.d0;
    _756.d0 = _757;
    if (_757 > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing bound for m
    _756.d1 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing bound for n
    int64_t _758 = -_345.d0;
    _756.d2 = _758;
    if (_758 > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing total size of heap memory to allocate
    int64_t _759 = 1;
    _759 *= _757;
    _759 *= _726.d0;
    _759 *= _758;
    _759 *= sizeof(int64_t);
    _756.data = jpl_alloc(_759);
    int64_t _760 = 0; // n
    int64_t _761 = 0; // m
    int64_t _762 = 0; // l
    _jump1055:; // Begin body of loop
    int64_t _763;
    // Computing bound for o
    if (_345.d2 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    // Computing bound for p
    if (_762 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing bound for q
    if (_726.d0 > 0) 
    goto _jump1058;
    fail_assertion("non-positive loop bound");
    _jump1058:;
    _763 = 0;
    int64_t _764 = 0; // q
    int64_t _765 = 0; // p
    int64_t _766 = 0; // o
    _jump1059:; // Begin body of loop
    _763 += _345.d1;
    _764++;
    if (_764 < _726.d0)
    goto _jump1059;
    _764 = 0;
    _765++;
    if (_765 < _762)
    goto _jump1059;
    _765 = 0;
    _766++;
    if (_766 < _345.d2)
    goto _jump1059;
    // End body of loop
    int64_t _767 = 0;
    _767 *= _756.d0;
    _767 += _762;
    _767 *= _756.d1;
    _767 += _761;
    _767 *= _756.d2;
    _767 += _760;
    _756.data[_767] = _763;
    _760++;
    if (_760 < _758)
    goto _jump1055;
    _760 = 0;
    _761++;
    if (_761 < _726.d0)
    goto _jump1055;
    _761 = 0;
    _762++;
    if (_762 < _757)
    goto _jump1055;
    // End body of loop
    int64_t _768;
    // Computing bound for l
    if (_345.d0 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing bound for m
    int64_t _769 = _726.d0 + _345.d0;
    if (_769 > 0) 
    goto _jump1061;
    fail_assertion("non-positive loop bound");
    _jump1061:;
    _768 = 0;
    int64_t _770 = 0; // m
    int64_t _771 = 0; // l
    _jump1062:; // Begin body of loop
    _768 += _726.d0;
    _770++;
    if (_770 < _769)
    goto _jump1062;
    _770 = 0;
    _771++;
    if (_771 < _345.d0)
    goto _jump1062;
    // End body of loop
    int64_t _772;
    // Computing bound for l
    if (_726.d1 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for m
    int64_t _773 = 573;
    int64_t _774 = 290;
    if (_773 >= 0)
    goto _jump1064;
    fail_assertion("negative array index");
    _jump1064:;
    if (_773 < _345.d0)
    goto _jump1065;
    fail_assertion("index too large");
    _jump1065:;
    if (_774 >= 0)
    goto _jump1066;
    fail_assertion("negative array index");
    _jump1066:;
    if (_774 < _345.d1)
    goto _jump1067;
    fail_assertion("index too large");
    _jump1067:;
    if (_345.d1 >= 0)
    goto _jump1068;
    fail_assertion("negative array index");
    _jump1068:;
    if (_345.d1 < _345.d2)
    goto _jump1069;
    fail_assertion("index too large");
    _jump1069:;
    int64_t _775 = 0;
    _775 *= _345.d0;
    _775 += _773;
    _775 *= _345.d1;
    _775 += _774;
    _775 *= _345.d2;
    _775 += _345.d1;
    int64_t _776 = _345.data[_775];
    if (_776 > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    _772 = 0;
    int64_t _777 = 0; // m
    int64_t _778 = 0; // l
    _jump1071:; // Begin body of loop
    _772 += _345.d0;
    _777++;
    if (_777 < _776)
    goto _jump1071;
    _777 = 0;
    _778++;
    if (_778 < _726.d1)
    goto _jump1071;
    // End body of loop
    if (_768 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (_768 < _756.d0)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    if (_726.d1 >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (_726.d1 < _756.d1)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    if (_772 >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (_772 < _756.d2)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    int64_t _779 = 0;
    _779 *= _756.d0;
    _779 += _768;
    _779 *= _756.d1;
    _779 += _726.d1;
    _779 *= _756.d2;
    _779 += _772;
    int64_t _780 = _756.data[_779];
    _a2_int64_t _781;
    // Computing bound for l
    _781.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    // Computing bound for m
    _781.d1 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing total size of heap memory to allocate
    int64_t _782 = 1;
    _782 *= _345.d2;
    _782 *= _345.d0;
    _782 *= sizeof(int64_t);
    _781.data = jpl_alloc(_782);
    int64_t _783 = 0; // m
    int64_t _784 = 0; // l
    _jump1080:; // Begin body of loop
    int64_t _785 = 545;
    int64_t _786 = 0;
    _786 *= _781.d0;
    _786 += _784;
    _786 *= _781.d1;
    _786 += _783;
    _781.data[_786] = _785;
    _783++;
    if (_783 < _345.d0)
    goto _jump1080;
    _783 = 0;
    _784++;
    if (_784 < _345.d2)
    goto _jump1080;
    // End body of loop
    if (_345.d1 >= 0)
    goto _jump1081;
    fail_assertion("negative array index");
    _jump1081:;
    if (_345.d1 < _781.d0)
    goto _jump1082;
    fail_assertion("index too large");
    _jump1082:;
    if (_345.d0 >= 0)
    goto _jump1083;
    fail_assertion("negative array index");
    _jump1083:;
    if (_345.d0 < _781.d1)
    goto _jump1084;
    fail_assertion("index too large");
    _jump1084:;
    int64_t _787 = 0;
    _787 *= _781.d0;
    _787 += _345.d1;
    _787 *= _781.d1;
    _787 += _345.d0;
    int64_t _788 = _781.data[_787];
    int64_t _789 = _780 - _788;
    if (_789 >= 0)
    goto _jump1085;
    fail_assertion("negative array index");
    _jump1085:;
    if (_789 < _736.d0)
    goto _jump1086;
    fail_assertion("index too large");
    _jump1086:;
    if (_345.d2 >= 0)
    goto _jump1087;
    fail_assertion("negative array index");
    _jump1087:;
    if (_345.d2 < _736.d1)
    goto _jump1088;
    fail_assertion("index too large");
    _jump1088:;
    int64_t _790 = 0;
    _790 *= _736.d0;
    _790 += _789;
    _790 *= _736.d1;
    _790 += _345.d2;
    bool _791 = _736.data[_790];
    _a1_bool _792;
    _792.d0 = 1;
    _792.data = jpl_alloc(sizeof(bool) * 1);
    _792.data[0] = _791;
    int64_t _793 = 905;
    bool _794 = _345.d2 <= _793;
    bool _795 = !_794;
    bool _796 = true;
    bool _797 = _795 != _796;
    double _798;
    if (!_797)
    goto _jump1089;
    double _799;
    // Computing bound for l
    int64_t _800 = 490;
    if (_800 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    _799 = 0;
    int64_t _801 = 0; // l
    _jump1091:; // Begin body of loop
    bool _802 = _726.d1 == _345.d0;
    double _803;
    if (!_802)
    goto _jump1092;
    double _804;
    // Computing bound for m
    if (_345.d1 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    _804 = 0;
    int64_t _805 = 0; // m
    _jump1094:; // Begin body of loop
    double _806 = 75.0;
    _804 += _806;
    _805++;
    if (_805 < _345.d1)
    goto _jump1094;
    // End body of loop
    _803 = _804;
    goto _jump1095;
    _jump1092:;
    double _807 = 27.0;
    _803 = _807;
    _jump1095:;
    _799 += _803;
    _801++;
    if (_801 < _800)
    goto _jump1091;
    // End body of loop
    _798 = _799;
    goto _jump1096;
    _jump1089:;
    double _808;
    // Computing bound for l
    if (_345.d2 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for m
    if (_345.d2 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    _808 = 0;
    int64_t _809 = 0; // m
    int64_t _810 = 0; // l
    _jump1099:; // Begin body of loop
    double _811 = 78.0;
    double _812 = 75.0;
    double _813 = _811 - _812;
    _808 += _813;
    _809++;
    if (_809 < _345.d2)
    goto _jump1099;
    _809 = 0;
    _810++;
    if (_810 < _345.d2)
    goto _jump1099;
    // End body of loop
    _798 = _808;
    _jump1096:;
    double _814 = 47.0;
    bool _815 = _798 == _814;
    int64_t _816;
    if (!_815)
    goto _jump1100;
    bool _817 = _345.d0 <= _726.d1;
    _a2_bool _818;
    if (!_817)
    goto _jump1101;
    _a2_bool _819;
    // Computing bound for l
    int64_t _820;
    // Computing bound for l
    if (_345.d1 > 0) 
    goto _jump1102;
    fail_assertion("non-positive loop bound");
    _jump1102:;
    _820 = 0;
    int64_t _821 = 0; // l
    _jump1103:; // Begin body of loop
    _820 += _345.d0;
    _821++;
    if (_821 < _345.d1)
    goto _jump1103;
    // End body of loop
    _819.d0 = _820;
    if (_820 > 0) 
    goto _jump1104;
    fail_assertion("non-positive loop bound");
    _jump1104:;
    // Computing bound for m
    int64_t _822;
    // Computing bound for l
    int64_t _823;
    // Computing bound for l
    if (_726.d0 > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing bound for m
    if (_345.d0 > 0) 
    goto _jump1106;
    fail_assertion("non-positive loop bound");
    _jump1106:;
    // Computing bound for n
    if (_345.d1 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    _823 = 0;
    int64_t _824 = 0; // n
    int64_t _825 = 0; // m
    int64_t _826 = 0; // l
    _jump1108:; // Begin body of loop
    _823 += _824;
    _824++;
    if (_824 < _345.d1)
    goto _jump1108;
    _824 = 0;
    _825++;
    if (_825 < _345.d0)
    goto _jump1108;
    _825 = 0;
    _826++;
    if (_826 < _726.d0)
    goto _jump1108;
    // End body of loop
    if (_823 > 0) 
    goto _jump1109;
    fail_assertion("non-positive loop bound");
    _jump1109:;
    _822 = 0;
    int64_t _827 = 0; // l
    _jump1110:; // Begin body of loop
    bool _828 = true;
    int64_t _829;
    if (!_828)
    goto _jump1111;
    _829 = _345.d0;
    goto _jump1112;
    _jump1111:;
    int64_t _830 = 514;
    _829 = _830;
    _jump1112:;
    _822 += _829;
    _827++;
    if (_827 < _823)
    goto _jump1110;
    // End body of loop
    _819.d1 = _822;
    if (_822 > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    // Computing total size of heap memory to allocate
    int64_t _831 = 1;
    _831 *= _820;
    _831 *= _822;
    _831 *= sizeof(bool);
    _819.data = jpl_alloc(_831);
    int64_t _832 = 0; // m
    int64_t _833 = 0; // l
    _jump1114:; // Begin body of loop
    double _834 = 85.0;
    double _835 = -_834;
    double _836 = 23.0;
    double _837 = -_836;
    bool _838 = _835 != _837;
    int64_t _839 = 0;
    _839 *= _819.d0;
    _839 += _833;
    _839 *= _819.d1;
    _839 += _832;
    _819.data[_839] = _838;
    _832++;
    if (_832 < _822)
    goto _jump1114;
    _832 = 0;
    _833++;
    if (_833 < _820)
    goto _jump1114;
    // End body of loop
    _818 = _819;
    goto _jump1115;
    _jump1101:;
    _a2_bool _840;
    // Computing bound for l
    int64_t _841;
    // Computing bound for l
    int64_t _842 = 44;
    if (_842 > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for m
    int64_t _843;
    // Computing bound for l
    if (_726.d0 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for m
    if (_726.d1 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    // Computing bound for n
    if (_726.d1 > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    _843 = 0;
    int64_t _844 = 0; // n
    int64_t _845 = 0; // m
    int64_t _846 = 0; // l
    _jump1120:; // Begin body of loop
    _843 += _345.d1;
    _844++;
    if (_844 < _726.d1)
    goto _jump1120;
    _844 = 0;
    _845++;
    if (_845 < _726.d1)
    goto _jump1120;
    _845 = 0;
    _846++;
    if (_846 < _726.d0)
    goto _jump1120;
    // End body of loop
    if (_843 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    _841 = 0;
    int64_t _847 = 0; // m
    int64_t _848 = 0; // l
    _jump1122:; // Begin body of loop
    _841 += _345.d0;
    _847++;
    if (_847 < _843)
    goto _jump1122;
    _847 = 0;
    _848++;
    if (_848 < _842)
    goto _jump1122;
    // End body of loop
    _840.d0 = _841;
    if (_841 > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    // Computing bound for m
    _840.d1 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing total size of heap memory to allocate
    int64_t _849 = 1;
    _849 *= _841;
    _849 *= _726.d1;
    _849 *= sizeof(bool);
    _840.data = jpl_alloc(_849);
    int64_t _850 = 0; // m
    int64_t _851 = 0; // l
    _jump1125:; // Begin body of loop
    bool _852 = true;
    int64_t _853 = 0;
    _853 *= _840.d0;
    _853 += _851;
    _853 *= _840.d1;
    _853 += _850;
    _840.data[_853] = _852;
    _850++;
    if (_850 < _726.d1)
    goto _jump1125;
    _850 = 0;
    _851++;
    if (_851 < _841)
    goto _jump1125;
    // End body of loop
    _818 = _840;
    _jump1115:;
    _a1__a1_bool _854;
    // Computing bound for l
    _854.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1126;
    fail_assertion("non-positive loop bound");
    _jump1126:;
    // Computing total size of heap memory to allocate
    int64_t _855 = 1;
    _855 *= _726.d1;
    _855 *= sizeof(_a1_bool);
    _854.data = jpl_alloc(_855);
    int64_t _856 = 0; // l
    _jump1127:; // Begin body of loop
    _a1_bool _857;
    // Computing bound for m
    int64_t _858 = 236;
    _857.d0 = _858;
    if (_858 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    // Computing total size of heap memory to allocate
    int64_t _859 = 1;
    _859 *= _858;
    _859 *= sizeof(bool);
    _857.data = jpl_alloc(_859);
    int64_t _860 = 0; // m
    _jump1129:; // Begin body of loop
    bool _861 = true;
    int64_t _862 = 0;
    _862 *= _857.d0;
    _862 += _860;
    _857.data[_862] = _861;
    _860++;
    if (_860 < _858)
    goto _jump1129;
    // End body of loop
    int64_t _863 = 0;
    _863 *= _854.d0;
    _863 += _856;
    _854.data[_863] = _857;
    _856++;
    if (_856 < _726.d1)
    goto _jump1127;
    // End body of loop
    if (_345.d1 >= 0)
    goto _jump1130;
    fail_assertion("negative array index");
    _jump1130:;
    if (_345.d1 < _854.d0)
    goto _jump1131;
    fail_assertion("index too large");
    _jump1131:;
    int64_t _864 = 0;
    _864 *= _854.d0;
    _864 += _345.d1;
    _a1_bool _865 = _854.data[_864];
    bool _866 = false;
    _a1_bool _867;
    _867.d0 = 1;
    _867.data = jpl_alloc(sizeof(bool) * 1);
    _867.data[0] = _866;
    void_t _868 = b(_865, _867);
    int64_t _869 = a(_818, _868);
    _816 = _869;
    goto _jump1132;
    _jump1100:;
    _816 = _726.d0;
    _jump1132:;
    if (_816 >= 0)
    goto _jump1133;
    fail_assertion("negative array index");
    _jump1133:;
    if (_816 < _792.d0)
    goto _jump1134;
    fail_assertion("index too large");
    _jump1134:;
    int64_t _870 = 0;
    _870 *= _792.d0;
    _870 += _816;
    bool _871 = _792.data[_870];
    if (0 != _871)
    goto _jump1135;
    fail_assertion("l");
    _jump1135:;
    _a2__a3_double _872;
    // Computing bound for p
    int64_t _873;
    // Computing bound for p
    int64_t _874 = -_345.d2;
    if (_874 > 0) 
    goto _jump1775;
    fail_assertion("non-positive loop bound");
    _jump1775:;
    // Computing bound for q
    if (_726.d0 > 0) 
    goto _jump1776;
    fail_assertion("non-positive loop bound");
    _jump1776:;
    // Computing bound for r
    int64_t _875 = 636;
    if (_875 > 0) 
    goto _jump1777;
    fail_assertion("non-positive loop bound");
    _jump1777:;
    _873 = 0;
    int64_t _876 = 0; // r
    int64_t _877 = 0; // q
    int64_t _878 = 0; // p
    _jump1778:; // Begin body of loop
    int64_t _879 = _345.d2 % _345.d2;
    _873 += _879;
    _876++;
    if (_876 < _875)
    goto _jump1778;
    _876 = 0;
    _877++;
    if (_877 < _726.d0)
    goto _jump1778;
    _877 = 0;
    _878++;
    if (_878 < _874)
    goto _jump1778;
    // End body of loop
    _872.d0 = _873;
    if (_873 > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    // Computing bound for q
    if (_726.d1 >= 0)
    goto _jump1780;
    fail_assertion("negative array index");
    _jump1780:;
    if (_726.d1 < _726.d0)
    goto _jump1781;
    fail_assertion("index too large");
    _jump1781:;
    if (_345.d0 >= 0)
    goto _jump1782;
    fail_assertion("negative array index");
    _jump1782:;
    if (_345.d0 < _726.d1)
    goto _jump1783;
    fail_assertion("index too large");
    _jump1783:;
    int64_t _880 = 0;
    _880 *= _726.d0;
    _880 += _726.d1;
    _880 *= _726.d1;
    _880 += _345.d0;
    int64_t _881 = _726.data[_880];
    _872.d1 = _881;
    if (_881 > 0) 
    goto _jump1784;
    fail_assertion("non-positive loop bound");
    _jump1784:;
    // Computing total size of heap memory to allocate
    int64_t _882 = 1;
    _882 *= _873;
    _882 *= _881;
    _882 *= sizeof(_a3_double);
    _872.data = jpl_alloc(_882);
    int64_t _883 = 0; // q
    int64_t _884 = 0; // p
    _jump1785:; // Begin body of loop
    _a3_double _885;
    // Computing bound for r
    int64_t _886;
    // Computing bound for r
    if (_884 > 0) 
    goto _jump1786;
    fail_assertion("non-positive loop bound");
    _jump1786:;
    // Computing bound for s
    if (_726.d1 > 0) 
    goto _jump1787;
    fail_assertion("non-positive loop bound");
    _jump1787:;
    _886 = 0;
    int64_t _887 = 0; // s
    int64_t _888 = 0; // r
    _jump1788:; // Begin body of loop
    _886 += _887;
    _887++;
    if (_887 < _726.d1)
    goto _jump1788;
    _887 = 0;
    _888++;
    if (_888 < _884)
    goto _jump1788;
    // End body of loop
    _885.d0 = _886;
    if (_886 > 0) 
    goto _jump1789;
    fail_assertion("non-positive loop bound");
    _jump1789:;
    // Computing bound for s
    int64_t _889 = 777;
    int64_t _890 = -_889;
    _885.d1 = _890;
    if (_890 > 0) 
    goto _jump1790;
    fail_assertion("non-positive loop bound");
    _jump1790:;
    // Computing bound for t
    _885.d2 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    // Computing total size of heap memory to allocate
    int64_t _891 = 1;
    _891 *= _886;
    _891 *= _890;
    _891 *= _726.d1;
    _891 *= sizeof(double);
    _885.data = jpl_alloc(_891);
    int64_t _892 = 0; // t
    int64_t _893 = 0; // s
    int64_t _894 = 0; // r
    _jump1792:; // Begin body of loop
    double _895;
    // Computing bound for u
    if (_894 > 0) 
    goto _jump1793;
    fail_assertion("non-positive loop bound");
    _jump1793:;
    // Computing bound for v
    if (_883 > 0) 
    goto _jump1794;
    fail_assertion("non-positive loop bound");
    _jump1794:;
    // Computing bound for w
    if (_884 > 0) 
    goto _jump1795;
    fail_assertion("non-positive loop bound");
    _jump1795:;
    _895 = 0;
    int64_t _896 = 0; // w
    int64_t _897 = 0; // v
    int64_t _898 = 0; // u
    _jump1796:; // Begin body of loop
    double _899 = 96.0;
    _895 += _899;
    _896++;
    if (_896 < _884)
    goto _jump1796;
    _896 = 0;
    _897++;
    if (_897 < _883)
    goto _jump1796;
    _897 = 0;
    _898++;
    if (_898 < _894)
    goto _jump1796;
    // End body of loop
    int64_t _900 = 0;
    _900 *= _885.d0;
    _900 += _894;
    _900 *= _885.d1;
    _900 += _893;
    _900 *= _885.d2;
    _900 += _892;
    _885.data[_900] = _895;
    _892++;
    if (_892 < _726.d1)
    goto _jump1792;
    _892 = 0;
    _893++;
    if (_893 < _890)
    goto _jump1792;
    _893 = 0;
    _894++;
    if (_894 < _886)
    goto _jump1792;
    // End body of loop
    int64_t _901 = 0;
    _901 *= _872.d0;
    _901 += _884;
    _901 *= _872.d1;
    _901 += _883;
    _872.data[_901] = _885;
    _883++;
    if (_883 < _881)
    goto _jump1785;
    _883 = 0;
    _884++;
    if (_884 < _873)
    goto _jump1785;
    // End body of loop
    int64_t _902;
    // Computing bound for p
    int64_t _903;
    // Computing bound for p
    if (_345.d1 > 0) 
    goto _jump1797;
    fail_assertion("non-positive loop bound");
    _jump1797:;
    _903 = 0;
    int64_t _904 = 0; // p
    _jump1798:; // Begin body of loop
    int64_t _905 = -_345.d1;
    _903 += _905;
    _904++;
    if (_904 < _345.d1)
    goto _jump1798;
    // End body of loop
    if (_903 > 0) 
    goto _jump1799;
    fail_assertion("non-positive loop bound");
    _jump1799:;
    // Computing bound for q
    int64_t _906 = 889;
    if (_906 > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for r
    bool _907 = _345.d1 == _345.d2;
    int64_t _908;
    if (!_907)
    goto _jump1801;
    _908 = _726.d1;
    goto _jump1802;
    _jump1801:;
    int64_t _909 = 283;
    _908 = _909;
    _jump1802:;
    if (_908 > 0) 
    goto _jump1803;
    fail_assertion("non-positive loop bound");
    _jump1803:;
    _902 = 0;
    int64_t _910 = 0; // r
    int64_t _911 = 0; // q
    int64_t _912 = 0; // p
    _jump1804:; // Begin body of loop
    int64_t _913 = 135;
    _902 += _913;
    _910++;
    if (_910 < _908)
    goto _jump1804;
    _910 = 0;
    _911++;
    if (_911 < _906)
    goto _jump1804;
    _911 = 0;
    _912++;
    if (_912 < _903)
    goto _jump1804;
    // End body of loop
    if (_902 >= 0)
    goto _jump1805;
    fail_assertion("negative array index");
    _jump1805:;
    if (_902 < _872.d0)
    goto _jump1806;
    fail_assertion("index too large");
    _jump1806:;
    if (_345.d2 >= 0)
    goto _jump1807;
    fail_assertion("negative array index");
    _jump1807:;
    if (_345.d2 < _872.d1)
    goto _jump1808;
    fail_assertion("index too large");
    _jump1808:;
    int64_t _914 = 0;
    _914 *= _872.d0;
    _914 += _902;
    _914 *= _872.d1;
    _914 += _345.d2;
    _a3_double _915 = _872.data[_914];
    bool _916 = n(_915);
    _a1_bool _917;
    // Computing bound for p
    int64_t _918;
    // Computing bound for p
    if (_345.d2 > 0) 
    goto _jump1809;
    fail_assertion("non-positive loop bound");
    _jump1809:;
    // Computing bound for q
    if (_345.d1 > 0) 
    goto _jump1810;
    fail_assertion("non-positive loop bound");
    _jump1810:;
    _918 = 0;
    int64_t _919 = 0; // q
    int64_t _920 = 0; // p
    _jump1811:; // Begin body of loop
    int64_t _921;
    // Computing bound for r
    if (_345.d1 > 0) 
    goto _jump1812;
    fail_assertion("non-positive loop bound");
    _jump1812:;
    // Computing bound for s
    if (_726.d1 > 0) 
    goto _jump1813;
    fail_assertion("non-positive loop bound");
    _jump1813:;
    _921 = 0;
    int64_t _922 = 0; // s
    int64_t _923 = 0; // r
    _jump1814:; // Begin body of loop
    int64_t _924 = 88;
    _921 += _924;
    _922++;
    if (_922 < _726.d1)
    goto _jump1814;
    _922 = 0;
    _923++;
    if (_923 < _345.d1)
    goto _jump1814;
    // End body of loop
    _918 += _921;
    _919++;
    if (_919 < _345.d1)
    goto _jump1811;
    _919 = 0;
    _920++;
    if (_920 < _345.d2)
    goto _jump1811;
    // End body of loop
    _917.d0 = _918;
    if (_918 > 0) 
    goto _jump1815;
    fail_assertion("non-positive loop bound");
    _jump1815:;
    // Computing total size of heap memory to allocate
    int64_t _925 = 1;
    _925 *= _918;
    _925 *= sizeof(bool);
    _917.data = jpl_alloc(_925);
    int64_t _926 = 0; // p
    _jump1816:; // Begin body of loop
    bool _927 = true;
    bool _928 = !_927;
    bool _929 = !_928;
    int64_t _930 = 0;
    _930 *= _917.d0;
    _930 += _926;
    _917.data[_930] = _929;
    _926++;
    if (_926 < _918)
    goto _jump1816;
    // End body of loop
    if (_726.d0 >= 0)
    goto _jump1817;
    fail_assertion("negative array index");
    _jump1817:;
    if (_726.d0 < _917.d0)
    goto _jump1818;
    fail_assertion("index too large");
    _jump1818:;
    int64_t _931 = 0;
    _931 *= _917.d0;
    _931 += _726.d0;
    bool _932 = _917.data[_931];
    bool _933;
    if (!_932)
    goto _jump1819;
    _a1_bool _934;
    // Computing bound for p
    _934.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing total size of heap memory to allocate
    int64_t _935 = 1;
    _935 *= _726.d1;
    _935 *= sizeof(bool);
    _934.data = jpl_alloc(_935);
    int64_t _936 = 0; // p
    _jump1821:; // Begin body of loop
    bool _937 = false;
    int64_t _938 = 0;
    _938 *= _934.d0;
    _938 += _936;
    _934.data[_938] = _937;
    _936++;
    if (_936 < _726.d1)
    goto _jump1821;
    // End body of loop
    if (_345.d1 >= 0)
    goto _jump1822;
    fail_assertion("negative array index");
    _jump1822:;
    if (_345.d1 < _934.d0)
    goto _jump1823;
    fail_assertion("index too large");
    _jump1823:;
    int64_t _939 = 0;
    _939 *= _934.d0;
    _939 += _345.d1;
    bool _940 = _934.data[_939];
    bool _941 = !_940;
    bool _942;
    if (!_941)
    goto _jump1824;
    _a2_bool _943;
    // Computing bound for p
    _943.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1825;
    fail_assertion("non-positive loop bound");
    _jump1825:;
    // Computing bound for q
    int64_t _944 = -_726.d1;
    _943.d1 = _944;
    if (_944 > 0) 
    goto _jump1826;
    fail_assertion("non-positive loop bound");
    _jump1826:;
    // Computing total size of heap memory to allocate
    int64_t _945 = 1;
    _945 *= _345.d1;
    _945 *= _944;
    _945 *= sizeof(bool);
    _943.data = jpl_alloc(_945);
    int64_t _946 = 0; // q
    int64_t _947 = 0; // p
    _jump1827:; // Begin body of loop
    int64_t _948 = 460;
    bool _949 = _726.d0 == _948;
    int64_t _950 = 0;
    _950 *= _943.d0;
    _950 += _947;
    _950 *= _943.d1;
    _950 += _946;
    _943.data[_950] = _949;
    _946++;
    if (_946 < _944)
    goto _jump1827;
    _946 = 0;
    _947++;
    if (_947 < _345.d1)
    goto _jump1827;
    // End body of loop
    int64_t _951;
    // Computing bound for p
    if (_345.d0 > 0) 
    goto _jump1828;
    fail_assertion("non-positive loop bound");
    _jump1828:;
    _951 = 0;
    int64_t _952 = 0; // p
    _jump1829:; // Begin body of loop
    _951 += _345.d0;
    _952++;
    if (_952 < _345.d0)
    goto _jump1829;
    // End body of loop
    int64_t _953 = -_726.d0;
    if (_951 >= 0)
    goto _jump1830;
    fail_assertion("negative array index");
    _jump1830:;
    if (_951 < _943.d0)
    goto _jump1831;
    fail_assertion("index too large");
    _jump1831:;
    if (_953 >= 0)
    goto _jump1832;
    fail_assertion("negative array index");
    _jump1832:;
    if (_953 < _943.d1)
    goto _jump1833;
    fail_assertion("index too large");
    _jump1833:;
    int64_t _954 = 0;
    _954 *= _943.d0;
    _954 += _951;
    _954 *= _943.d1;
    _954 += _953;
    bool _955 = _943.data[_954];
    _942 = _955;
    goto _jump1834;
    _jump1824:;
    bool _956 = _345.d1 != _345.d2;
    bool _957 = !_956;
    _942 = _957;
    _jump1834:;
    _933 = _942;
    goto _jump1835;
    _jump1819:;
    int64_t _958 = _726.d1 + _345.d1;
    bool _959 = false;
    int64_t _960;
    if (!_959)
    goto _jump1836;
    bool _961 = true;
    int64_t _962;
    if (!_961)
    goto _jump1837;
    _962 = _345.d0;
    goto _jump1838;
    _jump1837:;
    _962 = _345.d0;
    _jump1838:;
    _960 = _962;
    goto _jump1839;
    _jump1836:;
    _960 = _345.d2;
    _jump1839:;
    bool _963 = _958 < _960;
    bool _964;
    if (!_963)
    goto _jump1840;
    bool _966 = false;
    bool _965 = _966;
    if (0 == _966)
    goto _jump1841;
    bool _967 = _345.d1 == _345.d0;
    _965 = _967;
    _jump1841:;
    bool _968 = !_965;
    _964 = _968;
    goto _jump1842;
    _jump1840:;
    _a3_double _969;
    // Computing bound for p
    int64_t _970 = 643;
    _969.d0 = _970;
    if (_970 > 0) 
    goto _jump1843;
    fail_assertion("non-positive loop bound");
    _jump1843:;
    // Computing bound for q
    _969.d1 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump1844;
    fail_assertion("non-positive loop bound");
    _jump1844:;
    // Computing bound for r
    int64_t _971 = -_345.d2;
    _969.d2 = _971;
    if (_971 > 0) 
    goto _jump1845;
    fail_assertion("non-positive loop bound");
    _jump1845:;
    // Computing total size of heap memory to allocate
    int64_t _972 = 1;
    _972 *= _970;
    _972 *= _345.d0;
    _972 *= _971;
    _972 *= sizeof(double);
    _969.data = jpl_alloc(_972);
    int64_t _973 = 0; // r
    int64_t _974 = 0; // q
    int64_t _975 = 0; // p
    _jump1846:; // Begin body of loop
    double _976 = 20.0;
    int64_t _977 = 0;
    _977 *= _969.d0;
    _977 += _975;
    _977 *= _969.d1;
    _977 += _974;
    _977 *= _969.d2;
    _977 += _973;
    _969.data[_977] = _976;
    _973++;
    if (_973 < _971)
    goto _jump1846;
    _973 = 0;
    _974++;
    if (_974 < _345.d0)
    goto _jump1846;
    _974 = 0;
    _975++;
    if (_975 < _970)
    goto _jump1846;
    // End body of loop
    bool _978 = n(_969);
    _964 = _978;
    _jump1842:;
    _933 = _964;
    _jump1835:;
    bool _979 = _916 != _933;
    _a2_int64_t _980;
    if (!_979)
    goto _jump1847;
    _a3__a2_int64_t _981;
    // Computing bound for p
    int64_t _982;
    // Computing bound for p
    if (_726.d0 > 0) 
    goto _jump1848;
    fail_assertion("non-positive loop bound");
    _jump1848:;
    // Computing bound for q
    int64_t _983;
    // Computing bound for p
    if (_726.d1 > 0) 
    goto _jump1849;
    fail_assertion("non-positive loop bound");
    _jump1849:;
    // Computing bound for q
    if (_345.d2 > 0) 
    goto _jump1850;
    fail_assertion("non-positive loop bound");
    _jump1850:;
    _983 = 0;
    int64_t _984 = 0; // q
    int64_t _985 = 0; // p
    _jump1851:; // Begin body of loop
    int64_t _986 = 34;
    _983 += _986;
    _984++;
    if (_984 < _345.d2)
    goto _jump1851;
    _984 = 0;
    _985++;
    if (_985 < _726.d1)
    goto _jump1851;
    // End body of loop
    if (_983 > 0) 
    goto _jump1852;
    fail_assertion("non-positive loop bound");
    _jump1852:;
    _982 = 0;
    int64_t _987 = 0; // q
    int64_t _988 = 0; // p
    _jump1853:; // Begin body of loop
    _982 += _988;
    _987++;
    if (_987 < _983)
    goto _jump1853;
    _987 = 0;
    _988++;
    if (_988 < _726.d0)
    goto _jump1853;
    // End body of loop
    int64_t _989;
    // Computing bound for p
    if (_726.d0 > 0) 
    goto _jump1854;
    fail_assertion("non-positive loop bound");
    _jump1854:;
    // Computing bound for q
    int64_t _990 = 491;
    if (_990 > 0) 
    goto _jump1855;
    fail_assertion("non-positive loop bound");
    _jump1855:;
    // Computing bound for r
    if (_345.d2 > 0) 
    goto _jump1856;
    fail_assertion("non-positive loop bound");
    _jump1856:;
    _989 = 0;
    int64_t _991 = 0; // r
    int64_t _992 = 0; // q
    int64_t _993 = 0; // p
    _jump1857:; // Begin body of loop
    _989 += _345.d1;
    _991++;
    if (_991 < _345.d2)
    goto _jump1857;
    _991 = 0;
    _992++;
    if (_992 < _990)
    goto _jump1857;
    _992 = 0;
    _993++;
    if (_993 < _726.d0)
    goto _jump1857;
    // End body of loop
    int64_t _994 = -_726.d0;
    int64_t _995 = _989 / _994;
    int64_t _996 = _982 % _995;
    int64_t _997 = 919;
    if (_345.d0 >= 0)
    goto _jump1858;
    fail_assertion("negative array index");
    _jump1858:;
    if (_345.d0 < _345.d0)
    goto _jump1859;
    fail_assertion("index too large");
    _jump1859:;
    if (_996 >= 0)
    goto _jump1860;
    fail_assertion("negative array index");
    _jump1860:;
    if (_996 < _345.d1)
    goto _jump1861;
    fail_assertion("index too large");
    _jump1861:;
    if (_997 >= 0)
    goto _jump1862;
    fail_assertion("negative array index");
    _jump1862:;
    if (_997 < _345.d2)
    goto _jump1863;
    fail_assertion("index too large");
    _jump1863:;
    int64_t _998 = 0;
    _998 *= _345.d0;
    _998 += _345.d0;
    _998 *= _345.d1;
    _998 += _996;
    _998 *= _345.d2;
    _998 += _997;
    int64_t _999 = _345.data[_998];
    _981.d0 = _999;
    if (_999 > 0) 
    goto _jump1864;
    fail_assertion("non-positive loop bound");
    _jump1864:;
    // Computing bound for q
    _981.d1 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1865;
    fail_assertion("non-positive loop bound");
    _jump1865:;
    // Computing bound for r
    _981.d2 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1866;
    fail_assertion("non-positive loop bound");
    _jump1866:;
    // Computing total size of heap memory to allocate
    int64_t _1000 = 1;
    _1000 *= _999;
    _1000 *= _726.d0;
    _1000 *= _345.d1;
    _1000 *= sizeof(_a2_int64_t);
    _981.data = jpl_alloc(_1000);
    int64_t _1001 = 0; // r
    int64_t _1002 = 0; // q
    int64_t _1003 = 0; // p
    _jump1867:; // Begin body of loop
    double _1004 = 57.0;
    double _1005 = 39.0;
    bool _1006 = _1004 != _1005;
    _a3_double _1007;
    if (!_1006)
    goto _jump1868;
    _a3_double _1008;
    // Computing bound for s
    _1008.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1869;
    fail_assertion("non-positive loop bound");
    _jump1869:;
    // Computing bound for t
    _1008.d1 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1870;
    fail_assertion("non-positive loop bound");
    _jump1870:;
    // Computing bound for u
    _1008.d2 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1871;
    fail_assertion("non-positive loop bound");
    _jump1871:;
    // Computing total size of heap memory to allocate
    int64_t _1009 = 1;
    _1009 *= _726.d1;
    _1009 *= _345.d1;
    _1009 *= _345.d2;
    _1009 *= sizeof(double);
    _1008.data = jpl_alloc(_1009);
    int64_t _1010 = 0; // u
    int64_t _1011 = 0; // t
    int64_t _1012 = 0; // s
    _jump1872:; // Begin body of loop
    double _1013 = 35.0;
    int64_t _1014 = 0;
    _1014 *= _1008.d0;
    _1014 += _1012;
    _1014 *= _1008.d1;
    _1014 += _1011;
    _1014 *= _1008.d2;
    _1014 += _1010;
    _1008.data[_1014] = _1013;
    _1010++;
    if (_1010 < _345.d2)
    goto _jump1872;
    _1010 = 0;
    _1011++;
    if (_1011 < _345.d1)
    goto _jump1872;
    _1011 = 0;
    _1012++;
    if (_1012 < _726.d1)
    goto _jump1872;
    // End body of loop
    _1007 = _1008;
    goto _jump1873;
    _jump1868:;
    _a3_double _1015;
    // Computing bound for s
    _1015.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1874;
    fail_assertion("non-positive loop bound");
    _jump1874:;
    // Computing bound for t
    _1015.d1 = _1002;
    if (_1002 > 0) 
    goto _jump1875;
    fail_assertion("non-positive loop bound");
    _jump1875:;
    // Computing bound for u
    _1015.d2 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1876;
    fail_assertion("non-positive loop bound");
    _jump1876:;
    // Computing total size of heap memory to allocate
    int64_t _1016 = 1;
    _1016 *= _345.d1;
    _1016 *= _1002;
    _1016 *= _726.d1;
    _1016 *= sizeof(double);
    _1015.data = jpl_alloc(_1016);
    int64_t _1017 = 0; // u
    int64_t _1018 = 0; // t
    int64_t _1019 = 0; // s
    _jump1877:; // Begin body of loop
    double _1020 = 85.0;
    int64_t _1021 = 0;
    _1021 *= _1015.d0;
    _1021 += _1019;
    _1021 *= _1015.d1;
    _1021 += _1018;
    _1021 *= _1015.d2;
    _1021 += _1017;
    _1015.data[_1021] = _1020;
    _1017++;
    if (_1017 < _726.d1)
    goto _jump1877;
    _1017 = 0;
    _1018++;
    if (_1018 < _1002)
    goto _jump1877;
    _1018 = 0;
    _1019++;
    if (_1019 < _345.d1)
    goto _jump1877;
    // End body of loop
    _1007 = _1015;
    _jump1873:;
    bool _1022 = n(_1007);
    _a2_int64_t _1023;
    if (!_1022)
    goto _jump1878;
    _a2_int64_t _1024;
    // Computing bound for s
    _1024.d0 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1879;
    fail_assertion("non-positive loop bound");
    _jump1879:;
    // Computing bound for t
    _1024.d1 = _1001;
    if (_1001 > 0) 
    goto _jump1880;
    fail_assertion("non-positive loop bound");
    _jump1880:;
    // Computing total size of heap memory to allocate
    int64_t _1025 = 1;
    _1025 *= _726.d0;
    _1025 *= _1001;
    _1025 *= sizeof(int64_t);
    _1024.data = jpl_alloc(_1025);
    int64_t _1026 = 0; // t
    int64_t _1027 = 0; // s
    _jump1881:; // Begin body of loop
    int64_t _1028 = 0;
    _1028 *= _1024.d0;
    _1028 += _1027;
    _1028 *= _1024.d1;
    _1028 += _1026;
    _1024.data[_1028] = _726.d1;
    _1026++;
    if (_1026 < _1001)
    goto _jump1881;
    _1026 = 0;
    _1027++;
    if (_1027 < _726.d0)
    goto _jump1881;
    // End body of loop
    _a2_int64_t _1029;
    // Computing bound for s
    _1029.d0 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump1882;
    fail_assertion("non-positive loop bound");
    _jump1882:;
    // Computing bound for t
    int64_t _1030 = 27;
    _1029.d1 = _1030;
    if (_1030 > 0) 
    goto _jump1883;
    fail_assertion("non-positive loop bound");
    _jump1883:;
    // Computing total size of heap memory to allocate
    int64_t _1031 = 1;
    _1031 *= _345.d0;
    _1031 *= _1030;
    _1031 *= sizeof(int64_t);
    _1029.data = jpl_alloc(_1031);
    int64_t _1032 = 0; // t
    int64_t _1033 = 0; // s
    _jump1884:; // Begin body of loop
    int64_t _1034 = 0;
    _1034 *= _1029.d0;
    _1034 += _1033;
    _1034 *= _1029.d1;
    _1034 += _1032;
    _1029.data[_1034] = _345.d1;
    _1032++;
    if (_1032 < _1030)
    goto _jump1884;
    _1032 = 0;
    _1033++;
    if (_1033 < _345.d0)
    goto _jump1884;
    // End body of loop
    _a1__a2_int64_t _1035;
    _1035.d0 = 2;
    _1035.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _1035.data[0] = _1024;
    _1035.data[1] = _1029;
    int64_t _1036 = -_1003;
    if (_1036 >= 0)
    goto _jump1885;
    fail_assertion("negative array index");
    _jump1885:;
    if (_1036 < _1035.d0)
    goto _jump1886;
    fail_assertion("index too large");
    _jump1886:;
    int64_t _1037 = 0;
    _1037 *= _1035.d0;
    _1037 += _1036;
    _a2_int64_t _1038 = _1035.data[_1037];
    _1023 = _1038;
    goto _jump1887;
    _jump1878:;
    _a2_int64_t _1039;
    // Computing bound for s
    _1039.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1888;
    fail_assertion("non-positive loop bound");
    _jump1888:;
    // Computing bound for t
    int64_t _1040 = 675;
    int64_t _1041 = -_1040;
    _1039.d1 = _1041;
    if (_1041 > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    // Computing total size of heap memory to allocate
    int64_t _1042 = 1;
    _1042 *= _345.d2;
    _1042 *= _1041;
    _1042 *= sizeof(int64_t);
    _1039.data = jpl_alloc(_1042);
    int64_t _1043 = 0; // t
    int64_t _1044 = 0; // s
    _jump1890:; // Begin body of loop
    int64_t _1045 = 0;
    _1045 *= _1039.d0;
    _1045 += _1044;
    _1045 *= _1039.d1;
    _1045 += _1043;
    _1039.data[_1045] = _726.d1;
    _1043++;
    if (_1043 < _1041)
    goto _jump1890;
    _1043 = 0;
    _1044++;
    if (_1044 < _345.d2)
    goto _jump1890;
    // End body of loop
    _1023 = _1039;
    _jump1887:;
    int64_t _1046 = 0;
    _1046 *= _981.d0;
    _1046 += _1003;
    _1046 *= _981.d1;
    _1046 += _1002;
    _1046 *= _981.d2;
    _1046 += _1001;
    _981.data[_1046] = _1023;
    _1001++;
    if (_1001 < _345.d1)
    goto _jump1867;
    _1001 = 0;
    _1002++;
    if (_1002 < _726.d0)
    goto _jump1867;
    _1002 = 0;
    _1003++;
    if (_1003 < _999)
    goto _jump1867;
    // End body of loop
    int64_t _1047 = -_345.d2;
    _a2_bool _1048;
    // Computing bound for p
    _1048.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1891;
    fail_assertion("non-positive loop bound");
    _jump1891:;
    // Computing bound for q
    _1048.d1 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump1892;
    fail_assertion("non-positive loop bound");
    _jump1892:;
    // Computing total size of heap memory to allocate
    int64_t _1049 = 1;
    _1049 *= _345.d2;
    _1049 *= _345.d0;
    _1049 *= sizeof(bool);
    _1048.data = jpl_alloc(_1049);
    int64_t _1050 = 0; // q
    int64_t _1051 = 0; // p
    _jump1893:; // Begin body of loop
    _a3_double _1052;
    // Computing bound for r
    _1052.d0 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1894;
    fail_assertion("non-positive loop bound");
    _jump1894:;
    // Computing bound for s
    _1052.d1 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1895;
    fail_assertion("non-positive loop bound");
    _jump1895:;
    // Computing bound for t
    _1052.d2 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump1896;
    fail_assertion("non-positive loop bound");
    _jump1896:;
    // Computing total size of heap memory to allocate
    int64_t _1053 = 1;
    _1053 *= _726.d0;
    _1053 *= _726.d0;
    _1053 *= _726.d0;
    _1053 *= sizeof(double);
    _1052.data = jpl_alloc(_1053);
    int64_t _1054 = 0; // t
    int64_t _1055 = 0; // s
    int64_t _1056 = 0; // r
    _jump1897:; // Begin body of loop
    double _1057 = 62.0;
    double _1058 = 71.0;
    double _1059 = _1057 * _1058;
    int64_t _1060 = 0;
    _1060 *= _1052.d0;
    _1060 += _1056;
    _1060 *= _1052.d1;
    _1060 += _1055;
    _1060 *= _1052.d2;
    _1060 += _1054;
    _1052.data[_1060] = _1059;
    _1054++;
    if (_1054 < _726.d0)
    goto _jump1897;
    _1054 = 0;
    _1055++;
    if (_1055 < _726.d0)
    goto _jump1897;
    _1055 = 0;
    _1056++;
    if (_1056 < _726.d0)
    goto _jump1897;
    // End body of loop
    bool _1061 = n(_1052);
    int64_t _1062 = 0;
    _1062 *= _1048.d0;
    _1062 += _1051;
    _1062 *= _1048.d1;
    _1062 += _1050;
    _1048.data[_1062] = _1061;
    _1050++;
    if (_1050 < _345.d0)
    goto _jump1893;
    _1050 = 0;
    _1051++;
    if (_1051 < _345.d2)
    goto _jump1893;
    // End body of loop
    _a3__a1_bool _1063;
    // Computing bound for p
    int64_t _1064 = 431;
    _1063.d0 = _1064;
    if (_1064 > 0) 
    goto _jump1898;
    fail_assertion("non-positive loop bound");
    _jump1898:;
    // Computing bound for q
    _1063.d1 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1899;
    fail_assertion("non-positive loop bound");
    _jump1899:;
    // Computing bound for r
    int64_t _1065 = 881;
    _1063.d2 = _1065;
    if (_1065 > 0) 
    goto _jump1900;
    fail_assertion("non-positive loop bound");
    _jump1900:;
    // Computing total size of heap memory to allocate
    int64_t _1066 = 1;
    _1066 *= _1064;
    _1066 *= _345.d1;
    _1066 *= _1065;
    _1066 *= sizeof(_a1_bool);
    _1063.data = jpl_alloc(_1066);
    int64_t _1067 = 0; // r
    int64_t _1068 = 0; // q
    int64_t _1069 = 0; // p
    _jump1901:; // Begin body of loop
    _a1_bool _1070;
    // Computing bound for s
    _1070.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1902;
    fail_assertion("non-positive loop bound");
    _jump1902:;
    // Computing total size of heap memory to allocate
    int64_t _1071 = 1;
    _1071 *= _345.d2;
    _1071 *= sizeof(bool);
    _1070.data = jpl_alloc(_1071);
    int64_t _1072 = 0; // s
    _jump1903:; // Begin body of loop
    bool _1073 = false;
    int64_t _1074 = 0;
    _1074 *= _1070.d0;
    _1074 += _1072;
    _1070.data[_1074] = _1073;
    _1072++;
    if (_1072 < _345.d2)
    goto _jump1903;
    // End body of loop
    int64_t _1075 = 0;
    _1075 *= _1063.d0;
    _1075 += _1069;
    _1075 *= _1063.d1;
    _1075 += _1068;
    _1075 *= _1063.d2;
    _1075 += _1067;
    _1063.data[_1075] = _1070;
    _1067++;
    if (_1067 < _1065)
    goto _jump1901;
    _1067 = 0;
    _1068++;
    if (_1068 < _345.d1)
    goto _jump1901;
    _1068 = 0;
    _1069++;
    if (_1069 < _1064)
    goto _jump1901;
    // End body of loop
    int64_t _1076 = -_726.d1;
    int64_t _1077 = 956;
    if (_345.d0 >= 0)
    goto _jump1904;
    fail_assertion("negative array index");
    _jump1904:;
    if (_345.d0 < _345.d0)
    goto _jump1905;
    fail_assertion("index too large");
    _jump1905:;
    if (_726.d0 >= 0)
    goto _jump1906;
    fail_assertion("negative array index");
    _jump1906:;
    if (_726.d0 < _345.d1)
    goto _jump1907;
    fail_assertion("index too large");
    _jump1907:;
    if (_1077 >= 0)
    goto _jump1908;
    fail_assertion("negative array index");
    _jump1908:;
    if (_1077 < _345.d2)
    goto _jump1909;
    fail_assertion("index too large");
    _jump1909:;
    int64_t _1078 = 0;
    _1078 *= _345.d0;
    _1078 += _345.d0;
    _1078 *= _345.d1;
    _1078 += _726.d0;
    _1078 *= _345.d2;
    _1078 += _1077;
    int64_t _1079 = _345.data[_1078];
    int64_t _1080 = -_1079;
    if (_726.d0 >= 0)
    goto _jump1910;
    fail_assertion("negative array index");
    _jump1910:;
    if (_726.d0 < _1063.d0)
    goto _jump1911;
    fail_assertion("index too large");
    _jump1911:;
    if (_1076 >= 0)
    goto _jump1912;
    fail_assertion("negative array index");
    _jump1912:;
    if (_1076 < _1063.d1)
    goto _jump1913;
    fail_assertion("index too large");
    _jump1913:;
    if (_1080 >= 0)
    goto _jump1914;
    fail_assertion("negative array index");
    _jump1914:;
    if (_1080 < _1063.d2)
    goto _jump1915;
    fail_assertion("index too large");
    _jump1915:;
    int64_t _1081 = 0;
    _1081 *= _1063.d0;
    _1081 += _726.d0;
    _1081 *= _1063.d1;
    _1081 += _1076;
    _1081 *= _1063.d2;
    _1081 += _1080;
    _a1_bool _1082 = _1063.data[_1081];
    _a3_double _1083;
    // Computing bound for p
    _1083.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1916;
    fail_assertion("non-positive loop bound");
    _jump1916:;
    // Computing bound for q
    _1083.d1 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1917;
    fail_assertion("non-positive loop bound");
    _jump1917:;
    // Computing bound for r
    _1083.d2 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump1918;
    fail_assertion("non-positive loop bound");
    _jump1918:;
    // Computing total size of heap memory to allocate
    int64_t _1084 = 1;
    _1084 *= _345.d2;
    _1084 *= _345.d1;
    _1084 *= _345.d1;
    _1084 *= sizeof(double);
    _1083.data = jpl_alloc(_1084);
    int64_t _1085 = 0; // r
    int64_t _1086 = 0; // q
    int64_t _1087 = 0; // p
    _jump1919:; // Begin body of loop
    double _1088 = 24.0;
    int64_t _1089 = 0;
    _1089 *= _1083.d0;
    _1089 += _1087;
    _1089 *= _1083.d1;
    _1089 += _1086;
    _1089 *= _1083.d2;
    _1089 += _1085;
    _1083.data[_1089] = _1088;
    _1085++;
    if (_1085 < _345.d1)
    goto _jump1919;
    _1085 = 0;
    _1086++;
    if (_1086 < _345.d1)
    goto _jump1919;
    _1086 = 0;
    _1087++;
    if (_1087 < _345.d2)
    goto _jump1919;
    // End body of loop
    bool _1090 = n(_1083);
    bool _1093 = true;
    bool _1092 = _1093;
    if (0 != _1093)
    goto _jump1920;
    bool _1094 = true;
    _1092 = _1094;
    _jump1920:;
    bool _1091 = _1092;
    if (0 == _1092)
    goto _jump1921;
    bool _1095 = false;
    bool _1096 = !_1095;
    _1091 = _1096;
    _jump1921:;
    _a1_bool _1097;
    _1097.d0 = 2;
    _1097.data = jpl_alloc(sizeof(bool) * 2);
    _1097.data[0] = _1090;
    _1097.data[1] = _1091;
    void_t _1098 = b(_1082, _1097);
    int64_t _1099 = a(_1048, _1098);
    if (_345.d1 >= 0)
    goto _jump1922;
    fail_assertion("negative array index");
    _jump1922:;
    if (_345.d1 < _981.d0)
    goto _jump1923;
    fail_assertion("index too large");
    _jump1923:;
    if (_1047 >= 0)
    goto _jump1924;
    fail_assertion("negative array index");
    _jump1924:;
    if (_1047 < _981.d1)
    goto _jump1925;
    fail_assertion("index too large");
    _jump1925:;
    if (_1099 >= 0)
    goto _jump1926;
    fail_assertion("negative array index");
    _jump1926:;
    if (_1099 < _981.d2)
    goto _jump1927;
    fail_assertion("index too large");
    _jump1927:;
    int64_t _1100 = 0;
    _1100 *= _981.d0;
    _1100 += _345.d1;
    _1100 *= _981.d1;
    _1100 += _1047;
    _1100 *= _981.d2;
    _1100 += _1099;
    _a2_int64_t _1101 = _981.data[_1100];
    _980 = _1101;
    goto _jump1928;
    _jump1847:;
    _a2_int64_t _1102;
    // Computing bound for p
    _1102.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1929;
    fail_assertion("non-positive loop bound");
    _jump1929:;
    // Computing bound for q
    _1102.d1 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1930;
    fail_assertion("non-positive loop bound");
    _jump1930:;
    // Computing total size of heap memory to allocate
    int64_t _1103 = 1;
    _1103 *= _726.d1;
    _1103 *= _726.d1;
    _1103 *= sizeof(int64_t);
    _1102.data = jpl_alloc(_1103);
    int64_t _1104 = 0; // q
    int64_t _1105 = 0; // p
    _jump1931:; // Begin body of loop
    _a3_int64_t _1106;
    // Computing bound for r
    _1106.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump1932;
    fail_assertion("non-positive loop bound");
    _jump1932:;
    // Computing bound for s
    _1106.d1 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump1933;
    fail_assertion("non-positive loop bound");
    _jump1933:;
    // Computing bound for t
    int64_t _1107 = 401;
    _1106.d2 = _1107;
    if (_1107 > 0) 
    goto _jump1934;
    fail_assertion("non-positive loop bound");
    _jump1934:;
    // Computing total size of heap memory to allocate
    int64_t _1108 = 1;
    _1108 *= _345.d2;
    _1108 *= _726.d1;
    _1108 *= _1107;
    _1108 *= sizeof(int64_t);
    _1106.data = jpl_alloc(_1108);
    int64_t _1109 = 0; // t
    int64_t _1110 = 0; // s
    int64_t _1111 = 0; // r
    _jump1935:; // Begin body of loop
    int64_t _1112 = 58;
    int64_t _1113 = 0;
    _1113 *= _1106.d0;
    _1113 += _1111;
    _1113 *= _1106.d1;
    _1113 += _1110;
    _1113 *= _1106.d2;
    _1113 += _1109;
    _1106.data[_1113] = _1112;
    _1109++;
    if (_1109 < _1107)
    goto _jump1935;
    _1109 = 0;
    _1110++;
    if (_1110 < _726.d1)
    goto _jump1935;
    _1110 = 0;
    _1111++;
    if (_1111 < _345.d2)
    goto _jump1935;
    // End body of loop
    int64_t _1114 = 116;
    if (_1114 >= 0)
    goto _jump1936;
    fail_assertion("negative array index");
    _jump1936:;
    if (_1114 < _1106.d0)
    goto _jump1937;
    fail_assertion("index too large");
    _jump1937:;
    if (_345.d0 >= 0)
    goto _jump1938;
    fail_assertion("negative array index");
    _jump1938:;
    if (_345.d0 < _1106.d1)
    goto _jump1939;
    fail_assertion("index too large");
    _jump1939:;
    if (_345.d2 >= 0)
    goto _jump1940;
    fail_assertion("negative array index");
    _jump1940:;
    if (_345.d2 < _1106.d2)
    goto _jump1941;
    fail_assertion("index too large");
    _jump1941:;
    int64_t _1115 = 0;
    _1115 *= _1106.d0;
    _1115 += _1114;
    _1115 *= _1106.d1;
    _1115 += _345.d0;
    _1115 *= _1106.d2;
    _1115 += _345.d2;
    int64_t _1116 = _1106.data[_1115];
    _a1_int64_t _1117;
    _1117.d0 = 2;
    _1117.data = jpl_alloc(sizeof(int64_t) * 2);
    _1117.data[0] = _1116;
    _1117.data[1] = _1104;
    if (_345.d1 >= 0)
    goto _jump1942;
    fail_assertion("negative array index");
    _jump1942:;
    if (_345.d1 < _1117.d0)
    goto _jump1943;
    fail_assertion("index too large");
    _jump1943:;
    int64_t _1118 = 0;
    _1118 *= _1117.d0;
    _1118 += _345.d1;
    int64_t _1119 = _1117.data[_1118];
    int64_t _1120 = -_1119;
    int64_t _1121 = 0;
    _1121 *= _1102.d0;
    _1121 += _1105;
    _1121 *= _1102.d1;
    _1121 += _1104;
    _1102.data[_1121] = _1120;
    _1104++;
    if (_1104 < _726.d1)
    goto _jump1931;
    _1104 = 0;
    _1105++;
    if (_1105 < _726.d1)
    goto _jump1931;
    // End body of loop
    _980 = _1102;
    _jump1928:;
    int64_t _1122 = 724;
    if (_1122 >= 0)
    goto _jump2085;
    fail_assertion("negative array index");
    _jump2085:;
    if (_1122 < _219.d0)
    goto _jump2086;
    fail_assertion("index too large");
    _jump2086:;
    int64_t _1123 = 0;
    _1123 *= _219.d0;
    _1123 += _1122;
    double _1124 = _219.data[_1123];
    double _1125 = -_1124;
    bool _1126 = _980.d1 > _345.d1;
    double _1127;
    if (!_1126)
    goto _jump2087;
    double _1128 = 11.0;
    _1127 = _1128;
    goto _jump2088;
    _jump2087:;
    double _1129;
    // Computing bound for w
    int64_t _1130 = 704;
    if (_1130 > 0) 
    goto _jump2089;
    fail_assertion("non-positive loop bound");
    _jump2089:;
    _1129 = 0;
    int64_t _1131 = 0; // w
    _jump2090:; // Begin body of loop
    double _1132 = 90.0;
    _1129 += _1132;
    _1131++;
    if (_1131 < _1130)
    goto _jump2090;
    // End body of loop
    _1127 = _1129;
    _jump2088:;
    if (_980.d0 >= 0)
    goto _jump2091;
    fail_assertion("negative array index");
    _jump2091:;
    if (_980.d0 < _219.d0)
    goto _jump2092;
    fail_assertion("index too large");
    _jump2092:;
    int64_t _1133 = 0;
    _1133 *= _219.d0;
    _1133 += _980.d0;
    double _1134 = _219.data[_1133];
    double _1135 = -_1134;
    double _1136 = _1127 - _1135;
    double _1137 = -_1136;
    double _1138 = -_1137;
    bool _1139 = _1125 <= _1138;
    _a2_rgba _1140;
    if (!_1139)
    goto _jump2093;
    _a2_rgba _1141;
    // Computing bound for w
    _1141.d0 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump2094;
    fail_assertion("non-positive loop bound");
    _jump2094:;
    // Computing bound for x
    int64_t _1142 = 670;
    int64_t _1143 = -_1142;
    _1141.d1 = _1143;
    if (_1143 > 0) 
    goto _jump2095;
    fail_assertion("non-positive loop bound");
    _jump2095:;
    // Computing total size of heap memory to allocate
    int64_t _1144 = 1;
    _1144 *= _726.d0;
    _1144 *= _1143;
    _1144 *= sizeof(rgba);
    _1141.data = jpl_alloc(_1144);
    int64_t _1145 = 0; // x
    int64_t _1146 = 0; // w
    _jump2096:; // Begin body of loop
    _a3_bool _1147;
    // Computing bound for y
    _1147.d0 = _1145;
    if (_1145 > 0) 
    goto _jump2097;
    fail_assertion("non-positive loop bound");
    _jump2097:;
    // Computing bound for z
    int64_t _1148 = _345.d1 - _726.d0;
    int64_t _1149 = -_1148;
    _1147.d1 = _1149;
    if (_1149 > 0) 
    goto _jump2098;
    fail_assertion("non-positive loop bound");
    _jump2098:;
    // Computing bound for A
    _1147.d2 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump2099;
    fail_assertion("non-positive loop bound");
    _jump2099:;
    // Computing total size of heap memory to allocate
    int64_t _1150 = 1;
    _1150 *= _1145;
    _1150 *= _1149;
    _1150 *= _726.d1;
    _1150 *= sizeof(bool);
    _1147.data = jpl_alloc(_1150);
    int64_t _1151 = 0; // A
    int64_t _1152 = 0; // z
    int64_t _1153 = 0; // y
    _jump2100:; // Begin body of loop
    bool _1154 = _980.d1 > _980.d1;
    int64_t _1155 = 0;
    _1155 *= _1147.d0;
    _1155 += _1153;
    _1155 *= _1147.d1;
    _1155 += _1152;
    _1155 *= _1147.d2;
    _1155 += _1151;
    _1147.data[_1155] = _1154;
    _1151++;
    if (_1151 < _726.d1)
    goto _jump2100;
    _1151 = 0;
    _1152++;
    if (_1152 < _1149)
    goto _jump2100;
    _1152 = 0;
    _1153++;
    if (_1153 < _1145)
    goto _jump2100;
    // End body of loop
    int64_t _1156 = 487;
    if (_1156 >= 0)
    goto _jump2101;
    fail_assertion("negative array index");
    _jump2101:;
    if (_1156 < _1147.d0)
    goto _jump2102;
    fail_assertion("index too large");
    _jump2102:;
    if (_726.d1 >= 0)
    goto _jump2103;
    fail_assertion("negative array index");
    _jump2103:;
    if (_726.d1 < _1147.d1)
    goto _jump2104;
    fail_assertion("index too large");
    _jump2104:;
    if (_1146 >= 0)
    goto _jump2105;
    fail_assertion("negative array index");
    _jump2105:;
    if (_1146 < _1147.d2)
    goto _jump2106;
    fail_assertion("index too large");
    _jump2106:;
    int64_t _1157 = 0;
    _1157 *= _1147.d0;
    _1157 += _1156;
    _1157 *= _1147.d1;
    _1157 += _726.d1;
    _1157 *= _1147.d2;
    _1157 += _1146;
    bool _1158 = _1147.data[_1157];
    rgba _1159;
    if (!_1158)
    goto _jump2107;
    _a2__a2_int64_t _1160;
    // Computing bound for y
    _1160.d0 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2108;
    fail_assertion("non-positive loop bound");
    _jump2108:;
    // Computing bound for z
    _1160.d1 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump2109;
    fail_assertion("non-positive loop bound");
    _jump2109:;
    // Computing total size of heap memory to allocate
    int64_t _1161 = 1;
    _1161 *= _980.d1;
    _1161 *= _345.d0;
    _1161 *= sizeof(_a2_int64_t);
    _1160.data = jpl_alloc(_1161);
    int64_t _1162 = 0; // z
    int64_t _1163 = 0; // y
    _jump2110:; // Begin body of loop
    _a1__a2_int64_t _1164;
    // Computing bound for A
    _1164.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump2111;
    fail_assertion("non-positive loop bound");
    _jump2111:;
    // Computing total size of heap memory to allocate
    int64_t _1165 = 1;
    _1165 *= _726.d1;
    _1165 *= sizeof(_a2_int64_t);
    _1164.data = jpl_alloc(_1165);
    int64_t _1166 = 0; // A
    _jump2112:; // Begin body of loop
    int64_t _1167 = 0;
    _1167 *= _1164.d0;
    _1167 += _1166;
    _1164.data[_1167] = _980;
    _1166++;
    if (_1166 < _726.d1)
    goto _jump2112;
    // End body of loop
    if (_1145 >= 0)
    goto _jump2113;
    fail_assertion("negative array index");
    _jump2113:;
    if (_1145 < _1164.d0)
    goto _jump2114;
    fail_assertion("index too large");
    _jump2114:;
    int64_t _1168 = 0;
    _1168 *= _1164.d0;
    _1168 += _1145;
    _a2_int64_t _1169 = _1164.data[_1168];
    int64_t _1170 = 0;
    _1170 *= _1160.d0;
    _1170 += _1163;
    _1170 *= _1160.d1;
    _1170 += _1162;
    _1160.data[_1170] = _1169;
    _1162++;
    if (_1162 < _345.d0)
    goto _jump2110;
    _1162 = 0;
    _1163++;
    if (_1163 < _980.d1)
    goto _jump2110;
    // End body of loop
    _a3_bool _1171;
    // Computing bound for y
    _1171.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2115;
    fail_assertion("non-positive loop bound");
    _jump2115:;
    // Computing bound for z
    _1171.d1 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2116;
    fail_assertion("non-positive loop bound");
    _jump2116:;
    // Computing bound for A
    int64_t _1172 = 692;
    _1171.d2 = _1172;
    if (_1172 > 0) 
    goto _jump2117;
    fail_assertion("non-positive loop bound");
    _jump2117:;
    // Computing total size of heap memory to allocate
    int64_t _1173 = 1;
    _1173 *= _345.d2;
    _1173 *= _980.d1;
    _1173 *= _1172;
    _1173 *= sizeof(bool);
    _1171.data = jpl_alloc(_1173);
    int64_t _1174 = 0; // A
    int64_t _1175 = 0; // z
    int64_t _1176 = 0; // y
    _jump2118:; // Begin body of loop
    bool _1178 = false;
    bool _1177 = _1178;
    if (0 != _1178)
    goto _jump2119;
    bool _1179 = true;
    _1177 = _1179;
    _jump2119:;
    int64_t _1180 = 0;
    _1180 *= _1171.d0;
    _1180 += _1176;
    _1180 *= _1171.d1;
    _1180 += _1175;
    _1180 *= _1171.d2;
    _1180 += _1174;
    _1171.data[_1180] = _1177;
    _1174++;
    if (_1174 < _1172)
    goto _jump2118;
    _1174 = 0;
    _1175++;
    if (_1175 < _980.d1)
    goto _jump2118;
    _1175 = 0;
    _1176++;
    if (_1176 < _345.d2)
    goto _jump2118;
    // End body of loop
    rgba _1181 = m(_1160, _980.d0, _1171);
    _1159 = _1181;
    goto _jump2120;
    _jump2107:;
    _a3_double _1182;
    // Computing bound for y
    int64_t _1183;
    // Computing bound for y
    if (_345.d1 > 0) 
    goto _jump2121;
    fail_assertion("non-positive loop bound");
    _jump2121:;
    _1183 = 0;
    int64_t _1184 = 0; // y
    _jump2122:; // Begin body of loop
    _1183 += _345.d1;
    _1184++;
    if (_1184 < _345.d1)
    goto _jump2122;
    // End body of loop
    _1182.d0 = _1183;
    if (_1183 > 0) 
    goto _jump2123;
    fail_assertion("non-positive loop bound");
    _jump2123:;
    // Computing bound for z
    _1182.d1 = _1146;
    if (_1146 > 0) 
    goto _jump2124;
    fail_assertion("non-positive loop bound");
    _jump2124:;
    // Computing bound for A
    _1182.d2 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump2125;
    fail_assertion("non-positive loop bound");
    _jump2125:;
    // Computing total size of heap memory to allocate
    int64_t _1185 = 1;
    _1185 *= _1183;
    _1185 *= _1146;
    _1185 *= _345.d0;
    _1185 *= sizeof(double);
    _1182.data = jpl_alloc(_1185);
    int64_t _1186 = 0; // A
    int64_t _1187 = 0; // z
    int64_t _1188 = 0; // y
    _jump2126:; // Begin body of loop
    _a3_double _1189;
    // Computing bound for B
    _1189.d0 = _1187;
    if (_1187 > 0) 
    goto _jump2127;
    fail_assertion("non-positive loop bound");
    _jump2127:;
    // Computing bound for C
    _1189.d1 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2128;
    fail_assertion("non-positive loop bound");
    _jump2128:;
    // Computing bound for D
    _1189.d2 = _1145;
    if (_1145 > 0) 
    goto _jump2129;
    fail_assertion("non-positive loop bound");
    _jump2129:;
    // Computing total size of heap memory to allocate
    int64_t _1190 = 1;
    _1190 *= _1187;
    _1190 *= _980.d1;
    _1190 *= _1145;
    _1190 *= sizeof(double);
    _1189.data = jpl_alloc(_1190);
    int64_t _1191 = 0; // D
    int64_t _1192 = 0; // C
    int64_t _1193 = 0; // B
    _jump2130:; // Begin body of loop
    double _1194 = 94.0;
    int64_t _1195 = 0;
    _1195 *= _1189.d0;
    _1195 += _1193;
    _1195 *= _1189.d1;
    _1195 += _1192;
    _1195 *= _1189.d2;
    _1195 += _1191;
    _1189.data[_1195] = _1194;
    _1191++;
    if (_1191 < _1145)
    goto _jump2130;
    _1191 = 0;
    _1192++;
    if (_1192 < _980.d1)
    goto _jump2130;
    _1192 = 0;
    _1193++;
    if (_1193 < _1187)
    goto _jump2130;
    // End body of loop
    int64_t _1196 = _1188 * _1186;
    if (_980.d0 >= 0)
    goto _jump2131;
    fail_assertion("negative array index");
    _jump2131:;
    if (_980.d0 < _1189.d0)
    goto _jump2132;
    fail_assertion("index too large");
    _jump2132:;
    if (_980.d0 >= 0)
    goto _jump2133;
    fail_assertion("negative array index");
    _jump2133:;
    if (_980.d0 < _1189.d1)
    goto _jump2134;
    fail_assertion("index too large");
    _jump2134:;
    if (_1196 >= 0)
    goto _jump2135;
    fail_assertion("negative array index");
    _jump2135:;
    if (_1196 < _1189.d2)
    goto _jump2136;
    fail_assertion("index too large");
    _jump2136:;
    int64_t _1197 = 0;
    _1197 *= _1189.d0;
    _1197 += _980.d0;
    _1197 *= _1189.d1;
    _1197 += _980.d0;
    _1197 *= _1189.d2;
    _1197 += _1196;
    double _1198 = _1189.data[_1197];
    int64_t _1199 = 0;
    _1199 *= _1182.d0;
    _1199 += _1188;
    _1199 *= _1182.d1;
    _1199 += _1187;
    _1199 *= _1182.d2;
    _1199 += _1186;
    _1182.data[_1199] = _1198;
    _1186++;
    if (_1186 < _345.d0)
    goto _jump2126;
    _1186 = 0;
    _1187++;
    if (_1187 < _1146)
    goto _jump2126;
    _1187 = 0;
    _1188++;
    if (_1188 < _1183)
    goto _jump2126;
    // End body of loop
    bool _1200 = _980.d1 != _1146;
    bool _1201 = !_1200;
    bool _1202;
    if (!_1201)
    goto _jump2137;
    bool _1203 = true;
    bool _1204 = !_1203;
    _1202 = _1204;
    goto _jump2138;
    _jump2137:;
    int64_t _1205 = 721;
    bool _1206 = _1205 > _980.d0;
    _1202 = _1206;
    _jump2138:;
    rgba _1207 = o(_1182, _1202, _345.d0);
    _1159 = _1207;
    _jump2120:;
    int64_t _1208 = 0;
    _1208 *= _1141.d0;
    _1208 += _1146;
    _1208 *= _1141.d1;
    _1208 += _1145;
    _1141.data[_1208] = _1159;
    _1145++;
    if (_1145 < _1143)
    goto _jump2096;
    _1145 = 0;
    _1146++;
    if (_1146 < _726.d0)
    goto _jump2096;
    // End body of loop
    _1140 = _1141;
    goto _jump2139;
    _jump2093:;
    _a2_rgba _1209;
    // Computing bound for w
    int64_t _1210 = _345.d1 / _345.d1;
    if (_345.d0 >= 0)
    goto _jump2140;
    fail_assertion("negative array index");
    _jump2140:;
    if (_345.d0 < _345.d0)
    goto _jump2141;
    fail_assertion("index too large");
    _jump2141:;
    if (_1210 >= 0)
    goto _jump2142;
    fail_assertion("negative array index");
    _jump2142:;
    if (_1210 < _345.d1)
    goto _jump2143;
    fail_assertion("index too large");
    _jump2143:;
    if (_345.d2 >= 0)
    goto _jump2144;
    fail_assertion("negative array index");
    _jump2144:;
    if (_345.d2 < _345.d2)
    goto _jump2145;
    fail_assertion("index too large");
    _jump2145:;
    int64_t _1211 = 0;
    _1211 *= _345.d0;
    _1211 += _345.d0;
    _1211 *= _345.d1;
    _1211 += _1210;
    _1211 *= _345.d2;
    _1211 += _345.d2;
    int64_t _1212 = _345.data[_1211];
    _1209.d0 = _1212;
    if (_1212 > 0) 
    goto _jump2146;
    fail_assertion("non-positive loop bound");
    _jump2146:;
    // Computing bound for x
    _1209.d1 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2147;
    fail_assertion("non-positive loop bound");
    _jump2147:;
    // Computing total size of heap memory to allocate
    int64_t _1213 = 1;
    _1213 *= _1212;
    _1213 *= _345.d2;
    _1213 *= sizeof(rgba);
    _1209.data = jpl_alloc(_1213);
    int64_t _1214 = 0; // x
    int64_t _1215 = 0; // w
    _jump2148:; // Begin body of loop
    _a3_double _1216;
    // Computing bound for y
    _1216.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump2149;
    fail_assertion("non-positive loop bound");
    _jump2149:;
    // Computing bound for z
    _1216.d1 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2150;
    fail_assertion("non-positive loop bound");
    _jump2150:;
    // Computing bound for A
    _1216.d2 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    // Computing total size of heap memory to allocate
    int64_t _1217 = 1;
    _1217 *= _726.d1;
    _1217 *= _345.d2;
    _1217 *= _980.d0;
    _1217 *= sizeof(double);
    _1216.data = jpl_alloc(_1217);
    int64_t _1218 = 0; // A
    int64_t _1219 = 0; // z
    int64_t _1220 = 0; // y
    _jump2152:; // Begin body of loop
    double _1221;
    // Computing bound for B
    if (_980.d1 > 0) 
    goto _jump2153;
    fail_assertion("non-positive loop bound");
    _jump2153:;
    // Computing bound for C
    if (_980.d0 > 0) 
    goto _jump2154;
    fail_assertion("non-positive loop bound");
    _jump2154:;
    // Computing bound for D
    if (_345.d2 > 0) 
    goto _jump2155;
    fail_assertion("non-positive loop bound");
    _jump2155:;
    _1221 = 0;
    int64_t _1222 = 0; // D
    int64_t _1223 = 0; // C
    int64_t _1224 = 0; // B
    _jump2156:; // Begin body of loop
    double _1225 = 35.0;
    _1221 += _1225;
    _1222++;
    if (_1222 < _345.d2)
    goto _jump2156;
    _1222 = 0;
    _1223++;
    if (_1223 < _980.d0)
    goto _jump2156;
    _1223 = 0;
    _1224++;
    if (_1224 < _980.d1)
    goto _jump2156;
    // End body of loop
    int64_t _1226 = 0;
    _1226 *= _1216.d0;
    _1226 += _1220;
    _1226 *= _1216.d1;
    _1226 += _1219;
    _1226 *= _1216.d2;
    _1226 += _1218;
    _1216.data[_1226] = _1221;
    _1218++;
    if (_1218 < _980.d0)
    goto _jump2152;
    _1218 = 0;
    _1219++;
    if (_1219 < _345.d2)
    goto _jump2152;
    _1219 = 0;
    _1220++;
    if (_1220 < _726.d1)
    goto _jump2152;
    // End body of loop
    _a2_bool _1227;
    // Computing bound for y
    _1227.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump2157;
    fail_assertion("non-positive loop bound");
    _jump2157:;
    // Computing bound for z
    _1227.d1 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2158;
    fail_assertion("non-positive loop bound");
    _jump2158:;
    // Computing total size of heap memory to allocate
    int64_t _1228 = 1;
    _1228 *= _345.d1;
    _1228 *= _980.d0;
    _1228 *= sizeof(bool);
    _1227.data = jpl_alloc(_1228);
    int64_t _1229 = 0; // z
    int64_t _1230 = 0; // y
    _jump2159:; // Begin body of loop
    bool _1231 = true;
    int64_t _1232 = 0;
    _1232 *= _1227.d0;
    _1232 += _1230;
    _1232 *= _1227.d1;
    _1232 += _1229;
    _1227.data[_1232] = _1231;
    _1229++;
    if (_1229 < _980.d0)
    goto _jump2159;
    _1229 = 0;
    _1230++;
    if (_1230 < _345.d1)
    goto _jump2159;
    // End body of loop
    int64_t _1233 = -_980.d0;
    if (_1233 >= 0)
    goto _jump2160;
    fail_assertion("negative array index");
    _jump2160:;
    if (_1233 < _1227.d0)
    goto _jump2161;
    fail_assertion("index too large");
    _jump2161:;
    if (_345.d0 >= 0)
    goto _jump2162;
    fail_assertion("negative array index");
    _jump2162:;
    if (_345.d0 < _1227.d1)
    goto _jump2163;
    fail_assertion("index too large");
    _jump2163:;
    int64_t _1234 = 0;
    _1234 *= _1227.d0;
    _1234 += _1233;
    _1234 *= _1227.d1;
    _1234 += _345.d0;
    bool _1235 = _1227.data[_1234];
    int64_t _1236 = _980.d0 % _980.d0;
    rgba _1237 = o(_1216, _1235, _1236);
    int64_t _1238 = 0;
    _1238 *= _1209.d0;
    _1238 += _1215;
    _1238 *= _1209.d1;
    _1238 += _1214;
    _1209.data[_1238] = _1237;
    _1214++;
    if (_1214 < _345.d2)
    goto _jump2148;
    _1214 = 0;
    _1215++;
    if (_1215 < _1212)
    goto _jump2148;
    // End body of loop
    _a2_rgba _1239;
    // Computing bound for w
    bool _1240 = false;
    int64_t _1241;
    if (!_1240)
    goto _jump2164;
    _1241 = _726.d1;
    goto _jump2165;
    _jump2164:;
    _1241 = _345.d2;
    _jump2165:;
    int64_t _1242 = -_1241;
    int64_t _1243 = -_1242;
    _1239.d0 = _1243;
    if (_1243 > 0) 
    goto _jump2166;
    fail_assertion("non-positive loop bound");
    _jump2166:;
    // Computing bound for x
    _1239.d1 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump2167;
    fail_assertion("non-positive loop bound");
    _jump2167:;
    // Computing total size of heap memory to allocate
    int64_t _1244 = 1;
    _1244 *= _1243;
    _1244 *= _726.d1;
    _1244 *= sizeof(rgba);
    _1239.data = jpl_alloc(_1244);
    int64_t _1245 = 0; // x
    int64_t _1246 = 0; // w
    _jump2168:; // Begin body of loop
    bool _1248 = _726.d1 < _345.d0;
    bool _1247 = _1248;
    if (0 == _1248)
    goto _jump2169;
    bool _1249 = true;
    _1247 = _1249;
    _jump2169:;
    rgba _1250;
    if (!_1247)
    goto _jump2170;
    _a2__a2_int64_t _1251;
    // Computing bound for y
    int64_t _1252 = 714;
    _1251.d0 = _1252;
    if (_1252 > 0) 
    goto _jump2171;
    fail_assertion("non-positive loop bound");
    _jump2171:;
    // Computing bound for z
    _1251.d1 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump2172;
    fail_assertion("non-positive loop bound");
    _jump2172:;
    // Computing total size of heap memory to allocate
    int64_t _1253 = 1;
    _1253 *= _1252;
    _1253 *= _726.d1;
    _1253 *= sizeof(_a2_int64_t);
    _1251.data = jpl_alloc(_1253);
    int64_t _1254 = 0; // z
    int64_t _1255 = 0; // y
    _jump2173:; // Begin body of loop
    int64_t _1256 = 0;
    _1256 *= _1251.d0;
    _1256 += _1255;
    _1256 *= _1251.d1;
    _1256 += _1254;
    _1251.data[_1256] = _980;
    _1254++;
    if (_1254 < _726.d1)
    goto _jump2173;
    _1254 = 0;
    _1255++;
    if (_1255 < _1252)
    goto _jump2173;
    // End body of loop
    int64_t _1257 = -_345.d1;
    _a3_bool _1258;
    // Computing bound for y
    _1258.d0 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2174;
    fail_assertion("non-positive loop bound");
    _jump2174:;
    // Computing bound for z
    _1258.d1 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump2175;
    fail_assertion("non-positive loop bound");
    _jump2175:;
    // Computing bound for A
    _1258.d2 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2176;
    fail_assertion("non-positive loop bound");
    _jump2176:;
    // Computing total size of heap memory to allocate
    int64_t _1259 = 1;
    _1259 *= _980.d0;
    _1259 *= _345.d1;
    _1259 *= _980.d0;
    _1259 *= sizeof(bool);
    _1258.data = jpl_alloc(_1259);
    int64_t _1260 = 0; // A
    int64_t _1261 = 0; // z
    int64_t _1262 = 0; // y
    _jump2177:; // Begin body of loop
    bool _1263 = true;
    int64_t _1264 = 0;
    _1264 *= _1258.d0;
    _1264 += _1262;
    _1264 *= _1258.d1;
    _1264 += _1261;
    _1264 *= _1258.d2;
    _1264 += _1260;
    _1258.data[_1264] = _1263;
    _1260++;
    if (_1260 < _980.d0)
    goto _jump2177;
    _1260 = 0;
    _1261++;
    if (_1261 < _345.d1)
    goto _jump2177;
    _1261 = 0;
    _1262++;
    if (_1262 < _980.d0)
    goto _jump2177;
    // End body of loop
    rgba _1265 = m(_1251, _1257, _1258);
    _1250 = _1265;
    goto _jump2178;
    _jump2170:;
    _a3_double _1266;
    // Computing bound for y
    _1266.d0 = _1245;
    if (_1245 > 0) 
    goto _jump2179;
    fail_assertion("non-positive loop bound");
    _jump2179:;
    // Computing bound for z
    int64_t _1267 = 1;
    _1266.d1 = _1267;
    if (_1267 > 0) 
    goto _jump2180;
    fail_assertion("non-positive loop bound");
    _jump2180:;
    // Computing bound for A
    _1266.d2 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2181;
    fail_assertion("non-positive loop bound");
    _jump2181:;
    // Computing total size of heap memory to allocate
    int64_t _1268 = 1;
    _1268 *= _1245;
    _1268 *= _1267;
    _1268 *= _980.d0;
    _1268 *= sizeof(double);
    _1266.data = jpl_alloc(_1268);
    int64_t _1269 = 0; // A
    int64_t _1270 = 0; // z
    int64_t _1271 = 0; // y
    _jump2182:; // Begin body of loop
    double _1272 = 3.0;
    int64_t _1273 = 0;
    _1273 *= _1266.d0;
    _1273 += _1271;
    _1273 *= _1266.d1;
    _1273 += _1270;
    _1273 *= _1266.d2;
    _1273 += _1269;
    _1266.data[_1273] = _1272;
    _1269++;
    if (_1269 < _980.d0)
    goto _jump2182;
    _1269 = 0;
    _1270++;
    if (_1270 < _1267)
    goto _jump2182;
    _1270 = 0;
    _1271++;
    if (_1271 < _1245)
    goto _jump2182;
    // End body of loop
    bool _1274 = _980.d1 < _345.d0;
    rgba _1275 = o(_1266, _1274, _980.d1);
    _1250 = _1275;
    _jump2178:;
    int64_t _1276 = 0;
    _1276 *= _1239.d0;
    _1276 += _1246;
    _1276 *= _1239.d1;
    _1276 += _1245;
    _1239.data[_1276] = _1250;
    _1245++;
    if (_1245 < _726.d1)
    goto _jump2168;
    _1245 = 0;
    _1246++;
    if (_1246 < _1243)
    goto _jump2168;
    // End body of loop
    _a1__a2_rgba _1277;
    _1277.d0 = 2;
    _1277.data = jpl_alloc(sizeof(_a2_rgba) * 2);
    _1277.data[0] = _1209;
    _1277.data[1] = _1239;
    int64_t _1278 = 818;
    if (_1278 >= 0)
    goto _jump2183;
    fail_assertion("negative array index");
    _jump2183:;
    if (_1278 < _1277.d0)
    goto _jump2184;
    fail_assertion("index too large");
    _jump2184:;
    int64_t _1279 = 0;
    _1279 *= _1277.d0;
    _1279 += _1278;
    _a2_rgba _1280 = _1277.data[_1279];
    _1140 = _1280;
    _jump2139:;
    write_image(_1140, "w.png");
    double _1281 = 46.0;
    double _1282 = 6.0;
    double _1283 = -_1282;
    double _1284 = -_1283;
    double _1285 = 72.0;
    double _1286 = -_1285;
    double _1287 = 49.0;
    double _1288 = 38.0;
    rgba _1289 = { _1284, _1286, _1287, _1288 };
    double _1290 = _1289.r;
    bool _1291 = _1281 >= _1290;
    bool _1292;
    if (!_1291)
    goto _jump2185;
    bool _1294 = true;
    bool _1293 = _1294;
    if (0 == _1294)
    goto _jump2186;
    double _1295 = 18.0;
    double _1296;
    // Computing bound for w
    int64_t _1297 = 422;
    if (_1297 > 0) 
    goto _jump2187;
    fail_assertion("non-positive loop bound");
    _jump2187:;
    _1296 = 0;
    int64_t _1298 = 0; // w
    _jump2188:; // Begin body of loop
    double _1299 = 93.0;
    _1296 += _1299;
    _1298++;
    if (_1298 < _1297)
    goto _jump2188;
    // End body of loop
    bool _1300 = _1295 == _1296;
    _a3_bool _1301;
    if (!_1300)
    goto _jump2189;
    _a3_bool _1302;
    // Computing bound for w
    _1302.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump2190;
    fail_assertion("non-positive loop bound");
    _jump2190:;
    // Computing bound for x
    _1302.d1 = _726.d0;
    if (_726.d0 > 0) 
    goto _jump2191;
    fail_assertion("non-positive loop bound");
    _jump2191:;
    // Computing bound for y
    if (_726.d0 >= 0)
    goto _jump2192;
    fail_assertion("negative array index");
    _jump2192:;
    if (_726.d0 < _345.d0)
    goto _jump2193;
    fail_assertion("index too large");
    _jump2193:;
    if (_980.d0 >= 0)
    goto _jump2194;
    fail_assertion("negative array index");
    _jump2194:;
    if (_980.d0 < _345.d1)
    goto _jump2195;
    fail_assertion("index too large");
    _jump2195:;
    if (_726.d1 >= 0)
    goto _jump2196;
    fail_assertion("negative array index");
    _jump2196:;
    if (_726.d1 < _345.d2)
    goto _jump2197;
    fail_assertion("index too large");
    _jump2197:;
    int64_t _1303 = 0;
    _1303 *= _345.d0;
    _1303 += _726.d0;
    _1303 *= _345.d1;
    _1303 += _980.d0;
    _1303 *= _345.d2;
    _1303 += _726.d1;
    int64_t _1304 = _345.data[_1303];
    _1302.d2 = _1304;
    if (_1304 > 0) 
    goto _jump2198;
    fail_assertion("non-positive loop bound");
    _jump2198:;
    // Computing total size of heap memory to allocate
    int64_t _1305 = 1;
    _1305 *= _345.d1;
    _1305 *= _726.d0;
    _1305 *= _1304;
    _1305 *= sizeof(bool);
    _1302.data = jpl_alloc(_1305);
    int64_t _1306 = 0; // y
    int64_t _1307 = 0; // x
    int64_t _1308 = 0; // w
    _jump2199:; // Begin body of loop
    bool _1309 = _345.d0 != _726.d0;
    int64_t _1310 = 0;
    _1310 *= _1302.d0;
    _1310 += _1308;
    _1310 *= _1302.d1;
    _1310 += _1307;
    _1310 *= _1302.d2;
    _1310 += _1306;
    _1302.data[_1310] = _1309;
    _1306++;
    if (_1306 < _1304)
    goto _jump2199;
    _1306 = 0;
    _1307++;
    if (_1307 < _726.d0)
    goto _jump2199;
    _1307 = 0;
    _1308++;
    if (_1308 < _345.d1)
    goto _jump2199;
    // End body of loop
    _1301 = _1302;
    goto _jump2200;
    _jump2189:;
    _a3_bool _1311;
    // Computing bound for w
    _1311.d0 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2201;
    fail_assertion("non-positive loop bound");
    _jump2201:;
    // Computing bound for x
    _1311.d1 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2202;
    fail_assertion("non-positive loop bound");
    _jump2202:;
    // Computing bound for y
    _1311.d2 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2203;
    fail_assertion("non-positive loop bound");
    _jump2203:;
    // Computing total size of heap memory to allocate
    int64_t _1312 = 1;
    _1312 *= _980.d0;
    _1312 *= _980.d1;
    _1312 *= _345.d2;
    _1312 *= sizeof(bool);
    _1311.data = jpl_alloc(_1312);
    int64_t _1313 = 0; // y
    int64_t _1314 = 0; // x
    int64_t _1315 = 0; // w
    _jump2204:; // Begin body of loop
    bool _1316 = _345.d1 >= _726.d0;
    int64_t _1317 = 0;
    _1317 *= _1311.d0;
    _1317 += _1315;
    _1317 *= _1311.d1;
    _1317 += _1314;
    _1317 *= _1311.d2;
    _1317 += _1313;
    _1311.data[_1317] = _1316;
    _1313++;
    if (_1313 < _345.d2)
    goto _jump2204;
    _1313 = 0;
    _1314++;
    if (_1314 < _980.d1)
    goto _jump2204;
    _1314 = 0;
    _1315++;
    if (_1315 < _980.d0)
    goto _jump2204;
    // End body of loop
    _1301 = _1311;
    _jump2200:;
    int64_t _1318 = -_726.d1;
    bool _1319 = _1318 < _980.d1;
    int64_t _1320;
    if (!_1319)
    goto _jump2205;
    _1320 = _345.d2;
    goto _jump2206;
    _jump2205:;
    int64_t _1321;
    // Computing bound for w
    bool _1322 = false;
    int64_t _1323;
    if (!_1322)
    goto _jump2207;
    _1323 = _345.d0;
    goto _jump2208;
    _jump2207:;
    _1323 = _345.d2;
    _jump2208:;
    if (_1323 > 0) 
    goto _jump2209;
    fail_assertion("non-positive loop bound");
    _jump2209:;
    _1321 = 0;
    int64_t _1324 = 0; // w
    _jump2210:; // Begin body of loop
    _1321 += _726.d1;
    _1324++;
    if (_1324 < _1323)
    goto _jump2210;
    // End body of loop
    _1320 = _1321;
    _jump2206:;
    if (_345.d2 >= 0)
    goto _jump2211;
    fail_assertion("negative array index");
    _jump2211:;
    if (_345.d2 < _1301.d0)
    goto _jump2212;
    fail_assertion("index too large");
    _jump2212:;
    if (_1320 >= 0)
    goto _jump2213;
    fail_assertion("negative array index");
    _jump2213:;
    if (_1320 < _1301.d1)
    goto _jump2214;
    fail_assertion("index too large");
    _jump2214:;
    if (_980.d0 >= 0)
    goto _jump2215;
    fail_assertion("negative array index");
    _jump2215:;
    if (_980.d0 < _1301.d2)
    goto _jump2216;
    fail_assertion("index too large");
    _jump2216:;
    int64_t _1325 = 0;
    _1325 *= _1301.d0;
    _1325 += _345.d2;
    _1325 *= _1301.d1;
    _1325 += _1320;
    _1325 *= _1301.d2;
    _1325 += _980.d0;
    bool _1326 = _1301.data[_1325];
    _1293 = _1326;
    _jump2186:;
    _1292 = _1293;
    goto _jump2217;
    _jump2185:;
    _a1_bool _1328;
    // Computing bound for w
    _1328.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump2218;
    fail_assertion("non-positive loop bound");
    _jump2218:;
    // Computing total size of heap memory to allocate
    int64_t _1329 = 1;
    _1329 *= _345.d1;
    _1329 *= sizeof(bool);
    _1328.data = jpl_alloc(_1329);
    int64_t _1330 = 0; // w
    _jump2219:; // Begin body of loop
    bool _1331 = true;
    int64_t _1332 = 0;
    _1332 *= _1328.d0;
    _1332 += _1330;
    _1328.data[_1332] = _1331;
    _1330++;
    if (_1330 < _345.d1)
    goto _jump2219;
    // End body of loop
    if (_345.d2 >= 0)
    goto _jump2220;
    fail_assertion("negative array index");
    _jump2220:;
    if (_345.d2 < _1328.d0)
    goto _jump2221;
    fail_assertion("index too large");
    _jump2221:;
    int64_t _1333 = 0;
    _1333 *= _1328.d0;
    _1333 += _345.d2;
    bool _1334 = _1328.data[_1333];
    _a2_bool _1335;
    if (!_1334)
    goto _jump2222;
    _a2_bool _1336;
    // Computing bound for w
    _1336.d0 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump2223;
    fail_assertion("non-positive loop bound");
    _jump2223:;
    // Computing bound for x
    _1336.d1 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2224;
    fail_assertion("non-positive loop bound");
    _jump2224:;
    // Computing total size of heap memory to allocate
    int64_t _1337 = 1;
    _1337 *= _345.d0;
    _1337 *= _980.d0;
    _1337 *= sizeof(bool);
    _1336.data = jpl_alloc(_1337);
    int64_t _1338 = 0; // x
    int64_t _1339 = 0; // w
    _jump2225:; // Begin body of loop
    bool _1340 = true;
    int64_t _1341 = 0;
    _1341 *= _1336.d0;
    _1341 += _1339;
    _1341 *= _1336.d1;
    _1341 += _1338;
    _1336.data[_1341] = _1340;
    _1338++;
    if (_1338 < _980.d0)
    goto _jump2225;
    _1338 = 0;
    _1339++;
    if (_1339 < _345.d0)
    goto _jump2225;
    // End body of loop
    _1335 = _1336;
    goto _jump2226;
    _jump2222:;
    _a2_bool _1342;
    // Computing bound for w
    _1342.d0 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2227;
    fail_assertion("non-positive loop bound");
    _jump2227:;
    // Computing bound for x
    int64_t _1343 = 817;
    _1342.d1 = _1343;
    if (_1343 > 0) 
    goto _jump2228;
    fail_assertion("non-positive loop bound");
    _jump2228:;
    // Computing total size of heap memory to allocate
    int64_t _1344 = 1;
    _1344 *= _980.d1;
    _1344 *= _1343;
    _1344 *= sizeof(bool);
    _1342.data = jpl_alloc(_1344);
    int64_t _1345 = 0; // x
    int64_t _1346 = 0; // w
    _jump2229:; // Begin body of loop
    bool _1347 = false;
    bool _1348 = !_1347;
    int64_t _1349 = 0;
    _1349 *= _1342.d0;
    _1349 += _1346;
    _1349 *= _1342.d1;
    _1349 += _1345;
    _1342.data[_1349] = _1348;
    _1345++;
    if (_1345 < _1343)
    goto _jump2229;
    _1345 = 0;
    _1346++;
    if (_1346 < _980.d1)
    goto _jump2229;
    // End body of loop
    _1335 = _1342;
    _jump2226:;
    int64_t _1350 = -_726.d0;
    if (_1350 >= 0)
    goto _jump2230;
    fail_assertion("negative array index");
    _jump2230:;
    if (_1350 < _1335.d0)
    goto _jump2231;
    fail_assertion("index too large");
    _jump2231:;
    if (_345.d0 >= 0)
    goto _jump2232;
    fail_assertion("negative array index");
    _jump2232:;
    if (_345.d0 < _1335.d1)
    goto _jump2233;
    fail_assertion("index too large");
    _jump2233:;
    int64_t _1351 = 0;
    _1351 *= _1335.d0;
    _1351 += _1350;
    _1351 *= _1335.d1;
    _1351 += _345.d0;
    bool _1352 = _1335.data[_1351];
    bool _1327 = _1352;
    if (0 != _1352)
    goto _jump2234;
    int64_t _1353;
    // Computing bound for w
    int64_t _1354 = 62;
    if (_1354 > 0) 
    goto _jump2235;
    fail_assertion("non-positive loop bound");
    _jump2235:;
    // Computing bound for x
    if (_980.d1 > 0) 
    goto _jump2236;
    fail_assertion("non-positive loop bound");
    _jump2236:;
    // Computing bound for y
    if (_345.d0 > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    _1353 = 0;
    int64_t _1355 = 0; // y
    int64_t _1356 = 0; // x
    int64_t _1357 = 0; // w
    _jump2238:; // Begin body of loop
    _1353 += _726.d1;
    _1355++;
    if (_1355 < _345.d0)
    goto _jump2238;
    _1355 = 0;
    _1356++;
    if (_1356 < _980.d1)
    goto _jump2238;
    _1356 = 0;
    _1357++;
    if (_1357 < _1354)
    goto _jump2238;
    // End body of loop
    bool _1358 = _726.d0 != _1353;
    double _1359;
    if (!_1358)
    goto _jump2239;
    if (_726.d0 >= 0)
    goto _jump2240;
    fail_assertion("negative array index");
    _jump2240:;
    if (_726.d0 < _219.d0)
    goto _jump2241;
    fail_assertion("index too large");
    _jump2241:;
    int64_t _1360 = 0;
    _1360 *= _219.d0;
    _1360 += _726.d0;
    double _1361 = _219.data[_1360];
    _1359 = _1361;
    goto _jump2242;
    _jump2239:;
    double _1362 = 44.0;
    _1359 = _1362;
    _jump2242:;
    _a3_double _1363;
    // Computing bound for w
    int64_t _1364 = 353;
    _1363.d0 = _1364;
    if (_1364 > 0) 
    goto _jump2243;
    fail_assertion("non-positive loop bound");
    _jump2243:;
    // Computing bound for x
    _1363.d1 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump2244;
    fail_assertion("non-positive loop bound");
    _jump2244:;
    // Computing bound for y
    _1363.d2 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2245;
    fail_assertion("non-positive loop bound");
    _jump2245:;
    // Computing total size of heap memory to allocate
    int64_t _1365 = 1;
    _1365 *= _1364;
    _1365 *= _980.d0;
    _1365 *= _980.d1;
    _1365 *= sizeof(double);
    _1363.data = jpl_alloc(_1365);
    int64_t _1366 = 0; // y
    int64_t _1367 = 0; // x
    int64_t _1368 = 0; // w
    _jump2246:; // Begin body of loop
    double _1369 = 58.0;
    double _1370 = -_1369;
    int64_t _1371 = 0;
    _1371 *= _1363.d0;
    _1371 += _1368;
    _1371 *= _1363.d1;
    _1371 += _1367;
    _1371 *= _1363.d2;
    _1371 += _1366;
    _1363.data[_1371] = _1370;
    _1366++;
    if (_1366 < _980.d1)
    goto _jump2246;
    _1366 = 0;
    _1367++;
    if (_1367 < _980.d0)
    goto _jump2246;
    _1367 = 0;
    _1368++;
    if (_1368 < _1364)
    goto _jump2246;
    // End body of loop
    bool _1372 = _980.d0 == _980.d0;
    double _1373 = s(_1363, _1372, _980);
    bool _1374 = _1359 > _1373;
    _1327 = _1374;
    _jump2234:;
    _1292 = _1327;
    _jump2217:;
    _a1_double _1375;
    if (!_1292)
    goto _jump2247;
    bool _1376 = false;
    bool _1377 = !_1376;
    bool _1378;
    if (!_1377)
    goto _jump2248;
    bool _1379 = false;
    bool _1380 = !_1379;
    _1378 = _1380;
    goto _jump2249;
    _jump2248:;
    bool _1381 = true;
    _1378 = _1381;
    _jump2249:;
    _a1__a1__a1_double _1382;
    if (!_1378)
    goto _jump2250;
    bool _1383 = true;
    _a1__a1__a1_double _1384;
    if (!_1383)
    goto _jump2251;
    _a1__a1_double _1385;
    // Computing bound for w
    _1385.d0 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2252;
    fail_assertion("non-positive loop bound");
    _jump2252:;
    // Computing total size of heap memory to allocate
    int64_t _1386 = 1;
    _1386 *= _345.d2;
    _1386 *= sizeof(_a1_double);
    _1385.data = jpl_alloc(_1386);
    int64_t _1387 = 0; // w
    _jump2253:; // Begin body of loop
    int64_t _1388 = 0;
    _1388 *= _1385.d0;
    _1388 += _1387;
    _1385.data[_1388] = _284;
    _1387++;
    if (_1387 < _345.d2)
    goto _jump2253;
    // End body of loop
    _a1__a1__a1_double _1389;
    _1389.d0 = 1;
    _1389.data = jpl_alloc(sizeof(_a1__a1_double) * 1);
    _1389.data[0] = _1385;
    _1384 = _1389;
    goto _jump2254;
    _jump2251:;
    _a1__a1__a1_double _1390;
    // Computing bound for w
    int64_t _1391 = 210;
    _1390.d0 = _1391;
    if (_1391 > 0) 
    goto _jump2255;
    fail_assertion("non-positive loop bound");
    _jump2255:;
    // Computing total size of heap memory to allocate
    int64_t _1392 = 1;
    _1392 *= _1391;
    _1392 *= sizeof(_a1__a1_double);
    _1390.data = jpl_alloc(_1392);
    int64_t _1393 = 0; // w
    _jump2256:; // Begin body of loop
    _a1__a1_double _1394;
    // Computing bound for x
    _1394.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump2257;
    fail_assertion("non-positive loop bound");
    _jump2257:;
    // Computing total size of heap memory to allocate
    int64_t _1395 = 1;
    _1395 *= _345.d1;
    _1395 *= sizeof(_a1_double);
    _1394.data = jpl_alloc(_1395);
    int64_t _1396 = 0; // x
    _jump2258:; // Begin body of loop
    int64_t _1397 = 0;
    _1397 *= _1394.d0;
    _1397 += _1396;
    _1394.data[_1397] = _219;
    _1396++;
    if (_1396 < _345.d1)
    goto _jump2258;
    // End body of loop
    int64_t _1398 = 0;
    _1398 *= _1390.d0;
    _1398 += _1393;
    _1390.data[_1398] = _1394;
    _1393++;
    if (_1393 < _1391)
    goto _jump2256;
    // End body of loop
    _1384 = _1390;
    _jump2254:;
    _1382 = _1384;
    goto _jump2259;
    _jump2250:;
    _a1__a1__a1_double _1399;
    // Computing bound for w
    int64_t _1400 = 68;
    _1399.d0 = _1400;
    if (_1400 > 0) 
    goto _jump2260;
    fail_assertion("non-positive loop bound");
    _jump2260:;
    // Computing total size of heap memory to allocate
    int64_t _1401 = 1;
    _1401 *= _1400;
    _1401 *= sizeof(_a1__a1_double);
    _1399.data = jpl_alloc(_1401);
    int64_t _1402 = 0; // w
    _jump2261:; // Begin body of loop
    double _1403 = 47.0;
    double _1404 = 82.0;
    double _1405 = 63.0;
    _a1_double _1406;
    _1406.d0 = 3;
    _1406.data = jpl_alloc(sizeof(double) * 3);
    _1406.data[0] = _1403;
    _1406.data[1] = _1404;
    _1406.data[2] = _1405;
    _a1__a1_double _1407;
    _1407.d0 = 3;
    _1407.data = jpl_alloc(sizeof(_a1_double) * 3);
    _1407.data[0] = _284;
    _1407.data[1] = _284;
    _1407.data[2] = _1406;
    int64_t _1408 = 0;
    _1408 *= _1399.d0;
    _1408 += _1402;
    _1399.data[_1408] = _1407;
    _1402++;
    if (_1402 < _1400)
    goto _jump2261;
    // End body of loop
    _1382 = _1399;
    _jump2259:;
    if (_980.d0 >= 0)
    goto _jump2262;
    fail_assertion("negative array index");
    _jump2262:;
    if (_980.d0 < _1382.d0)
    goto _jump2263;
    fail_assertion("index too large");
    _jump2263:;
    int64_t _1409 = 0;
    _1409 *= _1382.d0;
    _1409 += _980.d0;
    _a1__a1_double _1410 = _1382.data[_1409];
    if (_726.d1 >= 0)
    goto _jump2264;
    fail_assertion("negative array index");
    _jump2264:;
    if (_726.d1 < _1410.d0)
    goto _jump2265;
    fail_assertion("index too large");
    _jump2265:;
    int64_t _1411 = 0;
    _1411 *= _1410.d0;
    _1411 += _726.d1;
    _a1_double _1412 = _1410.data[_1411];
    _1375 = _1412;
    goto _jump2266;
    _jump2247:;
    _a1_double _1413;
    // Computing bound for w
    int64_t _1414 = 247;
    _1413.d0 = _1414;
    if (_1414 > 0) 
    goto _jump2267;
    fail_assertion("non-positive loop bound");
    _jump2267:;
    // Computing total size of heap memory to allocate
    int64_t _1415 = 1;
    _1415 *= _1414;
    _1415 *= sizeof(double);
    _1413.data = jpl_alloc(_1415);
    int64_t _1416 = 0; // w
    _jump2268:; // Begin body of loop
    _a2__a2_int64_t _1417;
    // Computing bound for x
    _1417.d0 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2269;
    fail_assertion("non-positive loop bound");
    _jump2269:;
    // Computing bound for y
    _1417.d1 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump2270;
    fail_assertion("non-positive loop bound");
    _jump2270:;
    // Computing total size of heap memory to allocate
    int64_t _1418 = 1;
    _1418 *= _980.d1;
    _1418 *= _345.d0;
    _1418 *= sizeof(_a2_int64_t);
    _1417.data = jpl_alloc(_1418);
    int64_t _1419 = 0; // y
    int64_t _1420 = 0; // x
    _jump2271:; // Begin body of loop
    int64_t _1421 = 0;
    _1421 *= _1417.d0;
    _1421 += _1420;
    _1421 *= _1417.d1;
    _1421 += _1419;
    _1417.data[_1421] = _980;
    _1419++;
    if (_1419 < _345.d0)
    goto _jump2271;
    _1419 = 0;
    _1420++;
    if (_1420 < _980.d1)
    goto _jump2271;
    // End body of loop
    _a3_bool _1422;
    // Computing bound for x
    int64_t _1423 = 920;
    _1422.d0 = _1423;
    if (_1423 > 0) 
    goto _jump2272;
    fail_assertion("non-positive loop bound");
    _jump2272:;
    // Computing bound for y
    _1422.d1 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2273;
    fail_assertion("non-positive loop bound");
    _jump2273:;
    // Computing bound for z
    _1422.d2 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump2274;
    fail_assertion("non-positive loop bound");
    _jump2274:;
    // Computing total size of heap memory to allocate
    int64_t _1424 = 1;
    _1424 *= _1423;
    _1424 *= _345.d2;
    _1424 *= _345.d2;
    _1424 *= sizeof(bool);
    _1422.data = jpl_alloc(_1424);
    int64_t _1425 = 0; // z
    int64_t _1426 = 0; // y
    int64_t _1427 = 0; // x
    _jump2275:; // Begin body of loop
    bool _1428 = true;
    int64_t _1429 = 0;
    _1429 *= _1422.d0;
    _1429 += _1427;
    _1429 *= _1422.d1;
    _1429 += _1426;
    _1429 *= _1422.d2;
    _1429 += _1425;
    _1422.data[_1429] = _1428;
    _1425++;
    if (_1425 < _345.d2)
    goto _jump2275;
    _1425 = 0;
    _1426++;
    if (_1426 < _345.d2)
    goto _jump2275;
    _1426 = 0;
    _1427++;
    if (_1427 < _1423)
    goto _jump2275;
    // End body of loop
    rgba _1430 = m(_1417, _980.d1, _1422);
    double _1431 = _1430.g;
    double _1432 = 85.0;
    double _1433 = -_1432;
    if (_345.d0 >= 0)
    goto _jump2276;
    fail_assertion("negative array index");
    _jump2276:;
    if (_345.d0 < _219.d0)
    goto _jump2277;
    fail_assertion("index too large");
    _jump2277:;
    int64_t _1434 = 0;
    _1434 *= _219.d0;
    _1434 += _345.d0;
    double _1435 = _219.data[_1434];
    double _1436 = _1433 / _1435;
    double _1437 = -_1436;
    _a3_double _1438;
    // Computing bound for x
    _1438.d0 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2278;
    fail_assertion("non-positive loop bound");
    _jump2278:;
    // Computing bound for y
    _1438.d1 = _345.d0;
    if (_345.d0 > 0) 
    goto _jump2279;
    fail_assertion("non-positive loop bound");
    _jump2279:;
    // Computing bound for z
    _1438.d2 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump2280;
    fail_assertion("non-positive loop bound");
    _jump2280:;
    // Computing total size of heap memory to allocate
    int64_t _1439 = 1;
    _1439 *= _980.d1;
    _1439 *= _345.d0;
    _1439 *= _980.d1;
    _1439 *= sizeof(double);
    _1438.data = jpl_alloc(_1439);
    int64_t _1440 = 0; // z
    int64_t _1441 = 0; // y
    int64_t _1442 = 0; // x
    _jump2281:; // Begin body of loop
    double _1443 = 52.0;
    int64_t _1444 = 0;
    _1444 *= _1438.d0;
    _1444 += _1442;
    _1444 *= _1438.d1;
    _1444 += _1441;
    _1444 *= _1438.d2;
    _1444 += _1440;
    _1438.data[_1444] = _1443;
    _1440++;
    if (_1440 < _980.d1)
    goto _jump2281;
    _1440 = 0;
    _1441++;
    if (_1441 < _345.d0)
    goto _jump2281;
    _1441 = 0;
    _1442++;
    if (_1442 < _980.d1)
    goto _jump2281;
    // End body of loop
    bool _1445 = false;
    int64_t _1446;
    if (!_1445)
    goto _jump2282;
    _1446 = _980.d0;
    goto _jump2283;
    _jump2282:;
    _1446 = _726.d0;
    _jump2283:;
    if (_980.d0 >= 0)
    goto _jump2284;
    fail_assertion("negative array index");
    _jump2284:;
    if (_980.d0 < _726.d0)
    goto _jump2285;
    fail_assertion("index too large");
    _jump2285:;
    if (_726.d0 >= 0)
    goto _jump2286;
    fail_assertion("negative array index");
    _jump2286:;
    if (_726.d0 < _726.d1)
    goto _jump2287;
    fail_assertion("index too large");
    _jump2287:;
    int64_t _1447 = 0;
    _1447 *= _726.d0;
    _1447 += _980.d0;
    _1447 *= _726.d1;
    _1447 += _726.d0;
    int64_t _1448 = _726.data[_1447];
    bool _1449 = _1446 < _1448;
    double _1450 = s(_1438, _1449, _980);
    double _1451 = _1437 * _1450;
    double _1452 = _1431 * _1451;
    int64_t _1453 = 0;
    _1453 *= _1413.d0;
    _1453 += _1416;
    _1413.data[_1453] = _1452;
    _1416++;
    if (_1416 < _1414)
    goto _jump2268;
    // End body of loop
    _1375 = _1413;
    _jump2266:;
    double _1454 = 28.0;
    double _1455;
    // Computing bound for A
    int64_t _1456 = 142;
    int64_t _1457 = -_1456;
    if (_1457 > 0) 
    goto _jump3190;
    fail_assertion("non-positive loop bound");
    _jump3190:;
    // Computing bound for B
    if (_726.d1 > 0) 
    goto _jump3191;
    fail_assertion("non-positive loop bound");
    _jump3191:;
    // Computing bound for C
    if (_726.d0 > 0) 
    goto _jump3192;
    fail_assertion("non-positive loop bound");
    _jump3192:;
    _1455 = 0;
    int64_t _1458 = 0; // C
    int64_t _1459 = 0; // B
    int64_t _1460 = 0; // A
    _jump3193:; // Begin body of loop
    _a2_double _1461;
    // Computing bound for D
    int64_t _1462 = 824;
    int64_t _1463 = _1462 / _980.d0;
    _1461.d0 = _1463;
    if (_1463 > 0) 
    goto _jump3194;
    fail_assertion("non-positive loop bound");
    _jump3194:;
    // Computing bound for E
    _1461.d1 = _980.d0;
    if (_980.d0 > 0) 
    goto _jump3195;
    fail_assertion("non-positive loop bound");
    _jump3195:;
    // Computing total size of heap memory to allocate
    int64_t _1464 = 1;
    _1464 *= _1463;
    _1464 *= _980.d0;
    _1464 *= sizeof(double);
    _1461.data = jpl_alloc(_1464);
    int64_t _1465 = 0; // E
    int64_t _1466 = 0; // D
    _jump3196:; // Begin body of loop
    double _1467 = 52.0;
    double _1468 = -_1467;
    int64_t _1469 = 0;
    _1469 *= _1461.d0;
    _1469 += _1466;
    _1469 *= _1461.d1;
    _1469 += _1465;
    _1461.data[_1469] = _1468;
    _1465++;
    if (_1465 < _980.d0)
    goto _jump3196;
    _1465 = 0;
    _1466++;
    if (_1466 < _1463)
    goto _jump3196;
    // End body of loop
    int64_t _1470 = _1458 / _980.d1;
    if (_1470 >= 0)
    goto _jump3197;
    fail_assertion("negative array index");
    _jump3197:;
    if (_1470 < _1461.d0)
    goto _jump3198;
    fail_assertion("index too large");
    _jump3198:;
    if (_726.d0 >= 0)
    goto _jump3199;
    fail_assertion("negative array index");
    _jump3199:;
    if (_726.d0 < _1461.d1)
    goto _jump3200;
    fail_assertion("index too large");
    _jump3200:;
    int64_t _1471 = 0;
    _1471 *= _1461.d0;
    _1471 += _1470;
    _1471 *= _1461.d1;
    _1471 += _726.d0;
    double _1472 = _1461.data[_1471];
    _1455 += _1472;
    _1458++;
    if (_1458 < _726.d0)
    goto _jump3193;
    _1458 = 0;
    _1459++;
    if (_1459 < _726.d1)
    goto _jump3193;
    _1459 = 0;
    _1460++;
    if (_1460 < _1457)
    goto _jump3193;
    // End body of loop
    double _1473 = 35.0;
    double _1474 = -_1473;
    _a2__a2_bool _1475;
    // Computing bound for A
    int64_t _1476 = -_980.d1;
    _1475.d0 = _1476;
    if (_1476 > 0) 
    goto _jump3201;
    fail_assertion("non-positive loop bound");
    _jump3201:;
    // Computing bound for B
    bool _1477 = false;
    int64_t _1478;
    if (!_1477)
    goto _jump3202;
    _1478 = _726.d1;
    goto _jump3203;
    _jump3202:;
    _1478 = _726.d0;
    _jump3203:;
    _1475.d1 = _1478;
    if (_1478 > 0) 
    goto _jump3204;
    fail_assertion("non-positive loop bound");
    _jump3204:;
    // Computing total size of heap memory to allocate
    int64_t _1479 = 1;
    _1479 *= _1476;
    _1479 *= _1478;
    _1479 *= sizeof(_a2_bool);
    _1475.data = jpl_alloc(_1479);
    int64_t _1480 = 0; // B
    int64_t _1481 = 0; // A
    _jump3205:; // Begin body of loop
    _a2_bool _1482;
    // Computing bound for C
    _1482.d0 = _345.d1;
    if (_345.d1 > 0) 
    goto _jump3206;
    fail_assertion("non-positive loop bound");
    _jump3206:;
    // Computing bound for D
    _1482.d1 = _345.d2;
    if (_345.d2 > 0) 
    goto _jump3207;
    fail_assertion("non-positive loop bound");
    _jump3207:;
    // Computing total size of heap memory to allocate
    int64_t _1483 = 1;
    _1483 *= _345.d1;
    _1483 *= _345.d2;
    _1483 *= sizeof(bool);
    _1482.data = jpl_alloc(_1483);
    int64_t _1484 = 0; // D
    int64_t _1485 = 0; // C
    _jump3208:; // Begin body of loop
    bool _1486 = false;
    bool _1487 = !_1486;
    int64_t _1488 = 0;
    _1488 *= _1482.d0;
    _1488 += _1485;
    _1488 *= _1482.d1;
    _1488 += _1484;
    _1482.data[_1488] = _1487;
    _1484++;
    if (_1484 < _345.d2)
    goto _jump3208;
    _1484 = 0;
    _1485++;
    if (_1485 < _345.d1)
    goto _jump3208;
    // End body of loop
    int64_t _1489 = 0;
    _1489 *= _1475.d0;
    _1489 += _1481;
    _1489 *= _1475.d1;
    _1489 += _1480;
    _1475.data[_1489] = _1482;
    _1480++;
    if (_1480 < _1478)
    goto _jump3205;
    _1480 = 0;
    _1481++;
    if (_1481 < _1476)
    goto _jump3205;
    // End body of loop
    if (_726.d1 >= 0)
    goto _jump3209;
    fail_assertion("negative array index");
    _jump3209:;
    if (_726.d1 < _1475.d0)
    goto _jump3210;
    fail_assertion("index too large");
    _jump3210:;
    if (_345.d1 >= 0)
    goto _jump3211;
    fail_assertion("negative array index");
    _jump3211:;
    if (_345.d1 < _1475.d1)
    goto _jump3212;
    fail_assertion("index too large");
    _jump3212:;
    int64_t _1490 = 0;
    _1490 *= _1475.d0;
    _1490 += _726.d1;
    _1490 *= _1475.d1;
    _1490 += _345.d1;
    _a2_bool _1491 = _1475.data[_1490];
    rgba _1492 = y(_1491);
    double _1493 = _1492.a;
    rgba _1494 = { _1454, _1455, _1474, _1493 };
    _a2_int64_t _1495;
    // Computing bound for D
    _1495.d0 = _726.d1;
    if (_726.d1 > 0) 
    goto _jump3526;
    fail_assertion("non-positive loop bound");
    _jump3526:;
    // Computing bound for E
    _1495.d1 = _980.d1;
    if (_980.d1 > 0) 
    goto _jump3527;
    fail_assertion("non-positive loop bound");
    _jump3527:;
    // Computing total size of heap memory to allocate
    int64_t _1496 = 1;
    _1496 *= _726.d1;
    _1496 *= _980.d1;
    _1496 *= sizeof(int64_t);
    _1495.data = jpl_alloc(_1496);
    int64_t _1497 = 0; // E
    int64_t _1498 = 0; // D
    _jump3528:; // Begin body of loop
    int64_t _1499;
    // Computing bound for F
    int64_t _1500 = _980.d1 + _345.d0;
    if (_1500 > 0) 
    goto _jump3529;
    fail_assertion("non-positive loop bound");
    _jump3529:;
    // Computing bound for G
    bool _1502 = _1498 < _980.d0;
    bool _1501 = _1502;
    if (0 == _1502)
    goto _jump3530;
    bool _1503 = false;
    _1501 = _1503;
    _jump3530:;
    bool _1504 = !_1501;
    int64_t _1505;
    if (!_1504)
    goto _jump3531;
    _1505 = _345.d1;
    goto _jump3532;
    _jump3531:;
    int64_t _1506;
    // Computing bound for F
    if (_1375.d0 > 0) 
    goto _jump3533;
    fail_assertion("non-positive loop bound");
    _jump3533:;
    _1506 = 0;
    int64_t _1507 = 0; // F
    _jump3534:; // Begin body of loop
    _1506 += _980.d0;
    _1507++;
    if (_1507 < _1375.d0)
    goto _jump3534;
    // End body of loop
    _1505 = _1506;
    _jump3532:;
    if (_1505 > 0) 
    goto _jump3535;
    fail_assertion("non-positive loop bound");
    _jump3535:;
    // Computing bound for H
    if (_980.d1 > 0) 
    goto _jump3536;
    fail_assertion("non-positive loop bound");
    _jump3536:;
    _1499 = 0;
    int64_t _1508 = 0; // H
    int64_t _1509 = 0; // G
    int64_t _1510 = 0; // F
    _jump3537:; // Begin body of loop
    _1499 += _980.d0;
    _1508++;
    if (_1508 < _980.d1)
    goto _jump3537;
    _1508 = 0;
    _1509++;
    if (_1509 < _1505)
    goto _jump3537;
    _1509 = 0;
    _1510++;
    if (_1510 < _1500)
    goto _jump3537;
    // End body of loop
    int64_t _1511 = 0;
    _1511 *= _1495.d0;
    _1511 += _1498;
    _1511 *= _1495.d1;
    _1511 += _1497;
    _1495.data[_1511] = _1499;
    _1497++;
    if (_1497 < _980.d1)
    goto _jump3528;
    _1497 = 0;
    _1498++;
    if (_1498 < _726.d1)
    goto _jump3528;
    // End body of loop
    _a1__a2_int64_t _1512;
    _1512.d0 = 3;
    _1512.data = jpl_alloc(sizeof(_a2_int64_t) * 3);
    _1512.data[0] = _726;
    _1512.data[1] = _1495;
    _1512.data[2] = _726;
}

