
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_void_t *data;
} _a2__a1_void_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  _a3__a3_double *data;
} _a1__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
    bool a;
    int64_t b;
} g;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  g *data;
} _a3_g;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  g *data;
} _a1_g;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
    _a3__a3_double a;
    int64_t b;
    double c;
} k;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_double *data;
} _a3__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_bool *data;
} _a2__a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_void_t *data;
} _a3__a2__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a3_double *data;
} _a2__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  g *data;
} _a2_g;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_g *data;
} _a2__a2_g;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2_g *data;
} _a2__a2__a2_g;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  k *data;
} _a3_k;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_k *data;
} _a3__a3_k;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_k *data;
} _a2__a3_k;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2__a1_void_t *data;
} _a1__a2__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
    rgba a;
    _a3_g b;
} v;

typedef struct {
    g a;
} w;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1_int64_t *data;
} _a2__a1__a1_int64_t;

typedef struct {
  int64_t d0;
  w *data;
} _a1_w;

typedef struct {
  int64_t d0;
  _a3_rgba *data;
} _a1__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  _a2__a2_bool *data;
} _a1__a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a2__a2_bool *data;
} _a2__a1__a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  k *data;
} _a2_k;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  v *data;
} _a3_v;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_v *data;
} _a2__a3_v;

typedef struct {
  int64_t d0;
  v *data;
} _a1_v;

void_t b(_a2_bool c, int64_t f, _a2__a1_void_t g) {
    bool _0 = true;
    bool _1;
    if (!_0)
    goto _jump38;
    bool _2;
    if (!a)
    goto _jump39;
    bool _3 = f != g.d1;
    bool _4;
    if (!_3)
    goto _jump40;
    bool _5 = true;
    _4 = _5;
    goto _jump41;
    _jump40:;
    bool _7 = false;
    bool _8;
    if (!_7)
    goto _jump42;
    bool _9 = !a;
    _8 = _9;
    goto _jump43;
    _jump42:;
    bool _10 = true;
    _8 = _10;
    _jump43:;
    double _11 = 14.0;
    double _12 = 29.0;
    bool _13 = _11 > _12;
    bool _14 = !_13;
    bool _15 = _8 == _14;
    bool _6 = _15;
    if (0 != _15)
    goto _jump44;
    int64_t _17 = -c.d0;
    int64_t _18;
    // Computing bound for j
    int64_t _19 = 272;
    if (_19 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    _18 = 0;
    int64_t _20 = 0; // k
    int64_t _21 = 0; // j
    _jump47:; // Begin body of loop
    _18 += _20;
    _20++;
    if (_20 < c.d1)
    goto _jump47;
    _20 = 0;
    _21++;
    if (_21 < _19)
    goto _jump47;
    // End body of loop
    bool _22 = _17 <= _18;
    bool _16 = _22;
    if (0 == _22)
    goto _jump48;
    bool _24 = false;
    bool _23 = _24;
    if (0 != _24)
    goto _jump49;
    _23 = a;
    _jump49:;
    bool _25 = g.d1 < g.d1;
    bool _26 = _23 == _25;
    _16 = _26;
    _jump48:;
    _6 = _16;
    _jump44:;
    _4 = _6;
    _jump41:;
    _2 = _4;
    goto _jump50;
    _jump39:;
    double _27;
    // Computing bound for j
    double _28 = 41.0;
    double _29 = 15.0;
    bool _30 = _28 != _29;
    int64_t _31;
    if (!_30)
    goto _jump51;
    int64_t _32 = g.d1 / f;
    _31 = _32;
    goto _jump52;
    _jump51:;
    int64_t _33;
    if (!a)
    goto _jump53;
    _33 = g.d0;
    goto _jump54;
    _jump53:;
    _33 = g.d0;
    _jump54:;
    _31 = _33;
    _jump52:;
    if (_31 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    _27 = 0;
    int64_t _34 = 0; // k
    int64_t _35 = 0; // j
    _jump57:; // Begin body of loop
    double _36 = 23.0;
    _27 += _36;
    _34++;
    if (_34 < c.d1)
    goto _jump57;
    _34 = 0;
    _35++;
    if (_35 < _31)
    goto _jump57;
    // End body of loop
    double _37 = -_27;
    _a1_double _38;
    // Computing bound for j
    int64_t _39 = -c.d1;
    _38.d0 = _39;
    if (_39 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= _39;
    _40 *= sizeof(double);
    _38.data = jpl_alloc(_40);
    int64_t _41 = 0; // j
    _jump59:; // Begin body of loop
    double _42 = 77.0;
    double _43 = -_42;
    int64_t _44 = 0;
    _44 *= _38.d0;
    _44 += _41;
    _38.data[_44] = _43;
    _41++;
    if (_41 < _39)
    goto _jump59;
    // End body of loop
    if (g.d0 >= 0)
    goto _jump60;
    fail_assertion("negative array index");
    _jump60:;
    if (g.d0 < _38.d0)
    goto _jump61;
    fail_assertion("index too large");
    _jump61:;
    int64_t _45 = 0;
    _45 *= _38.d0;
    _45 += g.d0;
    double _46 = _38.data[_45];
    double _47 = -_46;
    bool _48 = _37 >= _47;
    _2 = _48;
    _jump50:;
    _1 = _2;
    goto _jump62;
    _jump38:;
    bool _49 = true;
    _1 = _49;
    _jump62:;
    if (0 != _1)
    goto _jump63;
    fail_assertion("j");
    _jump63:;
    _a2_void_t _50;
    // Computing bound for j
    int64_t _51 = -f;
    _50.d0 = _51;
    if (_51 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing bound for k
    int64_t _52;
    // Computing bound for j
    int64_t _53 = g.d1 % g.d1;
    if (_53 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    _52 = 0;
    int64_t _54 = 0; // j
    _jump66:; // Begin body of loop
    int64_t _55;
    // Computing bound for k
    int64_t _56 = c.d1 + c.d0;
    if (_56 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    // Computing bound for l
    if (c.d1 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    // Computing bound for m
    if (f > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    _55 = 0;
    int64_t _57 = 0; // m
    int64_t _58 = 0; // l
    int64_t _59 = 0; // k
    _jump70:; // Begin body of loop
    _55 += g.d0;
    _57++;
    if (_57 < f)
    goto _jump70;
    _57 = 0;
    _58++;
    if (_58 < c.d1)
    goto _jump70;
    _58 = 0;
    _59++;
    if (_59 < _56)
    goto _jump70;
    // End body of loop
    _52 += _55;
    _54++;
    if (_54 < _53)
    goto _jump66;
    // End body of loop
    _50.d1 = _52;
    if (_52 > 0) 
    goto _jump71;
    fail_assertion("non-positive loop bound");
    _jump71:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= _51;
    _60 *= _52;
    _60 *= sizeof(void_t);
    _50.data = jpl_alloc(_60);
    int64_t _61 = 0; // k
    int64_t _62 = 0; // j
    _jump72:; // Begin body of loop
    _a3_void_t _63;
    // Computing bound for l
    _63.d0 = _62;
    if (_62 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing bound for m
    int64_t _64;
    // Computing bound for l
    if (g.d1 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    // Computing bound for m
    int64_t _65;
    // Computing bound for l
    int64_t _66 = 155;
    int64_t _67 = _66 - c.d0;
    if (_67 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for m
    bool _68 = false;
    int64_t _69;
    if (!_68)
    goto _jump76;
    _69 = f;
    goto _jump77;
    _jump76:;
    _69 = c.d0;
    _jump77:;
    if (_69 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing bound for n
    if (f > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    _65 = 0;
    int64_t _70 = 0; // n
    int64_t _71 = 0; // m
    int64_t _72 = 0; // l
    _jump80:; // Begin body of loop
    int64_t _73 = g.d1 * _70;
    _65 += _73;
    _70++;
    if (_70 < f)
    goto _jump80;
    _70 = 0;
    _71++;
    if (_71 < _69)
    goto _jump80;
    _71 = 0;
    _72++;
    if (_72 < _67)
    goto _jump80;
    // End body of loop
    if (_65 > 0) 
    goto _jump81;
    fail_assertion("non-positive loop bound");
    _jump81:;
    // Computing bound for n
    if (_61 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    _64 = 0;
    int64_t _74 = 0; // n
    int64_t _75 = 0; // m
    int64_t _76 = 0; // l
    _jump83:; // Begin body of loop
    bool _77 = false;
    int64_t _78;
    if (!_77)
    goto _jump84;
    _78 = c.d0;
    goto _jump85;
    _jump84:;
    _78 = _74;
    _jump85:;
    _64 += _78;
    _74++;
    if (_74 < _61)
    goto _jump83;
    _74 = 0;
    _75++;
    if (_75 < _65)
    goto _jump83;
    _75 = 0;
    _76++;
    if (_76 < g.d1)
    goto _jump83;
    // End body of loop
    _63.d1 = _64;
    if (_64 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    // Computing bound for n
    _a1_bool _79;
    // Computing bound for l
    _79.d0 = _61;
    if (_61 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= _61;
    _80 *= sizeof(bool);
    _79.data = jpl_alloc(_80);
    int64_t _81 = 0; // l
    _jump88:; // Begin body of loop
    bool _82 = false;
    int64_t _83 = 0;
    _83 *= _79.d0;
    _83 += _81;
    _79.data[_83] = _82;
    _81++;
    if (_81 < _61)
    goto _jump88;
    // End body of loop
    if (c.d1 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (c.d1 < _79.d0)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    int64_t _84 = 0;
    _84 *= _79.d0;
    _84 += c.d1;
    bool _85 = _79.data[_84];
    int64_t _86;
    if (!_85)
    goto _jump91;
    _86 = _61;
    goto _jump92;
    _jump91:;
    int64_t _87 = 286;
    _86 = _87;
    _jump92:;
    _63.d2 = _86;
    if (_86 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= _62;
    _88 *= _64;
    _88 *= _86;
    _88 *= sizeof(void_t);
    _63.data = jpl_alloc(_88);
    int64_t _89 = 0; // n
    int64_t _90 = 0; // m
    int64_t _91 = 0; // l
    _jump94:; // Begin body of loop
    _a2_bool _92;
    // Computing bound for o
    _92.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    // Computing bound for p
    _92.d1 = _91;
    if (_91 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= c.d0;
    _93 *= _91;
    _93 *= sizeof(bool);
    _92.data = jpl_alloc(_93);
    int64_t _94 = 0; // p
    int64_t _95 = 0; // o
    _jump97:; // Begin body of loop
    bool _96 = true;
    bool _97 = _96 != a;
    int64_t _98 = 0;
    _98 *= _92.d0;
    _98 += _95;
    _98 *= _92.d1;
    _98 += _94;
    _92.data[_98] = _97;
    _94++;
    if (_94 < _91)
    goto _jump97;
    _94 = 0;
    _95++;
    if (_95 < c.d0)
    goto _jump97;
    // End body of loop
    void_t _99 = b(_92, _62, g);
    int64_t _100 = 0;
    _100 *= _63.d0;
    _100 += _91;
    _100 *= _63.d1;
    _100 += _90;
    _100 *= _63.d2;
    _100 += _89;
    _63.data[_100] = _99;
    _89++;
    if (_89 < _86)
    goto _jump94;
    _89 = 0;
    _90++;
    if (_90 < _64)
    goto _jump94;
    _90 = 0;
    _91++;
    if (_91 < _62)
    goto _jump94;
    // End body of loop
    if (g.d1 >= 0)
    goto _jump98;
    fail_assertion("negative array index");
    _jump98:;
    if (g.d1 < _63.d0)
    goto _jump99;
    fail_assertion("index too large");
    _jump99:;
    if (_62 >= 0)
    goto _jump100;
    fail_assertion("negative array index");
    _jump100:;
    if (_62 < _63.d1)
    goto _jump101;
    fail_assertion("index too large");
    _jump101:;
    if (g.d1 >= 0)
    goto _jump102;
    fail_assertion("negative array index");
    _jump102:;
    if (g.d1 < _63.d2)
    goto _jump103;
    fail_assertion("index too large");
    _jump103:;
    int64_t _101 = 0;
    _101 *= _63.d0;
    _101 += g.d1;
    _101 *= _63.d1;
    _101 += _62;
    _101 *= _63.d2;
    _101 += g.d1;
    void_t _102 = _63.data[_101];
    int64_t _103 = 0;
    _103 *= _50.d0;
    _103 += _62;
    _103 *= _50.d1;
    _103 += _61;
    _50.data[_103] = _102;
    _61++;
    if (_61 < _52)
    goto _jump72;
    _61 = 0;
    _62++;
    if (_62 < _51)
    goto _jump72;
    // End body of loop
    _a2_bool _104;
    // Computing bound for j
    int64_t _105;
    // Computing bound for j
    int64_t _106 = 575;
    if (_106 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    _105 = 0;
    int64_t _107 = 0; // j
    _jump105:; // Begin body of loop
    int64_t _108;
    // Computing bound for k
    int64_t _109 = 69;
    if (_109 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump107;
    fail_assertion("non-positive loop bound");
    _jump107:;
    _108 = 0;
    int64_t _110 = 0; // l
    int64_t _111 = 0; // k
    _jump108:; // Begin body of loop
    int64_t _112 = 994;
    _108 += _112;
    _110++;
    if (_110 < c.d0)
    goto _jump108;
    _110 = 0;
    _111++;
    if (_111 < _109)
    goto _jump108;
    // End body of loop
    _105 += _108;
    _107++;
    if (_107 < _106)
    goto _jump105;
    // End body of loop
    _104.d0 = _105;
    if (_105 > 0) 
    goto _jump109;
    fail_assertion("non-positive loop bound");
    _jump109:;
    // Computing bound for k
    int64_t _113;
    // Computing bound for j
    if (f > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    _113 = 0;
    int64_t _114 = 0; // j
    _jump111:; // Begin body of loop
    _113 += g.d0;
    _114++;
    if (_114 < f)
    goto _jump111;
    // End body of loop
    _104.d1 = _113;
    if (_113 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _105;
    _115 *= _113;
    _115 *= sizeof(bool);
    _104.data = jpl_alloc(_115);
    int64_t _116 = 0; // k
    int64_t _117 = 0; // j
    _jump113:; // Begin body of loop
    bool _118 = true;
    int64_t _119 = 0;
    _119 *= _104.d0;
    _119 += _117;
    _119 *= _104.d1;
    _119 += _116;
    _104.data[_119] = _118;
    _116++;
    if (_116 < _113)
    goto _jump113;
    _116 = 0;
    _117++;
    if (_117 < _105)
    goto _jump113;
    // End body of loop
    int64_t _120 = c.d1 % c.d1;
    int64_t _121;
    // Computing bound for j
    if (c.d1 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    // Computing bound for k
    int64_t _122 = 78;
    if (_122 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    _121 = 0;
    int64_t _123 = 0; // k
    int64_t _124 = 0; // j
    _jump116:; // Begin body of loop
    int64_t _125 = 536;
    _121 += _125;
    _123++;
    if (_123 < _122)
    goto _jump116;
    _123 = 0;
    _124++;
    if (_124 < c.d1)
    goto _jump116;
    // End body of loop
    if (_120 >= 0)
    goto _jump117;
    fail_assertion("negative array index");
    _jump117:;
    if (_120 < _104.d0)
    goto _jump118;
    fail_assertion("index too large");
    _jump118:;
    if (_121 >= 0)
    goto _jump119;
    fail_assertion("negative array index");
    _jump119:;
    if (_121 < _104.d1)
    goto _jump120;
    fail_assertion("index too large");
    _jump120:;
    int64_t _126 = 0;
    _126 *= _104.d0;
    _126 += _120;
    _126 *= _104.d1;
    _126 += _121;
    bool _127 = _104.data[_126];
    int64_t _128;
    if (!_127)
    goto _jump121;
    int64_t _129;
    // Computing bound for j
    int64_t _130 = 560;
    if (_130 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing bound for k
    int64_t _131;
    // Computing bound for j
    int64_t _132 = -c.d1;
    if (_132 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    _131 = 0;
    int64_t _133 = 0; // k
    int64_t _134 = 0; // j
    _jump125:; // Begin body of loop
    _131 += f;
    _133++;
    if (_133 < c.d1)
    goto _jump125;
    _133 = 0;
    _134++;
    if (_134 < _132)
    goto _jump125;
    // End body of loop
    int64_t _135 = -_131;
    if (_135 > 0) 
    goto _jump126;
    fail_assertion("non-positive loop bound");
    _jump126:;
    // Computing bound for l
    int64_t _136 = 874;
    if (_136 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    _129 = 0;
    int64_t _137 = 0; // l
    int64_t _138 = 0; // k
    int64_t _139 = 0; // j
    _jump128:; // Begin body of loop
    _129 += _138;
    _137++;
    if (_137 < _136)
    goto _jump128;
    _137 = 0;
    _138++;
    if (_138 < _135)
    goto _jump128;
    _138 = 0;
    _139++;
    if (_139 < _130)
    goto _jump128;
    // End body of loop
    _128 = _129;
    goto _jump129;
    _jump121:;
    _128 = c.d0;
    _jump129:;
    int64_t _140;
    // Computing bound for j
    if (c.d1 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for k
    int64_t _141 = g.d0 % c.d0;
    if (_141 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    _140 = 0;
    int64_t _142 = 0; // k
    int64_t _143 = 0; // j
    _jump132:; // Begin body of loop
    _140 += c.d1;
    _142++;
    if (_142 < _141)
    goto _jump132;
    _142 = 0;
    _143++;
    if (_143 < c.d1)
    goto _jump132;
    // End body of loop
    if (_128 >= 0)
    goto _jump133;
    fail_assertion("negative array index");
    _jump133:;
    if (_128 < _50.d0)
    goto _jump134;
    fail_assertion("index too large");
    _jump134:;
    if (_140 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_140 < _50.d1)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    int64_t _144 = 0;
    _144 *= _50.d0;
    _144 += _128;
    _144 *= _50.d1;
    _144 += _140;
    void_t _145 = _50.data[_144];
    return _145;
    _a1_void_t _146;
    // Computing bound for j
    int64_t _147;
    // Computing bound for j
    int64_t _148 = 496;
    if (_148 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing bound for k
    int64_t _149 = -f;
    if (_149 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    _147 = 0;
    int64_t _150 = 0; // k
    int64_t _151 = 0; // j
    _jump139:; // Begin body of loop
    _147 += _151;
    _150++;
    if (_150 < _149)
    goto _jump139;
    _150 = 0;
    _151++;
    if (_151 < _148)
    goto _jump139;
    // End body of loop
    _146.d0 = _147;
    if (_147 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= _147;
    _152 *= sizeof(void_t);
    _146.data = jpl_alloc(_152);
    int64_t _153 = 0; // j
    _jump141:; // Begin body of loop
    _a3_void_t _154;
    // Computing bound for k
    int64_t _155;
    // Computing bound for k
    int64_t _156 = 722;
    if (_156 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    // Computing bound for l
    if (f > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing bound for m
    if (g.d0 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    _155 = 0;
    int64_t _157 = 0; // m
    int64_t _158 = 0; // l
    int64_t _159 = 0; // k
    _jump145:; // Begin body of loop
    _155 += _157;
    _157++;
    if (_157 < g.d0)
    goto _jump145;
    _157 = 0;
    _158++;
    if (_158 < f)
    goto _jump145;
    _158 = 0;
    _159++;
    if (_159 < _156)
    goto _jump145;
    // End body of loop
    _154.d0 = _155;
    if (_155 > 0) 
    goto _jump146;
    fail_assertion("non-positive loop bound");
    _jump146:;
    // Computing bound for l
    int64_t _160;
    // Computing bound for k
    bool _161 = c.d0 != g.d0;
    int64_t _162;
    if (!_161)
    goto _jump147;
    int64_t _163 = 778;
    _162 = _163;
    goto _jump148;
    _jump147:;
    _162 = _153;
    _jump148:;
    if (_162 > 0) 
    goto _jump149;
    fail_assertion("non-positive loop bound");
    _jump149:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump150;
    fail_assertion("non-positive loop bound");
    _jump150:;
    _160 = 0;
    int64_t _164 = 0; // l
    int64_t _165 = 0; // k
    _jump151:; // Begin body of loop
    _160 += f;
    _164++;
    if (_164 < c.d0)
    goto _jump151;
    _164 = 0;
    _165++;
    if (_165 < _162)
    goto _jump151;
    // End body of loop
    _154.d1 = _160;
    if (_160 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing bound for m
    _154.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= _155;
    _166 *= _160;
    _166 *= g.d1;
    _166 *= sizeof(void_t);
    _154.data = jpl_alloc(_166);
    int64_t _167 = 0; // m
    int64_t _168 = 0; // l
    int64_t _169 = 0; // k
    _jump154:; // Begin body of loop
    bool _170;
    if (!a)
    goto _jump155;
    bool _171 = true;
    _170 = _171;
    goto _jump156;
    _jump155:;
    bool _172 = false;
    bool _173 = !_172;
    _170 = _173;
    _jump156:;
    void_t _174;
    if (!_170)
    goto _jump157;
    void_t _175 = b(c, _169, g);
    _174 = _175;
    goto _jump158;
    _jump157:;
    _a2_bool _176;
    // Computing bound for n
    _176.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing bound for o
    _176.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= g.d1;
    _177 *= c.d0;
    _177 *= sizeof(bool);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // o
    int64_t _179 = 0; // n
    _jump161:; // Begin body of loop
    bool _180 = false;
    int64_t _181 = 0;
    _181 *= _176.d0;
    _181 += _179;
    _181 *= _176.d1;
    _181 += _178;
    _176.data[_181] = _180;
    _178++;
    if (_178 < c.d0)
    goto _jump161;
    _178 = 0;
    _179++;
    if (_179 < g.d1)
    goto _jump161;
    // End body of loop
    int64_t _182;
    // Computing bound for n
    if (c.d0 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _182 = 0;
    int64_t _183 = 0; // n
    _jump163:; // Begin body of loop
    _182 += g.d1;
    _183++;
    if (_183 < c.d0)
    goto _jump163;
    // End body of loop
    void_t _184 = b(_176, _182, g);
    _174 = _184;
    _jump158:;
    int64_t _185 = 0;
    _185 *= _154.d0;
    _185 += _169;
    _185 *= _154.d1;
    _185 += _168;
    _185 *= _154.d2;
    _185 += _167;
    _154.data[_185] = _174;
    _167++;
    if (_167 < g.d1)
    goto _jump154;
    _167 = 0;
    _168++;
    if (_168 < _160)
    goto _jump154;
    _168 = 0;
    _169++;
    if (_169 < _155)
    goto _jump154;
    // End body of loop
    if (c.d0 >= 0)
    goto _jump164;
    fail_assertion("negative array index");
    _jump164:;
    if (c.d0 < _154.d0)
    goto _jump165;
    fail_assertion("index too large");
    _jump165:;
    if (g.d0 >= 0)
    goto _jump166;
    fail_assertion("negative array index");
    _jump166:;
    if (g.d0 < _154.d1)
    goto _jump167;
    fail_assertion("index too large");
    _jump167:;
    if (g.d0 >= 0)
    goto _jump168;
    fail_assertion("negative array index");
    _jump168:;
    if (g.d0 < _154.d2)
    goto _jump169;
    fail_assertion("index too large");
    _jump169:;
    int64_t _186 = 0;
    _186 *= _154.d0;
    _186 += c.d0;
    _186 *= _154.d1;
    _186 += g.d0;
    _186 *= _154.d2;
    _186 += g.d0;
    void_t _187 = _154.data[_186];
    int64_t _188 = 0;
    _188 *= _146.d0;
    _188 += _153;
    _146.data[_188] = _187;
    _153++;
    if (_153 < _147)
    goto _jump141;
    // End body of loop
    _a3__a1_int64_t _189;
    // Computing bound for j
    bool _190 = false;
    int64_t _191;
    if (!_190)
    goto _jump170;
    _191 = c.d1;
    goto _jump171;
    _jump170:;
    _191 = f;
    _jump171:;
    _189.d0 = _191;
    if (_191 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    // Computing bound for k
    int64_t _192;
    if (!a)
    goto _jump173;
    _192 = c.d1;
    goto _jump174;
    _jump173:;
    _192 = c.d0;
    _jump174:;
    _189.d1 = _192;
    if (_192 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing bound for l
    _189.d2 = c.d1;
    if (c.d1 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= _191;
    _193 *= _192;
    _193 *= c.d1;
    _193 *= sizeof(_a1_int64_t);
    _189.data = jpl_alloc(_193);
    int64_t _194 = 0; // l
    int64_t _195 = 0; // k
    int64_t _196 = 0; // j
    _jump177:; // Begin body of loop
    int64_t _197;
    if (!a)
    goto _jump178;
    _197 = _195;
    goto _jump179;
    _jump178:;
    _197 = _194;
    _jump179:;
    int64_t _198 = _197 % _195;
    _a1_int64_t _199;
    _199.d0 = 2;
    _199.data = jpl_alloc(sizeof(int64_t) * 2);
    _199.data[0] = g.d1;
    _199.data[1] = _198;
    int64_t _200 = 0;
    _200 *= _189.d0;
    _200 += _196;
    _200 *= _189.d1;
    _200 += _195;
    _200 *= _189.d2;
    _200 += _194;
    _189.data[_200] = _199;
    _194++;
    if (_194 < c.d1)
    goto _jump177;
    _194 = 0;
    _195++;
    if (_195 < _192)
    goto _jump177;
    _195 = 0;
    _196++;
    if (_196 < _191)
    goto _jump177;
    // End body of loop
    _a3_int64_t _201;
    // Computing bound for j
    _201.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump180;
    fail_assertion("non-positive loop bound");
    _jump180:;
    // Computing bound for k
    _201.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing bound for l
    int64_t _202;
    if (!a)
    goto _jump182;
    int64_t _203 = 906;
    _202 = _203;
    goto _jump183;
    _jump182:;
    _202 = c.d0;
    _jump183:;
    _201.d2 = _202;
    if (_202 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing total size of heap memory to allocate
    int64_t _204 = 1;
    _204 *= g.d1;
    _204 *= g.d0;
    _204 *= _202;
    _204 *= sizeof(int64_t);
    _201.data = jpl_alloc(_204);
    int64_t _205 = 0; // l
    int64_t _206 = 0; // k
    int64_t _207 = 0; // j
    _jump185:; // Begin body of loop
    int64_t _208 = 0;
    _208 *= _201.d0;
    _208 += _207;
    _208 *= _201.d1;
    _208 += _206;
    _208 *= _201.d2;
    _208 += _205;
    _201.data[_208] = _207;
    _205++;
    if (_205 < _202)
    goto _jump185;
    _205 = 0;
    _206++;
    if (_206 < g.d0)
    goto _jump185;
    _206 = 0;
    _207++;
    if (_207 < g.d1)
    goto _jump185;
    // End body of loop
    int64_t _209 = -c.d1;
    int64_t _210 = 263;
    int64_t _211 = _209 * _210;
    int64_t _212 = -_211;
    int64_t _213 = c.d0 / c.d1;
    int64_t _214 = _213 * g.d1;
    int64_t _215 = -_214;
    if (g.d1 >= 0)
    goto _jump186;
    fail_assertion("negative array index");
    _jump186:;
    if (g.d1 < _201.d0)
    goto _jump187;
    fail_assertion("index too large");
    _jump187:;
    if (_212 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_212 < _201.d1)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    if (_215 >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (_215 < _201.d2)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    int64_t _216 = 0;
    _216 *= _201.d0;
    _216 += g.d1;
    _216 *= _201.d1;
    _216 += _212;
    _216 *= _201.d2;
    _216 += _215;
    int64_t _217 = _201.data[_216];
    if (_217 >= 0)
    goto _jump192;
    fail_assertion("negative array index");
    _jump192:;
    if (_217 < _189.d0)
    goto _jump193;
    fail_assertion("index too large");
    _jump193:;
    if (g.d0 >= 0)
    goto _jump194;
    fail_assertion("negative array index");
    _jump194:;
    if (g.d0 < _189.d1)
    goto _jump195;
    fail_assertion("index too large");
    _jump195:;
    if (g.d0 >= 0)
    goto _jump196;
    fail_assertion("negative array index");
    _jump196:;
    if (g.d0 < _189.d2)
    goto _jump197;
    fail_assertion("index too large");
    _jump197:;
    int64_t _218 = 0;
    _218 *= _189.d0;
    _218 += _217;
    _218 *= _189.d1;
    _218 += g.d0;
    _218 *= _189.d2;
    _218 += g.d0;
    _a1_int64_t _219 = _189.data[_218];
    int64_t _220 = 413;
    if (_220 >= 0)
    goto _jump198;
    fail_assertion("negative array index");
    _jump198:;
    if (_220 < _219.d0)
    goto _jump199;
    fail_assertion("index too large");
    _jump199:;
    int64_t _221 = 0;
    _221 *= _219.d0;
    _221 += _220;
    int64_t _222 = _219.data[_221];
    if (_222 >= 0)
    goto _jump200;
    fail_assertion("negative array index");
    _jump200:;
    if (_222 < _146.d0)
    goto _jump201;
    fail_assertion("index too large");
    _jump201:;
    int64_t _223 = 0;
    _223 *= _146.d0;
    _223 += _222;
    void_t _224 = _146.data[_223];
    return _224;
    _a3_bool _225;
    // Computing bound for j
    _225.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    // Computing bound for k
    _225.d1 = f;
    if (f > 0) 
    goto _jump203;
    fail_assertion("non-positive loop bound");
    _jump203:;
    // Computing bound for l
    int64_t _226;
    if (!a)
    goto _jump204;
    _226 = g.d0;
    goto _jump205;
    _jump204:;
    int64_t _227 = 586;
    int64_t _228 = g.d0 % _227;
    _226 = _228;
    _jump205:;
    _225.d2 = _226;
    if (_226 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    // Computing total size of heap memory to allocate
    int64_t _229 = 1;
    _229 *= c.d1;
    _229 *= f;
    _229 *= _226;
    _229 *= sizeof(bool);
    _225.data = jpl_alloc(_229);
    int64_t _230 = 0; // l
    int64_t _231 = 0; // k
    int64_t _232 = 0; // j
    _jump207:; // Begin body of loop
    int64_t _233 = 0;
    _233 *= _225.d0;
    _233 += _232;
    _233 *= _225.d1;
    _233 += _231;
    _233 *= _225.d2;
    _233 += _230;
    _225.data[_233] = a;
    _230++;
    if (_230 < _226)
    goto _jump207;
    _230 = 0;
    _231++;
    if (_231 < f)
    goto _jump207;
    _231 = 0;
    _232++;
    if (_232 < c.d1)
    goto _jump207;
    // End body of loop
    int64_t _234;
    // Computing bound for j
    _a1_int64_t _235;
    _235.d0 = 1;
    _235.data = jpl_alloc(sizeof(int64_t) * 1);
    _235.data[0] = g.d0;
    if (g.d0 >= 0)
    goto _jump208;
    fail_assertion("negative array index");
    _jump208:;
    if (g.d0 < _235.d0)
    goto _jump209;
    fail_assertion("index too large");
    _jump209:;
    int64_t _236 = 0;
    _236 *= _235.d0;
    _236 += g.d0;
    int64_t _237 = _235.data[_236];
    if (_237 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for k
    bool _238 = true;
    int64_t _239;
    if (!_238)
    goto _jump211;
    _239 = g.d0;
    goto _jump212;
    _jump211:;
    int64_t _240;
    // Computing bound for j
    if (c.d1 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump214;
    fail_assertion("non-positive loop bound");
    _jump214:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    _240 = 0;
    int64_t _241 = 0; // l
    int64_t _242 = 0; // k
    int64_t _243 = 0; // j
    _jump216:; // Begin body of loop
    int64_t _244 = 890;
    _240 += _244;
    _241++;
    if (_241 < c.d0)
    goto _jump216;
    _241 = 0;
    _242++;
    if (_242 < c.d0)
    goto _jump216;
    _242 = 0;
    _243++;
    if (_243 < c.d1)
    goto _jump216;
    // End body of loop
    int64_t _245 = _240 * c.d0;
    _239 = _245;
    _jump212:;
    int64_t _246 = -_239;
    if (_246 > 0) 
    goto _jump217;
    fail_assertion("non-positive loop bound");
    _jump217:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump218;
    fail_assertion("non-positive loop bound");
    _jump218:;
    _234 = 0;
    int64_t _247 = 0; // l
    int64_t _248 = 0; // k
    int64_t _249 = 0; // j
    _jump219:; // Begin body of loop
    _234 += g.d1;
    _247++;
    if (_247 < c.d0)
    goto _jump219;
    _247 = 0;
    _248++;
    if (_248 < _246)
    goto _jump219;
    _248 = 0;
    _249++;
    if (_249 < _237)
    goto _jump219;
    // End body of loop
    if (g.d0 >= 0)
    goto _jump220;
    fail_assertion("negative array index");
    _jump220:;
    if (g.d0 < _225.d0)
    goto _jump221;
    fail_assertion("index too large");
    _jump221:;
    if (g.d1 >= 0)
    goto _jump222;
    fail_assertion("negative array index");
    _jump222:;
    if (g.d1 < _225.d1)
    goto _jump223;
    fail_assertion("index too large");
    _jump223:;
    if (_234 >= 0)
    goto _jump224;
    fail_assertion("negative array index");
    _jump224:;
    if (_234 < _225.d2)
    goto _jump225;
    fail_assertion("index too large");
    _jump225:;
    int64_t _250 = 0;
    _250 *= _225.d0;
    _250 += g.d0;
    _250 *= _225.d1;
    _250 += g.d1;
    _250 *= _225.d2;
    _250 += _234;
    bool _251 = _225.data[_250];
    _a1_int64_t _252;
    if (!_251)
    goto _jump226;
    double _254 = 54.0;
    double _255 = 88.0;
    bool _256 = _254 > _255;
    bool _253 = _256;
    if (0 != _256)
    goto _jump227;
    _253 = a;
    _jump227:;
    double _257;
    if (!_253)
    goto _jump228;
    double _258 = 1.0;
    _257 = _258;
    goto _jump229;
    _jump228:;
    double _259 = 94.0;
    double _260 = -_259;
    _257 = _260;
    _jump229:;
    bool _262 = c.d0 < f;
    bool _261 = _262;
    if (0 != _262)
    goto _jump230;
    bool _263 = true;
    _261 = _263;
    _jump230:;
    double _264;
    if (!_261)
    goto _jump231;
    double _265;
    // Computing bound for j
    if (g.d1 > 0) 
    goto _jump232;
    fail_assertion("non-positive loop bound");
    _jump232:;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    _265 = 0;
    int64_t _266 = 0; // l
    int64_t _267 = 0; // k
    int64_t _268 = 0; // j
    _jump235:; // Begin body of loop
    double _269 = 23.0;
    _265 += _269;
    _266++;
    if (_266 < c.d0)
    goto _jump235;
    _266 = 0;
    _267++;
    if (_267 < c.d1)
    goto _jump235;
    _267 = 0;
    _268++;
    if (_268 < g.d1)
    goto _jump235;
    // End body of loop
    double _270 = -_265;
    _264 = _270;
    goto _jump236;
    _jump231:;
    double _271;
    // Computing bound for j
    int64_t _272;
    // Computing bound for j
    if (g.d1 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing bound for k
    if (g.d0 > 0) 
    goto _jump238;
    fail_assertion("non-positive loop bound");
    _jump238:;
    _272 = 0;
    int64_t _273 = 0; // k
    int64_t _274 = 0; // j
    _jump239:; // Begin body of loop
    _272 += g.d1;
    _273++;
    if (_273 < g.d0)
    goto _jump239;
    _273 = 0;
    _274++;
    if (_274 < g.d1)
    goto _jump239;
    // End body of loop
    if (_272 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    // Computing bound for k
    if (f > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing bound for l
    int64_t _275;
    // Computing bound for j
    if (g.d1 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for k
    if (g.d0 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    // Computing bound for l
    if (g.d1 > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    _275 = 0;
    int64_t _276 = 0; // l
    int64_t _277 = 0; // k
    int64_t _278 = 0; // j
    _jump245:; // Begin body of loop
    _275 += c.d1;
    _276++;
    if (_276 < g.d1)
    goto _jump245;
    _276 = 0;
    _277++;
    if (_277 < g.d0)
    goto _jump245;
    _277 = 0;
    _278++;
    if (_278 < g.d1)
    goto _jump245;
    // End body of loop
    if (_275 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    _271 = 0;
    int64_t _279 = 0; // l
    int64_t _280 = 0; // k
    int64_t _281 = 0; // j
    _jump247:; // Begin body of loop
    double _282 = 24.0;
    _271 += _282;
    _279++;
    if (_279 < _275)
    goto _jump247;
    _279 = 0;
    _280++;
    if (_280 < f)
    goto _jump247;
    _280 = 0;
    _281++;
    if (_281 < _272)
    goto _jump247;
    // End body of loop
    _264 = _271;
    _jump236:;
    bool _283 = _257 > _264;
    bool _284 = !_283;
    _a1_int64_t _285;
    if (!_284)
    goto _jump248;
    _a1_int64_t _286;
    if (!a)
    goto _jump249;
    _a1_int64_t _287;
    // Computing bound for j
    int64_t _288 = 49;
    _287.d0 = _288;
    if (_288 > 0) 
    goto _jump250;
    fail_assertion("non-positive loop bound");
    _jump250:;
    // Computing total size of heap memory to allocate
    int64_t _289 = 1;
    _289 *= _288;
    _289 *= sizeof(int64_t);
    _287.data = jpl_alloc(_289);
    int64_t _290 = 0; // j
    _jump251:; // Begin body of loop
    int64_t _291 = 0;
    _291 *= _287.d0;
    _291 += _290;
    _287.data[_291] = c.d1;
    _290++;
    if (_290 < _288)
    goto _jump251;
    // End body of loop
    _286 = _287;
    goto _jump252;
    _jump249:;
    _a1_int64_t _292;
    // Computing bound for j
    int64_t _293;
    // Computing bound for j
    if (c.d1 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump254;
    fail_assertion("non-positive loop bound");
    _jump254:;
    // Computing bound for l
    if (c.d1 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    _293 = 0;
    int64_t _294 = 0; // l
    int64_t _295 = 0; // k
    int64_t _296 = 0; // j
    _jump256:; // Begin body of loop
    _293 += _296;
    _294++;
    if (_294 < c.d1)
    goto _jump256;
    _294 = 0;
    _295++;
    if (_295 < c.d1)
    goto _jump256;
    _295 = 0;
    _296++;
    if (_296 < c.d1)
    goto _jump256;
    // End body of loop
    _292.d0 = _293;
    if (_293 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing total size of heap memory to allocate
    int64_t _297 = 1;
    _297 *= _293;
    _297 *= sizeof(int64_t);
    _292.data = jpl_alloc(_297);
    int64_t _298 = 0; // j
    _jump258:; // Begin body of loop
    int64_t _299 = 0;
    _299 *= _292.d0;
    _299 += _298;
    _292.data[_299] = _298;
    _298++;
    if (_298 < _293)
    goto _jump258;
    // End body of loop
    _286 = _292;
    _jump252:;
    _a1__a1_int64_t _300;
    _300.d0 = 1;
    _300.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _300.data[0] = _286;
    int64_t _301 = 777;
    int64_t _302 = -g.d0;
    int64_t _303 = -_302;
    int64_t _304 = _301 % _303;
    int64_t _305 = -_304;
    if (_305 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_305 < _300.d0)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    int64_t _306 = 0;
    _306 *= _300.d0;
    _306 += _305;
    _a1_int64_t _307 = _300.data[_306];
    _285 = _307;
    goto _jump261;
    _jump248:;
    _a1_int64_t _308;
    // Computing bound for j
    _308.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing total size of heap memory to allocate
    int64_t _309 = 1;
    _309 *= g.d0;
    _309 *= sizeof(int64_t);
    _308.data = jpl_alloc(_309);
    int64_t _310 = 0; // j
    _jump263:; // Begin body of loop
    int64_t _311 = 0;
    _311 *= _308.d0;
    _311 += _310;
    _308.data[_311] = c.d0;
    _310++;
    if (_310 < g.d0)
    goto _jump263;
    // End body of loop
    _285 = _308;
    _jump261:;
    _252 = _285;
    goto _jump264;
    _jump226:;
    _a1_int64_t _312;
    // Computing bound for j
    _312.d0 = f;
    if (f > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing total size of heap memory to allocate
    int64_t _313 = 1;
    _313 *= f;
    _313 *= sizeof(int64_t);
    _312.data = jpl_alloc(_313);
    int64_t _314 = 0; // j
    _jump266:; // Begin body of loop
    int64_t _315 = 792;
    bool _316 = _315 != c.d0;
    bool _317;
    if (!_316)
    goto _jump267;
    int64_t _318;
    // Computing bound for k
    if (c.d0 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for l
    if (g.d1 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    _318 = 0;
    int64_t _319 = 0; // l
    int64_t _320 = 0; // k
    _jump270:; // Begin body of loop
    _318 += c.d1;
    _319++;
    if (_319 < g.d1)
    goto _jump270;
    _319 = 0;
    _320++;
    if (_320 < c.d0)
    goto _jump270;
    // End body of loop
    bool _321 = _318 == c.d1;
    _317 = _321;
    goto _jump271;
    _jump267:;
    _317 = a;
    _jump271:;
    int64_t _322;
    if (!_317)
    goto _jump272;
    int64_t _323;
    // Computing bound for k
    if (c.d1 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing bound for m
    if (c.d1 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    _323 = 0;
    int64_t _324 = 0; // m
    int64_t _325 = 0; // l
    int64_t _326 = 0; // k
    _jump276:; // Begin body of loop
    _323 += _314;
    _324++;
    if (_324 < c.d1)
    goto _jump276;
    _324 = 0;
    _325++;
    if (_325 < c.d0)
    goto _jump276;
    _325 = 0;
    _326++;
    if (_326 < c.d1)
    goto _jump276;
    // End body of loop
    _322 = _323;
    goto _jump277;
    _jump272:;
    _322 = c.d0;
    _jump277:;
    int64_t _327 = 0;
    _327 *= _312.d0;
    _327 += _314;
    _312.data[_327] = _322;
    _314++;
    if (_314 < f)
    goto _jump266;
    // End body of loop
    _252 = _312;
    _jump264:;
    bool _330 = false;
    bool _329 = _330;
    if (0 != _330)
    goto _jump278;
    bool _331 = true;
    _329 = _331;
    _jump278:;
    bool _328 = _329;
    if (0 != _329)
    goto _jump279;
    int64_t _333 = -c.d1;
    bool _334 = true;
    int64_t _335;
    if (!_334)
    goto _jump280;
    int64_t _336 = 442;
    _335 = _336;
    goto _jump281;
    _jump280:;
    int64_t _337 = 906;
    _335 = _337;
    _jump281:;
    if (_333 >= 0)
    goto _jump282;
    fail_assertion("negative array index");
    _jump282:;
    if (_333 < c.d0)
    goto _jump283;
    fail_assertion("index too large");
    _jump283:;
    if (_335 >= 0)
    goto _jump284;
    fail_assertion("negative array index");
    _jump284:;
    if (_335 < c.d1)
    goto _jump285;
    fail_assertion("index too large");
    _jump285:;
    int64_t _338 = 0;
    _338 *= c.d0;
    _338 += _333;
    _338 *= c.d1;
    _338 += _335;
    bool _339 = c.data[_338];
    bool _332 = _339;
    if (0 == _339)
    goto _jump286;
    int64_t _340;
    // Computing bound for l
    if (f > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    // Computing bound for m
    if (_252.d0 > 0) 
    goto _jump288;
    fail_assertion("non-positive loop bound");
    _jump288:;
    // Computing bound for n
    int64_t _341 = 4;
    if (_341 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    _340 = 0;
    int64_t _342 = 0; // n
    int64_t _343 = 0; // m
    int64_t _344 = 0; // l
    _jump290:; // Begin body of loop
    _340 += g.d0;
    _342++;
    if (_342 < _341)
    goto _jump290;
    _342 = 0;
    _343++;
    if (_343 < _252.d0)
    goto _jump290;
    _343 = 0;
    _344++;
    if (_344 < f)
    goto _jump290;
    // End body of loop
    bool _345 = g.d1 != _340;
    _332 = _345;
    _jump286:;
    bool _346 = !_332;
    _328 = _346;
    _jump279:;
    _a3__a3_double _347;
    if (!_328)
    goto _jump291;
    bool _348 = false;
    bool _349 = !_348;
    bool _350;
    if (!_349)
    goto _jump292;
    double _351;
    // Computing bound for l
    int64_t _352 = c.d1 / c.d1;
    if (_352 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    _351 = 0;
    int64_t _353 = 0; // l
    _jump294:; // Begin body of loop
    double _354;
    // Computing bound for m
    if (f > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    _354 = 0;
    int64_t _355 = 0; // m
    _jump296:; // Begin body of loop
    double _356 = 66.0;
    _354 += _356;
    _355++;
    if (_355 < f)
    goto _jump296;
    // End body of loop
    _351 += _354;
    _353++;
    if (_353 < _352)
    goto _jump294;
    // End body of loop
    _a1_double _357;
    // Computing bound for l
    _357.d0 = f;
    if (f > 0) 
    goto _jump297;
    fail_assertion("non-positive loop bound");
    _jump297:;
    // Computing total size of heap memory to allocate
    int64_t _358 = 1;
    _358 *= f;
    _358 *= sizeof(double);
    _357.data = jpl_alloc(_358);
    int64_t _359 = 0; // l
    _jump298:; // Begin body of loop
    double _360 = 91.0;
    int64_t _361 = 0;
    _361 *= _357.d0;
    _361 += _359;
    _357.data[_361] = _360;
    _359++;
    if (_359 < f)
    goto _jump298;
    // End body of loop
    if (g.d1 >= 0)
    goto _jump299;
    fail_assertion("negative array index");
    _jump299:;
    if (g.d1 < _357.d0)
    goto _jump300;
    fail_assertion("index too large");
    _jump300:;
    int64_t _362 = 0;
    _362 *= _357.d0;
    _362 += g.d1;
    double _363 = _357.data[_362];
    bool _364 = _351 <= _363;
    _350 = _364;
    goto _jump301;
    _jump292:;
    bool _365;
    if (!a)
    goto _jump302;
    bool _366 = true;
    _365 = _366;
    goto _jump303;
    _jump302:;
    bool _367 = c.d0 < c.d0;
    _365 = _367;
    _jump303:;
    _350 = _365;
    _jump301:;
    _a3__a3_double _368;
    if (!_350)
    goto _jump304;
    _a3__a3_double _369;
    // Computing bound for l
    _369.d0 = _252.d0;
    if (_252.d0 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing bound for m
    _369.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for n
    int64_t _370 = c.d0 + c.d1;
    _369.d2 = _370;
    if (_370 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    // Computing total size of heap memory to allocate
    int64_t _371 = 1;
    _371 *= _252.d0;
    _371 *= g.d0;
    _371 *= _370;
    _371 *= sizeof(_a3_double);
    _369.data = jpl_alloc(_371);
    int64_t _372 = 0; // n
    int64_t _373 = 0; // m
    int64_t _374 = 0; // l
    _jump308:; // Begin body of loop
    _a3_double _375;
    // Computing bound for o
    _375.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for p
    _375.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    // Computing bound for q
    _375.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= c.d1;
    _376 *= c.d0;
    _376 *= g.d0;
    _376 *= sizeof(double);
    _375.data = jpl_alloc(_376);
    int64_t _377 = 0; // q
    int64_t _378 = 0; // p
    int64_t _379 = 0; // o
    _jump312:; // Begin body of loop
    double _380 = 98.0;
    int64_t _381 = 0;
    _381 *= _375.d0;
    _381 += _379;
    _381 *= _375.d1;
    _381 += _378;
    _381 *= _375.d2;
    _381 += _377;
    _375.data[_381] = _380;
    _377++;
    if (_377 < g.d0)
    goto _jump312;
    _377 = 0;
    _378++;
    if (_378 < c.d0)
    goto _jump312;
    _378 = 0;
    _379++;
    if (_379 < c.d1)
    goto _jump312;
    // End body of loop
    int64_t _382 = 0;
    _382 *= _369.d0;
    _382 += _374;
    _382 *= _369.d1;
    _382 += _373;
    _382 *= _369.d2;
    _382 += _372;
    _369.data[_382] = _375;
    _372++;
    if (_372 < _370)
    goto _jump308;
    _372 = 0;
    _373++;
    if (_373 < g.d0)
    goto _jump308;
    _373 = 0;
    _374++;
    if (_374 < _252.d0)
    goto _jump308;
    // End body of loop
    _a1__a3__a3_double _383;
    _383.d0 = 1;
    _383.data = jpl_alloc(sizeof(_a3__a3_double) * 1);
    _383.data[0] = _369;
    if (g.d1 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (g.d1 < _383.d0)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    int64_t _384 = 0;
    _384 *= _383.d0;
    _384 += g.d1;
    _a3__a3_double _385 = _383.data[_384];
    _368 = _385;
    goto _jump315;
    _jump304:;
    _a3__a3_double _386;
    // Computing bound for l
    _386.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump316;
    fail_assertion("non-positive loop bound");
    _jump316:;
    // Computing bound for m
    _386.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump317;
    fail_assertion("non-positive loop bound");
    _jump317:;
    // Computing bound for n
    int64_t _387 = 701;
    int64_t _388 = -_387;
    _386.d2 = _388;
    if (_388 > 0) 
    goto _jump318;
    fail_assertion("non-positive loop bound");
    _jump318:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= c.d1;
    _389 *= c.d1;
    _389 *= _388;
    _389 *= sizeof(_a3_double);
    _386.data = jpl_alloc(_389);
    int64_t _390 = 0; // n
    int64_t _391 = 0; // m
    int64_t _392 = 0; // l
    _jump319:; // Begin body of loop
    _a3_double _393;
    // Computing bound for o
    _393.d0 = _392;
    if (_392 > 0) 
    goto _jump320;
    fail_assertion("non-positive loop bound");
    _jump320:;
    // Computing bound for p
    _a1_int64_t _394;
    _394.d0 = 2;
    _394.data = jpl_alloc(sizeof(int64_t) * 2);
    _394.data[0] = f;
    _394.data[1] = c.d0;
    int64_t _395 = f / _390;
    if (_395 >= 0)
    goto _jump321;
    fail_assertion("negative array index");
    _jump321:;
    if (_395 < _394.d0)
    goto _jump322;
    fail_assertion("index too large");
    _jump322:;
    int64_t _396 = 0;
    _396 *= _394.d0;
    _396 += _395;
    int64_t _397 = _394.data[_396];
    _393.d1 = _397;
    if (_397 > 0) 
    goto _jump323;
    fail_assertion("non-positive loop bound");
    _jump323:;
    // Computing bound for q
    _393.d2 = _391;
    if (_391 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing total size of heap memory to allocate
    int64_t _398 = 1;
    _398 *= _392;
    _398 *= _397;
    _398 *= _391;
    _398 *= sizeof(double);
    _393.data = jpl_alloc(_398);
    int64_t _399 = 0; // q
    int64_t _400 = 0; // p
    int64_t _401 = 0; // o
    _jump325:; // Begin body of loop
    bool _402 = false;
    double _403;
    if (!_402)
    goto _jump326;
    double _404 = 80.0;
    double _405 = -_404;
    _403 = _405;
    goto _jump327;
    _jump326:;
    double _406 = 49.0;
    _403 = _406;
    _jump327:;
    int64_t _407 = 0;
    _407 *= _393.d0;
    _407 += _401;
    _407 *= _393.d1;
    _407 += _400;
    _407 *= _393.d2;
    _407 += _399;
    _393.data[_407] = _403;
    _399++;
    if (_399 < _391)
    goto _jump325;
    _399 = 0;
    _400++;
    if (_400 < _397)
    goto _jump325;
    _400 = 0;
    _401++;
    if (_401 < _392)
    goto _jump325;
    // End body of loop
    int64_t _408 = 0;
    _408 *= _386.d0;
    _408 += _392;
    _408 *= _386.d1;
    _408 += _391;
    _408 *= _386.d2;
    _408 += _390;
    _386.data[_408] = _393;
    _390++;
    if (_390 < _388)
    goto _jump319;
    _390 = 0;
    _391++;
    if (_391 < c.d1)
    goto _jump319;
    _391 = 0;
    _392++;
    if (_392 < c.d1)
    goto _jump319;
    // End body of loop
    _368 = _386;
    _jump315:;
    _347 = _368;
    goto _jump328;
    _jump291:;
    _a3__a3_double _409;
    // Computing bound for l
    _a3_int64_t _410;
    // Computing bound for l
    _410.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for m
    _410.d1 = _252.d0;
    if (_252.d0 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for n
    int64_t _411;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing bound for m
    if (g.d1 > 0) 
    goto _jump332;
    fail_assertion("non-positive loop bound");
    _jump332:;
    _411 = 0;
    int64_t _412 = 0; // m
    int64_t _413 = 0; // l
    _jump333:; // Begin body of loop
    _411 += c.d0;
    _412++;
    if (_412 < g.d1)
    goto _jump333;
    _412 = 0;
    _413++;
    if (_413 < c.d0)
    goto _jump333;
    // End body of loop
    int64_t _414 = -_411;
    _410.d2 = _414;
    if (_414 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    // Computing total size of heap memory to allocate
    int64_t _415 = 1;
    _415 *= c.d0;
    _415 *= _252.d0;
    _415 *= _414;
    _415 *= sizeof(int64_t);
    _410.data = jpl_alloc(_415);
    int64_t _416 = 0; // n
    int64_t _417 = 0; // m
    int64_t _418 = 0; // l
    _jump335:; // Begin body of loop
    int64_t _419 = c.d1 % g.d1;
    int64_t _420 = 0;
    _420 *= _410.d0;
    _420 += _418;
    _420 *= _410.d1;
    _420 += _417;
    _420 *= _410.d2;
    _420 += _416;
    _410.data[_420] = _419;
    _416++;
    if (_416 < _414)
    goto _jump335;
    _416 = 0;
    _417++;
    if (_417 < _252.d0)
    goto _jump335;
    _417 = 0;
    _418++;
    if (_418 < c.d0)
    goto _jump335;
    // End body of loop
    if (c.d0 >= 0)
    goto _jump336;
    fail_assertion("negative array index");
    _jump336:;
    if (c.d0 < _252.d0)
    goto _jump337;
    fail_assertion("index too large");
    _jump337:;
    int64_t _421 = 0;
    _421 *= _252.d0;
    _421 += c.d0;
    int64_t _422 = _252.data[_421];
    int64_t _423 = c.d0 % _422;
    int64_t _424 = 73;
    if (_423 >= 0)
    goto _jump338;
    fail_assertion("negative array index");
    _jump338:;
    if (_423 < _410.d0)
    goto _jump339;
    fail_assertion("index too large");
    _jump339:;
    if (_424 >= 0)
    goto _jump340;
    fail_assertion("negative array index");
    _jump340:;
    if (_424 < _410.d1)
    goto _jump341;
    fail_assertion("index too large");
    _jump341:;
    if (g.d0 >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (g.d0 < _410.d2)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    int64_t _425 = 0;
    _425 *= _410.d0;
    _425 += _423;
    _425 *= _410.d1;
    _425 += _424;
    _425 *= _410.d2;
    _425 += g.d0;
    int64_t _426 = _410.data[_425];
    _409.d0 = _426;
    if (_426 > 0) 
    goto _jump344;
    fail_assertion("non-positive loop bound");
    _jump344:;
    // Computing bound for m
    int64_t _427 = -c.d1;
    _409.d1 = _427;
    if (_427 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    // Computing bound for n
    _409.d2 = f;
    if (f > 0) 
    goto _jump346;
    fail_assertion("non-positive loop bound");
    _jump346:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= _426;
    _428 *= _427;
    _428 *= f;
    _428 *= sizeof(_a3_double);
    _409.data = jpl_alloc(_428);
    int64_t _429 = 0; // n
    int64_t _430 = 0; // m
    int64_t _431 = 0; // l
    _jump347:; // Begin body of loop
    _a3_bool _432;
    // Computing bound for o
    _432.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing bound for p
    _432.d1 = _430;
    if (_430 > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing bound for q
    _432.d2 = _431;
    if (_431 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing total size of heap memory to allocate
    int64_t _433 = 1;
    _433 *= c.d0;
    _433 *= _430;
    _433 *= _431;
    _433 *= sizeof(bool);
    _432.data = jpl_alloc(_433);
    int64_t _434 = 0; // q
    int64_t _435 = 0; // p
    int64_t _436 = 0; // o
    _jump351:; // Begin body of loop
    int64_t _437 = 0;
    _437 *= _432.d0;
    _437 += _436;
    _437 *= _432.d1;
    _437 += _435;
    _437 *= _432.d2;
    _437 += _434;
    _432.data[_437] = a;
    _434++;
    if (_434 < _431)
    goto _jump351;
    _434 = 0;
    _435++;
    if (_435 < _430)
    goto _jump351;
    _435 = 0;
    _436++;
    if (_436 < c.d0)
    goto _jump351;
    // End body of loop
    int64_t _438 = 843;
    int64_t _439 = _438 * g.d0;
    if (_439 >= 0)
    goto _jump352;
    fail_assertion("negative array index");
    _jump352:;
    if (_439 < _432.d0)
    goto _jump353;
    fail_assertion("index too large");
    _jump353:;
    if (_252.d0 >= 0)
    goto _jump354;
    fail_assertion("negative array index");
    _jump354:;
    if (_252.d0 < _432.d1)
    goto _jump355;
    fail_assertion("index too large");
    _jump355:;
    if (_429 >= 0)
    goto _jump356;
    fail_assertion("negative array index");
    _jump356:;
    if (_429 < _432.d2)
    goto _jump357;
    fail_assertion("index too large");
    _jump357:;
    int64_t _440 = 0;
    _440 *= _432.d0;
    _440 += _439;
    _440 *= _432.d1;
    _440 += _252.d0;
    _440 *= _432.d2;
    _440 += _429;
    bool _441 = _432.data[_440];
    _a3_double _442;
    if (!_441)
    goto _jump358;
    _a2__a3_double _443;
    // Computing bound for o
    _443.d0 = f;
    if (f > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing bound for p
    _443.d1 = _430;
    if (_430 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing total size of heap memory to allocate
    int64_t _444 = 1;
    _444 *= f;
    _444 *= _430;
    _444 *= sizeof(_a3_double);
    _443.data = jpl_alloc(_444);
    int64_t _445 = 0; // p
    int64_t _446 = 0; // o
    _jump361:; // Begin body of loop
    _a3_double _447;
    // Computing bound for q
    _447.d0 = _430;
    if (_430 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing bound for r
    int64_t _448 = 658;
    _447.d1 = _448;
    if (_448 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for s
    _447.d2 = c.d0;
    if (c.d0 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing total size of heap memory to allocate
    int64_t _449 = 1;
    _449 *= _430;
    _449 *= _448;
    _449 *= c.d0;
    _449 *= sizeof(double);
    _447.data = jpl_alloc(_449);
    int64_t _450 = 0; // s
    int64_t _451 = 0; // r
    int64_t _452 = 0; // q
    _jump365:; // Begin body of loop
    double _453 = 63.0;
    int64_t _454 = 0;
    _454 *= _447.d0;
    _454 += _452;
    _454 *= _447.d1;
    _454 += _451;
    _454 *= _447.d2;
    _454 += _450;
    _447.data[_454] = _453;
    _450++;
    if (_450 < c.d0)
    goto _jump365;
    _450 = 0;
    _451++;
    if (_451 < _448)
    goto _jump365;
    _451 = 0;
    _452++;
    if (_452 < _430)
    goto _jump365;
    // End body of loop
    int64_t _455 = 0;
    _455 *= _443.d0;
    _455 += _446;
    _455 *= _443.d1;
    _455 += _445;
    _443.data[_455] = _447;
    _445++;
    if (_445 < _430)
    goto _jump361;
    _445 = 0;
    _446++;
    if (_446 < f)
    goto _jump361;
    // End body of loop
    int64_t _456 = 501;
    int64_t _457 = g.d1 + c.d0;
    if (_456 >= 0)
    goto _jump366;
    fail_assertion("negative array index");
    _jump366:;
    if (_456 < _443.d0)
    goto _jump367;
    fail_assertion("index too large");
    _jump367:;
    if (_457 >= 0)
    goto _jump368;
    fail_assertion("negative array index");
    _jump368:;
    if (_457 < _443.d1)
    goto _jump369;
    fail_assertion("index too large");
    _jump369:;
    int64_t _458 = 0;
    _458 *= _443.d0;
    _458 += _456;
    _458 *= _443.d1;
    _458 += _457;
    _a3_double _459 = _443.data[_458];
    _442 = _459;
    goto _jump370;
    _jump358:;
    _a2__a3_double _460;
    // Computing bound for o
    int64_t _461 = _430 + c.d1;
    _460.d0 = _461;
    if (_461 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing bound for p
    _460.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    // Computing total size of heap memory to allocate
    int64_t _462 = 1;
    _462 *= _461;
    _462 *= g.d1;
    _462 *= sizeof(_a3_double);
    _460.data = jpl_alloc(_462);
    int64_t _463 = 0; // p
    int64_t _464 = 0; // o
    _jump373:; // Begin body of loop
    _a3_double _465;
    // Computing bound for q
    _465.d0 = _463;
    if (_463 > 0) 
    goto _jump374;
    fail_assertion("non-positive loop bound");
    _jump374:;
    // Computing bound for r
    _465.d1 = _430;
    if (_430 > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    // Computing bound for s
    _465.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing total size of heap memory to allocate
    int64_t _466 = 1;
    _466 *= _463;
    _466 *= _430;
    _466 *= g.d0;
    _466 *= sizeof(double);
    _465.data = jpl_alloc(_466);
    int64_t _467 = 0; // s
    int64_t _468 = 0; // r
    int64_t _469 = 0; // q
    _jump377:; // Begin body of loop
    double _470 = 75.0;
    int64_t _471 = 0;
    _471 *= _465.d0;
    _471 += _469;
    _471 *= _465.d1;
    _471 += _468;
    _471 *= _465.d2;
    _471 += _467;
    _465.data[_471] = _470;
    _467++;
    if (_467 < g.d0)
    goto _jump377;
    _467 = 0;
    _468++;
    if (_468 < _430)
    goto _jump377;
    _468 = 0;
    _469++;
    if (_469 < _463)
    goto _jump377;
    // End body of loop
    int64_t _472 = 0;
    _472 *= _460.d0;
    _472 += _464;
    _472 *= _460.d1;
    _472 += _463;
    _460.data[_472] = _465;
    _463++;
    if (_463 < g.d1)
    goto _jump373;
    _463 = 0;
    _464++;
    if (_464 < _461)
    goto _jump373;
    // End body of loop
    int64_t _473 = _431 % g.d1;
    if (_473 >= 0)
    goto _jump378;
    fail_assertion("negative array index");
    _jump378:;
    if (_473 < _460.d0)
    goto _jump379;
    fail_assertion("index too large");
    _jump379:;
    if (_430 >= 0)
    goto _jump380;
    fail_assertion("negative array index");
    _jump380:;
    if (_430 < _460.d1)
    goto _jump381;
    fail_assertion("index too large");
    _jump381:;
    int64_t _474 = 0;
    _474 *= _460.d0;
    _474 += _473;
    _474 *= _460.d1;
    _474 += _430;
    _a3_double _475 = _460.data[_474];
    _442 = _475;
    _jump370:;
    int64_t _476 = 0;
    _476 *= _409.d0;
    _476 += _431;
    _476 *= _409.d1;
    _476 += _430;
    _476 *= _409.d2;
    _476 += _429;
    _409.data[_476] = _442;
    _429++;
    if (_429 < f)
    goto _jump347;
    _429 = 0;
    _430++;
    if (_430 < _427)
    goto _jump347;
    _430 = 0;
    _431++;
    if (_431 < _426)
    goto _jump347;
    // End body of loop
    _347 = _409;
    _jump328:;
    bool _477 = _252.d0 == _252.d0;
    int64_t _478;
    if (!_477)
    goto _jump382;
    _478 = c.d1;
    goto _jump383;
    _jump382:;
    int64_t _479 = 540;
    int64_t _480;
    // Computing bound for l
    if (c.d0 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    // Computing bound for m
    if (c.d1 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing bound for n
    if (c.d0 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    _480 = 0;
    int64_t _481 = 0; // n
    int64_t _482 = 0; // m
    int64_t _483 = 0; // l
    _jump387:; // Begin body of loop
    int64_t _484 = 228;
    _480 += _484;
    _481++;
    if (_481 < c.d0)
    goto _jump387;
    _481 = 0;
    _482++;
    if (_482 < c.d1)
    goto _jump387;
    _482 = 0;
    _483++;
    if (_483 < c.d0)
    goto _jump387;
    // End body of loop
    bool _485 = _479 > _480;
    int64_t _486;
    if (!_485)
    goto _jump388;
    _486 = g.d1;
    goto _jump389;
    _jump388:;
    _486 = c.d0;
    _jump389:;
    _478 = _486;
    _jump383:;
    _a3_int64_t _487;
    // Computing bound for l
    _487.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for m
    _487.d1 = _252.d0;
    if (_252.d0 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for n
    int64_t _488 = 552;
    _487.d2 = _488;
    if (_488 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing total size of heap memory to allocate
    int64_t _489 = 1;
    _489 *= c.d0;
    _489 *= _252.d0;
    _489 *= _488;
    _489 *= sizeof(int64_t);
    _487.data = jpl_alloc(_489);
    int64_t _490 = 0; // n
    int64_t _491 = 0; // m
    int64_t _492 = 0; // l
    _jump393:; // Begin body of loop
    int64_t _493;
    // Computing bound for o
    if (_491 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    _493 = 0;
    int64_t _494 = 0; // o
    _jump395:; // Begin body of loop
    _a3_int64_t _495;
    // Computing bound for p
    int64_t _496 = 122;
    _495.d0 = _496;
    if (_496 > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    // Computing bound for q
    _495.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing bound for r
    _495.d2 = f;
    if (f > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    // Computing total size of heap memory to allocate
    int64_t _497 = 1;
    _497 *= _496;
    _497 *= c.d1;
    _497 *= f;
    _497 *= sizeof(int64_t);
    _495.data = jpl_alloc(_497);
    int64_t _498 = 0; // r
    int64_t _499 = 0; // q
    int64_t _500 = 0; // p
    _jump399:; // Begin body of loop
    int64_t _501 = 0;
    _501 *= _495.d0;
    _501 += _500;
    _501 *= _495.d1;
    _501 += _499;
    _501 *= _495.d2;
    _501 += _498;
    _495.data[_501] = f;
    _498++;
    if (_498 < f)
    goto _jump399;
    _498 = 0;
    _499++;
    if (_499 < c.d1)
    goto _jump399;
    _499 = 0;
    _500++;
    if (_500 < _496)
    goto _jump399;
    // End body of loop
    _a3_int64_t _502;
    // Computing bound for p
    _502.d0 = _490;
    if (_490 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for q
    _502.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for r
    _502.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    // Computing total size of heap memory to allocate
    int64_t _503 = 1;
    _503 *= _490;
    _503 *= g.d1;
    _503 *= g.d1;
    _503 *= sizeof(int64_t);
    _502.data = jpl_alloc(_503);
    int64_t _504 = 0; // r
    int64_t _505 = 0; // q
    int64_t _506 = 0; // p
    _jump403:; // Begin body of loop
    int64_t _507 = 0;
    _507 *= _502.d0;
    _507 += _506;
    _507 *= _502.d1;
    _507 += _505;
    _507 *= _502.d2;
    _507 += _504;
    _502.data[_507] = c.d0;
    _504++;
    if (_504 < g.d1)
    goto _jump403;
    _504 = 0;
    _505++;
    if (_505 < g.d1)
    goto _jump403;
    _505 = 0;
    _506++;
    if (_506 < _490)
    goto _jump403;
    // End body of loop
    if (_491 >= 0)
    goto _jump404;
    fail_assertion("negative array index");
    _jump404:;
    if (_491 < _502.d0)
    goto _jump405;
    fail_assertion("index too large");
    _jump405:;
    if (_252.d0 >= 0)
    goto _jump406;
    fail_assertion("negative array index");
    _jump406:;
    if (_252.d0 < _502.d1)
    goto _jump407;
    fail_assertion("index too large");
    _jump407:;
    if (f >= 0)
    goto _jump408;
    fail_assertion("negative array index");
    _jump408:;
    if (f < _502.d2)
    goto _jump409;
    fail_assertion("index too large");
    _jump409:;
    int64_t _508 = 0;
    _508 *= _502.d0;
    _508 += _491;
    _508 *= _502.d1;
    _508 += _252.d0;
    _508 *= _502.d2;
    _508 += f;
    int64_t _509 = _502.data[_508];
    if (_509 >= 0)
    goto _jump410;
    fail_assertion("negative array index");
    _jump410:;
    if (_509 < _495.d0)
    goto _jump411;
    fail_assertion("index too large");
    _jump411:;
    if (_494 >= 0)
    goto _jump412;
    fail_assertion("negative array index");
    _jump412:;
    if (_494 < _495.d1)
    goto _jump413;
    fail_assertion("index too large");
    _jump413:;
    if (c.d1 >= 0)
    goto _jump414;
    fail_assertion("negative array index");
    _jump414:;
    if (c.d1 < _495.d2)
    goto _jump415;
    fail_assertion("index too large");
    _jump415:;
    int64_t _510 = 0;
    _510 *= _495.d0;
    _510 += _509;
    _510 *= _495.d1;
    _510 += _494;
    _510 *= _495.d2;
    _510 += c.d1;
    int64_t _511 = _495.data[_510];
    _493 += _511;
    _494++;
    if (_494 < _491)
    goto _jump395;
    // End body of loop
    int64_t _512 = 0;
    _512 *= _487.d0;
    _512 += _492;
    _512 *= _487.d1;
    _512 += _491;
    _512 *= _487.d2;
    _512 += _490;
    _487.data[_512] = _493;
    _490++;
    if (_490 < _488)
    goto _jump393;
    _490 = 0;
    _491++;
    if (_491 < _252.d0)
    goto _jump393;
    _491 = 0;
    _492++;
    if (_492 < c.d0)
    goto _jump393;
    // End body of loop
    int64_t _513 = 688;
    int64_t _514;
    // Computing bound for l
    if (g.d0 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for m
    int64_t _515 = 153;
    if (_515 > 0) 
    goto _jump417;
    fail_assertion("non-positive loop bound");
    _jump417:;
    _514 = 0;
    int64_t _516 = 0; // m
    int64_t _517 = 0; // l
    _jump418:; // Begin body of loop
    int64_t _518 = 427;
    _514 += _518;
    _516++;
    if (_516 < _515)
    goto _jump418;
    _516 = 0;
    _517++;
    if (_517 < g.d0)
    goto _jump418;
    // End body of loop
    if (c.d1 >= 0)
    goto _jump419;
    fail_assertion("negative array index");
    _jump419:;
    if (c.d1 < _487.d0)
    goto _jump420;
    fail_assertion("index too large");
    _jump420:;
    if (_513 >= 0)
    goto _jump421;
    fail_assertion("negative array index");
    _jump421:;
    if (_513 < _487.d1)
    goto _jump422;
    fail_assertion("index too large");
    _jump422:;
    if (_514 >= 0)
    goto _jump423;
    fail_assertion("negative array index");
    _jump423:;
    if (_514 < _487.d2)
    goto _jump424;
    fail_assertion("index too large");
    _jump424:;
    int64_t _519 = 0;
    _519 *= _487.d0;
    _519 += c.d1;
    _519 *= _487.d1;
    _519 += _513;
    _519 *= _487.d2;
    _519 += _514;
    int64_t _520 = _487.data[_519];
    if (_478 >= 0)
    goto _jump425;
    fail_assertion("negative array index");
    _jump425:;
    if (_478 < _347.d0)
    goto _jump426;
    fail_assertion("index too large");
    _jump426:;
    if (f >= 0)
    goto _jump427;
    fail_assertion("negative array index");
    _jump427:;
    if (f < _347.d1)
    goto _jump428;
    fail_assertion("index too large");
    _jump428:;
    if (_520 >= 0)
    goto _jump429;
    fail_assertion("negative array index");
    _jump429:;
    if (_520 < _347.d2)
    goto _jump430;
    fail_assertion("index too large");
    _jump430:;
    int64_t _521 = 0;
    _521 *= _347.d0;
    _521 += _478;
    _521 *= _347.d1;
    _521 += f;
    _521 *= _347.d2;
    _521 += _520;
    _a3_double _522 = _347.data[_521];
}

bool f(double g, _a2_double h) {
    bool _0 = true;
    if (0 != _0)
    goto _jump545;
    fail_assertion("k");
    _jump545:;
    bool _1 = true;
    if (0 != _1)
    goto _jump546;
    fail_assertion("k");
    _jump546:;
    double _2;
    // Computing bound for k
    int64_t _3;
    // Computing bound for k
    int64_t _4 = 746;
    if (_4 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    _3 = 0;
    int64_t _5 = 0; // k
    _jump548:; // Begin body of loop
    int64_t _6 = 773;
    _3 += _6;
    _5++;
    if (_5 < _4)
    goto _jump548;
    // End body of loop
    if (_3 > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    _2 = 0;
    int64_t _7 = 0; // k
    _jump550:; // Begin body of loop
    double _8 = 97.0;
    _2 += _8;
    _7++;
    if (_7 < _3)
    goto _jump550;
    // End body of loop
    _a3_int64_t _9;
    // Computing bound for l
    int64_t _10 = 92;
    _9.d0 = _10;
    if (_10 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing bound for m
    _9.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    // Computing bound for n
    int64_t _11;
    // Computing bound for l
    bool _12 = false;
    double _13;
    // Computing bound for l
    if (h.d1 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for m
    if (d > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for n
    int64_t _14 = -h.d1;
    if (_14 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    _13 = 0;
    int64_t _15 = 0; // n
    int64_t _16 = 0; // m
    int64_t _17 = 0; // l
    _jump556:; // Begin body of loop
    double _18;
    // Computing bound for o
    if (e > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for p
    if (h.d0 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing bound for q
    if (_17 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    _18 = 0;
    int64_t _19 = 0; // q
    int64_t _20 = 0; // p
    int64_t _21 = 0; // o
    _jump560:; // Begin body of loop
    _18 += g;
    _19++;
    if (_19 < _17)
    goto _jump560;
    _19 = 0;
    _20++;
    if (_20 < h.d0)
    goto _jump560;
    _20 = 0;
    _21++;
    if (_21 < e)
    goto _jump560;
    // End body of loop
    _13 += _18;
    _15++;
    if (_15 < _14)
    goto _jump556;
    _15 = 0;
    _16++;
    if (_16 < d)
    goto _jump556;
    _16 = 0;
    _17++;
    if (_17 < h.d1)
    goto _jump556;
    // End body of loop
    bool _22 = false;
    _a2_double _23;
    if (!_22)
    goto _jump561;
    _23 = h;
    goto _jump562;
    _jump561:;
    _a2_double _24;
    // Computing bound for l
    _24.d0 = e;
    if (e > 0) 
    goto _jump563;
    fail_assertion("non-positive loop bound");
    _jump563:;
    // Computing bound for m
    _24.d1 = e;
    if (e > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= e;
    _25 *= e;
    _25 *= sizeof(double);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // m
    int64_t _27 = 0; // l
    _jump565:; // Begin body of loop
    double _28 = 84.0;
    int64_t _29 = 0;
    _29 *= _24.d0;
    _29 += _27;
    _29 *= _24.d1;
    _29 += _26;
    _24.data[_29] = _28;
    _26++;
    if (_26 < e)
    goto _jump565;
    _26 = 0;
    _27++;
    if (_27 < e)
    goto _jump565;
    // End body of loop
    _23 = _24;
    _jump562:;
    bool _30 = f(_13, _23);
    bool _31 = _12 != _30;
    int64_t _32;
    if (!_31)
    goto _jump566;
    _32 = h.d0;
    goto _jump567;
    _jump566:;
    _32 = e;
    _jump567:;
    if (_32 > 0) 
    goto _jump568;
    fail_assertion("non-positive loop bound");
    _jump568:;
    _11 = 0;
    int64_t _33 = 0; // l
    _jump569:; // Begin body of loop
    _a3_int64_t _34;
    // Computing bound for m
    _34.d0 = d;
    if (d > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for n
    bool _35 = e >= h.d1;
    int64_t _36;
    if (!_35)
    goto _jump571;
    int64_t _37 = -e;
    _36 = _37;
    goto _jump572;
    _jump571:;
    int64_t _38;
    // Computing bound for m
    if (_33 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    // Computing bound for n
    int64_t _39 = 855;
    if (_39 > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    _38 = 0;
    int64_t _40 = 0; // n
    int64_t _41 = 0; // m
    _jump575:; // Begin body of loop
    _38 += h.d0;
    _40++;
    if (_40 < _39)
    goto _jump575;
    _40 = 0;
    _41++;
    if (_41 < _33)
    goto _jump575;
    // End body of loop
    _36 = _38;
    _jump572:;
    _34.d1 = _36;
    if (_36 > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing bound for o
    _34.d2 = h.d0;
    if (h.d0 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= d;
    _42 *= _36;
    _42 *= h.d0;
    _42 *= sizeof(int64_t);
    _34.data = jpl_alloc(_42);
    int64_t _43 = 0; // o
    int64_t _44 = 0; // n
    int64_t _45 = 0; // m
    _jump578:; // Begin body of loop
    int64_t _46 = 0;
    _46 *= _34.d0;
    _46 += _45;
    _46 *= _34.d1;
    _46 += _44;
    _46 *= _34.d2;
    _46 += _43;
    _34.data[_46] = _33;
    _43++;
    if (_43 < h.d0)
    goto _jump578;
    _43 = 0;
    _44++;
    if (_44 < _36)
    goto _jump578;
    _44 = 0;
    _45++;
    if (_45 < d)
    goto _jump578;
    // End body of loop
    _a1_int64_t _47;
    // Computing bound for m
    int64_t _48 = 885;
    int64_t _49 = _48 % e;
    _47.d0 = _49;
    if (_49 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _49;
    _50 *= sizeof(int64_t);
    _47.data = jpl_alloc(_50);
    int64_t _51 = 0; // m
    _jump580:; // Begin body of loop
    int64_t _52 = 0;
    _52 *= _47.d0;
    _52 += _51;
    _47.data[_52] = _51;
    _51++;
    if (_51 < _49)
    goto _jump580;
    // End body of loop
    int64_t _53;
    // Computing bound for m
    if (h.d0 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    _53 = 0;
    int64_t _54 = 0; // m
    _jump582:; // Begin body of loop
    int64_t _55 = 838;
    _53 += _55;
    _54++;
    if (_54 < h.d0)
    goto _jump582;
    // End body of loop
    if (_53 >= 0)
    goto _jump583;
    fail_assertion("negative array index");
    _jump583:;
    if (_53 < _47.d0)
    goto _jump584;
    fail_assertion("index too large");
    _jump584:;
    int64_t _56 = 0;
    _56 *= _47.d0;
    _56 += _53;
    int64_t _57 = _47.data[_56];
    if (_57 >= 0)
    goto _jump585;
    fail_assertion("negative array index");
    _jump585:;
    if (_57 < _34.d0)
    goto _jump586;
    fail_assertion("index too large");
    _jump586:;
    if (e >= 0)
    goto _jump587;
    fail_assertion("negative array index");
    _jump587:;
    if (e < _34.d1)
    goto _jump588;
    fail_assertion("index too large");
    _jump588:;
    if (h.d1 >= 0)
    goto _jump589;
    fail_assertion("negative array index");
    _jump589:;
    if (h.d1 < _34.d2)
    goto _jump590;
    fail_assertion("index too large");
    _jump590:;
    int64_t _58 = 0;
    _58 *= _34.d0;
    _58 += _57;
    _58 *= _34.d1;
    _58 += e;
    _58 *= _34.d2;
    _58 += h.d1;
    int64_t _59 = _34.data[_58];
    int64_t _60 = -_59;
    _11 += _60;
    _33++;
    if (_33 < _32)
    goto _jump569;
    // End body of loop
    _9.d2 = _11;
    if (_11 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= _10;
    _61 *= h.d0;
    _61 *= _11;
    _61 *= sizeof(int64_t);
    _9.data = jpl_alloc(_61);
    int64_t _62 = 0; // n
    int64_t _63 = 0; // m
    int64_t _64 = 0; // l
    _jump592:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _9.d0;
    _65 += _64;
    _65 *= _9.d1;
    _65 += _63;
    _65 *= _9.d2;
    _65 += _62;
    _9.data[_65] = _63;
    _62++;
    if (_62 < _11)
    goto _jump592;
    _62 = 0;
    _63++;
    if (_63 < h.d0)
    goto _jump592;
    _63 = 0;
    _64++;
    if (_64 < _10)
    goto _jump592;
    // End body of loop
    bool _66 = a;
    if (0 == a)
    goto _jump593;
    int64_t _67;
    // Computing bound for r
    int64_t _68 = _9.d0 % d;
    if (_68 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    _67 = 0;
    int64_t _69 = 0; // r
    _jump595:; // Begin body of loop
    _67 += h.d0;
    _69++;
    if (_69 < _68)
    goto _jump595;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump596;
    fail_assertion("negative array index");
    _jump596:;
    if (h.d1 < c.d0)
    goto _jump597;
    fail_assertion("index too large");
    _jump597:;
    if (_67 >= 0)
    goto _jump598;
    fail_assertion("negative array index");
    _jump598:;
    if (_67 < c.d1)
    goto _jump599;
    fail_assertion("index too large");
    _jump599:;
    int64_t _70 = 0;
    _70 *= c.d0;
    _70 += h.d1;
    _70 *= c.d1;
    _70 += _67;
    bool _71 = c.data[_70];
    bool _72 = a == _71;
    bool _73 = !_72;
    bool _74;
    if (!_73)
    goto _jump600;
    bool _75 = false;
    _74 = _75;
    goto _jump601;
    _jump600:;
    bool _76 = false;
    bool _77;
    if (!_76)
    goto _jump602;
    bool _78 = d >= _9.d0;
    _77 = _78;
    goto _jump603;
    _jump602:;
    bool _80 = !a;
    bool _79 = _80;
    if (0 != _80)
    goto _jump604;
    _79 = a;
    _jump604:;
    _77 = _79;
    _jump603:;
    bool _81 = !_77;
    bool _82 = !_81;
    _74 = _82;
    _jump601:;
    _66 = _74;
    _jump593:;
    return _66;
}

void_t h(int64_t i, rgba j, int64_t k) {
    double _0;
    // Computing bound for l
    if (e > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    _0 = 0;
    int64_t _1 = 0; // l
    _jump606:; // Begin body of loop
    double _2 = 23.0;
    _0 += _2;
    _1++;
    if (_1 < e)
    goto _jump606;
    // End body of loop
    _a1_rgba _3;
    // Computing bound for m
    int64_t _4 = 679;
    int64_t _5 = e * _4;
    _3.d0 = _5;
    if (_5 > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _5;
    _6 *= sizeof(rgba);
    _3.data = jpl_alloc(_6);
    int64_t _7 = 0; // m
    _jump608:; // Begin body of loop
    double _8 = -_0;
    double _9 = _0 - _0;
    double _10 = _8 / _9;
    double _11 = -_10;
    double _12 = 3.0;
    double _13 = j.g;
    rgba _14 = { _11, _12, _0, _13 };
    int64_t _15 = 0;
    _15 *= _3.d0;
    _15 += _7;
    _3.data[_15] = _14;
    _7++;
    if (_7 < _5)
    goto _jump608;
    // End body of loop
    if (e >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (e < _3.d0)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _16 = 0;
    _16 *= _3.d0;
    _16 += e;
    rgba _17 = _3.data[_16];
    _a2_double _18;
    // Computing bound for n
    _18.d0 = e;
    if (e > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for o
    _18.d1 = d;
    if (d > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= e;
    _19 *= d;
    _19 *= sizeof(double);
    _18.data = jpl_alloc(_19);
    int64_t _20 = 0; // o
    int64_t _21 = 0; // n
    _jump613:; // Begin body of loop
    double _22 = 21.0;
    int64_t _23 = 0;
    _23 *= _18.d0;
    _23 += _21;
    _23 *= _18.d1;
    _23 += _20;
    _18.data[_23] = _22;
    _20++;
    if (_20 < d)
    goto _jump613;
    _20 = 0;
    _21++;
    if (_21 < e)
    goto _jump613;
    // End body of loop
    int64_t _24 = i % k;
    if (_24 >= 0)
    goto _jump614;
    fail_assertion("negative array index");
    _jump614:;
    if (_24 < _18.d0)
    goto _jump615;
    fail_assertion("index too large");
    _jump615:;
    if (e >= 0)
    goto _jump616;
    fail_assertion("negative array index");
    _jump616:;
    if (e < _18.d1)
    goto _jump617;
    fail_assertion("index too large");
    _jump617:;
    int64_t _25 = 0;
    _25 *= _18.d0;
    _25 += _24;
    _25 *= _18.d1;
    _25 += e;
    double _26 = _18.data[_25];
    bool _27 = _26 <= _0;
    _a1_bool _28;
    if (!_27)
    goto _jump618;
    bool _29 = false;
    bool _30 = false;
    _a1_bool _31;
    _31.d0 = 2;
    _31.data = jpl_alloc(sizeof(bool) * 2);
    _31.data[0] = _29;
    _31.data[1] = _30;
    bool _32 = d < d;
    bool _33 = !a;
    _a1_bool _34;
    _34.d0 = 2;
    _34.data = jpl_alloc(sizeof(bool) * 2);
    _34.data[0] = _32;
    _34.data[1] = _33;
    _a1__a1_bool _35;
    _35.d0 = 2;
    _35.data = jpl_alloc(sizeof(_a1_bool) * 2);
    _35.data[0] = _31;
    _35.data[1] = _34;
    int64_t _36;
    // Computing bound for n
    if (i > 0) 
    goto _jump619;
    fail_assertion("non-positive loop bound");
    _jump619:;
    // Computing bound for o
    if (i > 0) 
    goto _jump620;
    fail_assertion("non-positive loop bound");
    _jump620:;
    _36 = 0;
    int64_t _37 = 0; // o
    int64_t _38 = 0; // n
    _jump621:; // Begin body of loop
    _36 += _37;
    _37++;
    if (_37 < i)
    goto _jump621;
    _37 = 0;
    _38++;
    if (_38 < i)
    goto _jump621;
    // End body of loop
    int64_t _39 = _36 * d;
    if (_39 >= 0)
    goto _jump622;
    fail_assertion("negative array index");
    _jump622:;
    if (_39 < _35.d0)
    goto _jump623;
    fail_assertion("index too large");
    _jump623:;
    int64_t _40 = 0;
    _40 *= _35.d0;
    _40 += _39;
    _a1_bool _41 = _35.data[_40];
    _28 = _41;
    goto _jump624;
    _jump618:;
    _a1__a1_bool _42;
    // Computing bound for n
    int64_t _43 = -k;
    _42.d0 = _43;
    if (_43 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing total size of heap memory to allocate
    int64_t _44 = 1;
    _44 *= _43;
    _44 *= sizeof(_a1_bool);
    _42.data = jpl_alloc(_44);
    int64_t _45 = 0; // n
    _jump626:; // Begin body of loop
    _a1_bool _46;
    _46.d0 = 2;
    _46.data = jpl_alloc(sizeof(bool) * 2);
    _46.data[0] = a;
    _46.data[1] = a;
    int64_t _47 = 0;
    _47 *= _42.d0;
    _47 += _45;
    _42.data[_47] = _46;
    _45++;
    if (_45 < _43)
    goto _jump626;
    // End body of loop
    int64_t _48;
    if (!a)
    goto _jump627;
    _48 = d;
    goto _jump628;
    _jump627:;
    _48 = e;
    _jump628:;
    int64_t _49 = -d;
    int64_t _50 = _48 * _49;
    int64_t _51 = _50 / d;
    if (_51 >= 0)
    goto _jump629;
    fail_assertion("negative array index");
    _jump629:;
    if (_51 < _42.d0)
    goto _jump630;
    fail_assertion("index too large");
    _jump630:;
    int64_t _52 = 0;
    _52 *= _42.d0;
    _52 += _51;
    _a1_bool _53 = _42.data[_52];
    _28 = _53;
    _jump624:;
    int64_t _54 = -i;
    int64_t _55 = 306;
    bool _56 = false;
    g _57 = { _56, i };
    int64_t _58 = _57.b;
    int64_t _59 = _55 - _58;
    int64_t _60 = _54 + _59;
    if (_60 >= 0)
    goto _jump631;
    fail_assertion("negative array index");
    _jump631:;
    if (_60 < _28.d0)
    goto _jump632;
    fail_assertion("index too large");
    _jump632:;
    int64_t _61 = 0;
    _61 *= _28.d0;
    _61 += _60;
    bool _62 = _28.data[_61];
    bool _63 = !_62;
    _a2_double _64;
    // Computing bound for o
    _a1_int64_t _65;
    _65.d0 = 1;
    _65.data = jpl_alloc(sizeof(int64_t) * 1);
    _65.data[0] = d;
    bool _66 = false;
    int64_t _67;
    // Computing bound for o
    int64_t _68 = 741;
    if (_68 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing bound for p
    if (e > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing bound for q
    int64_t _69 = 703;
    if (_69 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    _67 = 0;
    int64_t _70 = 0; // q
    int64_t _71 = 0; // p
    int64_t _72 = 0; // o
    _jump636:; // Begin body of loop
    _67 += d;
    _70++;
    if (_70 < _69)
    goto _jump636;
    _70 = 0;
    _71++;
    if (_71 < e)
    goto _jump636;
    _71 = 0;
    _72++;
    if (_72 < _68)
    goto _jump636;
    // End body of loop
    int64_t _73 = e % e;
    int64_t _74 = _67 % _73;
    g _75 = { _66, _74 };
    int64_t _76 = _75.b;
    int64_t _77 = -_76;
    if (_77 >= 0)
    goto _jump637;
    fail_assertion("negative array index");
    _jump637:;
    if (_77 < _65.d0)
    goto _jump638;
    fail_assertion("index too large");
    _jump638:;
    int64_t _78 = 0;
    _78 *= _65.d0;
    _78 += _77;
    int64_t _79 = _65.data[_78];
    _64.d0 = _79;
    if (_79 > 0) 
    goto _jump639;
    fail_assertion("non-positive loop bound");
    _jump639:;
    // Computing bound for p
    int64_t _80 = -d;
    _64.d1 = _80;
    if (_80 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= _79;
    _81 *= _80;
    _81 *= sizeof(double);
    _64.data = jpl_alloc(_81);
    int64_t _82 = 0; // p
    int64_t _83 = 0; // o
    _jump641:; // Begin body of loop
    _a2_double _84;
    // Computing bound for q
    _84.d0 = e;
    if (e > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing bound for r
    _a2_int64_t _85;
    // Computing bound for q
    int64_t _86;
    // Computing bound for q
    int64_t _87 = 164;
    if (_87 > 0) 
    goto _jump643;
    fail_assertion("non-positive loop bound");
    _jump643:;
    _86 = 0;
    int64_t _88 = 0; // q
    _jump644:; // Begin body of loop
    _86 += k;
    _88++;
    if (_88 < _87)
    goto _jump644;
    // End body of loop
    _85.d0 = _86;
    if (_86 > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    // Computing bound for r
    _85.d1 = k;
    if (k > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _86;
    _89 *= k;
    _89 *= sizeof(int64_t);
    _85.data = jpl_alloc(_89);
    int64_t _90 = 0; // r
    int64_t _91 = 0; // q
    _jump647:; // Begin body of loop
    g _92 = { a, _90 };
    int64_t _93 = _92.b;
    int64_t _94 = 0;
    _94 *= _85.d0;
    _94 += _91;
    _94 *= _85.d1;
    _94 += _90;
    _85.data[_94] = _93;
    _90++;
    if (_90 < k)
    goto _jump647;
    _90 = 0;
    _91++;
    if (_91 < _86)
    goto _jump647;
    // End body of loop
    _a2_int64_t _95;
    if (!a)
    goto _jump648;
    _a2_int64_t _96;
    // Computing bound for q
    int64_t _97 = 259;
    _96.d0 = _97;
    if (_97 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    // Computing bound for r
    _96.d1 = _82;
    if (_82 > 0) 
    goto _jump650;
    fail_assertion("non-positive loop bound");
    _jump650:;
    // Computing total size of heap memory to allocate
    int64_t _98 = 1;
    _98 *= _97;
    _98 *= _82;
    _98 *= sizeof(int64_t);
    _96.data = jpl_alloc(_98);
    int64_t _99 = 0; // r
    int64_t _100 = 0; // q
    _jump651:; // Begin body of loop
    int64_t _101 = 0;
    _101 *= _96.d0;
    _101 += _100;
    _101 *= _96.d1;
    _101 += _99;
    _96.data[_101] = e;
    _99++;
    if (_99 < _82)
    goto _jump651;
    _99 = 0;
    _100++;
    if (_100 < _97)
    goto _jump651;
    // End body of loop
    _95 = _96;
    goto _jump652;
    _jump648:;
    _a2_int64_t _102;
    // Computing bound for q
    _102.d0 = k;
    if (k > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    // Computing bound for r
    _102.d1 = e;
    if (e > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= k;
    _103 *= e;
    _103 *= sizeof(int64_t);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // r
    int64_t _105 = 0; // q
    _jump655:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _102.d0;
    _106 += _105;
    _106 *= _102.d1;
    _106 += _104;
    _102.data[_106] = k;
    _104++;
    if (_104 < e)
    goto _jump655;
    _104 = 0;
    _105++;
    if (_105 < k)
    goto _jump655;
    // End body of loop
    _95 = _102;
    _jump652:;
    int64_t _107 = -d;
    int64_t _108 = _107 * k;
    bool _109 = false;
    g _110 = { _109, _83 };
    int64_t _111 = _110.b;
    if (_108 >= 0)
    goto _jump656;
    fail_assertion("negative array index");
    _jump656:;
    if (_108 < _95.d0)
    goto _jump657;
    fail_assertion("index too large");
    _jump657:;
    if (_111 >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (_111 < _95.d1)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    int64_t _112 = 0;
    _112 *= _95.d0;
    _112 += _108;
    _112 *= _95.d1;
    _112 += _111;
    int64_t _113 = _95.data[_112];
    if (_113 >= 0)
    goto _jump660;
    fail_assertion("negative array index");
    _jump660:;
    if (_113 < _85.d0)
    goto _jump661;
    fail_assertion("index too large");
    _jump661:;
    if (i >= 0)
    goto _jump662;
    fail_assertion("negative array index");
    _jump662:;
    if (i < _85.d1)
    goto _jump663;
    fail_assertion("index too large");
    _jump663:;
    int64_t _114 = 0;
    _114 *= _85.d0;
    _114 += _113;
    _114 *= _85.d1;
    _114 += i;
    int64_t _115 = _85.data[_114];
    _84.d1 = _115;
    if (_115 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= e;
    _116 *= _115;
    _116 *= sizeof(double);
    _84.data = jpl_alloc(_116);
    int64_t _117 = 0; // r
    int64_t _118 = 0; // q
    _jump665:; // Begin body of loop
    int64_t _119 = 0;
    _119 *= _84.d0;
    _119 += _118;
    _119 *= _84.d1;
    _119 += _117;
    _84.data[_119] = _0;
    _117++;
    if (_117 < _115)
    goto _jump665;
    _117 = 0;
    _118++;
    if (_118 < e)
    goto _jump665;
    // End body of loop
    int64_t _120;
    if (!_63)
    goto _jump666;
    _120 = k;
    goto _jump667;
    _jump666:;
    _120 = _82;
    _jump667:;
    int64_t _121 = -_120;
    if (e >= 0)
    goto _jump668;
    fail_assertion("negative array index");
    _jump668:;
    if (e < _84.d0)
    goto _jump669;
    fail_assertion("index too large");
    _jump669:;
    if (_121 >= 0)
    goto _jump670;
    fail_assertion("negative array index");
    _jump670:;
    if (_121 < _84.d1)
    goto _jump671;
    fail_assertion("index too large");
    _jump671:;
    int64_t _122 = 0;
    _122 *= _84.d0;
    _122 += e;
    _122 *= _84.d1;
    _122 += _121;
    double _123 = _84.data[_122];
    int64_t _124 = 0;
    _124 *= _64.d0;
    _124 += _83;
    _124 *= _64.d1;
    _124 += _82;
    _64.data[_124] = _123;
    _82++;
    if (_82 < _80)
    goto _jump641;
    _82 = 0;
    _83++;
    if (_83 < _79)
    goto _jump641;
    // End body of loop
    double _125 = 69.0;
    double _126 = 66.0;
    bool _127 = _125 != _126;
    bool _128;
    if (!_127)
    goto _jump672;
    bool _129 = true;
    bool _130 = !_129;
    double _131;
    // Computing bound for p
    if (k > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    // Computing bound for q
    if (i > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    _131 = 0;
    int64_t _132 = 0; // q
    int64_t _133 = 0; // p
    _jump675:; // Begin body of loop
    _131 += _0;
    _132++;
    if (_132 < i)
    goto _jump675;
    _132 = 0;
    _133++;
    if (_133 < k)
    goto _jump675;
    // End body of loop
    bool _134 = f(_131, _64);
    _a1_bool _135;
    _135.d0 = 2;
    _135.data = jpl_alloc(sizeof(bool) * 2);
    _135.data[0] = _130;
    _135.data[1] = _134;
    bool _136 = false;
    int64_t _137;
    if (!_136)
    goto _jump676;
    bool _138 = _63;
    if (0 != _63)
    goto _jump677;
    _138 = _63;
    _jump677:;
    int64_t _139;
    if (!_138)
    goto _jump678;
    int64_t _140 = 912;
    int64_t _141 = _140 / i;
    _139 = _141;
    goto _jump679;
    _jump678:;
    int64_t _142 = 203;
    _139 = _142;
    _jump679:;
    _137 = _139;
    goto _jump680;
    _jump676:;
    int64_t _143;
    // Computing bound for p
    int64_t _144 = 712;
    if (_144 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    // Computing bound for q
    if (i > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing bound for r
    int64_t _145 = -i;
    if (_145 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    _143 = 0;
    int64_t _146 = 0; // r
    int64_t _147 = 0; // q
    int64_t _148 = 0; // p
    _jump684:; // Begin body of loop
    int64_t _149;
    // Computing bound for s
    if (i > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    _149 = 0;
    int64_t _150 = 0; // s
    _jump686:; // Begin body of loop
    _149 += _147;
    _150++;
    if (_150 < i)
    goto _jump686;
    // End body of loop
    _143 += _149;
    _146++;
    if (_146 < _145)
    goto _jump684;
    _146 = 0;
    _147++;
    if (_147 < i)
    goto _jump684;
    _147 = 0;
    _148++;
    if (_148 < _144)
    goto _jump684;
    // End body of loop
    _137 = _143;
    _jump680:;
    if (_137 >= 0)
    goto _jump687;
    fail_assertion("negative array index");
    _jump687:;
    if (_137 < _135.d0)
    goto _jump688;
    fail_assertion("index too large");
    _jump688:;
    int64_t _151 = 0;
    _151 *= _135.d0;
    _151 += _137;
    bool _152 = _135.data[_151];
    _128 = _152;
    goto _jump689;
    _jump672:;
    _a3_g _153;
    // Computing bound for p
    _153.d0 = i;
    if (i > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    // Computing bound for q
    int64_t _154;
    // Computing bound for p
    if (i > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    _154 = 0;
    int64_t _155 = 0; // p
    _jump692:; // Begin body of loop
    _154 += _155;
    _155++;
    if (_155 < i)
    goto _jump692;
    // End body of loop
    _153.d1 = _154;
    if (_154 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    // Computing bound for r
    _153.d2 = k;
    if (k > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= i;
    _156 *= _154;
    _156 *= k;
    _156 *= sizeof(g);
    _153.data = jpl_alloc(_156);
    int64_t _157 = 0; // r
    int64_t _158 = 0; // q
    int64_t _159 = 0; // p
    _jump695:; // Begin body of loop
    g _160 = { _63, d };
    int64_t _161 = 0;
    _161 *= _153.d0;
    _161 += _159;
    _161 *= _153.d1;
    _161 += _158;
    _161 *= _153.d2;
    _161 += _157;
    _153.data[_161] = _160;
    _157++;
    if (_157 < k)
    goto _jump695;
    _157 = 0;
    _158++;
    if (_158 < _154)
    goto _jump695;
    _158 = 0;
    _159++;
    if (_159 < i)
    goto _jump695;
    // End body of loop
    int64_t _162;
    // Computing bound for p
    int64_t _163 = 125;
    if (_163 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for q
    int64_t _164 = -k;
    if (_164 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    _162 = 0;
    int64_t _165 = 0; // q
    int64_t _166 = 0; // p
    _jump698:; // Begin body of loop
    int64_t _167 = d - k;
    _162 += _167;
    _165++;
    if (_165 < _164)
    goto _jump698;
    _165 = 0;
    _166++;
    if (_166 < _163)
    goto _jump698;
    // End body of loop
    _a3_int64_t _168;
    // Computing bound for p
    _168.d0 = k;
    if (k > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    // Computing bound for q
    _168.d1 = d;
    if (d > 0) 
    goto _jump700;
    fail_assertion("non-positive loop bound");
    _jump700:;
    // Computing bound for r
    _168.d2 = k;
    if (k > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= k;
    _169 *= d;
    _169 *= k;
    _169 *= sizeof(int64_t);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // r
    int64_t _171 = 0; // q
    int64_t _172 = 0; // p
    _jump702:; // Begin body of loop
    int64_t _173 = 0;
    _173 *= _168.d0;
    _173 += _172;
    _173 *= _168.d1;
    _173 += _171;
    _173 *= _168.d2;
    _173 += _170;
    _168.data[_173] = e;
    _170++;
    if (_170 < k)
    goto _jump702;
    _170 = 0;
    _171++;
    if (_171 < d)
    goto _jump702;
    _171 = 0;
    _172++;
    if (_172 < k)
    goto _jump702;
    // End body of loop
    int64_t _174 = 293;
    if (i >= 0)
    goto _jump703;
    fail_assertion("negative array index");
    _jump703:;
    if (i < _168.d0)
    goto _jump704;
    fail_assertion("index too large");
    _jump704:;
    if (d >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (d < _168.d1)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    if (_174 >= 0)
    goto _jump707;
    fail_assertion("negative array index");
    _jump707:;
    if (_174 < _168.d2)
    goto _jump708;
    fail_assertion("index too large");
    _jump708:;
    int64_t _175 = 0;
    _175 *= _168.d0;
    _175 += i;
    _175 *= _168.d1;
    _175 += d;
    _175 *= _168.d2;
    _175 += _174;
    int64_t _176 = _168.data[_175];
    int64_t _177 = 776;
    if (_162 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (_162 < _153.d0)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    if (_176 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (_176 < _153.d1)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    if (_177 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_177 < _153.d2)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    int64_t _178 = 0;
    _178 *= _153.d0;
    _178 += _162;
    _178 *= _153.d1;
    _178 += _176;
    _178 *= _153.d2;
    _178 += _177;
    g _179 = _153.data[_178];
    bool _180 = _179.a;
    _128 = _180;
    _jump689:;
    bool _181 = !_128;
    _a1_double _182;
    if (!_181)
    goto _jump715;
    bool _183 = f(_0, _64);
    bool _184 = !_183;
    double _185;
    if (!_184)
    goto _jump716;
    double _186 = _17.r;
    _185 = _186;
    goto _jump717;
    _jump716:;
    double _187 = 56.0;
    _185 = _187;
    _jump717:;
    double _188 = 60.0;
    rgba _189 = { _0, _0, _185, _188 };
    double _190 = _189.b;
    _a1_double _191;
    _191.d0 = 1;
    _191.data = jpl_alloc(sizeof(double) * 1);
    _191.data[0] = _190;
    _182 = _191;
    goto _jump718;
    _jump715:;
    _a1_double _192;
    // Computing bound for p
    _a3_int64_t _193;
    // Computing bound for p
    bool _194;
    if (!a)
    goto _jump719;
    double _195 = 32.0;
    bool _196 = _0 == _195;
    _194 = _196;
    goto _jump720;
    _jump719:;
    _194 = _63;
    _jump720:;
    int64_t _197;
    if (!_194)
    goto _jump721;
    int64_t _198 = 939;
    _197 = _198;
    goto _jump722;
    _jump721:;
    _197 = e;
    _jump722:;
    _193.d0 = _197;
    if (_197 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    // Computing bound for q
    int64_t _199;
    if (!_63)
    goto _jump724;
    int64_t _200;
    // Computing bound for p
    int64_t _201 = -d;
    if (_201 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    _200 = 0;
    int64_t _202 = 0; // p
    _jump726:; // Begin body of loop
    int64_t _203 = 896;
    _200 += _203;
    _202++;
    if (_202 < _201)
    goto _jump726;
    // End body of loop
    _199 = _200;
    goto _jump727;
    _jump724:;
    _199 = d;
    _jump727:;
    _193.d1 = _199;
    if (_199 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for r
    int64_t _204 = d + d;
    _193.d2 = _204;
    if (_204 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _197;
    _205 *= _199;
    _205 *= _204;
    _205 *= sizeof(int64_t);
    _193.data = jpl_alloc(_205);
    int64_t _206 = 0; // r
    int64_t _207 = 0; // q
    int64_t _208 = 0; // p
    _jump730:; // Begin body of loop
    int64_t _209 = 0;
    _209 *= _193.d0;
    _209 += _208;
    _209 *= _193.d1;
    _209 += _207;
    _209 *= _193.d2;
    _209 += _206;
    _193.data[_209] = k;
    _206++;
    if (_206 < _204)
    goto _jump730;
    _206 = 0;
    _207++;
    if (_207 < _199)
    goto _jump730;
    _207 = 0;
    _208++;
    if (_208 < _197)
    goto _jump730;
    // End body of loop
    g _210;
    if (!a)
    goto _jump731;
    int64_t _211 = 939;
    int64_t _212 = d * _211;
    g _213 = { _63, _212 };
    _210 = _213;
    goto _jump732;
    _jump731:;
    g _214;
    if (!a)
    goto _jump733;
    g _215 = { a, i };
    _214 = _215;
    goto _jump734;
    _jump733:;
    g _216 = { a, i };
    _214 = _216;
    _jump734:;
    _210 = _214;
    _jump732:;
    int64_t _217 = _210.b;
    int64_t _218 = -k;
    if (_217 >= 0)
    goto _jump735;
    fail_assertion("negative array index");
    _jump735:;
    if (_217 < _193.d0)
    goto _jump736;
    fail_assertion("index too large");
    _jump736:;
    if (_218 >= 0)
    goto _jump737;
    fail_assertion("negative array index");
    _jump737:;
    if (_218 < _193.d1)
    goto _jump738;
    fail_assertion("index too large");
    _jump738:;
    if (d >= 0)
    goto _jump739;
    fail_assertion("negative array index");
    _jump739:;
    if (d < _193.d2)
    goto _jump740;
    fail_assertion("index too large");
    _jump740:;
    int64_t _219 = 0;
    _219 *= _193.d0;
    _219 += _217;
    _219 *= _193.d1;
    _219 += _218;
    _219 *= _193.d2;
    _219 += d;
    int64_t _220 = _193.data[_219];
    _192.d0 = _220;
    if (_220 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _220;
    _221 *= sizeof(double);
    _192.data = jpl_alloc(_221);
    int64_t _222 = 0; // p
    _jump742:; // Begin body of loop
    double _223 = j.a;
    int64_t _224 = 0;
    _224 *= _192.d0;
    _224 += _222;
    _192.data[_224] = _223;
    _222++;
    if (_222 < _220)
    goto _jump742;
    // End body of loop
    _182 = _192;
    _jump718:;
    _a3__a2_void_t _225;
    // Computing bound for s
    int64_t _226 = 924;
    _225.d0 = _226;
    if (_226 > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing bound for t
    _225.d1 = _182.d0;
    if (_182.d0 > 0) 
    goto _jump744;
    fail_assertion("non-positive loop bound");
    _jump744:;
    // Computing bound for u
    _225.d2 = k;
    if (k > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing total size of heap memory to allocate
    int64_t _227 = 1;
    _227 *= _226;
    _227 *= _182.d0;
    _227 *= k;
    _227 *= sizeof(_a2_void_t);
    _225.data = jpl_alloc(_227);
    int64_t _228 = 0; // u
    int64_t _229 = 0; // t
    int64_t _230 = 0; // s
    _jump746:; // Begin body of loop
    _a3__a2_void_t _231;
    // Computing bound for v
    int64_t _232 = 446;
    _231.d0 = _232;
    if (_232 > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    // Computing bound for w
    int64_t _233 = 995;
    _231.d1 = _233;
    if (_233 > 0) 
    goto _jump748;
    fail_assertion("non-positive loop bound");
    _jump748:;
    // Computing bound for x
    int64_t _234;
    // Computing bound for v
    int64_t _235 = -e;
    if (_235 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing bound for w
    if (k > 0) 
    goto _jump750;
    fail_assertion("non-positive loop bound");
    _jump750:;
    _234 = 0;
    int64_t _236 = 0; // w
    int64_t _237 = 0; // v
    _jump751:; // Begin body of loop
    _234 += e;
    _236++;
    if (_236 < k)
    goto _jump751;
    _236 = 0;
    _237++;
    if (_237 < _235)
    goto _jump751;
    // End body of loop
    _231.d2 = _234;
    if (_234 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing total size of heap memory to allocate
    int64_t _238 = 1;
    _238 *= _232;
    _238 *= _233;
    _238 *= _234;
    _238 *= sizeof(_a2_void_t);
    _231.data = jpl_alloc(_238);
    int64_t _239 = 0; // x
    int64_t _240 = 0; // w
    int64_t _241 = 0; // v
    _jump753:; // Begin body of loop
    _a2_void_t _242;
    // Computing bound for y
    _242.d0 = _229;
    if (_229 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    // Computing bound for z
    int64_t _243 = 778;
    _242.d1 = _243;
    if (_243 > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= _229;
    _244 *= _243;
    _244 *= sizeof(void_t);
    _242.data = jpl_alloc(_244);
    int64_t _245 = 0; // z
    int64_t _246 = 0; // y
    _jump756:; // Begin body of loop
    void_t _247 = h(_246, _17, k);
    int64_t _248 = 0;
    _248 *= _242.d0;
    _248 += _246;
    _248 *= _242.d1;
    _248 += _245;
    _242.data[_248] = _247;
    _245++;
    if (_245 < _243)
    goto _jump756;
    _245 = 0;
    _246++;
    if (_246 < _229)
    goto _jump756;
    // End body of loop
    int64_t _249 = 0;
    _249 *= _231.d0;
    _249 += _241;
    _249 *= _231.d1;
    _249 += _240;
    _249 *= _231.d2;
    _249 += _239;
    _231.data[_249] = _242;
    _239++;
    if (_239 < _234)
    goto _jump753;
    _239 = 0;
    _240++;
    if (_240 < _233)
    goto _jump753;
    _240 = 0;
    _241++;
    if (_241 < _232)
    goto _jump753;
    // End body of loop
    int64_t _250 = -k;
    int64_t _251;
    // Computing bound for v
    g _252 = { a, _182.d0 };
    int64_t _253 = _252.b;
    if (_253 > 0) 
    goto _jump757;
    fail_assertion("non-positive loop bound");
    _jump757:;
    // Computing bound for w
    _a3_int64_t _254;
    // Computing bound for v
    _254.d0 = _230;
    if (_230 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing bound for w
    _254.d1 = _229;
    if (_229 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing bound for x
    _254.d2 = _182.d0;
    if (_182.d0 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    // Computing total size of heap memory to allocate
    int64_t _255 = 1;
    _255 *= _230;
    _255 *= _229;
    _255 *= _182.d0;
    _255 *= sizeof(int64_t);
    _254.data = jpl_alloc(_255);
    int64_t _256 = 0; // x
    int64_t _257 = 0; // w
    int64_t _258 = 0; // v
    _jump761:; // Begin body of loop
    int64_t _259 = 0;
    _259 *= _254.d0;
    _259 += _258;
    _259 *= _254.d1;
    _259 += _257;
    _259 *= _254.d2;
    _259 += _256;
    _254.data[_259] = _257;
    _256++;
    if (_256 < _182.d0)
    goto _jump761;
    _256 = 0;
    _257++;
    if (_257 < _229)
    goto _jump761;
    _257 = 0;
    _258++;
    if (_258 < _230)
    goto _jump761;
    // End body of loop
    int64_t _260;
    // Computing bound for v
    if (_229 > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing bound for w
    if (_182.d0 > 0) 
    goto _jump763;
    fail_assertion("non-positive loop bound");
    _jump763:;
    // Computing bound for x
    if (k > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    _260 = 0;
    int64_t _261 = 0; // x
    int64_t _262 = 0; // w
    int64_t _263 = 0; // v
    _jump765:; // Begin body of loop
    int64_t _264 = 843;
    _260 += _264;
    _261++;
    if (_261 < k)
    goto _jump765;
    _261 = 0;
    _262++;
    if (_262 < _182.d0)
    goto _jump765;
    _262 = 0;
    _263++;
    if (_263 < _229)
    goto _jump765;
    // End body of loop
    int64_t _265;
    if (!_63)
    goto _jump766;
    _265 = i;
    goto _jump767;
    _jump766:;
    _265 = k;
    _jump767:;
    if (_260 >= 0)
    goto _jump768;
    fail_assertion("negative array index");
    _jump768:;
    if (_260 < _254.d0)
    goto _jump769;
    fail_assertion("index too large");
    _jump769:;
    if (_182.d0 >= 0)
    goto _jump770;
    fail_assertion("negative array index");
    _jump770:;
    if (_182.d0 < _254.d1)
    goto _jump771;
    fail_assertion("index too large");
    _jump771:;
    if (_265 >= 0)
    goto _jump772;
    fail_assertion("negative array index");
    _jump772:;
    if (_265 < _254.d2)
    goto _jump773;
    fail_assertion("index too large");
    _jump773:;
    int64_t _266 = 0;
    _266 *= _254.d0;
    _266 += _260;
    _266 *= _254.d1;
    _266 += _182.d0;
    _266 *= _254.d2;
    _266 += _265;
    int64_t _267 = _254.data[_266];
    if (_267 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    _251 = 0;
    int64_t _268 = 0; // w
    int64_t _269 = 0; // v
    _jump775:; // Begin body of loop
    bool _270 = false;
    int64_t _271;
    if (!_270)
    goto _jump776;
    _271 = k;
    goto _jump777;
    _jump776:;
    _271 = _230;
    _jump777:;
    int64_t _272 = _271 / e;
    _251 += _272;
    _268++;
    if (_268 < _267)
    goto _jump775;
    _268 = 0;
    _269++;
    if (_269 < _253)
    goto _jump775;
    // End body of loop
    int64_t _273 = _182.d0 * d;
    if (_250 >= 0)
    goto _jump778;
    fail_assertion("negative array index");
    _jump778:;
    if (_250 < _231.d0)
    goto _jump779;
    fail_assertion("index too large");
    _jump779:;
    if (_251 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_251 < _231.d1)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    if (_273 >= 0)
    goto _jump782;
    fail_assertion("negative array index");
    _jump782:;
    if (_273 < _231.d2)
    goto _jump783;
    fail_assertion("index too large");
    _jump783:;
    int64_t _274 = 0;
    _274 *= _231.d0;
    _274 += _250;
    _274 *= _231.d1;
    _274 += _251;
    _274 *= _231.d2;
    _274 += _273;
    _a2_void_t _275 = _231.data[_274];
    int64_t _276 = 0;
    _276 *= _225.d0;
    _276 += _230;
    _276 *= _225.d1;
    _276 += _229;
    _276 *= _225.d2;
    _276 += _228;
    _225.data[_276] = _275;
    _228++;
    if (_228 < k)
    goto _jump746;
    _228 = 0;
    _229++;
    if (_229 < _182.d0)
    goto _jump746;
    _229 = 0;
    _230++;
    if (_230 < _226)
    goto _jump746;
    // End body of loop
    int64_t _277 = 84;
    if (d >= 0)
    goto _jump784;
    fail_assertion("negative array index");
    _jump784:;
    if (d < _225.d0)
    goto _jump785;
    fail_assertion("index too large");
    _jump785:;
    if (_277 >= 0)
    goto _jump786;
    fail_assertion("negative array index");
    _jump786:;
    if (_277 < _225.d1)
    goto _jump787;
    fail_assertion("index too large");
    _jump787:;
    if (_182.d0 >= 0)
    goto _jump788;
    fail_assertion("negative array index");
    _jump788:;
    if (_182.d0 < _225.d2)
    goto _jump789;
    fail_assertion("index too large");
    _jump789:;
    int64_t _278 = 0;
    _278 *= _225.d0;
    _278 += d;
    _278 *= _225.d1;
    _278 += _277;
    _278 *= _225.d2;
    _278 += _182.d0;
    _a2_void_t _279 = _225.data[_278];
    _a3_int64_t _280;
    // Computing bound for s
    _280.d0 = k;
    if (k > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for t
    double _281 = 61.0;
    double _282 = fmod(_0, _281);
    _a2_double _283;
    // Computing bound for s
    _283.d0 = _182.d0;
    if (_182.d0 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for t
    _283.d1 = i;
    if (i > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _182.d0;
    _284 *= i;
    _284 *= sizeof(double);
    _283.data = jpl_alloc(_284);
    int64_t _285 = 0; // t
    int64_t _286 = 0; // s
    _jump793:; // Begin body of loop
    double _287 = 85.0;
    int64_t _288 = 0;
    _288 *= _283.d0;
    _288 += _286;
    _288 *= _283.d1;
    _288 += _285;
    _283.data[_288] = _287;
    _285++;
    if (_285 < i)
    goto _jump793;
    _285 = 0;
    _286++;
    if (_286 < _182.d0)
    goto _jump793;
    // End body of loop
    bool _289 = f(_282, _283);
    bool _290;
    if (!_289)
    goto _jump794;
    double _291 = j.a;
    double _292 = 87.0;
    bool _293 = _291 < _292;
    _290 = _293;
    goto _jump795;
    _jump794:;
    bool _294 = !_63;
    _290 = _294;
    _jump795:;
    int64_t _295;
    if (!_290)
    goto _jump796;
    _295 = d;
    goto _jump797;
    _jump796:;
    _295 = _182.d0;
    _jump797:;
    _280.d1 = _295;
    if (_295 > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing bound for u
    _280.d2 = _182.d0;
    if (_182.d0 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= k;
    _296 *= _295;
    _296 *= _182.d0;
    _296 *= sizeof(int64_t);
    _280.data = jpl_alloc(_296);
    int64_t _297 = 0; // u
    int64_t _298 = 0; // t
    int64_t _299 = 0; // s
    _jump800:; // Begin body of loop
    int64_t _300;
    // Computing bound for v
    if (_182.d0 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing bound for w
    if (i > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    _300 = 0;
    int64_t _301 = 0; // w
    int64_t _302 = 0; // v
    _jump803:; // Begin body of loop
    _300 += _302;
    _301++;
    if (_301 < i)
    goto _jump803;
    _301 = 0;
    _302++;
    if (_302 < _182.d0)
    goto _jump803;
    // End body of loop
    int64_t _303 = 0;
    _303 *= _280.d0;
    _303 += _299;
    _303 *= _280.d1;
    _303 += _298;
    _303 *= _280.d2;
    _303 += _297;
    _280.data[_303] = _300;
    _297++;
    if (_297 < _182.d0)
    goto _jump800;
    _297 = 0;
    _298++;
    if (_298 < _295)
    goto _jump800;
    _298 = 0;
    _299++;
    if (_299 < k)
    goto _jump800;
    // End body of loop
    int64_t _304 = 285;
    int64_t _305;
    if (!_63)
    goto _jump804;
    bool _306 = !_63;
    bool _307 = !_306;
    g _308;
    if (!_307)
    goto _jump805;
    bool _309 = _63;
    if (0 != _63)
    goto _jump806;
    _309 = _63;
    _jump806:;
    g _310 = { _309, d };
    _308 = _310;
    goto _jump807;
    _jump805:;
    bool _311 = true;
    g _312 = { _311, _182.d0 };
    _308 = _312;
    _jump807:;
    int64_t _313 = _308.b;
    _305 = _313;
    goto _jump808;
    _jump804:;
    _305 = e;
    _jump808:;
    if (_182.d0 >= 0)
    goto _jump809;
    fail_assertion("negative array index");
    _jump809:;
    if (_182.d0 < _280.d0)
    goto _jump810;
    fail_assertion("index too large");
    _jump810:;
    if (_304 >= 0)
    goto _jump811;
    fail_assertion("negative array index");
    _jump811:;
    if (_304 < _280.d1)
    goto _jump812;
    fail_assertion("index too large");
    _jump812:;
    if (_305 >= 0)
    goto _jump813;
    fail_assertion("negative array index");
    _jump813:;
    if (_305 < _280.d2)
    goto _jump814;
    fail_assertion("index too large");
    _jump814:;
    int64_t _314 = 0;
    _314 *= _280.d0;
    _314 += _182.d0;
    _314 *= _280.d1;
    _314 += _304;
    _314 *= _280.d2;
    _314 += _305;
    int64_t _315 = _280.data[_314];
    int64_t _316 = -k;
    if (_315 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (_315 < _279.d0)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    if (_316 >= 0)
    goto _jump817;
    fail_assertion("negative array index");
    _jump817:;
    if (_316 < _279.d1)
    goto _jump818;
    fail_assertion("index too large");
    _jump818:;
    int64_t _317 = 0;
    _317 *= _279.d0;
    _317 += _315;
    _317 *= _279.d1;
    _317 += _316;
    void_t _318 = _279.data[_317];
    return _318;
}

rgba j() {
    _a3_bool _0;
    // Computing bound for k
    _0.d0 = d;
    if (d > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    // Computing bound for l
    int64_t _1 = i - i;
    g _2 = { a, _1 };
    int64_t _3 = _2.b;
    _0.d1 = _3;
    if (_3 > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    // Computing bound for m
    _a1_int64_t _4;
    // Computing bound for k
    _4.d0 = d;
    if (d > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= d;
    _5 *= sizeof(int64_t);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // k
    _jump822:; // Begin body of loop
    int64_t _7 = 0;
    _7 *= _4.d0;
    _7 += _6;
    _4.data[_7] = _6;
    _6++;
    if (_6 < d)
    goto _jump822;
    // End body of loop
    int64_t _8 = 83;
    if (_8 >= 0)
    goto _jump823;
    fail_assertion("negative array index");
    _jump823:;
    if (_8 < _4.d0)
    goto _jump824;
    fail_assertion("index too large");
    _jump824:;
    int64_t _9 = 0;
    _9 *= _4.d0;
    _9 += _8;
    int64_t _10 = _4.data[_9];
    int64_t _11 = -_10;
    _0.d2 = _11;
    if (_11 > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= d;
    _12 *= _3;
    _12 *= _11;
    _12 *= sizeof(bool);
    _0.data = jpl_alloc(_12);
    int64_t _13 = 0; // m
    int64_t _14 = 0; // l
    int64_t _15 = 0; // k
    _jump826:; // Begin body of loop
    double _16;
    // Computing bound for n
    if (d > 0) 
    goto _jump827;
    fail_assertion("non-positive loop bound");
    _jump827:;
    // Computing bound for o
    int64_t _17 = i / d;
    if (_17 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    _16 = 0;
    int64_t _18 = 0; // o
    int64_t _19 = 0; // n
    _jump829:; // Begin body of loop
    double _20 = 8.0;
    double _21 = -_20;
    _16 += _21;
    _18++;
    if (_18 < _17)
    goto _jump829;
    _18 = 0;
    _19++;
    if (_19 < d)
    goto _jump829;
    // End body of loop
    _a2_double _22;
    // Computing bound for n
    _22.d0 = d;
    if (d > 0) 
    goto _jump830;
    fail_assertion("non-positive loop bound");
    _jump830:;
    // Computing bound for o
    _22.d1 = _14;
    if (_14 > 0) 
    goto _jump831;
    fail_assertion("non-positive loop bound");
    _jump831:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= d;
    _23 *= _14;
    _23 *= sizeof(double);
    _22.data = jpl_alloc(_23);
    int64_t _24 = 0; // o
    int64_t _25 = 0; // n
    _jump832:; // Begin body of loop
    double _26 = 45.0;
    int64_t _27 = 0;
    _27 *= _22.d0;
    _27 += _25;
    _27 *= _22.d1;
    _27 += _24;
    _22.data[_27] = _26;
    _24++;
    if (_24 < _14)
    goto _jump832;
    _24 = 0;
    _25++;
    if (_25 < d)
    goto _jump832;
    // End body of loop
    bool _28 = f(_16, _22);
    int64_t _29 = 0;
    _29 *= _0.d0;
    _29 += _15;
    _29 *= _0.d1;
    _29 += _14;
    _29 *= _0.d2;
    _29 += _13;
    _0.data[_29] = _28;
    _13++;
    if (_13 < _11)
    goto _jump826;
    _13 = 0;
    _14++;
    if (_14 < _3)
    goto _jump826;
    _14 = 0;
    _15++;
    if (_15 < d)
    goto _jump826;
    // End body of loop
    _a2_int64_t _30;
    // Computing bound for k
    _30.d0 = d;
    if (d > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for l
    _30.d1 = e;
    if (e > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= d;
    _31 *= e;
    _31 *= sizeof(int64_t);
    _30.data = jpl_alloc(_31);
    int64_t _32 = 0; // l
    int64_t _33 = 0; // k
    _jump835:; // Begin body of loop
    int64_t _34 = 0;
    _34 *= _30.d0;
    _34 += _33;
    _34 *= _30.d1;
    _34 += _32;
    _30.data[_34] = _32;
    _32++;
    if (_32 < e)
    goto _jump835;
    _32 = 0;
    _33++;
    if (_33 < d)
    goto _jump835;
    // End body of loop
    if (i >= 0)
    goto _jump836;
    fail_assertion("negative array index");
    _jump836:;
    if (i < _30.d0)
    goto _jump837;
    fail_assertion("index too large");
    _jump837:;
    if (d >= 0)
    goto _jump838;
    fail_assertion("negative array index");
    _jump838:;
    if (d < _30.d1)
    goto _jump839;
    fail_assertion("index too large");
    _jump839:;
    int64_t _35 = 0;
    _35 *= _30.d0;
    _35 += i;
    _35 *= _30.d1;
    _35 += d;
    int64_t _36 = _30.data[_35];
    if (d >= 0)
    goto _jump840;
    fail_assertion("negative array index");
    _jump840:;
    if (d < _0.d0)
    goto _jump841;
    fail_assertion("index too large");
    _jump841:;
    if (_36 >= 0)
    goto _jump842;
    fail_assertion("negative array index");
    _jump842:;
    if (_36 < _0.d1)
    goto _jump843;
    fail_assertion("index too large");
    _jump843:;
    if (i >= 0)
    goto _jump844;
    fail_assertion("negative array index");
    _jump844:;
    if (i < _0.d2)
    goto _jump845;
    fail_assertion("index too large");
    _jump845:;
    int64_t _37 = 0;
    _37 *= _0.d0;
    _37 += d;
    _37 *= _0.d1;
    _37 += _36;
    _37 *= _0.d2;
    _37 += i;
    bool _38 = _0.data[_37];
    bool _39;
    if (!_38)
    goto _jump846;
    _a2_bool _40;
    if (!a)
    goto _jump847;
    _a2_bool _41;
    // Computing bound for k
    bool _42 = true;
    g _43 = { _42, i };
    int64_t _44 = _43.b;
    _41.d0 = _44;
    if (_44 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing bound for l
    int64_t _45 = d + d;
    int64_t _46 = _45 - e;
    _41.d1 = _46;
    if (_46 > 0) 
    goto _jump849;
    fail_assertion("non-positive loop bound");
    _jump849:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= _44;
    _47 *= _46;
    _47 *= sizeof(bool);
    _41.data = jpl_alloc(_47);
    int64_t _48 = 0; // l
    int64_t _49 = 0; // k
    _jump850:; // Begin body of loop
    bool _50 = true;
    int64_t _51 = 0;
    _51 *= _41.d0;
    _51 += _49;
    _51 *= _41.d1;
    _51 += _48;
    _41.data[_51] = _50;
    _48++;
    if (_48 < _46)
    goto _jump850;
    _48 = 0;
    _49++;
    if (_49 < _44)
    goto _jump850;
    // End body of loop
    _40 = _41;
    goto _jump851;
    _jump847:;
    double _52 = 57.0;
    double _53 = -_52;
    bool _54 = true;
    double _55;
    if (!_54)
    goto _jump852;
    double _56 = 25.0;
    _55 = _56;
    goto _jump853;
    _jump852:;
    double _57 = 26.0;
    _55 = _57;
    _jump853:;
    bool _58 = _53 != _55;
    _a2_bool _59;
    if (!_58)
    goto _jump854;
    _59 = c;
    goto _jump855;
    _jump854:;
    _a3__a2_bool _60;
    // Computing bound for k
    _60.d0 = e;
    if (e > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing bound for l
    _60.d1 = d;
    if (d > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    // Computing bound for m
    _60.d2 = e;
    if (e > 0) 
    goto _jump858;
    fail_assertion("non-positive loop bound");
    _jump858:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= e;
    _61 *= d;
    _61 *= e;
    _61 *= sizeof(_a2_bool);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // m
    int64_t _63 = 0; // l
    int64_t _64 = 0; // k
    _jump859:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _60.d0;
    _65 += _64;
    _65 *= _60.d1;
    _65 += _63;
    _65 *= _60.d2;
    _65 += _62;
    _60.data[_65] = c;
    _62++;
    if (_62 < e)
    goto _jump859;
    _62 = 0;
    _63++;
    if (_63 < d)
    goto _jump859;
    _63 = 0;
    _64++;
    if (_64 < e)
    goto _jump859;
    // End body of loop
    int64_t _66;
    // Computing bound for k
    if (i > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    // Computing bound for l
    if (e > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    _66 = 0;
    int64_t _67 = 0; // l
    int64_t _68 = 0; // k
    _jump862:; // Begin body of loop
    _66 += _67;
    _67++;
    if (_67 < e)
    goto _jump862;
    _67 = 0;
    _68++;
    if (_68 < i)
    goto _jump862;
    // End body of loop
    int64_t _69 = 182;
    int64_t _70 = -_69;
    if (i >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (i < _60.d0)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    if (_66 >= 0)
    goto _jump865;
    fail_assertion("negative array index");
    _jump865:;
    if (_66 < _60.d1)
    goto _jump866;
    fail_assertion("index too large");
    _jump866:;
    if (_70 >= 0)
    goto _jump867;
    fail_assertion("negative array index");
    _jump867:;
    if (_70 < _60.d2)
    goto _jump868;
    fail_assertion("index too large");
    _jump868:;
    int64_t _71 = 0;
    _71 *= _60.d0;
    _71 += i;
    _71 *= _60.d1;
    _71 += _66;
    _71 *= _60.d2;
    _71 += _70;
    _a2_bool _72 = _60.data[_71];
    _59 = _72;
    _jump855:;
    _40 = _59;
    _jump851:;
    int64_t _73 = 809;
    int64_t _74;
    // Computing bound for k
    int64_t _75 = i / i;
    if (_75 > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing bound for l
    if (e > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    _74 = 0;
    int64_t _76 = 0; // l
    int64_t _77 = 0; // k
    _jump871:; // Begin body of loop
    int64_t _78 = 466;
    _74 += _78;
    _76++;
    if (_76 < e)
    goto _jump871;
    _76 = 0;
    _77++;
    if (_77 < _75)
    goto _jump871;
    // End body of loop
    int64_t _79 = -_74;
    if (_73 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_73 < _40.d0)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    if (_79 >= 0)
    goto _jump874;
    fail_assertion("negative array index");
    _jump874:;
    if (_79 < _40.d1)
    goto _jump875;
    fail_assertion("index too large");
    _jump875:;
    int64_t _80 = 0;
    _80 *= _40.d0;
    _80 += _73;
    _80 *= _40.d1;
    _80 += _79;
    bool _81 = _40.data[_80];
    _39 = _81;
    goto _jump876;
    _jump846:;
    double _82 = 51.0;
    _a2_double _83;
    // Computing bound for k
    int64_t _84 = 879;
    _83.d0 = _84;
    if (_84 > 0) 
    goto _jump877;
    fail_assertion("non-positive loop bound");
    _jump877:;
    // Computing bound for l
    int64_t _85 = 688;
    _83.d1 = _85;
    if (_85 > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= _84;
    _86 *= _85;
    _86 *= sizeof(double);
    _83.data = jpl_alloc(_86);
    int64_t _87 = 0; // l
    int64_t _88 = 0; // k
    _jump879:; // Begin body of loop
    double _89;
    // Computing bound for m
    int64_t _90;
    // Computing bound for m
    if (e > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    _90 = 0;
    int64_t _91 = 0; // m
    _jump881:; // Begin body of loop
    int64_t _92 = 790;
    _90 += _92;
    _91++;
    if (_91 < e)
    goto _jump881;
    // End body of loop
    if (_90 > 0) 
    goto _jump882;
    fail_assertion("non-positive loop bound");
    _jump882:;
    _89 = 0;
    int64_t _93 = 0; // m
    _jump883:; // Begin body of loop
    rgba _94 = j();
    double _95 = _94.g;
    _89 += _95;
    _93++;
    if (_93 < _90)
    goto _jump883;
    // End body of loop
    double _96 = -_89;
    int64_t _97 = 0;
    _97 *= _83.d0;
    _97 += _88;
    _97 *= _83.d1;
    _97 += _87;
    _83.data[_97] = _96;
    _87++;
    if (_87 < _85)
    goto _jump879;
    _87 = 0;
    _88++;
    if (_88 < _84)
    goto _jump879;
    // End body of loop
    bool _98 = f(_82, _83);
    _39 = _98;
    _jump876:;
    _a1_double _99;
    if (!_39)
    goto _jump884;
    _a1_double _100;
    // Computing bound for k
    int64_t _101 = i / i;
    int64_t _102 = _101 * i;
    _a3_int64_t _103;
    // Computing bound for k
    _103.d0 = d;
    if (d > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing bound for l
    int64_t _104 = 991;
    _103.d1 = _104;
    if (_104 > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing bound for m
    _103.d2 = d;
    if (d > 0) 
    goto _jump887;
    fail_assertion("non-positive loop bound");
    _jump887:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= d;
    _105 *= _104;
    _105 *= d;
    _105 *= sizeof(int64_t);
    _103.data = jpl_alloc(_105);
    int64_t _106 = 0; // m
    int64_t _107 = 0; // l
    int64_t _108 = 0; // k
    _jump888:; // Begin body of loop
    int64_t _109 = 0;
    _109 *= _103.d0;
    _109 += _108;
    _109 *= _103.d1;
    _109 += _107;
    _109 *= _103.d2;
    _109 += _106;
    _103.data[_109] = d;
    _106++;
    if (_106 < d)
    goto _jump888;
    _106 = 0;
    _107++;
    if (_107 < _104)
    goto _jump888;
    _107 = 0;
    _108++;
    if (_108 < d)
    goto _jump888;
    // End body of loop
    int64_t _110 = e * e;
    int64_t _111 = 462;
    int64_t _112 = -_111;
    if (_110 >= 0)
    goto _jump889;
    fail_assertion("negative array index");
    _jump889:;
    if (_110 < _103.d0)
    goto _jump890;
    fail_assertion("index too large");
    _jump890:;
    if (_112 >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (_112 < _103.d1)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    if (e >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (e < _103.d2)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    int64_t _113 = 0;
    _113 *= _103.d0;
    _113 += _110;
    _113 *= _103.d1;
    _113 += _112;
    _113 *= _103.d2;
    _113 += e;
    int64_t _114 = _103.data[_113];
    _a1_int64_t _115;
    _115.d0 = 3;
    _115.data = jpl_alloc(sizeof(int64_t) * 3);
    _115.data[0] = _102;
    _115.data[1] = e;
    _115.data[2] = _114;
    if (e >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (e < _115.d0)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    int64_t _116 = 0;
    _116 *= _115.d0;
    _116 += e;
    int64_t _117 = _115.data[_116];
    int64_t _118;
    // Computing bound for k
    bool _119 = false;
    g _120 = { _119, e };
    bool _121 = _120.a;
    int64_t _122;
    if (!_121)
    goto _jump897;
    int64_t _123 = 516;
    int64_t _124 = -_123;
    _122 = _124;
    goto _jump898;
    _jump897:;
    bool _125 = false;
    int64_t _126 = 85;
    g _127 = { _125, _126 };
    int64_t _128 = _127.b;
    _122 = _128;
    _jump898:;
    if (_122 > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    // Computing bound for l
    _a3_int64_t _129;
    // Computing bound for k
    int64_t _130 = 648;
    _129.d0 = _130;
    if (_130 > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for l
    _129.d1 = e;
    if (e > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing bound for m
    int64_t _131 = 452;
    _129.d2 = _131;
    if (_131 > 0) 
    goto _jump902;
    fail_assertion("non-positive loop bound");
    _jump902:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= _130;
    _132 *= e;
    _132 *= _131;
    _132 *= sizeof(int64_t);
    _129.data = jpl_alloc(_132);
    int64_t _133 = 0; // m
    int64_t _134 = 0; // l
    int64_t _135 = 0; // k
    _jump903:; // Begin body of loop
    int64_t _136 = 747;
    int64_t _137 = 0;
    _137 *= _129.d0;
    _137 += _135;
    _137 *= _129.d1;
    _137 += _134;
    _137 *= _129.d2;
    _137 += _133;
    _129.data[_137] = _136;
    _133++;
    if (_133 < _131)
    goto _jump903;
    _133 = 0;
    _134++;
    if (_134 < e)
    goto _jump903;
    _134 = 0;
    _135++;
    if (_135 < _130)
    goto _jump903;
    // End body of loop
    int64_t _138;
    // Computing bound for k
    if (d > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for l
    if (i > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for m
    if (i > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    _138 = 0;
    int64_t _139 = 0; // m
    int64_t _140 = 0; // l
    int64_t _141 = 0; // k
    _jump907:; // Begin body of loop
    int64_t _142 = 531;
    _138 += _142;
    _139++;
    if (_139 < i)
    goto _jump907;
    _139 = 0;
    _140++;
    if (_140 < i)
    goto _jump907;
    _140 = 0;
    _141++;
    if (_141 < d)
    goto _jump907;
    // End body of loop
    if (_138 >= 0)
    goto _jump908;
    fail_assertion("negative array index");
    _jump908:;
    if (_138 < _129.d0)
    goto _jump909;
    fail_assertion("index too large");
    _jump909:;
    if (d >= 0)
    goto _jump910;
    fail_assertion("negative array index");
    _jump910:;
    if (d < _129.d1)
    goto _jump911;
    fail_assertion("index too large");
    _jump911:;
    if (i >= 0)
    goto _jump912;
    fail_assertion("negative array index");
    _jump912:;
    if (i < _129.d2)
    goto _jump913;
    fail_assertion("index too large");
    _jump913:;
    int64_t _143 = 0;
    _143 *= _129.d0;
    _143 += _138;
    _143 *= _129.d1;
    _143 += d;
    _143 *= _129.d2;
    _143 += i;
    int64_t _144 = _129.data[_143];
    if (_144 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing bound for m
    if (d > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    _118 = 0;
    int64_t _145 = 0; // m
    int64_t _146 = 0; // l
    int64_t _147 = 0; // k
    _jump916:; // Begin body of loop
    _118 += _146;
    _145++;
    if (_145 < d)
    goto _jump916;
    _145 = 0;
    _146++;
    if (_146 < _144)
    goto _jump916;
    _146 = 0;
    _147++;
    if (_147 < _122)
    goto _jump916;
    // End body of loop
    int64_t _148 = _117 / _118;
    _100.d0 = _148;
    if (_148 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _148;
    _149 *= sizeof(double);
    _100.data = jpl_alloc(_149);
    int64_t _150 = 0; // k
    _jump918:; // Begin body of loop
    double _151 = 73.0;
    int64_t _152 = 0;
    _152 *= _100.d0;
    _152 += _150;
    _100.data[_152] = _151;
    _150++;
    if (_150 < _148)
    goto _jump918;
    // End body of loop
    _99 = _100;
    goto _jump919;
    _jump884:;
    double _153;
    // Computing bound for k
    if (e > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for l
    if (i > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    _153 = 0;
    int64_t _154 = 0; // l
    int64_t _155 = 0; // k
    _jump922:; // Begin body of loop
    rgba _156 = j();
    double _157 = _156.r;
    double _158 = -_157;
    rgba _159 = j();
    double _160 = _159.b;
    double _161 = _158 - _160;
    bool _162 = false;
    g _163 = { _162, e };
    bool _164 = _163.a;
    double _165;
    if (!_164)
    goto _jump923;
    double _166 = 96.0;
    double _167 = -_166;
    double _168 = -_167;
    _165 = _168;
    goto _jump924;
    _jump923:;
    double _169 = 62.0;
    double _170 = 18.0;
    double _171 = _169 / _170;
    double _172 = -_171;
    _165 = _172;
    _jump924:;
    double _173 = _161 * _165;
    _153 += _173;
    _154++;
    if (_154 < i)
    goto _jump922;
    _154 = 0;
    _155++;
    if (_155 < e)
    goto _jump922;
    // End body of loop
    _a1_double _174;
    _174.d0 = 1;
    _174.data = jpl_alloc(sizeof(double) * 1);
    _174.data[0] = _153;
    _99 = _174;
    _jump919:;
    _a3_bool _175;
    // Computing bound for p
    _a1_int64_t _176;
    // Computing bound for p
    int64_t _177 = 285;
    int64_t _178 = _177 / i;
    int64_t _179 = -_178;
    _176.d0 = _179;
    if (_179 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= _179;
    _180 *= sizeof(int64_t);
    _176.data = jpl_alloc(_180);
    int64_t _181 = 0; // p
    _jump926:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _176.d0;
    _182 += _181;
    _176.data[_182] = i;
    _181++;
    if (_181 < _179)
    goto _jump926;
    // End body of loop
    if (d >= 0)
    goto _jump927;
    fail_assertion("negative array index");
    _jump927:;
    if (d < _176.d0)
    goto _jump928;
    fail_assertion("index too large");
    _jump928:;
    int64_t _183 = 0;
    _183 *= _176.d0;
    _183 += d;
    int64_t _184 = _176.data[_183];
    _175.d0 = _184;
    if (_184 > 0) 
    goto _jump929;
    fail_assertion("non-positive loop bound");
    _jump929:;
    // Computing bound for q
    _a1_g _185;
    // Computing bound for p
    _185.d0 = e;
    if (e > 0) 
    goto _jump930;
    fail_assertion("non-positive loop bound");
    _jump930:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= e;
    _186 *= sizeof(g);
    _185.data = jpl_alloc(_186);
    int64_t _187 = 0; // p
    _jump931:; // Begin body of loop
    bool _188 = true;
    g _189 = { _188, e };
    int64_t _190 = 0;
    _190 *= _185.d0;
    _190 += _187;
    _185.data[_190] = _189;
    _187++;
    if (_187 < e)
    goto _jump931;
    // End body of loop
    int64_t _191;
    // Computing bound for p
    if (c.d1 > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    // Computing bound for q
    if (c.d0 > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    _191 = 0;
    int64_t _192 = 0; // q
    int64_t _193 = 0; // p
    _jump934:; // Begin body of loop
    _191 += e;
    _192++;
    if (_192 < c.d0)
    goto _jump934;
    _192 = 0;
    _193++;
    if (_193 < c.d1)
    goto _jump934;
    // End body of loop
    int64_t _194 = -d;
    int64_t _195 = _191 - _194;
    if (_195 >= 0)
    goto _jump935;
    fail_assertion("negative array index");
    _jump935:;
    if (_195 < _185.d0)
    goto _jump936;
    fail_assertion("index too large");
    _jump936:;
    int64_t _196 = 0;
    _196 *= _185.d0;
    _196 += _195;
    g _197 = _185.data[_196];
    int64_t _198 = _197.b;
    _175.d1 = _198;
    if (_198 > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing bound for r
    double _199 = 58.0;
    double _200 = 48.0;
    double _201 = _199 - _200;
    _a2_double _202;
    // Computing bound for p
    _202.d0 = _99.d0;
    if (_99.d0 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing bound for q
    _202.d1 = d;
    if (d > 0) 
    goto _jump939;
    fail_assertion("non-positive loop bound");
    _jump939:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _99.d0;
    _203 *= d;
    _203 *= sizeof(double);
    _202.data = jpl_alloc(_203);
    int64_t _204 = 0; // q
    int64_t _205 = 0; // p
    _jump940:; // Begin body of loop
    double _206 = 20.0;
    int64_t _207 = 0;
    _207 *= _202.d0;
    _207 += _205;
    _207 *= _202.d1;
    _207 += _204;
    _202.data[_207] = _206;
    _204++;
    if (_204 < d)
    goto _jump940;
    _204 = 0;
    _205++;
    if (_205 < _99.d0)
    goto _jump940;
    // End body of loop
    bool _208 = f(_201, _202);
    rgba _209 = j();
    double _210 = _209.b;
    rgba _211 = j();
    double _212 = _211.b;
    bool _213 = _210 != _212;
    bool _214 = _208 == _213;
    int64_t _215;
    if (!_214)
    goto _jump941;
    int64_t _216;
    if (!a)
    goto _jump942;
    _216 = _99.d0;
    goto _jump943;
    _jump942:;
    _216 = d;
    _jump943:;
    int64_t _217 = -_216;
    _215 = _217;
    goto _jump944;
    _jump941:;
    _215 = c.d0;
    _jump944:;
    _175.d2 = _215;
    if (_215 > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    // Computing total size of heap memory to allocate
    int64_t _218 = 1;
    _218 *= _184;
    _218 *= _198;
    _218 *= _215;
    _218 *= sizeof(bool);
    _175.data = jpl_alloc(_218);
    int64_t _219 = 0; // r
    int64_t _220 = 0; // q
    int64_t _221 = 0; // p
    _jump946:; // Begin body of loop
    bool _222 = true;
    int64_t _223 = 0;
    _223 *= _175.d0;
    _223 += _221;
    _223 *= _175.d1;
    _223 += _220;
    _223 *= _175.d2;
    _223 += _219;
    _175.data[_223] = _222;
    _219++;
    if (_219 < _215)
    goto _jump946;
    _219 = 0;
    _220++;
    if (_220 < _198)
    goto _jump946;
    _220 = 0;
    _221++;
    if (_221 < _184)
    goto _jump946;
    // End body of loop
    int64_t _224;
    // Computing bound for p
    if (c.d1 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for q
    if (_99.d0 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing bound for r
    if (c.d0 > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    _224 = 0;
    int64_t _225 = 0; // r
    int64_t _226 = 0; // q
    int64_t _227 = 0; // p
    _jump950:; // Begin body of loop
    _224 += _225;
    _225++;
    if (_225 < c.d0)
    goto _jump950;
    _225 = 0;
    _226++;
    if (_226 < _99.d0)
    goto _jump950;
    _226 = 0;
    _227++;
    if (_227 < c.d1)
    goto _jump950;
    // End body of loop
    if (e >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (e < _175.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    if (d >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (d < _175.d1)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    if (_224 >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (_224 < _175.d2)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    int64_t _228 = 0;
    _228 *= _175.d0;
    _228 += e;
    _228 *= _175.d1;
    _228 += d;
    _228 *= _175.d2;
    _228 += _224;
    bool _229 = _175.data[_228];
    rgba _230;
    if (!_229)
    goto _jump957;
    _a2_bool _231;
    // Computing bound for p
    bool _232 = false;
    int64_t _233;
    if (!_232)
    goto _jump958;
    _233 = e;
    goto _jump959;
    _jump958:;
    _233 = _99.d0;
    _jump959:;
    _231.d0 = _233;
    if (_233 > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for q
    _231.d1 = d;
    if (d > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= _233;
    _234 *= d;
    _234 *= sizeof(bool);
    _231.data = jpl_alloc(_234);
    int64_t _235 = 0; // q
    int64_t _236 = 0; // p
    _jump962:; // Begin body of loop
    bool _237 = true;
    bool _238;
    if (!_237)
    goto _jump963;
    bool _239 = false;
    bool _240;
    if (!_239)
    goto _jump964;
    bool _241 = c.d0 == _235;
    _240 = _241;
    goto _jump965;
    _jump964:;
    if (_236 >= 0)
    goto _jump966;
    fail_assertion("negative array index");
    _jump966:;
    if (_236 < c.d0)
    goto _jump967;
    fail_assertion("index too large");
    _jump967:;
    if (_99.d0 >= 0)
    goto _jump968;
    fail_assertion("negative array index");
    _jump968:;
    if (_99.d0 < c.d1)
    goto _jump969;
    fail_assertion("index too large");
    _jump969:;
    int64_t _242 = 0;
    _242 *= c.d0;
    _242 += _236;
    _242 *= c.d1;
    _242 += _99.d0;
    bool _243 = c.data[_242];
    _240 = _243;
    _jump965:;
    _238 = _240;
    goto _jump970;
    _jump963:;
    _238 = a;
    _jump970:;
    int64_t _244 = 0;
    _244 *= _231.d0;
    _244 += _236;
    _244 *= _231.d1;
    _244 += _235;
    _231.data[_244] = _238;
    _235++;
    if (_235 < d)
    goto _jump962;
    _235 = 0;
    _236++;
    if (_236 < _233)
    goto _jump962;
    // End body of loop
    bool _245 = true;
    g _246 = { _245, i };
    g _247 = { a, d };
    _a1_g _248;
    _248.d0 = 2;
    _248.data = jpl_alloc(sizeof(g) * 2);
    _248.data[0] = _246;
    _248.data[1] = _247;
    if (_99.d0 >= 0)
    goto _jump971;
    fail_assertion("negative array index");
    _jump971:;
    if (_99.d0 < _248.d0)
    goto _jump972;
    fail_assertion("index too large");
    _jump972:;
    int64_t _249 = 0;
    _249 *= _248.d0;
    _249 += _99.d0;
    g _250 = _248.data[_249];
    int64_t _251 = _250.b;
    if (_251 >= 0)
    goto _jump973;
    fail_assertion("negative array index");
    _jump973:;
    if (_251 < _231.d0)
    goto _jump974;
    fail_assertion("index too large");
    _jump974:;
    if (c.d0 >= 0)
    goto _jump975;
    fail_assertion("negative array index");
    _jump975:;
    if (c.d0 < _231.d1)
    goto _jump976;
    fail_assertion("index too large");
    _jump976:;
    int64_t _252 = 0;
    _252 *= _231.d0;
    _252 += _251;
    _252 *= _231.d1;
    _252 += c.d0;
    bool _253 = _231.data[_252];
    rgba _254;
    if (!_253)
    goto _jump977;
    _a3__a2_rgba _255;
    // Computing bound for p
    _255.d0 = e;
    if (e > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for q
    _255.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing bound for r
    _255.d2 = e;
    if (e > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing total size of heap memory to allocate
    int64_t _256 = 1;
    _256 *= e;
    _256 *= c.d0;
    _256 *= e;
    _256 *= sizeof(_a2_rgba);
    _255.data = jpl_alloc(_256);
    int64_t _257 = 0; // r
    int64_t _258 = 0; // q
    int64_t _259 = 0; // p
    _jump981:; // Begin body of loop
    bool _260 = false;
    _a2_rgba _261;
    if (!_260)
    goto _jump982;
    _a2_rgba _262;
    // Computing bound for s
    _262.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for t
    _262.d1 = d;
    if (d > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= c.d0;
    _263 *= d;
    _263 *= sizeof(rgba);
    _262.data = jpl_alloc(_263);
    int64_t _264 = 0; // t
    int64_t _265 = 0; // s
    _jump985:; // Begin body of loop
    rgba _266 = j();
    int64_t _267 = 0;
    _267 *= _262.d0;
    _267 += _265;
    _267 *= _262.d1;
    _267 += _264;
    _262.data[_267] = _266;
    _264++;
    if (_264 < d)
    goto _jump985;
    _264 = 0;
    _265++;
    if (_265 < c.d0)
    goto _jump985;
    // End body of loop
    _261 = _262;
    goto _jump986;
    _jump982:;
    _a2_rgba _268;
    // Computing bound for s
    _268.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing bound for t
    _268.d1 = e;
    if (e > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing total size of heap memory to allocate
    int64_t _269 = 1;
    _269 *= c.d0;
    _269 *= e;
    _269 *= sizeof(rgba);
    _268.data = jpl_alloc(_269);
    int64_t _270 = 0; // t
    int64_t _271 = 0; // s
    _jump989:; // Begin body of loop
    rgba _272 = j();
    int64_t _273 = 0;
    _273 *= _268.d0;
    _273 += _271;
    _273 *= _268.d1;
    _273 += _270;
    _268.data[_273] = _272;
    _270++;
    if (_270 < e)
    goto _jump989;
    _270 = 0;
    _271++;
    if (_271 < c.d0)
    goto _jump989;
    // End body of loop
    _261 = _268;
    _jump986:;
    int64_t _274 = 0;
    _274 *= _255.d0;
    _274 += _259;
    _274 *= _255.d1;
    _274 += _258;
    _274 *= _255.d2;
    _274 += _257;
    _255.data[_274] = _261;
    _257++;
    if (_257 < e)
    goto _jump981;
    _257 = 0;
    _258++;
    if (_258 < c.d0)
    goto _jump981;
    _258 = 0;
    _259++;
    if (_259 < e)
    goto _jump981;
    // End body of loop
    int64_t _275;
    // Computing bound for p
    int64_t _276;
    // Computing bound for p
    if (e > 0) 
    goto _jump990;
    fail_assertion("non-positive loop bound");
    _jump990:;
    // Computing bound for q
    if (_99.d0 > 0) 
    goto _jump991;
    fail_assertion("non-positive loop bound");
    _jump991:;
    // Computing bound for r
    if (e > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    _276 = 0;
    int64_t _277 = 0; // r
    int64_t _278 = 0; // q
    int64_t _279 = 0; // p
    _jump993:; // Begin body of loop
    int64_t _280 = -e;
    _276 += _280;
    _277++;
    if (_277 < e)
    goto _jump993;
    _277 = 0;
    _278++;
    if (_278 < _99.d0)
    goto _jump993;
    _278 = 0;
    _279++;
    if (_279 < e)
    goto _jump993;
    // End body of loop
    if (_276 > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    _275 = 0;
    int64_t _281 = 0; // p
    _jump995:; // Begin body of loop
    _275 += c.d1;
    _281++;
    if (_281 < _276)
    goto _jump995;
    // End body of loop
    int64_t _282 = -e;
    int64_t _283 = 336;
    if (_275 >= 0)
    goto _jump996;
    fail_assertion("negative array index");
    _jump996:;
    if (_275 < _255.d0)
    goto _jump997;
    fail_assertion("index too large");
    _jump997:;
    if (_282 >= 0)
    goto _jump998;
    fail_assertion("negative array index");
    _jump998:;
    if (_282 < _255.d1)
    goto _jump999;
    fail_assertion("index too large");
    _jump999:;
    if (_283 >= 0)
    goto _jump1000;
    fail_assertion("negative array index");
    _jump1000:;
    if (_283 < _255.d2)
    goto _jump1001;
    fail_assertion("index too large");
    _jump1001:;
    int64_t _284 = 0;
    _284 *= _255.d0;
    _284 += _275;
    _284 *= _255.d1;
    _284 += _282;
    _284 *= _255.d2;
    _284 += _283;
    _a2_rgba _285 = _255.data[_284];
    int64_t _286;
    // Computing bound for p
    int64_t _287;
    // Computing bound for p
    int64_t _288;
    // Computing bound for p
    if (e > 0) 
    goto _jump1002;
    fail_assertion("non-positive loop bound");
    _jump1002:;
    _288 = 0;
    int64_t _289 = 0; // p
    _jump1003:; // Begin body of loop
    _288 += _99.d0;
    _289++;
    if (_289 < e)
    goto _jump1003;
    // End body of loop
    if (_288 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for q
    int64_t _290 = 489;
    if (_290 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing bound for r
    if (d > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    _287 = 0;
    int64_t _291 = 0; // r
    int64_t _292 = 0; // q
    int64_t _293 = 0; // p
    _jump1007:; // Begin body of loop
    _287 += e;
    _291++;
    if (_291 < d)
    goto _jump1007;
    _291 = 0;
    _292++;
    if (_292 < _290)
    goto _jump1007;
    _292 = 0;
    _293++;
    if (_293 < _288)
    goto _jump1007;
    // End body of loop
    if (_287 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    _286 = 0;
    int64_t _294 = 0; // p
    _jump1009:; // Begin body of loop
    _286 += c.d1;
    _294++;
    if (_294 < _287)
    goto _jump1009;
    // End body of loop
    int64_t _295 = -_286;
    if (_295 >= 0)
    goto _jump1010;
    fail_assertion("negative array index");
    _jump1010:;
    if (_295 < _285.d0)
    goto _jump1011;
    fail_assertion("index too large");
    _jump1011:;
    if (c.d1 >= 0)
    goto _jump1012;
    fail_assertion("negative array index");
    _jump1012:;
    if (c.d1 < _285.d1)
    goto _jump1013;
    fail_assertion("index too large");
    _jump1013:;
    int64_t _296 = 0;
    _296 *= _285.d0;
    _296 += _295;
    _296 *= _285.d1;
    _296 += c.d1;
    rgba _297 = _285.data[_296];
    _254 = _297;
    goto _jump1014;
    _jump977:;
    double _298;
    // Computing bound for p
    if (c.d0 > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing bound for q
    if (c.d1 > 0) 
    goto _jump1016;
    fail_assertion("non-positive loop bound");
    _jump1016:;
    _298 = 0;
    int64_t _299 = 0; // q
    int64_t _300 = 0; // p
    _jump1017:; // Begin body of loop
    int64_t _301 = 548;
    if (_301 >= 0)
    goto _jump1018;
    fail_assertion("negative array index");
    _jump1018:;
    if (_301 < _99.d0)
    goto _jump1019;
    fail_assertion("index too large");
    _jump1019:;
    int64_t _302 = 0;
    _302 *= _99.d0;
    _302 += _301;
    double _303 = _99.data[_302];
    _298 += _303;
    _299++;
    if (_299 < c.d1)
    goto _jump1017;
    _299 = 0;
    _300++;
    if (_300 < c.d0)
    goto _jump1017;
    // End body of loop
    rgba _304 = j();
    double _305 = _304.b;
    if (_99.d0 >= 0)
    goto _jump1020;
    fail_assertion("negative array index");
    _jump1020:;
    if (_99.d0 < _99.d0)
    goto _jump1021;
    fail_assertion("index too large");
    _jump1021:;
    int64_t _306 = 0;
    _306 *= _99.d0;
    _306 += _99.d0;
    double _307 = _99.data[_306];
    double _308 = _305 - _307;
    double _309 = -_308;
    double _310 = _298 + _309;
    bool _311 = e != d;
    bool _312;
    if (!_311)
    goto _jump1022;
    _312 = a;
    goto _jump1023;
    _jump1022:;
    _312 = a;
    _jump1023:;
    bool _313;
    if (!_312)
    goto _jump1024;
    double _314 = 41.0;
    double _315 = 49.0;
    bool _316 = _314 >= _315;
    _313 = _316;
    goto _jump1025;
    _jump1024:;
    g _317 = { a, _99.d0 };
    bool _318 = _317.a;
    _313 = _318;
    _jump1025:;
    double _319;
    if (!_313)
    goto _jump1026;
    double _320;
    // Computing bound for p
    if (c.d0 > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    _320 = 0;
    int64_t _321 = 0; // p
    _jump1028:; // Begin body of loop
    _a2_double _322;
    // Computing bound for q
    _322.d0 = _321;
    if (_321 > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    // Computing bound for r
    _322.d1 = _99.d0;
    if (_99.d0 > 0) 
    goto _jump1030;
    fail_assertion("non-positive loop bound");
    _jump1030:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= _321;
    _323 *= _99.d0;
    _323 *= sizeof(double);
    _322.data = jpl_alloc(_323);
    int64_t _324 = 0; // r
    int64_t _325 = 0; // q
    _jump1031:; // Begin body of loop
    double _326 = 74.0;
    int64_t _327 = 0;
    _327 *= _322.d0;
    _327 += _325;
    _327 *= _322.d1;
    _327 += _324;
    _322.data[_327] = _326;
    _324++;
    if (_324 < _99.d0)
    goto _jump1031;
    _324 = 0;
    _325++;
    if (_325 < _321)
    goto _jump1031;
    // End body of loop
    int64_t _328;
    // Computing bound for q
    if (i > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    // Computing bound for r
    if (e > 0) 
    goto _jump1033;
    fail_assertion("non-positive loop bound");
    _jump1033:;
    _328 = 0;
    int64_t _329 = 0; // r
    int64_t _330 = 0; // q
    _jump1034:; // Begin body of loop
    int64_t _331 = 238;
    _328 += _331;
    _329++;
    if (_329 < e)
    goto _jump1034;
    _329 = 0;
    _330++;
    if (_330 < i)
    goto _jump1034;
    // End body of loop
    if (_328 >= 0)
    goto _jump1035;
    fail_assertion("negative array index");
    _jump1035:;
    if (_328 < _322.d0)
    goto _jump1036;
    fail_assertion("index too large");
    _jump1036:;
    if (_99.d0 >= 0)
    goto _jump1037;
    fail_assertion("negative array index");
    _jump1037:;
    if (_99.d0 < _322.d1)
    goto _jump1038;
    fail_assertion("index too large");
    _jump1038:;
    int64_t _332 = 0;
    _332 *= _322.d0;
    _332 += _328;
    _332 *= _322.d1;
    _332 += _99.d0;
    double _333 = _322.data[_332];
    _320 += _333;
    _321++;
    if (_321 < c.d0)
    goto _jump1028;
    // End body of loop
    _319 = _320;
    goto _jump1039;
    _jump1026:;
    if (_99.d0 >= 0)
    goto _jump1040;
    fail_assertion("negative array index");
    _jump1040:;
    if (_99.d0 < _99.d0)
    goto _jump1041;
    fail_assertion("index too large");
    _jump1041:;
    int64_t _334 = 0;
    _334 *= _99.d0;
    _334 += _99.d0;
    double _335 = _99.data[_334];
    double _336 = -_335;
    double _337 = 92.0;
    double _338 = 93.0;
    double _339 = -_338;
    double _340 = _337 - _339;
    double _341 = fmod(_336, _340);
    _319 = _341;
    _jump1039:;
    _a1_double _342;
    if (!a)
    goto _jump1042;
    _342 = _99;
    goto _jump1043;
    _jump1042:;
    _a1_double _343;
    // Computing bound for p
    _343.d0 = i;
    if (i > 0) 
    goto _jump1044;
    fail_assertion("non-positive loop bound");
    _jump1044:;
    // Computing total size of heap memory to allocate
    int64_t _344 = 1;
    _344 *= i;
    _344 *= sizeof(double);
    _343.data = jpl_alloc(_344);
    int64_t _345 = 0; // p
    _jump1045:; // Begin body of loop
    double _346 = 34.0;
    int64_t _347 = 0;
    _347 *= _343.d0;
    _347 += _345;
    _343.data[_347] = _346;
    _345++;
    if (_345 < i)
    goto _jump1045;
    // End body of loop
    _342 = _343;
    _jump1043:;
    if (d >= 0)
    goto _jump1046;
    fail_assertion("negative array index");
    _jump1046:;
    if (d < _342.d0)
    goto _jump1047;
    fail_assertion("index too large");
    _jump1047:;
    int64_t _348 = 0;
    _348 *= _342.d0;
    _348 += d;
    double _349 = _342.data[_348];
    bool _351 = false;
    bool _350 = _351;
    if (0 == _351)
    goto _jump1048;
    bool _352 = true;
    _350 = _352;
    _jump1048:;
    double _353;
    if (!_350)
    goto _jump1049;
    double _354 = 22.0;
    _353 = _354;
    goto _jump1050;
    _jump1049:;
    rgba _355 = j();
    double _356 = _355.a;
    _353 = _356;
    _jump1050:;
    double _357 = _349 * _353;
    double _358;
    // Computing bound for p
    int64_t _359;
    // Computing bound for p
    if (d > 0) 
    goto _jump1051;
    fail_assertion("non-positive loop bound");
    _jump1051:;
    _359 = 0;
    int64_t _360 = 0; // p
    _jump1052:; // Begin body of loop
    _359 += c.d1;
    _360++;
    if (_360 < d)
    goto _jump1052;
    // End body of loop
    if (_359 > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing bound for q
    int64_t _361 = -c.d1;
    if (_361 > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing bound for r
    if (_99.d0 > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    _358 = 0;
    int64_t _362 = 0; // r
    int64_t _363 = 0; // q
    int64_t _364 = 0; // p
    _jump1056:; // Begin body of loop
    double _365 = 77.0;
    _358 += _365;
    _362++;
    if (_362 < _99.d0)
    goto _jump1056;
    _362 = 0;
    _363++;
    if (_363 < _361)
    goto _jump1056;
    _363 = 0;
    _364++;
    if (_364 < _359)
    goto _jump1056;
    // End body of loop
    double _366 = 8.0;
    double _367 = -_366;
    double _368 = 73.0;
    double _369 = fmod(_367, _368);
    double _370 = _358 + _369;
    double _371 = -_370;
    rgba _372 = { _310, _319, _357, _371 };
    _254 = _372;
    _jump1014:;
    _230 = _254;
    goto _jump1057;
    _jump957:;
    rgba _373 = j();
    _230 = _373;
    _jump1057:;
    return _230;
    bool _374 = a;
    if (0 != a)
    goto _jump1058;
    bool _375 = true;
    _374 = _375;
    _jump1058:;
    _a2_int64_t _376;
    // Computing bound for p
    _376.d0 = _99.d0;
    if (_99.d0 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing bound for q
    _376.d1 = d;
    if (d > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing total size of heap memory to allocate
    int64_t _377 = 1;
    _377 *= _99.d0;
    _377 *= d;
    _377 *= sizeof(int64_t);
    _376.data = jpl_alloc(_377);
    int64_t _378 = 0; // q
    int64_t _379 = 0; // p
    _jump1061:; // Begin body of loop
    int64_t _380 = 0;
    _380 *= _376.d0;
    _380 += _379;
    _380 *= _376.d1;
    _380 += _378;
    _376.data[_380] = e;
    _378++;
    if (_378 < d)
    goto _jump1061;
    _378 = 0;
    _379++;
    if (_379 < _99.d0)
    goto _jump1061;
    // End body of loop
    bool _381 = !a;
    bool _382 = _381 == a;
    int64_t _383;
    if (!_382)
    goto _jump1062;
    _383 = c.d0;
    goto _jump1063;
    _jump1062:;
    _383 = c.d1;
    _jump1063:;
    int64_t _384 = _383 - e;
    if (_384 >= 0)
    goto _jump1064;
    fail_assertion("negative array index");
    _jump1064:;
    if (_384 < _376.d0)
    goto _jump1065;
    fail_assertion("index too large");
    _jump1065:;
    if (i >= 0)
    goto _jump1066;
    fail_assertion("negative array index");
    _jump1066:;
    if (i < _376.d1)
    goto _jump1067;
    fail_assertion("index too large");
    _jump1067:;
    int64_t _385 = 0;
    _385 *= _376.d0;
    _385 += _384;
    _385 *= _376.d1;
    _385 += i;
    int64_t _386 = _376.data[_385];
    bool _387 = _386 >= _99.d0;
    _a1_bool _388;
    _388.d0 = 3;
    _388.data = jpl_alloc(sizeof(bool) * 3);
    _388.data[0] = _374;
    _388.data[1] = _387;
    _388.data[2] = a;
    _a2_void_t _389;
    // Computing bound for r
    int64_t _390 = 884;
    _389.d0 = _390;
    if (_390 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing bound for s
    _389.d1 = i;
    if (i > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= _390;
    _391 *= i;
    _391 *= sizeof(void_t);
    _389.data = jpl_alloc(_391);
    int64_t _392 = 0; // s
    int64_t _393 = 0; // r
    _jump1070:; // Begin body of loop
    _a1__a3_bool _394;
    // Computing bound for t
    int64_t _395 = d + _393;
    _394.d0 = _395;
    if (_395 > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing total size of heap memory to allocate
    int64_t _396 = 1;
    _396 *= _395;
    _396 *= sizeof(_a3_bool);
    _394.data = jpl_alloc(_396);
    int64_t _397 = 0; // t
    _jump1072:; // Begin body of loop
    _a3_bool _398;
    // Computing bound for u
    _398.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump1073;
    fail_assertion("non-positive loop bound");
    _jump1073:;
    // Computing bound for v
    _398.d1 = e;
    if (e > 0) 
    goto _jump1074;
    fail_assertion("non-positive loop bound");
    _jump1074:;
    // Computing bound for w
    _398.d2 = i;
    if (i > 0) 
    goto _jump1075;
    fail_assertion("non-positive loop bound");
    _jump1075:;
    // Computing total size of heap memory to allocate
    int64_t _399 = 1;
    _399 *= c.d0;
    _399 *= e;
    _399 *= i;
    _399 *= sizeof(bool);
    _398.data = jpl_alloc(_399);
    int64_t _400 = 0; // w
    int64_t _401 = 0; // v
    int64_t _402 = 0; // u
    _jump1076:; // Begin body of loop
    int64_t _403 = 0;
    _403 *= _398.d0;
    _403 += _402;
    _403 *= _398.d1;
    _403 += _401;
    _403 *= _398.d2;
    _403 += _400;
    _398.data[_403] = a;
    _400++;
    if (_400 < i)
    goto _jump1076;
    _400 = 0;
    _401++;
    if (_401 < e)
    goto _jump1076;
    _401 = 0;
    _402++;
    if (_402 < c.d0)
    goto _jump1076;
    // End body of loop
    int64_t _404 = 0;
    _404 *= _394.d0;
    _404 += _397;
    _394.data[_404] = _398;
    _397++;
    if (_397 < _395)
    goto _jump1072;
    // End body of loop
    if (c.d0 >= 0)
    goto _jump1077;
    fail_assertion("negative array index");
    _jump1077:;
    if (c.d0 < _394.d0)
    goto _jump1078;
    fail_assertion("index too large");
    _jump1078:;
    int64_t _405 = 0;
    _405 *= _394.d0;
    _405 += c.d0;
    _a3_bool _406 = _394.data[_405];
    if (_388.d0 >= 0)
    goto _jump1079;
    fail_assertion("negative array index");
    _jump1079:;
    if (_388.d0 < c.d0)
    goto _jump1080;
    fail_assertion("index too large");
    _jump1080:;
    if (d >= 0)
    goto _jump1081;
    fail_assertion("negative array index");
    _jump1081:;
    if (d < c.d1)
    goto _jump1082;
    fail_assertion("index too large");
    _jump1082:;
    int64_t _407 = 0;
    _407 *= c.d0;
    _407 += _388.d0;
    _407 *= c.d1;
    _407 += d;
    bool _408 = c.data[_407];
    int64_t _409 = _388.d0 % _393;
    g _410 = { _408, _409 };
    int64_t _411 = _410.b;
    if (c.d1 >= 0)
    goto _jump1083;
    fail_assertion("negative array index");
    _jump1083:;
    if (c.d1 < _406.d0)
    goto _jump1084;
    fail_assertion("index too large");
    _jump1084:;
    if (_411 >= 0)
    goto _jump1085;
    fail_assertion("negative array index");
    _jump1085:;
    if (_411 < _406.d1)
    goto _jump1086;
    fail_assertion("index too large");
    _jump1086:;
    if (_388.d0 >= 0)
    goto _jump1087;
    fail_assertion("negative array index");
    _jump1087:;
    if (_388.d0 < _406.d2)
    goto _jump1088;
    fail_assertion("index too large");
    _jump1088:;
    int64_t _412 = 0;
    _412 *= _406.d0;
    _412 += c.d1;
    _412 *= _406.d1;
    _412 += _411;
    _412 *= _406.d2;
    _412 += _388.d0;
    bool _413 = _406.data[_412];
    _a2_bool _414;
    if (!_413)
    goto _jump1089;
    _a3_bool _415;
    // Computing bound for t
    int64_t _416 = 196;
    _415.d0 = _416;
    if (_416 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for u
    int64_t _417 = 752;
    _415.d1 = _417;
    if (_417 > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    // Computing bound for v
    _415.d2 = c.d1;
    if (c.d1 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing total size of heap memory to allocate
    int64_t _418 = 1;
    _418 *= _416;
    _418 *= _417;
    _418 *= c.d1;
    _418 *= sizeof(bool);
    _415.data = jpl_alloc(_418);
    int64_t _419 = 0; // v
    int64_t _420 = 0; // u
    int64_t _421 = 0; // t
    _jump1093:; // Begin body of loop
    int64_t _422 = 0;
    _422 *= _415.d0;
    _422 += _421;
    _422 *= _415.d1;
    _422 += _420;
    _422 *= _415.d2;
    _422 += _419;
    _415.data[_422] = a;
    _419++;
    if (_419 < c.d1)
    goto _jump1093;
    _419 = 0;
    _420++;
    if (_420 < _417)
    goto _jump1093;
    _420 = 0;
    _421++;
    if (_421 < _416)
    goto _jump1093;
    // End body of loop
    if (d >= 0)
    goto _jump1094;
    fail_assertion("negative array index");
    _jump1094:;
    if (d < _415.d0)
    goto _jump1095;
    fail_assertion("index too large");
    _jump1095:;
    if (c.d0 >= 0)
    goto _jump1096;
    fail_assertion("negative array index");
    _jump1096:;
    if (c.d0 < _415.d1)
    goto _jump1097;
    fail_assertion("index too large");
    _jump1097:;
    if (i >= 0)
    goto _jump1098;
    fail_assertion("negative array index");
    _jump1098:;
    if (i < _415.d2)
    goto _jump1099;
    fail_assertion("index too large");
    _jump1099:;
    int64_t _423 = 0;
    _423 *= _415.d0;
    _423 += d;
    _423 *= _415.d1;
    _423 += c.d0;
    _423 *= _415.d2;
    _423 += i;
    bool _424 = _415.data[_423];
    _a3__a2_bool _425;
    if (!_424)
    goto _jump1100;
    _a3__a2_bool _426;
    // Computing bound for t
    bool _427 = true;
    int64_t _428;
    if (!_427)
    goto _jump1101;
    _428 = _388.d0;
    goto _jump1102;
    _jump1101:;
    _428 = _393;
    _jump1102:;
    _426.d0 = _428;
    if (_428 > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    // Computing bound for u
    int64_t _429 = 308;
    _426.d1 = _429;
    if (_429 > 0) 
    goto _jump1104;
    fail_assertion("non-positive loop bound");
    _jump1104:;
    // Computing bound for v
    int64_t _430 = 786;
    _426.d2 = _430;
    if (_430 > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing total size of heap memory to allocate
    int64_t _431 = 1;
    _431 *= _428;
    _431 *= _429;
    _431 *= _430;
    _431 *= sizeof(_a2_bool);
    _426.data = jpl_alloc(_431);
    int64_t _432 = 0; // v
    int64_t _433 = 0; // u
    int64_t _434 = 0; // t
    _jump1106:; // Begin body of loop
    bool _435 = true;
    _a2_bool _436;
    if (!_435)
    goto _jump1107;
    _436 = c;
    goto _jump1108;
    _jump1107:;
    _436 = c;
    _jump1108:;
    int64_t _437 = 0;
    _437 *= _426.d0;
    _437 += _434;
    _437 *= _426.d1;
    _437 += _433;
    _437 *= _426.d2;
    _437 += _432;
    _426.data[_437] = _436;
    _432++;
    if (_432 < _430)
    goto _jump1106;
    _432 = 0;
    _433++;
    if (_433 < _429)
    goto _jump1106;
    _433 = 0;
    _434++;
    if (_434 < _428)
    goto _jump1106;
    // End body of loop
    _425 = _426;
    goto _jump1109;
    _jump1100:;
    _a3__a2_bool _438;
    // Computing bound for t
    _438.d0 = _99.d0;
    if (_99.d0 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for u
    _438.d1 = _393;
    if (_393 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for v
    _438.d2 = i;
    if (i > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= _99.d0;
    _439 *= _393;
    _439 *= i;
    _439 *= sizeof(_a2_bool);
    _438.data = jpl_alloc(_439);
    int64_t _440 = 0; // v
    int64_t _441 = 0; // u
    int64_t _442 = 0; // t
    _jump1113:; // Begin body of loop
    _a2_bool _443;
    // Computing bound for w
    _443.d0 = _388.d0;
    if (_388.d0 > 0) 
    goto _jump1114;
    fail_assertion("non-positive loop bound");
    _jump1114:;
    // Computing bound for x
    _443.d1 = _441;
    if (_441 > 0) 
    goto _jump1115;
    fail_assertion("non-positive loop bound");
    _jump1115:;
    // Computing total size of heap memory to allocate
    int64_t _444 = 1;
    _444 *= _388.d0;
    _444 *= _441;
    _444 *= sizeof(bool);
    _443.data = jpl_alloc(_444);
    int64_t _445 = 0; // x
    int64_t _446 = 0; // w
    _jump1116:; // Begin body of loop
    int64_t _447 = 0;
    _447 *= _443.d0;
    _447 += _446;
    _447 *= _443.d1;
    _447 += _445;
    _443.data[_447] = a;
    _445++;
    if (_445 < _441)
    goto _jump1116;
    _445 = 0;
    _446++;
    if (_446 < _388.d0)
    goto _jump1116;
    // End body of loop
    int64_t _448 = 0;
    _448 *= _438.d0;
    _448 += _442;
    _448 *= _438.d1;
    _448 += _441;
    _448 *= _438.d2;
    _448 += _440;
    _438.data[_448] = _443;
    _440++;
    if (_440 < i)
    goto _jump1113;
    _440 = 0;
    _441++;
    if (_441 < _393)
    goto _jump1113;
    _441 = 0;
    _442++;
    if (_442 < _99.d0)
    goto _jump1113;
    // End body of loop
    _425 = _438;
    _jump1109:;
    int64_t _449 = 397;
    g _450 = { a, d };
    int64_t _451 = _450.b;
    int64_t _452 = -_451;
    bool _453 = !a;
    int64_t _454;
    if (!_453)
    goto _jump1117;
    _454 = c.d1;
    goto _jump1118;
    _jump1117:;
    bool _455 = true;
    g _456 = { _455, _393 };
    int64_t _457 = _456.b;
    _454 = _457;
    _jump1118:;
    if (_449 >= 0)
    goto _jump1119;
    fail_assertion("negative array index");
    _jump1119:;
    if (_449 < _425.d0)
    goto _jump1120;
    fail_assertion("index too large");
    _jump1120:;
    if (_452 >= 0)
    goto _jump1121;
    fail_assertion("negative array index");
    _jump1121:;
    if (_452 < _425.d1)
    goto _jump1122;
    fail_assertion("index too large");
    _jump1122:;
    if (_454 >= 0)
    goto _jump1123;
    fail_assertion("negative array index");
    _jump1123:;
    if (_454 < _425.d2)
    goto _jump1124;
    fail_assertion("index too large");
    _jump1124:;
    int64_t _458 = 0;
    _458 *= _425.d0;
    _458 += _449;
    _458 *= _425.d1;
    _458 += _452;
    _458 *= _425.d2;
    _458 += _454;
    _a2_bool _459 = _425.data[_458];
    _414 = _459;
    goto _jump1125;
    _jump1089:;
    _414 = c;
    _jump1125:;
    _a3_bool _460;
    // Computing bound for t
    int64_t _461 = 815;
    _460.d0 = _461;
    if (_461 > 0) 
    goto _jump1126;
    fail_assertion("non-positive loop bound");
    _jump1126:;
    // Computing bound for u
    int64_t _462 = _392 * _99.d0;
    int64_t _463 = -_462;
    _460.d1 = _463;
    if (_463 > 0) 
    goto _jump1127;
    fail_assertion("non-positive loop bound");
    _jump1127:;
    // Computing bound for v
    _460.d2 = _393;
    if (_393 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= _461;
    _464 *= _463;
    _464 *= _393;
    _464 *= sizeof(bool);
    _460.data = jpl_alloc(_464);
    int64_t _465 = 0; // v
    int64_t _466 = 0; // u
    int64_t _467 = 0; // t
    _jump1129:; // Begin body of loop
    bool _468 = false;
    int64_t _469 = 0;
    _469 *= _460.d0;
    _469 += _467;
    _469 *= _460.d1;
    _469 += _466;
    _469 *= _460.d2;
    _469 += _465;
    _460.data[_469] = _468;
    _465++;
    if (_465 < _393)
    goto _jump1129;
    _465 = 0;
    _466++;
    if (_466 < _463)
    goto _jump1129;
    _466 = 0;
    _467++;
    if (_467 < _461)
    goto _jump1129;
    // End body of loop
    if (i >= 0)
    goto _jump1130;
    fail_assertion("negative array index");
    _jump1130:;
    if (i < _460.d0)
    goto _jump1131;
    fail_assertion("index too large");
    _jump1131:;
    if (_99.d0 >= 0)
    goto _jump1132;
    fail_assertion("negative array index");
    _jump1132:;
    if (_99.d0 < _460.d1)
    goto _jump1133;
    fail_assertion("index too large");
    _jump1133:;
    if (_99.d0 >= 0)
    goto _jump1134;
    fail_assertion("negative array index");
    _jump1134:;
    if (_99.d0 < _460.d2)
    goto _jump1135;
    fail_assertion("index too large");
    _jump1135:;
    int64_t _470 = 0;
    _470 *= _460.d0;
    _470 += i;
    _470 *= _460.d1;
    _470 += _99.d0;
    _470 *= _460.d2;
    _470 += _99.d0;
    bool _471 = _460.data[_470];
    _a2__a1_void_t _472;
    if (!_471)
    goto _jump1136;
    _a2__a1_void_t _473;
    // Computing bound for t
    int64_t _474 = -d;
    int64_t _475 = _474 - i;
    _473.d0 = _475;
    if (_475 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    // Computing bound for u
    _473.d1 = i;
    if (i > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing total size of heap memory to allocate
    int64_t _476 = 1;
    _476 *= _475;
    _476 *= i;
    _476 *= sizeof(_a1_void_t);
    _473.data = jpl_alloc(_476);
    int64_t _477 = 0; // u
    int64_t _478 = 0; // t
    _jump1139:; // Begin body of loop
    bool _480 = c.d0 != c.d1;
    bool _479 = _480;
    if (0 == _480)
    goto _jump1140;
    int64_t _481 = 744;
    bool _482 = _481 > _388.d0;
    _479 = _482;
    _jump1140:;
    _a1_void_t _483;
    if (!_479)
    goto _jump1141;
    _a1_void_t _484;
    // Computing bound for v
    _484.d0 = i;
    if (i > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    // Computing total size of heap memory to allocate
    int64_t _485 = 1;
    _485 *= i;
    _485 *= sizeof(void_t);
    _484.data = jpl_alloc(_485);
    int64_t _486 = 0; // v
    _jump1143:; // Begin body of loop
    int64_t _487 = 964;
    rgba _488 = j();
    void_t _489 = h(_487, _488, _477);
    int64_t _490 = 0;
    _490 *= _484.d0;
    _490 += _486;
    _484.data[_490] = _489;
    _486++;
    if (_486 < i)
    goto _jump1143;
    // End body of loop
    _483 = _484;
    goto _jump1144;
    _jump1141:;
    rgba _491 = j();
    void_t _492 = h(i, _491, _393);
    _a1_void_t _493;
    _493.d0 = 1;
    _493.data = jpl_alloc(sizeof(void_t) * 1);
    _493.data[0] = _492;
    _483 = _493;
    _jump1144:;
    int64_t _494 = 0;
    _494 *= _473.d0;
    _494 += _478;
    _494 *= _473.d1;
    _494 += _477;
    _473.data[_494] = _483;
    _477++;
    if (_477 < i)
    goto _jump1139;
    _477 = 0;
    _478++;
    if (_478 < _475)
    goto _jump1139;
    // End body of loop
    _472 = _473;
    goto _jump1145;
    _jump1136:;
    _a2__a1_void_t _495;
    // Computing bound for t
    _495.d0 = i;
    if (i > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing bound for u
    _495.d1 = _99.d0;
    if (_99.d0 > 0) 
    goto _jump1147;
    fail_assertion("non-positive loop bound");
    _jump1147:;
    // Computing total size of heap memory to allocate
    int64_t _496 = 1;
    _496 *= i;
    _496 *= _99.d0;
    _496 *= sizeof(_a1_void_t);
    _495.data = jpl_alloc(_496);
    int64_t _497 = 0; // u
    int64_t _498 = 0; // t
    _jump1148:; // Begin body of loop
    int64_t _499 = -e;
    rgba _500 = j();
    int64_t _501;
    // Computing bound for v
    int64_t _502 = 8;
    if (_502 > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    _501 = 0;
    int64_t _503 = 0; // v
    _jump1150:; // Begin body of loop
    _501 += _498;
    _503++;
    if (_503 < _502)
    goto _jump1150;
    // End body of loop
    void_t _504 = h(_499, _500, _501);
    rgba _505 = j();
    int64_t _506 = 716;
    void_t _507 = h(_99.d0, _505, _506);
    _a1_void_t _508;
    _508.d0 = 2;
    _508.data = jpl_alloc(sizeof(void_t) * 2);
    _508.data[0] = _504;
    _508.data[1] = _507;
    int64_t _509 = 0;
    _509 *= _495.d0;
    _509 += _498;
    _509 *= _495.d1;
    _509 += _497;
    _495.data[_509] = _508;
    _497++;
    if (_497 < _99.d0)
    goto _jump1148;
    _497 = 0;
    _498++;
    if (_498 < i)
    goto _jump1148;
    // End body of loop
    _472 = _495;
    _jump1145:;
    void_t _510 = b(_414, e, _472);
    int64_t _511 = 0;
    _511 *= _389.d0;
    _511 += _393;
    _511 *= _389.d1;
    _511 += _392;
    _389.data[_511] = _510;
    _392++;
    if (_392 < i)
    goto _jump1070;
    _392 = 0;
    _393++;
    if (_393 < _390)
    goto _jump1070;
    // End body of loop
    double _512 = 33.0;
    rgba _513 = j();
    return _513;
}

g l() {
    _a3__a3__a3_double _0;
    // Computing bound for m
    _0.d0 = d;
    if (d > 0) 
    goto _jump1151;
    fail_assertion("non-positive loop bound");
    _jump1151:;
    // Computing bound for n
    _a1_int64_t _1;
    // Computing bound for m
    int64_t _2 = 788;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= sizeof(int64_t);
    _1.data = jpl_alloc(_3);
    int64_t _4 = 0; // m
    _jump1153:; // Begin body of loop
    int64_t _5 = 0;
    _5 *= _1.d0;
    _5 += _4;
    _1.data[_5] = d;
    _4++;
    if (_4 < _2)
    goto _jump1153;
    // End body of loop
    if (d >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (d < _1.d0)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    int64_t _6 = 0;
    _6 *= _1.d0;
    _6 += d;
    int64_t _7 = _1.data[_6];
    _0.d1 = _7;
    if (_7 > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    // Computing bound for o
    _0.d2 = i;
    if (i > 0) 
    goto _jump1157;
    fail_assertion("non-positive loop bound");
    _jump1157:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= d;
    _8 *= _7;
    _8 *= i;
    _8 *= sizeof(_a3__a3_double);
    _0.data = jpl_alloc(_8);
    int64_t _9 = 0; // o
    int64_t _10 = 0; // n
    int64_t _11 = 0; // m
    _jump1158:; // Begin body of loop
    _a3__a3_double _12;
    // Computing bound for p
    _12.d0 = i;
    if (i > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    // Computing bound for q
    _12.d1 = d;
    if (d > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing bound for r
    _12.d2 = i;
    if (i > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= i;
    _13 *= d;
    _13 *= i;
    _13 *= sizeof(_a3_double);
    _12.data = jpl_alloc(_13);
    int64_t _14 = 0; // r
    int64_t _15 = 0; // q
    int64_t _16 = 0; // p
    _jump1162:; // Begin body of loop
    _a3_double _17;
    // Computing bound for s
    int64_t _18 = 531;
    int64_t _19 = _15 - _18;
    _17.d0 = _19;
    if (_19 > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing bound for t
    _17.d1 = _11;
    if (_11 > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    // Computing bound for u
    _17.d2 = _16;
    if (_16 > 0) 
    goto _jump1165;
    fail_assertion("non-positive loop bound");
    _jump1165:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _19;
    _20 *= _11;
    _20 *= _16;
    _20 *= sizeof(double);
    _17.data = jpl_alloc(_20);
    int64_t _21 = 0; // u
    int64_t _22 = 0; // t
    int64_t _23 = 0; // s
    _jump1166:; // Begin body of loop
    double _24 = 80.0;
    double _25 = -_24;
    int64_t _26 = 0;
    _26 *= _17.d0;
    _26 += _23;
    _26 *= _17.d1;
    _26 += _22;
    _26 *= _17.d2;
    _26 += _21;
    _17.data[_26] = _25;
    _21++;
    if (_21 < _16)
    goto _jump1166;
    _21 = 0;
    _22++;
    if (_22 < _11)
    goto _jump1166;
    _22 = 0;
    _23++;
    if (_23 < _19)
    goto _jump1166;
    // End body of loop
    int64_t _27 = 0;
    _27 *= _12.d0;
    _27 += _16;
    _27 *= _12.d1;
    _27 += _15;
    _27 *= _12.d2;
    _27 += _14;
    _12.data[_27] = _17;
    _14++;
    if (_14 < i)
    goto _jump1162;
    _14 = 0;
    _15++;
    if (_15 < d)
    goto _jump1162;
    _15 = 0;
    _16++;
    if (_16 < i)
    goto _jump1162;
    // End body of loop
    int64_t _28 = 0;
    _28 *= _0.d0;
    _28 += _11;
    _28 *= _0.d1;
    _28 += _10;
    _28 *= _0.d2;
    _28 += _9;
    _0.data[_28] = _12;
    _9++;
    if (_9 < i)
    goto _jump1158;
    _9 = 0;
    _10++;
    if (_10 < _7)
    goto _jump1158;
    _10 = 0;
    _11++;
    if (_11 < d)
    goto _jump1158;
    // End body of loop
    int64_t _29 = -e;
    int64_t _30 = -_29;
    double _31 = 68.0;
    double _32 = 36.0;
    bool _33 = _31 > _32;
    bool _34 = _33 != a;
    int64_t _35;
    if (!_34)
    goto _jump1167;
    int64_t _36;
    // Computing bound for m
    int64_t _37 = 72;
    if (_37 > 0) 
    goto _jump1168;
    fail_assertion("non-positive loop bound");
    _jump1168:;
    // Computing bound for n
    if (e > 0) 
    goto _jump1169;
    fail_assertion("non-positive loop bound");
    _jump1169:;
    // Computing bound for o
    if (i > 0) 
    goto _jump1170;
    fail_assertion("non-positive loop bound");
    _jump1170:;
    _36 = 0;
    int64_t _38 = 0; // o
    int64_t _39 = 0; // n
    int64_t _40 = 0; // m
    _jump1171:; // Begin body of loop
    _36 += _40;
    _38++;
    if (_38 < i)
    goto _jump1171;
    _38 = 0;
    _39++;
    if (_39 < e)
    goto _jump1171;
    _39 = 0;
    _40++;
    if (_40 < _37)
    goto _jump1171;
    // End body of loop
    _35 = _36;
    goto _jump1172;
    _jump1167:;
    bool _41 = false;
    int64_t _42;
    if (!_41)
    goto _jump1173;
    int64_t _43;
    // Computing bound for m
    int64_t _44 = 925;
    if (_44 > 0) 
    goto _jump1174;
    fail_assertion("non-positive loop bound");
    _jump1174:;
    // Computing bound for n
    if (i > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    // Computing bound for o
    int64_t _45 = -e;
    if (_45 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    _43 = 0;
    int64_t _46 = 0; // o
    int64_t _47 = 0; // n
    int64_t _48 = 0; // m
    _jump1177:; // Begin body of loop
    _43 += i;
    _46++;
    if (_46 < _45)
    goto _jump1177;
    _46 = 0;
    _47++;
    if (_47 < i)
    goto _jump1177;
    _47 = 0;
    _48++;
    if (_48 < _44)
    goto _jump1177;
    // End body of loop
    _42 = _43;
    goto _jump1178;
    _jump1173:;
    int64_t _49;
    if (!a)
    goto _jump1179;
    _49 = i;
    goto _jump1180;
    _jump1179:;
    g _50 = l();
    int64_t _51 = _50.b;
    _49 = _51;
    _jump1180:;
    _42 = _49;
    _jump1178:;
    _35 = _42;
    _jump1172:;
    if (_30 >= 0)
    goto _jump1181;
    fail_assertion("negative array index");
    _jump1181:;
    if (_30 < _0.d0)
    goto _jump1182;
    fail_assertion("index too large");
    _jump1182:;
    if (_35 >= 0)
    goto _jump1183;
    fail_assertion("negative array index");
    _jump1183:;
    if (_35 < _0.d1)
    goto _jump1184;
    fail_assertion("index too large");
    _jump1184:;
    if (d >= 0)
    goto _jump1185;
    fail_assertion("negative array index");
    _jump1185:;
    if (d < _0.d2)
    goto _jump1186;
    fail_assertion("index too large");
    _jump1186:;
    int64_t _52 = 0;
    _52 *= _0.d0;
    _52 += _30;
    _52 *= _0.d1;
    _52 += _35;
    _52 *= _0.d2;
    _52 += d;
    _a3__a3_double _53 = _0.data[_52];
    _a1_int64_t _54;
    // Computing bound for m
    int64_t _55 = 724;
    _54.d0 = _55;
    if (_55 > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= _55;
    _56 *= sizeof(int64_t);
    _54.data = jpl_alloc(_56);
    int64_t _57 = 0; // m
    _jump1188:; // Begin body of loop
    int64_t _58;
    // Computing bound for n
    int64_t _59;
    if (!a)
    goto _jump1189;
    _59 = _57;
    goto _jump1190;
    _jump1189:;
    int64_t _60 = 450;
    _59 = _60;
    _jump1190:;
    if (_59 > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing bound for o
    if (d > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    _58 = 0;
    int64_t _61 = 0; // o
    int64_t _62 = 0; // n
    _jump1193:; // Begin body of loop
    _58 += i;
    _61++;
    if (_61 < d)
    goto _jump1193;
    _61 = 0;
    _62++;
    if (_62 < _59)
    goto _jump1193;
    // End body of loop
    int64_t _63 = 806;
    int64_t _64 = _58 * _63;
    int64_t _65 = 0;
    _65 *= _54.d0;
    _65 += _57;
    _54.data[_65] = _64;
    _57++;
    if (_57 < _55)
    goto _jump1188;
    // End body of loop
    int64_t _66 = -d;
    bool _67 = !a;
    int64_t _68;
    if (!_67)
    goto _jump1194;
    _68 = e;
    goto _jump1195;
    _jump1194:;
    _68 = d;
    _jump1195:;
    int64_t _69 = _66 + _68;
    int64_t _70 = i + _69;
    if (_70 >= 0)
    goto _jump1196;
    fail_assertion("negative array index");
    _jump1196:;
    if (_70 < _54.d0)
    goto _jump1197;
    fail_assertion("index too large");
    _jump1197:;
    int64_t _71 = 0;
    _71 *= _54.d0;
    _71 += _70;
    int64_t _72 = _54.data[_71];
    _a3__a3_double _73;
    // Computing bound for m
    int64_t _74 = -i;
    _73.d0 = _74;
    if (_74 > 0) 
    goto _jump1198;
    fail_assertion("non-positive loop bound");
    _jump1198:;
    // Computing bound for n
    int64_t _75 = i % i;
    _73.d1 = _75;
    if (_75 > 0) 
    goto _jump1199;
    fail_assertion("non-positive loop bound");
    _jump1199:;
    // Computing bound for o
    _73.d2 = d;
    if (d > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _74;
    _76 *= _75;
    _76 *= d;
    _76 *= sizeof(_a3_double);
    _73.data = jpl_alloc(_76);
    int64_t _77 = 0; // o
    int64_t _78 = 0; // n
    int64_t _79 = 0; // m
    _jump1201:; // Begin body of loop
    _a3_double _80;
    // Computing bound for p
    _80.d0 = d;
    if (d > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for q
    int64_t _81 = _77 - _77;
    _80.d1 = _81;
    if (_81 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing bound for r
    _80.d2 = e;
    if (e > 0) 
    goto _jump1204;
    fail_assertion("non-positive loop bound");
    _jump1204:;
    // Computing total size of heap memory to allocate
    int64_t _82 = 1;
    _82 *= d;
    _82 *= _81;
    _82 *= e;
    _82 *= sizeof(double);
    _80.data = jpl_alloc(_82);
    int64_t _83 = 0; // r
    int64_t _84 = 0; // q
    int64_t _85 = 0; // p
    _jump1205:; // Begin body of loop
    rgba _86 = j();
    double _87 = _86.r;
    int64_t _88 = 0;
    _88 *= _80.d0;
    _88 += _85;
    _88 *= _80.d1;
    _88 += _84;
    _88 *= _80.d2;
    _88 += _83;
    _80.data[_88] = _87;
    _83++;
    if (_83 < e)
    goto _jump1205;
    _83 = 0;
    _84++;
    if (_84 < _81)
    goto _jump1205;
    _84 = 0;
    _85++;
    if (_85 < d)
    goto _jump1205;
    // End body of loop
    int64_t _89 = 0;
    _89 *= _73.d0;
    _89 += _79;
    _89 *= _73.d1;
    _89 += _78;
    _89 *= _73.d2;
    _89 += _77;
    _73.data[_89] = _80;
    _77++;
    if (_77 < d)
    goto _jump1201;
    _77 = 0;
    _78++;
    if (_78 < _75)
    goto _jump1201;
    _78 = 0;
    _79++;
    if (_79 < _74)
    goto _jump1201;
    // End body of loop
    int64_t _90 = -d;
    double _91 = 86.0;
    k _92 = { _73, _90, _91 };
    double _93 = _92.c;
    k _94 = { _53, _72, _93 };
    _a3__a3_double _95 = _94.a;
    _a1_double _96;
    if (!a)
    goto _jump1206;
    _a1_double _97;
    // Computing bound for q
    _97.d0 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1207;
    fail_assertion("non-positive loop bound");
    _jump1207:;
    // Computing total size of heap memory to allocate
    int64_t _98 = 1;
    _98 *= _95.d0;
    _98 *= sizeof(double);
    _97.data = jpl_alloc(_98);
    int64_t _99 = 0; // q
    _jump1208:; // Begin body of loop
    _a1_double _100;
    // Computing bound for r
    _a3_int64_t _101;
    // Computing bound for r
    _101.d0 = e;
    if (e > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing bound for s
    _101.d1 = _99;
    if (_99 > 0) 
    goto _jump1210;
    fail_assertion("non-positive loop bound");
    _jump1210:;
    // Computing bound for t
    _101.d2 = e;
    if (e > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= e;
    _102 *= _99;
    _102 *= e;
    _102 *= sizeof(int64_t);
    _101.data = jpl_alloc(_102);
    int64_t _103 = 0; // t
    int64_t _104 = 0; // s
    int64_t _105 = 0; // r
    _jump1212:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _101.d0;
    _106 += _105;
    _106 *= _101.d1;
    _106 += _104;
    _106 *= _101.d2;
    _106 += _103;
    _101.data[_106] = _95.d0;
    _103++;
    if (_103 < e)
    goto _jump1212;
    _103 = 0;
    _104++;
    if (_104 < _99)
    goto _jump1212;
    _104 = 0;
    _105++;
    if (_105 < e)
    goto _jump1212;
    // End body of loop
    int64_t _107 = 315;
    int64_t _108 = -d;
    if (_107 >= 0)
    goto _jump1213;
    fail_assertion("negative array index");
    _jump1213:;
    if (_107 < _101.d0)
    goto _jump1214;
    fail_assertion("index too large");
    _jump1214:;
    if (_108 >= 0)
    goto _jump1215;
    fail_assertion("negative array index");
    _jump1215:;
    if (_108 < _101.d1)
    goto _jump1216;
    fail_assertion("index too large");
    _jump1216:;
    if (_99 >= 0)
    goto _jump1217;
    fail_assertion("negative array index");
    _jump1217:;
    if (_99 < _101.d2)
    goto _jump1218;
    fail_assertion("index too large");
    _jump1218:;
    int64_t _109 = 0;
    _109 *= _101.d0;
    _109 += _107;
    _109 *= _101.d1;
    _109 += _108;
    _109 *= _101.d2;
    _109 += _99;
    int64_t _110 = _101.data[_109];
    _100.d0 = _110;
    if (_110 > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= _110;
    _111 *= sizeof(double);
    _100.data = jpl_alloc(_111);
    int64_t _112 = 0; // r
    _jump1220:; // Begin body of loop
    rgba _113 = j();
    double _114 = _113.a;
    int64_t _115 = 0;
    _115 *= _100.d0;
    _115 += _112;
    _100.data[_115] = _114;
    _112++;
    if (_112 < _110)
    goto _jump1220;
    // End body of loop
    if (_95.d1 >= 0)
    goto _jump1221;
    fail_assertion("negative array index");
    _jump1221:;
    if (_95.d1 < _100.d0)
    goto _jump1222;
    fail_assertion("index too large");
    _jump1222:;
    int64_t _116 = 0;
    _116 *= _100.d0;
    _116 += _95.d1;
    double _117 = _100.data[_116];
    double _118 = -_117;
    int64_t _119 = 0;
    _119 *= _97.d0;
    _119 += _99;
    _97.data[_119] = _118;
    _99++;
    if (_99 < _95.d0)
    goto _jump1208;
    // End body of loop
    _96 = _97;
    goto _jump1223;
    _jump1206:;
    _a1_double _120;
    // Computing bound for q
    _120.d0 = d;
    if (d > 0) 
    goto _jump1224;
    fail_assertion("non-positive loop bound");
    _jump1224:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= d;
    _121 *= sizeof(double);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // q
    _jump1225:; // Begin body of loop
    bool _123 = true;
    double _124;
    if (!_123)
    goto _jump1226;
    double _125 = 4.0;
    _124 = _125;
    goto _jump1227;
    _jump1226:;
    double _126;
    // Computing bound for r
    if (i > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    // Computing bound for s
    if (_95.d2 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    _126 = 0;
    int64_t _127 = 0; // s
    int64_t _128 = 0; // r
    _jump1230:; // Begin body of loop
    double _129 = 76.0;
    _126 += _129;
    _127++;
    if (_127 < _95.d2)
    goto _jump1230;
    _127 = 0;
    _128++;
    if (_128 < i)
    goto _jump1230;
    // End body of loop
    _124 = _126;
    _jump1227:;
    double _130 = -_124;
    int64_t _131 = 0;
    _131 *= _120.d0;
    _131 += _122;
    _120.data[_131] = _130;
    _122++;
    if (_122 < d)
    goto _jump1225;
    // End body of loop
    _96 = _120;
    _jump1223:;
    _a2__a3__a2_bool _132;
    // Computing bound for s
    bool _133 = true;
    g _134;
    if (!_133)
    goto _jump1231;
    g _135 = l();
    _134 = _135;
    goto _jump1232;
    _jump1231:;
    g _136 = l();
    _134 = _136;
    _jump1232:;
    int64_t _137 = _134.b;
    int64_t _138 = -_137;
    _132.d0 = _138;
    if (_138 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing bound for t
    double _139 = 4.0;
    k _140 = { _95, e, _139 };
    int64_t _141 = _140.b;
    _132.d1 = _141;
    if (_141 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _138;
    _142 *= _141;
    _142 *= sizeof(_a3__a2_bool);
    _132.data = jpl_alloc(_142);
    int64_t _143 = 0; // t
    int64_t _144 = 0; // s
    _jump1235:; // Begin body of loop
    _a3__a2_bool _145;
    // Computing bound for u
    _145.d0 = _144;
    if (_144 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing bound for v
    _145.d1 = e;
    if (e > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    // Computing bound for w
    int64_t _146 = _95.d2 * _144;
    _145.d2 = _146;
    if (_146 > 0) 
    goto _jump1238;
    fail_assertion("non-positive loop bound");
    _jump1238:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= _144;
    _147 *= e;
    _147 *= _146;
    _147 *= sizeof(_a2_bool);
    _145.data = jpl_alloc(_147);
    int64_t _148 = 0; // w
    int64_t _149 = 0; // v
    int64_t _150 = 0; // u
    _jump1239:; // Begin body of loop
    bool _151 = true;
    bool _152 = !_151;
    _a2_bool _153;
    if (!_152)
    goto _jump1240;
    _a2_bool _154;
    // Computing bound for x
    _154.d0 = d;
    if (d > 0) 
    goto _jump1241;
    fail_assertion("non-positive loop bound");
    _jump1241:;
    // Computing bound for y
    _154.d1 = _143;
    if (_143 > 0) 
    goto _jump1242;
    fail_assertion("non-positive loop bound");
    _jump1242:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= d;
    _155 *= _143;
    _155 *= sizeof(bool);
    _154.data = jpl_alloc(_155);
    int64_t _156 = 0; // y
    int64_t _157 = 0; // x
    _jump1243:; // Begin body of loop
    bool _158 = true;
    int64_t _159 = 0;
    _159 *= _154.d0;
    _159 += _157;
    _159 *= _154.d1;
    _159 += _156;
    _154.data[_159] = _158;
    _156++;
    if (_156 < _143)
    goto _jump1243;
    _156 = 0;
    _157++;
    if (_157 < d)
    goto _jump1243;
    // End body of loop
    _153 = _154;
    goto _jump1244;
    _jump1240:;
    bool _160 = false;
    _a2_bool _161;
    if (!_160)
    goto _jump1245;
    _161 = c;
    goto _jump1246;
    _jump1245:;
    _161 = c;
    _jump1246:;
    _153 = _161;
    _jump1244:;
    int64_t _162 = 0;
    _162 *= _145.d0;
    _162 += _150;
    _162 *= _145.d1;
    _162 += _149;
    _162 *= _145.d2;
    _162 += _148;
    _145.data[_162] = _153;
    _148++;
    if (_148 < _146)
    goto _jump1239;
    _148 = 0;
    _149++;
    if (_149 < e)
    goto _jump1239;
    _149 = 0;
    _150++;
    if (_150 < _144)
    goto _jump1239;
    // End body of loop
    int64_t _163 = 0;
    _163 *= _132.d0;
    _163 += _144;
    _163 *= _132.d1;
    _163 += _143;
    _132.data[_163] = _145;
    _143++;
    if (_143 < _141)
    goto _jump1235;
    _143 = 0;
    _144++;
    if (_144 < _138)
    goto _jump1235;
    // End body of loop
    if (_96.d0 >= 0)
    goto _jump1247;
    fail_assertion("negative array index");
    _jump1247:;
    if (_96.d0 < _132.d0)
    goto _jump1248;
    fail_assertion("index too large");
    _jump1248:;
    if (_95.d0 >= 0)
    goto _jump1249;
    fail_assertion("negative array index");
    _jump1249:;
    if (_95.d0 < _132.d1)
    goto _jump1250;
    fail_assertion("index too large");
    _jump1250:;
    int64_t _164 = 0;
    _164 *= _132.d0;
    _164 += _96.d0;
    _164 *= _132.d1;
    _164 += _95.d0;
    _a3__a2_bool _165 = _132.data[_164];
    bool _166 = false;
    _a2_bool _167;
    if (!_166)
    goto _jump1251;
    _a2_bool _168;
    // Computing bound for s
    _168.d0 = d;
    if (d > 0) 
    goto _jump1252;
    fail_assertion("non-positive loop bound");
    _jump1252:;
    // Computing bound for t
    _168.d1 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1253;
    fail_assertion("non-positive loop bound");
    _jump1253:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= d;
    _169 *= _95.d0;
    _169 *= sizeof(bool);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // t
    int64_t _171 = 0; // s
    _jump1254:; // Begin body of loop
    int64_t _172 = 0;
    _172 *= _168.d0;
    _172 += _171;
    _172 *= _168.d1;
    _172 += _170;
    _168.data[_172] = a;
    _170++;
    if (_170 < _95.d0)
    goto _jump1254;
    _170 = 0;
    _171++;
    if (_171 < d)
    goto _jump1254;
    // End body of loop
    _167 = _168;
    goto _jump1255;
    _jump1251:;
    _a2_bool _173;
    // Computing bound for s
    _173.d0 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    // Computing bound for t
    int64_t _174 = 601;
    _173.d1 = _174;
    if (_174 > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    // Computing total size of heap memory to allocate
    int64_t _175 = 1;
    _175 *= _95.d0;
    _175 *= _174;
    _175 *= sizeof(bool);
    _173.data = jpl_alloc(_175);
    int64_t _176 = 0; // t
    int64_t _177 = 0; // s
    _jump1258:; // Begin body of loop
    bool _178 = true;
    int64_t _179 = 0;
    _179 *= _173.d0;
    _179 += _177;
    _179 *= _173.d1;
    _179 += _176;
    _173.data[_179] = _178;
    _176++;
    if (_176 < _174)
    goto _jump1258;
    _176 = 0;
    _177++;
    if (_177 < _95.d0)
    goto _jump1258;
    // End body of loop
    _167 = _173;
    _jump1255:;
    int64_t _180;
    // Computing bound for s
    int64_t _181 = 214;
    if (_181 > 0) 
    goto _jump1259;
    fail_assertion("non-positive loop bound");
    _jump1259:;
    _180 = 0;
    int64_t _182 = 0; // s
    _jump1260:; // Begin body of loop
    _180 += _96.d0;
    _182++;
    if (_182 < _181)
    goto _jump1260;
    // End body of loop
    int64_t _183 = _180 + _95.d1;
    if (_95.d0 >= 0)
    goto _jump1261;
    fail_assertion("negative array index");
    _jump1261:;
    if (_95.d0 < _167.d0)
    goto _jump1262;
    fail_assertion("index too large");
    _jump1262:;
    if (_183 >= 0)
    goto _jump1263;
    fail_assertion("negative array index");
    _jump1263:;
    if (_183 < _167.d1)
    goto _jump1264;
    fail_assertion("index too large");
    _jump1264:;
    int64_t _184 = 0;
    _184 *= _167.d0;
    _184 += _95.d0;
    _184 *= _167.d1;
    _184 += _183;
    bool _185 = _167.data[_184];
    int64_t _186;
    if (!_185)
    goto _jump1265;
    g _187 = l();
    bool _188 = _187.a;
    int64_t _189;
    if (!_188)
    goto _jump1266;
    _189 = i;
    goto _jump1267;
    _jump1266:;
    int64_t _190;
    // Computing bound for s
    if (i > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    // Computing bound for t
    if (d > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    // Computing bound for u
    int64_t _191 = 87;
    if (_191 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    _190 = 0;
    int64_t _192 = 0; // u
    int64_t _193 = 0; // t
    int64_t _194 = 0; // s
    _jump1271:; // Begin body of loop
    _190 += _193;
    _192++;
    if (_192 < _191)
    goto _jump1271;
    _192 = 0;
    _193++;
    if (_193 < d)
    goto _jump1271;
    _193 = 0;
    _194++;
    if (_194 < i)
    goto _jump1271;
    // End body of loop
    _189 = _190;
    _jump1267:;
    int64_t _195 = _189 % _95.d2;
    _186 = _195;
    goto _jump1272;
    _jump1265:;
    _186 = e;
    _jump1272:;
    int64_t _196 = _95.d2 + _186;
    if (_196 >= 0)
    goto _jump1273;
    fail_assertion("negative array index");
    _jump1273:;
    if (_196 < _165.d0)
    goto _jump1274;
    fail_assertion("index too large");
    _jump1274:;
    if (e >= 0)
    goto _jump1275;
    fail_assertion("negative array index");
    _jump1275:;
    if (e < _165.d1)
    goto _jump1276;
    fail_assertion("index too large");
    _jump1276:;
    if (_95.d1 >= 0)
    goto _jump1277;
    fail_assertion("negative array index");
    _jump1277:;
    if (_95.d1 < _165.d2)
    goto _jump1278;
    fail_assertion("index too large");
    _jump1278:;
    int64_t _197 = 0;
    _197 *= _165.d0;
    _197 += _196;
    _197 *= _165.d1;
    _197 += e;
    _197 *= _165.d2;
    _197 += _95.d1;
    _a2_bool _198 = _165.data[_197];
    int64_t _199 = 842;
    _a3__a2__a1_void_t _200;
    // Computing bound for s
    int64_t _201 = 574;
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing bound for t
    _200.d1 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    // Computing bound for u
    bool _202 = !a;
    bool _203 = true;
    bool _204 = _202 != _203;
    g _205;
    if (!_204)
    goto _jump1281;
    g _206 = { a, _95.d1 };
    _205 = _206;
    goto _jump1282;
    _jump1281:;
    if (d >= 0)
    goto _jump1283;
    fail_assertion("negative array index");
    _jump1283:;
    if (d < c.d0)
    goto _jump1284;
    fail_assertion("index too large");
    _jump1284:;
    if (_95.d1 >= 0)
    goto _jump1285;
    fail_assertion("negative array index");
    _jump1285:;
    if (_95.d1 < c.d1)
    goto _jump1286;
    fail_assertion("index too large");
    _jump1286:;
    int64_t _207 = 0;
    _207 *= c.d0;
    _207 += d;
    _207 *= c.d1;
    _207 += _95.d1;
    bool _208 = c.data[_207];
    int64_t _209 = 147;
    int64_t _210 = -_209;
    g _211 = { _208, _210 };
    _205 = _211;
    _jump1282:;
    int64_t _212 = _205.b;
    _200.d2 = _212;
    if (_212 > 0) 
    goto _jump1287;
    fail_assertion("non-positive loop bound");
    _jump1287:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= _201;
    _213 *= _96.d0;
    _213 *= _212;
    _213 *= sizeof(_a2__a1_void_t);
    _200.data = jpl_alloc(_213);
    int64_t _214 = 0; // u
    int64_t _215 = 0; // t
    int64_t _216 = 0; // s
    _jump1288:; // Begin body of loop
    _a2__a1_void_t _217;
    // Computing bound for v
    int64_t _218 = -_96.d0;
    _217.d0 = _218;
    if (_218 > 0) 
    goto _jump1289;
    fail_assertion("non-positive loop bound");
    _jump1289:;
    // Computing bound for w
    _217.d1 = _214;
    if (_214 > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing total size of heap memory to allocate
    int64_t _219 = 1;
    _219 *= _218;
    _219 *= _214;
    _219 *= sizeof(_a1_void_t);
    _217.data = jpl_alloc(_219);
    int64_t _220 = 0; // w
    int64_t _221 = 0; // v
    _jump1291:; // Begin body of loop
    _a1_void_t _222;
    // Computing bound for x
    _222.d0 = _215;
    if (_215 > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing total size of heap memory to allocate
    int64_t _223 = 1;
    _223 *= _215;
    _223 *= sizeof(void_t);
    _222.data = jpl_alloc(_223);
    int64_t _224 = 0; // x
    _jump1293:; // Begin body of loop
    double _225 = 24.0;
    double _226 = 5.0;
    double _227 = 69.0;
    double _228 = 15.0;
    rgba _229 = { _225, _226, _227, _228 };
    int64_t _230 = _215 % _95.d0;
    void_t _231 = h(_215, _229, _230);
    int64_t _232 = 0;
    _232 *= _222.d0;
    _232 += _224;
    _222.data[_232] = _231;
    _224++;
    if (_224 < _215)
    goto _jump1293;
    // End body of loop
    int64_t _233 = 0;
    _233 *= _217.d0;
    _233 += _221;
    _233 *= _217.d1;
    _233 += _220;
    _217.data[_233] = _222;
    _220++;
    if (_220 < _214)
    goto _jump1291;
    _220 = 0;
    _221++;
    if (_221 < _218)
    goto _jump1291;
    // End body of loop
    int64_t _234 = 0;
    _234 *= _200.d0;
    _234 += _216;
    _234 *= _200.d1;
    _234 += _215;
    _234 *= _200.d2;
    _234 += _214;
    _200.data[_234] = _217;
    _214++;
    if (_214 < _212)
    goto _jump1288;
    _214 = 0;
    _215++;
    if (_215 < _96.d0)
    goto _jump1288;
    _215 = 0;
    _216++;
    if (_216 < _201)
    goto _jump1288;
    // End body of loop
    g _235 = { a, _95.d1 };
    int64_t _236 = _235.b;
    int64_t _237 = -_236;
    int64_t _238;
    // Computing bound for s
    _a2__a3__a3_double _239;
    // Computing bound for s
    _239.d0 = _95.d1;
    if (_95.d1 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    // Computing bound for t
    _239.d1 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing total size of heap memory to allocate
    int64_t _240 = 1;
    _240 *= _95.d1;
    _240 *= _95.d2;
    _240 *= sizeof(_a3__a3_double);
    _239.data = jpl_alloc(_240);
    int64_t _241 = 0; // t
    int64_t _242 = 0; // s
    _jump1296:; // Begin body of loop
    int64_t _243 = 0;
    _243 *= _239.d0;
    _243 += _242;
    _243 *= _239.d1;
    _243 += _241;
    _239.data[_243] = _95;
    _241++;
    if (_241 < _95.d2)
    goto _jump1296;
    _241 = 0;
    _242++;
    if (_242 < _95.d1)
    goto _jump1296;
    // End body of loop
    int64_t _244;
    // Computing bound for s
    if (_95.d1 > 0) 
    goto _jump1297;
    fail_assertion("non-positive loop bound");
    _jump1297:;
    // Computing bound for t
    if (_95.d2 > 0) 
    goto _jump1298;
    fail_assertion("non-positive loop bound");
    _jump1298:;
    // Computing bound for u
    if (i > 0) 
    goto _jump1299;
    fail_assertion("non-positive loop bound");
    _jump1299:;
    _244 = 0;
    int64_t _245 = 0; // u
    int64_t _246 = 0; // t
    int64_t _247 = 0; // s
    _jump1300:; // Begin body of loop
    _244 += _95.d0;
    _245++;
    if (_245 < i)
    goto _jump1300;
    _245 = 0;
    _246++;
    if (_246 < _95.d2)
    goto _jump1300;
    _246 = 0;
    _247++;
    if (_247 < _95.d1)
    goto _jump1300;
    // End body of loop
    int64_t _248 = 693;
    if (_244 >= 0)
    goto _jump1301;
    fail_assertion("negative array index");
    _jump1301:;
    if (_244 < _239.d0)
    goto _jump1302;
    fail_assertion("index too large");
    _jump1302:;
    if (_248 >= 0)
    goto _jump1303;
    fail_assertion("negative array index");
    _jump1303:;
    if (_248 < _239.d1)
    goto _jump1304;
    fail_assertion("index too large");
    _jump1304:;
    int64_t _249 = 0;
    _249 *= _239.d0;
    _249 += _244;
    _249 *= _239.d1;
    _249 += _248;
    _a3__a3_double _250 = _239.data[_249];
    double _251;
    // Computing bound for s
    if (e > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing bound for t
    if (_95.d1 > 0) 
    goto _jump1306;
    fail_assertion("non-positive loop bound");
    _jump1306:;
    _251 = 0;
    int64_t _252 = 0; // t
    int64_t _253 = 0; // s
    _jump1307:; // Begin body of loop
    double _254 = 88.0;
    _251 += _254;
    _252++;
    if (_252 < _95.d1)
    goto _jump1307;
    _252 = 0;
    _253++;
    if (_253 < e)
    goto _jump1307;
    // End body of loop
    k _255 = { _250, _95.d0, _251 };
    int64_t _256 = _255.b;
    if (_256 > 0) 
    goto _jump1308;
    fail_assertion("non-positive loop bound");
    _jump1308:;
    _238 = 0;
    int64_t _257 = 0; // s
    _jump1309:; // Begin body of loop
    _238 += _95.d1;
    _257++;
    if (_257 < _256)
    goto _jump1309;
    // End body of loop
    _a3__a3_int64_t _258;
    // Computing bound for s
    int64_t _259 = 178;
    _258.d0 = _259;
    if (_259 > 0) 
    goto _jump1310;
    fail_assertion("non-positive loop bound");
    _jump1310:;
    // Computing bound for t
    _258.d1 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1311;
    fail_assertion("non-positive loop bound");
    _jump1311:;
    // Computing bound for u
    int64_t _260 = 12;
    int64_t _261 = -_260;
    _258.d2 = _261;
    if (_261 > 0) 
    goto _jump1312;
    fail_assertion("non-positive loop bound");
    _jump1312:;
    // Computing total size of heap memory to allocate
    int64_t _262 = 1;
    _262 *= _259;
    _262 *= _95.d0;
    _262 *= _261;
    _262 *= sizeof(_a3_int64_t);
    _258.data = jpl_alloc(_262);
    int64_t _263 = 0; // u
    int64_t _264 = 0; // t
    int64_t _265 = 0; // s
    _jump1313:; // Begin body of loop
    _a3_int64_t _266;
    if (!a)
    goto _jump1314;
    _a3_int64_t _267;
    // Computing bound for v
    _267.d0 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump1315;
    fail_assertion("non-positive loop bound");
    _jump1315:;
    // Computing bound for w
    _267.d1 = e;
    if (e > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    // Computing bound for x
    _267.d2 = i;
    if (i > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    // Computing total size of heap memory to allocate
    int64_t _268 = 1;
    _268 *= _96.d0;
    _268 *= e;
    _268 *= i;
    _268 *= sizeof(int64_t);
    _267.data = jpl_alloc(_268);
    int64_t _269 = 0; // x
    int64_t _270 = 0; // w
    int64_t _271 = 0; // v
    _jump1318:; // Begin body of loop
    int64_t _272 = 0;
    _272 *= _267.d0;
    _272 += _271;
    _272 *= _267.d1;
    _272 += _270;
    _272 *= _267.d2;
    _272 += _269;
    _267.data[_272] = e;
    _269++;
    if (_269 < i)
    goto _jump1318;
    _269 = 0;
    _270++;
    if (_270 < e)
    goto _jump1318;
    _270 = 0;
    _271++;
    if (_271 < _96.d0)
    goto _jump1318;
    // End body of loop
    _266 = _267;
    goto _jump1319;
    _jump1314:;
    _a3_int64_t _273;
    // Computing bound for v
    _273.d0 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump1320;
    fail_assertion("non-positive loop bound");
    _jump1320:;
    // Computing bound for w
    _273.d1 = e;
    if (e > 0) 
    goto _jump1321;
    fail_assertion("non-positive loop bound");
    _jump1321:;
    // Computing bound for x
    _273.d2 = d;
    if (d > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= _95.d2;
    _274 *= e;
    _274 *= d;
    _274 *= sizeof(int64_t);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // x
    int64_t _276 = 0; // w
    int64_t _277 = 0; // v
    _jump1323:; // Begin body of loop
    int64_t _278 = 0;
    _278 *= _273.d0;
    _278 += _277;
    _278 *= _273.d1;
    _278 += _276;
    _278 *= _273.d2;
    _278 += _275;
    _273.data[_278] = _263;
    _275++;
    if (_275 < d)
    goto _jump1323;
    _275 = 0;
    _276++;
    if (_276 < e)
    goto _jump1323;
    _276 = 0;
    _277++;
    if (_277 < _95.d2)
    goto _jump1323;
    // End body of loop
    _266 = _273;
    _jump1319:;
    int64_t _279 = 0;
    _279 *= _258.d0;
    _279 += _265;
    _279 *= _258.d1;
    _279 += _264;
    _279 *= _258.d2;
    _279 += _263;
    _258.data[_279] = _266;
    _263++;
    if (_263 < _261)
    goto _jump1313;
    _263 = 0;
    _264++;
    if (_264 < _95.d0)
    goto _jump1313;
    _264 = 0;
    _265++;
    if (_265 < _259)
    goto _jump1313;
    // End body of loop
    _a2_int64_t _280;
    // Computing bound for s
    _280.d0 = e;
    if (e > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing bound for t
    _280.d1 = e;
    if (e > 0) 
    goto _jump1325;
    fail_assertion("non-positive loop bound");
    _jump1325:;
    // Computing total size of heap memory to allocate
    int64_t _281 = 1;
    _281 *= e;
    _281 *= e;
    _281 *= sizeof(int64_t);
    _280.data = jpl_alloc(_281);
    int64_t _282 = 0; // t
    int64_t _283 = 0; // s
    _jump1326:; // Begin body of loop
    int64_t _284 = 0;
    _284 *= _280.d0;
    _284 += _283;
    _284 *= _280.d1;
    _284 += _282;
    _280.data[_284] = _95.d2;
    _282++;
    if (_282 < e)
    goto _jump1326;
    _282 = 0;
    _283++;
    if (_283 < e)
    goto _jump1326;
    // End body of loop
    int64_t _285 = 534;
    g _286 = l();
    int64_t _287 = _286.b;
    if (_285 >= 0)
    goto _jump1327;
    fail_assertion("negative array index");
    _jump1327:;
    if (_285 < _280.d0)
    goto _jump1328;
    fail_assertion("index too large");
    _jump1328:;
    if (_287 >= 0)
    goto _jump1329;
    fail_assertion("negative array index");
    _jump1329:;
    if (_287 < _280.d1)
    goto _jump1330;
    fail_assertion("index too large");
    _jump1330:;
    int64_t _288 = 0;
    _288 *= _280.d0;
    _288 += _285;
    _288 *= _280.d1;
    _288 += _287;
    int64_t _289 = _280.data[_288];
    if (_96.d0 >= 0)
    goto _jump1331;
    fail_assertion("negative array index");
    _jump1331:;
    if (_96.d0 < _258.d0)
    goto _jump1332;
    fail_assertion("index too large");
    _jump1332:;
    if (d >= 0)
    goto _jump1333;
    fail_assertion("negative array index");
    _jump1333:;
    if (d < _258.d1)
    goto _jump1334;
    fail_assertion("index too large");
    _jump1334:;
    if (_289 >= 0)
    goto _jump1335;
    fail_assertion("negative array index");
    _jump1335:;
    if (_289 < _258.d2)
    goto _jump1336;
    fail_assertion("index too large");
    _jump1336:;
    int64_t _290 = 0;
    _290 *= _258.d0;
    _290 += _96.d0;
    _290 *= _258.d1;
    _290 += d;
    _290 *= _258.d2;
    _290 += _289;
    _a3_int64_t _291 = _258.data[_290];
    int64_t _292;
    // Computing bound for s
    int64_t _293 = 915;
    if (_293 > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    _292 = 0;
    int64_t _294 = 0; // s
    _jump1338:; // Begin body of loop
    _292 += _96.d0;
    _294++;
    if (_294 < _293)
    goto _jump1338;
    // End body of loop
    if (_95.d0 >= 0)
    goto _jump1339;
    fail_assertion("negative array index");
    _jump1339:;
    if (_95.d0 < _291.d0)
    goto _jump1340;
    fail_assertion("index too large");
    _jump1340:;
    if (e >= 0)
    goto _jump1341;
    fail_assertion("negative array index");
    _jump1341:;
    if (e < _291.d1)
    goto _jump1342;
    fail_assertion("index too large");
    _jump1342:;
    if (_292 >= 0)
    goto _jump1343;
    fail_assertion("negative array index");
    _jump1343:;
    if (_292 < _291.d2)
    goto _jump1344;
    fail_assertion("index too large");
    _jump1344:;
    int64_t _295 = 0;
    _295 *= _291.d0;
    _295 += _95.d0;
    _295 *= _291.d1;
    _295 += e;
    _295 *= _291.d2;
    _295 += _292;
    int64_t _296 = _291.data[_295];
    if (_237 >= 0)
    goto _jump1345;
    fail_assertion("negative array index");
    _jump1345:;
    if (_237 < _200.d0)
    goto _jump1346;
    fail_assertion("index too large");
    _jump1346:;
    if (_238 >= 0)
    goto _jump1347;
    fail_assertion("negative array index");
    _jump1347:;
    if (_238 < _200.d1)
    goto _jump1348;
    fail_assertion("index too large");
    _jump1348:;
    if (_296 >= 0)
    goto _jump1349;
    fail_assertion("negative array index");
    _jump1349:;
    if (_296 < _200.d2)
    goto _jump1350;
    fail_assertion("index too large");
    _jump1350:;
    int64_t _297 = 0;
    _297 *= _200.d0;
    _297 += _237;
    _297 *= _200.d1;
    _297 += _238;
    _297 *= _200.d2;
    _297 += _296;
    _a2__a1_void_t _298 = _200.data[_297];
    void_t _299 = b(_198, _199, _298);
    rgba _300 = j();
    double _301 = _300.b;
    _a2_double _302;
    // Computing bound for t
    _302.d0 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump1351;
    fail_assertion("non-positive loop bound");
    _jump1351:;
    // Computing bound for u
    _302.d1 = i;
    if (i > 0) 
    goto _jump1352;
    fail_assertion("non-positive loop bound");
    _jump1352:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= _96.d0;
    _303 *= i;
    _303 *= sizeof(double);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // u
    int64_t _305 = 0; // t
    _jump1353:; // Begin body of loop
    double _306 = 44.0;
    double _307 = -_306;
    int64_t _308 = 0;
    _308 *= _302.d0;
    _308 += _305;
    _308 *= _302.d1;
    _308 += _304;
    _302.data[_308] = _307;
    _304++;
    if (_304 < i)
    goto _jump1353;
    _304 = 0;
    _305++;
    if (_305 < _96.d0)
    goto _jump1353;
    // End body of loop
    bool _309 = f(_301, _302);
    bool _310 = !_309;
    _a2_rgba _311;
    if (!_310)
    goto _jump1354;
    _a2_rgba _312;
    // Computing bound for t
    _312.d0 = e;
    if (e > 0) 
    goto _jump1355;
    fail_assertion("non-positive loop bound");
    _jump1355:;
    // Computing bound for u
    int64_t _313 = _95.d2 % e;
    bool _314 = _313 < _95.d2;
    int64_t _315;
    if (!_314)
    goto _jump1356;
    _a2_int64_t _316;
    // Computing bound for t
    _316.d0 = _95.d1;
    if (_95.d1 > 0) 
    goto _jump1357;
    fail_assertion("non-positive loop bound");
    _jump1357:;
    // Computing bound for u
    _316.d1 = _95.d1;
    if (_95.d1 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= _95.d1;
    _317 *= _95.d1;
    _317 *= sizeof(int64_t);
    _316.data = jpl_alloc(_317);
    int64_t _318 = 0; // u
    int64_t _319 = 0; // t
    _jump1359:; // Begin body of loop
    int64_t _320 = 0;
    _320 *= _316.d0;
    _320 += _319;
    _320 *= _316.d1;
    _320 += _318;
    _316.data[_320] = d;
    _318++;
    if (_318 < _95.d1)
    goto _jump1359;
    _318 = 0;
    _319++;
    if (_319 < _95.d1)
    goto _jump1359;
    // End body of loop
    if (e >= 0)
    goto _jump1360;
    fail_assertion("negative array index");
    _jump1360:;
    if (e < _316.d0)
    goto _jump1361;
    fail_assertion("index too large");
    _jump1361:;
    if (_95.d1 >= 0)
    goto _jump1362;
    fail_assertion("negative array index");
    _jump1362:;
    if (_95.d1 < _316.d1)
    goto _jump1363;
    fail_assertion("index too large");
    _jump1363:;
    int64_t _321 = 0;
    _321 *= _316.d0;
    _321 += e;
    _321 *= _316.d1;
    _321 += _95.d1;
    int64_t _322 = _316.data[_321];
    _315 = _322;
    goto _jump1364;
    _jump1356:;
    _315 = _95.d2;
    _jump1364:;
    _312.d1 = _315;
    if (_315 > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= e;
    _323 *= _315;
    _323 *= sizeof(rgba);
    _312.data = jpl_alloc(_323);
    int64_t _324 = 0; // u
    int64_t _325 = 0; // t
    _jump1366:; // Begin body of loop
    double _326;
    // Computing bound for v
    if (_95.d0 > 0) 
    goto _jump1367;
    fail_assertion("non-positive loop bound");
    _jump1367:;
    // Computing bound for w
    if (_325 > 0) 
    goto _jump1368;
    fail_assertion("non-positive loop bound");
    _jump1368:;
    // Computing bound for x
    if (_95.d2 > 0) 
    goto _jump1369;
    fail_assertion("non-positive loop bound");
    _jump1369:;
    _326 = 0;
    int64_t _327 = 0; // x
    int64_t _328 = 0; // w
    int64_t _329 = 0; // v
    _jump1370:; // Begin body of loop
    rgba _330 = j();
    double _331 = _330.a;
    _326 += _331;
    _327++;
    if (_327 < _95.d2)
    goto _jump1370;
    _327 = 0;
    _328++;
    if (_328 < _325)
    goto _jump1370;
    _328 = 0;
    _329++;
    if (_329 < _95.d0)
    goto _jump1370;
    // End body of loop
    double _332;
    // Computing bound for v
    if (d > 0) 
    goto _jump1371;
    fail_assertion("non-positive loop bound");
    _jump1371:;
    _332 = 0;
    int64_t _333 = 0; // v
    _jump1372:; // Begin body of loop
    double _334 = 19.0;
    _332 += _334;
    _333++;
    if (_333 < d)
    goto _jump1372;
    // End body of loop
    double _335 = 99.0;
    double _336 = _332 - _335;
    _a2_double _337;
    // Computing bound for v
    _337.d0 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump1373;
    fail_assertion("non-positive loop bound");
    _jump1373:;
    // Computing bound for w
    _337.d1 = _324;
    if (_324 > 0) 
    goto _jump1374;
    fail_assertion("non-positive loop bound");
    _jump1374:;
    // Computing total size of heap memory to allocate
    int64_t _338 = 1;
    _338 *= _95.d2;
    _338 *= _324;
    _338 *= sizeof(double);
    _337.data = jpl_alloc(_338);
    int64_t _339 = 0; // w
    int64_t _340 = 0; // v
    _jump1375:; // Begin body of loop
    double _341 = 55.0;
    int64_t _342 = 0;
    _342 *= _337.d0;
    _342 += _340;
    _342 *= _337.d1;
    _342 += _339;
    _337.data[_342] = _341;
    _339++;
    if (_339 < _324)
    goto _jump1375;
    _339 = 0;
    _340++;
    if (_340 < _95.d2)
    goto _jump1375;
    // End body of loop
    int64_t _343;
    // Computing bound for v
    if (_324 > 0) 
    goto _jump1376;
    fail_assertion("non-positive loop bound");
    _jump1376:;
    // Computing bound for w
    if (e > 0) 
    goto _jump1377;
    fail_assertion("non-positive loop bound");
    _jump1377:;
    _343 = 0;
    int64_t _344 = 0; // w
    int64_t _345 = 0; // v
    _jump1378:; // Begin body of loop
    _343 += _95.d0;
    _344++;
    if (_344 < e)
    goto _jump1378;
    _344 = 0;
    _345++;
    if (_345 < _324)
    goto _jump1378;
    // End body of loop
    if (_343 >= 0)
    goto _jump1379;
    fail_assertion("negative array index");
    _jump1379:;
    if (_343 < _337.d0)
    goto _jump1380;
    fail_assertion("index too large");
    _jump1380:;
    if (_96.d0 >= 0)
    goto _jump1381;
    fail_assertion("negative array index");
    _jump1381:;
    if (_96.d0 < _337.d1)
    goto _jump1382;
    fail_assertion("index too large");
    _jump1382:;
    int64_t _346 = 0;
    _346 *= _337.d0;
    _346 += _343;
    _346 *= _337.d1;
    _346 += _96.d0;
    double _347 = _337.data[_346];
    if (e >= 0)
    goto _jump1383;
    fail_assertion("negative array index");
    _jump1383:;
    if (e < _96.d0)
    goto _jump1384;
    fail_assertion("index too large");
    _jump1384:;
    int64_t _348 = 0;
    _348 *= _96.d0;
    _348 += e;
    double _349 = _96.data[_348];
    rgba _350 = { _326, _336, _347, _349 };
    int64_t _351 = 0;
    _351 *= _312.d0;
    _351 += _325;
    _351 *= _312.d1;
    _351 += _324;
    _312.data[_351] = _350;
    _324++;
    if (_324 < _315)
    goto _jump1366;
    _324 = 0;
    _325++;
    if (_325 < e)
    goto _jump1366;
    // End body of loop
    _311 = _312;
    goto _jump1385;
    _jump1354:;
    _a2_rgba _352;
    // Computing bound for t
    int64_t _353 = -i;
    _352.d0 = _353;
    if (_353 > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing bound for u
    _352.d1 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1387;
    fail_assertion("non-positive loop bound");
    _jump1387:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= _353;
    _354 *= _95.d0;
    _354 *= sizeof(rgba);
    _352.data = jpl_alloc(_354);
    int64_t _355 = 0; // u
    int64_t _356 = 0; // t
    _jump1388:; // Begin body of loop
    rgba _357 = j();
    int64_t _358 = 0;
    _358 *= _352.d0;
    _358 += _356;
    _358 *= _352.d1;
    _358 += _355;
    _352.data[_358] = _357;
    _355++;
    if (_355 < _95.d0)
    goto _jump1388;
    _355 = 0;
    _356++;
    if (_356 < _353)
    goto _jump1388;
    // End body of loop
    _311 = _352;
    _jump1385:;
    if (_95.d1 >= 0)
    goto _jump1389;
    fail_assertion("negative array index");
    _jump1389:;
    if (_95.d1 < _96.d0)
    goto _jump1390;
    fail_assertion("index too large");
    _jump1390:;
    int64_t _359 = 0;
    _359 *= _96.d0;
    _359 += _95.d1;
    double _360 = _96.data[_359];
    bool _361 = d < d;
    rgba _362;
    if (!_361)
    goto _jump1391;
    rgba _363;
    if (!a)
    goto _jump1392;
    rgba _364 = j();
    _363 = _364;
    goto _jump1393;
    _jump1392:;
    rgba _365 = j();
    _363 = _365;
    _jump1393:;
    _362 = _363;
    goto _jump1394;
    _jump1391:;
    rgba _366 = j();
    _362 = _366;
    _jump1394:;
    double _367 = _362.r;
    bool _368 = _360 <= _367;
    _a2_rgba _369;
    if (!_368)
    goto _jump1395;
    _a2_rgba _370;
    // Computing bound for t
    bool _371 = false;
    int64_t _372;
    if (!_371)
    goto _jump1396;
    _372 = d;
    goto _jump1397;
    _jump1396:;
    _372 = i;
    _jump1397:;
    int64_t _373;
    if (!a)
    goto _jump1398;
    _373 = e;
    goto _jump1399;
    _jump1398:;
    _373 = _95.d0;
    _jump1399:;
    int64_t _374 = _372 + _373;
    int64_t _375;
    if (!a)
    goto _jump1400;
    int64_t _376;
    // Computing bound for t
    if (i > 0) 
    goto _jump1401;
    fail_assertion("non-positive loop bound");
    _jump1401:;
    // Computing bound for u
    if (_95.d0 > 0) 
    goto _jump1402;
    fail_assertion("non-positive loop bound");
    _jump1402:;
    // Computing bound for v
    if (_95.d2 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    _376 = 0;
    int64_t _377 = 0; // v
    int64_t _378 = 0; // u
    int64_t _379 = 0; // t
    _jump1404:; // Begin body of loop
    _376 += e;
    _377++;
    if (_377 < _95.d2)
    goto _jump1404;
    _377 = 0;
    _378++;
    if (_378 < _95.d0)
    goto _jump1404;
    _378 = 0;
    _379++;
    if (_379 < i)
    goto _jump1404;
    // End body of loop
    _375 = _376;
    goto _jump1405;
    _jump1400:;
    int64_t _380;
    if (!a)
    goto _jump1406;
    _380 = _95.d1;
    goto _jump1407;
    _jump1406:;
    _380 = _95.d1;
    _jump1407:;
    _375 = _380;
    _jump1405:;
    int64_t _381 = _374 % _375;
    _370.d0 = _381;
    if (_381 > 0) 
    goto _jump1408;
    fail_assertion("non-positive loop bound");
    _jump1408:;
    // Computing bound for u
    _370.d1 = d;
    if (d > 0) 
    goto _jump1409;
    fail_assertion("non-positive loop bound");
    _jump1409:;
    // Computing total size of heap memory to allocate
    int64_t _382 = 1;
    _382 *= _381;
    _382 *= d;
    _382 *= sizeof(rgba);
    _370.data = jpl_alloc(_382);
    int64_t _383 = 0; // u
    int64_t _384 = 0; // t
    _jump1410:; // Begin body of loop
    rgba _385;
    if (!a)
    goto _jump1411;
    _a3_rgba _386;
    // Computing bound for v
    _386.d0 = _383;
    if (_383 > 0) 
    goto _jump1412;
    fail_assertion("non-positive loop bound");
    _jump1412:;
    // Computing bound for w
    _386.d1 = d;
    if (d > 0) 
    goto _jump1413;
    fail_assertion("non-positive loop bound");
    _jump1413:;
    // Computing bound for x
    _386.d2 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump1414;
    fail_assertion("non-positive loop bound");
    _jump1414:;
    // Computing total size of heap memory to allocate
    int64_t _387 = 1;
    _387 *= _383;
    _387 *= d;
    _387 *= _95.d2;
    _387 *= sizeof(rgba);
    _386.data = jpl_alloc(_387);
    int64_t _388 = 0; // x
    int64_t _389 = 0; // w
    int64_t _390 = 0; // v
    _jump1415:; // Begin body of loop
    rgba _391 = j();
    int64_t _392 = 0;
    _392 *= _386.d0;
    _392 += _390;
    _392 *= _386.d1;
    _392 += _389;
    _392 *= _386.d2;
    _392 += _388;
    _386.data[_392] = _391;
    _388++;
    if (_388 < _95.d2)
    goto _jump1415;
    _388 = 0;
    _389++;
    if (_389 < d)
    goto _jump1415;
    _389 = 0;
    _390++;
    if (_390 < _383)
    goto _jump1415;
    // End body of loop
    int64_t _393 = 40;
    if (d >= 0)
    goto _jump1416;
    fail_assertion("negative array index");
    _jump1416:;
    if (d < _386.d0)
    goto _jump1417;
    fail_assertion("index too large");
    _jump1417:;
    if (_393 >= 0)
    goto _jump1418;
    fail_assertion("negative array index");
    _jump1418:;
    if (_393 < _386.d1)
    goto _jump1419;
    fail_assertion("index too large");
    _jump1419:;
    if (_95.d2 >= 0)
    goto _jump1420;
    fail_assertion("negative array index");
    _jump1420:;
    if (_95.d2 < _386.d2)
    goto _jump1421;
    fail_assertion("index too large");
    _jump1421:;
    int64_t _394 = 0;
    _394 *= _386.d0;
    _394 += d;
    _394 *= _386.d1;
    _394 += _393;
    _394 *= _386.d2;
    _394 += _95.d2;
    rgba _395 = _386.data[_394];
    _385 = _395;
    goto _jump1422;
    _jump1411:;
    rgba _396 = j();
    _385 = _396;
    _jump1422:;
    int64_t _397 = 0;
    _397 *= _370.d0;
    _397 += _384;
    _397 *= _370.d1;
    _397 += _383;
    _370.data[_397] = _385;
    _383++;
    if (_383 < d)
    goto _jump1410;
    _383 = 0;
    _384++;
    if (_384 < _381)
    goto _jump1410;
    // End body of loop
    _369 = _370;
    goto _jump1423;
    _jump1395:;
    int64_t _398 = -i;
    bool _399 = _398 != d;
    int64_t _400 = _95.d2 * _95.d0;
    bool _401 = true;
    int64_t _402;
    if (!_401)
    goto _jump1424;
    _402 = _95.d1;
    goto _jump1425;
    _jump1424:;
    _402 = _95.d2;
    _jump1425:;
    bool _403 = _400 != _402;
    bool _404 = _399 != _403;
    _a2_rgba _405;
    if (!_404)
    goto _jump1426;
    _a2_rgba _406;
    // Computing bound for t
    int64_t _407 = _95.d0 - _95.d2;
    int64_t _408 = _407 / _96.d0;
    _406.d0 = _408;
    if (_408 > 0) 
    goto _jump1427;
    fail_assertion("non-positive loop bound");
    _jump1427:;
    // Computing bound for u
    int64_t _409;
    if (!a)
    goto _jump1428;
    int64_t _410 = e / i;
    _409 = _410;
    goto _jump1429;
    _jump1428:;
    g _411 = l();
    int64_t _412 = _411.b;
    _409 = _412;
    _jump1429:;
    _406.d1 = _409;
    if (_409 > 0) 
    goto _jump1430;
    fail_assertion("non-positive loop bound");
    _jump1430:;
    // Computing total size of heap memory to allocate
    int64_t _413 = 1;
    _413 *= _408;
    _413 *= _409;
    _413 *= sizeof(rgba);
    _406.data = jpl_alloc(_413);
    int64_t _414 = 0; // u
    int64_t _415 = 0; // t
    _jump1431:; // Begin body of loop
    rgba _416 = j();
    int64_t _417 = 0;
    _417 *= _406.d0;
    _417 += _415;
    _417 *= _406.d1;
    _417 += _414;
    _406.data[_417] = _416;
    _414++;
    if (_414 < _409)
    goto _jump1431;
    _414 = 0;
    _415++;
    if (_415 < _408)
    goto _jump1431;
    // End body of loop
    _405 = _406;
    goto _jump1432;
    _jump1426:;
    _a3__a2_rgba _418;
    // Computing bound for t
    _418.d0 = _95.d1;
    if (_95.d1 > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing bound for u
    int64_t _419 = -d;
    _418.d1 = _419;
    if (_419 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing bound for v
    _418.d2 = i;
    if (i > 0) 
    goto _jump1435;
    fail_assertion("non-positive loop bound");
    _jump1435:;
    // Computing total size of heap memory to allocate
    int64_t _420 = 1;
    _420 *= _95.d1;
    _420 *= _419;
    _420 *= i;
    _420 *= sizeof(_a2_rgba);
    _418.data = jpl_alloc(_420);
    int64_t _421 = 0; // v
    int64_t _422 = 0; // u
    int64_t _423 = 0; // t
    _jump1436:; // Begin body of loop
    _a2_rgba _424;
    // Computing bound for w
    _424.d0 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1437;
    fail_assertion("non-positive loop bound");
    _jump1437:;
    // Computing bound for x
    _424.d1 = _95.d0;
    if (_95.d0 > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    // Computing total size of heap memory to allocate
    int64_t _425 = 1;
    _425 *= _95.d0;
    _425 *= _95.d0;
    _425 *= sizeof(rgba);
    _424.data = jpl_alloc(_425);
    int64_t _426 = 0; // x
    int64_t _427 = 0; // w
    _jump1439:; // Begin body of loop
    rgba _428 = j();
    int64_t _429 = 0;
    _429 *= _424.d0;
    _429 += _427;
    _429 *= _424.d1;
    _429 += _426;
    _424.data[_429] = _428;
    _426++;
    if (_426 < _95.d0)
    goto _jump1439;
    _426 = 0;
    _427++;
    if (_427 < _95.d0)
    goto _jump1439;
    // End body of loop
    int64_t _430 = 0;
    _430 *= _418.d0;
    _430 += _423;
    _430 *= _418.d1;
    _430 += _422;
    _430 *= _418.d2;
    _430 += _421;
    _418.data[_430] = _424;
    _421++;
    if (_421 < i)
    goto _jump1436;
    _421 = 0;
    _422++;
    if (_422 < _419)
    goto _jump1436;
    _422 = 0;
    _423++;
    if (_423 < _95.d1)
    goto _jump1436;
    // End body of loop
    _a2_int64_t _431;
    // Computing bound for t
    _431.d0 = _95.d1;
    if (_95.d1 > 0) 
    goto _jump1440;
    fail_assertion("non-positive loop bound");
    _jump1440:;
    // Computing bound for u
    int64_t _432 = 221;
    _431.d1 = _432;
    if (_432 > 0) 
    goto _jump1441;
    fail_assertion("non-positive loop bound");
    _jump1441:;
    // Computing total size of heap memory to allocate
    int64_t _433 = 1;
    _433 *= _95.d1;
    _433 *= _432;
    _433 *= sizeof(int64_t);
    _431.data = jpl_alloc(_433);
    int64_t _434 = 0; // u
    int64_t _435 = 0; // t
    _jump1442:; // Begin body of loop
    int64_t _436 = 0;
    _436 *= _431.d0;
    _436 += _435;
    _436 *= _431.d1;
    _436 += _434;
    _431.data[_436] = _435;
    _434++;
    if (_434 < _432)
    goto _jump1442;
    _434 = 0;
    _435++;
    if (_435 < _95.d1)
    goto _jump1442;
    // End body of loop
    if (d >= 0)
    goto _jump1443;
    fail_assertion("negative array index");
    _jump1443:;
    if (d < _431.d0)
    goto _jump1444;
    fail_assertion("index too large");
    _jump1444:;
    if (_95.d2 >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (_95.d2 < _431.d1)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    int64_t _437 = 0;
    _437 *= _431.d0;
    _437 += d;
    _437 *= _431.d1;
    _437 += _95.d2;
    int64_t _438 = _431.data[_437];
    int64_t _439;
    // Computing bound for t
    if (i > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    // Computing bound for u
    if (_96.d0 > 0) 
    goto _jump1448;
    fail_assertion("non-positive loop bound");
    _jump1448:;
    _439 = 0;
    int64_t _440 = 0; // u
    int64_t _441 = 0; // t
    _jump1449:; // Begin body of loop
    int64_t _442 = 968;
    _439 += _442;
    _440++;
    if (_440 < _96.d0)
    goto _jump1449;
    _440 = 0;
    _441++;
    if (_441 < i)
    goto _jump1449;
    // End body of loop
    if (i >= 0)
    goto _jump1450;
    fail_assertion("negative array index");
    _jump1450:;
    if (i < _418.d0)
    goto _jump1451;
    fail_assertion("index too large");
    _jump1451:;
    if (_438 >= 0)
    goto _jump1452;
    fail_assertion("negative array index");
    _jump1452:;
    if (_438 < _418.d1)
    goto _jump1453;
    fail_assertion("index too large");
    _jump1453:;
    if (_439 >= 0)
    goto _jump1454;
    fail_assertion("negative array index");
    _jump1454:;
    if (_439 < _418.d2)
    goto _jump1455;
    fail_assertion("index too large");
    _jump1455:;
    int64_t _443 = 0;
    _443 *= _418.d0;
    _443 += i;
    _443 *= _418.d1;
    _443 += _438;
    _443 *= _418.d2;
    _443 += _439;
    _a2_rgba _444 = _418.data[_443];
    _405 = _444;
    _jump1432:;
    _369 = _405;
    _jump1423:;
    _a1__a2_rgba _445;
    _445.d0 = 2;
    _445.data = jpl_alloc(sizeof(_a2_rgba) * 2);
    _445.data[0] = _311;
    _445.data[1] = _369;
    int64_t _446;
    // Computing bound for t
    int64_t _447 = -_95.d2;
    if (_447 > 0) 
    goto _jump1456;
    fail_assertion("non-positive loop bound");
    _jump1456:;
    // Computing bound for u
    bool _448 = _95.d1 != d;
    g _449;
    if (!_448)
    goto _jump1457;
    g _450 = l();
    _449 = _450;
    goto _jump1458;
    _jump1457:;
    bool _451 = true;
    g _452 = { _451, _95.d0 };
    _449 = _452;
    _jump1458:;
    int64_t _453 = _449.b;
    if (_453 > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    _446 = 0;
    int64_t _454 = 0; // u
    int64_t _455 = 0; // t
    _jump1460:; // Begin body of loop
    _a3_bool _457;
    // Computing bound for v
    _457.d0 = _454;
    if (_454 > 0) 
    goto _jump1461;
    fail_assertion("non-positive loop bound");
    _jump1461:;
    // Computing bound for w
    _457.d1 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump1462;
    fail_assertion("non-positive loop bound");
    _jump1462:;
    // Computing bound for x
    _457.d2 = d;
    if (d > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing total size of heap memory to allocate
    int64_t _458 = 1;
    _458 *= _454;
    _458 *= _96.d0;
    _458 *= d;
    _458 *= sizeof(bool);
    _457.data = jpl_alloc(_458);
    int64_t _459 = 0; // x
    int64_t _460 = 0; // w
    int64_t _461 = 0; // v
    _jump1464:; // Begin body of loop
    int64_t _462 = 0;
    _462 *= _457.d0;
    _462 += _461;
    _462 *= _457.d1;
    _462 += _460;
    _462 *= _457.d2;
    _462 += _459;
    _457.data[_462] = a;
    _459++;
    if (_459 < d)
    goto _jump1464;
    _459 = 0;
    _460++;
    if (_460 < _96.d0)
    goto _jump1464;
    _460 = 0;
    _461++;
    if (_461 < _454)
    goto _jump1464;
    // End body of loop
    int64_t _463 = 587;
    int64_t _464 = _463 + _96.d0;
    if (_464 >= 0)
    goto _jump1465;
    fail_assertion("negative array index");
    _jump1465:;
    if (_464 < _457.d0)
    goto _jump1466;
    fail_assertion("index too large");
    _jump1466:;
    if (e >= 0)
    goto _jump1467;
    fail_assertion("negative array index");
    _jump1467:;
    if (e < _457.d1)
    goto _jump1468;
    fail_assertion("index too large");
    _jump1468:;
    if (i >= 0)
    goto _jump1469;
    fail_assertion("negative array index");
    _jump1469:;
    if (i < _457.d2)
    goto _jump1470;
    fail_assertion("index too large");
    _jump1470:;
    int64_t _465 = 0;
    _465 *= _457.d0;
    _465 += _464;
    _465 *= _457.d1;
    _465 += e;
    _465 *= _457.d2;
    _465 += i;
    bool _466 = _457.data[_465];
    bool _456 = _466;
    if (0 != _466)
    goto _jump1471;
    g _467 = l();
    bool _468 = _467.a;
    _456 = _468;
    _jump1471:;
    int64_t _469;
    if (!_456)
    goto _jump1472;
    _469 = _95.d2;
    goto _jump1473;
    _jump1472:;
    _469 = _95.d2;
    _jump1473:;
    _446 += _469;
    _454++;
    if (_454 < _453)
    goto _jump1460;
    _454 = 0;
    _455++;
    if (_455 < _447)
    goto _jump1460;
    // End body of loop
    int64_t _470 = _96.d0 / _446;
    if (_470 >= 0)
    goto _jump1474;
    fail_assertion("negative array index");
    _jump1474:;
    if (_470 < _445.d0)
    goto _jump1475;
    fail_assertion("index too large");
    _jump1475:;
    int64_t _471 = 0;
    _471 *= _445.d0;
    _471 += _470;
    _a2_rgba _472 = _445.data[_471];
    double _473;
    if (!a)
    goto _jump1476;
    double _474 = 75.0;
    _473 = _474;
    goto _jump1477;
    _jump1476:;
    double _475;
    // Computing bound for w
    if (_96.d0 > 0) 
    goto _jump1478;
    fail_assertion("non-positive loop bound");
    _jump1478:;
    _475 = 0;
    int64_t _476 = 0; // w
    _jump1479:; // Begin body of loop
    if (_96.d0 >= 0)
    goto _jump1480;
    fail_assertion("negative array index");
    _jump1480:;
    if (_96.d0 < _96.d0)
    goto _jump1481;
    fail_assertion("index too large");
    _jump1481:;
    int64_t _477 = 0;
    _477 *= _96.d0;
    _477 += _96.d0;
    double _478 = _96.data[_477];
    _475 += _478;
    _476++;
    if (_476 < _96.d0)
    goto _jump1479;
    // End body of loop
    double _479 = 57.0;
    double _480 = -_479;
    double _481 = _475 * _480;
    double _482 = 87.0;
    double _483 = fmod(_481, _482);
    _473 = _483;
    _jump1477:;
    int64_t _484 = -i;
    bool _485 = _484 != _95.d2;
    _a2_double _486;
    if (!_485)
    goto _jump1482;
    _a2_double _487;
    // Computing bound for w
    int64_t _488 = -_95.d2;
    _487.d0 = _488;
    if (_488 > 0) 
    goto _jump1483;
    fail_assertion("non-positive loop bound");
    _jump1483:;
    // Computing bound for x
    _487.d1 = i;
    if (i > 0) 
    goto _jump1484;
    fail_assertion("non-positive loop bound");
    _jump1484:;
    // Computing total size of heap memory to allocate
    int64_t _489 = 1;
    _489 *= _488;
    _489 *= i;
    _489 *= sizeof(double);
    _487.data = jpl_alloc(_489);
    int64_t _490 = 0; // x
    int64_t _491 = 0; // w
    _jump1485:; // Begin body of loop
    rgba _492 = j();
    double _493 = _492.b;
    double _494 = 45.0;
    double _495 = _493 / _494;
    int64_t _496 = 0;
    _496 *= _487.d0;
    _496 += _491;
    _496 *= _487.d1;
    _496 += _490;
    _487.data[_496] = _495;
    _490++;
    if (_490 < i)
    goto _jump1485;
    _490 = 0;
    _491++;
    if (_491 < _488)
    goto _jump1485;
    // End body of loop
    _486 = _487;
    goto _jump1486;
    _jump1482:;
    bool _497 = _95.d0 == _95.d2;
    bool _498 = !_497;
    _a2_double _499;
    if (!_498)
    goto _jump1487;
    _a2_double _500;
    // Computing bound for w
    _500.d0 = _472.d1;
    if (_472.d1 > 0) 
    goto _jump1488;
    fail_assertion("non-positive loop bound");
    _jump1488:;
    // Computing bound for x
    _500.d1 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump1489;
    fail_assertion("non-positive loop bound");
    _jump1489:;
    // Computing total size of heap memory to allocate
    int64_t _501 = 1;
    _501 *= _472.d1;
    _501 *= _95.d2;
    _501 *= sizeof(double);
    _500.data = jpl_alloc(_501);
    int64_t _502 = 0; // x
    int64_t _503 = 0; // w
    _jump1490:; // Begin body of loop
    double _504 = 2.0;
    int64_t _505 = 0;
    _505 *= _500.d0;
    _505 += _503;
    _505 *= _500.d1;
    _505 += _502;
    _500.data[_505] = _504;
    _502++;
    if (_502 < _95.d2)
    goto _jump1490;
    _502 = 0;
    _503++;
    if (_503 < _472.d1)
    goto _jump1490;
    // End body of loop
    _499 = _500;
    goto _jump1491;
    _jump1487:;
    _a2_double _506;
    // Computing bound for w
    _506.d0 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump1492;
    fail_assertion("non-positive loop bound");
    _jump1492:;
    // Computing bound for x
    int64_t _507 = 755;
    _506.d1 = _507;
    if (_507 > 0) 
    goto _jump1493;
    fail_assertion("non-positive loop bound");
    _jump1493:;
    // Computing total size of heap memory to allocate
    int64_t _508 = 1;
    _508 *= _95.d2;
    _508 *= _507;
    _508 *= sizeof(double);
    _506.data = jpl_alloc(_508);
    int64_t _509 = 0; // x
    int64_t _510 = 0; // w
    _jump1494:; // Begin body of loop
    double _511 = 15.0;
    int64_t _512 = 0;
    _512 *= _506.d0;
    _512 += _510;
    _512 *= _506.d1;
    _512 += _509;
    _506.data[_512] = _511;
    _509++;
    if (_509 < _507)
    goto _jump1494;
    _509 = 0;
    _510++;
    if (_510 < _95.d2)
    goto _jump1494;
    // End body of loop
    _499 = _506;
    _jump1491:;
    _486 = _499;
    _jump1486:;
    double _513 = 45.0;
    k _514 = { _95, _96.d0, _513 };
    _a3__a3_double _515 = _514.a;
    double _516 = 19.0;
    double _517 = -_516;
    k _518 = { _515, _95.d0, _517 };
    int64_t _519 = _518.b;
    if (_472.d1 >= 0)
    goto _jump1495;
    fail_assertion("negative array index");
    _jump1495:;
    if (_472.d1 < _486.d0)
    goto _jump1496;
    fail_assertion("index too large");
    _jump1496:;
    if (_519 >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (_519 < _486.d1)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    int64_t _520 = 0;
    _520 *= _486.d0;
    _520 += _472.d1;
    _520 *= _486.d1;
    _520 += _519;
    double _521 = _486.data[_520];
    bool _522 = _473 <= _521;
    g _523;
    if (!_522)
    goto _jump1499;
    g _524 = l();
    _523 = _524;
    goto _jump1500;
    _jump1499:;
    bool _525 = false;
    bool _526;
    if (!_525)
    goto _jump1501;
    g _527 = l();
    bool _528 = _527.a;
    _526 = _528;
    goto _jump1502;
    _jump1501:;
    bool _529 = _95.d0 == _95.d0;
    _526 = _529;
    _jump1502:;
    bool _530;
    if (!_526)
    goto _jump1503;
    bool _531 = !a;
    _530 = _531;
    goto _jump1504;
    _jump1503:;
    bool _533 = false;
    bool _534 = !_533;
    bool _532 = _534;
    if (0 != _534)
    goto _jump1505;
    g _535 = l();
    bool _536 = _535.a;
    _532 = _536;
    _jump1505:;
    g _537 = { _532, _95.d1 };
    bool _538 = _537.a;
    _530 = _538;
    _jump1504:;
    g _539 = { _530, d };
    _523 = _539;
    _jump1500:;
    return _523;
    int64_t _540;
    // Computing bound for w
    if (_95.d0 > 0) 
    goto _jump1506;
    fail_assertion("non-positive loop bound");
    _jump1506:;
    _540 = 0;
    int64_t _541 = 0; // w
    _jump1507:; // Begin body of loop
    _540 += _541;
    _541++;
    if (_541 < _95.d0)
    goto _jump1507;
    // End body of loop
    g _542;
    if (!a)
    goto _jump1508;
    g _543 = l();
    _542 = _543;
    goto _jump1509;
    _jump1508:;
    g _544 = l();
    _542 = _544;
    _jump1509:;
    bool _545 = _542.a;
    g _546;
    if (!_545)
    goto _jump1510;
    _a2__a2__a2_g _547;
    // Computing bound for x
    _547.d0 = _540;
    if (_540 > 0) 
    goto _jump1511;
    fail_assertion("non-positive loop bound");
    _jump1511:;
    // Computing bound for y
    _547.d1 = i;
    if (i > 0) 
    goto _jump1512;
    fail_assertion("non-positive loop bound");
    _jump1512:;
    // Computing total size of heap memory to allocate
    int64_t _548 = 1;
    _548 *= _540;
    _548 *= i;
    _548 *= sizeof(_a2__a2_g);
    _547.data = jpl_alloc(_548);
    int64_t _549 = 0; // y
    int64_t _550 = 0; // x
    _jump1513:; // Begin body of loop
    _a2__a2_g _551;
    // Computing bound for z
    _551.d0 = i;
    if (i > 0) 
    goto _jump1514;
    fail_assertion("non-positive loop bound");
    _jump1514:;
    // Computing bound for A
    _551.d1 = d;
    if (d > 0) 
    goto _jump1515;
    fail_assertion("non-positive loop bound");
    _jump1515:;
    // Computing total size of heap memory to allocate
    int64_t _552 = 1;
    _552 *= i;
    _552 *= d;
    _552 *= sizeof(_a2_g);
    _551.data = jpl_alloc(_552);
    int64_t _553 = 0; // A
    int64_t _554 = 0; // z
    _jump1516:; // Begin body of loop
    _a2_g _555;
    // Computing bound for B
    _555.d0 = _554;
    if (_554 > 0) 
    goto _jump1517;
    fail_assertion("non-positive loop bound");
    _jump1517:;
    // Computing bound for C
    _555.d1 = _554;
    if (_554 > 0) 
    goto _jump1518;
    fail_assertion("non-positive loop bound");
    _jump1518:;
    // Computing total size of heap memory to allocate
    int64_t _556 = 1;
    _556 *= _554;
    _556 *= _554;
    _556 *= sizeof(g);
    _555.data = jpl_alloc(_556);
    int64_t _557 = 0; // C
    int64_t _558 = 0; // B
    _jump1519:; // Begin body of loop
    g _559 = l();
    int64_t _560 = 0;
    _560 *= _555.d0;
    _560 += _558;
    _560 *= _555.d1;
    _560 += _557;
    _555.data[_560] = _559;
    _557++;
    if (_557 < _554)
    goto _jump1519;
    _557 = 0;
    _558++;
    if (_558 < _554)
    goto _jump1519;
    // End body of loop
    int64_t _561 = 0;
    _561 *= _551.d0;
    _561 += _554;
    _561 *= _551.d1;
    _561 += _553;
    _551.data[_561] = _555;
    _553++;
    if (_553 < d)
    goto _jump1516;
    _553 = 0;
    _554++;
    if (_554 < i)
    goto _jump1516;
    // End body of loop
    int64_t _562 = 0;
    _562 *= _547.d0;
    _562 += _550;
    _562 *= _547.d1;
    _562 += _549;
    _547.data[_562] = _551;
    _549++;
    if (_549 < i)
    goto _jump1513;
    _549 = 0;
    _550++;
    if (_550 < _540)
    goto _jump1513;
    // End body of loop
    int64_t _563;
    // Computing bound for x
    if (i > 0) 
    goto _jump1520;
    fail_assertion("non-positive loop bound");
    _jump1520:;
    // Computing bound for y
    if (d > 0) 
    goto _jump1521;
    fail_assertion("non-positive loop bound");
    _jump1521:;
    // Computing bound for z
    if (_95.d2 > 0) 
    goto _jump1522;
    fail_assertion("non-positive loop bound");
    _jump1522:;
    _563 = 0;
    int64_t _564 = 0; // z
    int64_t _565 = 0; // y
    int64_t _566 = 0; // x
    _jump1523:; // Begin body of loop
    _563 += _472.d1;
    _564++;
    if (_564 < _95.d2)
    goto _jump1523;
    _564 = 0;
    _565++;
    if (_565 < d)
    goto _jump1523;
    _565 = 0;
    _566++;
    if (_566 < i)
    goto _jump1523;
    // End body of loop
    int64_t _567;
    if (!a)
    goto _jump1524;
    g _568 = l();
    int64_t _569 = _568.b;
    _567 = _569;
    goto _jump1525;
    _jump1524:;
    _567 = d;
    _jump1525:;
    if (_563 >= 0)
    goto _jump1526;
    fail_assertion("negative array index");
    _jump1526:;
    if (_563 < _547.d0)
    goto _jump1527;
    fail_assertion("index too large");
    _jump1527:;
    if (_567 >= 0)
    goto _jump1528;
    fail_assertion("negative array index");
    _jump1528:;
    if (_567 < _547.d1)
    goto _jump1529;
    fail_assertion("index too large");
    _jump1529:;
    int64_t _570 = 0;
    _570 *= _547.d0;
    _570 += _563;
    _570 *= _547.d1;
    _570 += _567;
    _a2__a2_g _571 = _547.data[_570];
    int64_t _572 = 433;
    if (_572 >= 0)
    goto _jump1530;
    fail_assertion("negative array index");
    _jump1530:;
    if (_572 < _571.d0)
    goto _jump1531;
    fail_assertion("index too large");
    _jump1531:;
    if (_540 >= 0)
    goto _jump1532;
    fail_assertion("negative array index");
    _jump1532:;
    if (_540 < _571.d1)
    goto _jump1533;
    fail_assertion("index too large");
    _jump1533:;
    int64_t _573 = 0;
    _573 *= _571.d0;
    _573 += _572;
    _573 *= _571.d1;
    _573 += _540;
    _a2_g _574 = _571.data[_573];
    bool _575 = false;
    bool _576;
    if (!_575)
    goto _jump1534;
    bool _577 = true;
    _576 = _577;
    goto _jump1535;
    _jump1534:;
    bool _578 = true;
    _576 = _578;
    _jump1535:;
    bool _579 = !_576;
    bool _580;
    if (!_579)
    goto _jump1536;
    bool _581;
    if (!a)
    goto _jump1537;
    bool _582 = _540 >= _95.d2;
    _581 = _582;
    goto _jump1538;
    _jump1537:;
    double _583 = 83.0;
    double _584 = 70.0;
    bool _585 = _583 == _584;
    _581 = _585;
    _jump1538:;
    _580 = _581;
    goto _jump1539;
    _jump1536:;
    bool _586 = false;
    bool _587 = !_586;
    bool _588;
    if (!_587)
    goto _jump1540;
    g _589 = l();
    bool _590 = _589.a;
    _588 = _590;
    goto _jump1541;
    _jump1540:;
    bool _591 = true;
    bool _592 = !_591;
    _588 = _592;
    _jump1541:;
    _580 = _588;
    _jump1539:;
    bool _593 = !_580;
    int64_t _594;
    if (!_593)
    goto _jump1542;
    int64_t _595 = 380;
    _594 = _595;
    goto _jump1543;
    _jump1542:;
    _594 = _96.d0;
    _jump1543:;
    if (_594 >= 0)
    goto _jump1544;
    fail_assertion("negative array index");
    _jump1544:;
    if (_594 < _574.d0)
    goto _jump1545;
    fail_assertion("index too large");
    _jump1545:;
    if (e >= 0)
    goto _jump1546;
    fail_assertion("negative array index");
    _jump1546:;
    if (e < _574.d1)
    goto _jump1547;
    fail_assertion("index too large");
    _jump1547:;
    int64_t _596 = 0;
    _596 *= _574.d0;
    _596 += _594;
    _596 *= _574.d1;
    _596 += e;
    g _597 = _574.data[_596];
    _546 = _597;
    goto _jump1548;
    _jump1510:;
    bool _598 = false;
    g _599 = { _598, _540 };
    _546 = _599;
    _jump1548:;
    return _546;
}

bool n(double o, _a3_k p) {
    int64_t _1;
    // Computing bound for t
    if (i > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    _1 = 0;
    int64_t _2 = 0; // t
    _jump1550:; // Begin body of loop
    _1 += _2;
    _2++;
    if (_2 < i)
    goto _jump1550;
    // End body of loop
    int64_t _3 = p.d0 * p.d1;
    bool _4 = _1 == _3;
    g _5;
    if (!_4)
    goto _jump1551;
    _a1_g _6;
    // Computing bound for t
    _6.d0 = e;
    if (e > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= e;
    _7 *= sizeof(g);
    _6.data = jpl_alloc(_7);
    int64_t _8 = 0; // t
    _jump1553:; // Begin body of loop
    g _9 = l();
    int64_t _10 = 0;
    _10 *= _6.d0;
    _10 += _8;
    _6.data[_10] = _9;
    _8++;
    if (_8 < e)
    goto _jump1553;
    // End body of loop
    if (i >= 0)
    goto _jump1554;
    fail_assertion("negative array index");
    _jump1554:;
    if (i < _6.d0)
    goto _jump1555;
    fail_assertion("index too large");
    _jump1555:;
    int64_t _11 = 0;
    _11 *= _6.d0;
    _11 += i;
    g _12 = _6.data[_11];
    _5 = _12;
    goto _jump1556;
    _jump1551:;
    g _13 = l();
    _5 = _13;
    _jump1556:;
    bool _14 = _5.a;
    bool _15;
    if (!_14)
    goto _jump1557;
    int64_t _16 = 575;
    bool _17 = _16 <= p.d0;
    bool _18 = !_17;
    g _19;
    if (!_18)
    goto _jump1558;
    g _20 = l();
    _19 = _20;
    goto _jump1559;
    _jump1558:;
    bool _21 = true;
    g _22 = { _21, p.d0 };
    _19 = _22;
    _jump1559:;
    bool _23 = _19.a;
    bool _24;
    if (!_23)
    goto _jump1560;
    bool _25 = p.d0 > p.d0;
    bool _26 = true;
    g _27;
    if (!_26)
    goto _jump1561;
    g _28 = l();
    _27 = _28;
    goto _jump1562;
    _jump1561:;
    g _29 = l();
    _27 = _29;
    _jump1562:;
    bool _30 = _27.a;
    bool _31 = _25 == _30;
    bool _32;
    if (!_31)
    goto _jump1563;
    _a1_int64_t _33;
    // Computing bound for t
    _33.d0 = p.d2;
    if (p.d2 > 0) 
    goto _jump1564;
    fail_assertion("non-positive loop bound");
    _jump1564:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= p.d2;
    _34 *= sizeof(int64_t);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // t
    _jump1565:; // Begin body of loop
    int64_t _36 = 0;
    _36 *= _33.d0;
    _36 += _35;
    _33.data[_36] = d;
    _35++;
    if (_35 < p.d2)
    goto _jump1565;
    // End body of loop
    if (e >= 0)
    goto _jump1566;
    fail_assertion("negative array index");
    _jump1566:;
    if (e < _33.d0)
    goto _jump1567;
    fail_assertion("index too large");
    _jump1567:;
    int64_t _37 = 0;
    _37 *= _33.d0;
    _37 += e;
    int64_t _38 = _33.data[_37];
    bool _39 = _38 <= e;
    _32 = _39;
    goto _jump1568;
    _jump1563:;
    double _40 = 59.0;
    bool _41 = o < _40;
    _32 = _41;
    _jump1568:;
    _24 = _32;
    goto _jump1569;
    _jump1560:;
    int64_t _42 = 250;
    bool _43 = p.d0 != _42;
    bool _44;
    if (!_43)
    goto _jump1570;
    bool _45 = p.d2 == p.d1;
    _44 = _45;
    goto _jump1571;
    _jump1570:;
    bool _46 = p.d1 < p.d0;
    _44 = _46;
    _jump1571:;
    g _47 = { _44, e };
    bool _48 = _47.a;
    _24 = _48;
    _jump1569:;
    _15 = _24;
    goto _jump1572;
    _jump1557:;
    double _49 = 27.0;
    _a3__a3_k _50;
    // Computing bound for t
    _50.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump1573;
    fail_assertion("non-positive loop bound");
    _jump1573:;
    // Computing bound for u
    int64_t _51 = 422;
    int64_t _52 = -_51;
    _50.d1 = _52;
    if (_52 > 0) 
    goto _jump1574;
    fail_assertion("non-positive loop bound");
    _jump1574:;
    // Computing bound for v
    int64_t _53 = p.d2 / d;
    _50.d2 = _53;
    if (_53 > 0) 
    goto _jump1575;
    fail_assertion("non-positive loop bound");
    _jump1575:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= p.d0;
    _54 *= _52;
    _54 *= _53;
    _54 *= sizeof(_a3_k);
    _50.data = jpl_alloc(_54);
    int64_t _55 = 0; // v
    int64_t _56 = 0; // u
    int64_t _57 = 0; // t
    _jump1576:; // Begin body of loop
    int64_t _58 = 0;
    _58 *= _50.d0;
    _58 += _57;
    _58 *= _50.d1;
    _58 += _56;
    _58 *= _50.d2;
    _58 += _55;
    _50.data[_58] = p;
    _55++;
    if (_55 < _53)
    goto _jump1576;
    _55 = 0;
    _56++;
    if (_56 < _52)
    goto _jump1576;
    _56 = 0;
    _57++;
    if (_57 < p.d0)
    goto _jump1576;
    // End body of loop
    int64_t _59 = 315;
    int64_t _60 = 740;
    int64_t _61 = _60 + e;
    int64_t _62 = -_61;
    if (_59 >= 0)
    goto _jump1577;
    fail_assertion("negative array index");
    _jump1577:;
    if (_59 < _50.d0)
    goto _jump1578;
    fail_assertion("index too large");
    _jump1578:;
    if (_62 >= 0)
    goto _jump1579;
    fail_assertion("negative array index");
    _jump1579:;
    if (_62 < _50.d1)
    goto _jump1580;
    fail_assertion("index too large");
    _jump1580:;
    if (p.d1 >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (p.d1 < _50.d2)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    int64_t _63 = 0;
    _63 *= _50.d0;
    _63 += _59;
    _63 *= _50.d1;
    _63 += _62;
    _63 *= _50.d2;
    _63 += p.d1;
    _a3_k _64 = _50.data[_63];
    bool _65 = n(_49, _64);
    bool _66 = !_65;
    _15 = _66;
    _jump1572:;
    bool _0 = _15;
    if (0 != _15)
    goto _jump1583;
    _a3__a3_double _67;
    // Computing bound for t
    int64_t _68;
    // Computing bound for t
    if (p.d2 > 0) 
    goto _jump1584;
    fail_assertion("non-positive loop bound");
    _jump1584:;
    // Computing bound for u
    if (p.d0 > 0) 
    goto _jump1585;
    fail_assertion("non-positive loop bound");
    _jump1585:;
    _68 = 0;
    int64_t _69 = 0; // u
    int64_t _70 = 0; // t
    _jump1586:; // Begin body of loop
    _68 += p.d0;
    _69++;
    if (_69 < p.d0)
    goto _jump1586;
    _69 = 0;
    _70++;
    if (_70 < p.d2)
    goto _jump1586;
    // End body of loop
    int64_t _71 = -_68;
    _67.d0 = _71;
    if (_71 > 0) 
    goto _jump1587;
    fail_assertion("non-positive loop bound");
    _jump1587:;
    // Computing bound for u
    g _72 = l();
    int64_t _73 = _72.b;
    _67.d1 = _73;
    if (_73 > 0) 
    goto _jump1588;
    fail_assertion("non-positive loop bound");
    _jump1588:;
    // Computing bound for v
    g _74 = { a, p.d2 };
    int64_t _75 = _74.b;
    _67.d2 = _75;
    if (_75 > 0) 
    goto _jump1589;
    fail_assertion("non-positive loop bound");
    _jump1589:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _71;
    _76 *= _73;
    _76 *= _75;
    _76 *= sizeof(_a3_double);
    _67.data = jpl_alloc(_76);
    int64_t _77 = 0; // v
    int64_t _78 = 0; // u
    int64_t _79 = 0; // t
    _jump1590:; // Begin body of loop
    _a3_double _80;
    // Computing bound for w
    _80.d0 = d;
    if (d > 0) 
    goto _jump1591;
    fail_assertion("non-positive loop bound");
    _jump1591:;
    // Computing bound for x
    _80.d1 = p.d1;
    if (p.d1 > 0) 
    goto _jump1592;
    fail_assertion("non-positive loop bound");
    _jump1592:;
    // Computing bound for y
    _80.d2 = _77;
    if (_77 > 0) 
    goto _jump1593;
    fail_assertion("non-positive loop bound");
    _jump1593:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= d;
    _81 *= p.d1;
    _81 *= _77;
    _81 *= sizeof(double);
    _80.data = jpl_alloc(_81);
    int64_t _82 = 0; // y
    int64_t _83 = 0; // x
    int64_t _84 = 0; // w
    _jump1594:; // Begin body of loop
    rgba _85 = j();
    double _86 = _85.b;
    int64_t _87 = 0;
    _87 *= _80.d0;
    _87 += _84;
    _87 *= _80.d1;
    _87 += _83;
    _87 *= _80.d2;
    _87 += _82;
    _80.data[_87] = _86;
    _82++;
    if (_82 < _77)
    goto _jump1594;
    _82 = 0;
    _83++;
    if (_83 < p.d1)
    goto _jump1594;
    _83 = 0;
    _84++;
    if (_84 < d)
    goto _jump1594;
    // End body of loop
    int64_t _88 = 0;
    _88 *= _67.d0;
    _88 += _79;
    _88 *= _67.d1;
    _88 += _78;
    _88 *= _67.d2;
    _88 += _77;
    _67.data[_88] = _80;
    _77++;
    if (_77 < _75)
    goto _jump1590;
    _77 = 0;
    _78++;
    if (_78 < _73)
    goto _jump1590;
    _78 = 0;
    _79++;
    if (_79 < _71)
    goto _jump1590;
    // End body of loop
    k _89 = { _67, p.d2, o };
    double _90 = _89.c;
    _a2__a3_k _91;
    // Computing bound for t
    _91.d0 = i;
    if (i > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing bound for u
    g _92;
    if (!a)
    goto _jump1596;
    bool _93 = true;
    g _94 = { _93, d };
    _92 = _94;
    goto _jump1597;
    _jump1596:;
    g _95 = { a, p.d1 };
    _92 = _95;
    _jump1597:;
    int64_t _96 = _92.b;
    _91.d1 = _96;
    if (_96 > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= i;
    _97 *= _96;
    _97 *= sizeof(_a3_k);
    _91.data = jpl_alloc(_97);
    int64_t _98 = 0; // u
    int64_t _99 = 0; // t
    _jump1599:; // Begin body of loop
    bool _100 = true;
    bool _101 = !_100;
    _a3_k _102;
    if (!_101)
    goto _jump1600;
    _102 = p;
    goto _jump1601;
    _jump1600:;
    _102 = p;
    _jump1601:;
    int64_t _103 = 0;
    _103 *= _91.d0;
    _103 += _99;
    _103 *= _91.d1;
    _103 += _98;
    _91.data[_103] = _102;
    _98++;
    if (_98 < _96)
    goto _jump1599;
    _98 = 0;
    _99++;
    if (_99 < i)
    goto _jump1599;
    // End body of loop
    g _106 = l();
    bool _107 = _106.a;
    bool _105 = _107;
    if (0 != _107)
    goto _jump1602;
    double _108 = 57.0;
    bool _109 = o != _108;
    _105 = _109;
    _jump1602:;
    bool _104 = _105;
    if (0 != _105)
    goto _jump1603;
    _104 = a;
    _jump1603:;
    int64_t _110;
    if (!_104)
    goto _jump1604;
    int64_t _111 = 388;
    _110 = _111;
    goto _jump1605;
    _jump1604:;
    g _112;
    if (!a)
    goto _jump1606;
    bool _113 = false;
    g _114 = { _113, i };
    _112 = _114;
    goto _jump1607;
    _jump1606:;
    g _115 = l();
    _112 = _115;
    _jump1607:;
    int64_t _116 = _112.b;
    _110 = _116;
    _jump1605:;
    if (i >= 0)
    goto _jump1608;
    fail_assertion("negative array index");
    _jump1608:;
    if (i < _91.d0)
    goto _jump1609;
    fail_assertion("index too large");
    _jump1609:;
    if (_110 >= 0)
    goto _jump1610;
    fail_assertion("negative array index");
    _jump1610:;
    if (_110 < _91.d1)
    goto _jump1611;
    fail_assertion("index too large");
    _jump1611:;
    int64_t _117 = 0;
    _117 *= _91.d0;
    _117 += i;
    _117 *= _91.d1;
    _117 += _110;
    _a3_k _118 = _91.data[_117];
    bool _119 = n(_90, _118);
    _0 = _119;
    _jump1583:;
    if (0 != _0)
    goto _jump1612;
    fail_assertion("t");
    _jump1612:;
    bool _120 = false;
    int64_t _121;
    // Computing bound for t
    if (p.d0 > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for u
    int64_t _122 = 585;
    if (_122 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for v
    int64_t _123 = 489;
    if (_123 > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    _121 = 0;
    int64_t _124 = 0; // v
    int64_t _125 = 0; // u
    int64_t _126 = 0; // t
    _jump1616:; // Begin body of loop
    _121 += _126;
    _124++;
    if (_124 < _123)
    goto _jump1616;
    _124 = 0;
    _125++;
    if (_125 < _122)
    goto _jump1616;
    _125 = 0;
    _126++;
    if (_126 < p.d0)
    goto _jump1616;
    // End body of loop
    g _127 = { _120, _121 };
    bool _128 = _127.a;
    bool _129 = !_128;
    _a3__a3_double _130;
    if (!_129)
    goto _jump1617;
    _a3__a3__a3_double _131;
    // Computing bound for t
    _131.d0 = d;
    if (d > 0) 
    goto _jump1618;
    fail_assertion("non-positive loop bound");
    _jump1618:;
    // Computing bound for u
    _131.d1 = i;
    if (i > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    // Computing bound for v
    _131.d2 = p.d0;
    if (p.d0 > 0) 
    goto _jump1620;
    fail_assertion("non-positive loop bound");
    _jump1620:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= d;
    _132 *= i;
    _132 *= p.d0;
    _132 *= sizeof(_a3__a3_double);
    _131.data = jpl_alloc(_132);
    int64_t _133 = 0; // v
    int64_t _134 = 0; // u
    int64_t _135 = 0; // t
    _jump1621:; // Begin body of loop
    if (_135 >= 0)
    goto _jump1622;
    fail_assertion("negative array index");
    _jump1622:;
    if (_135 < p.d0)
    goto _jump1623;
    fail_assertion("index too large");
    _jump1623:;
    if (_133 >= 0)
    goto _jump1624;
    fail_assertion("negative array index");
    _jump1624:;
    if (_133 < p.d1)
    goto _jump1625;
    fail_assertion("index too large");
    _jump1625:;
    if (_134 >= 0)
    goto _jump1626;
    fail_assertion("negative array index");
    _jump1626:;
    if (_134 < p.d2)
    goto _jump1627;
    fail_assertion("index too large");
    _jump1627:;
    int64_t _136 = 0;
    _136 *= p.d0;
    _136 += _135;
    _136 *= p.d1;
    _136 += _133;
    _136 *= p.d2;
    _136 += _134;
    k _137 = p.data[_136];
    _a3__a3_double _138 = _137.a;
    int64_t _139 = 0;
    _139 *= _131.d0;
    _139 += _135;
    _139 *= _131.d1;
    _139 += _134;
    _139 *= _131.d2;
    _139 += _133;
    _131.data[_139] = _138;
    _133++;
    if (_133 < p.d0)
    goto _jump1621;
    _133 = 0;
    _134++;
    if (_134 < i)
    goto _jump1621;
    _134 = 0;
    _135++;
    if (_135 < d)
    goto _jump1621;
    // End body of loop
    _a2_bool _140;
    // Computing bound for t
    _140.d0 = d;
    if (d > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing bound for u
    _140.d1 = p.d0;
    if (p.d0 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= d;
    _141 *= p.d0;
    _141 *= sizeof(bool);
    _140.data = jpl_alloc(_141);
    int64_t _142 = 0; // u
    int64_t _143 = 0; // t
    _jump1630:; // Begin body of loop
    int64_t _144 = 0;
    _144 *= _140.d0;
    _144 += _143;
    _144 *= _140.d1;
    _144 += _142;
    _140.data[_144] = a;
    _142++;
    if (_142 < p.d0)
    goto _jump1630;
    _142 = 0;
    _143++;
    if (_143 < d)
    goto _jump1630;
    // End body of loop
    int64_t _145 = d / p.d0;
    int64_t _146 = 989;
    if (_145 >= 0)
    goto _jump1631;
    fail_assertion("negative array index");
    _jump1631:;
    if (_145 < _140.d0)
    goto _jump1632;
    fail_assertion("index too large");
    _jump1632:;
    if (_146 >= 0)
    goto _jump1633;
    fail_assertion("negative array index");
    _jump1633:;
    if (_146 < _140.d1)
    goto _jump1634;
    fail_assertion("index too large");
    _jump1634:;
    int64_t _147 = 0;
    _147 *= _140.d0;
    _147 += _145;
    _147 *= _140.d1;
    _147 += _146;
    bool _148 = _140.data[_147];
    int64_t _149;
    if (!_148)
    goto _jump1635;
    _a2_int64_t _150;
    // Computing bound for t
    _150.d0 = p.d1;
    if (p.d1 > 0) 
    goto _jump1636;
    fail_assertion("non-positive loop bound");
    _jump1636:;
    // Computing bound for u
    _150.d1 = p.d1;
    if (p.d1 > 0) 
    goto _jump1637;
    fail_assertion("non-positive loop bound");
    _jump1637:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= p.d1;
    _151 *= p.d1;
    _151 *= sizeof(int64_t);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // u
    int64_t _153 = 0; // t
    _jump1638:; // Begin body of loop
    int64_t _154 = 0;
    _154 *= _150.d0;
    _154 += _153;
    _154 *= _150.d1;
    _154 += _152;
    _150.data[_154] = i;
    _152++;
    if (_152 < p.d1)
    goto _jump1638;
    _152 = 0;
    _153++;
    if (_153 < p.d1)
    goto _jump1638;
    // End body of loop
    if (p.d1 >= 0)
    goto _jump1639;
    fail_assertion("negative array index");
    _jump1639:;
    if (p.d1 < _150.d0)
    goto _jump1640;
    fail_assertion("index too large");
    _jump1640:;
    if (p.d0 >= 0)
    goto _jump1641;
    fail_assertion("negative array index");
    _jump1641:;
    if (p.d0 < _150.d1)
    goto _jump1642;
    fail_assertion("index too large");
    _jump1642:;
    int64_t _155 = 0;
    _155 *= _150.d0;
    _155 += p.d1;
    _155 *= _150.d1;
    _155 += p.d0;
    int64_t _156 = _150.data[_155];
    _149 = _156;
    goto _jump1643;
    _jump1635:;
    _149 = p.d2;
    _jump1643:;
    g _157 = l();
    int64_t _158 = _157.b;
    g _159 = { a, _158 };
    int64_t _160 = _159.b;
    if (_149 >= 0)
    goto _jump1644;
    fail_assertion("negative array index");
    _jump1644:;
    if (_149 < _131.d0)
    goto _jump1645;
    fail_assertion("index too large");
    _jump1645:;
    if (_160 >= 0)
    goto _jump1646;
    fail_assertion("negative array index");
    _jump1646:;
    if (_160 < _131.d1)
    goto _jump1647;
    fail_assertion("index too large");
    _jump1647:;
    if (e >= 0)
    goto _jump1648;
    fail_assertion("negative array index");
    _jump1648:;
    if (e < _131.d2)
    goto _jump1649;
    fail_assertion("index too large");
    _jump1649:;
    int64_t _161 = 0;
    _161 *= _131.d0;
    _161 += _149;
    _161 *= _131.d1;
    _161 += _160;
    _161 *= _131.d2;
    _161 += e;
    _a3__a3_double _162 = _131.data[_161];
    _130 = _162;
    goto _jump1650;
    _jump1617:;
    int64_t _163 = -i;
    if (_163 >= 0)
    goto _jump1651;
    fail_assertion("negative array index");
    _jump1651:;
    if (_163 < p.d0)
    goto _jump1652;
    fail_assertion("index too large");
    _jump1652:;
    if (d >= 0)
    goto _jump1653;
    fail_assertion("negative array index");
    _jump1653:;
    if (d < p.d1)
    goto _jump1654;
    fail_assertion("index too large");
    _jump1654:;
    if (i >= 0)
    goto _jump1655;
    fail_assertion("negative array index");
    _jump1655:;
    if (i < p.d2)
    goto _jump1656;
    fail_assertion("index too large");
    _jump1656:;
    int64_t _164 = 0;
    _164 *= p.d0;
    _164 += _163;
    _164 *= p.d1;
    _164 += d;
    _164 *= p.d2;
    _164 += i;
    k _165 = p.data[_164];
    _a3__a3_double _166 = _165.a;
    _130 = _166;
    _jump1650:;
    double _167 = 44.0;
    bool _168 = o != _167;
    _a3__a3_double _169;
    if (!_168)
    goto _jump1657;
    _a3__a3_double _170;
    // Computing bound for t
    _170.d0 = p.d1;
    if (p.d1 > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    // Computing bound for u
    _170.d1 = p.d2;
    if (p.d2 > 0) 
    goto _jump1659;
    fail_assertion("non-positive loop bound");
    _jump1659:;
    // Computing bound for v
    int64_t _171 = 521;
    _170.d2 = _171;
    if (_171 > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= p.d1;
    _172 *= p.d2;
    _172 *= _171;
    _172 *= sizeof(_a3_double);
    _170.data = jpl_alloc(_172);
    int64_t _173 = 0; // v
    int64_t _174 = 0; // u
    int64_t _175 = 0; // t
    _jump1661:; // Begin body of loop
    _a3_double _176;
    // Computing bound for w
    _176.d0 = p.d2;
    if (p.d2 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    // Computing bound for x
    int64_t _177 = 492;
    _176.d1 = _177;
    if (_177 > 0) 
    goto _jump1663;
    fail_assertion("non-positive loop bound");
    _jump1663:;
    // Computing bound for y
    _176.d2 = p.d1;
    if (p.d1 > 0) 
    goto _jump1664;
    fail_assertion("non-positive loop bound");
    _jump1664:;
    // Computing total size of heap memory to allocate
    int64_t _178 = 1;
    _178 *= p.d2;
    _178 *= _177;
    _178 *= p.d1;
    _178 *= sizeof(double);
    _176.data = jpl_alloc(_178);
    int64_t _179 = 0; // y
    int64_t _180 = 0; // x
    int64_t _181 = 0; // w
    _jump1665:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _176.d0;
    _182 += _181;
    _182 *= _176.d1;
    _182 += _180;
    _182 *= _176.d2;
    _182 += _179;
    _176.data[_182] = o;
    _179++;
    if (_179 < p.d1)
    goto _jump1665;
    _179 = 0;
    _180++;
    if (_180 < _177)
    goto _jump1665;
    _180 = 0;
    _181++;
    if (_181 < p.d2)
    goto _jump1665;
    // End body of loop
    int64_t _183 = 0;
    _183 *= _170.d0;
    _183 += _175;
    _183 *= _170.d1;
    _183 += _174;
    _183 *= _170.d2;
    _183 += _173;
    _170.data[_183] = _176;
    _173++;
    if (_173 < _171)
    goto _jump1661;
    _173 = 0;
    _174++;
    if (_174 < p.d2)
    goto _jump1661;
    _174 = 0;
    _175++;
    if (_175 < p.d1)
    goto _jump1661;
    // End body of loop
    _169 = _170;
    goto _jump1666;
    _jump1657:;
    if (i >= 0)
    goto _jump1667;
    fail_assertion("negative array index");
    _jump1667:;
    if (i < p.d0)
    goto _jump1668;
    fail_assertion("index too large");
    _jump1668:;
    if (p.d0 >= 0)
    goto _jump1669;
    fail_assertion("negative array index");
    _jump1669:;
    if (p.d0 < p.d1)
    goto _jump1670;
    fail_assertion("index too large");
    _jump1670:;
    if (p.d0 >= 0)
    goto _jump1671;
    fail_assertion("negative array index");
    _jump1671:;
    if (p.d0 < p.d2)
    goto _jump1672;
    fail_assertion("index too large");
    _jump1672:;
    int64_t _184 = 0;
    _184 *= p.d0;
    _184 += i;
    _184 *= p.d1;
    _184 += p.d0;
    _184 *= p.d2;
    _184 += p.d0;
    k _185 = p.data[_184];
    _a3__a3_double _186 = _185.a;
    _169 = _186;
    _jump1666:;
    int64_t _187;
    // Computing bound for t
    int64_t _188 = 238;
    if (_188 > 0) 
    goto _jump1673;
    fail_assertion("non-positive loop bound");
    _jump1673:;
    // Computing bound for u
    if (p.d0 > 0) 
    goto _jump1674;
    fail_assertion("non-positive loop bound");
    _jump1674:;
    // Computing bound for v
    int64_t _189 = 388;
    if (_189 > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    _187 = 0;
    int64_t _190 = 0; // v
    int64_t _191 = 0; // u
    int64_t _192 = 0; // t
    _jump1676:; // Begin body of loop
    _187 += _190;
    _190++;
    if (_190 < _189)
    goto _jump1676;
    _190 = 0;
    _191++;
    if (_191 < p.d0)
    goto _jump1676;
    _191 = 0;
    _192++;
    if (_192 < _188)
    goto _jump1676;
    // End body of loop
    int64_t _193 = -_187;
    double _194;
    // Computing bound for t
    int64_t _195 = 262;
    if (_195 > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    _194 = 0;
    int64_t _196 = 0; // t
    _jump1678:; // Begin body of loop
    g _197 = l();
    bool _198 = _197.a;
    double _199;
    if (!_198)
    goto _jump1679;
    bool _200 = true;
    double _201;
    if (!_200)
    goto _jump1680;
    _201 = o;
    goto _jump1681;
    _jump1680:;
    _201 = o;
    _jump1681:;
    _199 = _201;
    goto _jump1682;
    _jump1679:;
    _199 = o;
    _jump1682:;
    _194 += _199;
    _196++;
    if (_196 < _195)
    goto _jump1678;
    // End body of loop
    k _202 = { _169, _193, _194 };
    int64_t _203 = _202.b;
    _a3_double _204;
    // Computing bound for t
    _204.d0 = i;
    if (i > 0) 
    goto _jump1683;
    fail_assertion("non-positive loop bound");
    _jump1683:;
    // Computing bound for u
    _a1_g _205;
    // Computing bound for t
    _205.d0 = p.d1;
    if (p.d1 > 0) 
    goto _jump1684;
    fail_assertion("non-positive loop bound");
    _jump1684:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= p.d1;
    _206 *= sizeof(g);
    _205.data = jpl_alloc(_206);
    int64_t _207 = 0; // t
    _jump1685:; // Begin body of loop
    g _208 = l();
    int64_t _209 = 0;
    _209 *= _205.d0;
    _209 += _207;
    _205.data[_209] = _208;
    _207++;
    if (_207 < p.d1)
    goto _jump1685;
    // End body of loop
    int64_t _210 = -d;
    if (_210 >= 0)
    goto _jump1686;
    fail_assertion("negative array index");
    _jump1686:;
    if (_210 < _205.d0)
    goto _jump1687;
    fail_assertion("index too large");
    _jump1687:;
    int64_t _211 = 0;
    _211 *= _205.d0;
    _211 += _210;
    g _212 = _205.data[_211];
    int64_t _213 = _212.b;
    _204.d1 = _213;
    if (_213 > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing bound for v
    bool _214;
    if (!a)
    goto _jump1689;
    bool _215 = false;
    _214 = _215;
    goto _jump1690;
    _jump1689:;
    _214 = a;
    _jump1690:;
    bool _216;
    if (!_214)
    goto _jump1691;
    double _217 = 2.0;
    bool _218 = o == _217;
    _216 = _218;
    goto _jump1692;
    _jump1691:;
    bool _219 = true;
    _216 = _219;
    _jump1692:;
    int64_t _220;
    if (!_216)
    goto _jump1693;
    int64_t _221 = -p.d0;
    _220 = _221;
    goto _jump1694;
    _jump1693:;
    g _222 = l();
    int64_t _223 = _222.b;
    _220 = _223;
    _jump1694:;
    _204.d2 = _220;
    if (_220 > 0) 
    goto _jump1695;
    fail_assertion("non-positive loop bound");
    _jump1695:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= i;
    _224 *= _213;
    _224 *= _220;
    _224 *= sizeof(double);
    _204.data = jpl_alloc(_224);
    int64_t _225 = 0; // v
    int64_t _226 = 0; // u
    int64_t _227 = 0; // t
    _jump1696:; // Begin body of loop
    double _228;
    // Computing bound for w
    if (p.d2 > 0) 
    goto _jump1697;
    fail_assertion("non-positive loop bound");
    _jump1697:;
    _228 = 0;
    int64_t _229 = 0; // w
    _jump1698:; // Begin body of loop
    rgba _230 = j();
    double _231 = _230.r;
    double _232 = 29.0;
    double _233 = _231 + _232;
    _228 += _233;
    _229++;
    if (_229 < p.d2)
    goto _jump1698;
    // End body of loop
    int64_t _234 = 0;
    _234 *= _204.d0;
    _234 += _227;
    _234 *= _204.d1;
    _234 += _226;
    _234 *= _204.d2;
    _234 += _225;
    _204.data[_234] = _228;
    _225++;
    if (_225 < _220)
    goto _jump1696;
    _225 = 0;
    _226++;
    if (_226 < _213)
    goto _jump1696;
    _226 = 0;
    _227++;
    if (_227 < i)
    goto _jump1696;
    // End body of loop
    int64_t _235 = -i;
    int64_t _236 = -_235;
    int64_t _237 = 494;
    bool _238 = true;
    g _239 = { _238, p.d2 };
    int64_t _240 = _239.b;
    if (_236 >= 0)
    goto _jump1699;
    fail_assertion("negative array index");
    _jump1699:;
    if (_236 < _204.d0)
    goto _jump1700;
    fail_assertion("index too large");
    _jump1700:;
    if (_237 >= 0)
    goto _jump1701;
    fail_assertion("negative array index");
    _jump1701:;
    if (_237 < _204.d1)
    goto _jump1702;
    fail_assertion("index too large");
    _jump1702:;
    if (_240 >= 0)
    goto _jump1703;
    fail_assertion("negative array index");
    _jump1703:;
    if (_240 < _204.d2)
    goto _jump1704;
    fail_assertion("index too large");
    _jump1704:;
    int64_t _241 = 0;
    _241 *= _204.d0;
    _241 += _236;
    _241 *= _204.d1;
    _241 += _237;
    _241 *= _204.d2;
    _241 += _240;
    double _242 = _204.data[_241];
    k _243 = { _130, _203, _242 };
    _a3__a3_double _244 = _243.a;
    bool _245 = false;
    if (0 != _245)
    goto _jump1705;
    fail_assertion("x");
    _jump1705:;
    return a;
    bool _247 = false;
    bool _248 = true;
    bool _249 = _247 == _248;
    double _250;
    if (!_249)
    goto _jump1706;
    double _251;
    // Computing bound for x
    if (_244.d2 > 0) 
    goto _jump1707;
    fail_assertion("non-positive loop bound");
    _jump1707:;
    _251 = 0;
    int64_t _252 = 0; // x
    _jump1708:; // Begin body of loop
    double _253 = 64.0;
    _251 += _253;
    _252++;
    if (_252 < _244.d2)
    goto _jump1708;
    // End body of loop
    _250 = _251;
    goto _jump1709;
    _jump1706:;
    _250 = o;
    _jump1709:;
    _a2_double _254;
    // Computing bound for x
    int64_t _255;
    // Computing bound for x
    if (p.d1 > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    // Computing bound for y
    if (p.d1 > 0) 
    goto _jump1711;
    fail_assertion("non-positive loop bound");
    _jump1711:;
    // Computing bound for z
    if (p.d0 > 0) 
    goto _jump1712;
    fail_assertion("non-positive loop bound");
    _jump1712:;
    _255 = 0;
    int64_t _256 = 0; // z
    int64_t _257 = 0; // y
    int64_t _258 = 0; // x
    _jump1713:; // Begin body of loop
    _255 += _258;
    _256++;
    if (_256 < p.d0)
    goto _jump1713;
    _256 = 0;
    _257++;
    if (_257 < p.d1)
    goto _jump1713;
    _257 = 0;
    _258++;
    if (_258 < p.d1)
    goto _jump1713;
    // End body of loop
    _254.d0 = _255;
    if (_255 > 0) 
    goto _jump1714;
    fail_assertion("non-positive loop bound");
    _jump1714:;
    // Computing bound for y
    _254.d1 = p.d0;
    if (p.d0 > 0) 
    goto _jump1715;
    fail_assertion("non-positive loop bound");
    _jump1715:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= _255;
    _259 *= p.d0;
    _259 *= sizeof(double);
    _254.data = jpl_alloc(_259);
    int64_t _260 = 0; // y
    int64_t _261 = 0; // x
    _jump1716:; // Begin body of loop
    double _262 = 92.0;
    int64_t _263 = 0;
    _263 *= _254.d0;
    _263 += _261;
    _263 *= _254.d1;
    _263 += _260;
    _254.data[_263] = _262;
    _260++;
    if (_260 < p.d0)
    goto _jump1716;
    _260 = 0;
    _261++;
    if (_261 < _255)
    goto _jump1716;
    // End body of loop
    bool _264 = f(_250, _254);
    bool _246 = _264;
    if (0 != _264)
    goto _jump1717;
    _a3_bool _265;
    // Computing bound for x
    _265.d0 = _244.d0;
    if (_244.d0 > 0) 
    goto _jump1718;
    fail_assertion("non-positive loop bound");
    _jump1718:;
    // Computing bound for y
    _265.d1 = p.d1;
    if (p.d1 > 0) 
    goto _jump1719;
    fail_assertion("non-positive loop bound");
    _jump1719:;
    // Computing bound for z
    _265.d2 = _244.d2;
    if (_244.d2 > 0) 
    goto _jump1720;
    fail_assertion("non-positive loop bound");
    _jump1720:;
    // Computing total size of heap memory to allocate
    int64_t _266 = 1;
    _266 *= _244.d0;
    _266 *= p.d1;
    _266 *= _244.d2;
    _266 *= sizeof(bool);
    _265.data = jpl_alloc(_266);
    int64_t _267 = 0; // z
    int64_t _268 = 0; // y
    int64_t _269 = 0; // x
    _jump1721:; // Begin body of loop
    bool _270 = p.d0 > p.d2;
    int64_t _271 = 0;
    _271 *= _265.d0;
    _271 += _269;
    _271 *= _265.d1;
    _271 += _268;
    _271 *= _265.d2;
    _271 += _267;
    _265.data[_271] = _270;
    _267++;
    if (_267 < _244.d2)
    goto _jump1721;
    _267 = 0;
    _268++;
    if (_268 < p.d1)
    goto _jump1721;
    _268 = 0;
    _269++;
    if (_269 < _244.d0)
    goto _jump1721;
    // End body of loop
    bool _272 = true;
    g _273 = { _272, e };
    int64_t _274 = _273.b;
    int64_t _275 = -e;
    if (_274 >= 0)
    goto _jump1722;
    fail_assertion("negative array index");
    _jump1722:;
    if (_274 < _265.d0)
    goto _jump1723;
    fail_assertion("index too large");
    _jump1723:;
    if (e >= 0)
    goto _jump1724;
    fail_assertion("negative array index");
    _jump1724:;
    if (e < _265.d1)
    goto _jump1725;
    fail_assertion("index too large");
    _jump1725:;
    if (_275 >= 0)
    goto _jump1726;
    fail_assertion("negative array index");
    _jump1726:;
    if (_275 < _265.d2)
    goto _jump1727;
    fail_assertion("index too large");
    _jump1727:;
    int64_t _276 = 0;
    _276 *= _265.d0;
    _276 += _274;
    _276 *= _265.d1;
    _276 += e;
    _276 *= _265.d2;
    _276 += _275;
    bool _277 = _265.data[_276];
    _246 = _277;
    _jump1717:;
    k _278;
    if (!_246)
    goto _jump1728;
    double _279;
    // Computing bound for x
    bool _280 = false;
    int64_t _281;
    if (!_280)
    goto _jump1729;
    int64_t _282 = -_244.d1;
    _281 = _282;
    goto _jump1730;
    _jump1729:;
    int64_t _283 = -p.d0;
    _281 = _283;
    _jump1730:;
    if (_281 > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    // Computing bound for y
    if (p.d2 > 0) 
    goto _jump1732;
    fail_assertion("non-positive loop bound");
    _jump1732:;
    _279 = 0;
    int64_t _284 = 0; // y
    int64_t _285 = 0; // x
    _jump1733:; // Begin body of loop
    bool _286 = !a;
    double _287;
    if (!_286)
    goto _jump1734;
    double _288 = -o;
    _287 = _288;
    goto _jump1735;
    _jump1734:;
    double _289;
    // Computing bound for z
    int64_t _290 = 800;
    if (_290 > 0) 
    goto _jump1736;
    fail_assertion("non-positive loop bound");
    _jump1736:;
    // Computing bound for A
    if (_285 > 0) 
    goto _jump1737;
    fail_assertion("non-positive loop bound");
    _jump1737:;
    // Computing bound for B
    if (_285 > 0) 
    goto _jump1738;
    fail_assertion("non-positive loop bound");
    _jump1738:;
    _289 = 0;
    int64_t _291 = 0; // B
    int64_t _292 = 0; // A
    int64_t _293 = 0; // z
    _jump1739:; // Begin body of loop
    double _294 = 37.0;
    _289 += _294;
    _291++;
    if (_291 < _285)
    goto _jump1739;
    _291 = 0;
    _292++;
    if (_292 < _285)
    goto _jump1739;
    _292 = 0;
    _293++;
    if (_293 < _290)
    goto _jump1739;
    // End body of loop
    _287 = _289;
    _jump1735:;
    _279 += _287;
    _284++;
    if (_284 < p.d2)
    goto _jump1733;
    _284 = 0;
    _285++;
    if (_285 < _281)
    goto _jump1733;
    // End body of loop
    k _295 = { _244, e, _279 };
    _278 = _295;
    goto _jump1740;
    _jump1728:;
    rgba _297 = j();
    double _298 = _297.g;
    _a2_double _299;
    // Computing bound for x
    _299.d0 = e;
    if (e > 0) 
    goto _jump1741;
    fail_assertion("non-positive loop bound");
    _jump1741:;
    // Computing bound for y
    _299.d1 = _244.d1;
    if (_244.d1 > 0) 
    goto _jump1742;
    fail_assertion("non-positive loop bound");
    _jump1742:;
    // Computing total size of heap memory to allocate
    int64_t _300 = 1;
    _300 *= e;
    _300 *= _244.d1;
    _300 *= sizeof(double);
    _299.data = jpl_alloc(_300);
    int64_t _301 = 0; // y
    int64_t _302 = 0; // x
    _jump1743:; // Begin body of loop
    int64_t _303 = 0;
    _303 *= _299.d0;
    _303 += _302;
    _303 *= _299.d1;
    _303 += _301;
    _299.data[_303] = o;
    _301++;
    if (_301 < _244.d1)
    goto _jump1743;
    _301 = 0;
    _302++;
    if (_302 < e)
    goto _jump1743;
    // End body of loop
    bool _304 = f(_298, _299);
    bool _296 = _304;
    if (0 != _304)
    goto _jump1744;
    bool _306 = p.d0 > _244.d2;
    bool _305 = _306;
    if (0 == _306)
    goto _jump1745;
    g _307 = l();
    bool _308 = _307.a;
    _305 = _308;
    _jump1745:;
    _296 = _305;
    _jump1744:;
    k _309;
    if (!_296)
    goto _jump1746;
    _a3__a3_double _310;
    // Computing bound for x
    _310.d0 = i;
    if (i > 0) 
    goto _jump1747;
    fail_assertion("non-positive loop bound");
    _jump1747:;
    // Computing bound for y
    _310.d1 = p.d2;
    if (p.d2 > 0) 
    goto _jump1748;
    fail_assertion("non-positive loop bound");
    _jump1748:;
    // Computing bound for z
    int64_t _311 = 296;
    _310.d2 = _311;
    if (_311 > 0) 
    goto _jump1749;
    fail_assertion("non-positive loop bound");
    _jump1749:;
    // Computing total size of heap memory to allocate
    int64_t _312 = 1;
    _312 *= i;
    _312 *= p.d2;
    _312 *= _311;
    _312 *= sizeof(_a3_double);
    _310.data = jpl_alloc(_312);
    int64_t _313 = 0; // z
    int64_t _314 = 0; // y
    int64_t _315 = 0; // x
    _jump1750:; // Begin body of loop
    _a3_double _316;
    // Computing bound for A
    _316.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump1751;
    fail_assertion("non-positive loop bound");
    _jump1751:;
    // Computing bound for B
    _316.d1 = _244.d0;
    if (_244.d0 > 0) 
    goto _jump1752;
    fail_assertion("non-positive loop bound");
    _jump1752:;
    // Computing bound for C
    _316.d2 = _313;
    if (_313 > 0) 
    goto _jump1753;
    fail_assertion("non-positive loop bound");
    _jump1753:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= p.d0;
    _317 *= _244.d0;
    _317 *= _313;
    _317 *= sizeof(double);
    _316.data = jpl_alloc(_317);
    int64_t _318 = 0; // C
    int64_t _319 = 0; // B
    int64_t _320 = 0; // A
    _jump1754:; // Begin body of loop
    double _321 = 63.0;
    int64_t _322 = 0;
    _322 *= _316.d0;
    _322 += _320;
    _322 *= _316.d1;
    _322 += _319;
    _322 *= _316.d2;
    _322 += _318;
    _316.data[_322] = _321;
    _318++;
    if (_318 < _313)
    goto _jump1754;
    _318 = 0;
    _319++;
    if (_319 < _244.d0)
    goto _jump1754;
    _319 = 0;
    _320++;
    if (_320 < p.d0)
    goto _jump1754;
    // End body of loop
    int64_t _323 = 0;
    _323 *= _310.d0;
    _323 += _315;
    _323 *= _310.d1;
    _323 += _314;
    _323 *= _310.d2;
    _323 += _313;
    _310.data[_323] = _316;
    _313++;
    if (_313 < _311)
    goto _jump1750;
    _313 = 0;
    _314++;
    if (_314 < p.d2)
    goto _jump1750;
    _314 = 0;
    _315++;
    if (_315 < i)
    goto _jump1750;
    // End body of loop
    g _324 = l();
    bool _325 = _324.a;
    int64_t _326;
    if (!_325)
    goto _jump1755;
    _326 = _244.d2;
    goto _jump1756;
    _jump1755:;
    _326 = p.d1;
    _jump1756:;
    _a3_double _327;
    // Computing bound for x
    _327.d0 = _244.d1;
    if (_244.d1 > 0) 
    goto _jump1757;
    fail_assertion("non-positive loop bound");
    _jump1757:;
    // Computing bound for y
    _327.d1 = p.d2;
    if (p.d2 > 0) 
    goto _jump1758;
    fail_assertion("non-positive loop bound");
    _jump1758:;
    // Computing bound for z
    _327.d2 = e;
    if (e > 0) 
    goto _jump1759;
    fail_assertion("non-positive loop bound");
    _jump1759:;
    // Computing total size of heap memory to allocate
    int64_t _328 = 1;
    _328 *= _244.d1;
    _328 *= p.d2;
    _328 *= e;
    _328 *= sizeof(double);
    _327.data = jpl_alloc(_328);
    int64_t _329 = 0; // z
    int64_t _330 = 0; // y
    int64_t _331 = 0; // x
    _jump1760:; // Begin body of loop
    double _332 = 61.0;
    int64_t _333 = 0;
    _333 *= _327.d0;
    _333 += _331;
    _333 *= _327.d1;
    _333 += _330;
    _333 *= _327.d2;
    _333 += _329;
    _327.data[_333] = _332;
    _329++;
    if (_329 < e)
    goto _jump1760;
    _329 = 0;
    _330++;
    if (_330 < p.d2)
    goto _jump1760;
    _330 = 0;
    _331++;
    if (_331 < _244.d1)
    goto _jump1760;
    // End body of loop
    if (_244.d2 >= 0)
    goto _jump1761;
    fail_assertion("negative array index");
    _jump1761:;
    if (_244.d2 < _327.d0)
    goto _jump1762;
    fail_assertion("index too large");
    _jump1762:;
    if (p.d1 >= 0)
    goto _jump1763;
    fail_assertion("negative array index");
    _jump1763:;
    if (p.d1 < _327.d1)
    goto _jump1764;
    fail_assertion("index too large");
    _jump1764:;
    if (p.d1 >= 0)
    goto _jump1765;
    fail_assertion("negative array index");
    _jump1765:;
    if (p.d1 < _327.d2)
    goto _jump1766;
    fail_assertion("index too large");
    _jump1766:;
    int64_t _334 = 0;
    _334 *= _327.d0;
    _334 += _244.d2;
    _334 *= _327.d1;
    _334 += p.d1;
    _334 *= _327.d2;
    _334 += p.d1;
    double _335 = _327.data[_334];
    k _336 = { _310, _326, _335 };
    _309 = _336;
    goto _jump1767;
    _jump1746:;
    bool _337 = n(o, p);
    k _338;
    if (!_337)
    goto _jump1768;
    if (_244.d0 >= 0)
    goto _jump1769;
    fail_assertion("negative array index");
    _jump1769:;
    if (_244.d0 < p.d0)
    goto _jump1770;
    fail_assertion("index too large");
    _jump1770:;
    if (_244.d0 >= 0)
    goto _jump1771;
    fail_assertion("negative array index");
    _jump1771:;
    if (_244.d0 < p.d1)
    goto _jump1772;
    fail_assertion("index too large");
    _jump1772:;
    if (p.d0 >= 0)
    goto _jump1773;
    fail_assertion("negative array index");
    _jump1773:;
    if (p.d0 < p.d2)
    goto _jump1774;
    fail_assertion("index too large");
    _jump1774:;
    int64_t _339 = 0;
    _339 *= p.d0;
    _339 += _244.d0;
    _339 *= p.d1;
    _339 += _244.d0;
    _339 *= p.d2;
    _339 += p.d0;
    k _340 = p.data[_339];
    _338 = _340;
    goto _jump1775;
    _jump1768:;
    int64_t _341 = -p.d2;
    int64_t _342;
    // Computing bound for x
    if (p.d1 > 0) 
    goto _jump1776;
    fail_assertion("non-positive loop bound");
    _jump1776:;
    _342 = 0;
    int64_t _343 = 0; // x
    _jump1777:; // Begin body of loop
    _342 += _343;
    _343++;
    if (_343 < p.d1)
    goto _jump1777;
    // End body of loop
    if (_341 >= 0)
    goto _jump1778;
    fail_assertion("negative array index");
    _jump1778:;
    if (_341 < p.d0)
    goto _jump1779;
    fail_assertion("index too large");
    _jump1779:;
    if (i >= 0)
    goto _jump1780;
    fail_assertion("negative array index");
    _jump1780:;
    if (i < p.d1)
    goto _jump1781;
    fail_assertion("index too large");
    _jump1781:;
    if (_342 >= 0)
    goto _jump1782;
    fail_assertion("negative array index");
    _jump1782:;
    if (_342 < p.d2)
    goto _jump1783;
    fail_assertion("index too large");
    _jump1783:;
    int64_t _344 = 0;
    _344 *= p.d0;
    _344 += _341;
    _344 *= p.d1;
    _344 += i;
    _344 *= p.d2;
    _344 += _342;
    k _345 = p.data[_344];
    _338 = _345;
    _jump1775:;
    _309 = _338;
    _jump1767:;
    _278 = _309;
    _jump1740:;
    double _346 = _278.c;
    double _347;
    // Computing bound for x
    int64_t _348;
    // Computing bound for x
    if (_244.d1 > 0) 
    goto _jump1784;
    fail_assertion("non-positive loop bound");
    _jump1784:;
    // Computing bound for y
    if (p.d2 > 0) 
    goto _jump1785;
    fail_assertion("non-positive loop bound");
    _jump1785:;
    _348 = 0;
    int64_t _349 = 0; // y
    int64_t _350 = 0; // x
    _jump1786:; // Begin body of loop
    _348 += e;
    _349++;
    if (_349 < p.d2)
    goto _jump1786;
    _349 = 0;
    _350++;
    if (_350 < _244.d1)
    goto _jump1786;
    // End body of loop
    if (_348 > 0) 
    goto _jump1787;
    fail_assertion("non-positive loop bound");
    _jump1787:;
    _347 = 0;
    int64_t _351 = 0; // x
    _jump1788:; // Begin body of loop
    _347 += o;
    _351++;
    if (_351 < _348)
    goto _jump1788;
    // End body of loop
    bool _352 = _346 > _347;
    return _352;
    int64_t _353 = p.d2 / _244.d1;
    if (_353 >= 0)
    goto _jump1789;
    fail_assertion("negative array index");
    _jump1789:;
    if (_353 < c.d0)
    goto _jump1790;
    fail_assertion("index too large");
    _jump1790:;
    if (_244.d2 >= 0)
    goto _jump1791;
    fail_assertion("negative array index");
    _jump1791:;
    if (_244.d2 < c.d1)
    goto _jump1792;
    fail_assertion("index too large");
    _jump1792:;
    int64_t _354 = 0;
    _354 *= c.d0;
    _354 += _353;
    _354 *= c.d1;
    _354 += _244.d2;
    bool _355 = c.data[_354];
    return _355;
}

void_t o() {
    bool _0;
    if (!a)
    goto _jump1793;
    _0 = a;
    goto _jump1794;
    _jump1793:;
    _0 = a;
    _jump1794:;
    void_t _1;
    if (!_0)
    goto _jump1795;
    double _2 = 14.0;
    double _3 = -_2;
    double _4;
    // Computing bound for p
    int64_t _5 = 371;
    if (_5 > 0) 
    goto _jump1796;
    fail_assertion("non-positive loop bound");
    _jump1796:;
    // Computing bound for q
    g _6 = l();
    int64_t _7 = _6.b;
    if (_7 > 0) 
    goto _jump1797;
    fail_assertion("non-positive loop bound");
    _jump1797:;
    _4 = 0;
    int64_t _8 = 0; // q
    int64_t _9 = 0; // p
    _jump1798:; // Begin body of loop
    double _10 = 96.0;
    double _11 = -_10;
    _4 += _11;
    _8++;
    if (_8 < _7)
    goto _jump1798;
    _8 = 0;
    _9++;
    if (_9 < _5)
    goto _jump1798;
    // End body of loop
    bool _12 = _3 < _4;
    _a2_void_t _13;
    if (!_12)
    goto _jump1799;
    _a2_void_t _14;
    // Computing bound for p
    _14.d0 = d;
    if (d > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for q
    _14.d1 = i;
    if (i > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= d;
    _15 *= i;
    _15 *= sizeof(void_t);
    _14.data = jpl_alloc(_15);
    int64_t _16 = 0; // q
    int64_t _17 = 0; // p
    _jump1802:; // Begin body of loop
    bool _18 = e > e;
    bool _19 = !_18;
    void_t _20;
    if (!_19)
    goto _jump1803;
    _a2_void_t _21;
    // Computing bound for r
    _21.d0 = d;
    if (d > 0) 
    goto _jump1804;
    fail_assertion("non-positive loop bound");
    _jump1804:;
    // Computing bound for s
    _21.d1 = d;
    if (d > 0) 
    goto _jump1805;
    fail_assertion("non-positive loop bound");
    _jump1805:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= d;
    _22 *= d;
    _22 *= sizeof(void_t);
    _21.data = jpl_alloc(_22);
    int64_t _23 = 0; // s
    int64_t _24 = 0; // r
    _jump1806:; // Begin body of loop
    void_t _25 = o();
    int64_t _26 = 0;
    _26 *= _21.d0;
    _26 += _24;
    _26 *= _21.d1;
    _26 += _23;
    _21.data[_26] = _25;
    _23++;
    if (_23 < d)
    goto _jump1806;
    _23 = 0;
    _24++;
    if (_24 < d)
    goto _jump1806;
    // End body of loop
    int64_t _27 = 766;
    int64_t _28 = 788;
    int64_t _29 = _27 - _28;
    if (_16 >= 0)
    goto _jump1807;
    fail_assertion("negative array index");
    _jump1807:;
    if (_16 < _21.d0)
    goto _jump1808;
    fail_assertion("index too large");
    _jump1808:;
    if (_29 >= 0)
    goto _jump1809;
    fail_assertion("negative array index");
    _jump1809:;
    if (_29 < _21.d1)
    goto _jump1810;
    fail_assertion("index too large");
    _jump1810:;
    int64_t _30 = 0;
    _30 *= _21.d0;
    _30 += _16;
    _30 *= _21.d1;
    _30 += _29;
    void_t _31 = _21.data[_30];
    _20 = _31;
    goto _jump1811;
    _jump1803:;
    rgba _32 = j();
    void_t _33 = h(_16, _32, _17);
    _20 = _33;
    _jump1811:;
    int64_t _34 = 0;
    _34 *= _14.d0;
    _34 += _17;
    _34 *= _14.d1;
    _34 += _16;
    _14.data[_34] = _20;
    _16++;
    if (_16 < i)
    goto _jump1802;
    _16 = 0;
    _17++;
    if (_17 < d)
    goto _jump1802;
    // End body of loop
    _13 = _14;
    goto _jump1812;
    _jump1799:;
    int64_t _35;
    // Computing bound for p
    if (e > 0) 
    goto _jump1813;
    fail_assertion("non-positive loop bound");
    _jump1813:;
    _35 = 0;
    int64_t _36 = 0; // p
    _jump1814:; // Begin body of loop
    _35 += i;
    _36++;
    if (_36 < e)
    goto _jump1814;
    // End body of loop
    bool _37 = _35 >= i;
    if (i >= 0)
    goto _jump1815;
    fail_assertion("negative array index");
    _jump1815:;
    if (i < c.d0)
    goto _jump1816;
    fail_assertion("index too large");
    _jump1816:;
    if (e >= 0)
    goto _jump1817;
    fail_assertion("negative array index");
    _jump1817:;
    if (e < c.d1)
    goto _jump1818;
    fail_assertion("index too large");
    _jump1818:;
    int64_t _38 = 0;
    _38 *= c.d0;
    _38 += i;
    _38 *= c.d1;
    _38 += e;
    bool _39 = c.data[_38];
    bool _40;
    if (!_39)
    goto _jump1819;
    _40 = a;
    goto _jump1820;
    _jump1819:;
    bool _41 = false;
    bool _42 = _41 != a;
    _40 = _42;
    _jump1820:;
    bool _43 = _37 != _40;
    _a2_void_t _44;
    if (!_43)
    goto _jump1821;
    _a2_void_t _45;
    // Computing bound for p
    _45.d0 = i;
    if (i > 0) 
    goto _jump1822;
    fail_assertion("non-positive loop bound");
    _jump1822:;
    // Computing bound for q
    _45.d1 = d;
    if (d > 0) 
    goto _jump1823;
    fail_assertion("non-positive loop bound");
    _jump1823:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= i;
    _46 *= d;
    _46 *= sizeof(void_t);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // q
    int64_t _48 = 0; // p
    _jump1824:; // Begin body of loop
    void_t _49 = o();
    int64_t _50 = 0;
    _50 *= _45.d0;
    _50 += _48;
    _50 *= _45.d1;
    _50 += _47;
    _45.data[_50] = _49;
    _47++;
    if (_47 < d)
    goto _jump1824;
    _47 = 0;
    _48++;
    if (_48 < i)
    goto _jump1824;
    // End body of loop
    _44 = _45;
    goto _jump1825;
    _jump1821:;
    _a2_void_t _51;
    // Computing bound for p
    int64_t _52 = -d;
    int64_t _53 = _52 % i;
    _51.d0 = _53;
    if (_53 > 0) 
    goto _jump1826;
    fail_assertion("non-positive loop bound");
    _jump1826:;
    // Computing bound for q
    int64_t _54 = 370;
    _51.d1 = _54;
    if (_54 > 0) 
    goto _jump1827;
    fail_assertion("non-positive loop bound");
    _jump1827:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= _53;
    _55 *= _54;
    _55 *= sizeof(void_t);
    _51.data = jpl_alloc(_55);
    int64_t _56 = 0; // q
    int64_t _57 = 0; // p
    _jump1828:; // Begin body of loop
    bool _58 = true;
    bool _59 = !_58;
    void_t _60;
    if (!_59)
    goto _jump1829;
    rgba _61 = j();
    int64_t _62 = 702;
    void_t _63 = h(_57, _61, _62);
    _60 = _63;
    goto _jump1830;
    _jump1829:;
    void_t _64 = o();
    _60 = _64;
    _jump1830:;
    int64_t _65 = 0;
    _65 *= _51.d0;
    _65 += _57;
    _65 *= _51.d1;
    _65 += _56;
    _51.data[_65] = _60;
    _56++;
    if (_56 < _54)
    goto _jump1828;
    _56 = 0;
    _57++;
    if (_57 < _53)
    goto _jump1828;
    // End body of loop
    _44 = _51;
    _jump1825:;
    _13 = _44;
    _jump1812:;
    _a3__a3_double _66;
    // Computing bound for p
    int64_t _67 = 358;
    int64_t _68 = 277;
    int64_t _69 = _67 - _68;
    int64_t _70 = -_69;
    _66.d0 = _70;
    if (_70 > 0) 
    goto _jump1831;
    fail_assertion("non-positive loop bound");
    _jump1831:;
    // Computing bound for q
    int64_t _71;
    // Computing bound for p
    if (i > 0) 
    goto _jump1832;
    fail_assertion("non-positive loop bound");
    _jump1832:;
    _71 = 0;
    int64_t _72 = 0; // p
    _jump1833:; // Begin body of loop
    _71 += d;
    _72++;
    if (_72 < i)
    goto _jump1833;
    // End body of loop
    int64_t _73 = -_71;
    _66.d1 = _73;
    if (_73 > 0) 
    goto _jump1834;
    fail_assertion("non-positive loop bound");
    _jump1834:;
    // Computing bound for r
    int64_t _74 = e + i;
    _66.d2 = _74;
    if (_74 > 0) 
    goto _jump1835;
    fail_assertion("non-positive loop bound");
    _jump1835:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= _70;
    _75 *= _73;
    _75 *= _74;
    _75 *= sizeof(_a3_double);
    _66.data = jpl_alloc(_75);
    int64_t _76 = 0; // r
    int64_t _77 = 0; // q
    int64_t _78 = 0; // p
    _jump1836:; // Begin body of loop
    _a3_double _79;
    // Computing bound for s
    _79.d0 = e;
    if (e > 0) 
    goto _jump1837;
    fail_assertion("non-positive loop bound");
    _jump1837:;
    // Computing bound for t
    int64_t _80 = -e;
    _79.d1 = _80;
    if (_80 > 0) 
    goto _jump1838;
    fail_assertion("non-positive loop bound");
    _jump1838:;
    // Computing bound for u
    _79.d2 = _78;
    if (_78 > 0) 
    goto _jump1839;
    fail_assertion("non-positive loop bound");
    _jump1839:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= e;
    _81 *= _80;
    _81 *= _78;
    _81 *= sizeof(double);
    _79.data = jpl_alloc(_81);
    int64_t _82 = 0; // u
    int64_t _83 = 0; // t
    int64_t _84 = 0; // s
    _jump1840:; // Begin body of loop
    double _85 = 86.0;
    int64_t _86 = 0;
    _86 *= _79.d0;
    _86 += _84;
    _86 *= _79.d1;
    _86 += _83;
    _86 *= _79.d2;
    _86 += _82;
    _79.data[_86] = _85;
    _82++;
    if (_82 < _78)
    goto _jump1840;
    _82 = 0;
    _83++;
    if (_83 < _80)
    goto _jump1840;
    _83 = 0;
    _84++;
    if (_84 < e)
    goto _jump1840;
    // End body of loop
    int64_t _87 = 0;
    _87 *= _66.d0;
    _87 += _78;
    _87 *= _66.d1;
    _87 += _77;
    _87 *= _66.d2;
    _87 += _76;
    _66.data[_87] = _79;
    _76++;
    if (_76 < _74)
    goto _jump1836;
    _76 = 0;
    _77++;
    if (_77 < _73)
    goto _jump1836;
    _77 = 0;
    _78++;
    if (_78 < _70)
    goto _jump1836;
    // End body of loop
    g _88 = l();
    int64_t _89 = _88.b;
    int64_t _90 = -e;
    int64_t _91 = _90 * d;
    int64_t _92 = _89 - _91;
    double _93 = 83.0;
    k _94 = { _66, _92, _93 };
    int64_t _95 = _94.b;
    int64_t _96 = 698;
    int64_t _97 = 18;
    bool _98 = _96 <= _97;
    bool _99 = !_98;
    int64_t _100;
    if (!_99)
    goto _jump1841;
    g _101 = l();
    int64_t _102 = _101.b;
    _100 = _102;
    goto _jump1842;
    _jump1841:;
    _100 = e;
    _jump1842:;
    _a1_int64_t _103;
    _103.d0 = 2;
    _103.data = jpl_alloc(sizeof(int64_t) * 2);
    _103.data[0] = _100;
    _103.data[1] = d;
    bool _105 = true;
    bool _104 = _105;
    if (0 == _105)
    goto _jump1843;
    _104 = a;
    _jump1843:;
    g _106 = { _104, i };
    int64_t _107 = _106.b;
    if (_107 >= 0)
    goto _jump1844;
    fail_assertion("negative array index");
    _jump1844:;
    if (_107 < _103.d0)
    goto _jump1845;
    fail_assertion("index too large");
    _jump1845:;
    int64_t _108 = 0;
    _108 *= _103.d0;
    _108 += _107;
    int64_t _109 = _103.data[_108];
    if (_95 >= 0)
    goto _jump1846;
    fail_assertion("negative array index");
    _jump1846:;
    if (_95 < _13.d0)
    goto _jump1847;
    fail_assertion("index too large");
    _jump1847:;
    if (_109 >= 0)
    goto _jump1848;
    fail_assertion("negative array index");
    _jump1848:;
    if (_109 < _13.d1)
    goto _jump1849;
    fail_assertion("index too large");
    _jump1849:;
    int64_t _110 = 0;
    _110 *= _13.d0;
    _110 += _95;
    _110 *= _13.d1;
    _110 += _109;
    void_t _111 = _13.data[_110];
    _1 = _111;
    goto _jump1850;
    _jump1795:;
    void_t _112 = o();
    _1 = _112;
    _jump1850:;
    return _1;
    bool _113 = d > e;
    int64_t _114;
    if (!_113)
    goto _jump1851;
    _114 = e;
    goto _jump1852;
    _jump1851:;
    _114 = e;
    _jump1852:;
    int64_t _115 = 994;
    int64_t _116 = _114 - _115;
    bool _117 = false;
    bool _118 = !_117;
    int64_t _119;
    if (!_118)
    goto _jump1853;
    bool _120 = false;
    bool _121 = true;
    int64_t _122;
    if (!_121)
    goto _jump1854;
    _122 = d;
    goto _jump1855;
    _jump1854:;
    _122 = i;
    _jump1855:;
    g _123 = { _120, _122 };
    int64_t _124 = _123.b;
    int64_t _125 = d / _124;
    _119 = _125;
    goto _jump1856;
    _jump1853:;
    _119 = i;
    _jump1856:;
    int64_t _126 = -_119;
    _a1_int64_t _127;
    _127.d0 = 3;
    _127.data = jpl_alloc(sizeof(int64_t) * 3);
    _127.data[0] = i;
    _127.data[1] = _116;
    _127.data[2] = _126;
    _a2_g _128;
    // Computing bound for q
    int64_t _129;
    // Computing bound for q
    int64_t _130 = i % e;
    if (_130 > 0) 
    goto _jump1857;
    fail_assertion("non-positive loop bound");
    _jump1857:;
    _129 = 0;
    int64_t _131 = 0; // q
    _jump1858:; // Begin body of loop
    int64_t _132 = 459;
    _129 += _132;
    _131++;
    if (_131 < _130)
    goto _jump1858;
    // End body of loop
    _128.d0 = _129;
    if (_129 > 0) 
    goto _jump1859;
    fail_assertion("non-positive loop bound");
    _jump1859:;
    // Computing bound for r
    int64_t _133 = -e;
    _128.d1 = _133;
    if (_133 > 0) 
    goto _jump1860;
    fail_assertion("non-positive loop bound");
    _jump1860:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= _129;
    _134 *= _133;
    _134 *= sizeof(g);
    _128.data = jpl_alloc(_134);
    int64_t _135 = 0; // r
    int64_t _136 = 0; // q
    _jump1861:; // Begin body of loop
    g _137 = { a, _135 };
    int64_t _138 = 0;
    _138 *= _128.d0;
    _138 += _136;
    _138 *= _128.d1;
    _138 += _135;
    _128.data[_138] = _137;
    _135++;
    if (_135 < _133)
    goto _jump1861;
    _135 = 0;
    _136++;
    if (_136 < _129)
    goto _jump1861;
    // End body of loop
    if (d >= 0)
    goto _jump1862;
    fail_assertion("negative array index");
    _jump1862:;
    if (d < _128.d0)
    goto _jump1863;
    fail_assertion("index too large");
    _jump1863:;
    if (i >= 0)
    goto _jump1864;
    fail_assertion("negative array index");
    _jump1864:;
    if (i < _128.d1)
    goto _jump1865;
    fail_assertion("index too large");
    _jump1865:;
    int64_t _139 = 0;
    _139 *= _128.d0;
    _139 += d;
    _139 *= _128.d1;
    _139 += i;
    g _140 = _128.data[_139];
    int64_t _141;
    // Computing bound for q
    if (e > 0) 
    goto _jump1866;
    fail_assertion("non-positive loop bound");
    _jump1866:;
    _141 = 0;
    int64_t _142 = 0; // q
    _jump1867:; // Begin body of loop
    _141 += e;
    _142++;
    if (_142 < e)
    goto _jump1867;
    // End body of loop
    bool _143 = e < _141;
    g _144 = l();
    bool _145 = _144.a;
    int64_t _146;
    if (!_145)
    goto _jump1868;
    int64_t _147;
    // Computing bound for q
    if (d > 0) 
    goto _jump1869;
    fail_assertion("non-positive loop bound");
    _jump1869:;
    // Computing bound for r
    int64_t _148 = 825;
    if (_148 > 0) 
    goto _jump1870;
    fail_assertion("non-positive loop bound");
    _jump1870:;
    // Computing bound for s
    if (e > 0) 
    goto _jump1871;
    fail_assertion("non-positive loop bound");
    _jump1871:;
    _147 = 0;
    int64_t _149 = 0; // s
    int64_t _150 = 0; // r
    int64_t _151 = 0; // q
    _jump1872:; // Begin body of loop
    _147 += _151;
    _149++;
    if (_149 < e)
    goto _jump1872;
    _149 = 0;
    _150++;
    if (_150 < _148)
    goto _jump1872;
    _150 = 0;
    _151++;
    if (_151 < d)
    goto _jump1872;
    // End body of loop
    _146 = _147;
    goto _jump1873;
    _jump1868:;
    _146 = e;
    _jump1873:;
    int64_t _152 = -_146;
    g _153 = { _143, _152 };
    g _154 = l();
    _a1_g _155;
    _155.d0 = 3;
    _155.data = jpl_alloc(sizeof(g) * 3);
    _155.data[0] = _140;
    _155.data[1] = _153;
    _155.data[2] = _154;
    if (i >= 0)
    goto _jump1874;
    fail_assertion("negative array index");
    _jump1874:;
    if (i < _155.d0)
    goto _jump1875;
    fail_assertion("index too large");
    _jump1875:;
    int64_t _156 = 0;
    _156 *= _155.d0;
    _156 += i;
    g _157 = _155.data[_156];
    bool _158 = _157.a;
    _a2__a3__a2_bool _159;
    // Computing bound for r
    _159.d0 = d;
    if (d > 0) 
    goto _jump1876;
    fail_assertion("non-positive loop bound");
    _jump1876:;
    // Computing bound for s
    g _160 = l();
    bool _161 = _160.a;
    g _162 = { _161, i };
    int64_t _163 = _162.b;
    _159.d1 = _163;
    if (_163 > 0) 
    goto _jump1877;
    fail_assertion("non-positive loop bound");
    _jump1877:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= d;
    _164 *= _163;
    _164 *= sizeof(_a3__a2_bool);
    _159.data = jpl_alloc(_164);
    int64_t _165 = 0; // s
    int64_t _166 = 0; // r
    _jump1878:; // Begin body of loop
    _a3__a2_bool _167;
    // Computing bound for t
    int64_t _168;
    // Computing bound for t
    g _169 = l();
    int64_t _170 = _169.b;
    if (_170 > 0) 
    goto _jump1879;
    fail_assertion("non-positive loop bound");
    _jump1879:;
    // Computing bound for u
    int64_t _171;
    // Computing bound for t
    if (_165 > 0) 
    goto _jump1880;
    fail_assertion("non-positive loop bound");
    _jump1880:;
    // Computing bound for u
    if (e > 0) 
    goto _jump1881;
    fail_assertion("non-positive loop bound");
    _jump1881:;
    _171 = 0;
    int64_t _172 = 0; // u
    int64_t _173 = 0; // t
    _jump1882:; // Begin body of loop
    _171 += e;
    _172++;
    if (_172 < e)
    goto _jump1882;
    _172 = 0;
    _173++;
    if (_173 < _165)
    goto _jump1882;
    // End body of loop
    if (_171 > 0) 
    goto _jump1883;
    fail_assertion("non-positive loop bound");
    _jump1883:;
    _168 = 0;
    int64_t _174 = 0; // u
    int64_t _175 = 0; // t
    _jump1884:; // Begin body of loop
    int64_t _176 = i * _174;
    _168 += _176;
    _174++;
    if (_174 < _171)
    goto _jump1884;
    _174 = 0;
    _175++;
    if (_175 < _170)
    goto _jump1884;
    // End body of loop
    _167.d0 = _168;
    if (_168 > 0) 
    goto _jump1885;
    fail_assertion("non-positive loop bound");
    _jump1885:;
    // Computing bound for u
    _167.d1 = d;
    if (d > 0) 
    goto _jump1886;
    fail_assertion("non-positive loop bound");
    _jump1886:;
    // Computing bound for v
    _167.d2 = _165;
    if (_165 > 0) 
    goto _jump1887;
    fail_assertion("non-positive loop bound");
    _jump1887:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _168;
    _177 *= d;
    _177 *= _165;
    _177 *= sizeof(_a2_bool);
    _167.data = jpl_alloc(_177);
    int64_t _178 = 0; // v
    int64_t _179 = 0; // u
    int64_t _180 = 0; // t
    _jump1888:; // Begin body of loop
    _a2_bool _181;
    // Computing bound for w
    g _182 = l();
    int64_t _183 = _182.b;
    _181.d0 = _183;
    if (_183 > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    // Computing bound for x
    _181.d1 = e;
    if (e > 0) 
    goto _jump1890;
    fail_assertion("non-positive loop bound");
    _jump1890:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= _183;
    _184 *= e;
    _184 *= sizeof(bool);
    _181.data = jpl_alloc(_184);
    int64_t _185 = 0; // x
    int64_t _186 = 0; // w
    _jump1891:; // Begin body of loop
    bool _187 = false;
    int64_t _188 = 0;
    _188 *= _181.d0;
    _188 += _186;
    _188 *= _181.d1;
    _188 += _185;
    _181.data[_188] = _187;
    _185++;
    if (_185 < e)
    goto _jump1891;
    _185 = 0;
    _186++;
    if (_186 < _183)
    goto _jump1891;
    // End body of loop
    int64_t _189 = 0;
    _189 *= _167.d0;
    _189 += _180;
    _189 *= _167.d1;
    _189 += _179;
    _189 *= _167.d2;
    _189 += _178;
    _167.data[_189] = _181;
    _178++;
    if (_178 < _165)
    goto _jump1888;
    _178 = 0;
    _179++;
    if (_179 < d)
    goto _jump1888;
    _179 = 0;
    _180++;
    if (_180 < _168)
    goto _jump1888;
    // End body of loop
    int64_t _190 = 0;
    _190 *= _159.d0;
    _190 += _166;
    _190 *= _159.d1;
    _190 += _165;
    _159.data[_190] = _167;
    _165++;
    if (_165 < _163)
    goto _jump1878;
    _165 = 0;
    _166++;
    if (_166 < d)
    goto _jump1878;
    // End body of loop
    int64_t _191 = i / d;
    if (_191 >= 0)
    goto _jump1892;
    fail_assertion("negative array index");
    _jump1892:;
    if (_191 < _159.d0)
    goto _jump1893;
    fail_assertion("index too large");
    _jump1893:;
    if (d >= 0)
    goto _jump1894;
    fail_assertion("negative array index");
    _jump1894:;
    if (d < _159.d1)
    goto _jump1895;
    fail_assertion("index too large");
    _jump1895:;
    int64_t _192 = 0;
    _192 *= _159.d0;
    _192 += _191;
    _192 *= _159.d1;
    _192 += d;
    _a3__a2_bool _193 = _159.data[_192];
    g _194 = l();
    int64_t _195 = _194.b;
    _a1__a2_int64_t _196;
    // Computing bound for r
    int64_t _197;
    // Computing bound for r
    if (i > 0) 
    goto _jump1896;
    fail_assertion("non-positive loop bound");
    _jump1896:;
    // Computing bound for s
    int64_t _198 = 670;
    if (_198 > 0) 
    goto _jump1897;
    fail_assertion("non-positive loop bound");
    _jump1897:;
    // Computing bound for t
    int64_t _199;
    // Computing bound for r
    if (e > 0) 
    goto _jump1898;
    fail_assertion("non-positive loop bound");
    _jump1898:;
    // Computing bound for s
    int64_t _200 = 798;
    if (_200 > 0) 
    goto _jump1899;
    fail_assertion("non-positive loop bound");
    _jump1899:;
    // Computing bound for t
    int64_t _201 = 633;
    if (_201 > 0) 
    goto _jump1900;
    fail_assertion("non-positive loop bound");
    _jump1900:;
    _199 = 0;
    int64_t _202 = 0; // t
    int64_t _203 = 0; // s
    int64_t _204 = 0; // r
    _jump1901:; // Begin body of loop
    _199 += e;
    _202++;
    if (_202 < _201)
    goto _jump1901;
    _202 = 0;
    _203++;
    if (_203 < _200)
    goto _jump1901;
    _203 = 0;
    _204++;
    if (_204 < e)
    goto _jump1901;
    // End body of loop
    if (_199 > 0) 
    goto _jump1902;
    fail_assertion("non-positive loop bound");
    _jump1902:;
    _197 = 0;
    int64_t _205 = 0; // t
    int64_t _206 = 0; // s
    int64_t _207 = 0; // r
    _jump1903:; // Begin body of loop
    _197 += d;
    _205++;
    if (_205 < _199)
    goto _jump1903;
    _205 = 0;
    _206++;
    if (_206 < _198)
    goto _jump1903;
    _206 = 0;
    _207++;
    if (_207 < i)
    goto _jump1903;
    // End body of loop
    _196.d0 = _197;
    if (_197 > 0) 
    goto _jump1904;
    fail_assertion("non-positive loop bound");
    _jump1904:;
    // Computing total size of heap memory to allocate
    int64_t _208 = 1;
    _208 *= _197;
    _208 *= sizeof(_a2_int64_t);
    _196.data = jpl_alloc(_208);
    int64_t _209 = 0; // r
    _jump1905:; // Begin body of loop
    _a2_int64_t _210;
    // Computing bound for s
    _210.d0 = _209;
    if (_209 > 0) 
    goto _jump1906;
    fail_assertion("non-positive loop bound");
    _jump1906:;
    // Computing bound for t
    _210.d1 = i;
    if (i > 0) 
    goto _jump1907;
    fail_assertion("non-positive loop bound");
    _jump1907:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= _209;
    _211 *= i;
    _211 *= sizeof(int64_t);
    _210.data = jpl_alloc(_211);
    int64_t _212 = 0; // t
    int64_t _213 = 0; // s
    _jump1908:; // Begin body of loop
    int64_t _214 = 0;
    _214 *= _210.d0;
    _214 += _213;
    _214 *= _210.d1;
    _214 += _212;
    _210.data[_214] = e;
    _212++;
    if (_212 < i)
    goto _jump1908;
    _212 = 0;
    _213++;
    if (_213 < _209)
    goto _jump1908;
    // End body of loop
    int64_t _215 = 0;
    _215 *= _196.d0;
    _215 += _209;
    _196.data[_215] = _210;
    _209++;
    if (_209 < _197)
    goto _jump1905;
    // End body of loop
    if (d >= 0)
    goto _jump1909;
    fail_assertion("negative array index");
    _jump1909:;
    if (d < _196.d0)
    goto _jump1910;
    fail_assertion("index too large");
    _jump1910:;
    int64_t _216 = 0;
    _216 *= _196.d0;
    _216 += d;
    _a2_int64_t _217 = _196.data[_216];
    int64_t _218;
    // Computing bound for r
    int64_t _219 = -e;
    int64_t _220 = -_219;
    if (_220 > 0) 
    goto _jump1911;
    fail_assertion("non-positive loop bound");
    _jump1911:;
    // Computing bound for s
    int64_t _221;
    // Computing bound for r
    _a1_int64_t _222;
    if (!a)
    goto _jump1912;
    _222 = _127;
    goto _jump1913;
    _jump1912:;
    _222 = _127;
    _jump1913:;
    if (i >= 0)
    goto _jump1914;
    fail_assertion("negative array index");
    _jump1914:;
    if (i < _222.d0)
    goto _jump1915;
    fail_assertion("index too large");
    _jump1915:;
    int64_t _223 = 0;
    _223 *= _222.d0;
    _223 += i;
    int64_t _224 = _222.data[_223];
    if (_224 > 0) 
    goto _jump1916;
    fail_assertion("non-positive loop bound");
    _jump1916:;
    // Computing bound for s
    if (i > 0) 
    goto _jump1917;
    fail_assertion("non-positive loop bound");
    _jump1917:;
    _221 = 0;
    int64_t _225 = 0; // s
    int64_t _226 = 0; // r
    _jump1918:; // Begin body of loop
    _221 += i;
    _225++;
    if (_225 < i)
    goto _jump1918;
    _225 = 0;
    _226++;
    if (_226 < _224)
    goto _jump1918;
    // End body of loop
    if (_221 > 0) 
    goto _jump1919;
    fail_assertion("non-positive loop bound");
    _jump1919:;
    // Computing bound for t
    int64_t _227;
    // Computing bound for r
    g _228 = l();
    int64_t _229 = _228.b;
    if (_229 > 0) 
    goto _jump1920;
    fail_assertion("non-positive loop bound");
    _jump1920:;
    // Computing bound for s
    g _230 = l();
    int64_t _231 = _230.b;
    if (_231 > 0) 
    goto _jump1921;
    fail_assertion("non-positive loop bound");
    _jump1921:;
    _227 = 0;
    int64_t _232 = 0; // s
    int64_t _233 = 0; // r
    _jump1922:; // Begin body of loop
    g _234 = l();
    int64_t _235 = _234.b;
    _227 += _235;
    _232++;
    if (_232 < _231)
    goto _jump1922;
    _232 = 0;
    _233++;
    if (_233 < _229)
    goto _jump1922;
    // End body of loop
    int64_t _236 = 189;
    if (_236 >= 0)
    goto _jump1923;
    fail_assertion("negative array index");
    _jump1923:;
    if (_236 < m.d0)
    goto _jump1924;
    fail_assertion("index too large");
    _jump1924:;
    if (d >= 0)
    goto _jump1925;
    fail_assertion("negative array index");
    _jump1925:;
    if (d < m.d1)
    goto _jump1926;
    fail_assertion("index too large");
    _jump1926:;
    int64_t _237 = 0;
    _237 *= m.d0;
    _237 += _236;
    _237 *= m.d1;
    _237 += d;
    bool _238 = m.data[_237];
    int64_t _239;
    if (!_238)
    goto _jump1927;
    g _240 = l();
    int64_t _241 = _240.b;
    _239 = _241;
    goto _jump1928;
    _jump1927:;
    _239 = d;
    _jump1928:;
    int64_t _242 = _227 * _239;
    if (_242 > 0) 
    goto _jump1929;
    fail_assertion("non-positive loop bound");
    _jump1929:;
    _218 = 0;
    int64_t _243 = 0; // t
    int64_t _244 = 0; // s
    int64_t _245 = 0; // r
    _jump1930:; // Begin body of loop
    int64_t _246 = _244 % e;
    _218 += _246;
    _243++;
    if (_243 < _242)
    goto _jump1930;
    _243 = 0;
    _244++;
    if (_244 < _221)
    goto _jump1930;
    _244 = 0;
    _245++;
    if (_245 < _220)
    goto _jump1930;
    // End body of loop
    if (e >= 0)
    goto _jump1931;
    fail_assertion("negative array index");
    _jump1931:;
    if (e < _217.d0)
    goto _jump1932;
    fail_assertion("index too large");
    _jump1932:;
    if (_218 >= 0)
    goto _jump1933;
    fail_assertion("negative array index");
    _jump1933:;
    if (_218 < _217.d1)
    goto _jump1934;
    fail_assertion("index too large");
    _jump1934:;
    int64_t _247 = 0;
    _247 *= _217.d0;
    _247 += e;
    _247 *= _217.d1;
    _247 += _218;
    int64_t _248 = _217.data[_247];
    if (i >= 0)
    goto _jump1935;
    fail_assertion("negative array index");
    _jump1935:;
    if (i < _193.d0)
    goto _jump1936;
    fail_assertion("index too large");
    _jump1936:;
    if (_195 >= 0)
    goto _jump1937;
    fail_assertion("negative array index");
    _jump1937:;
    if (_195 < _193.d1)
    goto _jump1938;
    fail_assertion("index too large");
    _jump1938:;
    if (_248 >= 0)
    goto _jump1939;
    fail_assertion("negative array index");
    _jump1939:;
    if (_248 < _193.d2)
    goto _jump1940;
    fail_assertion("index too large");
    _jump1940:;
    int64_t _249 = 0;
    _249 *= _193.d0;
    _249 += i;
    _249 *= _193.d1;
    _249 += _195;
    _249 *= _193.d2;
    _249 += _248;
    _a2_bool _250 = _193.data[_249];
    int64_t _251 = 863;
    _a2__a1_void_t _252;
    if (!a)
    goto _jump1941;
    _a3_bool _254;
    // Computing bound for r
    bool _255 = true;
    int64_t _256;
    if (!_255)
    goto _jump1942;
    _256 = e;
    goto _jump1943;
    _jump1942:;
    _256 = i;
    _jump1943:;
    _254.d0 = _256;
    if (_256 > 0) 
    goto _jump1944;
    fail_assertion("non-positive loop bound");
    _jump1944:;
    // Computing bound for s
    _254.d1 = d;
    if (d > 0) 
    goto _jump1945;
    fail_assertion("non-positive loop bound");
    _jump1945:;
    // Computing bound for t
    int64_t _257 = 972;
    int64_t _258 = -_257;
    _254.d2 = _258;
    if (_258 > 0) 
    goto _jump1946;
    fail_assertion("non-positive loop bound");
    _jump1946:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= _256;
    _259 *= d;
    _259 *= _258;
    _259 *= sizeof(bool);
    _254.data = jpl_alloc(_259);
    int64_t _260 = 0; // t
    int64_t _261 = 0; // s
    int64_t _262 = 0; // r
    _jump1947:; // Begin body of loop
    int64_t _263 = 0;
    _263 *= _254.d0;
    _263 += _262;
    _263 *= _254.d1;
    _263 += _261;
    _263 *= _254.d2;
    _263 += _260;
    _254.data[_263] = _158;
    _260++;
    if (_260 < _258)
    goto _jump1947;
    _260 = 0;
    _261++;
    if (_261 < d)
    goto _jump1947;
    _261 = 0;
    _262++;
    if (_262 < _256)
    goto _jump1947;
    // End body of loop
    int64_t _264;
    // Computing bound for r
    int64_t _265;
    if (!_158)
    goto _jump1948;
    int64_t _266 = 991;
    _265 = _266;
    goto _jump1949;
    _jump1948:;
    _265 = e;
    _jump1949:;
    if (_265 > 0) 
    goto _jump1950;
    fail_assertion("non-positive loop bound");
    _jump1950:;
    _264 = 0;
    int64_t _267 = 0; // r
    _jump1951:; // Begin body of loop
    int64_t _268 = 54;
    int64_t _269 = _268 - i;
    _264 += _269;
    _267++;
    if (_267 < _265)
    goto _jump1951;
    // End body of loop
    g _270 = l();
    int64_t _271 = _270.b;
    _a2_int64_t _272;
    // Computing bound for r
    _272.d0 = d;
    if (d > 0) 
    goto _jump1952;
    fail_assertion("non-positive loop bound");
    _jump1952:;
    // Computing bound for s
    _272.d1 = e;
    if (e > 0) 
    goto _jump1953;
    fail_assertion("non-positive loop bound");
    _jump1953:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= d;
    _273 *= e;
    _273 *= sizeof(int64_t);
    _272.data = jpl_alloc(_273);
    int64_t _274 = 0; // s
    int64_t _275 = 0; // r
    _jump1954:; // Begin body of loop
    int64_t _276 = 0;
    _276 *= _272.d0;
    _276 += _275;
    _276 *= _272.d1;
    _276 += _274;
    _272.data[_276] = e;
    _274++;
    if (_274 < e)
    goto _jump1954;
    _274 = 0;
    _275++;
    if (_275 < d)
    goto _jump1954;
    // End body of loop
    g _277 = l();
    int64_t _278 = _277.b;
    if (e >= 0)
    goto _jump1955;
    fail_assertion("negative array index");
    _jump1955:;
    if (e < _272.d0)
    goto _jump1956;
    fail_assertion("index too large");
    _jump1956:;
    if (_278 >= 0)
    goto _jump1957;
    fail_assertion("negative array index");
    _jump1957:;
    if (_278 < _272.d1)
    goto _jump1958;
    fail_assertion("index too large");
    _jump1958:;
    int64_t _279 = 0;
    _279 *= _272.d0;
    _279 += e;
    _279 *= _272.d1;
    _279 += _278;
    int64_t _280 = _272.data[_279];
    if (_264 >= 0)
    goto _jump1959;
    fail_assertion("negative array index");
    _jump1959:;
    if (_264 < _254.d0)
    goto _jump1960;
    fail_assertion("index too large");
    _jump1960:;
    if (_271 >= 0)
    goto _jump1961;
    fail_assertion("negative array index");
    _jump1961:;
    if (_271 < _254.d1)
    goto _jump1962;
    fail_assertion("index too large");
    _jump1962:;
    if (_280 >= 0)
    goto _jump1963;
    fail_assertion("negative array index");
    _jump1963:;
    if (_280 < _254.d2)
    goto _jump1964;
    fail_assertion("index too large");
    _jump1964:;
    int64_t _281 = 0;
    _281 *= _254.d0;
    _281 += _264;
    _281 *= _254.d1;
    _281 += _271;
    _281 *= _254.d2;
    _281 += _280;
    bool _282 = _254.data[_281];
    bool _253 = _282;
    if (0 != _282)
    goto _jump1965;
    int64_t _283 = 401;
    int64_t _284;
    if (!a)
    goto _jump1966;
    _284 = d;
    goto _jump1967;
    _jump1966:;
    _284 = e;
    _jump1967:;
    int64_t _285 = -_284;
    bool _286 = _283 <= _285;
    _253 = _286;
    _jump1965:;
    _a2__a1_void_t _287;
    if (!_253)
    goto _jump1968;
    _a2__a1_void_t _288;
    // Computing bound for r
    _a3_int64_t _289;
    // Computing bound for r
    int64_t _290 = 832;
    _289.d0 = _290;
    if (_290 > 0) 
    goto _jump1969;
    fail_assertion("non-positive loop bound");
    _jump1969:;
    // Computing bound for s
    _289.d1 = e;
    if (e > 0) 
    goto _jump1970;
    fail_assertion("non-positive loop bound");
    _jump1970:;
    // Computing bound for t
    int64_t _291 = 689;
    _289.d2 = _291;
    if (_291 > 0) 
    goto _jump1971;
    fail_assertion("non-positive loop bound");
    _jump1971:;
    // Computing total size of heap memory to allocate
    int64_t _292 = 1;
    _292 *= _290;
    _292 *= e;
    _292 *= _291;
    _292 *= sizeof(int64_t);
    _289.data = jpl_alloc(_292);
    int64_t _293 = 0; // t
    int64_t _294 = 0; // s
    int64_t _295 = 0; // r
    _jump1972:; // Begin body of loop
    int64_t _296 = 0;
    _296 *= _289.d0;
    _296 += _295;
    _296 *= _289.d1;
    _296 += _294;
    _296 *= _289.d2;
    _296 += _293;
    _289.data[_296] = i;
    _293++;
    if (_293 < _291)
    goto _jump1972;
    _293 = 0;
    _294++;
    if (_294 < e)
    goto _jump1972;
    _294 = 0;
    _295++;
    if (_295 < _290)
    goto _jump1972;
    // End body of loop
    int64_t _297;
    // Computing bound for r
    int64_t _298 = 881;
    if (_298 > 0) 
    goto _jump1973;
    fail_assertion("non-positive loop bound");
    _jump1973:;
    // Computing bound for s
    int64_t _299 = 208;
    if (_299 > 0) 
    goto _jump1974;
    fail_assertion("non-positive loop bound");
    _jump1974:;
    // Computing bound for t
    int64_t _300 = 655;
    int64_t _301 = -_300;
    if (_301 > 0) 
    goto _jump1975;
    fail_assertion("non-positive loop bound");
    _jump1975:;
    _297 = 0;
    int64_t _302 = 0; // t
    int64_t _303 = 0; // s
    int64_t _304 = 0; // r
    _jump1976:; // Begin body of loop
    _297 += e;
    _302++;
    if (_302 < _301)
    goto _jump1976;
    _302 = 0;
    _303++;
    if (_303 < _299)
    goto _jump1976;
    _303 = 0;
    _304++;
    if (_304 < _298)
    goto _jump1976;
    // End body of loop
    bool _305 = true;
    int64_t _306;
    if (!_305)
    goto _jump1977;
    _306 = e;
    goto _jump1978;
    _jump1977:;
    _306 = d;
    _jump1978:;
    if (_297 >= 0)
    goto _jump1979;
    fail_assertion("negative array index");
    _jump1979:;
    if (_297 < _289.d0)
    goto _jump1980;
    fail_assertion("index too large");
    _jump1980:;
    if (e >= 0)
    goto _jump1981;
    fail_assertion("negative array index");
    _jump1981:;
    if (e < _289.d1)
    goto _jump1982;
    fail_assertion("index too large");
    _jump1982:;
    if (_306 >= 0)
    goto _jump1983;
    fail_assertion("negative array index");
    _jump1983:;
    if (_306 < _289.d2)
    goto _jump1984;
    fail_assertion("index too large");
    _jump1984:;
    int64_t _307 = 0;
    _307 *= _289.d0;
    _307 += _297;
    _307 *= _289.d1;
    _307 += e;
    _307 *= _289.d2;
    _307 += _306;
    int64_t _308 = _289.data[_307];
    _288.d0 = _308;
    if (_308 > 0) 
    goto _jump1985;
    fail_assertion("non-positive loop bound");
    _jump1985:;
    // Computing bound for s
    bool _309 = false;
    g _310;
    if (!_309)
    goto _jump1986;
    int64_t _311 = 825;
    g _312 = { a, _311 };
    _310 = _312;
    goto _jump1987;
    _jump1986:;
    g _313 = { a, e };
    _310 = _313;
    _jump1987:;
    int64_t _314 = _310.b;
    _288.d1 = _314;
    if (_314 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    // Computing total size of heap memory to allocate
    int64_t _315 = 1;
    _315 *= _308;
    _315 *= _314;
    _315 *= sizeof(_a1_void_t);
    _288.data = jpl_alloc(_315);
    int64_t _316 = 0; // s
    int64_t _317 = 0; // r
    _jump1989:; // Begin body of loop
    _a1_void_t _318;
    // Computing bound for t
    _318.d0 = d;
    if (d > 0) 
    goto _jump1990;
    fail_assertion("non-positive loop bound");
    _jump1990:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= d;
    _319 *= sizeof(void_t);
    _318.data = jpl_alloc(_319);
    int64_t _320 = 0; // t
    _jump1991:; // Begin body of loop
    g _321 = l();
    int64_t _322 = _321.b;
    rgba _323 = j();
    void_t _324 = h(_322, _323, i);
    int64_t _325 = 0;
    _325 *= _318.d0;
    _325 += _320;
    _318.data[_325] = _324;
    _320++;
    if (_320 < d)
    goto _jump1991;
    // End body of loop
    int64_t _326 = 0;
    _326 *= _288.d0;
    _326 += _317;
    _326 *= _288.d1;
    _326 += _316;
    _288.data[_326] = _318;
    _316++;
    if (_316 < _314)
    goto _jump1989;
    _316 = 0;
    _317++;
    if (_317 < _308)
    goto _jump1989;
    // End body of loop
    _287 = _288;
    goto _jump1992;
    _jump1968:;
    _a2__a1_void_t _327;
    // Computing bound for r
    int64_t _328 = 650;
    int64_t _329 = _328 - i;
    int64_t _330 = 367;
    int64_t _331 = d - _330;
    int64_t _332 = _329 - _331;
    _a2_int64_t _333;
    // Computing bound for r
    _333.d0 = i;
    if (i > 0) 
    goto _jump1993;
    fail_assertion("non-positive loop bound");
    _jump1993:;
    // Computing bound for s
    _333.d1 = e;
    if (e > 0) 
    goto _jump1994;
    fail_assertion("non-positive loop bound");
    _jump1994:;
    // Computing total size of heap memory to allocate
    int64_t _334 = 1;
    _334 *= i;
    _334 *= e;
    _334 *= sizeof(int64_t);
    _333.data = jpl_alloc(_334);
    int64_t _335 = 0; // s
    int64_t _336 = 0; // r
    _jump1995:; // Begin body of loop
    int64_t _337 = 0;
    _337 *= _333.d0;
    _337 += _336;
    _337 *= _333.d1;
    _337 += _335;
    _333.data[_337] = d;
    _335++;
    if (_335 < e)
    goto _jump1995;
    _335 = 0;
    _336++;
    if (_336 < i)
    goto _jump1995;
    // End body of loop
    int64_t _338 = -i;
    if (_338 >= 0)
    goto _jump1996;
    fail_assertion("negative array index");
    _jump1996:;
    if (_338 < _333.d0)
    goto _jump1997;
    fail_assertion("index too large");
    _jump1997:;
    if (e >= 0)
    goto _jump1998;
    fail_assertion("negative array index");
    _jump1998:;
    if (e < _333.d1)
    goto _jump1999;
    fail_assertion("index too large");
    _jump1999:;
    int64_t _339 = 0;
    _339 *= _333.d0;
    _339 += _338;
    _339 *= _333.d1;
    _339 += e;
    int64_t _340 = _333.data[_339];
    int64_t _341 = _332 + _340;
    _327.d0 = _341;
    if (_341 > 0) 
    goto _jump2000;
    fail_assertion("non-positive loop bound");
    _jump2000:;
    // Computing bound for s
    int64_t _342 = 101;
    int64_t _343 = -_342;
    _327.d1 = _343;
    if (_343 > 0) 
    goto _jump2001;
    fail_assertion("non-positive loop bound");
    _jump2001:;
    // Computing total size of heap memory to allocate
    int64_t _344 = 1;
    _344 *= _341;
    _344 *= _343;
    _344 *= sizeof(_a1_void_t);
    _327.data = jpl_alloc(_344);
    int64_t _345 = 0; // s
    int64_t _346 = 0; // r
    _jump2002:; // Begin body of loop
    _a2__a1_void_t _347;
    // Computing bound for t
    int64_t _348 = -e;
    _347.d0 = _348;
    if (_348 > 0) 
    goto _jump2003;
    fail_assertion("non-positive loop bound");
    _jump2003:;
    // Computing bound for u
    _347.d1 = i;
    if (i > 0) 
    goto _jump2004;
    fail_assertion("non-positive loop bound");
    _jump2004:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= _348;
    _349 *= i;
    _349 *= sizeof(_a1_void_t);
    _347.data = jpl_alloc(_349);
    int64_t _350 = 0; // u
    int64_t _351 = 0; // t
    _jump2005:; // Begin body of loop
    void_t _352 = o();
    void_t _353 = o();
    _a1_void_t _354;
    _354.d0 = 2;
    _354.data = jpl_alloc(sizeof(void_t) * 2);
    _354.data[0] = _352;
    _354.data[1] = _353;
    int64_t _355 = 0;
    _355 *= _347.d0;
    _355 += _351;
    _355 *= _347.d1;
    _355 += _350;
    _347.data[_355] = _354;
    _350++;
    if (_350 < i)
    goto _jump2005;
    _350 = 0;
    _351++;
    if (_351 < _348)
    goto _jump2005;
    // End body of loop
    if (_345 >= 0)
    goto _jump2006;
    fail_assertion("negative array index");
    _jump2006:;
    if (_345 < _347.d0)
    goto _jump2007;
    fail_assertion("index too large");
    _jump2007:;
    if (d >= 0)
    goto _jump2008;
    fail_assertion("negative array index");
    _jump2008:;
    if (d < _347.d1)
    goto _jump2009;
    fail_assertion("index too large");
    _jump2009:;
    int64_t _356 = 0;
    _356 *= _347.d0;
    _356 += _345;
    _356 *= _347.d1;
    _356 += d;
    _a1_void_t _357 = _347.data[_356];
    int64_t _358 = 0;
    _358 *= _327.d0;
    _358 += _346;
    _358 *= _327.d1;
    _358 += _345;
    _327.data[_358] = _357;
    _345++;
    if (_345 < _343)
    goto _jump2002;
    _345 = 0;
    _346++;
    if (_346 < _341)
    goto _jump2002;
    // End body of loop
    _287 = _327;
    _jump1992:;
    _252 = _287;
    goto _jump2010;
    _jump1941:;
    _a2__a1_void_t _359;
    if (!_158)
    goto _jump2011;
    _a2__a1_void_t _360;
    // Computing bound for r
    int64_t _361;
    // Computing bound for r
    if (i > 0) 
    goto _jump2012;
    fail_assertion("non-positive loop bound");
    _jump2012:;
    _361 = 0;
    int64_t _362 = 0; // r
    _jump2013:; // Begin body of loop
    int64_t _363 = 44;
    _361 += _363;
    _362++;
    if (_362 < i)
    goto _jump2013;
    // End body of loop
    _360.d0 = _361;
    if (_361 > 0) 
    goto _jump2014;
    fail_assertion("non-positive loop bound");
    _jump2014:;
    // Computing bound for s
    int64_t _364 = -e;
    _360.d1 = _364;
    if (_364 > 0) 
    goto _jump2015;
    fail_assertion("non-positive loop bound");
    _jump2015:;
    // Computing total size of heap memory to allocate
    int64_t _365 = 1;
    _365 *= _361;
    _365 *= _364;
    _365 *= sizeof(_a1_void_t);
    _360.data = jpl_alloc(_365);
    int64_t _366 = 0; // s
    int64_t _367 = 0; // r
    _jump2016:; // Begin body of loop
    _a1_void_t _368;
    // Computing bound for t
    _368.d0 = e;
    if (e > 0) 
    goto _jump2017;
    fail_assertion("non-positive loop bound");
    _jump2017:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= e;
    _369 *= sizeof(void_t);
    _368.data = jpl_alloc(_369);
    int64_t _370 = 0; // t
    _jump2018:; // Begin body of loop
    void_t _371 = o();
    int64_t _372 = 0;
    _372 *= _368.d0;
    _372 += _370;
    _368.data[_372] = _371;
    _370++;
    if (_370 < e)
    goto _jump2018;
    // End body of loop
    int64_t _373 = 0;
    _373 *= _360.d0;
    _373 += _367;
    _373 *= _360.d1;
    _373 += _366;
    _360.data[_373] = _368;
    _366++;
    if (_366 < _364)
    goto _jump2016;
    _366 = 0;
    _367++;
    if (_367 < _361)
    goto _jump2016;
    // End body of loop
    _a1__a2__a1_void_t _374;
    _374.d0 = 1;
    _374.data = jpl_alloc(sizeof(_a2__a1_void_t) * 1);
    _374.data[0] = _360;
    if (i >= 0)
    goto _jump2019;
    fail_assertion("negative array index");
    _jump2019:;
    if (i < _374.d0)
    goto _jump2020;
    fail_assertion("index too large");
    _jump2020:;
    int64_t _375 = 0;
    _375 *= _374.d0;
    _375 += i;
    _a2__a1_void_t _376 = _374.data[_375];
    _359 = _376;
    goto _jump2021;
    _jump2011:;
    _a2__a1_void_t _377;
    // Computing bound for r
    int64_t _378 = -d;
    int64_t _379 = _378 % i;
    int64_t _380 = _379 / d;
    _377.d0 = _380;
    if (_380 > 0) 
    goto _jump2022;
    fail_assertion("non-positive loop bound");
    _jump2022:;
    // Computing bound for s
    int64_t _381 = 913;
    _377.d1 = _381;
    if (_381 > 0) 
    goto _jump2023;
    fail_assertion("non-positive loop bound");
    _jump2023:;
    // Computing total size of heap memory to allocate
    int64_t _382 = 1;
    _382 *= _380;
    _382 *= _381;
    _382 *= sizeof(_a1_void_t);
    _377.data = jpl_alloc(_382);
    int64_t _383 = 0; // s
    int64_t _384 = 0; // r
    _jump2024:; // Begin body of loop
    _a1_void_t _385;
    // Computing bound for t
    int64_t _386 = 691;
    _385.d0 = _386;
    if (_386 > 0) 
    goto _jump2025;
    fail_assertion("non-positive loop bound");
    _jump2025:;
    // Computing total size of heap memory to allocate
    int64_t _387 = 1;
    _387 *= _386;
    _387 *= sizeof(void_t);
    _385.data = jpl_alloc(_387);
    int64_t _388 = 0; // t
    _jump2026:; // Begin body of loop
    void_t _389 = o();
    int64_t _390 = 0;
    _390 *= _385.d0;
    _390 += _388;
    _385.data[_390] = _389;
    _388++;
    if (_388 < _386)
    goto _jump2026;
    // End body of loop
    int64_t _391 = 0;
    _391 *= _377.d0;
    _391 += _384;
    _391 *= _377.d1;
    _391 += _383;
    _377.data[_391] = _385;
    _383++;
    if (_383 < _381)
    goto _jump2024;
    _383 = 0;
    _384++;
    if (_384 < _380)
    goto _jump2024;
    // End body of loop
    _359 = _377;
    _jump2021:;
    _252 = _359;
    _jump2010:;
    void_t _392 = b(_250, _251, _252);
    return _392;
    _a1__a3__a3_double _393;
    // Computing bound for r
    _a3_int64_t _394;
    // Computing bound for r
    int64_t _395;
    // Computing bound for r
    if (d > 0) 
    goto _jump2027;
    fail_assertion("non-positive loop bound");
    _jump2027:;
    _395 = 0;
    int64_t _396 = 0; // r
    _jump2028:; // Begin body of loop
    _395 += e;
    _396++;
    if (_396 < d)
    goto _jump2028;
    // End body of loop
    _394.d0 = _395;
    if (_395 > 0) 
    goto _jump2029;
    fail_assertion("non-positive loop bound");
    _jump2029:;
    // Computing bound for s
    int64_t _397 = 634;
    int64_t _398 = -_397;
    _394.d1 = _398;
    if (_398 > 0) 
    goto _jump2030;
    fail_assertion("non-positive loop bound");
    _jump2030:;
    // Computing bound for t
    int64_t _399;
    // Computing bound for r
    if (i > 0) 
    goto _jump2031;
    fail_assertion("non-positive loop bound");
    _jump2031:;
    _399 = 0;
    int64_t _400 = 0; // r
    _jump2032:; // Begin body of loop
    _399 += d;
    _400++;
    if (_400 < i)
    goto _jump2032;
    // End body of loop
    _394.d2 = _399;
    if (_399 > 0) 
    goto _jump2033;
    fail_assertion("non-positive loop bound");
    _jump2033:;
    // Computing total size of heap memory to allocate
    int64_t _401 = 1;
    _401 *= _395;
    _401 *= _398;
    _401 *= _399;
    _401 *= sizeof(int64_t);
    _394.data = jpl_alloc(_401);
    int64_t _402 = 0; // t
    int64_t _403 = 0; // s
    int64_t _404 = 0; // r
    _jump2034:; // Begin body of loop
    int64_t _405;
    // Computing bound for u
    if (e > 0) 
    goto _jump2035;
    fail_assertion("non-positive loop bound");
    _jump2035:;
    _405 = 0;
    int64_t _406 = 0; // u
    _jump2036:; // Begin body of loop
    _405 += _404;
    _406++;
    if (_406 < e)
    goto _jump2036;
    // End body of loop
    if (_405 >= 0)
    goto _jump2037;
    fail_assertion("negative array index");
    _jump2037:;
    if (_405 < _127.d0)
    goto _jump2038;
    fail_assertion("index too large");
    _jump2038:;
    int64_t _407 = 0;
    _407 *= _127.d0;
    _407 += _405;
    int64_t _408 = _127.data[_407];
    int64_t _409 = 0;
    _409 *= _394.d0;
    _409 += _404;
    _409 *= _394.d1;
    _409 += _403;
    _409 *= _394.d2;
    _409 += _402;
    _394.data[_409] = _408;
    _402++;
    if (_402 < _399)
    goto _jump2034;
    _402 = 0;
    _403++;
    if (_403 < _398)
    goto _jump2034;
    _403 = 0;
    _404++;
    if (_404 < _395)
    goto _jump2034;
    // End body of loop
    int64_t _410 = -i;
    int64_t _411;
    // Computing bound for r
    if (e > 0) 
    goto _jump2039;
    fail_assertion("non-positive loop bound");
    _jump2039:;
    // Computing bound for s
    if (i > 0) 
    goto _jump2040;
    fail_assertion("non-positive loop bound");
    _jump2040:;
    // Computing bound for t
    int64_t _412;
    // Computing bound for r
    if (d > 0) 
    goto _jump2041;
    fail_assertion("non-positive loop bound");
    _jump2041:;
    // Computing bound for s
    if (e > 0) 
    goto _jump2042;
    fail_assertion("non-positive loop bound");
    _jump2042:;
    // Computing bound for t
    if (e > 0) 
    goto _jump2043;
    fail_assertion("non-positive loop bound");
    _jump2043:;
    _412 = 0;
    int64_t _413 = 0; // t
    int64_t _414 = 0; // s
    int64_t _415 = 0; // r
    _jump2044:; // Begin body of loop
    _412 += _413;
    _413++;
    if (_413 < e)
    goto _jump2044;
    _413 = 0;
    _414++;
    if (_414 < e)
    goto _jump2044;
    _414 = 0;
    _415++;
    if (_415 < d)
    goto _jump2044;
    // End body of loop
    if (_412 > 0) 
    goto _jump2045;
    fail_assertion("non-positive loop bound");
    _jump2045:;
    _411 = 0;
    int64_t _416 = 0; // t
    int64_t _417 = 0; // s
    int64_t _418 = 0; // r
    _jump2046:; // Begin body of loop
    int64_t _419 = 928;
    _411 += _419;
    _416++;
    if (_416 < _412)
    goto _jump2046;
    _416 = 0;
    _417++;
    if (_417 < i)
    goto _jump2046;
    _417 = 0;
    _418++;
    if (_418 < e)
    goto _jump2046;
    // End body of loop
    int64_t _420 = _411 * d;
    if (_410 >= 0)
    goto _jump2047;
    fail_assertion("negative array index");
    _jump2047:;
    if (_410 < _394.d0)
    goto _jump2048;
    fail_assertion("index too large");
    _jump2048:;
    if (i >= 0)
    goto _jump2049;
    fail_assertion("negative array index");
    _jump2049:;
    if (i < _394.d1)
    goto _jump2050;
    fail_assertion("index too large");
    _jump2050:;
    if (_420 >= 0)
    goto _jump2051;
    fail_assertion("negative array index");
    _jump2051:;
    if (_420 < _394.d2)
    goto _jump2052;
    fail_assertion("index too large");
    _jump2052:;
    int64_t _421 = 0;
    _421 *= _394.d0;
    _421 += _410;
    _421 *= _394.d1;
    _421 += i;
    _421 *= _394.d2;
    _421 += _420;
    int64_t _422 = _394.data[_421];
    _393.d0 = _422;
    if (_422 > 0) 
    goto _jump2053;
    fail_assertion("non-positive loop bound");
    _jump2053:;
    // Computing total size of heap memory to allocate
    int64_t _423 = 1;
    _423 *= _422;
    _423 *= sizeof(_a3__a3_double);
    _393.data = jpl_alloc(_423);
    int64_t _424 = 0; // r
    _jump2054:; // Begin body of loop
    _a3__a3_double _425;
    // Computing bound for s
    _425.d0 = d;
    if (d > 0) 
    goto _jump2055;
    fail_assertion("non-positive loop bound");
    _jump2055:;
    // Computing bound for t
    int64_t _426;
    // Computing bound for s
    int64_t _427 = 215;
    if (_427 > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing bound for t
    int64_t _428;
    if (!a)
    goto _jump2057;
    _428 = d;
    goto _jump2058;
    _jump2057:;
    _428 = i;
    _jump2058:;
    if (_428 > 0) 
    goto _jump2059;
    fail_assertion("non-positive loop bound");
    _jump2059:;
    // Computing bound for u
    if (_424 > 0) 
    goto _jump2060;
    fail_assertion("non-positive loop bound");
    _jump2060:;
    _426 = 0;
    int64_t _429 = 0; // u
    int64_t _430 = 0; // t
    int64_t _431 = 0; // s
    _jump2061:; // Begin body of loop
    _426 += _431;
    _429++;
    if (_429 < _424)
    goto _jump2061;
    _429 = 0;
    _430++;
    if (_430 < _428)
    goto _jump2061;
    _430 = 0;
    _431++;
    if (_431 < _427)
    goto _jump2061;
    // End body of loop
    int64_t _432;
    // Computing bound for s
    g _433 = l();
    int64_t _434 = _433.b;
    if (_434 > 0) 
    goto _jump2062;
    fail_assertion("non-positive loop bound");
    _jump2062:;
    _432 = 0;
    int64_t _435 = 0; // s
    _jump2063:; // Begin body of loop
    g _436 = l();
    int64_t _437 = _436.b;
    _432 += _437;
    _435++;
    if (_435 < _434)
    goto _jump2063;
    // End body of loop
    int64_t _438 = _426 * _432;
    _425.d1 = _438;
    if (_438 > 0) 
    goto _jump2064;
    fail_assertion("non-positive loop bound");
    _jump2064:;
    // Computing bound for u
    _425.d2 = i;
    if (i > 0) 
    goto _jump2065;
    fail_assertion("non-positive loop bound");
    _jump2065:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= d;
    _439 *= _438;
    _439 *= i;
    _439 *= sizeof(_a3_double);
    _425.data = jpl_alloc(_439);
    int64_t _440 = 0; // u
    int64_t _441 = 0; // t
    int64_t _442 = 0; // s
    _jump2066:; // Begin body of loop
    _a3_double _443;
    // Computing bound for v
    _443.d0 = _442;
    if (_442 > 0) 
    goto _jump2067;
    fail_assertion("non-positive loop bound");
    _jump2067:;
    // Computing bound for w
    _443.d1 = _442;
    if (_442 > 0) 
    goto _jump2068;
    fail_assertion("non-positive loop bound");
    _jump2068:;
    // Computing bound for x
    int64_t _444 = 164;
    _443.d2 = _444;
    if (_444 > 0) 
    goto _jump2069;
    fail_assertion("non-positive loop bound");
    _jump2069:;
    // Computing total size of heap memory to allocate
    int64_t _445 = 1;
    _445 *= _442;
    _445 *= _442;
    _445 *= _444;
    _445 *= sizeof(double);
    _443.data = jpl_alloc(_445);
    int64_t _446 = 0; // x
    int64_t _447 = 0; // w
    int64_t _448 = 0; // v
    _jump2070:; // Begin body of loop
    double _449 = 11.0;
    int64_t _450 = 0;
    _450 *= _443.d0;
    _450 += _448;
    _450 *= _443.d1;
    _450 += _447;
    _450 *= _443.d2;
    _450 += _446;
    _443.data[_450] = _449;
    _446++;
    if (_446 < _444)
    goto _jump2070;
    _446 = 0;
    _447++;
    if (_447 < _442)
    goto _jump2070;
    _447 = 0;
    _448++;
    if (_448 < _442)
    goto _jump2070;
    // End body of loop
    int64_t _451 = 0;
    _451 *= _425.d0;
    _451 += _442;
    _451 *= _425.d1;
    _451 += _441;
    _451 *= _425.d2;
    _451 += _440;
    _425.data[_451] = _443;
    _440++;
    if (_440 < i)
    goto _jump2066;
    _440 = 0;
    _441++;
    if (_441 < _438)
    goto _jump2066;
    _441 = 0;
    _442++;
    if (_442 < d)
    goto _jump2066;
    // End body of loop
    int64_t _452 = 0;
    _452 *= _393.d0;
    _452 += _424;
    _393.data[_452] = _425;
    _424++;
    if (_424 < _422)
    goto _jump2054;
    // End body of loop
    if (i >= 0)
    goto _jump2071;
    fail_assertion("negative array index");
    _jump2071:;
    if (i < _393.d0)
    goto _jump2072;
    fail_assertion("index too large");
    _jump2072:;
    int64_t _453 = 0;
    _453 *= _393.d0;
    _453 += i;
    _a3__a3_double _454 = _393.data[_453];
    int64_t _455 = 879;
    if (_455 >= 0)
    goto _jump2073;
    fail_assertion("negative array index");
    _jump2073:;
    if (_455 < m.d0)
    goto _jump2074;
    fail_assertion("index too large");
    _jump2074:;
    if (e >= 0)
    goto _jump2075;
    fail_assertion("negative array index");
    _jump2075:;
    if (e < m.d1)
    goto _jump2076;
    fail_assertion("index too large");
    _jump2076:;
    int64_t _456 = 0;
    _456 *= m.d0;
    _456 += _455;
    _456 *= m.d1;
    _456 += e;
    bool _457 = m.data[_456];
    rgba _458;
    if (!_457)
    goto _jump2077;
    _a3_rgba _459;
    // Computing bound for r
    int64_t _460 = 891;
    _459.d0 = _460;
    if (_460 > 0) 
    goto _jump2078;
    fail_assertion("non-positive loop bound");
    _jump2078:;
    // Computing bound for s
    int64_t _461;
    if (!a)
    goto _jump2079;
    int64_t _462 = -d;
    _461 = _462;
    goto _jump2080;
    _jump2079:;
    _461 = e;
    _jump2080:;
    _459.d1 = _461;
    if (_461 > 0) 
    goto _jump2081;
    fail_assertion("non-positive loop bound");
    _jump2081:;
    // Computing bound for t
    _459.d2 = i;
    if (i > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing total size of heap memory to allocate
    int64_t _463 = 1;
    _463 *= _460;
    _463 *= _461;
    _463 *= i;
    _463 *= sizeof(rgba);
    _459.data = jpl_alloc(_463);
    int64_t _464 = 0; // t
    int64_t _465 = 0; // s
    int64_t _466 = 0; // r
    _jump2083:; // Begin body of loop
    _a2_rgba _467;
    // Computing bound for u
    int64_t _468 = 47;
    _467.d0 = _468;
    if (_468 > 0) 
    goto _jump2084;
    fail_assertion("non-positive loop bound");
    _jump2084:;
    // Computing bound for v
    _467.d1 = _466;
    if (_466 > 0) 
    goto _jump2085;
    fail_assertion("non-positive loop bound");
    _jump2085:;
    // Computing total size of heap memory to allocate
    int64_t _469 = 1;
    _469 *= _468;
    _469 *= _466;
    _469 *= sizeof(rgba);
    _467.data = jpl_alloc(_469);
    int64_t _470 = 0; // v
    int64_t _471 = 0; // u
    _jump2086:; // Begin body of loop
    rgba _472 = j();
    int64_t _473 = 0;
    _473 *= _467.d0;
    _473 += _471;
    _473 *= _467.d1;
    _473 += _470;
    _467.data[_473] = _472;
    _470++;
    if (_470 < _466)
    goto _jump2086;
    _470 = 0;
    _471++;
    if (_471 < _468)
    goto _jump2086;
    // End body of loop
    int64_t _474 = 21;
    if (_474 >= 0)
    goto _jump2087;
    fail_assertion("negative array index");
    _jump2087:;
    if (_474 < _467.d0)
    goto _jump2088;
    fail_assertion("index too large");
    _jump2088:;
    if (_466 >= 0)
    goto _jump2089;
    fail_assertion("negative array index");
    _jump2089:;
    if (_466 < _467.d1)
    goto _jump2090;
    fail_assertion("index too large");
    _jump2090:;
    int64_t _475 = 0;
    _475 *= _467.d0;
    _475 += _474;
    _475 *= _467.d1;
    _475 += _466;
    rgba _476 = _467.data[_475];
    int64_t _477 = 0;
    _477 *= _459.d0;
    _477 += _466;
    _477 *= _459.d1;
    _477 += _465;
    _477 *= _459.d2;
    _477 += _464;
    _459.data[_477] = _476;
    _464++;
    if (_464 < i)
    goto _jump2083;
    _464 = 0;
    _465++;
    if (_465 < _461)
    goto _jump2083;
    _465 = 0;
    _466++;
    if (_466 < _460)
    goto _jump2083;
    // End body of loop
    int64_t _478;
    // Computing bound for r
    int64_t _479 = -d;
    int64_t _480 = -_479;
    if (_480 > 0) 
    goto _jump2091;
    fail_assertion("non-positive loop bound");
    _jump2091:;
    // Computing bound for s
    bool _481 = _158 != a;
    int64_t _482;
    if (!_481)
    goto _jump2092;
    int64_t _483 = 412;
    _482 = _483;
    goto _jump2093;
    _jump2092:;
    _482 = e;
    _jump2093:;
    if (_482 > 0) 
    goto _jump2094;
    fail_assertion("non-positive loop bound");
    _jump2094:;
    // Computing bound for t
    if (d > 0) 
    goto _jump2095;
    fail_assertion("non-positive loop bound");
    _jump2095:;
    _478 = 0;
    int64_t _484 = 0; // t
    int64_t _485 = 0; // s
    int64_t _486 = 0; // r
    _jump2096:; // Begin body of loop
    _478 += i;
    _484++;
    if (_484 < d)
    goto _jump2096;
    _484 = 0;
    _485++;
    if (_485 < _482)
    goto _jump2096;
    _485 = 0;
    _486++;
    if (_486 < _480)
    goto _jump2096;
    // End body of loop
    if (i >= 0)
    goto _jump2097;
    fail_assertion("negative array index");
    _jump2097:;
    if (i < _459.d0)
    goto _jump2098;
    fail_assertion("index too large");
    _jump2098:;
    if (e >= 0)
    goto _jump2099;
    fail_assertion("negative array index");
    _jump2099:;
    if (e < _459.d1)
    goto _jump2100;
    fail_assertion("index too large");
    _jump2100:;
    if (_478 >= 0)
    goto _jump2101;
    fail_assertion("negative array index");
    _jump2101:;
    if (_478 < _459.d2)
    goto _jump2102;
    fail_assertion("index too large");
    _jump2102:;
    int64_t _487 = 0;
    _487 *= _459.d0;
    _487 += i;
    _487 *= _459.d1;
    _487 += e;
    _487 *= _459.d2;
    _487 += _478;
    rgba _488 = _459.data[_487];
    _458 = _488;
    goto _jump2103;
    _jump2077:;
    rgba _489 = j();
    _458 = _489;
    _jump2103:;
    double _490 = _458.g;
    k _491 = { _454, e, _490 };
    _a3__a3_double _492 = _491.a;
    _a3_int64_t _493;
    // Computing bound for s
    int64_t _494 = _491.b;
    _493.d0 = _494;
    if (_494 > 0) 
    goto _jump2104;
    fail_assertion("non-positive loop bound");
    _jump2104:;
    // Computing bound for t
    _493.d1 = d;
    if (d > 0) 
    goto _jump2105;
    fail_assertion("non-positive loop bound");
    _jump2105:;
    // Computing bound for u
    _493.d2 = i;
    if (i > 0) 
    goto _jump2106;
    fail_assertion("non-positive loop bound");
    _jump2106:;
    // Computing total size of heap memory to allocate
    int64_t _495 = 1;
    _495 *= _494;
    _495 *= d;
    _495 *= i;
    _495 *= sizeof(int64_t);
    _493.data = jpl_alloc(_495);
    int64_t _496 = 0; // u
    int64_t _497 = 0; // t
    int64_t _498 = 0; // s
    _jump2107:; // Begin body of loop
    int64_t _499 = -_498;
    int64_t _500 = 0;
    _500 *= _493.d0;
    _500 += _498;
    _500 *= _493.d1;
    _500 += _497;
    _500 *= _493.d2;
    _500 += _496;
    _493.data[_500] = _499;
    _496++;
    if (_496 < i)
    goto _jump2107;
    _496 = 0;
    _497++;
    if (_497 < d)
    goto _jump2107;
    _497 = 0;
    _498++;
    if (_498 < _494)
    goto _jump2107;
    // End body of loop
    _a2_bool _501;
    // Computing bound for s
    int64_t _502 = 926;
    int64_t _503 = 716;
    int64_t _504 = _502 * _503;
    _501.d0 = _504;
    if (_504 > 0) 
    goto _jump2108;
    fail_assertion("non-positive loop bound");
    _jump2108:;
    // Computing bound for t
    int64_t _505 = _491.b;
    _501.d1 = _505;
    if (_505 > 0) 
    goto _jump2109;
    fail_assertion("non-positive loop bound");
    _jump2109:;
    // Computing total size of heap memory to allocate
    int64_t _506 = 1;
    _506 *= _504;
    _506 *= _505;
    _506 *= sizeof(bool);
    _501.data = jpl_alloc(_506);
    int64_t _507 = 0; // t
    int64_t _508 = 0; // s
    _jump2110:; // Begin body of loop
    bool _509 = true;
    int64_t _510 = 0;
    _510 *= _501.d0;
    _510 += _508;
    _510 *= _501.d1;
    _510 += _507;
    _501.data[_510] = _509;
    _507++;
    if (_507 < _505)
    goto _jump2110;
    _507 = 0;
    _508++;
    if (_508 < _504)
    goto _jump2110;
    // End body of loop
    int64_t _511;
    // Computing bound for s
    int64_t _512 = _491.b;
    if (_512 > 0) 
    goto _jump2111;
    fail_assertion("non-positive loop bound");
    _jump2111:;
    // Computing bound for t
    int64_t _513 = _491.b;
    if (_513 > 0) 
    goto _jump2112;
    fail_assertion("non-positive loop bound");
    _jump2112:;
    _511 = 0;
    int64_t _514 = 0; // t
    int64_t _515 = 0; // s
    _jump2113:; // Begin body of loop
    _511 += _514;
    _514++;
    if (_514 < _513)
    goto _jump2113;
    _514 = 0;
    _515++;
    if (_515 < _512)
    goto _jump2113;
    // End body of loop
    if (_511 >= 0)
    goto _jump2114;
    fail_assertion("negative array index");
    _jump2114:;
    if (_511 < _501.d0)
    goto _jump2115;
    fail_assertion("index too large");
    _jump2115:;
    if (d >= 0)
    goto _jump2116;
    fail_assertion("negative array index");
    _jump2116:;
    if (d < _501.d1)
    goto _jump2117;
    fail_assertion("index too large");
    _jump2117:;
    int64_t _516 = 0;
    _516 *= _501.d0;
    _516 += _511;
    _516 *= _501.d1;
    _516 += d;
    bool _517 = _501.data[_516];
    int64_t _518;
    if (!_517)
    goto _jump2118;
    g _519 = l();
    bool _520 = _519.a;
    _a3_int64_t _521;
    if (!_520)
    goto _jump2119;
    _a3_int64_t _522;
    // Computing bound for s
    _522.d0 = i;
    if (i > 0) 
    goto _jump2120;
    fail_assertion("non-positive loop bound");
    _jump2120:;
    // Computing bound for t
    _522.d1 = i;
    if (i > 0) 
    goto _jump2121;
    fail_assertion("non-positive loop bound");
    _jump2121:;
    // Computing bound for u
    int64_t _523 = 247;
    _522.d2 = _523;
    if (_523 > 0) 
    goto _jump2122;
    fail_assertion("non-positive loop bound");
    _jump2122:;
    // Computing total size of heap memory to allocate
    int64_t _524 = 1;
    _524 *= i;
    _524 *= i;
    _524 *= _523;
    _524 *= sizeof(int64_t);
    _522.data = jpl_alloc(_524);
    int64_t _525 = 0; // u
    int64_t _526 = 0; // t
    int64_t _527 = 0; // s
    _jump2123:; // Begin body of loop
    int64_t _528 = 482;
    int64_t _529 = 0;
    _529 *= _522.d0;
    _529 += _527;
    _529 *= _522.d1;
    _529 += _526;
    _529 *= _522.d2;
    _529 += _525;
    _522.data[_529] = _528;
    _525++;
    if (_525 < _523)
    goto _jump2123;
    _525 = 0;
    _526++;
    if (_526 < i)
    goto _jump2123;
    _526 = 0;
    _527++;
    if (_527 < i)
    goto _jump2123;
    // End body of loop
    _521 = _522;
    goto _jump2124;
    _jump2119:;
    _a3_int64_t _530;
    // Computing bound for s
    _530.d0 = e;
    if (e > 0) 
    goto _jump2125;
    fail_assertion("non-positive loop bound");
    _jump2125:;
    // Computing bound for t
    _530.d1 = d;
    if (d > 0) 
    goto _jump2126;
    fail_assertion("non-positive loop bound");
    _jump2126:;
    // Computing bound for u
    _530.d2 = e;
    if (e > 0) 
    goto _jump2127;
    fail_assertion("non-positive loop bound");
    _jump2127:;
    // Computing total size of heap memory to allocate
    int64_t _531 = 1;
    _531 *= e;
    _531 *= d;
    _531 *= e;
    _531 *= sizeof(int64_t);
    _530.data = jpl_alloc(_531);
    int64_t _532 = 0; // u
    int64_t _533 = 0; // t
    int64_t _534 = 0; // s
    _jump2128:; // Begin body of loop
    int64_t _535 = 0;
    _535 *= _530.d0;
    _535 += _534;
    _535 *= _530.d1;
    _535 += _533;
    _535 *= _530.d2;
    _535 += _532;
    _530.data[_535] = _533;
    _532++;
    if (_532 < e)
    goto _jump2128;
    _532 = 0;
    _533++;
    if (_533 < d)
    goto _jump2128;
    _533 = 0;
    _534++;
    if (_534 < e)
    goto _jump2128;
    // End body of loop
    _521 = _530;
    _jump2124:;
    g _536 = l();
    int64_t _537 = _536.b;
    int64_t _538 = 297;
    if (_537 >= 0)
    goto _jump2129;
    fail_assertion("negative array index");
    _jump2129:;
    if (_537 < _521.d0)
    goto _jump2130;
    fail_assertion("index too large");
    _jump2130:;
    if (i >= 0)
    goto _jump2131;
    fail_assertion("negative array index");
    _jump2131:;
    if (i < _521.d1)
    goto _jump2132;
    fail_assertion("index too large");
    _jump2132:;
    if (_538 >= 0)
    goto _jump2133;
    fail_assertion("negative array index");
    _jump2133:;
    if (_538 < _521.d2)
    goto _jump2134;
    fail_assertion("index too large");
    _jump2134:;
    int64_t _539 = 0;
    _539 *= _521.d0;
    _539 += _537;
    _539 *= _521.d1;
    _539 += i;
    _539 *= _521.d2;
    _539 += _538;
    int64_t _540 = _521.data[_539];
    _518 = _540;
    goto _jump2135;
    _jump2118:;
    int64_t _541 = _491.b;
    _518 = _541;
    _jump2135:;
    int64_t _542 = _491.b;
    if (_518 >= 0)
    goto _jump2136;
    fail_assertion("negative array index");
    _jump2136:;
    if (_518 < _493.d0)
    goto _jump2137;
    fail_assertion("index too large");
    _jump2137:;
    if (_542 >= 0)
    goto _jump2138;
    fail_assertion("negative array index");
    _jump2138:;
    if (_542 < _493.d1)
    goto _jump2139;
    fail_assertion("index too large");
    _jump2139:;
    if (d >= 0)
    goto _jump2140;
    fail_assertion("negative array index");
    _jump2140:;
    if (d < _493.d2)
    goto _jump2141;
    fail_assertion("index too large");
    _jump2141:;
    int64_t _543 = 0;
    _543 *= _493.d0;
    _543 += _518;
    _543 *= _493.d1;
    _543 += _542;
    _543 *= _493.d2;
    _543 += d;
    int64_t _544 = _493.data[_543];
    int64_t _545 = 262;
    int64_t _546 = -_545;
    int64_t _547 = _546 * i;
    int64_t _548 = 101;
    bool _549 = _547 >= _548;
    _a2_double _550;
    if (!_549)
    goto _jump2142;
    _a2_double _551;
    // Computing bound for s
    int64_t _552 = _491.b;
    _551.d0 = _552;
    if (_552 > 0) 
    goto _jump2143;
    fail_assertion("non-positive loop bound");
    _jump2143:;
    // Computing bound for t
    int64_t _553 = 918;
    int64_t _554 = -_553;
    _551.d1 = _554;
    if (_554 > 0) 
    goto _jump2144;
    fail_assertion("non-positive loop bound");
    _jump2144:;
    // Computing total size of heap memory to allocate
    int64_t _555 = 1;
    _555 *= _552;
    _555 *= _554;
    _555 *= sizeof(double);
    _551.data = jpl_alloc(_555);
    int64_t _556 = 0; // t
    int64_t _557 = 0; // s
    _jump2145:; // Begin body of loop
    double _558;
    // Computing bound for u
    if (d > 0) 
    goto _jump2146;
    fail_assertion("non-positive loop bound");
    _jump2146:;
    // Computing bound for v
    if (d > 0) 
    goto _jump2147;
    fail_assertion("non-positive loop bound");
    _jump2147:;
    // Computing bound for w
    if (i > 0) 
    goto _jump2148;
    fail_assertion("non-positive loop bound");
    _jump2148:;
    _558 = 0;
    int64_t _559 = 0; // w
    int64_t _560 = 0; // v
    int64_t _561 = 0; // u
    _jump2149:; // Begin body of loop
    double _562 = 47.0;
    _558 += _562;
    _559++;
    if (_559 < i)
    goto _jump2149;
    _559 = 0;
    _560++;
    if (_560 < d)
    goto _jump2149;
    _560 = 0;
    _561++;
    if (_561 < d)
    goto _jump2149;
    // End body of loop
    int64_t _563 = 0;
    _563 *= _551.d0;
    _563 += _557;
    _563 *= _551.d1;
    _563 += _556;
    _551.data[_563] = _558;
    _556++;
    if (_556 < _554)
    goto _jump2145;
    _556 = 0;
    _557++;
    if (_557 < _552)
    goto _jump2145;
    // End body of loop
    _550 = _551;
    goto _jump2150;
    _jump2142:;
    _a3__a2_double _564;
    // Computing bound for s
    _564.d0 = d;
    if (d > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    // Computing bound for t
    _564.d1 = e;
    if (e > 0) 
    goto _jump2152;
    fail_assertion("non-positive loop bound");
    _jump2152:;
    // Computing bound for u
    int64_t _565 = d % d;
    _564.d2 = _565;
    if (_565 > 0) 
    goto _jump2153;
    fail_assertion("non-positive loop bound");
    _jump2153:;
    // Computing total size of heap memory to allocate
    int64_t _566 = 1;
    _566 *= d;
    _566 *= e;
    _566 *= _565;
    _566 *= sizeof(_a2_double);
    _564.data = jpl_alloc(_566);
    int64_t _567 = 0; // u
    int64_t _568 = 0; // t
    int64_t _569 = 0; // s
    _jump2154:; // Begin body of loop
    _a2_double _570;
    // Computing bound for v
    _570.d0 = _569;
    if (_569 > 0) 
    goto _jump2155;
    fail_assertion("non-positive loop bound");
    _jump2155:;
    // Computing bound for w
    _570.d1 = e;
    if (e > 0) 
    goto _jump2156;
    fail_assertion("non-positive loop bound");
    _jump2156:;
    // Computing total size of heap memory to allocate
    int64_t _571 = 1;
    _571 *= _569;
    _571 *= e;
    _571 *= sizeof(double);
    _570.data = jpl_alloc(_571);
    int64_t _572 = 0; // w
    int64_t _573 = 0; // v
    _jump2157:; // Begin body of loop
    double _574 = 9.0;
    int64_t _575 = 0;
    _575 *= _570.d0;
    _575 += _573;
    _575 *= _570.d1;
    _575 += _572;
    _570.data[_575] = _574;
    _572++;
    if (_572 < e)
    goto _jump2157;
    _572 = 0;
    _573++;
    if (_573 < _569)
    goto _jump2157;
    // End body of loop
    int64_t _576 = 0;
    _576 *= _564.d0;
    _576 += _569;
    _576 *= _564.d1;
    _576 += _568;
    _576 *= _564.d2;
    _576 += _567;
    _564.data[_576] = _570;
    _567++;
    if (_567 < _565)
    goto _jump2154;
    _567 = 0;
    _568++;
    if (_568 < e)
    goto _jump2154;
    _568 = 0;
    _569++;
    if (_569 < d)
    goto _jump2154;
    // End body of loop
    int64_t _577 = 270;
    int64_t _578 = -i;
    if (_577 >= 0)
    goto _jump2158;
    fail_assertion("negative array index");
    _jump2158:;
    if (_577 < _564.d0)
    goto _jump2159;
    fail_assertion("index too large");
    _jump2159:;
    if (d >= 0)
    goto _jump2160;
    fail_assertion("negative array index");
    _jump2160:;
    if (d < _564.d1)
    goto _jump2161;
    fail_assertion("index too large");
    _jump2161:;
    if (_578 >= 0)
    goto _jump2162;
    fail_assertion("negative array index");
    _jump2162:;
    if (_578 < _564.d2)
    goto _jump2163;
    fail_assertion("index too large");
    _jump2163:;
    int64_t _579 = 0;
    _579 *= _564.d0;
    _579 += _577;
    _579 *= _564.d1;
    _579 += d;
    _579 *= _564.d2;
    _579 += _578;
    _a2_double _580 = _564.data[_579];
    _550 = _580;
    _jump2150:;
    int64_t _581 = _491.b;
    int64_t _582 = _581 * e;
    _a1_int64_t _583;
    // Computing bound for s
    _583.d0 = i;
    if (i > 0) 
    goto _jump2164;
    fail_assertion("non-positive loop bound");
    _jump2164:;
    // Computing total size of heap memory to allocate
    int64_t _584 = 1;
    _584 *= i;
    _584 *= sizeof(int64_t);
    _583.data = jpl_alloc(_584);
    int64_t _585 = 0; // s
    _jump2165:; // Begin body of loop
    int64_t _586;
    // Computing bound for t
    int64_t _587 = 212;
    if (_587 > 0) 
    goto _jump2166;
    fail_assertion("non-positive loop bound");
    _jump2166:;
    _586 = 0;
    int64_t _588 = 0; // t
    _jump2167:; // Begin body of loop
    int64_t _589 = 163;
    _586 += _589;
    _588++;
    if (_588 < _587)
    goto _jump2167;
    // End body of loop
    int64_t _590 = 0;
    _590 *= _583.d0;
    _590 += _585;
    _583.data[_590] = _586;
    _585++;
    if (_585 < i)
    goto _jump2165;
    // End body of loop
    g _591 = l();
    int64_t _592 = _591.b;
    int64_t _593 = e * _592;
    if (_593 >= 0)
    goto _jump2168;
    fail_assertion("negative array index");
    _jump2168:;
    if (_593 < _583.d0)
    goto _jump2169;
    fail_assertion("index too large");
    _jump2169:;
    int64_t _594 = 0;
    _594 *= _583.d0;
    _594 += _593;
    int64_t _595 = _583.data[_594];
    int64_t _596 = _582 % _595;
    int64_t _597 = d - d;
    int64_t _598;
    // Computing bound for s
    if (i > 0) 
    goto _jump2170;
    fail_assertion("non-positive loop bound");
    _jump2170:;
    _598 = 0;
    int64_t _599 = 0; // s
    _jump2171:; // Begin body of loop
    int64_t _600 = 526;
    _598 += _600;
    _599++;
    if (_599 < i)
    goto _jump2171;
    // End body of loop
    bool _601 = _597 >= _598;
    int64_t _602 = _491.b;
    g _603 = { _601, _602 };
    int64_t _604 = _603.b;
    if (_596 >= 0)
    goto _jump2172;
    fail_assertion("negative array index");
    _jump2172:;
    if (_596 < _550.d0)
    goto _jump2173;
    fail_assertion("index too large");
    _jump2173:;
    if (_604 >= 0)
    goto _jump2174;
    fail_assertion("negative array index");
    _jump2174:;
    if (_604 < _550.d1)
    goto _jump2175;
    fail_assertion("index too large");
    _jump2175:;
    int64_t _605 = 0;
    _605 *= _550.d0;
    _605 += _596;
    _605 *= _550.d1;
    _605 += _604;
    double _606 = _550.data[_605];
    k _607 = { _492, _544, _606 };
    double _608 = _607.c;
}

double z() {
    bool _0 = false;
    _a3_bool _1;
    if (!_0)
    goto _jump2338;
    _a3_bool _2;
    // Computing bound for C
    int64_t _3;
    // Computing bound for C
    int64_t _4 = t + y;
    int64_t _5 = -_4;
    if (_5 > 0) 
    goto _jump2339;
    fail_assertion("non-positive loop bound");
    _jump2339:;
    // Computing bound for D
    int64_t _6 = 907;
    int64_t _7 = r + _6;
    if (_7 > 0) 
    goto _jump2340;
    fail_assertion("non-positive loop bound");
    _jump2340:;
    _3 = 0;
    int64_t _8 = 0; // D
    int64_t _9 = 0; // C
    _jump2341:; // Begin body of loop
    _3 += _8;
    _8++;
    if (_8 < _7)
    goto _jump2341;
    _8 = 0;
    _9++;
    if (_9 < _5)
    goto _jump2341;
    // End body of loop
    _2.d0 = _3;
    if (_3 > 0) 
    goto _jump2342;
    fail_assertion("non-positive loop bound");
    _jump2342:;
    // Computing bound for D
    _2.d1 = x.d0;
    if (x.d0 > 0) 
    goto _jump2343;
    fail_assertion("non-positive loop bound");
    _jump2343:;
    // Computing bound for E
    _2.d2 = y;
    if (y > 0) 
    goto _jump2344;
    fail_assertion("non-positive loop bound");
    _jump2344:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _3;
    _10 *= x.d0;
    _10 *= y;
    _10 *= sizeof(bool);
    _2.data = jpl_alloc(_10);
    int64_t _11 = 0; // E
    int64_t _12 = 0; // D
    int64_t _13 = 0; // C
    _jump2345:; // Begin body of loop
    _a2_bool _14;
    // Computing bound for F
    int64_t _15 = _13 % q;
    _14.d0 = _15;
    if (_15 > 0) 
    goto _jump2346;
    fail_assertion("non-positive loop bound");
    _jump2346:;
    // Computing bound for G
    _14.d1 = t;
    if (t > 0) 
    goto _jump2347;
    fail_assertion("non-positive loop bound");
    _jump2347:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _15;
    _16 *= t;
    _16 *= sizeof(bool);
    _14.data = jpl_alloc(_16);
    int64_t _17 = 0; // G
    int64_t _18 = 0; // F
    _jump2348:; // Begin body of loop
    bool _19 = true;
    int64_t _20 = 0;
    _20 *= _14.d0;
    _20 += _18;
    _20 *= _14.d1;
    _20 += _17;
    _14.data[_20] = _19;
    _17++;
    if (_17 < t)
    goto _jump2348;
    _17 = 0;
    _18++;
    if (_18 < _15)
    goto _jump2348;
    // End body of loop
    int64_t _21 = 81;
    int64_t _22 = _12 * _21;
    if (x.d0 >= 0)
    goto _jump2349;
    fail_assertion("negative array index");
    _jump2349:;
    if (x.d0 < _14.d0)
    goto _jump2350;
    fail_assertion("index too large");
    _jump2350:;
    if (_22 >= 0)
    goto _jump2351;
    fail_assertion("negative array index");
    _jump2351:;
    if (_22 < _14.d1)
    goto _jump2352;
    fail_assertion("index too large");
    _jump2352:;
    int64_t _23 = 0;
    _23 *= _14.d0;
    _23 += x.d0;
    _23 *= _14.d1;
    _23 += _22;
    bool _24 = _14.data[_23];
    int64_t _25 = 0;
    _25 *= _2.d0;
    _25 += _13;
    _25 *= _2.d1;
    _25 += _12;
    _25 *= _2.d2;
    _25 += _11;
    _2.data[_25] = _24;
    _11++;
    if (_11 < y)
    goto _jump2345;
    _11 = 0;
    _12++;
    if (_12 < x.d0)
    goto _jump2345;
    _12 = 0;
    _13++;
    if (_13 < _3)
    goto _jump2345;
    // End body of loop
    _1 = _2;
    goto _jump2353;
    _jump2338:;
    _a3_bool _26;
    // Computing bound for C
    _26.d0 = r;
    if (r > 0) 
    goto _jump2354;
    fail_assertion("non-positive loop bound");
    _jump2354:;
    // Computing bound for D
    _26.d1 = d;
    if (d > 0) 
    goto _jump2355;
    fail_assertion("non-positive loop bound");
    _jump2355:;
    // Computing bound for E
    _26.d2 = q;
    if (q > 0) 
    goto _jump2356;
    fail_assertion("non-positive loop bound");
    _jump2356:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= r;
    _27 *= d;
    _27 *= q;
    _27 *= sizeof(bool);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // E
    int64_t _29 = 0; // D
    int64_t _30 = 0; // C
    _jump2357:; // Begin body of loop
    bool _31 = i != _29;
    bool _32;
    if (!_31)
    goto _jump2358;
    bool _33 = true;
    bool _34 = !_33;
    bool _35 = !_34;
    bool _36 = true;
    g _37 = { _36, y };
    bool _38 = _37.a;
    bool _39 = _35 == _38;
    _32 = _39;
    goto _jump2359;
    _jump2358:;
    _32 = a;
    _jump2359:;
    int64_t _40 = 0;
    _40 *= _26.d0;
    _40 += _30;
    _40 *= _26.d1;
    _40 += _29;
    _40 *= _26.d2;
    _40 += _28;
    _26.data[_40] = _32;
    _28++;
    if (_28 < q)
    goto _jump2357;
    _28 = 0;
    _29++;
    if (_29 < d)
    goto _jump2357;
    _29 = 0;
    _30++;
    if (_30 < r)
    goto _jump2357;
    // End body of loop
    _1 = _26;
    _jump2353:;
    _a3__a3_double _41;
    // Computing bound for C
    _41.d0 = q;
    if (q > 0) 
    goto _jump2360;
    fail_assertion("non-positive loop bound");
    _jump2360:;
    // Computing bound for D
    int64_t _42 = 924;
    _41.d1 = _42;
    if (_42 > 0) 
    goto _jump2361;
    fail_assertion("non-positive loop bound");
    _jump2361:;
    // Computing bound for E
    _41.d2 = e;
    if (e > 0) 
    goto _jump2362;
    fail_assertion("non-positive loop bound");
    _jump2362:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= q;
    _43 *= _42;
    _43 *= e;
    _43 *= sizeof(_a3_double);
    _41.data = jpl_alloc(_43);
    int64_t _44 = 0; // E
    int64_t _45 = 0; // D
    int64_t _46 = 0; // C
    _jump2363:; // Begin body of loop
    _a3_double _47;
    // Computing bound for F
    _47.d0 = x.d0;
    if (x.d0 > 0) 
    goto _jump2364;
    fail_assertion("non-positive loop bound");
    _jump2364:;
    // Computing bound for G
    _47.d1 = i;
    if (i > 0) 
    goto _jump2365;
    fail_assertion("non-positive loop bound");
    _jump2365:;
    // Computing bound for H
    _47.d2 = x.d0;
    if (x.d0 > 0) 
    goto _jump2366;
    fail_assertion("non-positive loop bound");
    _jump2366:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= x.d0;
    _48 *= i;
    _48 *= x.d0;
    _48 *= sizeof(double);
    _47.data = jpl_alloc(_48);
    int64_t _49 = 0; // H
    int64_t _50 = 0; // G
    int64_t _51 = 0; // F
    _jump2367:; // Begin body of loop
    double _52 = 70.0;
    int64_t _53 = 0;
    _53 *= _47.d0;
    _53 += _51;
    _53 *= _47.d1;
    _53 += _50;
    _53 *= _47.d2;
    _53 += _49;
    _47.data[_53] = _52;
    _49++;
    if (_49 < x.d0)
    goto _jump2367;
    _49 = 0;
    _50++;
    if (_50 < i)
    goto _jump2367;
    _50 = 0;
    _51++;
    if (_51 < x.d0)
    goto _jump2367;
    // End body of loop
    int64_t _54 = 0;
    _54 *= _41.d0;
    _54 += _46;
    _54 *= _41.d1;
    _54 += _45;
    _54 *= _41.d2;
    _54 += _44;
    _41.data[_54] = _47;
    _44++;
    if (_44 < e)
    goto _jump2363;
    _44 = 0;
    _45++;
    if (_45 < _42)
    goto _jump2363;
    _45 = 0;
    _46++;
    if (_46 < q)
    goto _jump2363;
    // End body of loop
    int64_t _55 = -u;
    double _56 = 98.0;
    double _57 = -_56;
    k _58 = { _41, _55, _57 };
    int64_t _59 = _58.b;
    if (e >= 0)
    goto _jump2368;
    fail_assertion("negative array index");
    _jump2368:;
    if (e < m.d0)
    goto _jump2369;
    fail_assertion("index too large");
    _jump2369:;
    if (_59 >= 0)
    goto _jump2370;
    fail_assertion("negative array index");
    _jump2370:;
    if (_59 < m.d1)
    goto _jump2371;
    fail_assertion("index too large");
    _jump2371:;
    int64_t _60 = 0;
    _60 *= m.d0;
    _60 += e;
    _60 *= m.d1;
    _60 += _59;
    bool _61 = m.data[_60];
    int64_t _62;
    if (!_61)
    goto _jump2372;
    _62 = t;
    goto _jump2373;
    _jump2372:;
    _62 = x.d0;
    _jump2373:;
    bool _63 = true;
    int64_t _64 = 459;
    g _65 = { _63, _64 };
    bool _66 = _65.a;
    bool _67;
    if (!_66)
    goto _jump2374;
    bool _69 = true;
    bool _70;
    if (!_69)
    goto _jump2375;
    bool _71 = true;
    _70 = _71;
    goto _jump2376;
    _jump2375:;
    bool _72 = true;
    _70 = _72;
    _jump2376:;
    bool _68 = _70;
    if (0 != _70)
    goto _jump2377;
    bool _73 = false;
    _68 = _73;
    _jump2377:;
    _67 = _68;
    goto _jump2378;
    _jump2374:;
    bool _74 = true;
    _67 = _74;
    _jump2378:;
    bool _75 = !_67;
    _a1_int64_t _76;
    if (!_75)
    goto _jump2379;
    _76 = x;
    goto _jump2380;
    _jump2379:;
    _a1_int64_t _77;
    // Computing bound for C
    _77.d0 = x.d0;
    if (x.d0 > 0) 
    goto _jump2381;
    fail_assertion("non-positive loop bound");
    _jump2381:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= x.d0;
    _78 *= sizeof(int64_t);
    _77.data = jpl_alloc(_78);
    int64_t _79 = 0; // C
    _jump2382:; // Begin body of loop
    int64_t _80 = -i;
    int64_t _81 = 0;
    _81 *= _77.d0;
    _81 += _79;
    _77.data[_81] = _80;
    _79++;
    if (_79 < x.d0)
    goto _jump2382;
    // End body of loop
    _76 = _77;
    _jump2380:;
    int64_t _82 = 953;
    if (_82 >= 0)
    goto _jump2383;
    fail_assertion("negative array index");
    _jump2383:;
    if (_82 < _76.d0)
    goto _jump2384;
    fail_assertion("index too large");
    _jump2384:;
    int64_t _83 = 0;
    _83 *= _76.d0;
    _83 += _82;
    int64_t _84 = _76.data[_83];
    if (_62 >= 0)
    goto _jump2385;
    fail_assertion("negative array index");
    _jump2385:;
    if (_62 < _1.d0)
    goto _jump2386;
    fail_assertion("index too large");
    _jump2386:;
    if (_84 >= 0)
    goto _jump2387;
    fail_assertion("negative array index");
    _jump2387:;
    if (_84 < _1.d1)
    goto _jump2388;
    fail_assertion("index too large");
    _jump2388:;
    if (t >= 0)
    goto _jump2389;
    fail_assertion("negative array index");
    _jump2389:;
    if (t < _1.d2)
    goto _jump2390;
    fail_assertion("index too large");
    _jump2390:;
    int64_t _85 = 0;
    _85 *= _1.d0;
    _85 += _62;
    _85 *= _1.d1;
    _85 += _84;
    _85 *= _1.d2;
    _85 += t;
    bool _86 = _1.data[_85];
    if (0 != _86)
    goto _jump2391;
    fail_assertion("C");
    _jump2391:;
    double _87 = z();
    return _87;
    rgba _88 = j();
    double _89 = _88.g;
    _a2_double _90;
    // Computing bound for C
    _90.d0 = x.d0;
    if (x.d0 > 0) 
    goto _jump2392;
    fail_assertion("non-positive loop bound");
    _jump2392:;
    // Computing bound for D
    int64_t _91 = -r;
    _90.d1 = _91;
    if (_91 > 0) 
    goto _jump2393;
    fail_assertion("non-positive loop bound");
    _jump2393:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= x.d0;
    _92 *= _91;
    _92 *= sizeof(double);
    _90.data = jpl_alloc(_92);
    int64_t _93 = 0; // D
    int64_t _94 = 0; // C
    _jump2394:; // Begin body of loop
    double _95 = z();
    double _96 = 67.0;
    double _97 = _95 - _96;
    int64_t _98 = 0;
    _98 *= _90.d0;
    _98 += _94;
    _98 *= _90.d1;
    _98 += _93;
    _90.data[_98] = _97;
    _93++;
    if (_93 < _91)
    goto _jump2394;
    _93 = 0;
    _94++;
    if (_94 < x.d0)
    goto _jump2394;
    // End body of loop
    bool _99 = f(_89, _90);
    bool _100 = !_99;
    bool _101 = !_100;
    _a3_double _102;
    if (!_101)
    goto _jump2395;
    double _104 = z();
    bool _105 = a;
    if (0 != a)
    goto _jump2396;
    bool _106 = !a;
    _105 = _106;
    _jump2396:;
    _a2_double _107;
    if (!_105)
    goto _jump2397;
    _a2_double _108;
    // Computing bound for C
    bool _109 = false;
    int64_t _110;
    if (!_109)
    goto _jump2398;
    _110 = x.d0;
    goto _jump2399;
    _jump2398:;
    _110 = y;
    _jump2399:;
    _108.d0 = _110;
    if (_110 > 0) 
    goto _jump2400;
    fail_assertion("non-positive loop bound");
    _jump2400:;
    // Computing bound for D
    _108.d1 = q;
    if (q > 0) 
    goto _jump2401;
    fail_assertion("non-positive loop bound");
    _jump2401:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= _110;
    _111 *= q;
    _111 *= sizeof(double);
    _108.data = jpl_alloc(_111);
    int64_t _112 = 0; // D
    int64_t _113 = 0; // C
    _jump2402:; // Begin body of loop
    double _114 = z();
    double _115 = -_114;
    int64_t _116 = 0;
    _116 *= _108.d0;
    _116 += _113;
    _116 *= _108.d1;
    _116 += _112;
    _108.data[_116] = _115;
    _112++;
    if (_112 < q)
    goto _jump2402;
    _112 = 0;
    _113++;
    if (_113 < _110)
    goto _jump2402;
    // End body of loop
    _107 = _108;
    goto _jump2403;
    _jump2397:;
    _a2_double _117;
    // Computing bound for C
    _117.d0 = q;
    if (q > 0) 
    goto _jump2404;
    fail_assertion("non-positive loop bound");
    _jump2404:;
    // Computing bound for D
    _117.d1 = y;
    if (y > 0) 
    goto _jump2405;
    fail_assertion("non-positive loop bound");
    _jump2405:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= q;
    _118 *= y;
    _118 *= sizeof(double);
    _117.data = jpl_alloc(_118);
    int64_t _119 = 0; // D
    int64_t _120 = 0; // C
    _jump2406:; // Begin body of loop
    double _121 = 6.0;
    int64_t _122 = 0;
    _122 *= _117.d0;
    _122 += _120;
    _122 *= _117.d1;
    _122 += _119;
    _117.data[_122] = _121;
    _119++;
    if (_119 < y)
    goto _jump2406;
    _119 = 0;
    _120++;
    if (_120 < q)
    goto _jump2406;
    // End body of loop
    _107 = _117;
    _jump2403:;
    bool _123 = f(_104, _107);
    bool _103 = _123;
    if (0 != _123)
    goto _jump2407;
    rgba _124 = j();
    double _125 = _124.a;
    _a2_double _126;
    // Computing bound for C
    int64_t _127 = 258;
    _126.d0 = _127;
    if (_127 > 0) 
    goto _jump2408;
    fail_assertion("non-positive loop bound");
    _jump2408:;
    // Computing bound for D
    _126.d1 = e;
    if (e > 0) 
    goto _jump2409;
    fail_assertion("non-positive loop bound");
    _jump2409:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _127;
    _128 *= e;
    _128 *= sizeof(double);
    _126.data = jpl_alloc(_128);
    int64_t _129 = 0; // D
    int64_t _130 = 0; // C
    _jump2410:; // Begin body of loop
    double _131 = 38.0;
    int64_t _132 = 0;
    _132 *= _126.d0;
    _132 += _130;
    _132 *= _126.d1;
    _132 += _129;
    _126.data[_132] = _131;
    _129++;
    if (_129 < e)
    goto _jump2410;
    _129 = 0;
    _130++;
    if (_130 < _127)
    goto _jump2410;
    // End body of loop
    bool _133 = f(_125, _126);
    int64_t _134 = 619;
    g _135 = { _133, _134 };
    bool _136 = _135.a;
    _103 = _136;
    _jump2407:;
    _a3_double _137;
    if (!_103)
    goto _jump2411;
    _a3__a3_double _138;
    // Computing bound for C
    int64_t _139 = 289;
    g _140 = { a, _139 };
    int64_t _141 = _140.b;
    _138.d0 = _141;
    if (_141 > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    // Computing bound for D
    bool _142 = true;
    _a2_int64_t _143;
    if (!_142)
    goto _jump2413;
    _a2_int64_t _144;
    // Computing bound for C
    _144.d0 = x.d0;
    if (x.d0 > 0) 
    goto _jump2414;
    fail_assertion("non-positive loop bound");
    _jump2414:;
    // Computing bound for D
    _144.d1 = q;
    if (q > 0) 
    goto _jump2415;
    fail_assertion("non-positive loop bound");
    _jump2415:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= x.d0;
    _145 *= q;
    _145 *= sizeof(int64_t);
    _144.data = jpl_alloc(_145);
    int64_t _146 = 0; // D
    int64_t _147 = 0; // C
    _jump2416:; // Begin body of loop
    int64_t _148 = 0;
    _148 *= _144.d0;
    _148 += _147;
    _148 *= _144.d1;
    _148 += _146;
    _144.data[_148] = d;
    _146++;
    if (_146 < q)
    goto _jump2416;
    _146 = 0;
    _147++;
    if (_147 < x.d0)
    goto _jump2416;
    // End body of loop
    _143 = _144;
    goto _jump2417;
    _jump2413:;
    _a2_int64_t _149;
    // Computing bound for C
    _149.d0 = e;
    if (e > 0) 
    goto _jump2418;
    fail_assertion("non-positive loop bound");
    _jump2418:;
    // Computing bound for D
    _149.d1 = x.d0;
    if (x.d0 > 0) 
    goto _jump2419;
    fail_assertion("non-positive loop bound");
    _jump2419:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= e;
    _150 *= x.d0;
    _150 *= sizeof(int64_t);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // D
    int64_t _152 = 0; // C
    _jump2420:; // Begin body of loop
    int64_t _153 = 0;
    _153 *= _149.d0;
    _153 += _152;
    _153 *= _149.d1;
    _153 += _151;
    _149.data[_153] = u;
    _151++;
    if (_151 < x.d0)
    goto _jump2420;
    _151 = 0;
    _152++;
    if (_152 < e)
    goto _jump2420;
    // End body of loop
    _143 = _149;
    _jump2417:;
    int64_t _154;
    // Computing bound for C
    int64_t _155 = -u;
    if (_155 > 0) 
    goto _jump2421;
    fail_assertion("non-positive loop bound");
    _jump2421:;
    // Computing bound for D
    if (x.d0 > 0) 
    goto _jump2422;
    fail_assertion("non-positive loop bound");
    _jump2422:;
    // Computing bound for E
    if (x.d0 > 0) 
    goto _jump2423;
    fail_assertion("non-positive loop bound");
    _jump2423:;
    _154 = 0;
    int64_t _156 = 0; // E
    int64_t _157 = 0; // D
    int64_t _158 = 0; // C
    _jump2424:; // Begin body of loop
    _154 += d;
    _156++;
    if (_156 < x.d0)
    goto _jump2424;
    _156 = 0;
    _157++;
    if (_157 < x.d0)
    goto _jump2424;
    _157 = 0;
    _158++;
    if (_158 < _155)
    goto _jump2424;
    // End body of loop
    if (t >= 0)
    goto _jump2425;
    fail_assertion("negative array index");
    _jump2425:;
    if (t < m.d0)
    goto _jump2426;
    fail_assertion("index too large");
    _jump2426:;
    if (y >= 0)
    goto _jump2427;
    fail_assertion("negative array index");
    _jump2427:;
    if (y < m.d1)
    goto _jump2428;
    fail_assertion("index too large");
    _jump2428:;
    int64_t _159 = 0;
    _159 *= m.d0;
    _159 += t;
    _159 *= m.d1;
    _159 += y;
    bool _160 = m.data[_159];
    int64_t _161;
    if (!_160)
    goto _jump2429;
    int64_t _162 = -e;
    _161 = _162;
    goto _jump2430;
    _jump2429:;
    int64_t _163 = -d;
    _161 = _163;
    _jump2430:;
    if (_154 >= 0)
    goto _jump2431;
    fail_assertion("negative array index");
    _jump2431:;
    if (_154 < _143.d0)
    goto _jump2432;
    fail_assertion("index too large");
    _jump2432:;
    if (_161 >= 0)
    goto _jump2433;
    fail_assertion("negative array index");
    _jump2433:;
    if (_161 < _143.d1)
    goto _jump2434;
    fail_assertion("index too large");
    _jump2434:;
    int64_t _164 = 0;
    _164 *= _143.d0;
    _164 += _154;
    _164 *= _143.d1;
    _164 += _161;
    int64_t _165 = _143.data[_164];
    _138.d1 = _165;
    if (_165 > 0) 
    goto _jump2435;
    fail_assertion("non-positive loop bound");
    _jump2435:;
    // Computing bound for E
    _138.d2 = q;
    if (q > 0) 
    goto _jump2436;
    fail_assertion("non-positive loop bound");
    _jump2436:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= _141;
    _166 *= _165;
    _166 *= q;
    _166 *= sizeof(_a3_double);
    _138.data = jpl_alloc(_166);
    int64_t _167 = 0; // E
    int64_t _168 = 0; // D
    int64_t _169 = 0; // C
    _jump2437:; // Begin body of loop
    _a3_double _170;
    // Computing bound for F
    _170.d0 = r;
    if (r > 0) 
    goto _jump2438;
    fail_assertion("non-positive loop bound");
    _jump2438:;
    // Computing bound for G
    _170.d1 = _168;
    if (_168 > 0) 
    goto _jump2439;
    fail_assertion("non-positive loop bound");
    _jump2439:;
    // Computing bound for H
    _170.d2 = _168;
    if (_168 > 0) 
    goto _jump2440;
    fail_assertion("non-positive loop bound");
    _jump2440:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= r;
    _171 *= _168;
    _171 *= _168;
    _171 *= sizeof(double);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // H
    int64_t _173 = 0; // G
    int64_t _174 = 0; // F
    _jump2441:; // Begin body of loop
    double _175 = 48.0;
    int64_t _176 = 0;
    _176 *= _170.d0;
    _176 += _174;
    _176 *= _170.d1;
    _176 += _173;
    _176 *= _170.d2;
    _176 += _172;
    _170.data[_176] = _175;
    _172++;
    if (_172 < _168)
    goto _jump2441;
    _172 = 0;
    _173++;
    if (_173 < _168)
    goto _jump2441;
    _173 = 0;
    _174++;
    if (_174 < r)
    goto _jump2441;
    // End body of loop
    int64_t _177 = 0;
    _177 *= _138.d0;
    _177 += _169;
    _177 *= _138.d1;
    _177 += _168;
    _177 *= _138.d2;
    _177 += _167;
    _138.data[_177] = _170;
    _167++;
    if (_167 < q)
    goto _jump2437;
    _167 = 0;
    _168++;
    if (_168 < _165)
    goto _jump2437;
    _168 = 0;
    _169++;
    if (_169 < _141)
    goto _jump2437;
    // End body of loop
    int64_t _178 = t - r;
    int64_t _179 = e + _178;
    g _180 = l();
    bool _181 = _180.a;
    g _182 = l();
    int64_t _183 = _182.b;
    g _184 = { _181, _183 };
    int64_t _185 = _184.b;
    if (_179 >= 0)
    goto _jump2442;
    fail_assertion("negative array index");
    _jump2442:;
    if (_179 < _138.d0)
    goto _jump2443;
    fail_assertion("index too large");
    _jump2443:;
    if (_185 >= 0)
    goto _jump2444;
    fail_assertion("negative array index");
    _jump2444:;
    if (_185 < _138.d1)
    goto _jump2445;
    fail_assertion("index too large");
    _jump2445:;
    if (d >= 0)
    goto _jump2446;
    fail_assertion("negative array index");
    _jump2446:;
    if (d < _138.d2)
    goto _jump2447;
    fail_assertion("index too large");
    _jump2447:;
    int64_t _186 = 0;
    _186 *= _138.d0;
    _186 += _179;
    _186 *= _138.d1;
    _186 += _185;
    _186 *= _138.d2;
    _186 += d;
    _a3_double _187 = _138.data[_186];
    _137 = _187;
    goto _jump2448;
    _jump2411:;
    int64_t _188 = 636;
    if (_188 >= 0)
    goto _jump2449;
    fail_assertion("negative array index");
    _jump2449:;
    if (_188 < p.d0)
    goto _jump2450;
    fail_assertion("index too large");
    _jump2450:;
    if (d >= 0)
    goto _jump2451;
    fail_assertion("negative array index");
    _jump2451:;
    if (d < p.d1)
    goto _jump2452;
    fail_assertion("index too large");
    _jump2452:;
    int64_t _189 = 0;
    _189 *= p.d0;
    _189 += _188;
    _189 *= p.d1;
    _189 += d;
    bool _190 = p.data[_189];
    bool _191;
    if (!_190)
    goto _jump2453;
    bool _192 = r != i;
    _a2_bool _193;
    if (!_192)
    goto _jump2454;
    _193 = c;
    goto _jump2455;
    _jump2454:;
    _a2_bool _194;
    // Computing bound for C
    _194.d0 = e;
    if (e > 0) 
    goto _jump2456;
    fail_assertion("non-positive loop bound");
    _jump2456:;
    // Computing bound for D
    _194.d1 = x.d0;
    if (x.d0 > 0) 
    goto _jump2457;
    fail_assertion("non-positive loop bound");
    _jump2457:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= e;
    _195 *= x.d0;
    _195 *= sizeof(bool);
    _194.data = jpl_alloc(_195);
    int64_t _196 = 0; // D
    int64_t _197 = 0; // C
    _jump2458:; // Begin body of loop
    bool _198 = false;
    int64_t _199 = 0;
    _199 *= _194.d0;
    _199 += _197;
    _199 *= _194.d1;
    _199 += _196;
    _194.data[_199] = _198;
    _196++;
    if (_196 < x.d0)
    goto _jump2458;
    _196 = 0;
    _197++;
    if (_197 < e)
    goto _jump2458;
    // End body of loop
    _193 = _194;
    _jump2455:;
    int64_t _200;
    // Computing bound for C
    int64_t _201;
    if (!a)
    goto _jump2459;
    _201 = i;
    goto _jump2460;
    _jump2459:;
    _201 = u;
    _jump2460:;
    if (_201 > 0) 
    goto _jump2461;
    fail_assertion("non-positive loop bound");
    _jump2461:;
    _200 = 0;
    int64_t _202 = 0; // C
    _jump2462:; // Begin body of loop
    _200 += d;
    _202++;
    if (_202 < _201)
    goto _jump2462;
    // End body of loop
    if (_200 >= 0)
    goto _jump2463;
    fail_assertion("negative array index");
    _jump2463:;
    if (_200 < _193.d0)
    goto _jump2464;
    fail_assertion("index too large");
    _jump2464:;
    if (i >= 0)
    goto _jump2465;
    fail_assertion("negative array index");
    _jump2465:;
    if (i < _193.d1)
    goto _jump2466;
    fail_assertion("index too large");
    _jump2466:;
    int64_t _203 = 0;
    _203 *= _193.d0;
    _203 += _200;
    _203 *= _193.d1;
    _203 += i;
    bool _204 = _193.data[_203];
    _191 = _204;
    goto _jump2467;
    _jump2453:;
    double _205;
    // Computing bound for C
    if (d > 0) 
    goto _jump2468;
    fail_assertion("non-positive loop bound");
    _jump2468:;
    _205 = 0;
    int64_t _206 = 0; // C
    _jump2469:; // Begin body of loop
    double _207 = z();
    _205 += _207;
    _206++;
    if (_206 < d)
    goto _jump2469;
    // End body of loop
    double _208 = -_205;
    double _209 = z();
    bool _210 = _208 >= _209;
    _191 = _210;
    _jump2467:;
    _a3_double _211;
    if (!_191)
    goto _jump2470;
    _a3_double _212;
    // Computing bound for C
    _212.d0 = i;
    if (i > 0) 
    goto _jump2471;
    fail_assertion("non-positive loop bound");
    _jump2471:;
    // Computing bound for D
    g _213 = l();
    w _214 = { _213 };
    g _215 = _214.a;
    int64_t _216 = _215.b;
    _212.d1 = _216;
    if (_216 > 0) 
    goto _jump2472;
    fail_assertion("non-positive loop bound");
    _jump2472:;
    // Computing bound for E
    _212.d2 = q;
    if (q > 0) 
    goto _jump2473;
    fail_assertion("non-positive loop bound");
    _jump2473:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= i;
    _217 *= _216;
    _217 *= q;
    _217 *= sizeof(double);
    _212.data = jpl_alloc(_217);
    int64_t _218 = 0; // E
    int64_t _219 = 0; // D
    int64_t _220 = 0; // C
    _jump2474:; // Begin body of loop
    double _221 = z();
    int64_t _222 = 0;
    _222 *= _212.d0;
    _222 += _220;
    _222 *= _212.d1;
    _222 += _219;
    _222 *= _212.d2;
    _222 += _218;
    _212.data[_222] = _221;
    _218++;
    if (_218 < q)
    goto _jump2474;
    _218 = 0;
    _219++;
    if (_219 < _216)
    goto _jump2474;
    _219 = 0;
    _220++;
    if (_220 < i)
    goto _jump2474;
    // End body of loop
    _211 = _212;
    goto _jump2475;
    _jump2470:;
    _a3__a3_double _223;
    // Computing bound for C
    _223.d0 = y;
    if (y > 0) 
    goto _jump2476;
    fail_assertion("non-positive loop bound");
    _jump2476:;
    // Computing bound for D
    _223.d1 = t;
    if (t > 0) 
    goto _jump2477;
    fail_assertion("non-positive loop bound");
    _jump2477:;
    // Computing bound for E
    _223.d2 = d;
    if (d > 0) 
    goto _jump2478;
    fail_assertion("non-positive loop bound");
    _jump2478:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= y;
    _224 *= t;
    _224 *= d;
    _224 *= sizeof(_a3_double);
    _223.data = jpl_alloc(_224);
    int64_t _225 = 0; // E
    int64_t _226 = 0; // D
    int64_t _227 = 0; // C
    _jump2479:; // Begin body of loop
    _a3_double _228;
    // Computing bound for F
    int64_t _229;
    // Computing bound for F
    if (_227 > 0) 
    goto _jump2480;
    fail_assertion("non-positive loop bound");
    _jump2480:;
    _229 = 0;
    int64_t _230 = 0; // F
    _jump2481:; // Begin body of loop
    _229 += r;
    _230++;
    if (_230 < _227)
    goto _jump2481;
    // End body of loop
    _228.d0 = _229;
    if (_229 > 0) 
    goto _jump2482;
    fail_assertion("non-positive loop bound");
    _jump2482:;
    // Computing bound for G
    g _231 = l();
    int64_t _232 = _231.b;
    _228.d1 = _232;
    if (_232 > 0) 
    goto _jump2483;
    fail_assertion("non-positive loop bound");
    _jump2483:;
    // Computing bound for H
    int64_t _233 = 371;
    int64_t _234 = t % _233;
    _228.d2 = _234;
    if (_234 > 0) 
    goto _jump2484;
    fail_assertion("non-positive loop bound");
    _jump2484:;
    // Computing total size of heap memory to allocate
    int64_t _235 = 1;
    _235 *= _229;
    _235 *= _232;
    _235 *= _234;
    _235 *= sizeof(double);
    _228.data = jpl_alloc(_235);
    int64_t _236 = 0; // H
    int64_t _237 = 0; // G
    int64_t _238 = 0; // F
    _jump2485:; // Begin body of loop
    double _239 = 39.0;
    int64_t _240 = 0;
    _240 *= _228.d0;
    _240 += _238;
    _240 *= _228.d1;
    _240 += _237;
    _240 *= _228.d2;
    _240 += _236;
    _228.data[_240] = _239;
    _236++;
    if (_236 < _234)
    goto _jump2485;
    _236 = 0;
    _237++;
    if (_237 < _232)
    goto _jump2485;
    _237 = 0;
    _238++;
    if (_238 < _229)
    goto _jump2485;
    // End body of loop
    int64_t _241 = 0;
    _241 *= _223.d0;
    _241 += _227;
    _241 *= _223.d1;
    _241 += _226;
    _241 *= _223.d2;
    _241 += _225;
    _223.data[_241] = _228;
    _225++;
    if (_225 < d)
    goto _jump2479;
    _225 = 0;
    _226++;
    if (_226 < t)
    goto _jump2479;
    _226 = 0;
    _227++;
    if (_227 < y)
    goto _jump2479;
    // End body of loop
    int64_t _242 = 532;
    if (_242 >= 0)
    goto _jump2486;
    fail_assertion("negative array index");
    _jump2486:;
    if (_242 < _223.d0)
    goto _jump2487;
    fail_assertion("index too large");
    _jump2487:;
    if (e >= 0)
    goto _jump2488;
    fail_assertion("negative array index");
    _jump2488:;
    if (e < _223.d1)
    goto _jump2489;
    fail_assertion("index too large");
    _jump2489:;
    if (y >= 0)
    goto _jump2490;
    fail_assertion("negative array index");
    _jump2490:;
    if (y < _223.d2)
    goto _jump2491;
    fail_assertion("index too large");
    _jump2491:;
    int64_t _243 = 0;
    _243 *= _223.d0;
    _243 += _242;
    _243 *= _223.d1;
    _243 += e;
    _243 *= _223.d2;
    _243 += y;
    _a3_double _244 = _223.data[_243];
    _211 = _244;
    _jump2475:;
    _137 = _211;
    _jump2448:;
    _102 = _137;
    goto _jump2492;
    _jump2395:;
    _a3_double _245;
    // Computing bound for C
    _245.d0 = u;
    if (u > 0) 
    goto _jump2493;
    fail_assertion("non-positive loop bound");
    _jump2493:;
    // Computing bound for D
    _245.d1 = d;
    if (d > 0) 
    goto _jump2494;
    fail_assertion("non-positive loop bound");
    _jump2494:;
    // Computing bound for E
    _245.d2 = i;
    if (i > 0) 
    goto _jump2495;
    fail_assertion("non-positive loop bound");
    _jump2495:;
    // Computing total size of heap memory to allocate
    int64_t _246 = 1;
    _246 *= u;
    _246 *= d;
    _246 *= i;
    _246 *= sizeof(double);
    _245.data = jpl_alloc(_246);
    int64_t _247 = 0; // E
    int64_t _248 = 0; // D
    int64_t _249 = 0; // C
    _jump2496:; // Begin body of loop
    double _251 = 37.0;
    rgba _252 = j();
    double _253 = _252.a;
    double _254 = _251 + _253;
    _a2_double _255;
    // Computing bound for F
    _255.d0 = e;
    if (e > 0) 
    goto _jump2497;
    fail_assertion("non-positive loop bound");
    _jump2497:;
    // Computing bound for G
    _255.d1 = e;
    if (e > 0) 
    goto _jump2498;
    fail_assertion("non-positive loop bound");
    _jump2498:;
    // Computing total size of heap memory to allocate
    int64_t _256 = 1;
    _256 *= e;
    _256 *= e;
    _256 *= sizeof(double);
    _255.data = jpl_alloc(_256);
    int64_t _257 = 0; // G
    int64_t _258 = 0; // F
    _jump2499:; // Begin body of loop
    double _259 = z();
    double _260 = -_259;
    int64_t _261 = 0;
    _261 *= _255.d0;
    _261 += _258;
    _261 *= _255.d1;
    _261 += _257;
    _255.data[_261] = _260;
    _257++;
    if (_257 < e)
    goto _jump2499;
    _257 = 0;
    _258++;
    if (_258 < e)
    goto _jump2499;
    // End body of loop
    bool _262 = f(_254, _255);
    bool _250 = _262;
    if (0 != _262)
    goto _jump2500;
    if (i >= 0)
    goto _jump2501;
    fail_assertion("negative array index");
    _jump2501:;
    if (i < m.d0)
    goto _jump2502;
    fail_assertion("index too large");
    _jump2502:;
    if (i >= 0)
    goto _jump2503;
    fail_assertion("negative array index");
    _jump2503:;
    if (i < m.d1)
    goto _jump2504;
    fail_assertion("index too large");
    _jump2504:;
    int64_t _263 = 0;
    _263 *= m.d0;
    _263 += i;
    _263 *= m.d1;
    _263 += i;
    bool _264 = m.data[_263];
    _250 = _264;
    _jump2500:;
    double _265;
    if (!_250)
    goto _jump2505;
    double _266 = z();
    _265 = _266;
    goto _jump2506;
    _jump2505:;
    _a3_double _267;
    // Computing bound for F
    int64_t _268 = _249 / u;
    int64_t _269 = _248 - _268;
    _267.d0 = _269;
    if (_269 > 0) 
    goto _jump2507;
    fail_assertion("non-positive loop bound");
    _jump2507:;
    // Computing bound for G
    _267.d1 = _248;
    if (_248 > 0) 
    goto _jump2508;
    fail_assertion("non-positive loop bound");
    _jump2508:;
    // Computing bound for H
    int64_t _270 = _248 + _248;
    _267.d2 = _270;
    if (_270 > 0) 
    goto _jump2509;
    fail_assertion("non-positive loop bound");
    _jump2509:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= _269;
    _271 *= _248;
    _271 *= _270;
    _271 *= sizeof(double);
    _267.data = jpl_alloc(_271);
    int64_t _272 = 0; // H
    int64_t _273 = 0; // G
    int64_t _274 = 0; // F
    _jump2510:; // Begin body of loop
    bool _275 = _247 == _272;
    double _276;
    if (!_275)
    goto _jump2511;
    double _277;
    // Computing bound for I
    if (_274 > 0) 
    goto _jump2512;
    fail_assertion("non-positive loop bound");
    _jump2512:;
    _277 = 0;
    int64_t _278 = 0; // I
    _jump2513:; // Begin body of loop
    double _279 = 45.0;
    _277 += _279;
    _278++;
    if (_278 < _274)
    goto _jump2513;
    // End body of loop
    _276 = _277;
    goto _jump2514;
    _jump2511:;
    double _280 = z();
    double _281 = 33.0;
    double _282 = _280 * _281;
    _276 = _282;
    _jump2514:;
    int64_t _283 = 0;
    _283 *= _267.d0;
    _283 += _274;
    _283 *= _267.d1;
    _283 += _273;
    _283 *= _267.d2;
    _283 += _272;
    _267.data[_283] = _276;
    _272++;
    if (_272 < _270)
    goto _jump2510;
    _272 = 0;
    _273++;
    if (_273 < _248)
    goto _jump2510;
    _273 = 0;
    _274++;
    if (_274 < _269)
    goto _jump2510;
    // End body of loop
    int64_t _284 = 436;
    if (t >= 0)
    goto _jump2515;
    fail_assertion("negative array index");
    _jump2515:;
    if (t < _267.d0)
    goto _jump2516;
    fail_assertion("index too large");
    _jump2516:;
    if (q >= 0)
    goto _jump2517;
    fail_assertion("negative array index");
    _jump2517:;
    if (q < _267.d1)
    goto _jump2518;
    fail_assertion("index too large");
    _jump2518:;
    if (_284 >= 0)
    goto _jump2519;
    fail_assertion("negative array index");
    _jump2519:;
    if (_284 < _267.d2)
    goto _jump2520;
    fail_assertion("index too large");
    _jump2520:;
    int64_t _285 = 0;
    _285 *= _267.d0;
    _285 += t;
    _285 *= _267.d1;
    _285 += q;
    _285 *= _267.d2;
    _285 += _284;
    double _286 = _267.data[_285];
    _265 = _286;
    _jump2506:;
    int64_t _287 = 0;
    _287 *= _245.d0;
    _287 += _249;
    _287 *= _245.d1;
    _287 += _248;
    _287 *= _245.d2;
    _287 += _247;
    _245.data[_287] = _265;
    _247++;
    if (_247 < i)
    goto _jump2496;
    _247 = 0;
    _248++;
    if (_248 < d)
    goto _jump2496;
    _248 = 0;
    _249++;
    if (_249 < u)
    goto _jump2496;
    // End body of loop
    _102 = _245;
    _jump2492:;
    _a2_rgba _288;
    // Computing bound for G
    _a3__a1_int64_t _289;
    // Computing bound for G
    _289.d0 = _102.d0;
    if (_102.d0 > 0) 
    goto _jump2521;
    fail_assertion("non-positive loop bound");
    _jump2521:;
    // Computing bound for H
    _289.d1 = r;
    if (r > 0) 
    goto _jump2522;
    fail_assertion("non-positive loop bound");
    _jump2522:;
    // Computing bound for I
    _289.d2 = d;
    if (d > 0) 
    goto _jump2523;
    fail_assertion("non-positive loop bound");
    _jump2523:;
    // Computing total size of heap memory to allocate
    int64_t _290 = 1;
    _290 *= _102.d0;
    _290 *= r;
    _290 *= d;
    _290 *= sizeof(_a1_int64_t);
    _289.data = jpl_alloc(_290);
    int64_t _291 = 0; // I
    int64_t _292 = 0; // H
    int64_t _293 = 0; // G
    _jump2524:; // Begin body of loop
    int64_t _294 = 0;
    _294 *= _289.d0;
    _294 += _293;
    _294 *= _289.d1;
    _294 += _292;
    _294 *= _289.d2;
    _294 += _291;
    _289.data[_294] = x;
    _291++;
    if (_291 < d)
    goto _jump2524;
    _291 = 0;
    _292++;
    if (_292 < r)
    goto _jump2524;
    _292 = 0;
    _293++;
    if (_293 < _102.d0)
    goto _jump2524;
    // End body of loop
    int64_t _295;
    // Computing bound for G
    if (q > 0) 
    goto _jump2525;
    fail_assertion("non-positive loop bound");
    _jump2525:;
    _295 = 0;
    int64_t _296 = 0; // G
    _jump2526:; // Begin body of loop
    _295 += _102.d1;
    _296++;
    if (_296 < q)
    goto _jump2526;
    // End body of loop
    if (_295 >= 0)
    goto _jump2527;
    fail_assertion("negative array index");
    _jump2527:;
    if (_295 < _289.d0)
    goto _jump2528;
    fail_assertion("index too large");
    _jump2528:;
    if (x.d0 >= 0)
    goto _jump2529;
    fail_assertion("negative array index");
    _jump2529:;
    if (x.d0 < _289.d1)
    goto _jump2530;
    fail_assertion("index too large");
    _jump2530:;
    if (y >= 0)
    goto _jump2531;
    fail_assertion("negative array index");
    _jump2531:;
    if (y < _289.d2)
    goto _jump2532;
    fail_assertion("index too large");
    _jump2532:;
    int64_t _297 = 0;
    _297 *= _289.d0;
    _297 += _295;
    _297 *= _289.d1;
    _297 += x.d0;
    _297 *= _289.d2;
    _297 += y;
    _a1_int64_t _298 = _289.data[_297];
    if (d >= 0)
    goto _jump2533;
    fail_assertion("negative array index");
    _jump2533:;
    if (d < _298.d0)
    goto _jump2534;
    fail_assertion("index too large");
    _jump2534:;
    int64_t _299 = 0;
    _299 *= _298.d0;
    _299 += d;
    int64_t _300 = _298.data[_299];
    _288.d0 = _300;
    if (_300 > 0) 
    goto _jump2535;
    fail_assertion("non-positive loop bound");
    _jump2535:;
    // Computing bound for H
    _288.d1 = i;
    if (i > 0) 
    goto _jump2536;
    fail_assertion("non-positive loop bound");
    _jump2536:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= _300;
    _301 *= i;
    _301 *= sizeof(rgba);
    _288.data = jpl_alloc(_301);
    int64_t _302 = 0; // H
    int64_t _303 = 0; // G
    _jump2537:; // Begin body of loop
    double _304;
    // Computing bound for I
    if (i > 0) 
    goto _jump2538;
    fail_assertion("non-positive loop bound");
    _jump2538:;
    // Computing bound for J
    if (q > 0) 
    goto _jump2539;
    fail_assertion("non-positive loop bound");
    _jump2539:;
    _304 = 0;
    int64_t _305 = 0; // J
    int64_t _306 = 0; // I
    _jump2540:; // Begin body of loop
    double _307 = 88.0;
    _304 += _307;
    _305++;
    if (_305 < q)
    goto _jump2540;
    _305 = 0;
    _306++;
    if (_306 < i)
    goto _jump2540;
    // End body of loop
    double _308 = 19.0;
    double _309 = 9.0;
    double _310 = _308 / _309;
    double _311 = fmod(_304, _310);
    double _312 = 10.0;
    double _313 = -_312;
    double _314;
    // Computing bound for I
    if (_303 > 0) 
    goto _jump2541;
    fail_assertion("non-positive loop bound");
    _jump2541:;
    // Computing bound for J
    if (y > 0) 
    goto _jump2542;
    fail_assertion("non-positive loop bound");
    _jump2542:;
    _314 = 0;
    int64_t _315 = 0; // J
    int64_t _316 = 0; // I
    _jump2543:; // Begin body of loop
    double _317 = z();
    _314 += _317;
    _315++;
    if (_315 < y)
    goto _jump2543;
    _315 = 0;
    _316++;
    if (_316 < _303)
    goto _jump2543;
    // End body of loop
    double _318 = z();
    rgba _319 = { _311, _313, _314, _318 };
    int64_t _320 = 0;
    _320 *= _288.d0;
    _320 += _303;
    _320 *= _288.d1;
    _320 += _302;
    _288.data[_320] = _319;
    _302++;
    if (_302 < i)
    goto _jump2537;
    _302 = 0;
    _303++;
    if (_303 < _300)
    goto _jump2537;
    // End body of loop
    if (q >= 0)
    goto _jump2544;
    fail_assertion("negative array index");
    _jump2544:;
    if (q < _288.d0)
    goto _jump2545;
    fail_assertion("index too large");
    _jump2545:;
    if (i >= 0)
    goto _jump2546;
    fail_assertion("negative array index");
    _jump2546:;
    if (i < _288.d1)
    goto _jump2547;
    fail_assertion("index too large");
    _jump2547:;
    int64_t _321 = 0;
    _321 *= _288.d0;
    _321 += q;
    _321 *= _288.d1;
    _321 += i;
    rgba _322 = _288.data[_321];
    double _323 = _322.a;
    double _324 = -_323;
    return _324;
    bool _326 = false;
    bool _325 = _326;
    if (0 != _326)
    goto _jump2548;
    bool _327 = true;
    _325 = _327;
    _jump2548:;
    bool _328;
    if (!_325)
    goto _jump2549;
    _328 = a;
    goto _jump2550;
    _jump2549:;
    _328 = a;
    _jump2550:;
    bool _329 = !_328;
    double _330;
    if (!_329)
    goto _jump2551;
    _a1__a3_rgba _331;
    // Computing bound for G
    _331.d0 = q;
    if (q > 0) 
    goto _jump2552;
    fail_assertion("non-positive loop bound");
    _jump2552:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= q;
    _332 *= sizeof(_a3_rgba);
    _331.data = jpl_alloc(_332);
    int64_t _333 = 0; // G
    _jump2553:; // Begin body of loop
    _a3_rgba _334;
    // Computing bound for H
    _334.d0 = x.d0;
    if (x.d0 > 0) 
    goto _jump2554;
    fail_assertion("non-positive loop bound");
    _jump2554:;
    // Computing bound for I
    _334.d1 = _102.d0;
    if (_102.d0 > 0) 
    goto _jump2555;
    fail_assertion("non-positive loop bound");
    _jump2555:;
    // Computing bound for J
    _334.d2 = _102.d0;
    if (_102.d0 > 0) 
    goto _jump2556;
    fail_assertion("non-positive loop bound");
    _jump2556:;
    // Computing total size of heap memory to allocate
    int64_t _335 = 1;
    _335 *= x.d0;
    _335 *= _102.d0;
    _335 *= _102.d0;
    _335 *= sizeof(rgba);
    _334.data = jpl_alloc(_335);
    int64_t _336 = 0; // J
    int64_t _337 = 0; // I
    int64_t _338 = 0; // H
    _jump2557:; // Begin body of loop
    rgba _339 = j();
    int64_t _340 = 0;
    _340 *= _334.d0;
    _340 += _338;
    _340 *= _334.d1;
    _340 += _337;
    _340 *= _334.d2;
    _340 += _336;
    _334.data[_340] = _339;
    _336++;
    if (_336 < _102.d0)
    goto _jump2557;
    _336 = 0;
    _337++;
    if (_337 < _102.d0)
    goto _jump2557;
    _337 = 0;
    _338++;
    if (_338 < x.d0)
    goto _jump2557;
    // End body of loop
    int64_t _341 = 0;
    _341 *= _331.d0;
    _341 += _333;
    _331.data[_341] = _334;
    _333++;
    if (_333 < q)
    goto _jump2553;
    // End body of loop
    if (r >= 0)
    goto _jump2558;
    fail_assertion("negative array index");
    _jump2558:;
    if (r < _331.d0)
    goto _jump2559;
    fail_assertion("index too large");
    _jump2559:;
    int64_t _342 = 0;
    _342 *= _331.d0;
    _342 += r;
    _a3_rgba _343 = _331.data[_342];
    g _344;
    if (!a)
    goto _jump2560;
    g _345 = l();
    _344 = _345;
    goto _jump2561;
    _jump2560:;
    g _346 = l();
    _344 = _346;
    _jump2561:;
    int64_t _347 = _344.b;
    if (y >= 0)
    goto _jump2562;
    fail_assertion("negative array index");
    _jump2562:;
    if (y < _343.d0)
    goto _jump2563;
    fail_assertion("index too large");
    _jump2563:;
    if (_102.d0 >= 0)
    goto _jump2564;
    fail_assertion("negative array index");
    _jump2564:;
    if (_102.d0 < _343.d1)
    goto _jump2565;
    fail_assertion("index too large");
    _jump2565:;
    if (_347 >= 0)
    goto _jump2566;
    fail_assertion("negative array index");
    _jump2566:;
    if (_347 < _343.d2)
    goto _jump2567;
    fail_assertion("index too large");
    _jump2567:;
    int64_t _348 = 0;
    _348 *= _343.d0;
    _348 += y;
    _348 *= _343.d1;
    _348 += _102.d0;
    _348 *= _343.d2;
    _348 += _347;
    rgba _349 = _343.data[_348];
    double _350 = _349.r;
    _330 = _350;
    goto _jump2568;
    _jump2551:;
    _a3_double _351;
    // Computing bound for G
    _351.d0 = e;
    if (e > 0) 
    goto _jump2569;
    fail_assertion("non-positive loop bound");
    _jump2569:;
    // Computing bound for H
    _351.d1 = r;
    if (r > 0) 
    goto _jump2570;
    fail_assertion("non-positive loop bound");
    _jump2570:;
    // Computing bound for I
    g _352 = l();
    int64_t _353 = _352.b;
    _351.d2 = _353;
    if (_353 > 0) 
    goto _jump2571;
    fail_assertion("non-positive loop bound");
    _jump2571:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= e;
    _354 *= r;
    _354 *= _353;
    _354 *= sizeof(double);
    _351.data = jpl_alloc(_354);
    int64_t _355 = 0; // I
    int64_t _356 = 0; // H
    int64_t _357 = 0; // G
    _jump2572:; // Begin body of loop
    double _358 = z();
    int64_t _359 = 0;
    _359 *= _351.d0;
    _359 += _357;
    _359 *= _351.d1;
    _359 += _356;
    _359 *= _351.d2;
    _359 += _355;
    _351.data[_359] = _358;
    _355++;
    if (_355 < _353)
    goto _jump2572;
    _355 = 0;
    _356++;
    if (_356 < r)
    goto _jump2572;
    _356 = 0;
    _357++;
    if (_357 < e)
    goto _jump2572;
    // End body of loop
    int64_t _360 = 303;
    if (_360 >= 0)
    goto _jump2573;
    fail_assertion("negative array index");
    _jump2573:;
    if (_360 < _351.d0)
    goto _jump2574;
    fail_assertion("index too large");
    _jump2574:;
    if (t >= 0)
    goto _jump2575;
    fail_assertion("negative array index");
    _jump2575:;
    if (t < _351.d1)
    goto _jump2576;
    fail_assertion("index too large");
    _jump2576:;
    if (d >= 0)
    goto _jump2577;
    fail_assertion("negative array index");
    _jump2577:;
    if (d < _351.d2)
    goto _jump2578;
    fail_assertion("index too large");
    _jump2578:;
    int64_t _361 = 0;
    _361 *= _351.d0;
    _361 += _360;
    _361 *= _351.d1;
    _361 += t;
    _361 *= _351.d2;
    _361 += d;
    double _362 = _351.data[_361];
    double _363 = -_362;
    _330 = _363;
    _jump2568:;
    double _364 = -_330;
    return _364;
    bool _365 = true;
    double _366;
    if (!_365)
    goto _jump2579;
    double _367 = z();
    _366 = _367;
    goto _jump2580;
    _jump2579:;
    double _368 = z();
    _366 = _368;
    _jump2580:;
    return _366;
}

rgba A(_a3_int64_t B, v F, _a3_double G) {
    _a2__a1__a2__a2_bool _0;
    // Computing bound for L
    g _1 = l();
    int64_t _2 = _1.b;
    _0.d0 = _2;
    if (_2 > 0) 
    goto _jump2582;
    fail_assertion("non-positive loop bound");
    _jump2582:;
    // Computing bound for M
    _0.d1 = i;
    if (i > 0) 
    goto _jump2583;
    fail_assertion("non-positive loop bound");
    _jump2583:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= i;
    _3 *= sizeof(_a1__a2__a2_bool);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // M
    int64_t _5 = 0; // L
    _jump2584:; // Begin body of loop
    _a1__a2__a2_bool _6;
    // Computing bound for N
    _6.d0 = u;
    if (u > 0) 
    goto _jump2585;
    fail_assertion("non-positive loop bound");
    _jump2585:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= u;
    _7 *= sizeof(_a2__a2_bool);
    _6.data = jpl_alloc(_7);
    int64_t _8 = 0; // N
    _jump2586:; // Begin body of loop
    _a2__a2_bool _9;
    // Computing bound for O
    _9.d0 = _4;
    if (_4 > 0) 
    goto _jump2587;
    fail_assertion("non-positive loop bound");
    _jump2587:;
    // Computing bound for P
    _9.d1 = _5;
    if (_5 > 0) 
    goto _jump2588;
    fail_assertion("non-positive loop bound");
    _jump2588:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _4;
    _10 *= _5;
    _10 *= sizeof(_a2_bool);
    _9.data = jpl_alloc(_10);
    int64_t _11 = 0; // P
    int64_t _12 = 0; // O
    _jump2589:; // Begin body of loop
    int64_t _13 = 0;
    _13 *= _9.d0;
    _13 += _12;
    _13 *= _9.d1;
    _13 += _11;
    _9.data[_13] = m;
    _11++;
    if (_11 < _5)
    goto _jump2589;
    _11 = 0;
    _12++;
    if (_12 < _4)
    goto _jump2589;
    // End body of loop
    int64_t _14 = 0;
    _14 *= _6.d0;
    _14 += _8;
    _6.data[_14] = _9;
    _8++;
    if (_8 < u)
    goto _jump2586;
    // End body of loop
    int64_t _15 = 0;
    _15 *= _0.d0;
    _15 += _5;
    _15 *= _0.d1;
    _15 += _4;
    _0.data[_15] = _6;
    _4++;
    if (_4 < i)
    goto _jump2584;
    _4 = 0;
    _5++;
    if (_5 < _2)
    goto _jump2584;
    // End body of loop
    if (y >= 0)
    goto _jump2590;
    fail_assertion("negative array index");
    _jump2590:;
    if (y < _0.d0)
    goto _jump2591;
    fail_assertion("index too large");
    _jump2591:;
    if (r >= 0)
    goto _jump2592;
    fail_assertion("negative array index");
    _jump2592:;
    if (r < _0.d1)
    goto _jump2593;
    fail_assertion("index too large");
    _jump2593:;
    int64_t _16 = 0;
    _16 *= _0.d0;
    _16 += y;
    _16 *= _0.d1;
    _16 += r;
    _a1__a2__a2_bool _17 = _0.data[_16];
    int64_t _18 = q + G.d2;
    if (_18 >= 0)
    goto _jump2594;
    fail_assertion("negative array index");
    _jump2594:;
    if (_18 < _17.d0)
    goto _jump2595;
    fail_assertion("index too large");
    _jump2595:;
    int64_t _19 = 0;
    _19 *= _17.d0;
    _19 += _18;
    _a2__a2_bool _20 = _17.data[_19];
    int64_t _21 = 266;
    if (G.d0 >= 0)
    goto _jump2596;
    fail_assertion("negative array index");
    _jump2596:;
    if (G.d0 < _20.d0)
    goto _jump2597;
    fail_assertion("index too large");
    _jump2597:;
    if (_21 >= 0)
    goto _jump2598;
    fail_assertion("negative array index");
    _jump2598:;
    if (_21 < _20.d1)
    goto _jump2599;
    fail_assertion("index too large");
    _jump2599:;
    int64_t _22 = 0;
    _22 *= _20.d0;
    _22 += G.d0;
    _22 *= _20.d1;
    _22 += _21;
    _a2_bool _23 = _20.data[_22];
    _a3_bool _24;
    // Computing bound for O
    _24.d0 = d;
    if (d > 0) 
    goto _jump2600;
    fail_assertion("non-positive loop bound");
    _jump2600:;
    // Computing bound for P
    _24.d1 = e;
    if (e > 0) 
    goto _jump2601;
    fail_assertion("non-positive loop bound");
    _jump2601:;
    // Computing bound for Q
    _24.d2 = e;
    if (e > 0) 
    goto _jump2602;
    fail_assertion("non-positive loop bound");
    _jump2602:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= d;
    _25 *= e;
    _25 *= e;
    _25 *= sizeof(bool);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // Q
    int64_t _27 = 0; // P
    int64_t _28 = 0; // O
    _jump2603:; // Begin body of loop
    int64_t _29 = 0;
    _29 *= _24.d0;
    _29 += _28;
    _29 *= _24.d1;
    _29 += _27;
    _29 *= _24.d2;
    _29 += _26;
    _24.data[_29] = a;
    _26++;
    if (_26 < e)
    goto _jump2603;
    _26 = 0;
    _27++;
    if (_27 < e)
    goto _jump2603;
    _27 = 0;
    _28++;
    if (_28 < d)
    goto _jump2603;
    // End body of loop
    int64_t _30;
    // Computing bound for O
    if (d > 0) 
    goto _jump2604;
    fail_assertion("non-positive loop bound");
    _jump2604:;
    // Computing bound for P
    if (B.d1 > 0) 
    goto _jump2605;
    fail_assertion("non-positive loop bound");
    _jump2605:;
    // Computing bound for Q
    if (i > 0) 
    goto _jump2606;
    fail_assertion("non-positive loop bound");
    _jump2606:;
    _30 = 0;
    int64_t _31 = 0; // Q
    int64_t _32 = 0; // P
    int64_t _33 = 0; // O
    _jump2607:; // Begin body of loop
    _30 += _23.d1;
    _31++;
    if (_31 < i)
    goto _jump2607;
    _31 = 0;
    _32++;
    if (_32 < B.d1)
    goto _jump2607;
    _32 = 0;
    _33++;
    if (_33 < d)
    goto _jump2607;
    // End body of loop
    if (e >= 0)
    goto _jump2608;
    fail_assertion("negative array index");
    _jump2608:;
    if (e < _24.d0)
    goto _jump2609;
    fail_assertion("index too large");
    _jump2609:;
    if (t >= 0)
    goto _jump2610;
    fail_assertion("negative array index");
    _jump2610:;
    if (t < _24.d1)
    goto _jump2611;
    fail_assertion("index too large");
    _jump2611:;
    if (_30 >= 0)
    goto _jump2612;
    fail_assertion("negative array index");
    _jump2612:;
    if (_30 < _24.d2)
    goto _jump2613;
    fail_assertion("index too large");
    _jump2613:;
    int64_t _34 = 0;
    _34 *= _24.d0;
    _34 += e;
    _34 *= _24.d1;
    _34 += t;
    _34 *= _24.d2;
    _34 += _30;
    bool _35 = _24.data[_34];
    bool _36;
    if (!_35)
    goto _jump2614;
    bool _37 = a;
    if (0 != a)
    goto _jump2615;
    _37 = a;
    _jump2615:;
    bool _38 = !_37;
    bool _39 = !_38;
    _36 = _39;
    goto _jump2616;
    _jump2614:;
    _a3_int64_t _40;
    // Computing bound for O
    _40.d0 = G.d0;
    if (G.d0 > 0) 
    goto _jump2617;
    fail_assertion("non-positive loop bound");
    _jump2617:;
    // Computing bound for P
    _40.d1 = t;
    if (t > 0) 
    goto _jump2618;
    fail_assertion("non-positive loop bound");
    _jump2618:;
    // Computing bound for Q
    _40.d2 = G.d0;
    if (G.d0 > 0) 
    goto _jump2619;
    fail_assertion("non-positive loop bound");
    _jump2619:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= G.d0;
    _41 *= t;
    _41 *= G.d0;
    _41 *= sizeof(int64_t);
    _40.data = jpl_alloc(_41);
    int64_t _42 = 0; // Q
    int64_t _43 = 0; // P
    int64_t _44 = 0; // O
    _jump2620:; // Begin body of loop
    int64_t _45 = 0;
    _45 *= _40.d0;
    _45 += _44;
    _45 *= _40.d1;
    _45 += _43;
    _45 *= _40.d2;
    _45 += _42;
    _40.data[_45] = B.d1;
    _42++;
    if (_42 < G.d0)
    goto _jump2620;
    _42 = 0;
    _43++;
    if (_43 < t)
    goto _jump2620;
    _43 = 0;
    _44++;
    if (_44 < G.d0)
    goto _jump2620;
    // End body of loop
    if (_23.d1 >= 0)
    goto _jump2621;
    fail_assertion("negative array index");
    _jump2621:;
    if (_23.d1 < _40.d0)
    goto _jump2622;
    fail_assertion("index too large");
    _jump2622:;
    if (r >= 0)
    goto _jump2623;
    fail_assertion("negative array index");
    _jump2623:;
    if (r < _40.d1)
    goto _jump2624;
    fail_assertion("index too large");
    _jump2624:;
    if (B.d2 >= 0)
    goto _jump2625;
    fail_assertion("negative array index");
    _jump2625:;
    if (B.d2 < _40.d2)
    goto _jump2626;
    fail_assertion("index too large");
    _jump2626:;
    int64_t _46 = 0;
    _46 *= _40.d0;
    _46 += _23.d1;
    _46 *= _40.d1;
    _46 += r;
    _46 *= _40.d2;
    _46 += B.d2;
    int64_t _47 = _40.data[_46];
    if (t >= 0)
    goto _jump2627;
    fail_assertion("negative array index");
    _jump2627:;
    if (t < p.d0)
    goto _jump2628;
    fail_assertion("index too large");
    _jump2628:;
    if (_47 >= 0)
    goto _jump2629;
    fail_assertion("negative array index");
    _jump2629:;
    if (_47 < p.d1)
    goto _jump2630;
    fail_assertion("index too large");
    _jump2630:;
    int64_t _48 = 0;
    _48 *= p.d0;
    _48 += t;
    _48 *= p.d1;
    _48 += _47;
    bool _49 = p.data[_48];
    _36 = _49;
    _jump2616:;
    double _50;
    if (!_36)
    goto _jump2631;
    double _51 = z();
    _50 = _51;
    goto _jump2632;
    _jump2631:;
    double _52 = z();
    _50 = _52;
    _jump2632:;
    _a3_k _53;
    // Computing bound for O
    _53.d0 = G.d0;
    if (G.d0 > 0) 
    goto _jump2633;
    fail_assertion("non-positive loop bound");
    _jump2633:;
    // Computing bound for P
    _53.d1 = y;
    if (y > 0) 
    goto _jump2634;
    fail_assertion("non-positive loop bound");
    _jump2634:;
    // Computing bound for Q
    _53.d2 = G.d1;
    if (G.d1 > 0) 
    goto _jump2635;
    fail_assertion("non-positive loop bound");
    _jump2635:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= G.d0;
    _54 *= y;
    _54 *= G.d1;
    _54 *= sizeof(k);
    _53.data = jpl_alloc(_54);
    int64_t _55 = 0; // Q
    int64_t _56 = 0; // P
    int64_t _57 = 0; // O
    _jump2636:; // Begin body of loop
    _a2_k _58;
    // Computing bound for R
    _58.d0 = G.d1;
    if (G.d1 > 0) 
    goto _jump2637;
    fail_assertion("non-positive loop bound");
    _jump2637:;
    // Computing bound for S
    int64_t _59 = _55 + _23.d0;
    _58.d1 = _59;
    if (_59 > 0) 
    goto _jump2638;
    fail_assertion("non-positive loop bound");
    _jump2638:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= G.d1;
    _60 *= _59;
    _60 *= sizeof(k);
    _58.data = jpl_alloc(_60);
    int64_t _61 = 0; // S
    int64_t _62 = 0; // R
    _jump2639:; // Begin body of loop
    _a3__a3_double _63;
    // Computing bound for T
    _63.d0 = G.d0;
    if (G.d0 > 0) 
    goto _jump2640;
    fail_assertion("non-positive loop bound");
    _jump2640:;
    // Computing bound for U
    _63.d1 = _57;
    if (_57 > 0) 
    goto _jump2641;
    fail_assertion("non-positive loop bound");
    _jump2641:;
    // Computing bound for V
    _63.d2 = i;
    if (i > 0) 
    goto _jump2642;
    fail_assertion("non-positive loop bound");
    _jump2642:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= G.d0;
    _64 *= _57;
    _64 *= i;
    _64 *= sizeof(_a3_double);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // V
    int64_t _66 = 0; // U
    int64_t _67 = 0; // T
    _jump2643:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _63.d0;
    _68 += _67;
    _68 *= _63.d1;
    _68 += _66;
    _68 *= _63.d2;
    _68 += _65;
    _63.data[_68] = G;
    _65++;
    if (_65 < i)
    goto _jump2643;
    _65 = 0;
    _66++;
    if (_66 < _57)
    goto _jump2643;
    _66 = 0;
    _67++;
    if (_67 < G.d0)
    goto _jump2643;
    // End body of loop
    if (e >= 0)
    goto _jump2644;
    fail_assertion("negative array index");
    _jump2644:;
    if (e < x.d0)
    goto _jump2645;
    fail_assertion("index too large");
    _jump2645:;
    int64_t _69 = 0;
    _69 *= x.d0;
    _69 += e;
    int64_t _70 = x.data[_69];
    double _71 = z();
    k _72 = { _63, _70, _71 };
    int64_t _73 = 0;
    _73 *= _58.d0;
    _73 += _62;
    _73 *= _58.d1;
    _73 += _61;
    _58.data[_73] = _72;
    _61++;
    if (_61 < _59)
    goto _jump2639;
    _61 = 0;
    _62++;
    if (_62 < G.d1)
    goto _jump2639;
    // End body of loop
    bool _74 = true;
    int64_t _75;
    if (!_74)
    goto _jump2646;
    _75 = i;
    goto _jump2647;
    _jump2646:;
    _75 = G.d1;
    _jump2647:;
    bool _76 = _75 >= B.d0;
    int64_t _77;
    if (!_76)
    goto _jump2648;
    _77 = G.d2;
    goto _jump2649;
    _jump2648:;
    _77 = B.d2;
    _jump2649:;
    if (r >= 0)
    goto _jump2650;
    fail_assertion("negative array index");
    _jump2650:;
    if (r < _58.d0)
    goto _jump2651;
    fail_assertion("index too large");
    _jump2651:;
    if (_77 >= 0)
    goto _jump2652;
    fail_assertion("negative array index");
    _jump2652:;
    if (_77 < _58.d1)
    goto _jump2653;
    fail_assertion("index too large");
    _jump2653:;
    int64_t _78 = 0;
    _78 *= _58.d0;
    _78 += r;
    _78 *= _58.d1;
    _78 += _77;
    k _79 = _58.data[_78];
    int64_t _80 = 0;
    _80 *= _53.d0;
    _80 += _57;
    _80 *= _53.d1;
    _80 += _56;
    _80 *= _53.d2;
    _80 += _55;
    _53.data[_80] = _79;
    _55++;
    if (_55 < G.d1)
    goto _jump2636;
    _55 = 0;
    _56++;
    if (_56 < y)
    goto _jump2636;
    _56 = 0;
    _57++;
    if (_57 < G.d0)
    goto _jump2636;
    // End body of loop
    bool _81 = n(_50, _53);
    rgba _82;
    if (!_81)
    goto _jump2654;
    _a2__a2_rgba _83;
    // Computing bound for O
    _83.d0 = B.d1;
    if (B.d1 > 0) 
    goto _jump2655;
    fail_assertion("non-positive loop bound");
    _jump2655:;
    // Computing bound for P
    _83.d1 = q;
    if (q > 0) 
    goto _jump2656;
    fail_assertion("non-positive loop bound");
    _jump2656:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= B.d1;
    _84 *= q;
    _84 *= sizeof(_a2_rgba);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // P
    int64_t _86 = 0; // O
    _jump2657:; // Begin body of loop
    _a2_rgba _87;
    // Computing bound for Q
    _87.d0 = _23.d0;
    if (_23.d0 > 0) 
    goto _jump2658;
    fail_assertion("non-positive loop bound");
    _jump2658:;
    // Computing bound for R
    int64_t _88 = 585;
    _87.d1 = _88;
    if (_88 > 0) 
    goto _jump2659;
    fail_assertion("non-positive loop bound");
    _jump2659:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _23.d0;
    _89 *= _88;
    _89 *= sizeof(rgba);
    _87.data = jpl_alloc(_89);
    int64_t _90 = 0; // R
    int64_t _91 = 0; // Q
    _jump2660:; // Begin body of loop
    rgba _92 = F.a;
    int64_t _93 = 0;
    _93 *= _87.d0;
    _93 += _91;
    _93 *= _87.d1;
    _93 += _90;
    _87.data[_93] = _92;
    _90++;
    if (_90 < _88)
    goto _jump2660;
    _90 = 0;
    _91++;
    if (_91 < _23.d0)
    goto _jump2660;
    // End body of loop
    int64_t _94 = 0;
    _94 *= _83.d0;
    _94 += _86;
    _94 *= _83.d1;
    _94 += _85;
    _83.data[_94] = _87;
    _85++;
    if (_85 < q)
    goto _jump2657;
    _85 = 0;
    _86++;
    if (_86 < B.d1)
    goto _jump2657;
    // End body of loop
    int64_t _95 = -d;
    if (_95 >= 0)
    goto _jump2661;
    fail_assertion("negative array index");
    _jump2661:;
    if (_95 < _83.d0)
    goto _jump2662;
    fail_assertion("index too large");
    _jump2662:;
    if (y >= 0)
    goto _jump2663;
    fail_assertion("negative array index");
    _jump2663:;
    if (y < _83.d1)
    goto _jump2664;
    fail_assertion("index too large");
    _jump2664:;
    int64_t _96 = 0;
    _96 *= _83.d0;
    _96 += _95;
    _96 *= _83.d1;
    _96 += y;
    _a2_rgba _97 = _83.data[_96];
    int64_t _98 = -e;
    if (G.d1 >= 0)
    goto _jump2665;
    fail_assertion("negative array index");
    _jump2665:;
    if (G.d1 < _97.d0)
    goto _jump2666;
    fail_assertion("index too large");
    _jump2666:;
    if (_98 >= 0)
    goto _jump2667;
    fail_assertion("negative array index");
    _jump2667:;
    if (_98 < _97.d1)
    goto _jump2668;
    fail_assertion("index too large");
    _jump2668:;
    int64_t _99 = 0;
    _99 *= _97.d0;
    _99 += G.d1;
    _99 *= _97.d1;
    _99 += _98;
    rgba _100 = _97.data[_99];
    _82 = _100;
    goto _jump2669;
    _jump2654:;
    _a2__a3_v _101;
    // Computing bound for O
    _101.d0 = y;
    if (y > 0) 
    goto _jump2670;
    fail_assertion("non-positive loop bound");
    _jump2670:;
    // Computing bound for P
    int64_t _102;
    if (!a)
    goto _jump2671;
    int64_t _103 = q + e;
    _102 = _103;
    goto _jump2672;
    _jump2671:;
    _102 = B.d0;
    _jump2672:;
    _101.d1 = _102;
    if (_102 > 0) 
    goto _jump2673;
    fail_assertion("non-positive loop bound");
    _jump2673:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= y;
    _104 *= _102;
    _104 *= sizeof(_a3_v);
    _101.data = jpl_alloc(_104);
    int64_t _105 = 0; // P
    int64_t _106 = 0; // O
    _jump2674:; // Begin body of loop
    _a3_v _107;
    // Computing bound for Q
    _107.d0 = d;
    if (d > 0) 
    goto _jump2675;
    fail_assertion("non-positive loop bound");
    _jump2675:;
    // Computing bound for R
    _107.d1 = G.d0;
    if (G.d0 > 0) 
    goto _jump2676;
    fail_assertion("non-positive loop bound");
    _jump2676:;
    // Computing bound for S
    int64_t _108;
    // Computing bound for Q
    if (q > 0) 
    goto _jump2677;
    fail_assertion("non-positive loop bound");
    _jump2677:;
    _108 = 0;
    int64_t _109 = 0; // Q
    _jump2678:; // Begin body of loop
    _108 += e;
    _109++;
    if (_109 < q)
    goto _jump2678;
    // End body of loop
    _107.d2 = _108;
    if (_108 > 0) 
    goto _jump2679;
    fail_assertion("non-positive loop bound");
    _jump2679:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= d;
    _110 *= G.d0;
    _110 *= _108;
    _110 *= sizeof(v);
    _107.data = jpl_alloc(_110);
    int64_t _111 = 0; // S
    int64_t _112 = 0; // R
    int64_t _113 = 0; // Q
    _jump2680:; // Begin body of loop
    int64_t _114 = 0;
    _114 *= _107.d0;
    _114 += _113;
    _114 *= _107.d1;
    _114 += _112;
    _114 *= _107.d2;
    _114 += _111;
    _107.data[_114] = F;
    _111++;
    if (_111 < _108)
    goto _jump2680;
    _111 = 0;
    _112++;
    if (_112 < G.d0)
    goto _jump2680;
    _112 = 0;
    _113++;
    if (_113 < d)
    goto _jump2680;
    // End body of loop
    int64_t _115 = 0;
    _115 *= _101.d0;
    _115 += _106;
    _115 *= _101.d1;
    _115 += _105;
    _101.data[_115] = _107;
    _105++;
    if (_105 < _102)
    goto _jump2674;
    _105 = 0;
    _106++;
    if (_106 < y)
    goto _jump2674;
    // End body of loop
    int64_t _116;
    // Computing bound for O
    if (B.d2 > 0) 
    goto _jump2681;
    fail_assertion("non-positive loop bound");
    _jump2681:;
    // Computing bound for P
    if (G.d0 > 0) 
    goto _jump2682;
    fail_assertion("non-positive loop bound");
    _jump2682:;
    _116 = 0;
    int64_t _117 = 0; // P
    int64_t _118 = 0; // O
    _jump2683:; // Begin body of loop
    _116 += G.d0;
    _117++;
    if (_117 < G.d0)
    goto _jump2683;
    _117 = 0;
    _118++;
    if (_118 < B.d2)
    goto _jump2683;
    // End body of loop
    if (y >= 0)
    goto _jump2684;
    fail_assertion("negative array index");
    _jump2684:;
    if (y < B.d0)
    goto _jump2685;
    fail_assertion("index too large");
    _jump2685:;
    if (_116 >= 0)
    goto _jump2686;
    fail_assertion("negative array index");
    _jump2686:;
    if (_116 < B.d1)
    goto _jump2687;
    fail_assertion("index too large");
    _jump2687:;
    if (e >= 0)
    goto _jump2688;
    fail_assertion("negative array index");
    _jump2688:;
    if (e < B.d2)
    goto _jump2689;
    fail_assertion("index too large");
    _jump2689:;
    int64_t _119 = 0;
    _119 *= B.d0;
    _119 += y;
    _119 *= B.d1;
    _119 += _116;
    _119 *= B.d2;
    _119 += e;
    int64_t _120 = B.data[_119];
    if (B.d0 >= 0)
    goto _jump2690;
    fail_assertion("negative array index");
    _jump2690:;
    if (B.d0 < _101.d0)
    goto _jump2691;
    fail_assertion("index too large");
    _jump2691:;
    if (_120 >= 0)
    goto _jump2692;
    fail_assertion("negative array index");
    _jump2692:;
    if (_120 < _101.d1)
    goto _jump2693;
    fail_assertion("index too large");
    _jump2693:;
    int64_t _121 = 0;
    _121 *= _101.d0;
    _121 += B.d0;
    _121 *= _101.d1;
    _121 += _120;
    _a3_v _122 = _101.data[_121];
    if (G.d0 >= 0)
    goto _jump2694;
    fail_assertion("negative array index");
    _jump2694:;
    if (G.d0 < _122.d0)
    goto _jump2695;
    fail_assertion("index too large");
    _jump2695:;
    if (u >= 0)
    goto _jump2696;
    fail_assertion("negative array index");
    _jump2696:;
    if (u < _122.d1)
    goto _jump2697;
    fail_assertion("index too large");
    _jump2697:;
    if (G.d2 >= 0)
    goto _jump2698;
    fail_assertion("negative array index");
    _jump2698:;
    if (G.d2 < _122.d2)
    goto _jump2699;
    fail_assertion("index too large");
    _jump2699:;
    int64_t _123 = 0;
    _123 *= _122.d0;
    _123 += G.d0;
    _123 *= _122.d1;
    _123 += u;
    _123 *= _122.d2;
    _123 += G.d2;
    v _124 = _122.data[_123];
    rgba _125 = _124.a;
    _82 = _125;
    _jump2669:;
    return _82;
    rgba _126 = j();
    return _126;
}

void jpl_main(struct args args) {
    _a1_int64_t _1;
    // Computing bound for a
    int64_t _2 = 126;
    int64_t _3 = 387;
    int64_t _4 = _2 * _3;
    int64_t _5 = -_4;
    _1.d0 = _5;
    if (_5 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _5;
    _6 *= sizeof(int64_t);
    _1.data = jpl_alloc(_6);
    int64_t _7 = 0; // a
    _jump2:; // Begin body of loop
    int64_t _8;
    // Computing bound for b
    int64_t _9 = 572;
    if (_9 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing bound for c
    int64_t _10 = 766;
    if (_10 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    // Computing bound for d
    int64_t _11 = 319;
    if (_11 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    _8 = 0;
    int64_t _12 = 0; // d
    int64_t _13 = 0; // c
    int64_t _14 = 0; // b
    _jump6:; // Begin body of loop
    int64_t _15 = 866;
    int64_t _16 = -_15;
    _8 += _16;
    _12++;
    if (_12 < _11)
    goto _jump6;
    _12 = 0;
    _13++;
    if (_13 < _10)
    goto _jump6;
    _13 = 0;
    _14++;
    if (_14 < _9)
    goto _jump6;
    // End body of loop
    int64_t _17 = 0;
    _17 *= _1.d0;
    _17 += _7;
    _1.data[_17] = _8;
    _7++;
    if (_7 < _5)
    goto _jump2;
    // End body of loop
    int64_t _18;
    // Computing bound for a
    int64_t _19 = 674;
    if (_19 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing bound for b
    int64_t _20 = 555;
    int64_t _21 = -_20;
    if (_21 > 0) 
    goto _jump8;
    fail_assertion("non-positive loop bound");
    _jump8:;
    // Computing bound for c
    int64_t _22 = 27;
    if (_22 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    _18 = 0;
    int64_t _23 = 0; // c
    int64_t _24 = 0; // b
    int64_t _25 = 0; // a
    _jump10:; // Begin body of loop
    int64_t _26;
    // Computing bound for d
    if (_25 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for e
    if (_25 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    _26 = 0;
    int64_t _27 = 0; // e
    int64_t _28 = 0; // d
    _jump13:; // Begin body of loop
    int64_t _29 = 326;
    _26 += _29;
    _27++;
    if (_27 < _25)
    goto _jump13;
    _27 = 0;
    _28++;
    if (_28 < _25)
    goto _jump13;
    // End body of loop
    _18 += _26;
    _23++;
    if (_23 < _22)
    goto _jump10;
    _23 = 0;
    _24++;
    if (_24 < _21)
    goto _jump10;
    _24 = 0;
    _25++;
    if (_25 < _19)
    goto _jump10;
    // End body of loop
    int64_t _30 = -_18;
    if (_30 >= 0)
    goto _jump14;
    fail_assertion("negative array index");
    _jump14:;
    if (_30 < _1.d0)
    goto _jump15;
    fail_assertion("index too large");
    _jump15:;
    int64_t _31 = 0;
    _31 *= _1.d0;
    _31 += _30;
    int64_t _32 = _1.data[_31];
    int64_t _33;
    // Computing bound for a
    bool _34 = false;
    bool _35;
    if (!_34)
    goto _jump16;
    bool _36 = false;
    _35 = _36;
    goto _jump17;
    _jump16:;
    bool _37 = false;
    _35 = _37;
    _jump17:;
    int64_t _38;
    if (!_35)
    goto _jump18;
    int64_t _39 = 662;
    int64_t _40 = -_39;
    int64_t _41 = 686;
    int64_t _42 = _40 / _41;
    _38 = _42;
    goto _jump19;
    _jump18:;
    int64_t _43 = 274;
    int64_t _44 = -_43;
    _38 = _44;
    _jump19:;
    if (_38 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _33 = 0;
    int64_t _45 = 0; // a
    _jump21:; // Begin body of loop
    bool _46 = false;
    bool _47 = !_46;
    int64_t _48;
    if (!_47)
    goto _jump22;
    int64_t _49 = 949;
    _48 = _49;
    goto _jump23;
    _jump22:;
    int64_t _50;
    // Computing bound for b
    if (_45 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    _50 = 0;
    int64_t _51 = 0; // b
    _jump25:; // Begin body of loop
    int64_t _52 = -_45;
    _50 += _52;
    _51++;
    if (_51 < _45)
    goto _jump25;
    // End body of loop
    _48 = _50;
    _jump23:;
    _33 += _48;
    _45++;
    if (_45 < _38)
    goto _jump21;
    // End body of loop
    bool _53 = _32 <= _33;
    bool _0 = _53;
    if (0 != _53)
    goto _jump26;
    double _54;
    // Computing bound for a
    int64_t _55 = 879;
    if (_55 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _54 = 0;
    int64_t _56 = 0; // a
    _jump28:; // Begin body of loop
    double _57 = 89.0;
    _54 += _57;
    _56++;
    if (_56 < _55)
    goto _jump28;
    // End body of loop
    double _58 = -_54;
    double _59;
    // Computing bound for a
    int64_t _60 = 720;
    if (_60 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    _59 = 0;
    int64_t _61 = 0; // a
    _jump30:; // Begin body of loop
    double _62;
    // Computing bound for b
    int64_t _63 = 572;
    _a1_int64_t _64;
    _64.d0 = 1;
    _64.data = jpl_alloc(sizeof(int64_t) * 1);
    _64.data[0] = _63;
    int64_t _65 = 470;
    if (_65 >= 0)
    goto _jump31;
    fail_assertion("negative array index");
    _jump31:;
    if (_65 < _64.d0)
    goto _jump32;
    fail_assertion("index too large");
    _jump32:;
    int64_t _66 = 0;
    _66 *= _64.d0;
    _66 += _65;
    int64_t _67 = _64.data[_66];
    if (_67 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing bound for c
    int64_t _68 = -_61;
    int64_t _69 = _68 - _61;
    if (_69 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    _62 = 0;
    int64_t _70 = 0; // c
    int64_t _71 = 0; // b
    _jump35:; // Begin body of loop
    double _72 = 46.0;
    _62 += _72;
    _70++;
    if (_70 < _69)
    goto _jump35;
    _70 = 0;
    _71++;
    if (_71 < _67)
    goto _jump35;
    // End body of loop
    _59 += _62;
    _61++;
    if (_61 < _60)
    goto _jump30;
    // End body of loop
    bool _73 = _58 < _59;
    _0 = _73;
    _jump26:;
    bool _74;
    if (!_0)
    goto _jump36;
    bool _75 = true;
    _74 = _75;
    goto _jump37;
    _jump36:;
    bool _76 = true;
    _74 = _76;
    _jump37:;
    bool _77 = _74;
    if (0 == _74)
    goto _jump431;
    bool _78 = true;
    _77 = _78;
    _jump431:;
    bool _79;
    if (!_77)
    goto _jump432;
    bool _80 = _74;
    if (0 != _74)
    goto _jump433;
    bool _82 = true;
    bool _81 = _82;
    if (0 == _82)
    goto _jump434;
    int64_t _83 = 150;
    int64_t _84 = 150;
    bool _85 = _83 == _84;
    _81 = _85;
    _jump434:;
    _80 = _81;
    _jump433:;
    bool _86 = !_80;
    _79 = _86;
    goto _jump435;
    _jump432:;
    double _87;
    // Computing bound for c
    int64_t _88 = 657;
    _a1_int64_t _89;
    _89.d0 = 1;
    _89.data = jpl_alloc(sizeof(int64_t) * 1);
    _89.data[0] = _88;
    int64_t _90 = 890;
    if (_90 >= 0)
    goto _jump436;
    fail_assertion("negative array index");
    _jump436:;
    if (_90 < _89.d0)
    goto _jump437;
    fail_assertion("index too large");
    _jump437:;
    int64_t _91 = 0;
    _91 *= _89.d0;
    _91 += _90;
    int64_t _92 = _89.data[_91];
    if (_92 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    _87 = 0;
    int64_t _93 = 0; // c
    _jump439:; // Begin body of loop
    double _94;
    // Computing bound for d
    int64_t _95;
    // Computing bound for d
    if (_93 > 0) 
    goto _jump440;
    fail_assertion("non-positive loop bound");
    _jump440:;
    // Computing bound for e
    int64_t _96 = 443;
    if (_96 > 0) 
    goto _jump441;
    fail_assertion("non-positive loop bound");
    _jump441:;
    // Computing bound for f
    if (_93 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    _95 = 0;
    int64_t _97 = 0; // f
    int64_t _98 = 0; // e
    int64_t _99 = 0; // d
    _jump443:; // Begin body of loop
    _95 += _98;
    _97++;
    if (_97 < _93)
    goto _jump443;
    _97 = 0;
    _98++;
    if (_98 < _96)
    goto _jump443;
    _98 = 0;
    _99++;
    if (_99 < _93)
    goto _jump443;
    // End body of loop
    if (_95 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing bound for e
    int64_t _100 = 835;
    if (_100 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    _94 = 0;
    int64_t _101 = 0; // e
    int64_t _102 = 0; // d
    _jump446:; // Begin body of loop
    double _103 = 42.0;
    double _104 = 70.0;
    double _105 = _103 - _104;
    _94 += _105;
    _101++;
    if (_101 < _100)
    goto _jump446;
    _101 = 0;
    _102++;
    if (_102 < _95)
    goto _jump446;
    // End body of loop
    _87 += _94;
    _93++;
    if (_93 < _92)
    goto _jump439;
    // End body of loop
    double _106 = 51.0;
    double _107 = 19.0;
    double _108 = _106 / _107;
    bool _109 = _87 != _108;
    _79 = _109;
    _jump435:;
    bool _110 = !_79;
    bool _111 = !_110;
    if (0 != _111)
    goto _jump447;
    fail_assertion("c");
    _jump447:;
    double _112 = get_time();
    double _113 = 76.0;
    double _114 = 23.0;
    double _115 = _113 + _114;
    double _116 = 78.0;
    bool _117 = _115 == _116;
    bool _118;
    if (!_117)
    goto _jump448;
    int64_t _120 = 776;
    int64_t _121 = 289;
    bool _122 = _120 != _121;
    bool _119 = _122;
    if (0 != _122)
    goto _jump449;
    _119 = _74;
    _jump449:;
    _a1_bool _123;
    if (!_119)
    goto _jump450;
    bool _124 = true;
    bool _125;
    if (!_74)
    goto _jump451;
    _125 = _74;
    goto _jump452;
    _jump451:;
    _125 = _74;
    _jump452:;
    bool _126 = false;
    bool _127;
    if (!_126)
    goto _jump453;
    bool _128 = false;
    _127 = _128;
    goto _jump454;
    _jump453:;
    _127 = _74;
    _jump454:;
    _a1_bool _129;
    _129.d0 = 3;
    _129.data = jpl_alloc(sizeof(bool) * 3);
    _129.data[0] = _124;
    _129.data[1] = _125;
    _129.data[2] = _127;
    _123 = _129;
    goto _jump455;
    _jump450:;
    _a1_bool _130;
    // Computing bound for c
    int64_t _131 = 633;
    _130.d0 = _131;
    if (_131 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= _131;
    _132 *= sizeof(bool);
    _130.data = jpl_alloc(_132);
    int64_t _133 = 0; // c
    _jump457:; // Begin body of loop
    bool _134 = false;
    bool _135 = !_134;
    int64_t _136 = 0;
    _136 *= _130.d0;
    _136 += _133;
    _130.data[_136] = _135;
    _133++;
    if (_133 < _131)
    goto _jump457;
    // End body of loop
    _123 = _130;
    _jump455:;
    int64_t _137 = 325;
    if (_137 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_137 < _123.d0)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    int64_t _138 = 0;
    _138 *= _123.d0;
    _138 += _137;
    bool _139 = _123.data[_138];
    _118 = _139;
    goto _jump460;
    _jump448:;
    bool _140 = _74;
    if (0 == _74)
    goto _jump461;
    _140 = _74;
    _jump461:;
    bool _141;
    if (!_140)
    goto _jump462;
    double _142 = 65.0;
    double _143 = 28.0;
    double _144;
    if (!_74)
    goto _jump463;
    double _145 = 88.0;
    _144 = _145;
    goto _jump464;
    _jump463:;
    double _146 = 87.0;
    _144 = _146;
    _jump464:;
    double _147 = _143 / _144;
    bool _148 = _142 <= _147;
    _141 = _148;
    goto _jump465;
    _jump462:;
    bool _149 = true;
    _141 = _149;
    _jump465:;
    _118 = _141;
    _jump460:;
    _a2_bool _150;
    if (!_118)
    goto _jump466;
    _a1_bool _151;
    // Computing bound for c
    int64_t _152 = 275;
    _151.d0 = _152;
    if (_152 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _152;
    _153 *= sizeof(bool);
    _151.data = jpl_alloc(_153);
    int64_t _154 = 0; // c
    _jump468:; // Begin body of loop
    bool _155 = _74;
    if (0 != _74)
    goto _jump469;
    double _156 = 7.0;
    double _157 = 60.0;
    bool _158 = _156 == _157;
    _155 = _158;
    _jump469:;
    int64_t _159 = 0;
    _159 *= _151.d0;
    _159 += _154;
    _151.data[_159] = _155;
    _154++;
    if (_154 < _152)
    goto _jump468;
    // End body of loop
    int64_t _160 = 400;
    if (_160 >= 0)
    goto _jump470;
    fail_assertion("negative array index");
    _jump470:;
    if (_160 < _151.d0)
    goto _jump471;
    fail_assertion("index too large");
    _jump471:;
    int64_t _161 = 0;
    _161 *= _151.d0;
    _161 += _160;
    bool _162 = _151.data[_161];
    _a2_bool _163;
    if (!_162)
    goto _jump472;
    _a2_bool _164;
    // Computing bound for c
    int64_t _165;
    // Computing bound for c
    int64_t _166 = 725;
    if (_166 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for d
    bool _167 = false;
    bool _168;
    if (!_167)
    goto _jump474;
    _168 = _74;
    goto _jump475;
    _jump474:;
    _168 = _74;
    _jump475:;
    int64_t _169;
    if (!_168)
    goto _jump476;
    int64_t _170 = 896;
    _169 = _170;
    goto _jump477;
    _jump476:;
    int64_t _171 = 558;
    _169 = _171;
    _jump477:;
    if (_169 > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    _165 = 0;
    int64_t _172 = 0; // d
    int64_t _173 = 0; // c
    _jump479:; // Begin body of loop
    int64_t _174 = 881;
    _165 += _174;
    _172++;
    if (_172 < _169)
    goto _jump479;
    _172 = 0;
    _173++;
    if (_173 < _166)
    goto _jump479;
    // End body of loop
    _164.d0 = _165;
    if (_165 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for d
    bool _175 = true;
    int64_t _176;
    if (!_175)
    goto _jump481;
    int64_t _177;
    // Computing bound for c
    int64_t _178 = 909;
    if (_178 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    _177 = 0;
    int64_t _179 = 0; // c
    _jump483:; // Begin body of loop
    int64_t _180 = -_179;
    _177 += _180;
    _179++;
    if (_179 < _178)
    goto _jump483;
    // End body of loop
    _176 = _177;
    goto _jump484;
    _jump481:;
    int64_t _181;
    // Computing bound for c
    int64_t _182 = 797;
    if (_182 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing bound for d
    int64_t _183 = 236;
    if (_183 > 0) 
    goto _jump486;
    fail_assertion("non-positive loop bound");
    _jump486:;
    _181 = 0;
    int64_t _184 = 0; // d
    int64_t _185 = 0; // c
    _jump487:; // Begin body of loop
    int64_t _186 = 51;
    int64_t _187 = -_186;
    _181 += _187;
    _184++;
    if (_184 < _183)
    goto _jump487;
    _184 = 0;
    _185++;
    if (_185 < _182)
    goto _jump487;
    // End body of loop
    _176 = _181;
    _jump484:;
    _164.d1 = _176;
    if (_176 > 0) 
    goto _jump488;
    fail_assertion("non-positive loop bound");
    _jump488:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= _165;
    _188 *= _176;
    _188 *= sizeof(bool);
    _164.data = jpl_alloc(_188);
    int64_t _189 = 0; // d
    int64_t _190 = 0; // c
    _jump489:; // Begin body of loop
    bool _193 = false;
    bool _192 = _193;
    if (0 == _193)
    goto _jump490;
    bool _194 = !_74;
    _192 = _194;
    _jump490:;
    bool _191 = _192;
    if (0 == _192)
    goto _jump491;
    bool _195 = false;
    _191 = _195;
    _jump491:;
    int64_t _196 = 0;
    _196 *= _164.d0;
    _196 += _190;
    _196 *= _164.d1;
    _196 += _189;
    _164.data[_196] = _191;
    _189++;
    if (_189 < _176)
    goto _jump489;
    _189 = 0;
    _190++;
    if (_190 < _165)
    goto _jump489;
    // End body of loop
    _163 = _164;
    goto _jump492;
    _jump472:;
    _a1__a2_bool _197;
    // Computing bound for c
    int64_t _198 = 126;
    int64_t _199 = -_198;
    _197.d0 = _199;
    if (_199 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= _199;
    _200 *= sizeof(_a2_bool);
    _197.data = jpl_alloc(_200);
    int64_t _201 = 0; // c
    _jump494:; // Begin body of loop
    _a2_bool _202;
    // Computing bound for d
    int64_t _203 = 835;
    _202.d0 = _203;
    if (_203 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing bound for e
    int64_t _204;
    // Computing bound for d
    int64_t _205 = 997;
    if (_205 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    _204 = 0;
    int64_t _206 = 0; // d
    _jump497:; // Begin body of loop
    _204 += _201;
    _206++;
    if (_206 < _205)
    goto _jump497;
    // End body of loop
    _202.d1 = _204;
    if (_204 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing total size of heap memory to allocate
    int64_t _207 = 1;
    _207 *= _203;
    _207 *= _204;
    _207 *= sizeof(bool);
    _202.data = jpl_alloc(_207);
    int64_t _208 = 0; // e
    int64_t _209 = 0; // d
    _jump499:; // Begin body of loop
    int64_t _210 = 181;
    int64_t _211 = 112;
    bool _212 = _210 != _211;
    int64_t _213 = 0;
    _213 *= _202.d0;
    _213 += _209;
    _213 *= _202.d1;
    _213 += _208;
    _202.data[_213] = _212;
    _208++;
    if (_208 < _204)
    goto _jump499;
    _208 = 0;
    _209++;
    if (_209 < _203)
    goto _jump499;
    // End body of loop
    int64_t _214 = 0;
    _214 *= _197.d0;
    _214 += _201;
    _197.data[_214] = _202;
    _201++;
    if (_201 < _199)
    goto _jump494;
    // End body of loop
    int64_t _215;
    // Computing bound for c
    int64_t _216 = 357;
    if (_216 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    _215 = 0;
    int64_t _217 = 0; // c
    _jump501:; // Begin body of loop
    int64_t _218;
    // Computing bound for d
    if (_217 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    _218 = 0;
    int64_t _219 = 0; // d
    _jump503:; // Begin body of loop
    _218 += _217;
    _219++;
    if (_219 < _217)
    goto _jump503;
    // End body of loop
    int64_t _220 = _218 * _217;
    _215 += _220;
    _217++;
    if (_217 < _216)
    goto _jump501;
    // End body of loop
    if (_215 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (_215 < _197.d0)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    int64_t _221 = 0;
    _221 *= _197.d0;
    _221 += _215;
    _a2_bool _222 = _197.data[_221];
    _163 = _222;
    _jump492:;
    _150 = _163;
    goto _jump506;
    _jump466:;
    _a2_bool _223;
    // Computing bound for c
    int64_t _224;
    // Computing bound for c
    bool _226 = _74;
    if (0 != _74)
    goto _jump507;
    bool _227 = true;
    _226 = _227;
    _jump507:;
    bool _225 = _226;
    if (0 == _226)
    goto _jump508;
    bool _228;
    if (!_74)
    goto _jump509;
    _228 = _74;
    goto _jump510;
    _jump509:;
    bool _229 = true;
    _228 = _229;
    _jump510:;
    _225 = _228;
    _jump508:;
    int64_t _230;
    if (!_225)
    goto _jump511;
    bool _231 = _74;
    if (0 != _74)
    goto _jump512;
    _231 = _74;
    _jump512:;
    int64_t _232;
    if (!_231)
    goto _jump513;
    int64_t _233 = 984;
    int64_t _234 = -_233;
    _232 = _234;
    goto _jump514;
    _jump513:;
    int64_t _235 = 514;
    int64_t _236 = 726;
    int64_t _237 = _235 + _236;
    _232 = _237;
    _jump514:;
    _230 = _232;
    goto _jump515;
    _jump511:;
    int64_t _238;
    // Computing bound for c
    int64_t _239 = 423;
    int64_t _240 = -_239;
    if (_240 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for d
    int64_t _241 = 163;
    if (_241 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for e
    int64_t _242;
    // Computing bound for c
    int64_t _243 = 911;
    if (_243 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    _242 = 0;
    int64_t _244 = 0; // c
    _jump519:; // Begin body of loop
    _242 += _244;
    _244++;
    if (_244 < _243)
    goto _jump519;
    // End body of loop
    if (_242 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    _238 = 0;
    int64_t _245 = 0; // e
    int64_t _246 = 0; // d
    int64_t _247 = 0; // c
    _jump521:; // Begin body of loop
    _238 += _246;
    _245++;
    if (_245 < _242)
    goto _jump521;
    _245 = 0;
    _246++;
    if (_246 < _241)
    goto _jump521;
    _246 = 0;
    _247++;
    if (_247 < _240)
    goto _jump521;
    // End body of loop
    _230 = _238;
    _jump515:;
    if (_230 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    _224 = 0;
    int64_t _248 = 0; // c
    _jump523:; // Begin body of loop
    int64_t _249 = 632;
    int64_t _250 = -_249;
    _224 += _250;
    _248++;
    if (_248 < _230)
    goto _jump523;
    // End body of loop
    _223.d0 = _224;
    if (_224 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing bound for d
    int64_t _251 = 205;
    _a1_int64_t _252;
    _252.d0 = 1;
    _252.data = jpl_alloc(sizeof(int64_t) * 1);
    _252.data[0] = _251;
    int64_t _253 = 138;
    if (_253 >= 0)
    goto _jump525;
    fail_assertion("negative array index");
    _jump525:;
    if (_253 < _252.d0)
    goto _jump526;
    fail_assertion("index too large");
    _jump526:;
    int64_t _254 = 0;
    _254 *= _252.d0;
    _254 += _253;
    int64_t _255 = _252.data[_254];
    int64_t _256 = -_255;
    int64_t _257 = -_256;
    _223.d1 = _257;
    if (_257 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing total size of heap memory to allocate
    int64_t _258 = 1;
    _258 *= _224;
    _258 *= _257;
    _258 *= sizeof(bool);
    _223.data = jpl_alloc(_258);
    int64_t _259 = 0; // d
    int64_t _260 = 0; // c
    _jump528:; // Begin body of loop
    bool _261 = true;
    bool _262;
    if (!_261)
    goto _jump529;
    int64_t _263 = 823;
    bool _264 = _263 > _260;
    _a1_bool _265;
    if (!_264)
    goto _jump530;
    bool _266 = false;
    _a1_bool _267;
    _267.d0 = 2;
    _267.data = jpl_alloc(sizeof(bool) * 2);
    _267.data[0] = _266;
    _267.data[1] = _74;
    _265 = _267;
    goto _jump531;
    _jump530:;
    _a1_bool _268;
    // Computing bound for e
    _268.d0 = _260;
    if (_260 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing total size of heap memory to allocate
    int64_t _269 = 1;
    _269 *= _260;
    _269 *= sizeof(bool);
    _268.data = jpl_alloc(_269);
    int64_t _270 = 0; // e
    _jump533:; // Begin body of loop
    bool _271 = false;
    int64_t _272 = 0;
    _272 *= _268.d0;
    _272 += _270;
    _268.data[_272] = _271;
    _270++;
    if (_270 < _260)
    goto _jump533;
    // End body of loop
    _265 = _268;
    _jump531:;
    int64_t _273 = -_259;
    if (_273 >= 0)
    goto _jump534;
    fail_assertion("negative array index");
    _jump534:;
    if (_273 < _265.d0)
    goto _jump535;
    fail_assertion("index too large");
    _jump535:;
    int64_t _274 = 0;
    _274 *= _265.d0;
    _274 += _273;
    bool _275 = _265.data[_274];
    _262 = _275;
    goto _jump536;
    _jump529:;
    bool _276 = false;
    bool _277;
    if (!_276)
    goto _jump537;
    bool _278 = true;
    _277 = _278;
    goto _jump538;
    _jump537:;
    _277 = _74;
    _jump538:;
    double _279;
    if (!_277)
    goto _jump539;
    double _280 = 82.0;
    double _281 = -_280;
    _279 = _281;
    goto _jump540;
    _jump539:;
    double _282 = 63.0;
    _279 = _282;
    _jump540:;
    _a1_double _283;
    // Computing bound for e
    _283.d0 = _259;
    if (_259 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _259;
    _284 *= sizeof(double);
    _283.data = jpl_alloc(_284);
    int64_t _285 = 0; // e
    _jump542:; // Begin body of loop
    double _286 = 38.0;
    int64_t _287 = 0;
    _287 *= _283.d0;
    _287 += _285;
    _283.data[_287] = _286;
    _285++;
    if (_285 < _259)
    goto _jump542;
    // End body of loop
    if (_260 >= 0)
    goto _jump543;
    fail_assertion("negative array index");
    _jump543:;
    if (_260 < _283.d0)
    goto _jump544;
    fail_assertion("index too large");
    _jump544:;
    int64_t _288 = 0;
    _288 *= _283.d0;
    _288 += _260;
    double _289 = _283.data[_288];
    bool _290 = _279 <= _289;
    _262 = _290;
    _jump536:;
    int64_t _291 = 0;
    _291 *= _223.d0;
    _291 += _260;
    _291 *= _223.d1;
    _291 += _259;
    _223.data[_291] = _262;
    _259++;
    if (_259 < _257)
    goto _jump528;
    _259 = 0;
    _260++;
    if (_260 < _224)
    goto _jump528;
    // End body of loop
    _150 = _223;
    _jump506:;
    double _292 = get_time();
    print_time(_292 - _112);
    double _293 = get_time();
    double _294 = get_time();
    double _295 = get_time();
    print_time(_295 - _294);
    double _296 = get_time();
    print_time(_296 - _293);
    int64_t _297 = 251;
    _a3__a2_double _298;
    // Computing bound for s
    g _299 = l();
    bool _300 = _299.a;
    int64_t _301;
    if (!_300)
    goto _jump2176;
    _301 = _150.d1;
    goto _jump2177;
    _jump2176:;
    bool _302 = true;
    int64_t _303;
    if (!_302)
    goto _jump2178;
    _303 = _297;
    goto _jump2179;
    _jump2178:;
    _303 = _150.d1;
    _jump2179:;
    _301 = _303;
    _jump2177:;
    _298.d0 = _301;
    if (_301 > 0) 
    goto _jump2180;
    fail_assertion("non-positive loop bound");
    _jump2180:;
    // Computing bound for t
    int64_t _304 = -_150.d0;
    _298.d1 = _304;
    if (_304 > 0) 
    goto _jump2181;
    fail_assertion("non-positive loop bound");
    _jump2181:;
    // Computing bound for u
    g _305 = l();
    int64_t _306 = _305.b;
    int64_t _307 = -_306;
    _298.d2 = _307;
    if (_307 > 0) 
    goto _jump2182;
    fail_assertion("non-positive loop bound");
    _jump2182:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= _301;
    _308 *= _304;
    _308 *= _307;
    _308 *= sizeof(_a2_double);
    _298.data = jpl_alloc(_308);
    int64_t _309 = 0; // u
    int64_t _310 = 0; // t
    int64_t _311 = 0; // s
    _jump2183:; // Begin body of loop
    _a2_double _312;
    // Computing bound for v
    _312.d0 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2184;
    fail_assertion("non-positive loop bound");
    _jump2184:;
    // Computing bound for w
    _312.d1 = _309;
    if (_309 > 0) 
    goto _jump2185;
    fail_assertion("non-positive loop bound");
    _jump2185:;
    // Computing total size of heap memory to allocate
    int64_t _313 = 1;
    _313 *= _150.d1;
    _313 *= _309;
    _313 *= sizeof(double);
    _312.data = jpl_alloc(_313);
    int64_t _314 = 0; // w
    int64_t _315 = 0; // v
    _jump2186:; // Begin body of loop
    double _316;
    // Computing bound for x
    if (_309 > 0) 
    goto _jump2187;
    fail_assertion("non-positive loop bound");
    _jump2187:;
    _316 = 0;
    int64_t _317 = 0; // x
    _jump2188:; // Begin body of loop
    double _318 = 84.0;
    _316 += _318;
    _317++;
    if (_317 < _309)
    goto _jump2188;
    // End body of loop
    int64_t _319 = 0;
    _319 *= _312.d0;
    _319 += _315;
    _319 *= _312.d1;
    _319 += _314;
    _312.data[_319] = _316;
    _314++;
    if (_314 < _309)
    goto _jump2186;
    _314 = 0;
    _315++;
    if (_315 < _150.d1)
    goto _jump2186;
    // End body of loop
    int64_t _320 = 0;
    _320 *= _298.d0;
    _320 += _311;
    _320 *= _298.d1;
    _320 += _310;
    _320 *= _298.d2;
    _320 += _309;
    _298.data[_320] = _312;
    _309++;
    if (_309 < _307)
    goto _jump2183;
    _309 = 0;
    _310++;
    if (_310 < _304)
    goto _jump2183;
    _310 = 0;
    _311++;
    if (_311 < _301)
    goto _jump2183;
    // End body of loop
    int64_t _321;
    if (!_74)
    goto _jump2189;
    _321 = _150.d0;
    goto _jump2190;
    _jump2189:;
    int64_t _322 = -_297;
    _321 = _322;
    _jump2190:;
    if (_297 >= 0)
    goto _jump2191;
    fail_assertion("negative array index");
    _jump2191:;
    if (_297 < _298.d0)
    goto _jump2192;
    fail_assertion("index too large");
    _jump2192:;
    if (_150.d0 >= 0)
    goto _jump2193;
    fail_assertion("negative array index");
    _jump2193:;
    if (_150.d0 < _298.d1)
    goto _jump2194;
    fail_assertion("index too large");
    _jump2194:;
    if (_321 >= 0)
    goto _jump2195;
    fail_assertion("negative array index");
    _jump2195:;
    if (_321 < _298.d2)
    goto _jump2196;
    fail_assertion("index too large");
    _jump2196:;
    int64_t _323 = 0;
    _323 *= _298.d0;
    _323 += _297;
    _323 *= _298.d1;
    _323 += _150.d0;
    _323 *= _298.d2;
    _323 += _321;
    _a2_double _324 = _298.data[_323];
    _a3__a3_int64_t _325;
    // Computing bound for s
    _325.d0 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2197;
    fail_assertion("non-positive loop bound");
    _jump2197:;
    // Computing bound for t
    _325.d1 = _297;
    if (_297 > 0) 
    goto _jump2198;
    fail_assertion("non-positive loop bound");
    _jump2198:;
    // Computing bound for u
    _325.d2 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2199;
    fail_assertion("non-positive loop bound");
    _jump2199:;
    // Computing total size of heap memory to allocate
    int64_t _326 = 1;
    _326 *= _150.d0;
    _326 *= _297;
    _326 *= _150.d0;
    _326 *= sizeof(_a3_int64_t);
    _325.data = jpl_alloc(_326);
    int64_t _327 = 0; // u
    int64_t _328 = 0; // t
    int64_t _329 = 0; // s
    _jump2200:; // Begin body of loop
    _a3_int64_t _330;
    // Computing bound for v
    _330.d0 = _329;
    if (_329 > 0) 
    goto _jump2201;
    fail_assertion("non-positive loop bound");
    _jump2201:;
    // Computing bound for w
    _330.d1 = _329;
    if (_329 > 0) 
    goto _jump2202;
    fail_assertion("non-positive loop bound");
    _jump2202:;
    // Computing bound for x
    _330.d2 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2203;
    fail_assertion("non-positive loop bound");
    _jump2203:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= _329;
    _331 *= _329;
    _331 *= _150.d1;
    _331 *= sizeof(int64_t);
    _330.data = jpl_alloc(_331);
    int64_t _332 = 0; // x
    int64_t _333 = 0; // w
    int64_t _334 = 0; // v
    _jump2204:; // Begin body of loop
    int64_t _335 = 0;
    _335 *= _330.d0;
    _335 += _334;
    _335 *= _330.d1;
    _335 += _333;
    _335 *= _330.d2;
    _335 += _332;
    _330.data[_335] = _333;
    _332++;
    if (_332 < _150.d1)
    goto _jump2204;
    _332 = 0;
    _333++;
    if (_333 < _329)
    goto _jump2204;
    _333 = 0;
    _334++;
    if (_334 < _329)
    goto _jump2204;
    // End body of loop
    int64_t _336 = 0;
    _336 *= _325.d0;
    _336 += _329;
    _336 *= _325.d1;
    _336 += _328;
    _336 *= _325.d2;
    _336 += _327;
    _325.data[_336] = _330;
    _327++;
    if (_327 < _150.d0)
    goto _jump2200;
    _327 = 0;
    _328++;
    if (_328 < _297)
    goto _jump2200;
    _328 = 0;
    _329++;
    if (_329 < _150.d0)
    goto _jump2200;
    // End body of loop
    int64_t _337;
    // Computing bound for s
    int64_t _338 = 460;
    int64_t _339 = -_338;
    if (_339 > 0) 
    goto _jump2205;
    fail_assertion("non-positive loop bound");
    _jump2205:;
    _337 = 0;
    int64_t _340 = 0; // s
    _jump2206:; // Begin body of loop
    bool _341 = false;
    int64_t _342;
    if (!_341)
    goto _jump2207;
    _342 = _297;
    goto _jump2208;
    _jump2207:;
    _342 = _150.d0;
    _jump2208:;
    _337 += _342;
    _340++;
    if (_340 < _339)
    goto _jump2206;
    // End body of loop
    int64_t _343;
    // Computing bound for s
    if (_150.d1 > 0) 
    goto _jump2209;
    fail_assertion("non-positive loop bound");
    _jump2209:;
    _343 = 0;
    int64_t _344 = 0; // s
    _jump2210:; // Begin body of loop
    _343 += _297;
    _344++;
    if (_344 < _150.d1)
    goto _jump2210;
    // End body of loop
    if (_337 >= 0)
    goto _jump2211;
    fail_assertion("negative array index");
    _jump2211:;
    if (_337 < _325.d0)
    goto _jump2212;
    fail_assertion("index too large");
    _jump2212:;
    if (_343 >= 0)
    goto _jump2213;
    fail_assertion("negative array index");
    _jump2213:;
    if (_343 < _325.d1)
    goto _jump2214;
    fail_assertion("index too large");
    _jump2214:;
    if (_150.d1 >= 0)
    goto _jump2215;
    fail_assertion("negative array index");
    _jump2215:;
    if (_150.d1 < _325.d2)
    goto _jump2216;
    fail_assertion("index too large");
    _jump2216:;
    int64_t _345 = 0;
    _345 *= _325.d0;
    _345 += _337;
    _345 *= _325.d1;
    _345 += _343;
    _345 *= _325.d2;
    _345 += _150.d1;
    _a3_int64_t _346 = _325.data[_345];
    int64_t _347;
    // Computing bound for s
    bool _348 = true;
    int64_t _349;
    if (!_348)
    goto _jump2217;
    int64_t _350 = 503;
    _349 = _350;
    goto _jump2218;
    _jump2217:;
    int64_t _351 = 800;
    _349 = _351;
    _jump2218:;
    int64_t _352 = -_349;
    if (_352 > 0) 
    goto _jump2219;
    fail_assertion("non-positive loop bound");
    _jump2219:;
    // Computing bound for t
    int64_t _353 = -_297;
    if (_353 > 0) 
    goto _jump2220;
    fail_assertion("non-positive loop bound");
    _jump2220:;
    _347 = 0;
    int64_t _354 = 0; // t
    int64_t _355 = 0; // s
    _jump2221:; // Begin body of loop
    _a2_int64_t _356;
    // Computing bound for u
    _356.d0 = _297;
    if (_297 > 0) 
    goto _jump2222;
    fail_assertion("non-positive loop bound");
    _jump2222:;
    // Computing bound for v
    _356.d1 = _354;
    if (_354 > 0) 
    goto _jump2223;
    fail_assertion("non-positive loop bound");
    _jump2223:;
    // Computing total size of heap memory to allocate
    int64_t _357 = 1;
    _357 *= _297;
    _357 *= _354;
    _357 *= sizeof(int64_t);
    _356.data = jpl_alloc(_357);
    int64_t _358 = 0; // v
    int64_t _359 = 0; // u
    _jump2224:; // Begin body of loop
    int64_t _360 = 0;
    _360 *= _356.d0;
    _360 += _359;
    _360 *= _356.d1;
    _360 += _358;
    _356.data[_360] = _297;
    _358++;
    if (_358 < _354)
    goto _jump2224;
    _358 = 0;
    _359++;
    if (_359 < _297)
    goto _jump2224;
    // End body of loop
    g _361 = l();
    int64_t _362 = _361.b;
    if (_362 >= 0)
    goto _jump2225;
    fail_assertion("negative array index");
    _jump2225:;
    if (_362 < _356.d0)
    goto _jump2226;
    fail_assertion("index too large");
    _jump2226:;
    if (_355 >= 0)
    goto _jump2227;
    fail_assertion("negative array index");
    _jump2227:;
    if (_355 < _356.d1)
    goto _jump2228;
    fail_assertion("index too large");
    _jump2228:;
    int64_t _363 = 0;
    _363 *= _356.d0;
    _363 += _362;
    _363 *= _356.d1;
    _363 += _355;
    int64_t _364 = _356.data[_363];
    _347 += _364;
    _354++;
    if (_354 < _353)
    goto _jump2221;
    _354 = 0;
    _355++;
    if (_355 < _352)
    goto _jump2221;
    // End body of loop
    int64_t _365 = -_150.d1;
    if (_150.d1 >= 0)
    goto _jump2229;
    fail_assertion("negative array index");
    _jump2229:;
    if (_150.d1 < _346.d0)
    goto _jump2230;
    fail_assertion("index too large");
    _jump2230:;
    if (_347 >= 0)
    goto _jump2231;
    fail_assertion("negative array index");
    _jump2231:;
    if (_347 < _346.d1)
    goto _jump2232;
    fail_assertion("index too large");
    _jump2232:;
    if (_365 >= 0)
    goto _jump2233;
    fail_assertion("negative array index");
    _jump2233:;
    if (_365 < _346.d2)
    goto _jump2234;
    fail_assertion("index too large");
    _jump2234:;
    int64_t _366 = 0;
    _366 *= _346.d0;
    _366 += _150.d1;
    _366 *= _346.d1;
    _366 += _347;
    _366 *= _346.d2;
    _366 += _365;
    int64_t _367 = _346.data[_366];
    int64_t _368 = 649;
    if (_367 >= 0)
    goto _jump2235;
    fail_assertion("negative array index");
    _jump2235:;
    if (_367 < _324.d0)
    goto _jump2236;
    fail_assertion("index too large");
    _jump2236:;
    if (_368 >= 0)
    goto _jump2237;
    fail_assertion("negative array index");
    _jump2237:;
    if (_368 < _324.d1)
    goto _jump2238;
    fail_assertion("index too large");
    _jump2238:;
    int64_t _369 = 0;
    _369 *= _324.d0;
    _369 += _367;
    _369 *= _324.d1;
    _369 += _368;
    double _370 = _324.data[_369];
    _a2_double _371;
    if (!_74)
    goto _jump2239;
    _a3__a2_double _372;
    // Computing bound for s
    _372.d0 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2240;
    fail_assertion("non-positive loop bound");
    _jump2240:;
    // Computing bound for t
    _372.d1 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2241;
    fail_assertion("non-positive loop bound");
    _jump2241:;
    // Computing bound for u
    _372.d2 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2242;
    fail_assertion("non-positive loop bound");
    _jump2242:;
    // Computing total size of heap memory to allocate
    int64_t _373 = 1;
    _373 *= _150.d1;
    _373 *= _150.d1;
    _373 *= _150.d0;
    _373 *= sizeof(_a2_double);
    _372.data = jpl_alloc(_373);
    int64_t _374 = 0; // u
    int64_t _375 = 0; // t
    int64_t _376 = 0; // s
    _jump2243:; // Begin body of loop
    _a2_double _377;
    // Computing bound for v
    _377.d0 = _376;
    if (_376 > 0) 
    goto _jump2244;
    fail_assertion("non-positive loop bound");
    _jump2244:;
    // Computing bound for w
    int64_t _378 = -_297;
    _377.d1 = _378;
    if (_378 > 0) 
    goto _jump2245;
    fail_assertion("non-positive loop bound");
    _jump2245:;
    // Computing total size of heap memory to allocate
    int64_t _379 = 1;
    _379 *= _376;
    _379 *= _378;
    _379 *= sizeof(double);
    _377.data = jpl_alloc(_379);
    int64_t _380 = 0; // w
    int64_t _381 = 0; // v
    _jump2246:; // Begin body of loop
    double _382 = 1.0;
    double _383 = 43.0;
    double _384 = _382 - _383;
    int64_t _385 = 0;
    _385 *= _377.d0;
    _385 += _381;
    _385 *= _377.d1;
    _385 += _380;
    _377.data[_385] = _384;
    _380++;
    if (_380 < _378)
    goto _jump2246;
    _380 = 0;
    _381++;
    if (_381 < _376)
    goto _jump2246;
    // End body of loop
    int64_t _386 = 0;
    _386 *= _372.d0;
    _386 += _376;
    _386 *= _372.d1;
    _386 += _375;
    _386 *= _372.d2;
    _386 += _374;
    _372.data[_386] = _377;
    _374++;
    if (_374 < _150.d0)
    goto _jump2243;
    _374 = 0;
    _375++;
    if (_375 < _150.d1)
    goto _jump2243;
    _375 = 0;
    _376++;
    if (_376 < _150.d1)
    goto _jump2243;
    // End body of loop
    if (_297 >= 0)
    goto _jump2247;
    fail_assertion("negative array index");
    _jump2247:;
    if (_297 < _372.d0)
    goto _jump2248;
    fail_assertion("index too large");
    _jump2248:;
    if (_150.d0 >= 0)
    goto _jump2249;
    fail_assertion("negative array index");
    _jump2249:;
    if (_150.d0 < _372.d1)
    goto _jump2250;
    fail_assertion("index too large");
    _jump2250:;
    if (_297 >= 0)
    goto _jump2251;
    fail_assertion("negative array index");
    _jump2251:;
    if (_297 < _372.d2)
    goto _jump2252;
    fail_assertion("index too large");
    _jump2252:;
    int64_t _387 = 0;
    _387 *= _372.d0;
    _387 += _297;
    _387 *= _372.d1;
    _387 += _150.d0;
    _387 *= _372.d2;
    _387 += _297;
    _a2_double _388 = _372.data[_387];
    _371 = _388;
    goto _jump2253;
    _jump2239:;
    _a2_double _389;
    // Computing bound for s
    int64_t _390;
    // Computing bound for s
    if (_150.d0 > 0) 
    goto _jump2254;
    fail_assertion("non-positive loop bound");
    _jump2254:;
    // Computing bound for t
    if (_150.d1 > 0) 
    goto _jump2255;
    fail_assertion("non-positive loop bound");
    _jump2255:;
    _390 = 0;
    int64_t _391 = 0; // t
    int64_t _392 = 0; // s
    _jump2256:; // Begin body of loop
    int64_t _393 = _392 * _150.d1;
    _390 += _393;
    _391++;
    if (_391 < _150.d1)
    goto _jump2256;
    _391 = 0;
    _392++;
    if (_392 < _150.d0)
    goto _jump2256;
    // End body of loop
    _389.d0 = _390;
    if (_390 > 0) 
    goto _jump2257;
    fail_assertion("non-positive loop bound");
    _jump2257:;
    // Computing bound for t
    _389.d1 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2258;
    fail_assertion("non-positive loop bound");
    _jump2258:;
    // Computing total size of heap memory to allocate
    int64_t _394 = 1;
    _394 *= _390;
    _394 *= _150.d0;
    _394 *= sizeof(double);
    _389.data = jpl_alloc(_394);
    int64_t _395 = 0; // t
    int64_t _396 = 0; // s
    _jump2259:; // Begin body of loop
    double _397;
    // Computing bound for u
    if (_395 > 0) 
    goto _jump2260;
    fail_assertion("non-positive loop bound");
    _jump2260:;
    // Computing bound for v
    if (_150.d1 > 0) 
    goto _jump2261;
    fail_assertion("non-positive loop bound");
    _jump2261:;
    _397 = 0;
    int64_t _398 = 0; // v
    int64_t _399 = 0; // u
    _jump2262:; // Begin body of loop
    double _400 = 31.0;
    double _401 = -_400;
    _397 += _401;
    _398++;
    if (_398 < _150.d1)
    goto _jump2262;
    _398 = 0;
    _399++;
    if (_399 < _395)
    goto _jump2262;
    // End body of loop
    int64_t _402 = 0;
    _402 *= _389.d0;
    _402 += _396;
    _402 *= _389.d1;
    _402 += _395;
    _389.data[_402] = _397;
    _395++;
    if (_395 < _150.d0)
    goto _jump2259;
    _395 = 0;
    _396++;
    if (_396 < _390)
    goto _jump2259;
    // End body of loop
    _371 = _389;
    _jump2253:;
    bool _403 = f(_370, _371);
    _a2_bool _404;
    if (!_403)
    goto _jump2263;
    _404 = _150;
    goto _jump2264;
    _jump2263:;
    g _405 = { _74, _150.d0 };
    bool _406 = _405.a;
    bool _407 = false;
    bool _408;
    if (!_407)
    goto _jump2265;
    bool _409 = false;
    _408 = _409;
    goto _jump2266;
    _jump2265:;
    bool _411 = _74;
    if (0 == _74)
    goto _jump2267;
    bool _412 = !_74;
    _411 = _412;
    _jump2267:;
    bool _410 = _411;
    if (0 != _411)
    goto _jump2268;
    bool _414 = false;
    bool _415 = !_414;
    bool _413 = _415;
    if (0 == _415)
    goto _jump2269;
    bool _416 = true;
    bool _417;
    if (!_416)
    goto _jump2270;
    _417 = _74;
    goto _jump2271;
    _jump2270:;
    _417 = _74;
    _jump2271:;
    _413 = _417;
    _jump2269:;
    _410 = _413;
    _jump2268:;
    _408 = _410;
    _jump2266:;
    bool _418 = _406 == _408;
    _a2_bool _419;
    if (!_418)
    goto _jump2272;
    _419 = _150;
    goto _jump2273;
    _jump2272:;
    _419 = _150;
    _jump2273:;
    _404 = _419;
    _jump2264:;
    _a2__a1__a1_int64_t _420;
    if (!_74)
    goto _jump2274;
    _a2_g _421;
    // Computing bound for x
    int64_t _422 = 282;
    _421.d0 = _422;
    if (_422 > 0) 
    goto _jump2275;
    fail_assertion("non-positive loop bound");
    _jump2275:;
    // Computing bound for y
    _421.d1 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2276;
    fail_assertion("non-positive loop bound");
    _jump2276:;
    // Computing total size of heap memory to allocate
    int64_t _423 = 1;
    _423 *= _422;
    _423 *= _150.d0;
    _423 *= sizeof(g);
    _421.data = jpl_alloc(_423);
    int64_t _424 = 0; // y
    int64_t _425 = 0; // x
    _jump2277:; // Begin body of loop
    g _426 = l();
    int64_t _427 = 0;
    _427 *= _421.d0;
    _427 += _425;
    _427 *= _421.d1;
    _427 += _424;
    _421.data[_427] = _426;
    _424++;
    if (_424 < _150.d0)
    goto _jump2277;
    _424 = 0;
    _425++;
    if (_425 < _422)
    goto _jump2277;
    // End body of loop
    int64_t _428 = 254;
    if (_150.d0 >= 0)
    goto _jump2278;
    fail_assertion("negative array index");
    _jump2278:;
    if (_150.d0 < _421.d0)
    goto _jump2279;
    fail_assertion("index too large");
    _jump2279:;
    if (_428 >= 0)
    goto _jump2280;
    fail_assertion("negative array index");
    _jump2280:;
    if (_428 < _421.d1)
    goto _jump2281;
    fail_assertion("index too large");
    _jump2281:;
    int64_t _429 = 0;
    _429 *= _421.d0;
    _429 += _150.d0;
    _429 *= _421.d1;
    _429 += _428;
    g _430 = _421.data[_429];
    bool _431 = _430.a;
    _a2__a1__a1_int64_t _432;
    if (!_431)
    goto _jump2282;
    _a2__a1__a1_int64_t _433;
    // Computing bound for x
    g _434 = l();
    int64_t _435 = _434.b;
    _433.d0 = _435;
    if (_435 > 0) 
    goto _jump2283;
    fail_assertion("non-positive loop bound");
    _jump2283:;
    // Computing bound for y
    g _436 = l();
    int64_t _437 = _436.b;
    _433.d1 = _437;
    if (_437 > 0) 
    goto _jump2284;
    fail_assertion("non-positive loop bound");
    _jump2284:;
    // Computing total size of heap memory to allocate
    int64_t _438 = 1;
    _438 *= _435;
    _438 *= _437;
    _438 *= sizeof(_a1__a1_int64_t);
    _433.data = jpl_alloc(_438);
    int64_t _439 = 0; // y
    int64_t _440 = 0; // x
    _jump2285:; // Begin body of loop
    _a1__a1_int64_t _441;
    // Computing bound for z
    _441.d0 = _439;
    if (_439 > 0) 
    goto _jump2286;
    fail_assertion("non-positive loop bound");
    _jump2286:;
    // Computing total size of heap memory to allocate
    int64_t _442 = 1;
    _442 *= _439;
    _442 *= sizeof(_a1_int64_t);
    _441.data = jpl_alloc(_442);
    int64_t _443 = 0; // z
    _jump2287:; // Begin body of loop
    _a1_int64_t _444;
    _444.d0 = 3;
    _444.data = jpl_alloc(sizeof(int64_t) * 3);
    _444.data[0] = _440;
    _444.data[1] = _150.d0;
    _444.data[2] = _150.d0;
    int64_t _445 = 0;
    _445 *= _441.d0;
    _445 += _443;
    _441.data[_445] = _444;
    _443++;
    if (_443 < _439)
    goto _jump2287;
    // End body of loop
    int64_t _446 = 0;
    _446 *= _433.d0;
    _446 += _440;
    _446 *= _433.d1;
    _446 += _439;
    _433.data[_446] = _441;
    _439++;
    if (_439 < _437)
    goto _jump2285;
    _439 = 0;
    _440++;
    if (_440 < _435)
    goto _jump2285;
    // End body of loop
    _432 = _433;
    goto _jump2288;
    _jump2282:;
    _a2__a1__a1_int64_t _447;
    // Computing bound for x
    int64_t _448 = 657;
    _447.d0 = _448;
    if (_448 > 0) 
    goto _jump2289;
    fail_assertion("non-positive loop bound");
    _jump2289:;
    // Computing bound for y
    int64_t _449 = -_150.d0;
    _447.d1 = _449;
    if (_449 > 0) 
    goto _jump2290;
    fail_assertion("non-positive loop bound");
    _jump2290:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= _448;
    _450 *= _449;
    _450 *= sizeof(_a1__a1_int64_t);
    _447.data = jpl_alloc(_450);
    int64_t _451 = 0; // y
    int64_t _452 = 0; // x
    _jump2291:; // Begin body of loop
    _a1__a1_int64_t _453;
    // Computing bound for z
    _453.d0 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2292;
    fail_assertion("non-positive loop bound");
    _jump2292:;
    // Computing total size of heap memory to allocate
    int64_t _454 = 1;
    _454 *= _150.d1;
    _454 *= sizeof(_a1_int64_t);
    _453.data = jpl_alloc(_454);
    int64_t _455 = 0; // z
    _jump2293:; // Begin body of loop
    _a1_int64_t _456;
    _456.d0 = 2;
    _456.data = jpl_alloc(sizeof(int64_t) * 2);
    _456.data[0] = _404.d0;
    _456.data[1] = _404.d1;
    int64_t _457 = 0;
    _457 *= _453.d0;
    _457 += _455;
    _453.data[_457] = _456;
    _455++;
    if (_455 < _150.d1)
    goto _jump2293;
    // End body of loop
    int64_t _458 = 0;
    _458 *= _447.d0;
    _458 += _452;
    _458 *= _447.d1;
    _458 += _451;
    _447.data[_458] = _453;
    _451++;
    if (_451 < _449)
    goto _jump2291;
    _451 = 0;
    _452++;
    if (_452 < _448)
    goto _jump2291;
    // End body of loop
    _432 = _447;
    _jump2288:;
    _420 = _432;
    goto _jump2294;
    _jump2274:;
    _a2__a1__a1_int64_t _459;
    // Computing bound for x
    _459.d0 = _297;
    if (_297 > 0) 
    goto _jump2295;
    fail_assertion("non-positive loop bound");
    _jump2295:;
    // Computing bound for y
    _459.d1 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2296;
    fail_assertion("non-positive loop bound");
    _jump2296:;
    // Computing total size of heap memory to allocate
    int64_t _460 = 1;
    _460 *= _297;
    _460 *= _150.d1;
    _460 *= sizeof(_a1__a1_int64_t);
    _459.data = jpl_alloc(_460);
    int64_t _461 = 0; // y
    int64_t _462 = 0; // x
    _jump2297:; // Begin body of loop
    _a1__a1_int64_t _463;
    // Computing bound for z
    bool _464 = _150.d1 != _297;
    int64_t _465;
    if (!_464)
    goto _jump2298;
    bool _466 = true;
    int64_t _467;
    if (!_466)
    goto _jump2299;
    int64_t _468 = 145;
    _467 = _468;
    goto _jump2300;
    _jump2299:;
    _467 = _404.d1;
    _jump2300:;
    _465 = _467;
    goto _jump2301;
    _jump2298:;
    _465 = _404.d1;
    _jump2301:;
    _463.d0 = _465;
    if (_465 > 0) 
    goto _jump2302;
    fail_assertion("non-positive loop bound");
    _jump2302:;
    // Computing total size of heap memory to allocate
    int64_t _469 = 1;
    _469 *= _465;
    _469 *= sizeof(_a1_int64_t);
    _463.data = jpl_alloc(_469);
    int64_t _470 = 0; // z
    _jump2303:; // Begin body of loop
    _a1_int64_t _471;
    _471.d0 = 3;
    _471.data = jpl_alloc(sizeof(int64_t) * 3);
    _471.data[0] = _150.d0;
    _471.data[1] = _150.d0;
    _471.data[2] = _404.d0;
    int64_t _472 = 0;
    _472 *= _463.d0;
    _472 += _470;
    _463.data[_472] = _471;
    _470++;
    if (_470 < _465)
    goto _jump2303;
    // End body of loop
    int64_t _473 = 0;
    _473 *= _459.d0;
    _473 += _462;
    _473 *= _459.d1;
    _473 += _461;
    _459.data[_473] = _463;
    _461++;
    if (_461 < _150.d1)
    goto _jump2297;
    _461 = 0;
    _462++;
    if (_462 < _297)
    goto _jump2297;
    // End body of loop
    _420 = _459;
    _jump2294:;
    _a1_bool _474;
    // Computing bound for x
    _474.d0 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2304;
    fail_assertion("non-positive loop bound");
    _jump2304:;
    // Computing total size of heap memory to allocate
    int64_t _475 = 1;
    _475 *= _150.d0;
    _475 *= sizeof(bool);
    _474.data = jpl_alloc(_475);
    int64_t _476 = 0; // x
    _jump2305:; // Begin body of loop
    int64_t _477 = 427;
    int64_t _478 = 340;
    bool _479 = _477 > _478;
    bool _480;
    if (!_479)
    goto _jump2306;
    _480 = _74;
    goto _jump2307;
    _jump2306:;
    _480 = _74;
    _jump2307:;
    int64_t _481 = 0;
    _481 *= _474.d0;
    _481 += _476;
    _474.data[_481] = _480;
    _476++;
    if (_476 < _150.d0)
    goto _jump2305;
    // End body of loop
    _a2_int64_t _482;
    // Computing bound for x
    int64_t _483;
    // Computing bound for x
    if (_150.d1 > 0) 
    goto _jump2308;
    fail_assertion("non-positive loop bound");
    _jump2308:;
    // Computing bound for y
    if (_150.d1 > 0) 
    goto _jump2309;
    fail_assertion("non-positive loop bound");
    _jump2309:;
    // Computing bound for z
    if (_150.d0 > 0) 
    goto _jump2310;
    fail_assertion("non-positive loop bound");
    _jump2310:;
    _483 = 0;
    int64_t _484 = 0; // z
    int64_t _485 = 0; // y
    int64_t _486 = 0; // x
    _jump2311:; // Begin body of loop
    int64_t _487 = 979;
    _483 += _487;
    _484++;
    if (_484 < _150.d0)
    goto _jump2311;
    _484 = 0;
    _485++;
    if (_485 < _150.d1)
    goto _jump2311;
    _485 = 0;
    _486++;
    if (_486 < _150.d1)
    goto _jump2311;
    // End body of loop
    _482.d0 = _483;
    if (_483 > 0) 
    goto _jump2312;
    fail_assertion("non-positive loop bound");
    _jump2312:;
    // Computing bound for y
    _482.d1 = _404.d1;
    if (_404.d1 > 0) 
    goto _jump2313;
    fail_assertion("non-positive loop bound");
    _jump2313:;
    // Computing total size of heap memory to allocate
    int64_t _488 = 1;
    _488 *= _483;
    _488 *= _404.d1;
    _488 *= sizeof(int64_t);
    _482.data = jpl_alloc(_488);
    int64_t _489 = 0; // y
    int64_t _490 = 0; // x
    _jump2314:; // Begin body of loop
    int64_t _491 = -_150.d1;
    int64_t _492 = 0;
    _492 *= _482.d0;
    _492 += _490;
    _492 *= _482.d1;
    _492 += _489;
    _482.data[_492] = _491;
    _489++;
    if (_489 < _404.d1)
    goto _jump2314;
    _489 = 0;
    _490++;
    if (_490 < _483)
    goto _jump2314;
    // End body of loop
    if (_150.d1 >= 0)
    goto _jump2315;
    fail_assertion("negative array index");
    _jump2315:;
    if (_150.d1 < _482.d0)
    goto _jump2316;
    fail_assertion("index too large");
    _jump2316:;
    if (_297 >= 0)
    goto _jump2317;
    fail_assertion("negative array index");
    _jump2317:;
    if (_297 < _482.d1)
    goto _jump2318;
    fail_assertion("index too large");
    _jump2318:;
    int64_t _493 = 0;
    _493 *= _482.d0;
    _493 += _150.d1;
    _493 *= _482.d1;
    _493 += _297;
    int64_t _494 = _482.data[_493];
    if (_494 >= 0)
    goto _jump2319;
    fail_assertion("negative array index");
    _jump2319:;
    if (_494 < _474.d0)
    goto _jump2320;
    fail_assertion("index too large");
    _jump2320:;
    int64_t _495 = 0;
    _495 *= _474.d0;
    _495 += _494;
    bool _496 = _474.data[_495];
    int64_t _497;
    if (!_496)
    goto _jump2321;
    _497 = _297;
    goto _jump2322;
    _jump2321:;
    _497 = _150.d1;
    _jump2322:;
    if (_150.d0 >= 0)
    goto _jump2323;
    fail_assertion("negative array index");
    _jump2323:;
    if (_150.d0 < _420.d0)
    goto _jump2324;
    fail_assertion("index too large");
    _jump2324:;
    if (_497 >= 0)
    goto _jump2325;
    fail_assertion("negative array index");
    _jump2325:;
    if (_497 < _420.d1)
    goto _jump2326;
    fail_assertion("index too large");
    _jump2326:;
    int64_t _498 = 0;
    _498 *= _420.d0;
    _498 += _150.d0;
    _498 *= _420.d1;
    _498 += _497;
    _a1__a1_int64_t _499 = _420.data[_498];
    _a1_w _500;
    // Computing bound for x
    _500.d0 = _404.d0;
    if (_404.d0 > 0) 
    goto _jump2327;
    fail_assertion("non-positive loop bound");
    _jump2327:;
    // Computing total size of heap memory to allocate
    int64_t _501 = 1;
    _501 *= _404.d0;
    _501 *= sizeof(w);
    _500.data = jpl_alloc(_501);
    int64_t _502 = 0; // x
    _jump2328:; // Begin body of loop
    g _503 = l();
    w _504 = { _503 };
    int64_t _505 = 0;
    _505 *= _500.d0;
    _505 += _502;
    _500.data[_505] = _504;
    _502++;
    if (_502 < _404.d0)
    goto _jump2328;
    // End body of loop
    g _506 = l();
    bool _507 = _506.a;
    int64_t _508;
    if (!_507)
    goto _jump2329;
    int64_t _509;
    // Computing bound for x
    if (_150.d0 > 0) 
    goto _jump2330;
    fail_assertion("non-positive loop bound");
    _jump2330:;
    // Computing bound for y
    if (_404.d1 > 0) 
    goto _jump2331;
    fail_assertion("non-positive loop bound");
    _jump2331:;
    _509 = 0;
    int64_t _510 = 0; // y
    int64_t _511 = 0; // x
    _jump2332:; // Begin body of loop
    _509 += _404.d1;
    _510++;
    if (_510 < _404.d1)
    goto _jump2332;
    _510 = 0;
    _511++;
    if (_511 < _150.d0)
    goto _jump2332;
    // End body of loop
    _508 = _509;
    goto _jump2333;
    _jump2329:;
    _508 = _150.d1;
    _jump2333:;
    int64_t _512 = -_508;
    if (_512 >= 0)
    goto _jump2334;
    fail_assertion("negative array index");
    _jump2334:;
    if (_512 < _500.d0)
    goto _jump2335;
    fail_assertion("index too large");
    _jump2335:;
    int64_t _513 = 0;
    _513 *= _500.d0;
    _513 += _512;
    w _514 = _500.data[_513];
    g _515 = _514.a;
    int64_t _516 = _515.b;
    if (_516 >= 0)
    goto _jump2336;
    fail_assertion("negative array index");
    _jump2336:;
    if (_516 < _499.d0)
    goto _jump2337;
    fail_assertion("index too large");
    _jump2337:;
    int64_t _517 = 0;
    _517 *= _499.d0;
    _517 += _516;
    _a1_int64_t _518 = _499.data[_517];
    show("(ArrayType (BoolType) 2)", &_150);
    int64_t _519 = 362;
    bool _520 = _150.d1 < _519;
    if (0 != _520)
    goto _jump2581;
    fail_assertion("A");
    _jump2581:;
    _a2_rgba _521;
    // Computing bound for B
    bool _522 = true;
    bool _523 = !_522;
    int64_t _524;
    if (!_523)
    goto _jump2700;
    _a3__a3_double _525;
    // Computing bound for B
    _525.d0 = _297;
    if (_297 > 0) 
    goto _jump2701;
    fail_assertion("non-positive loop bound");
    _jump2701:;
    // Computing bound for C
    int64_t _526 = 233;
    _a1_int64_t _527;
    _527.d0 = 2;
    _527.data = jpl_alloc(sizeof(int64_t) * 2);
    _527.data[0] = _526;
    _527.data[1] = _518.d0;
    if (_404.d1 >= 0)
    goto _jump2702;
    fail_assertion("negative array index");
    _jump2702:;
    if (_404.d1 < _527.d0)
    goto _jump2703;
    fail_assertion("index too large");
    _jump2703:;
    int64_t _528 = 0;
    _528 *= _527.d0;
    _528 += _404.d1;
    int64_t _529 = _527.data[_528];
    _525.d1 = _529;
    if (_529 > 0) 
    goto _jump2704;
    fail_assertion("non-positive loop bound");
    _jump2704:;
    // Computing bound for D
    int64_t _530 = 920;
    _525.d2 = _530;
    if (_530 > 0) 
    goto _jump2705;
    fail_assertion("non-positive loop bound");
    _jump2705:;
    // Computing total size of heap memory to allocate
    int64_t _531 = 1;
    _531 *= _297;
    _531 *= _529;
    _531 *= _530;
    _531 *= sizeof(_a3_double);
    _525.data = jpl_alloc(_531);
    int64_t _532 = 0; // D
    int64_t _533 = 0; // C
    int64_t _534 = 0; // B
    _jump2706:; // Begin body of loop
    _a3_double _535;
    // Computing bound for E
    _535.d0 = _297;
    if (_297 > 0) 
    goto _jump2707;
    fail_assertion("non-positive loop bound");
    _jump2707:;
    // Computing bound for F
    int64_t _536 = _150.d1 + _533;
    _535.d1 = _536;
    if (_536 > 0) 
    goto _jump2708;
    fail_assertion("non-positive loop bound");
    _jump2708:;
    // Computing bound for G
    int64_t _537 = 342;
    _535.d2 = _537;
    if (_537 > 0) 
    goto _jump2709;
    fail_assertion("non-positive loop bound");
    _jump2709:;
    // Computing total size of heap memory to allocate
    int64_t _538 = 1;
    _538 *= _297;
    _538 *= _536;
    _538 *= _537;
    _538 *= sizeof(double);
    _535.data = jpl_alloc(_538);
    int64_t _539 = 0; // G
    int64_t _540 = 0; // F
    int64_t _541 = 0; // E
    _jump2710:; // Begin body of loop
    double _542 = 4.0;
    int64_t _543 = 0;
    _543 *= _535.d0;
    _543 += _541;
    _543 *= _535.d1;
    _543 += _540;
    _543 *= _535.d2;
    _543 += _539;
    _535.data[_543] = _542;
    _539++;
    if (_539 < _537)
    goto _jump2710;
    _539 = 0;
    _540++;
    if (_540 < _536)
    goto _jump2710;
    _540 = 0;
    _541++;
    if (_541 < _297)
    goto _jump2710;
    // End body of loop
    int64_t _544 = 0;
    _544 *= _525.d0;
    _544 += _534;
    _544 *= _525.d1;
    _544 += _533;
    _544 *= _525.d2;
    _544 += _532;
    _525.data[_544] = _535;
    _532++;
    if (_532 < _530)
    goto _jump2706;
    _532 = 0;
    _533++;
    if (_533 < _529)
    goto _jump2706;
    _533 = 0;
    _534++;
    if (_534 < _297)
    goto _jump2706;
    // End body of loop
    double _545;
    // Computing bound for B
    int64_t _546;
    // Computing bound for B
    if (_404.d1 > 0) 
    goto _jump2711;
    fail_assertion("non-positive loop bound");
    _jump2711:;
    // Computing bound for C
    if (_404.d0 > 0) 
    goto _jump2712;
    fail_assertion("non-positive loop bound");
    _jump2712:;
    _546 = 0;
    int64_t _547 = 0; // C
    int64_t _548 = 0; // B
    _jump2713:; // Begin body of loop
    _546 += _404.d0;
    _547++;
    if (_547 < _404.d0)
    goto _jump2713;
    _547 = 0;
    _548++;
    if (_548 < _404.d1)
    goto _jump2713;
    // End body of loop
    int64_t _549 = -_546;
    if (_549 > 0) 
    goto _jump2714;
    fail_assertion("non-positive loop bound");
    _jump2714:;
    // Computing bound for C
    if (_404.d0 > 0) 
    goto _jump2715;
    fail_assertion("non-positive loop bound");
    _jump2715:;
    _545 = 0;
    int64_t _550 = 0; // C
    int64_t _551 = 0; // B
    _jump2716:; // Begin body of loop
    double _552 = z();
    _545 += _552;
    _550++;
    if (_550 < _404.d0)
    goto _jump2716;
    _550 = 0;
    _551++;
    if (_551 < _549)
    goto _jump2716;
    // End body of loop
    k _553 = { _525, _404.d1, _545 };
    int64_t _554 = _553.b;
    _524 = _554;
    goto _jump2717;
    _jump2700:;
    int64_t _555 = _404.d1 - _150.d1;
    _524 = _555;
    _jump2717:;
    _521.d0 = _524;
    if (_524 > 0) 
    goto _jump2718;
    fail_assertion("non-positive loop bound");
    _jump2718:;
    // Computing bound for C
    _521.d1 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2719;
    fail_assertion("non-positive loop bound");
    _jump2719:;
    // Computing total size of heap memory to allocate
    int64_t _556 = 1;
    _556 *= _524;
    _556 *= _150.d1;
    _556 *= sizeof(rgba);
    _521.data = jpl_alloc(_556);
    int64_t _557 = 0; // C
    int64_t _558 = 0; // B
    _jump2720:; // Begin body of loop
    bool _560 = false;
    bool _559 = _560;
    if (0 == _560)
    goto _jump2721;
    int64_t _561;
    // Computing bound for D
    if (_150.d1 > 0) 
    goto _jump2722;
    fail_assertion("non-positive loop bound");
    _jump2722:;
    // Computing bound for E
    if (_150.d0 > 0) 
    goto _jump2723;
    fail_assertion("non-positive loop bound");
    _jump2723:;
    // Computing bound for F
    if (_150.d1 > 0) 
    goto _jump2724;
    fail_assertion("non-positive loop bound");
    _jump2724:;
    _561 = 0;
    int64_t _562 = 0; // F
    int64_t _563 = 0; // E
    int64_t _564 = 0; // D
    _jump2725:; // Begin body of loop
    _561 += _150.d1;
    _562++;
    if (_562 < _150.d1)
    goto _jump2725;
    _562 = 0;
    _563++;
    if (_563 < _150.d0)
    goto _jump2725;
    _563 = 0;
    _564++;
    if (_564 < _150.d1)
    goto _jump2725;
    // End body of loop
    int64_t _565 = -_518.d0;
    bool _566 = _561 > _565;
    bool _567;
    if (!_566)
    goto _jump2726;
    double _568 = z();
    double _569 = 61.0;
    double _570 = _568 - _569;
    rgba _571 = j();
    double _572 = _571.b;
    bool _573 = _570 > _572;
    _567 = _573;
    goto _jump2727;
    _jump2726:;
    _567 = _74;
    _jump2727:;
    _559 = _567;
    _jump2721:;
    bool _574 = true;
    bool _575 = _559 == _574;
    rgba _576;
    if (!_575)
    goto _jump2728;
    double _577 = z();
    double _578 = -_577;
    rgba _579 = j();
    double _580 = _579.g;
    double _581 = 67.0;
    _a2_double _582;
    // Computing bound for D
    _582.d0 = _557;
    if (_557 > 0) 
    goto _jump2729;
    fail_assertion("non-positive loop bound");
    _jump2729:;
    // Computing bound for E
    _582.d1 = _404.d1;
    if (_404.d1 > 0) 
    goto _jump2730;
    fail_assertion("non-positive loop bound");
    _jump2730:;
    // Computing total size of heap memory to allocate
    int64_t _583 = 1;
    _583 *= _557;
    _583 *= _404.d1;
    _583 *= sizeof(double);
    _582.data = jpl_alloc(_583);
    int64_t _584 = 0; // E
    int64_t _585 = 0; // D
    _jump2731:; // Begin body of loop
    double _586 = z();
    int64_t _587 = 0;
    _587 *= _582.d0;
    _587 += _585;
    _587 *= _582.d1;
    _587 += _584;
    _582.data[_587] = _586;
    _584++;
    if (_584 < _404.d1)
    goto _jump2731;
    _584 = 0;
    _585++;
    if (_585 < _557)
    goto _jump2731;
    // End body of loop
    if (_404.d1 >= 0)
    goto _jump2732;
    fail_assertion("negative array index");
    _jump2732:;
    if (_404.d1 < _582.d0)
    goto _jump2733;
    fail_assertion("index too large");
    _jump2733:;
    if (_518.d0 >= 0)
    goto _jump2734;
    fail_assertion("negative array index");
    _jump2734:;
    if (_518.d0 < _582.d1)
    goto _jump2735;
    fail_assertion("index too large");
    _jump2735:;
    int64_t _588 = 0;
    _588 *= _582.d0;
    _588 += _404.d1;
    _588 *= _582.d1;
    _588 += _518.d0;
    double _589 = _582.data[_588];
    rgba _590 = j();
    double _591 = _590.r;
    rgba _592 = { _580, _581, _589, _591 };
    double _593 = _592.r;
    bool _594 = true;
    rgba _595;
    if (!_594)
    goto _jump2736;
    rgba _596 = j();
    _595 = _596;
    goto _jump2737;
    _jump2736:;
    rgba _597 = j();
    _595 = _597;
    _jump2737:;
    double _598 = _595.b;
    _a2_double _599;
    // Computing bound for D
    int64_t _600 = 432;
    int64_t _601 = _600 * _150.d0;
    _599.d0 = _601;
    if (_601 > 0) 
    goto _jump2738;
    fail_assertion("non-positive loop bound");
    _jump2738:;
    // Computing bound for E
    _599.d1 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2739;
    fail_assertion("non-positive loop bound");
    _jump2739:;
    // Computing total size of heap memory to allocate
    int64_t _602 = 1;
    _602 *= _601;
    _602 *= _150.d1;
    _602 *= sizeof(double);
    _599.data = jpl_alloc(_602);
    int64_t _603 = 0; // E
    int64_t _604 = 0; // D
    _jump2740:; // Begin body of loop
    rgba _605 = j();
    double _606 = _605.g;
    int64_t _607 = 0;
    _607 *= _599.d0;
    _607 += _604;
    _607 *= _599.d1;
    _607 += _603;
    _599.data[_607] = _606;
    _603++;
    if (_603 < _150.d1)
    goto _jump2740;
    _603 = 0;
    _604++;
    if (_604 < _601)
    goto _jump2740;
    // End body of loop
    bool _608 = f(_598, _599);
    double _609;
    if (!_608)
    goto _jump2741;
    double _610;
    if (!_74)
    goto _jump2742;
    double _611 = z();
    _610 = _611;
    goto _jump2743;
    _jump2742:;
    rgba _612 = j();
    double _613 = _612.g;
    _610 = _613;
    _jump2743:;
    double _614 = -_610;
    _609 = _614;
    goto _jump2744;
    _jump2741:;
    double _615;
    // Computing bound for D
    if (_150.d1 > 0) 
    goto _jump2745;
    fail_assertion("non-positive loop bound");
    _jump2745:;
    _615 = 0;
    int64_t _616 = 0; // D
    _jump2746:; // Begin body of loop
    double _617 = 51.0;
    _615 += _617;
    _616++;
    if (_616 < _150.d1)
    goto _jump2746;
    // End body of loop
    double _618 = -_615;
    double _619;
    // Computing bound for D
    if (_518.d0 > 0) 
    goto _jump2747;
    fail_assertion("non-positive loop bound");
    _jump2747:;
    // Computing bound for E
    if (_150.d0 > 0) 
    goto _jump2748;
    fail_assertion("non-positive loop bound");
    _jump2748:;
    // Computing bound for F
    if (_150.d0 > 0) 
    goto _jump2749;
    fail_assertion("non-positive loop bound");
    _jump2749:;
    _619 = 0;
    int64_t _620 = 0; // F
    int64_t _621 = 0; // E
    int64_t _622 = 0; // D
    _jump2750:; // Begin body of loop
    double _623 = 88.0;
    _619 += _623;
    _620++;
    if (_620 < _150.d0)
    goto _jump2750;
    _620 = 0;
    _621++;
    if (_621 < _150.d0)
    goto _jump2750;
    _621 = 0;
    _622++;
    if (_622 < _518.d0)
    goto _jump2750;
    // End body of loop
    double _624 = -_619;
    double _625 = _618 / _624;
    _609 = _625;
    _jump2744:;
    double _626;
    // Computing bound for D
    if (_404.d1 > 0) 
    goto _jump2751;
    fail_assertion("non-positive loop bound");
    _jump2751:;
    // Computing bound for E
    int64_t _627 = _557 - _404.d1;
    if (_627 > 0) 
    goto _jump2752;
    fail_assertion("non-positive loop bound");
    _jump2752:;
    _626 = 0;
    int64_t _628 = 0; // E
    int64_t _629 = 0; // D
    _jump2753:; // Begin body of loop
    double _630 = 69.0;
    double _631 = -_630;
    _626 += _631;
    _628++;
    if (_628 < _627)
    goto _jump2753;
    _628 = 0;
    _629++;
    if (_629 < _404.d1)
    goto _jump2753;
    // End body of loop
    double _632;
    // Computing bound for D
    if (_404.d1 > 0) 
    goto _jump2754;
    fail_assertion("non-positive loop bound");
    _jump2754:;
    _632 = 0;
    int64_t _633 = 0; // D
    _jump2755:; // Begin body of loop
    double _634;
    if (!_74)
    goto _jump2756;
    double _635 = z();
    _634 = _635;
    goto _jump2757;
    _jump2756:;
    double _636 = 18.0;
    _634 = _636;
    _jump2757:;
    _632 += _634;
    _633++;
    if (_633 < _404.d1)
    goto _jump2755;
    // End body of loop
    _a3_double _637;
    // Computing bound for D
    _637.d0 = _150.d0;
    if (_150.d0 > 0) 
    goto _jump2758;
    fail_assertion("non-positive loop bound");
    _jump2758:;
    // Computing bound for E
    int64_t _638 = 699;
    _637.d1 = _638;
    if (_638 > 0) 
    goto _jump2759;
    fail_assertion("non-positive loop bound");
    _jump2759:;
    // Computing bound for F
    _637.d2 = _557;
    if (_557 > 0) 
    goto _jump2760;
    fail_assertion("non-positive loop bound");
    _jump2760:;
    // Computing total size of heap memory to allocate
    int64_t _639 = 1;
    _639 *= _150.d0;
    _639 *= _638;
    _639 *= _557;
    _639 *= sizeof(double);
    _637.data = jpl_alloc(_639);
    int64_t _640 = 0; // F
    int64_t _641 = 0; // E
    int64_t _642 = 0; // D
    _jump2761:; // Begin body of loop
    double _643 = z();
    int64_t _644 = 0;
    _644 *= _637.d0;
    _644 += _642;
    _644 *= _637.d1;
    _644 += _641;
    _644 *= _637.d2;
    _644 += _640;
    _637.data[_644] = _643;
    _640++;
    if (_640 < _557)
    goto _jump2761;
    _640 = 0;
    _641++;
    if (_641 < _638)
    goto _jump2761;
    _641 = 0;
    _642++;
    if (_642 < _150.d0)
    goto _jump2761;
    // End body of loop
    int64_t _645 = 793;
    int64_t _646 = -_297;
    if (_645 >= 0)
    goto _jump2762;
    fail_assertion("negative array index");
    _jump2762:;
    if (_645 < _637.d0)
    goto _jump2763;
    fail_assertion("index too large");
    _jump2763:;
    if (_404.d0 >= 0)
    goto _jump2764;
    fail_assertion("negative array index");
    _jump2764:;
    if (_404.d0 < _637.d1)
    goto _jump2765;
    fail_assertion("index too large");
    _jump2765:;
    if (_646 >= 0)
    goto _jump2766;
    fail_assertion("negative array index");
    _jump2766:;
    if (_646 < _637.d2)
    goto _jump2767;
    fail_assertion("index too large");
    _jump2767:;
    int64_t _647 = 0;
    _647 *= _637.d0;
    _647 += _645;
    _647 *= _637.d1;
    _647 += _404.d0;
    _647 *= _637.d2;
    _647 += _646;
    double _648 = _637.data[_647];
    double _649 = 29.0;
    _a1_double _650;
    _650.d0 = 1;
    _650.data = jpl_alloc(sizeof(double) * 1);
    _650.data[0] = _649;
    int64_t _651 = 50;
    if (_651 >= 0)
    goto _jump2768;
    fail_assertion("negative array index");
    _jump2768:;
    if (_651 < _650.d0)
    goto _jump2769;
    fail_assertion("index too large");
    _jump2769:;
    int64_t _652 = 0;
    _652 *= _650.d0;
    _652 += _651;
    double _653 = _650.data[_652];
    rgba _654 = { _626, _632, _648, _653 };
    double _655 = _654.g;
    rgba _656 = { _578, _593, _609, _655 };
    _576 = _656;
    goto _jump2770;
    _jump2728:;
    bool _657 = true;
    rgba _658;
    if (!_657)
    goto _jump2771;
    rgba _659 = j();
    _658 = _659;
    goto _jump2772;
    _jump2771:;
    rgba _660 = j();
    _658 = _660;
    _jump2772:;
    _a3_g _661;
    // Computing bound for D
    _661.d0 = _518.d0;
    if (_518.d0 > 0) 
    goto _jump2773;
    fail_assertion("non-positive loop bound");
    _jump2773:;
    // Computing bound for E
    _661.d1 = _150.d1;
    if (_150.d1 > 0) 
    goto _jump2774;
    fail_assertion("non-positive loop bound");
    _jump2774:;
    // Computing bound for F
    _661.d2 = _557;
    if (_557 > 0) 
    goto _jump2775;
    fail_assertion("non-positive loop bound");
    _jump2775:;
    // Computing total size of heap memory to allocate
    int64_t _662 = 1;
    _662 *= _518.d0;
    _662 *= _150.d1;
    _662 *= _557;
    _662 *= sizeof(g);
    _661.data = jpl_alloc(_662);
    int64_t _663 = 0; // F
    int64_t _664 = 0; // E
    int64_t _665 = 0; // D
    _jump2776:; // Begin body of loop
    g _666 = l();
    int64_t _667 = 0;
    _667 *= _661.d0;
    _667 += _665;
    _667 *= _661.d1;
    _667 += _664;
    _667 *= _661.d2;
    _667 += _663;
    _661.data[_667] = _666;
    _663++;
    if (_663 < _557)
    goto _jump2776;
    _663 = 0;
    _664++;
    if (_664 < _150.d1)
    goto _jump2776;
    _664 = 0;
    _665++;
    if (_665 < _518.d0)
    goto _jump2776;
    // End body of loop
    v _668 = { _658, _661 };
    _a1_v _669;
    _669.d0 = 1;
    _669.data = jpl_alloc(sizeof(v) * 1);
    _669.data[0] = _668;
    if (_404.d1 >= 0)
    goto _jump2777;
    fail_assertion("negative array index");
    _jump2777:;
    if (_404.d1 < _669.d0)
    goto _jump2778;
    fail_assertion("index too large");
    _jump2778:;
    int64_t _670 = 0;
    _670 *= _669.d0;
    _670 += _404.d1;
    v _671 = _669.data[_670];
    rgba _672 = _671.a;
    _576 = _672;
    _jump2770:;
    int64_t _673 = 0;
    _673 *= _521.d0;
    _673 += _558;
    _673 *= _521.d1;
    _673 += _557;
    _521.data[_673] = _576;
    _557++;
    if (_557 < _150.d1)
    goto _jump2720;
    _557 = 0;
    _558++;
    if (_558 < _524)
    goto _jump2720;
    // End body of loop
    write_image(_521, "B.png");
}

