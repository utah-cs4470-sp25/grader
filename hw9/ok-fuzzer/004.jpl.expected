
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
    double a;
    double b;
    void_t c;
} b;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  b *data;
} _a2_b;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_bool *data;
} _a3__a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_double *data;
} _a2__a2__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_double *data;
} _a3__a2__a3_double;

typedef struct {
  int64_t d0;
  _a2__a3_double *data;
} _a1__a2__a3_double;

typedef struct {
  int64_t d0;
  _a2__a2__a3_double *data;
} _a1__a2__a2__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2__a3_double *data;
} _a2__a2__a2__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a3_double *data;
} _a3__a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_rgba *data;
} _a3__a1_rgba;

typedef struct {
  int64_t d0;
  b *data;
} _a1_b;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  b *data;
} _a3_b;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a3_double *data;
} _a2__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3__a3_double *data;
} _a2__a2__a3__a3_double;

typedef struct {
  int64_t d0;
  _a3__a3_double *data;
} _a1__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a2_bool *data;
} _a3__a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a3_double *data;
} _a2__a1__a3_double;

typedef struct {
  int64_t d0;
  _a3__a3_bool *data;
} _a1__a3__a3_bool;

rgba c(b d, _a3_void_t e, double i) {
    _a2_bool _0;
    // Computing bound for k
    int64_t _1;
    // Computing bound for k
    if (e.d1 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    _1 = 0;
    int64_t _2 = 0; // k
    _jump137:; // Begin body of loop
    _1 += e.d0;
    _2++;
    if (_2 < e.d1)
    goto _jump137;
    // End body of loop
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    // Computing bound for l
    _0.d1 = e.d1;
    if (e.d1 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _1;
    _3 *= e.d1;
    _3 *= sizeof(bool);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // l
    int64_t _5 = 0; // k
    _jump140:; // Begin body of loop
    bool _6 = false;
    int64_t _7 = 0;
    _7 *= _0.d0;
    _7 += _5;
    _7 *= _0.d1;
    _7 += _4;
    _0.data[_7] = _6;
    _4++;
    if (_4 < e.d1)
    goto _jump140;
    _4 = 0;
    _5++;
    if (_5 < _1)
    goto _jump140;
    // End body of loop
    int64_t _8 = -e.d0;
    int64_t _9 = -_8;
    if (_9 >= 0)
    goto _jump141;
    fail_assertion("negative array index");
    _jump141:;
    if (_9 < _0.d0)
    goto _jump142;
    fail_assertion("index too large");
    _jump142:;
    if (e.d1 >= 0)
    goto _jump143;
    fail_assertion("negative array index");
    _jump143:;
    if (e.d1 < _0.d1)
    goto _jump144;
    fail_assertion("index too large");
    _jump144:;
    int64_t _10 = 0;
    _10 *= _0.d0;
    _10 += _9;
    _10 *= _0.d1;
    _10 += e.d1;
    bool _11 = _0.data[_10];
    bool _12 = !_11;
    bool _13;
    if (!_12)
    goto _jump145;
    int64_t _14 = -e.d0;
    int64_t _15 = 701;
    if (_15 >= 0)
    goto _jump146;
    fail_assertion("negative array index");
    _jump146:;
    if (_15 < a.d0)
    goto _jump147;
    fail_assertion("index too large");
    _jump147:;
    int64_t _16 = 0;
    _16 *= a.d0;
    _16 += _15;
    bool _17 = a.data[_16];
    int64_t _18;
    if (!_17)
    goto _jump148;
    int64_t _19 = 580;
    _18 = _19;
    goto _jump149;
    _jump148:;
    int64_t _20 = -e.d0;
    _18 = _20;
    _jump149:;
    int64_t _21 = _14 * _18;
    bool _22 = _21 > e.d0;
    _13 = _22;
    goto _jump150;
    _jump145:;
    double _23;
    // Computing bound for k
    if (e.d1 > 0) 
    goto _jump151;
    fail_assertion("non-positive loop bound");
    _jump151:;
    // Computing bound for l
    if (e.d0 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    _23 = 0;
    int64_t _24 = 0; // l
    int64_t _25 = 0; // k
    _jump153:; // Begin body of loop
    _23 += i;
    _24++;
    if (_24 < e.d0)
    goto _jump153;
    _24 = 0;
    _25++;
    if (_25 < e.d1)
    goto _jump153;
    // End body of loop
    bool _26 = true;
    double _27;
    if (!_26)
    goto _jump154;
    _27 = i;
    goto _jump155;
    _jump154:;
    double _28 = 95.0;
    _27 = _28;
    _jump155:;
    _a1_double _29;
    _29.d0 = 3;
    _29.data = jpl_alloc(sizeof(double) * 3);
    _29.data[0] = _23;
    _29.data[1] = i;
    _29.data[2] = _27;
    int64_t _30 = -e.d0;
    if (_30 >= 0)
    goto _jump156;
    fail_assertion("negative array index");
    _jump156:;
    if (_30 < _29.d0)
    goto _jump157;
    fail_assertion("index too large");
    _jump157:;
    int64_t _31 = 0;
    _31 *= _29.d0;
    _31 += _30;
    double _32 = _29.data[_31];
    double _33 = 75.0;
    rgba _34 = c(d, e, _33);
    double _35 = _34.r;
    bool _36 = _32 > _35;
    _13 = _36;
    _jump150:;
    _a3__a1_double _37;
    if (!_13)
    goto _jump158;
    _a3__a1_double _38;
    // Computing bound for k
    _38.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing bound for l
    int64_t _39;
    // Computing bound for k
    int64_t _40 = -e.d0;
    if (_40 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    // Computing bound for l
    int64_t _41 = 961;
    if (_41 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for m
    int64_t _42 = 884;
    int64_t _43 = -_42;
    if (_43 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _39 = 0;
    int64_t _44 = 0; // m
    int64_t _45 = 0; // l
    int64_t _46 = 0; // k
    _jump163:; // Begin body of loop
    _39 += _45;
    _44++;
    if (_44 < _43)
    goto _jump163;
    _44 = 0;
    _45++;
    if (_45 < _41)
    goto _jump163;
    _45 = 0;
    _46++;
    if (_46 < _40)
    goto _jump163;
    // End body of loop
    _38.d1 = _39;
    if (_39 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing bound for m
    _38.d2 = e.d2;
    if (e.d2 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= e.d1;
    _47 *= _39;
    _47 *= e.d2;
    _47 *= sizeof(_a1_double);
    _38.data = jpl_alloc(_47);
    int64_t _48 = 0; // m
    int64_t _49 = 0; // l
    int64_t _50 = 0; // k
    _jump166:; // Begin body of loop
    double _52 = 88.0;
    bool _53 = i > _52;
    bool _51 = _53;
    if (0 != _53)
    goto _jump167;
    bool _54 = false;
    _51 = _54;
    _jump167:;
    bool _55 = !_51;
    _a1_double _56;
    if (!_55)
    goto _jump168;
    _a1_double _57;
    // Computing bound for n
    _57.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= e.d1;
    _58 *= sizeof(double);
    _57.data = jpl_alloc(_58);
    int64_t _59 = 0; // n
    _jump170:; // Begin body of loop
    double _60 = 85.0;
    int64_t _61 = 0;
    _61 *= _57.d0;
    _61 += _59;
    _57.data[_61] = _60;
    _59++;
    if (_59 < e.d1)
    goto _jump170;
    // End body of loop
    _56 = _57;
    goto _jump171;
    _jump168:;
    _a1_double _62;
    // Computing bound for n
    _62.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= e.d2;
    _63 *= sizeof(double);
    _62.data = jpl_alloc(_63);
    int64_t _64 = 0; // n
    _jump173:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _62.d0;
    _65 += _64;
    _62.data[_65] = i;
    _64++;
    if (_64 < e.d2)
    goto _jump173;
    // End body of loop
    _56 = _62;
    _jump171:;
    int64_t _66 = 0;
    _66 *= _38.d0;
    _66 += _50;
    _66 *= _38.d1;
    _66 += _49;
    _66 *= _38.d2;
    _66 += _48;
    _38.data[_66] = _56;
    _48++;
    if (_48 < e.d2)
    goto _jump166;
    _48 = 0;
    _49++;
    if (_49 < _39)
    goto _jump166;
    _49 = 0;
    _50++;
    if (_50 < e.d1)
    goto _jump166;
    // End body of loop
    _37 = _38;
    goto _jump174;
    _jump158:;
    bool _68 = false;
    bool _67 = _68;
    if (0 == _68)
    goto _jump175;
    bool _69 = false;
    _67 = _69;
    _jump175:;
    bool _70 = !_67;
    bool _71;
    if (!_70)
    goto _jump176;
    bool _72 = false;
    _71 = _72;
    goto _jump177;
    _jump176:;
    double _73 = -i;
    double _74 = 15.0;
    bool _75 = _73 != _74;
    _71 = _75;
    _jump177:;
    bool _76 = !_71;
    _a3__a1_double _77;
    if (!_76)
    goto _jump178;
    bool _79 = false;
    bool _80 = false;
    bool _81 = _79 != _80;
    bool _82;
    if (!_81)
    goto _jump179;
    int64_t _83 = 522;
    if (_83 >= 0)
    goto _jump180;
    fail_assertion("negative array index");
    _jump180:;
    if (_83 < a.d0)
    goto _jump181;
    fail_assertion("index too large");
    _jump181:;
    int64_t _84 = 0;
    _84 *= a.d0;
    _84 += _83;
    bool _85 = a.data[_84];
    _82 = _85;
    goto _jump182;
    _jump179:;
    bool _86 = e.d1 > e.d0;
    _82 = _86;
    _jump182:;
    bool _78 = _82;
    if (0 == _82)
    goto _jump183;
    double _87 = 50.0;
    bool _88 = _87 != i;
    _78 = _88;
    _jump183:;
    _a3__a1_double _89;
    if (!_78)
    goto _jump184;
    _a3__a1_double _90;
    // Computing bound for k
    _90.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing bound for l
    _90.d1 = e.d1;
    if (e.d1 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing bound for m
    bool _91 = true;
    int64_t _92;
    if (!_91)
    goto _jump187;
    int64_t _93 = 459;
    int64_t _94 = e.d0 * _93;
    _92 = _94;
    goto _jump188;
    _jump187:;
    int64_t _95 = 425;
    _92 = _95;
    _jump188:;
    _90.d2 = _92;
    if (_92 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= e.d1;
    _96 *= e.d1;
    _96 *= _92;
    _96 *= sizeof(_a1_double);
    _90.data = jpl_alloc(_96);
    int64_t _97 = 0; // m
    int64_t _98 = 0; // l
    int64_t _99 = 0; // k
    _jump190:; // Begin body of loop
    bool _100 = true;
    bool _101 = true;
    bool _102 = _100 == _101;
    _a1_double _103;
    if (!_102)
    goto _jump191;
    _a1_double _104;
    // Computing bound for n
    _104.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump192;
    fail_assertion("non-positive loop bound");
    _jump192:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= e.d2;
    _105 *= sizeof(double);
    _104.data = jpl_alloc(_105);
    int64_t _106 = 0; // n
    _jump193:; // Begin body of loop
    int64_t _107 = 0;
    _107 *= _104.d0;
    _107 += _106;
    _104.data[_107] = i;
    _106++;
    if (_106 < e.d2)
    goto _jump193;
    // End body of loop
    _103 = _104;
    goto _jump194;
    _jump191:;
    double _108 = 12.0;
    _a1_double _109;
    _109.d0 = 3;
    _109.data = jpl_alloc(sizeof(double) * 3);
    _109.data[0] = i;
    _109.data[1] = i;
    _109.data[2] = _108;
    _103 = _109;
    _jump194:;
    int64_t _110 = 0;
    _110 *= _90.d0;
    _110 += _99;
    _110 *= _90.d1;
    _110 += _98;
    _110 *= _90.d2;
    _110 += _97;
    _90.data[_110] = _103;
    _97++;
    if (_97 < _92)
    goto _jump190;
    _97 = 0;
    _98++;
    if (_98 < e.d1)
    goto _jump190;
    _98 = 0;
    _99++;
    if (_99 < e.d1)
    goto _jump190;
    // End body of loop
    _89 = _90;
    goto _jump195;
    _jump184:;
    _a3__a1_double _111;
    // Computing bound for k
    _111.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump196;
    fail_assertion("non-positive loop bound");
    _jump196:;
    // Computing bound for l
    int64_t _112 = 544;
    bool _113 = _112 <= e.d0;
    int64_t _114;
    if (!_113)
    goto _jump197;
    int64_t _115;
    // Computing bound for k
    if (e.d1 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing bound for l
    int64_t _116 = 227;
    if (_116 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    _115 = 0;
    int64_t _117 = 0; // l
    int64_t _118 = 0; // k
    _jump200:; // Begin body of loop
    _115 += _118;
    _117++;
    if (_117 < _116)
    goto _jump200;
    _117 = 0;
    _118++;
    if (_118 < e.d1)
    goto _jump200;
    // End body of loop
    _114 = _115;
    goto _jump201;
    _jump197:;
    int64_t _119 = 142;
    _114 = _119;
    _jump201:;
    _111.d1 = _114;
    if (_114 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    // Computing bound for m
    int64_t _120 = 639;
    int64_t _121 = 882;
    int64_t _122 = _120 % _121;
    _111.d2 = _122;
    if (_122 > 0) 
    goto _jump203;
    fail_assertion("non-positive loop bound");
    _jump203:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= e.d0;
    _123 *= _114;
    _123 *= _122;
    _123 *= sizeof(_a1_double);
    _111.data = jpl_alloc(_123);
    int64_t _124 = 0; // m
    int64_t _125 = 0; // l
    int64_t _126 = 0; // k
    _jump204:; // Begin body of loop
    _a1_double _127;
    _127.d0 = 2;
    _127.data = jpl_alloc(sizeof(double) * 2);
    _127.data[0] = i;
    _127.data[1] = i;
    int64_t _128 = 0;
    _128 *= _111.d0;
    _128 += _126;
    _128 *= _111.d1;
    _128 += _125;
    _128 *= _111.d2;
    _128 += _124;
    _111.data[_128] = _127;
    _124++;
    if (_124 < _122)
    goto _jump204;
    _124 = 0;
    _125++;
    if (_125 < _114)
    goto _jump204;
    _125 = 0;
    _126++;
    if (_126 < e.d0)
    goto _jump204;
    // End body of loop
    _89 = _111;
    _jump195:;
    _77 = _89;
    goto _jump205;
    _jump178:;
    _a3__a1_double _129;
    // Computing bound for k
    _129.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    // Computing bound for l
    int64_t _130 = e.d1 / e.d0;
    int64_t _131 = -_130;
    _129.d1 = _131;
    if (_131 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing bound for m
    _129.d2 = e.d2;
    if (e.d2 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= e.d1;
    _132 *= _131;
    _132 *= e.d2;
    _132 *= sizeof(_a1_double);
    _129.data = jpl_alloc(_132);
    int64_t _133 = 0; // m
    int64_t _134 = 0; // l
    int64_t _135 = 0; // k
    _jump209:; // Begin body of loop
    _a2_bool _136;
    // Computing bound for n
    _136.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for o
    _136.d1 = _134;
    if (_134 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing total size of heap memory to allocate
    int64_t _137 = 1;
    _137 *= e.d0;
    _137 *= _134;
    _137 *= sizeof(bool);
    _136.data = jpl_alloc(_137);
    int64_t _138 = 0; // o
    int64_t _139 = 0; // n
    _jump212:; // Begin body of loop
    bool _140 = true;
    int64_t _141 = 0;
    _141 *= _136.d0;
    _141 += _139;
    _141 *= _136.d1;
    _141 += _138;
    _136.data[_141] = _140;
    _138++;
    if (_138 < _134)
    goto _jump212;
    _138 = 0;
    _139++;
    if (_139 < e.d0)
    goto _jump212;
    // End body of loop
    int64_t _142 = _133 - _134;
    if (_142 >= 0)
    goto _jump213;
    fail_assertion("negative array index");
    _jump213:;
    if (_142 < _136.d0)
    goto _jump214;
    fail_assertion("index too large");
    _jump214:;
    if (_133 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (_133 < _136.d1)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    int64_t _143 = 0;
    _143 *= _136.d0;
    _143 += _142;
    _143 *= _136.d1;
    _143 += _133;
    bool _144 = _136.data[_143];
    _a1_double _145;
    if (!_144)
    goto _jump217;
    bool _146 = true;
    _a1_double _147;
    if (!_146)
    goto _jump218;
    _a1_double _148;
    // Computing bound for n
    _148.d0 = _133;
    if (_133 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _133;
    _149 *= sizeof(double);
    _148.data = jpl_alloc(_149);
    int64_t _150 = 0; // n
    _jump220:; // Begin body of loop
    int64_t _151 = 0;
    _151 *= _148.d0;
    _151 += _150;
    _148.data[_151] = i;
    _150++;
    if (_150 < _133)
    goto _jump220;
    // End body of loop
    _147 = _148;
    goto _jump221;
    _jump218:;
    _a1_double _152;
    // Computing bound for n
    _152.d0 = _135;
    if (_135 > 0) 
    goto _jump222;
    fail_assertion("non-positive loop bound");
    _jump222:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _135;
    _153 *= sizeof(double);
    _152.data = jpl_alloc(_153);
    int64_t _154 = 0; // n
    _jump223:; // Begin body of loop
    double _155 = 79.0;
    int64_t _156 = 0;
    _156 *= _152.d0;
    _156 += _154;
    _152.data[_156] = _155;
    _154++;
    if (_154 < _135)
    goto _jump223;
    // End body of loop
    _147 = _152;
    _jump221:;
    _145 = _147;
    goto _jump224;
    _jump217:;
    double _157;
    // Computing bound for n
    if (e.d1 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for o
    if (_135 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    _157 = 0;
    int64_t _158 = 0; // o
    int64_t _159 = 0; // n
    _jump227:; // Begin body of loop
    double _160 = 73.0;
    _157 += _160;
    _158++;
    if (_158 < _135)
    goto _jump227;
    _158 = 0;
    _159++;
    if (_159 < e.d1)
    goto _jump227;
    // End body of loop
    _a1_double _161;
    _161.d0 = 2;
    _161.data = jpl_alloc(sizeof(double) * 2);
    _161.data[0] = i;
    _161.data[1] = _157;
    _145 = _161;
    _jump224:;
    int64_t _162 = 0;
    _162 *= _129.d0;
    _162 += _135;
    _162 *= _129.d1;
    _162 += _134;
    _162 *= _129.d2;
    _162 += _133;
    _129.data[_162] = _145;
    _133++;
    if (_133 < e.d2)
    goto _jump209;
    _133 = 0;
    _134++;
    if (_134 < _131)
    goto _jump209;
    _134 = 0;
    _135++;
    if (_135 < e.d1)
    goto _jump209;
    // End body of loop
    _77 = _129;
    _jump205:;
    _37 = _77;
    _jump174:;
    if (e.d0 >= 0)
    goto _jump228;
    fail_assertion("negative array index");
    _jump228:;
    if (e.d0 < _37.d0)
    goto _jump229;
    fail_assertion("index too large");
    _jump229:;
    if (e.d1 >= 0)
    goto _jump230;
    fail_assertion("negative array index");
    _jump230:;
    if (e.d1 < _37.d1)
    goto _jump231;
    fail_assertion("index too large");
    _jump231:;
    if (e.d0 >= 0)
    goto _jump232;
    fail_assertion("negative array index");
    _jump232:;
    if (e.d0 < _37.d2)
    goto _jump233;
    fail_assertion("index too large");
    _jump233:;
    int64_t _163 = 0;
    _163 *= _37.d0;
    _163 += e.d0;
    _163 *= _37.d1;
    _163 += e.d1;
    _163 *= _37.d2;
    _163 += e.d0;
    _a1_double _164 = _37.data[_163];
    double _165 = -i;
    double _166 = -_165;
    rgba _167 = c(d, e, _166);
    double _168 = _167.g;
    double _169 = 48.0;
    double _170 = _168 - _169;
    double _171;
    // Computing bound for m
    int64_t _172;
    // Computing bound for m
    if (e.d1 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing bound for n
    _a2_int64_t _173;
    // Computing bound for m
    _173.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing bound for n
    _173.d1 = e.d2;
    if (e.d2 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing total size of heap memory to allocate
    int64_t _174 = 1;
    _174 *= e.d2;
    _174 *= e.d2;
    _174 *= sizeof(int64_t);
    _173.data = jpl_alloc(_174);
    int64_t _175 = 0; // n
    int64_t _176 = 0; // m
    _jump237:; // Begin body of loop
    int64_t _177 = 0;
    _177 *= _173.d0;
    _177 += _176;
    _177 *= _173.d1;
    _177 += _175;
    _173.data[_177] = _176;
    _175++;
    if (_175 < e.d2)
    goto _jump237;
    _175 = 0;
    _176++;
    if (_176 < e.d2)
    goto _jump237;
    // End body of loop
    int64_t _178 = -e.d0;
    if (e.d1 >= 0)
    goto _jump238;
    fail_assertion("negative array index");
    _jump238:;
    if (e.d1 < _173.d0)
    goto _jump239;
    fail_assertion("index too large");
    _jump239:;
    if (_178 >= 0)
    goto _jump240;
    fail_assertion("negative array index");
    _jump240:;
    if (_178 < _173.d1)
    goto _jump241;
    fail_assertion("index too large");
    _jump241:;
    int64_t _179 = 0;
    _179 *= _173.d0;
    _179 += e.d1;
    _179 *= _173.d1;
    _179 += _178;
    int64_t _180 = _173.data[_179];
    if (_180 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for o
    int64_t _181;
    // Computing bound for m
    int64_t _182 = 371;
    if (_182 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    _181 = 0;
    int64_t _183 = 0; // m
    _jump244:; // Begin body of loop
    int64_t _184 = 779;
    _181 += _184;
    _183++;
    if (_183 < _182)
    goto _jump244;
    // End body of loop
    int64_t _185 = e.d2 + _181;
    if (_185 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    _172 = 0;
    int64_t _186 = 0; // o
    int64_t _187 = 0; // n
    int64_t _188 = 0; // m
    _jump246:; // Begin body of loop
    int64_t _189 = -_187;
    int64_t _190 = _189 % _187;
    _172 += _190;
    _186++;
    if (_186 < _185)
    goto _jump246;
    _186 = 0;
    _187++;
    if (_187 < _180)
    goto _jump246;
    _187 = 0;
    _188++;
    if (_188 < e.d1)
    goto _jump246;
    // End body of loop
    if (_172 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    // Computing bound for n
    if (e.d2 > 0) 
    goto _jump248;
    fail_assertion("non-positive loop bound");
    _jump248:;
    _171 = 0;
    int64_t _191 = 0; // n
    int64_t _192 = 0; // m
    _jump249:; // Begin body of loop
    bool _193 = true;
    b _194;
    if (!_193)
    goto _jump250;
    _194 = d;
    goto _jump251;
    _jump250:;
    _194 = d;
    _jump251:;
    double _195 = d.b;
    rgba _196 = c(_194, e, _195);
    double _197 = _196.a;
    _171 += _197;
    _191++;
    if (_191 < e.d2)
    goto _jump249;
    _191 = 0;
    _192++;
    if (_192 < _172)
    goto _jump249;
    // End body of loop
    double _198 = -_171;
    double _199;
    // Computing bound for m
    if (e.d2 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for n
    int64_t _200 = e.d1 % e.d2;
    int64_t _201 = 78;
    int64_t _202 = 623;
    int64_t _203 = _201 + _202;
    _a1_int64_t _204;
    _204.d0 = 2;
    _204.data = jpl_alloc(sizeof(int64_t) * 2);
    _204.data[0] = _200;
    _204.data[1] = _203;
    int64_t _205;
    // Computing bound for m
    if (e.d2 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    _205 = 0;
    int64_t _206 = 0; // m
    _jump254:; // Begin body of loop
    _205 += e.d0;
    _206++;
    if (_206 < e.d2)
    goto _jump254;
    // End body of loop
    if (_205 >= 0)
    goto _jump255;
    fail_assertion("negative array index");
    _jump255:;
    if (_205 < _204.d0)
    goto _jump256;
    fail_assertion("index too large");
    _jump256:;
    int64_t _207 = 0;
    _207 *= _204.d0;
    _207 += _205;
    int64_t _208 = _204.data[_207];
    if (_208 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing bound for o
    int64_t _209 = 724;
    int64_t _210 = -_209;
    int64_t _211 = e.d1 + _210;
    _a1_int64_t _212;
    // Computing bound for m
    _212.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= e.d1;
    _213 *= sizeof(int64_t);
    _212.data = jpl_alloc(_213);
    int64_t _214 = 0; // m
    _jump259:; // Begin body of loop
    int64_t _215 = 967;
    int64_t _216 = 0;
    _216 *= _212.d0;
    _216 += _214;
    _212.data[_216] = _215;
    _214++;
    if (_214 < e.d1)
    goto _jump259;
    // End body of loop
    int64_t _217;
    // Computing bound for m
    if (e.d0 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    _217 = 0;
    int64_t _218 = 0; // m
    _jump261:; // Begin body of loop
    _217 += _218;
    _218++;
    if (_218 < e.d0)
    goto _jump261;
    // End body of loop
    if (_217 >= 0)
    goto _jump262;
    fail_assertion("negative array index");
    _jump262:;
    if (_217 < _212.d0)
    goto _jump263;
    fail_assertion("index too large");
    _jump263:;
    int64_t _219 = 0;
    _219 *= _212.d0;
    _219 += _217;
    int64_t _220 = _212.data[_219];
    int64_t _221 = _211 / _220;
    if (_221 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    _199 = 0;
    int64_t _222 = 0; // o
    int64_t _223 = 0; // n
    int64_t _224 = 0; // m
    _jump265:; // Begin body of loop
    double _225;
    // Computing bound for p
    int64_t _226 = 974;
    if (_226 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    _225 = 0;
    int64_t _227 = 0; // p
    _jump267:; // Begin body of loop
    double _228 = d.a;
    double _229 = fmod(i, _228);
    _225 += _229;
    _227++;
    if (_227 < _226)
    goto _jump267;
    // End body of loop
    _199 += _225;
    _222++;
    if (_222 < _221)
    goto _jump265;
    _222 = 0;
    _223++;
    if (_223 < _208)
    goto _jump265;
    _223 = 0;
    _224++;
    if (_224 < e.d2)
    goto _jump265;
    // End body of loop
    double _230 = -i;
    double _231 = _199 - _230;
    rgba _232 = c(d, e, i);
    double _233 = _232.r;
    double _234 = -_233;
    rgba _235 = { _198, _231, i, _234 };
    _a1_rgba _236;
    _236.d0 = 1;
    _236.data = jpl_alloc(sizeof(rgba) * 1);
    _236.data[0] = _235;
    double _237 = 98.0;
    rgba _238 = { _170, _237, i, _170 };
    return _238;
    bool _241 = true;
    bool _242 = !_241;
    bool _243 = !_242;
    bool _240 = _243;
    if (0 == _243)
    goto _jump268;
    bool _244 = true;
    bool _245;
    if (!_244)
    goto _jump269;
    bool _246 = i <= i;
    _245 = _246;
    goto _jump270;
    _jump269:;
    bool _247 = false;
    bool _248 = !_247;
    _245 = _248;
    _jump270:;
    _240 = _245;
    _jump268:;
    bool _249;
    if (!_240)
    goto _jump271;
    int64_t _250;
    // Computing bound for q
    if (_236.d0 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing bound for r
    if (e.d1 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    _250 = 0;
    int64_t _251 = 0; // r
    int64_t _252 = 0; // q
    _jump274:; // Begin body of loop
    _250 += _164.d0;
    _251++;
    if (_251 < e.d1)
    goto _jump274;
    _251 = 0;
    _252++;
    if (_252 < _236.d0)
    goto _jump274;
    // End body of loop
    bool _253 = e.d1 < _250;
    bool _254 = !_253;
    _249 = _254;
    goto _jump275;
    _jump271:;
    bool _255 = true;
    _249 = _255;
    _jump275:;
    bool _239 = _249;
    if (0 != _249)
    goto _jump276;
    _a3__a1_bool _256;
    // Computing bound for q
    _256.d0 = e.d1;
    if (e.d1 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for r
    _256.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing bound for s
    _256.d2 = e.d0;
    if (e.d0 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing total size of heap memory to allocate
    int64_t _257 = 1;
    _257 *= e.d1;
    _257 *= e.d0;
    _257 *= e.d0;
    _257 *= sizeof(_a1_bool);
    _256.data = jpl_alloc(_257);
    int64_t _258 = 0; // s
    int64_t _259 = 0; // r
    int64_t _260 = 0; // q
    _jump280:; // Begin body of loop
    int64_t _261 = 0;
    _261 *= _256.d0;
    _261 += _260;
    _261 *= _256.d1;
    _261 += _259;
    _261 *= _256.d2;
    _261 += _258;
    _256.data[_261] = a;
    _258++;
    if (_258 < e.d0)
    goto _jump280;
    _258 = 0;
    _259++;
    if (_259 < e.d0)
    goto _jump280;
    _259 = 0;
    _260++;
    if (_260 < e.d1)
    goto _jump280;
    // End body of loop
    int64_t _262 = -e.d0;
    if (_262 >= 0)
    goto _jump281;
    fail_assertion("negative array index");
    _jump281:;
    if (_262 < _256.d0)
    goto _jump282;
    fail_assertion("index too large");
    _jump282:;
    if (e.d2 >= 0)
    goto _jump283;
    fail_assertion("negative array index");
    _jump283:;
    if (e.d2 < _256.d1)
    goto _jump284;
    fail_assertion("index too large");
    _jump284:;
    if (e.d0 >= 0)
    goto _jump285;
    fail_assertion("negative array index");
    _jump285:;
    if (e.d0 < _256.d2)
    goto _jump286;
    fail_assertion("index too large");
    _jump286:;
    int64_t _263 = 0;
    _263 *= _256.d0;
    _263 += _262;
    _263 *= _256.d1;
    _263 += e.d2;
    _263 *= _256.d2;
    _263 += e.d0;
    _a1_bool _264 = _256.data[_263];
    int64_t _265 = 12;
    int64_t _266 = _265 - e.d2;
    if (_266 >= 0)
    goto _jump287;
    fail_assertion("negative array index");
    _jump287:;
    if (_266 < _264.d0)
    goto _jump288;
    fail_assertion("index too large");
    _jump288:;
    int64_t _267 = 0;
    _267 *= _264.d0;
    _267 += _266;
    bool _268 = _264.data[_267];
    bool _269 = !_268;
    _239 = _269;
    _jump276:;
    double _270;
    if (!_239)
    goto _jump289;
    double _271;
    // Computing bound for q
    bool _273 = false;
    bool _272 = _273;
    if (0 != _273)
    goto _jump290;
    bool _274 = true;
    _272 = _274;
    _jump290:;
    bool _275;
    if (!_272)
    goto _jump291;
    int64_t _276 = 126;
    int64_t _277 = -_276;
    bool _278 = _277 < e.d0;
    _275 = _278;
    goto _jump292;
    _jump291:;
    double _280 = 34.0;
    bool _281 = _280 > _170;
    bool _279 = _281;
    if (0 != _281)
    goto _jump293;
    bool _282 = true;
    _279 = _282;
    _jump293:;
    _275 = _279;
    _jump292:;
    int64_t _283;
    if (!_275)
    goto _jump294;
    bool _284 = _236.d0 <= _236.d0;
    int64_t _285;
    if (!_284)
    goto _jump295;
    _285 = _236.d0;
    goto _jump296;
    _jump295:;
    _285 = e.d1;
    _jump296:;
    int64_t _286 = -_285;
    _283 = _286;
    goto _jump297;
    _jump294:;
    bool _287 = false;
    double _288;
    if (!_287)
    goto _jump298;
    _288 = i;
    goto _jump299;
    _jump298:;
    double _289 = 66.0;
    _288 = _289;
    _jump299:;
    double _290 = d.b;
    bool _291 = _288 == _290;
    int64_t _292;
    if (!_291)
    goto _jump300;
    _292 = _164.d0;
    goto _jump301;
    _jump300:;
    _292 = e.d0;
    _jump301:;
    _283 = _292;
    _jump297:;
    if (_283 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    _271 = 0;
    int64_t _293 = 0; // q
    _jump303:; // Begin body of loop
    _a3_bool _294;
    // Computing bound for r
    _294.d0 = _236.d0;
    if (_236.d0 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for s
    _294.d1 = e.d1;
    if (e.d1 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing bound for t
    int64_t _295 = -_293;
    _294.d2 = _295;
    if (_295 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _236.d0;
    _296 *= e.d1;
    _296 *= _295;
    _296 *= sizeof(bool);
    _294.data = jpl_alloc(_296);
    int64_t _297 = 0; // t
    int64_t _298 = 0; // s
    int64_t _299 = 0; // r
    _jump307:; // Begin body of loop
    bool _300 = false;
    int64_t _301 = 0;
    _301 *= _294.d0;
    _301 += _299;
    _301 *= _294.d1;
    _301 += _298;
    _301 *= _294.d2;
    _301 += _297;
    _294.data[_301] = _300;
    _297++;
    if (_297 < _295)
    goto _jump307;
    _297 = 0;
    _298++;
    if (_298 < e.d1)
    goto _jump307;
    _298 = 0;
    _299++;
    if (_299 < _236.d0)
    goto _jump307;
    // End body of loop
    _a2_int64_t _302;
    // Computing bound for r
    _302.d0 = _236.d0;
    if (_236.d0 > 0) 
    goto _jump308;
    fail_assertion("non-positive loop bound");
    _jump308:;
    // Computing bound for s
    _302.d1 = _164.d0;
    if (_164.d0 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= _236.d0;
    _303 *= _164.d0;
    _303 *= sizeof(int64_t);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // s
    int64_t _305 = 0; // r
    _jump310:; // Begin body of loop
    int64_t _306 = 0;
    _306 *= _302.d0;
    _306 += _305;
    _306 *= _302.d1;
    _306 += _304;
    _302.data[_306] = _305;
    _304++;
    if (_304 < _164.d0)
    goto _jump310;
    _304 = 0;
    _305++;
    if (_305 < _236.d0)
    goto _jump310;
    // End body of loop
    if (e.d0 >= 0)
    goto _jump311;
    fail_assertion("negative array index");
    _jump311:;
    if (e.d0 < _302.d0)
    goto _jump312;
    fail_assertion("index too large");
    _jump312:;
    if (e.d2 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (e.d2 < _302.d1)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    int64_t _307 = 0;
    _307 *= _302.d0;
    _307 += e.d0;
    _307 *= _302.d1;
    _307 += e.d2;
    int64_t _308 = _302.data[_307];
    if (e.d0 >= 0)
    goto _jump315;
    fail_assertion("negative array index");
    _jump315:;
    if (e.d0 < _294.d0)
    goto _jump316;
    fail_assertion("index too large");
    _jump316:;
    if (e.d2 >= 0)
    goto _jump317;
    fail_assertion("negative array index");
    _jump317:;
    if (e.d2 < _294.d1)
    goto _jump318;
    fail_assertion("index too large");
    _jump318:;
    if (_308 >= 0)
    goto _jump319;
    fail_assertion("negative array index");
    _jump319:;
    if (_308 < _294.d2)
    goto _jump320;
    fail_assertion("index too large");
    _jump320:;
    int64_t _309 = 0;
    _309 *= _294.d0;
    _309 += e.d0;
    _309 *= _294.d1;
    _309 += e.d2;
    _309 *= _294.d2;
    _309 += _308;
    bool _310 = _294.data[_309];
    double _311;
    if (!_310)
    goto _jump321;
    _311 = i;
    goto _jump322;
    _jump321:;
    double _312 = 73.0;
    double _313 = 12.0;
    double _314 = 94.0;
    double _315 = _314 * i;
    rgba _316 = { _312, _313, _315, _170 };
    double _317 = _316.g;
    _311 = _317;
    _jump322:;
    _271 += _311;
    _293++;
    if (_293 < _283)
    goto _jump303;
    // End body of loop
    _270 = _271;
    goto _jump323;
    _jump289:;
    _270 = _170;
    _jump323:;
    rgba _318 = c(d, e, _170);
    double _319 = _318.g;
    bool _320 = e.d2 != _164.d0;
    int64_t _321;
    if (!_320)
    goto _jump324;
    int64_t _322 = _236.d0 % _236.d0;
    _321 = _322;
    goto _jump325;
    _jump324:;
    _321 = _236.d0;
    _jump325:;
    if (_321 >= 0)
    goto _jump326;
    fail_assertion("negative array index");
    _jump326:;
    if (_321 < _164.d0)
    goto _jump327;
    fail_assertion("index too large");
    _jump327:;
    int64_t _323 = 0;
    _323 *= _164.d0;
    _323 += _321;
    double _324 = _164.data[_323];
    double _325 = _319 + _324;
    double _326 = _325 + i;
    double _327 = -_326;
    double _328 = d.b;
    _a2_b _329;
    // Computing bound for q
    _329.d0 = e.d2;
    if (e.d2 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    // Computing bound for r
    _329.d1 = _164.d0;
    if (_164.d0 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= e.d2;
    _330 *= _164.d0;
    _330 *= sizeof(b);
    _329.data = jpl_alloc(_330);
    int64_t _331 = 0; // r
    int64_t _332 = 0; // q
    _jump330:; // Begin body of loop
    int64_t _333 = 0;
    _333 *= _329.d0;
    _333 += _332;
    _333 *= _329.d1;
    _333 += _331;
    _329.data[_333] = d;
    _331++;
    if (_331 < _164.d0)
    goto _jump330;
    _331 = 0;
    _332++;
    if (_332 < e.d2)
    goto _jump330;
    // End body of loop
    int64_t _334 = e.d2 + _164.d0;
    int64_t _335 = -_334;
    if (e.d1 >= 0)
    goto _jump331;
    fail_assertion("negative array index");
    _jump331:;
    if (e.d1 < _329.d0)
    goto _jump332;
    fail_assertion("index too large");
    _jump332:;
    if (_335 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (_335 < _329.d1)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    int64_t _336 = 0;
    _336 *= _329.d0;
    _336 += e.d1;
    _336 *= _329.d1;
    _336 += _335;
    b _337 = _329.data[_336];
    double _338 = _337.a;
    _a3_void_t _339;
    // Computing bound for q
    _339.d0 = _236.d0;
    if (_236.d0 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    // Computing bound for r
    _339.d1 = _236.d0;
    if (_236.d0 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    // Computing bound for s
    _339.d2 = e.d0;
    if (e.d0 > 0) 
    goto _jump337;
    fail_assertion("non-positive loop bound");
    _jump337:;
    // Computing total size of heap memory to allocate
    int64_t _340 = 1;
    _340 *= _236.d0;
    _340 *= _236.d0;
    _340 *= e.d0;
    _340 *= sizeof(void_t);
    _339.data = jpl_alloc(_340);
    int64_t _341 = 0; // s
    int64_t _342 = 0; // r
    int64_t _343 = 0; // q
    _jump338:; // Begin body of loop
    bool _344 = false;
    b _345;
    if (!_344)
    goto _jump339;
    _345 = d;
    goto _jump340;
    _jump339:;
    _345 = d;
    _jump340:;
    void_t _346 = _345.c;
    int64_t _347 = 0;
    _347 *= _339.d0;
    _347 += _343;
    _347 *= _339.d1;
    _347 += _342;
    _347 *= _339.d2;
    _347 += _341;
    _339.data[_347] = _346;
    _341++;
    if (_341 < e.d0)
    goto _jump338;
    _341 = 0;
    _342++;
    if (_342 < _236.d0)
    goto _jump338;
    _342 = 0;
    _343++;
    if (_343 < _236.d0)
    goto _jump338;
    // End body of loop
    if (_236.d0 >= 0)
    goto _jump341;
    fail_assertion("negative array index");
    _jump341:;
    if (_236.d0 < _339.d0)
    goto _jump342;
    fail_assertion("index too large");
    _jump342:;
    if (e.d2 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (e.d2 < _339.d1)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (e.d1 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (e.d1 < _339.d2)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _348 = 0;
    _348 *= _339.d0;
    _348 += _236.d0;
    _348 *= _339.d1;
    _348 += e.d2;
    _348 *= _339.d2;
    _348 += e.d1;
    void_t _349 = _339.data[_348];
    b _350 = { _328, _338, _349 };
    double _351 = _350.b;
    double _352 = 77.0;
    double _353 = _352 / i;
    double _354 = _353 * _170;
    rgba _355 = { _270, _327, _351, _354 };
    return _355;
}

b k(_a1_double l) {
    if (i >= 0)
    goto _jump735;
    fail_assertion("negative array index");
    _jump735:;
    if (i < a.d0)
    goto _jump736;
    fail_assertion("index too large");
    _jump736:;
    int64_t _0 = 0;
    _0 *= a.d0;
    _0 += i;
    bool _1 = a.data[_0];
    _a2__a3_double _2;
    if (!_1)
    goto _jump737;
    _2 = h;
    goto _jump738;
    _jump737:;
    _a2__a3_double _3;
    // Computing bound for n
    int64_t _4 = 414;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing bound for o
    _3.d1 = g;
    if (g > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _4;
    _5 *= g;
    _5 *= sizeof(_a3_double);
    _3.data = jpl_alloc(_5);
    int64_t _6 = 0; // o
    int64_t _7 = 0; // n
    _jump741:; // Begin body of loop
    int64_t _8 = 0;
    _8 *= _3.d0;
    _8 += _7;
    _8 *= _3.d1;
    _8 += _6;
    _3.data[_8] = d;
    _6++;
    if (_6 < g)
    goto _jump741;
    _6 = 0;
    _7++;
    if (_7 < _4)
    goto _jump741;
    // End body of loop
    _2 = _3;
    _jump738:;
    double _9 = 77.0;
    bool _10 = true;
    double _11;
    if (!_10)
    goto _jump742;
    double _12;
    // Computing bound for q
    if (g > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing bound for r
    int64_t _13 = -f;
    if (_13 > 0) 
    goto _jump744;
    fail_assertion("non-positive loop bound");
    _jump744:;
    // Computing bound for s
    if (j > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    _12 = 0;
    int64_t _14 = 0; // s
    int64_t _15 = 0; // r
    int64_t _16 = 0; // q
    _jump746:; // Begin body of loop
    double _17 = 33.0;
    double _18 = 54.0;
    double _19 = -_18;
    double _20 = _17 - _19;
    _12 += _20;
    _14++;
    if (_14 < j)
    goto _jump746;
    _14 = 0;
    _15++;
    if (_15 < _13)
    goto _jump746;
    _15 = 0;
    _16++;
    if (_16 < g)
    goto _jump746;
    // End body of loop
    _11 = _12;
    goto _jump747;
    _jump742:;
    double _21 = 89.0;
    double _22 = -_21;
    _11 = _22;
    _jump747:;
    double _23 = _9 - _11;
    bool _24 = false;
    double _25;
    if (!_24)
    goto _jump748;
    int64_t _26 = -e;
    bool _27 = l.d0 > _26;
    double _28;
    if (!_27)
    goto _jump749;
    double _29;
    // Computing bound for q
    int64_t _30 = 340;
    int64_t _31 = -_30;
    if (_31 > 0) 
    goto _jump750;
    fail_assertion("non-positive loop bound");
    _jump750:;
    // Computing bound for r
    if (i > 0) 
    goto _jump751;
    fail_assertion("non-positive loop bound");
    _jump751:;
    // Computing bound for s
    bool _32 = true;
    int64_t _33;
    if (!_32)
    goto _jump752;
    _33 = _2.d0;
    goto _jump753;
    _jump752:;
    _33 = f;
    _jump753:;
    if (_33 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    _29 = 0;
    int64_t _34 = 0; // s
    int64_t _35 = 0; // r
    int64_t _36 = 0; // q
    _jump755:; // Begin body of loop
    double _37 = 94.0;
    _29 += _37;
    _34++;
    if (_34 < _33)
    goto _jump755;
    _34 = 0;
    _35++;
    if (_35 < i)
    goto _jump755;
    _35 = 0;
    _36++;
    if (_36 < _31)
    goto _jump755;
    // End body of loop
    _28 = _29;
    goto _jump756;
    _jump749:;
    double _38 = 79.0;
    _28 = _38;
    _jump756:;
    _25 = _28;
    goto _jump757;
    _jump748:;
    double _39 = 76.0;
    double _40 = -_39;
    _a1_double _41;
    // Computing bound for q
    _41.d0 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= _2.d0;
    _42 *= sizeof(double);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // q
    _jump759:; // Begin body of loop
    double _44 = 32.0;
    int64_t _45 = 0;
    _45 *= _41.d0;
    _45 += _43;
    _41.data[_45] = _44;
    _43++;
    if (_43 < _2.d0)
    goto _jump759;
    // End body of loop
    if (_2.d1 >= 0)
    goto _jump760;
    fail_assertion("negative array index");
    _jump760:;
    if (_2.d1 < _41.d0)
    goto _jump761;
    fail_assertion("index too large");
    _jump761:;
    int64_t _46 = 0;
    _46 *= _41.d0;
    _46 += _2.d1;
    double _47 = _41.data[_46];
    double _48 = _40 - _47;
    double _49 = -_48;
    _25 = _49;
    _jump757:;
    bool _50 = _23 <= _25;
    bool _56 = false;
    bool _55 = _56;
    if (0 != _56)
    goto _jump762;
    double _57 = 48.0;
    double _58 = 56.0;
    bool _59 = _57 == _58;
    _55 = _59;
    _jump762:;
    bool _54 = _55;
    if (0 != _55)
    goto _jump763;
    bool _60 = false;
    _54 = _60;
    _jump763:;
    bool _53 = _54;
    if (0 != _54)
    goto _jump764;
    bool _61 = false;
    bool _62 = !_61;
    _53 = _62;
    _jump764:;
    bool _52 = _53;
    if (0 != _53)
    goto _jump765;
    bool _63 = false;
    _a2_bool _64;
    if (!_63)
    goto _jump766;
    _a2_bool _65;
    // Computing bound for q
    _65.d0 = g;
    if (g > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for r
    _65.d1 = g;
    if (g > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= g;
    _66 *= g;
    _66 *= sizeof(bool);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // r
    int64_t _68 = 0; // q
    _jump769:; // Begin body of loop
    bool _69 = true;
    bool _70 = !_69;
    int64_t _71 = 0;
    _71 *= _65.d0;
    _71 += _68;
    _71 *= _65.d1;
    _71 += _67;
    _65.data[_71] = _70;
    _67++;
    if (_67 < g)
    goto _jump769;
    _67 = 0;
    _68++;
    if (_68 < g)
    goto _jump769;
    // End body of loop
    _64 = _65;
    goto _jump770;
    _jump766:;
    _a2_bool _72;
    // Computing bound for q
    int64_t _73 = i - f;
    _72.d0 = _73;
    if (_73 > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    // Computing bound for r
    int64_t _74;
    // Computing bound for q
    if (e > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    // Computing bound for r
    if (f > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing bound for s
    if (_2.d0 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    _74 = 0;
    int64_t _75 = 0; // s
    int64_t _76 = 0; // r
    int64_t _77 = 0; // q
    _jump775:; // Begin body of loop
    _74 += _2.d0;
    _75++;
    if (_75 < _2.d0)
    goto _jump775;
    _75 = 0;
    _76++;
    if (_76 < f)
    goto _jump775;
    _76 = 0;
    _77++;
    if (_77 < e)
    goto _jump775;
    // End body of loop
    _72.d1 = _74;
    if (_74 > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= _73;
    _78 *= _74;
    _78 *= sizeof(bool);
    _72.data = jpl_alloc(_78);
    int64_t _79 = 0; // r
    int64_t _80 = 0; // q
    _jump777:; // Begin body of loop
    bool _81 = true;
    int64_t _82 = 0;
    _82 *= _72.d0;
    _82 += _80;
    _82 *= _72.d1;
    _82 += _79;
    _72.data[_82] = _81;
    _79++;
    if (_79 < _74)
    goto _jump777;
    _79 = 0;
    _80++;
    if (_80 < _73)
    goto _jump777;
    // End body of loop
    _64 = _72;
    _jump770:;
    int64_t _83 = 7;
    if (e >= 0)
    goto _jump778;
    fail_assertion("negative array index");
    _jump778:;
    if (e < _64.d0)
    goto _jump779;
    fail_assertion("index too large");
    _jump779:;
    if (_83 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_83 < _64.d1)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _84 = 0;
    _84 *= _64.d0;
    _84 += e;
    _84 *= _64.d1;
    _84 += _83;
    bool _85 = _64.data[_84];
    _52 = _85;
    _jump765:;
    bool _51 = _52;
    if (0 == _52)
    goto _jump782;
    double _86;
    // Computing bound for q
    _a3_int64_t _87;
    // Computing bound for q
    _87.d0 = f;
    if (f > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing bound for r
    int64_t _88 = 180;
    _87.d1 = _88;
    if (_88 > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    // Computing bound for s
    _87.d2 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= f;
    _89 *= _88;
    _89 *= _2.d1;
    _89 *= sizeof(int64_t);
    _87.data = jpl_alloc(_89);
    int64_t _90 = 0; // s
    int64_t _91 = 0; // r
    int64_t _92 = 0; // q
    _jump786:; // Begin body of loop
    int64_t _93 = 0;
    _93 *= _87.d0;
    _93 += _92;
    _93 *= _87.d1;
    _93 += _91;
    _93 *= _87.d2;
    _93 += _90;
    _87.data[_93] = e;
    _90++;
    if (_90 < _2.d1)
    goto _jump786;
    _90 = 0;
    _91++;
    if (_91 < _88)
    goto _jump786;
    _91 = 0;
    _92++;
    if (_92 < f)
    goto _jump786;
    // End body of loop
    int64_t _94 = -f;
    if (i >= 0)
    goto _jump787;
    fail_assertion("negative array index");
    _jump787:;
    if (i < _87.d0)
    goto _jump788;
    fail_assertion("index too large");
    _jump788:;
    if (_94 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_94 < _87.d1)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    if (_2.d1 >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (_2.d1 < _87.d2)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    int64_t _95 = 0;
    _95 *= _87.d0;
    _95 += i;
    _95 *= _87.d1;
    _95 += _94;
    _95 *= _87.d2;
    _95 += _2.d1;
    int64_t _96 = _87.data[_95];
    if (_96 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    _86 = 0;
    int64_t _97 = 0; // q
    _jump794:; // Begin body of loop
    double _98 = 50.0;
    _86 += _98;
    _97++;
    if (_97 < _96)
    goto _jump794;
    // End body of loop
    double _99 = 85.0;
    bool _100 = _86 == _99;
    bool _101;
    if (!_100)
    goto _jump795;
    bool _102 = true;
    _101 = _102;
    goto _jump796;
    _jump795:;
    if (_2.d1 >= 0)
    goto _jump797;
    fail_assertion("negative array index");
    _jump797:;
    if (_2.d1 < a.d0)
    goto _jump798;
    fail_assertion("index too large");
    _jump798:;
    int64_t _105 = 0;
    _105 *= a.d0;
    _105 += _2.d1;
    bool _106 = a.data[_105];
    int64_t _107 = 617;
    bool _108 = g == _107;
    bool _109 = _106 != _108;
    bool _104 = _109;
    if (0 == _109)
    goto _jump799;
    bool _110 = false;
    _104 = _110;
    _jump799:;
    bool _103 = _104;
    if (0 == _104)
    goto _jump800;
    int64_t _111;
    // Computing bound for q
    if (g > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing bound for r
    if (_2.d1 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing bound for s
    if (g > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    _111 = 0;
    int64_t _112 = 0; // s
    int64_t _113 = 0; // r
    int64_t _114 = 0; // q
    _jump804:; // Begin body of loop
    int64_t _115 = 612;
    _111 += _115;
    _112++;
    if (_112 < g)
    goto _jump804;
    _112 = 0;
    _113++;
    if (_113 < _2.d1)
    goto _jump804;
    _113 = 0;
    _114++;
    if (_114 < g)
    goto _jump804;
    // End body of loop
    bool _116 = _111 != l.d0;
    bool _117;
    if (!_116)
    goto _jump805;
    bool _119 = true;
    bool _120 = !_119;
    bool _118 = _120;
    if (0 != _120)
    goto _jump806;
    bool _121 = true;
    _118 = _121;
    _jump806:;
    _117 = _118;
    goto _jump807;
    _jump805:;
    if (i >= 0)
    goto _jump808;
    fail_assertion("negative array index");
    _jump808:;
    if (i < a.d0)
    goto _jump809;
    fail_assertion("index too large");
    _jump809:;
    int64_t _123 = 0;
    _123 *= a.d0;
    _123 += i;
    bool _124 = a.data[_123];
    bool _122 = _124;
    if (0 == _124)
    goto _jump810;
    bool _125 = f != e;
    _122 = _125;
    _jump810:;
    _117 = _122;
    _jump807:;
    _103 = _117;
    _jump800:;
    _101 = _103;
    _jump796:;
    _51 = _101;
    _jump782:;
    bool _126 = _50 != _51;
    bool _127 = true;
    _a1__a2__a2__a3_double _128;
    if (!_127)
    goto _jump811;
    _a2__a2__a3_double _129;
    // Computing bound for r
    int64_t _130 = 629;
    int64_t _131 = f / _130;
    _129.d0 = _131;
    if (_131 > 0) 
    goto _jump812;
    fail_assertion("non-positive loop bound");
    _jump812:;
    // Computing bound for s
    _129.d1 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= _131;
    _132 *= _2.d0;
    _132 *= sizeof(_a2__a3_double);
    _129.data = jpl_alloc(_132);
    int64_t _133 = 0; // s
    int64_t _134 = 0; // r
    _jump814:; // Begin body of loop
    int64_t _135 = 0;
    _135 *= _129.d0;
    _135 += _134;
    _135 *= _129.d1;
    _135 += _133;
    _129.data[_135] = _2;
    _133++;
    if (_133 < _2.d0)
    goto _jump814;
    _133 = 0;
    _134++;
    if (_134 < _131)
    goto _jump814;
    // End body of loop
    _a1__a2__a2__a3_double _136;
    // Computing bound for r
    int64_t _137 = 961;
    _136.d0 = _137;
    if (_137 > 0) 
    goto _jump815;
    fail_assertion("non-positive loop bound");
    _jump815:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= _137;
    _138 *= sizeof(_a2__a2__a3_double);
    _136.data = jpl_alloc(_138);
    int64_t _139 = 0; // r
    _jump816:; // Begin body of loop
    _a2__a2__a3_double _140;
    // Computing bound for s
    int64_t _141;
    // Computing bound for s
    if (f > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for t
    if (_2.d1 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for u
    if (_2.d0 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    _141 = 0;
    int64_t _142 = 0; // u
    int64_t _143 = 0; // t
    int64_t _144 = 0; // s
    _jump820:; // Begin body of loop
    _141 += e;
    _142++;
    if (_142 < _2.d0)
    goto _jump820;
    _142 = 0;
    _143++;
    if (_143 < _2.d1)
    goto _jump820;
    _143 = 0;
    _144++;
    if (_144 < f)
    goto _jump820;
    // End body of loop
    _140.d0 = _141;
    if (_141 > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    // Computing bound for t
    _140.d1 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= _141;
    _145 *= _2.d0;
    _145 *= sizeof(_a2__a3_double);
    _140.data = jpl_alloc(_145);
    int64_t _146 = 0; // t
    int64_t _147 = 0; // s
    _jump823:; // Begin body of loop
    int64_t _148 = 0;
    _148 *= _140.d0;
    _148 += _147;
    _148 *= _140.d1;
    _148 += _146;
    _140.data[_148] = h;
    _146++;
    if (_146 < _2.d0)
    goto _jump823;
    _146 = 0;
    _147++;
    if (_147 < _141)
    goto _jump823;
    // End body of loop
    int64_t _149 = 0;
    _149 *= _136.d0;
    _149 += _139;
    _136.data[_149] = _140;
    _139++;
    if (_139 < _137)
    goto _jump816;
    // End body of loop
    bool _150 = _126;
    if (0 != _126)
    goto _jump824;
    double _151 = 30.0;
    double _152 = 7.0;
    bool _153 = _151 < _152;
    _150 = _153;
    _jump824:;
    int64_t _154;
    if (!_150)
    goto _jump825;
    _154 = l.d0;
    goto _jump826;
    _jump825:;
    int64_t _155;
    // Computing bound for r
    if (f > 0) 
    goto _jump827;
    fail_assertion("non-positive loop bound");
    _jump827:;
    // Computing bound for s
    if (i > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing bound for t
    if (l.d0 > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    _155 = 0;
    int64_t _156 = 0; // t
    int64_t _157 = 0; // s
    int64_t _158 = 0; // r
    _jump830:; // Begin body of loop
    int64_t _159 = -_157;
    _155 += _159;
    _156++;
    if (_156 < l.d0)
    goto _jump830;
    _156 = 0;
    _157++;
    if (_157 < i)
    goto _jump830;
    _157 = 0;
    _158++;
    if (_158 < f)
    goto _jump830;
    // End body of loop
    _154 = _155;
    _jump826:;
    if (_154 >= 0)
    goto _jump831;
    fail_assertion("negative array index");
    _jump831:;
    if (_154 < _136.d0)
    goto _jump832;
    fail_assertion("index too large");
    _jump832:;
    int64_t _160 = 0;
    _160 *= _136.d0;
    _160 += _154;
    _a2__a2__a3_double _161 = _136.data[_160];
    _a1__a2__a2__a3_double _162;
    _162.d0 = 2;
    _162.data = jpl_alloc(sizeof(_a2__a2__a3_double) * 2);
    _162.data[0] = _129;
    _162.data[1] = _161;
    _128 = _162;
    goto _jump833;
    _jump811:;
    _a2__a2__a3_double _163;
    // Computing bound for r
    _163.d0 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing bound for s
    _163.d1 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= _2.d1;
    _164 *= _2.d1;
    _164 *= sizeof(_a2__a3_double);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // s
    int64_t _166 = 0; // r
    _jump836:; // Begin body of loop
    int64_t _167 = 0;
    _167 *= _163.d0;
    _167 += _166;
    _167 *= _163.d1;
    _167 += _165;
    _163.data[_167] = h;
    _165++;
    if (_165 < _2.d1)
    goto _jump836;
    _165 = 0;
    _166++;
    if (_166 < _2.d1)
    goto _jump836;
    // End body of loop
    _a2__a2__a2__a3_double _168;
    // Computing bound for r
    int64_t _169 = 425;
    _168.d0 = _169;
    if (_169 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for s
    _168.d1 = j;
    if (j > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing total size of heap memory to allocate
    int64_t _170 = 1;
    _170 *= _169;
    _170 *= j;
    _170 *= sizeof(_a2__a2__a3_double);
    _168.data = jpl_alloc(_170);
    int64_t _171 = 0; // s
    int64_t _172 = 0; // r
    _jump839:; // Begin body of loop
    _a2__a2__a3_double _173;
    // Computing bound for t
    _173.d0 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for u
    int64_t _174 = 680;
    _173.d1 = _174;
    if (_174 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing total size of heap memory to allocate
    int64_t _175 = 1;
    _175 *= _2.d0;
    _175 *= _174;
    _175 *= sizeof(_a2__a3_double);
    _173.data = jpl_alloc(_175);
    int64_t _176 = 0; // u
    int64_t _177 = 0; // t
    _jump842:; // Begin body of loop
    int64_t _178 = 0;
    _178 *= _173.d0;
    _178 += _177;
    _178 *= _173.d1;
    _178 += _176;
    _173.data[_178] = _2;
    _176++;
    if (_176 < _174)
    goto _jump842;
    _176 = 0;
    _177++;
    if (_177 < _2.d0)
    goto _jump842;
    // End body of loop
    int64_t _179 = 0;
    _179 *= _168.d0;
    _179 += _172;
    _179 *= _168.d1;
    _179 += _171;
    _168.data[_179] = _173;
    _171++;
    if (_171 < j)
    goto _jump839;
    _171 = 0;
    _172++;
    if (_172 < _169)
    goto _jump839;
    // End body of loop
    bool _180 = _2.d0 <= i;
    bool _181 = !_180;
    int64_t _182;
    if (!_181)
    goto _jump843;
    bool _183 = true;
    int64_t _184;
    if (!_183)
    goto _jump844;
    _184 = g;
    goto _jump845;
    _jump844:;
    _184 = f;
    _jump845:;
    _182 = _184;
    goto _jump846;
    _jump843:;
    int64_t _185;
    // Computing bound for r
    if (i > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing bound for s
    int64_t _186 = 479;
    if (_186 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    _185 = 0;
    int64_t _187 = 0; // s
    int64_t _188 = 0; // r
    _jump849:; // Begin body of loop
    int64_t _189 = 525;
    _185 += _189;
    _187++;
    if (_187 < _186)
    goto _jump849;
    _187 = 0;
    _188++;
    if (_188 < i)
    goto _jump849;
    // End body of loop
    _182 = _185;
    _jump846:;
    if (j >= 0)
    goto _jump850;
    fail_assertion("negative array index");
    _jump850:;
    if (j < _168.d0)
    goto _jump851;
    fail_assertion("index too large");
    _jump851:;
    if (_182 >= 0)
    goto _jump852;
    fail_assertion("negative array index");
    _jump852:;
    if (_182 < _168.d1)
    goto _jump853;
    fail_assertion("index too large");
    _jump853:;
    int64_t _190 = 0;
    _190 *= _168.d0;
    _190 += j;
    _190 *= _168.d1;
    _190 += _182;
    _a2__a2__a3_double _191 = _168.data[_190];
    bool _192 = _126;
    if (0 != _126)
    goto _jump854;
    bool _193 = true;
    _192 = _193;
    _jump854:;
    bool _194 = !_192;
    bool _195 = !_194;
    _a2__a2__a3_double _196;
    if (!_195)
    goto _jump855;
    _a2__a2__a3_double _197;
    // Computing bound for r
    int64_t _198 = 582;
    _197.d0 = _198;
    if (_198 > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing bound for s
    _197.d1 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= _198;
    _199 *= _2.d1;
    _199 *= sizeof(_a2__a3_double);
    _197.data = jpl_alloc(_199);
    int64_t _200 = 0; // s
    int64_t _201 = 0; // r
    _jump858:; // Begin body of loop
    int64_t _202 = 0;
    _202 *= _197.d0;
    _202 += _201;
    _202 *= _197.d1;
    _202 += _200;
    _197.data[_202] = _2;
    _200++;
    if (_200 < _2.d1)
    goto _jump858;
    _200 = 0;
    _201++;
    if (_201 < _198)
    goto _jump858;
    // End body of loop
    _196 = _197;
    goto _jump859;
    _jump855:;
    _a2__a2__a3_double _203;
    // Computing bound for r
    int64_t _204;
    // Computing bound for r
    if (_2.d1 > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    _204 = 0;
    int64_t _205 = 0; // r
    _jump861:; // Begin body of loop
    _204 += _2.d0;
    _205++;
    if (_205 < _2.d1)
    goto _jump861;
    // End body of loop
    _203.d0 = _204;
    if (_204 > 0) 
    goto _jump862;
    fail_assertion("non-positive loop bound");
    _jump862:;
    // Computing bound for s
    _203.d1 = _2.d1;
    if (_2.d1 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= _204;
    _206 *= _2.d1;
    _206 *= sizeof(_a2__a3_double);
    _203.data = jpl_alloc(_206);
    int64_t _207 = 0; // s
    int64_t _208 = 0; // r
    _jump864:; // Begin body of loop
    _a2__a3_double _209;
    // Computing bound for t
    int64_t _210 = _2.d0 * i;
    _209.d0 = _210;
    if (_210 > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    // Computing bound for u
    _209.d1 = e;
    if (e > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= _210;
    _211 *= e;
    _211 *= sizeof(_a3_double);
    _209.data = jpl_alloc(_211);
    int64_t _212 = 0; // u
    int64_t _213 = 0; // t
    _jump867:; // Begin body of loop
    int64_t _214 = 0;
    _214 *= _209.d0;
    _214 += _213;
    _214 *= _209.d1;
    _214 += _212;
    _209.data[_214] = d;
    _212++;
    if (_212 < e)
    goto _jump867;
    _212 = 0;
    _213++;
    if (_213 < _210)
    goto _jump867;
    // End body of loop
    int64_t _215 = 0;
    _215 *= _203.d0;
    _215 += _208;
    _215 *= _203.d1;
    _215 += _207;
    _203.data[_215] = _209;
    _207++;
    if (_207 < _2.d1)
    goto _jump864;
    _207 = 0;
    _208++;
    if (_208 < _204)
    goto _jump864;
    // End body of loop
    _196 = _203;
    _jump859:;
    _a1__a2__a2__a3_double _216;
    _216.d0 = 3;
    _216.data = jpl_alloc(sizeof(_a2__a2__a3_double) * 3);
    _216.data[0] = _163;
    _216.data[1] = _191;
    _216.data[2] = _196;
    _128 = _216;
    _jump833:;
    int64_t _217 = i + g;
    int64_t _218 = _217 / j;
    if (_218 >= 0)
    goto _jump868;
    fail_assertion("negative array index");
    _jump868:;
    if (_218 < _128.d0)
    goto _jump869;
    fail_assertion("index too large");
    _jump869:;
    int64_t _219 = 0;
    _219 *= _128.d0;
    _219 += _218;
    _a2__a2__a3_double _220 = _128.data[_219];
    _a3_double _221;
    if (!_126)
    goto _jump870;
    _a3_double _222;
    // Computing bound for u
    bool _223 = true;
    int64_t _224;
    if (!_223)
    goto _jump871;
    _224 = _220.d1;
    goto _jump872;
    _jump871:;
    _224 = e;
    _jump872:;
    int64_t _225;
    // Computing bound for u
    if (_220.d1 > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    _225 = 0;
    int64_t _226 = 0; // u
    _jump874:; // Begin body of loop
    _225 += i;
    _226++;
    if (_226 < _220.d1)
    goto _jump874;
    // End body of loop
    int64_t _227 = _225 % l.d0;
    int64_t _228 = _224 / _227;
    _222.d0 = _228;
    if (_228 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for v
    _222.d1 = f;
    if (f > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing bound for w
    bool _230 = e > l.d0;
    bool _231;
    if (!_230)
    goto _jump877;
    _a3_bool _232;
    // Computing bound for u
    _232.d0 = g;
    if (g > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing bound for v
    int64_t _233 = 200;
    _232.d1 = _233;
    if (_233 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing bound for w
    _232.d2 = e;
    if (e > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= g;
    _234 *= _233;
    _234 *= e;
    _234 *= sizeof(bool);
    _232.data = jpl_alloc(_234);
    int64_t _235 = 0; // w
    int64_t _236 = 0; // v
    int64_t _237 = 0; // u
    _jump881:; // Begin body of loop
    int64_t _238 = 0;
    _238 *= _232.d0;
    _238 += _237;
    _238 *= _232.d1;
    _238 += _236;
    _238 *= _232.d2;
    _238 += _235;
    _232.data[_238] = _126;
    _235++;
    if (_235 < e)
    goto _jump881;
    _235 = 0;
    _236++;
    if (_236 < _233)
    goto _jump881;
    _236 = 0;
    _237++;
    if (_237 < g)
    goto _jump881;
    // End body of loop
    if (_2.d0 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_2.d0 < _232.d0)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    if (e >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (e < _232.d1)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    if (f >= 0)
    goto _jump886;
    fail_assertion("negative array index");
    _jump886:;
    if (f < _232.d2)
    goto _jump887;
    fail_assertion("index too large");
    _jump887:;
    int64_t _239 = 0;
    _239 *= _232.d0;
    _239 += _2.d0;
    _239 *= _232.d1;
    _239 += e;
    _239 *= _232.d2;
    _239 += f;
    bool _240 = _232.data[_239];
    _231 = _240;
    goto _jump888;
    _jump877:;
    bool _241;
    if (!_126)
    goto _jump889;
    bool _242 = false;
    bool _243 = !_242;
    _241 = _243;
    goto _jump890;
    _jump889:;
    _241 = _126;
    _jump890:;
    _231 = _241;
    _jump888:;
    bool _229 = _231;
    if (0 != _231)
    goto _jump891;
    bool _244 = true;
    _229 = _244;
    _jump891:;
    int64_t _245;
    if (!_229)
    goto _jump892;
    bool _246 = i == _220.d1;
    int64_t _247;
    if (!_246)
    goto _jump893;
    _247 = l.d0;
    goto _jump894;
    _jump893:;
    int64_t _248 = 528;
    _247 = _248;
    _jump894:;
    _245 = _247;
    goto _jump895;
    _jump892:;
    _245 = i;
    _jump895:;
    _222.d2 = _245;
    if (_245 > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    // Computing total size of heap memory to allocate
    int64_t _249 = 1;
    _249 *= _228;
    _249 *= f;
    _249 *= _245;
    _249 *= sizeof(double);
    _222.data = jpl_alloc(_249);
    int64_t _250 = 0; // w
    int64_t _251 = 0; // v
    int64_t _252 = 0; // u
    _jump897:; // Begin body of loop
    _a1__a3_double _253;
    // Computing bound for x
    _253.d0 = _251;
    if (_251 > 0) 
    goto _jump898;
    fail_assertion("non-positive loop bound");
    _jump898:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= _251;
    _254 *= sizeof(_a3_double);
    _253.data = jpl_alloc(_254);
    int64_t _255 = 0; // x
    _jump899:; // Begin body of loop
    _a2__a3_double _256;
    // Computing bound for y
    _256.d0 = i;
    if (i > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for z
    _256.d1 = _252;
    if (_252 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing total size of heap memory to allocate
    int64_t _257 = 1;
    _257 *= i;
    _257 *= _252;
    _257 *= sizeof(_a3_double);
    _256.data = jpl_alloc(_257);
    int64_t _258 = 0; // z
    int64_t _259 = 0; // y
    _jump902:; // Begin body of loop
    int64_t _260 = 0;
    _260 *= _256.d0;
    _260 += _259;
    _260 *= _256.d1;
    _260 += _258;
    _256.data[_260] = d;
    _258++;
    if (_258 < _252)
    goto _jump902;
    _258 = 0;
    _259++;
    if (_259 < i)
    goto _jump902;
    // End body of loop
    int64_t _261 = -_220.d0;
    if (_220.d0 >= 0)
    goto _jump903;
    fail_assertion("negative array index");
    _jump903:;
    if (_220.d0 < _256.d0)
    goto _jump904;
    fail_assertion("index too large");
    _jump904:;
    if (_261 >= 0)
    goto _jump905;
    fail_assertion("negative array index");
    _jump905:;
    if (_261 < _256.d1)
    goto _jump906;
    fail_assertion("index too large");
    _jump906:;
    int64_t _262 = 0;
    _262 *= _256.d0;
    _262 += _220.d0;
    _262 *= _256.d1;
    _262 += _261;
    _a3_double _263 = _256.data[_262];
    int64_t _264 = 0;
    _264 *= _253.d0;
    _264 += _255;
    _253.data[_264] = _263;
    _255++;
    if (_255 < _251)
    goto _jump899;
    // End body of loop
    if (_220.d1 >= 0)
    goto _jump907;
    fail_assertion("negative array index");
    _jump907:;
    if (_220.d1 < _253.d0)
    goto _jump908;
    fail_assertion("index too large");
    _jump908:;
    int64_t _265 = 0;
    _265 *= _253.d0;
    _265 += _220.d1;
    _a3_double _266 = _253.data[_265];
    int64_t _267;
    // Computing bound for x
    int64_t _268 = i - _220.d0;
    if (_268 > 0) 
    goto _jump909;
    fail_assertion("non-positive loop bound");
    _jump909:;
    // Computing bound for y
    if (_252 > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    _267 = 0;
    int64_t _269 = 0; // y
    int64_t _270 = 0; // x
    _jump911:; // Begin body of loop
    _267 += _2.d1;
    _269++;
    if (_269 < _252)
    goto _jump911;
    _269 = 0;
    _270++;
    if (_270 < _268)
    goto _jump911;
    // End body of loop
    bool _271 = false;
    bool _272 = !_271;
    _a2_int64_t _273;
    if (!_272)
    goto _jump912;
    _a2_int64_t _274;
    // Computing bound for x
    int64_t _275 = 639;
    _274.d0 = _275;
    if (_275 > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    // Computing bound for y
    _274.d1 = _250;
    if (_250 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing total size of heap memory to allocate
    int64_t _276 = 1;
    _276 *= _275;
    _276 *= _250;
    _276 *= sizeof(int64_t);
    _274.data = jpl_alloc(_276);
    int64_t _277 = 0; // y
    int64_t _278 = 0; // x
    _jump915:; // Begin body of loop
    int64_t _279 = 0;
    _279 *= _274.d0;
    _279 += _278;
    _279 *= _274.d1;
    _279 += _277;
    _274.data[_279] = _220.d0;
    _277++;
    if (_277 < _250)
    goto _jump915;
    _277 = 0;
    _278++;
    if (_278 < _275)
    goto _jump915;
    // End body of loop
    _273 = _274;
    goto _jump916;
    _jump912:;
    _a2_int64_t _280;
    // Computing bound for x
    _280.d0 = _251;
    if (_251 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for y
    _280.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing total size of heap memory to allocate
    int64_t _281 = 1;
    _281 *= _251;
    _281 *= l.d0;
    _281 *= sizeof(int64_t);
    _280.data = jpl_alloc(_281);
    int64_t _282 = 0; // y
    int64_t _283 = 0; // x
    _jump919:; // Begin body of loop
    int64_t _284 = 0;
    _284 *= _280.d0;
    _284 += _283;
    _284 *= _280.d1;
    _284 += _282;
    _280.data[_284] = g;
    _282++;
    if (_282 < l.d0)
    goto _jump919;
    _282 = 0;
    _283++;
    if (_283 < _251)
    goto _jump919;
    // End body of loop
    _273 = _280;
    _jump916:;
    if (_2.d1 >= 0)
    goto _jump920;
    fail_assertion("negative array index");
    _jump920:;
    if (_2.d1 < _273.d0)
    goto _jump921;
    fail_assertion("index too large");
    _jump921:;
    if (f >= 0)
    goto _jump922;
    fail_assertion("negative array index");
    _jump922:;
    if (f < _273.d1)
    goto _jump923;
    fail_assertion("index too large");
    _jump923:;
    int64_t _285 = 0;
    _285 *= _273.d0;
    _285 += _2.d1;
    _285 *= _273.d1;
    _285 += f;
    int64_t _286 = _273.data[_285];
    int64_t _287 = _267 * _286;
    if (i >= 0)
    goto _jump924;
    fail_assertion("negative array index");
    _jump924:;
    if (i < _266.d0)
    goto _jump925;
    fail_assertion("index too large");
    _jump925:;
    if (_287 >= 0)
    goto _jump926;
    fail_assertion("negative array index");
    _jump926:;
    if (_287 < _266.d1)
    goto _jump927;
    fail_assertion("index too large");
    _jump927:;
    if (_250 >= 0)
    goto _jump928;
    fail_assertion("negative array index");
    _jump928:;
    if (_250 < _266.d2)
    goto _jump929;
    fail_assertion("index too large");
    _jump929:;
    int64_t _288 = 0;
    _288 *= _266.d0;
    _288 += i;
    _288 *= _266.d1;
    _288 += _287;
    _288 *= _266.d2;
    _288 += _250;
    double _289 = _266.data[_288];
    int64_t _290 = 0;
    _290 *= _222.d0;
    _290 += _252;
    _290 *= _222.d1;
    _290 += _251;
    _290 *= _222.d2;
    _290 += _250;
    _222.data[_290] = _289;
    _250++;
    if (_250 < _245)
    goto _jump897;
    _250 = 0;
    _251++;
    if (_251 < f)
    goto _jump897;
    _251 = 0;
    _252++;
    if (_252 < _228)
    goto _jump897;
    // End body of loop
    _221 = _222;
    goto _jump930;
    _jump870:;
    int64_t _291 = l.d0 * _2.d1;
    bool _292 = _291 == _220.d0;
    bool _293;
    if (!_292)
    goto _jump931;
    _a3_bool _294;
    // Computing bound for u
    int64_t _295;
    // Computing bound for u
    int64_t _296 = 483;
    if (_296 > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    // Computing bound for v
    if (_2.d1 > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    // Computing bound for w
    int64_t _297 = 776;
    if (_297 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    _295 = 0;
    int64_t _298 = 0; // w
    int64_t _299 = 0; // v
    int64_t _300 = 0; // u
    _jump935:; // Begin body of loop
    _295 += j;
    _298++;
    if (_298 < _297)
    goto _jump935;
    _298 = 0;
    _299++;
    if (_299 < _2.d1)
    goto _jump935;
    _299 = 0;
    _300++;
    if (_300 < _296)
    goto _jump935;
    // End body of loop
    _294.d0 = _295;
    if (_295 > 0) 
    goto _jump936;
    fail_assertion("non-positive loop bound");
    _jump936:;
    // Computing bound for v
    int64_t _301 = -f;
    _294.d1 = _301;
    if (_301 > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing bound for w
    _294.d2 = g;
    if (g > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _295;
    _302 *= _301;
    _302 *= g;
    _302 *= sizeof(bool);
    _294.data = jpl_alloc(_302);
    int64_t _303 = 0; // w
    int64_t _304 = 0; // v
    int64_t _305 = 0; // u
    _jump939:; // Begin body of loop
    bool _306;
    if (!_126)
    goto _jump940;
    bool _307 = false;
    _306 = _307;
    goto _jump941;
    _jump940:;
    _306 = _126;
    _jump941:;
    int64_t _308 = 0;
    _308 *= _294.d0;
    _308 += _305;
    _308 *= _294.d1;
    _308 += _304;
    _308 *= _294.d2;
    _308 += _303;
    _294.data[_308] = _306;
    _303++;
    if (_303 < g)
    goto _jump939;
    _303 = 0;
    _304++;
    if (_304 < _301)
    goto _jump939;
    _304 = 0;
    _305++;
    if (_305 < _295)
    goto _jump939;
    // End body of loop
    int64_t _309;
    // Computing bound for u
    int64_t _310 = 883;
    if (_310 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing bound for v
    if (_220.d1 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    _309 = 0;
    int64_t _311 = 0; // v
    int64_t _312 = 0; // u
    _jump944:; // Begin body of loop
    int64_t _313 = -g;
    _309 += _313;
    _311++;
    if (_311 < _220.d1)
    goto _jump944;
    _311 = 0;
    _312++;
    if (_312 < _310)
    goto _jump944;
    // End body of loop
    if (_2.d0 >= 0)
    goto _jump945;
    fail_assertion("negative array index");
    _jump945:;
    if (_2.d0 < _294.d0)
    goto _jump946;
    fail_assertion("index too large");
    _jump946:;
    if (f >= 0)
    goto _jump947;
    fail_assertion("negative array index");
    _jump947:;
    if (f < _294.d1)
    goto _jump948;
    fail_assertion("index too large");
    _jump948:;
    if (_309 >= 0)
    goto _jump949;
    fail_assertion("negative array index");
    _jump949:;
    if (_309 < _294.d2)
    goto _jump950;
    fail_assertion("index too large");
    _jump950:;
    int64_t _314 = 0;
    _314 *= _294.d0;
    _314 += _2.d0;
    _314 *= _294.d1;
    _314 += f;
    _314 *= _294.d2;
    _314 += _309;
    bool _315 = _294.data[_314];
    _293 = _315;
    goto _jump951;
    _jump931:;
    double _316 = 27.0;
    double _317 = -_316;
    double _318 = -_317;
    double _319 = 12.0;
    double _320 = 62.0;
    double _321 = fmod(_319, _320);
    bool _322 = _318 != _321;
    _293 = _322;
    _jump951:;
    _a1__a3_double _323;
    if (!_293)
    goto _jump952;
    _a1__a3_double _324;
    if (!_126)
    goto _jump953;
    _a3__a1__a3_double _325;
    // Computing bound for u
    _325.d0 = _2.d0;
    if (_2.d0 > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing bound for v
    int64_t _326 = -e;
    _325.d1 = _326;
    if (_326 > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing bound for w
    _325.d2 = f;
    if (f > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing total size of heap memory to allocate
    int64_t _327 = 1;
    _327 *= _2.d0;
    _327 *= _326;
    _327 *= f;
    _327 *= sizeof(_a1__a3_double);
    _325.data = jpl_alloc(_327);
    int64_t _328 = 0; // w
    int64_t _329 = 0; // v
    int64_t _330 = 0; // u
    _jump957:; // Begin body of loop
    _a1__a3_double _331;
    // Computing bound for x
    _331.d0 = _220.d0;
    if (_220.d0 > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= _220.d0;
    _332 *= sizeof(_a3_double);
    _331.data = jpl_alloc(_332);
    int64_t _333 = 0; // x
    _jump959:; // Begin body of loop
    int64_t _334 = 0;
    _334 *= _331.d0;
    _334 += _333;
    _331.data[_334] = d;
    _333++;
    if (_333 < _220.d0)
    goto _jump959;
    // End body of loop
    int64_t _335 = 0;
    _335 *= _325.d0;
    _335 += _330;
    _335 *= _325.d1;
    _335 += _329;
    _335 *= _325.d2;
    _335 += _328;
    _325.data[_335] = _331;
    _328++;
    if (_328 < f)
    goto _jump957;
    _328 = 0;
    _329++;
    if (_329 < _326)
    goto _jump957;
    _329 = 0;
    _330++;
    if (_330 < _2.d0)
    goto _jump957;
    // End body of loop
    int64_t _336;
    // Computing bound for u
    if (l.d0 > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for v
    int64_t _337 = l.d0 - j;
    if (_337 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for w
    if (g > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    _336 = 0;
    int64_t _338 = 0; // w
    int64_t _339 = 0; // v
    int64_t _340 = 0; // u
    _jump963:; // Begin body of loop
    _336 += _220.d1;
    _338++;
    if (_338 < g)
    goto _jump963;
    _338 = 0;
    _339++;
    if (_339 < _337)
    goto _jump963;
    _339 = 0;
    _340++;
    if (_340 < l.d0)
    goto _jump963;
    // End body of loop
    int64_t _341 = 298;
    if (_336 >= 0)
    goto _jump964;
    fail_assertion("negative array index");
    _jump964:;
    if (_336 < _325.d0)
    goto _jump965;
    fail_assertion("index too large");
    _jump965:;
    if (_341 >= 0)
    goto _jump966;
    fail_assertion("negative array index");
    _jump966:;
    if (_341 < _325.d1)
    goto _jump967;
    fail_assertion("index too large");
    _jump967:;
    if (l.d0 >= 0)
    goto _jump968;
    fail_assertion("negative array index");
    _jump968:;
    if (l.d0 < _325.d2)
    goto _jump969;
    fail_assertion("index too large");
    _jump969:;
    int64_t _342 = 0;
    _342 *= _325.d0;
    _342 += _336;
    _342 *= _325.d1;
    _342 += _341;
    _342 *= _325.d2;
    _342 += l.d0;
    _a1__a3_double _343 = _325.data[_342];
    _324 = _343;
    goto _jump970;
    _jump953:;
    _a1__a3_double _344;
    // Computing bound for u
    int64_t _345 = -g;
    _344.d0 = _345;
    if (_345 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    // Computing total size of heap memory to allocate
    int64_t _346 = 1;
    _346 *= _345;
    _346 *= sizeof(_a3_double);
    _344.data = jpl_alloc(_346);
    int64_t _347 = 0; // u
    _jump972:; // Begin body of loop
    int64_t _348 = 0;
    _348 *= _344.d0;
    _348 += _347;
    _344.data[_348] = d;
    _347++;
    if (_347 < _345)
    goto _jump972;
    // End body of loop
    _324 = _344;
    _jump970:;
    _323 = _324;
    goto _jump973;
    _jump952:;
    _a3__a3_double _349;
    // Computing bound for u
    int64_t _350;
    // Computing bound for u
    int64_t _351 = 29;
    if (_351 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for v
    int64_t _352 = 890;
    if (_352 > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing bound for w
    if (e > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    _350 = 0;
    int64_t _353 = 0; // w
    int64_t _354 = 0; // v
    int64_t _355 = 0; // u
    _jump977:; // Begin body of loop
    _350 += f;
    _353++;
    if (_353 < e)
    goto _jump977;
    _353 = 0;
    _354++;
    if (_354 < _352)
    goto _jump977;
    _354 = 0;
    _355++;
    if (_355 < _351)
    goto _jump977;
    // End body of loop
    _349.d0 = _350;
    if (_350 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for v
    _349.d1 = g;
    if (g > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing bound for w
    int64_t _356;
    // Computing bound for u
    if (g > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing bound for v
    if (f > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    _356 = 0;
    int64_t _357 = 0; // v
    int64_t _358 = 0; // u
    _jump982:; // Begin body of loop
    _356 += i;
    _357++;
    if (_357 < f)
    goto _jump982;
    _357 = 0;
    _358++;
    if (_358 < g)
    goto _jump982;
    // End body of loop
    _349.d2 = _356;
    if (_356 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing total size of heap memory to allocate
    int64_t _359 = 1;
    _359 *= _350;
    _359 *= g;
    _359 *= _356;
    _359 *= sizeof(_a3_double);
    _349.data = jpl_alloc(_359);
    int64_t _360 = 0; // w
    int64_t _361 = 0; // v
    int64_t _362 = 0; // u
    _jump984:; // Begin body of loop
    _a3_double _363;
    if (!_126)
    goto _jump985;
    _363 = d;
    goto _jump986;
    _jump985:;
    _363 = d;
    _jump986:;
    int64_t _364 = 0;
    _364 *= _349.d0;
    _364 += _362;
    _364 *= _349.d1;
    _364 += _361;
    _364 *= _349.d2;
    _364 += _360;
    _349.data[_364] = _363;
    _360++;
    if (_360 < _356)
    goto _jump984;
    _360 = 0;
    _361++;
    if (_361 < g)
    goto _jump984;
    _361 = 0;
    _362++;
    if (_362 < _350)
    goto _jump984;
    // End body of loop
    if (i >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (i < _349.d0)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    if (l.d0 >= 0)
    goto _jump989;
    fail_assertion("negative array index");
    _jump989:;
    if (l.d0 < _349.d1)
    goto _jump990;
    fail_assertion("index too large");
    _jump990:;
    if (j >= 0)
    goto _jump991;
    fail_assertion("negative array index");
    _jump991:;
    if (j < _349.d2)
    goto _jump992;
    fail_assertion("index too large");
    _jump992:;
    int64_t _365 = 0;
    _365 *= _349.d0;
    _365 += i;
    _365 *= _349.d1;
    _365 += l.d0;
    _365 *= _349.d2;
    _365 += j;
    _a3_double _366 = _349.data[_365];
    _a1__a3_double _367;
    _367.d0 = 2;
    _367.data = jpl_alloc(sizeof(_a3_double) * 2);
    _367.data[0] = d;
    _367.data[1] = _366;
    _323 = _367;
    _jump973:;
    if (e >= 0)
    goto _jump993;
    fail_assertion("negative array index");
    _jump993:;
    if (e < _323.d0)
    goto _jump994;
    fail_assertion("index too large");
    _jump994:;
    int64_t _368 = 0;
    _368 *= _323.d0;
    _368 += e;
    _a3_double _369 = _323.data[_368];
    _221 = _369;
    _jump930:;
    bool _370 = true;
    int64_t _371;
    if (!_370)
    goto _jump995;
    double _372 = 10.0;
    if (i >= 0)
    goto _jump996;
    fail_assertion("negative array index");
    _jump996:;
    if (i < l.d0)
    goto _jump997;
    fail_assertion("index too large");
    _jump997:;
    int64_t _373 = 0;
    _373 *= l.d0;
    _373 += i;
    double _374 = l.data[_373];
    bool _375 = _372 < _374;
    _a2_int64_t _376;
    if (!_375)
    goto _jump998;
    bool _377 = false;
    bool _378 = !_377;
    _a2_int64_t _379;
    if (!_378)
    goto _jump999;
    _a2_int64_t _380;
    // Computing bound for y
    _380.d0 = f;
    if (f > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for z
    _380.d1 = _221.d2;
    if (_221.d2 > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= f;
    _381 *= _221.d2;
    _381 *= sizeof(int64_t);
    _380.data = jpl_alloc(_381);
    int64_t _382 = 0; // z
    int64_t _383 = 0; // y
    _jump1002:; // Begin body of loop
    int64_t _384 = 0;
    _384 *= _380.d0;
    _384 += _383;
    _384 *= _380.d1;
    _384 += _382;
    _380.data[_384] = _382;
    _382++;
    if (_382 < _221.d2)
    goto _jump1002;
    _382 = 0;
    _383++;
    if (_383 < f)
    goto _jump1002;
    // End body of loop
    _379 = _380;
    goto _jump1003;
    _jump999:;
    _a2_int64_t _385;
    // Computing bound for y
    _385.d0 = i;
    if (i > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for z
    _385.d1 = _221.d1;
    if (_221.d1 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing total size of heap memory to allocate
    int64_t _386 = 1;
    _386 *= i;
    _386 *= _221.d1;
    _386 *= sizeof(int64_t);
    _385.data = jpl_alloc(_386);
    int64_t _387 = 0; // z
    int64_t _388 = 0; // y
    _jump1006:; // Begin body of loop
    int64_t _389 = 0;
    _389 *= _385.d0;
    _389 += _388;
    _389 *= _385.d1;
    _389 += _387;
    _385.data[_389] = j;
    _387++;
    if (_387 < _221.d1)
    goto _jump1006;
    _387 = 0;
    _388++;
    if (_388 < i)
    goto _jump1006;
    // End body of loop
    _379 = _385;
    _jump1003:;
    _376 = _379;
    goto _jump1007;
    _jump998:;
    _a2_int64_t _390;
    // Computing bound for y
    _390.d0 = _221.d2;
    if (_221.d2 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for z
    _390.d1 = e;
    if (e > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= _221.d2;
    _391 *= e;
    _391 *= sizeof(int64_t);
    _390.data = jpl_alloc(_391);
    int64_t _392 = 0; // z
    int64_t _393 = 0; // y
    _jump1010:; // Begin body of loop
    int64_t _394 = 0;
    _394 *= _390.d0;
    _394 += _393;
    _394 *= _390.d1;
    _394 += _392;
    _390.data[_394] = _220.d0;
    _392++;
    if (_392 < e)
    goto _jump1010;
    _392 = 0;
    _393++;
    if (_393 < _221.d2)
    goto _jump1010;
    // End body of loop
    _376 = _390;
    _jump1007:;
    if (_220.d0 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (_220.d0 < _376.d0)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    if (_221.d0 >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (_221.d0 < _376.d1)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    int64_t _395 = 0;
    _395 *= _376.d0;
    _395 += _220.d0;
    _395 *= _376.d1;
    _395 += _221.d0;
    int64_t _396 = _376.data[_395];
    _371 = _396;
    goto _jump1015;
    _jump995:;
    _371 = l.d0;
    _jump1015:;
    int64_t _397;
    // Computing bound for y
    if (_221.d2 > 0) 
    goto _jump1016;
    fail_assertion("non-positive loop bound");
    _jump1016:;
    // Computing bound for z
    if (i > 0) 
    goto _jump1017;
    fail_assertion("non-positive loop bound");
    _jump1017:;
    _397 = 0;
    int64_t _398 = 0; // z
    int64_t _399 = 0; // y
    _jump1018:; // Begin body of loop
    _397 += g;
    _398++;
    if (_398 < i)
    goto _jump1018;
    _398 = 0;
    _399++;
    if (_399 < _221.d2)
    goto _jump1018;
    // End body of loop
    int64_t _400 = _371 % _397;
    bool _401 = _400 != e;
    if (0 != _401)
    goto _jump1019;
    fail_assertion("y");
    _jump1019:;
    b _402 = k(l);
    return _402;
}

int64_t l() {
    int64_t _0 = 965;
    int64_t _1 = -_0;
    return _1;
    double _2;
    // Computing bound for m
    if (i > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    _2 = 0;
    int64_t _3 = 0; // m
    _jump1021:; // Begin body of loop
    double _4 = 29.0;
    _2 += _4;
    _3++;
    if (_3 < i)
    goto _jump1021;
    // End body of loop
    double _5 = 8.0;
    bool _6 = _2 >= _5;
    _a1_int64_t _7;
    if (!_6)
    goto _jump1022;
    int64_t _8 = l();
    _a1_int64_t _9;
    _9.d0 = 2;
    _9.data = jpl_alloc(sizeof(int64_t) * 2);
    _9.data[0] = f;
    _9.data[1] = _8;
    _7 = _9;
    goto _jump1023;
    _jump1022:;
    int64_t _10 = l();
    int64_t _11 = _10 / f;
    int64_t _12 = 864;
    _a1_int64_t _13;
    _13.d0 = 3;
    _13.data = jpl_alloc(sizeof(int64_t) * 3);
    _13.data[0] = i;
    _13.data[1] = _11;
    _13.data[2] = _12;
    _7 = _13;
    _jump1023:;
    _a1__a1_int64_t _14;
    _14.d0 = 1;
    _14.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _14.data[0] = _7;
    if (j >= 0)
    goto _jump1024;
    fail_assertion("negative array index");
    _jump1024:;
    if (j < _14.d0)
    goto _jump1025;
    fail_assertion("index too large");
    _jump1025:;
    int64_t _15 = 0;
    _15 *= _14.d0;
    _15 += j;
    _a1_int64_t _16 = _14.data[_15];
    if (j >= 0)
    goto _jump1026;
    fail_assertion("negative array index");
    _jump1026:;
    if (j < _16.d0)
    goto _jump1027;
    fail_assertion("index too large");
    _jump1027:;
    int64_t _17 = 0;
    _17 *= _16.d0;
    _17 += j;
    int64_t _18 = _16.data[_17];
    int64_t _19 = -_18;
    int64_t _20 = 494;
    return _20;
    int64_t _21 = l();
    _a2__a2_int64_t _22;
    // Computing bound for n
    int64_t _23 = l();
    _22.d0 = _23;
    if (_23 > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing bound for o
    int64_t _24 = l();
    _22.d1 = _24;
    if (_24 > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= _23;
    _25 *= _24;
    _25 *= sizeof(_a2_int64_t);
    _22.data = jpl_alloc(_25);
    int64_t _26 = 0; // o
    int64_t _27 = 0; // n
    _jump1030:; // Begin body of loop
    _a2_int64_t _28;
    // Computing bound for p
    int64_t _29 = -_27;
    _28.d0 = _29;
    if (_29 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    // Computing bound for q
    _28.d1 = i;
    if (i > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _29;
    _30 *= i;
    _30 *= sizeof(int64_t);
    _28.data = jpl_alloc(_30);
    int64_t _31 = 0; // q
    int64_t _32 = 0; // p
    _jump1033:; // Begin body of loop
    _a3_int64_t _33;
    // Computing bound for r
    _33.d0 = _32;
    if (_32 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing bound for s
    _33.d1 = _26;
    if (_26 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    // Computing bound for t
    _33.d2 = _26;
    if (_26 > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= _32;
    _34 *= _26;
    _34 *= _26;
    _34 *= sizeof(int64_t);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // t
    int64_t _36 = 0; // s
    int64_t _37 = 0; // r
    _jump1037:; // Begin body of loop
    int64_t _38 = 0;
    _38 *= _33.d0;
    _38 += _37;
    _38 *= _33.d1;
    _38 += _36;
    _38 *= _33.d2;
    _38 += _35;
    _33.data[_38] = i;
    _35++;
    if (_35 < _26)
    goto _jump1037;
    _35 = 0;
    _36++;
    if (_36 < _26)
    goto _jump1037;
    _36 = 0;
    _37++;
    if (_37 < _32)
    goto _jump1037;
    // End body of loop
    int64_t _39;
    // Computing bound for r
    if (e > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    // Computing bound for s
    if (f > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    _39 = 0;
    int64_t _40 = 0; // s
    int64_t _41 = 0; // r
    _jump1040:; // Begin body of loop
    _39 += _31;
    _40++;
    if (_40 < f)
    goto _jump1040;
    _40 = 0;
    _41++;
    if (_41 < e)
    goto _jump1040;
    // End body of loop
    if (f >= 0)
    goto _jump1041;
    fail_assertion("negative array index");
    _jump1041:;
    if (f < _33.d0)
    goto _jump1042;
    fail_assertion("index too large");
    _jump1042:;
    if (_39 >= 0)
    goto _jump1043;
    fail_assertion("negative array index");
    _jump1043:;
    if (_39 < _33.d1)
    goto _jump1044;
    fail_assertion("index too large");
    _jump1044:;
    if (_27 >= 0)
    goto _jump1045;
    fail_assertion("negative array index");
    _jump1045:;
    if (_27 < _33.d2)
    goto _jump1046;
    fail_assertion("index too large");
    _jump1046:;
    int64_t _42 = 0;
    _42 *= _33.d0;
    _42 += f;
    _42 *= _33.d1;
    _42 += _39;
    _42 *= _33.d2;
    _42 += _27;
    int64_t _43 = _33.data[_42];
    int64_t _44 = 0;
    _44 *= _28.d0;
    _44 += _32;
    _44 *= _28.d1;
    _44 += _31;
    _28.data[_44] = _43;
    _31++;
    if (_31 < i)
    goto _jump1033;
    _31 = 0;
    _32++;
    if (_32 < _29)
    goto _jump1033;
    // End body of loop
    int64_t _45 = 0;
    _45 *= _22.d0;
    _45 += _27;
    _45 *= _22.d1;
    _45 += _26;
    _22.data[_45] = _28;
    _26++;
    if (_26 < _24)
    goto _jump1030;
    _26 = 0;
    _27++;
    if (_27 < _23)
    goto _jump1030;
    // End body of loop
    int64_t _46 = 222;
    int64_t _47 = 616;
    if (_46 >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (_46 < _22.d0)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    if (_47 >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (_47 < _22.d1)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    int64_t _48 = 0;
    _48 *= _22.d0;
    _48 += _46;
    _48 *= _22.d1;
    _48 += _47;
    _a2_int64_t _49 = _22.data[_48];
    int64_t _50 = l();
    bool _51 = f == f;
    bool _52 = !_51;
    bool _53 = !_52;
    int64_t _54;
    if (!_53)
    goto _jump1051;
    int64_t _55;
    // Computing bound for n
    if (f > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing bound for o
    bool _56 = false;
    int64_t _57;
    if (!_56)
    goto _jump1053;
    _57 = f;
    goto _jump1054;
    _jump1053:;
    int64_t _58 = 917;
    _57 = _58;
    _jump1054:;
    if (_57 > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    _55 = 0;
    int64_t _59 = 0; // o
    int64_t _60 = 0; // n
    _jump1056:; // Begin body of loop
    bool _61 = true;
    int64_t _62;
    if (!_61)
    goto _jump1057;
    _62 = _60;
    goto _jump1058;
    _jump1057:;
    _62 = j;
    _jump1058:;
    _55 += _62;
    _59++;
    if (_59 < _57)
    goto _jump1056;
    _59 = 0;
    _60++;
    if (_60 < f)
    goto _jump1056;
    // End body of loop
    int64_t _63 = -_55;
    int64_t _64 = _63 + j;
    _54 = _64;
    goto _jump1059;
    _jump1051:;
    _54 = i;
    _jump1059:;
    if (_50 >= 0)
    goto _jump1060;
    fail_assertion("negative array index");
    _jump1060:;
    if (_50 < _49.d0)
    goto _jump1061;
    fail_assertion("index too large");
    _jump1061:;
    if (_54 >= 0)
    goto _jump1062;
    fail_assertion("negative array index");
    _jump1062:;
    if (_54 < _49.d1)
    goto _jump1063;
    fail_assertion("index too large");
    _jump1063:;
    int64_t _65 = 0;
    _65 *= _49.d0;
    _65 += _50;
    _65 *= _49.d1;
    _65 += _54;
    int64_t _66 = _49.data[_65];
    int64_t _67 = l();
    int64_t _68 = -_67;
    _a1_int64_t _69;
    _69.d0 = 3;
    _69.data = jpl_alloc(sizeof(int64_t) * 3);
    _69.data[0] = _21;
    _69.data[1] = _66;
    _69.data[2] = _68;
    _a1_int64_t _70;
    // Computing bound for p
    _70.d0 = f;
    if (f > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= f;
    _71 *= sizeof(int64_t);
    _70.data = jpl_alloc(_71);
    int64_t _72 = 0; // p
    _jump1065:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _70.d0;
    _73 += _72;
    _70.data[_73] = j;
    _72++;
    if (_72 < f)
    goto _jump1065;
    // End body of loop
    int64_t _74 = l();
    return _74;
}

double o(_a1_rgba p, int64_t r, void_t s) {
    double _0;
    // Computing bound for w
    if (e > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    _0 = 0;
    int64_t _1 = 0; // w
    _jump1086:; // Begin body of loop
    int64_t _2 = -g;
    if (h.d0 >= 0)
    goto _jump1087;
    fail_assertion("negative array index");
    _jump1087:;
    if (h.d0 < d.d0)
    goto _jump1088;
    fail_assertion("index too large");
    _jump1088:;
    if (r >= 0)
    goto _jump1089;
    fail_assertion("negative array index");
    _jump1089:;
    if (r < d.d1)
    goto _jump1090;
    fail_assertion("index too large");
    _jump1090:;
    if (_2 >= 0)
    goto _jump1091;
    fail_assertion("negative array index");
    _jump1091:;
    if (_2 < d.d2)
    goto _jump1092;
    fail_assertion("index too large");
    _jump1092:;
    int64_t _3 = 0;
    _3 *= d.d0;
    _3 += h.d0;
    _3 *= d.d1;
    _3 += r;
    _3 *= d.d2;
    _3 += _2;
    double _4 = d.data[_3];
    _0 += _4;
    _1++;
    if (_1 < e)
    goto _jump1086;
    // End body of loop
    bool _5 = false;
    double _6;
    if (!_5)
    goto _jump1093;
    double _7 = o(p, r, s);
    _6 = _7;
    goto _jump1094;
    _jump1093:;
    double _8 = 27.0;
    _6 = _8;
    _jump1094:;
    double _9 = -_6;
    double _10 = fmod(_0, _9);
    int64_t _11 = 17;
    _a3_void_t _12;
    // Computing bound for w
    int64_t _13 = j * p.d0;
    _12.d0 = _13;
    if (_13 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing bound for x
    _12.d1 = p.d0;
    if (p.d0 > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    // Computing bound for y
    int64_t _14;
    // Computing bound for w
    int64_t _15 = 410;
    if (_15 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for x
    if (p.d0 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    _14 = 0;
    int64_t _16 = 0; // x
    int64_t _17 = 0; // w
    _jump1099:; // Begin body of loop
    _14 += _16;
    _16++;
    if (_16 < p.d0)
    goto _jump1099;
    _16 = 0;
    _17++;
    if (_17 < _15)
    goto _jump1099;
    // End body of loop
    _12.d2 = _14;
    if (_14 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= _13;
    _18 *= p.d0;
    _18 *= _14;
    _18 *= sizeof(void_t);
    _12.data = jpl_alloc(_18);
    int64_t _19 = 0; // y
    int64_t _20 = 0; // x
    int64_t _21 = 0; // w
    _jump1101:; // Begin body of loop
    int64_t _22 = 0;
    _22 *= _12.d0;
    _22 += _21;
    _22 *= _12.d1;
    _22 += _20;
    _22 *= _12.d2;
    _22 += _19;
    _12.data[_22] = s;
    _19++;
    if (_19 < _14)
    goto _jump1101;
    _19 = 0;
    _20++;
    if (_20 < p.d0)
    goto _jump1101;
    _20 = 0;
    _21++;
    if (_21 < _13)
    goto _jump1101;
    // End body of loop
    int64_t _23 = n % n;
    int64_t _24 = -_23;
    int64_t _25 = l();
    int64_t _26 = e / _25;
    if (_24 >= 0)
    goto _jump1102;
    fail_assertion("negative array index");
    _jump1102:;
    if (_24 < _12.d0)
    goto _jump1103;
    fail_assertion("index too large");
    _jump1103:;
    if (f >= 0)
    goto _jump1104;
    fail_assertion("negative array index");
    _jump1104:;
    if (f < _12.d1)
    goto _jump1105;
    fail_assertion("index too large");
    _jump1105:;
    if (_26 >= 0)
    goto _jump1106;
    fail_assertion("negative array index");
    _jump1106:;
    if (_26 < _12.d2)
    goto _jump1107;
    fail_assertion("index too large");
    _jump1107:;
    int64_t _27 = 0;
    _27 *= _12.d0;
    _27 += _24;
    _27 *= _12.d1;
    _27 += f;
    _27 *= _12.d2;
    _27 += _26;
    void_t _28 = _12.data[_27];
    double _29 = o(p, _11, _28);
    _a1__a3_void_t _30;
    // Computing bound for w
    int64_t _31 = l();
    _30.d0 = _31;
    if (_31 > 0) 
    goto _jump1108;
    fail_assertion("non-positive loop bound");
    _jump1108:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _31;
    _32 *= sizeof(_a3_void_t);
    _30.data = jpl_alloc(_32);
    int64_t _33 = 0; // w
    _jump1109:; // Begin body of loop
    _a3_void_t _34;
    // Computing bound for x
    int64_t _35 = 87;
    _34.d0 = _35;
    if (_35 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for y
    _34.d1 = g;
    if (g > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for z
    _34.d2 = p.d0;
    if (p.d0 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _35;
    _36 *= g;
    _36 *= p.d0;
    _36 *= sizeof(void_t);
    _34.data = jpl_alloc(_36);
    int64_t _37 = 0; // z
    int64_t _38 = 0; // y
    int64_t _39 = 0; // x
    _jump1113:; // Begin body of loop
    int64_t _40 = 0;
    _40 *= _34.d0;
    _40 += _39;
    _40 *= _34.d1;
    _40 += _38;
    _40 *= _34.d2;
    _40 += _37;
    _34.data[_40] = s;
    _37++;
    if (_37 < p.d0)
    goto _jump1113;
    _37 = 0;
    _38++;
    if (_38 < g)
    goto _jump1113;
    _38 = 0;
    _39++;
    if (_39 < _35)
    goto _jump1113;
    // End body of loop
    int64_t _41 = 0;
    _41 *= _30.d0;
    _41 += _33;
    _30.data[_41] = _34;
    _33++;
    if (_33 < _31)
    goto _jump1109;
    // End body of loop
    if (n >= 0)
    goto _jump1114;
    fail_assertion("negative array index");
    _jump1114:;
    if (n < _30.d0)
    goto _jump1115;
    fail_assertion("index too large");
    _jump1115:;
    int64_t _42 = 0;
    _42 *= _30.d0;
    _42 += n;
    _a3_void_t _43 = _30.data[_42];
    int64_t _44;
    // Computing bound for w
    if (i > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for x
    int64_t _45 = l();
    int64_t _46 = -_45;
    int64_t _47 = n / _46;
    if (_47 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for y
    int64_t _48 = n % p.d0;
    if (_48 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    _44 = 0;
    int64_t _49 = 0; // y
    int64_t _50 = 0; // x
    int64_t _51 = 0; // w
    _jump1119:; // Begin body of loop
    int64_t _52;
    // Computing bound for z
    if (e > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing bound for A
    int64_t _53;
    // Computing bound for z
    if (p.d0 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing bound for A
    if (_49 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    _53 = 0;
    int64_t _54 = 0; // A
    int64_t _55 = 0; // z
    _jump1123:; // Begin body of loop
    _53 += _54;
    _54++;
    if (_54 < _49)
    goto _jump1123;
    _54 = 0;
    _55++;
    if (_55 < p.d0)
    goto _jump1123;
    // End body of loop
    if (_53 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    _52 = 0;
    int64_t _56 = 0; // A
    int64_t _57 = 0; // z
    _jump1125:; // Begin body of loop
    _52 += _57;
    _56++;
    if (_56 < _53)
    goto _jump1125;
    _56 = 0;
    _57++;
    if (_57 < e)
    goto _jump1125;
    // End body of loop
    _44 += _52;
    _49++;
    if (_49 < _48)
    goto _jump1119;
    _49 = 0;
    _50++;
    if (_50 < _47)
    goto _jump1119;
    _50 = 0;
    _51++;
    if (_51 < i)
    goto _jump1119;
    // End body of loop
    int64_t _58 = 937;
    int64_t _59 = 370;
    int64_t _60 = _58 - _59;
    if (p.d0 >= 0)
    goto _jump1126;
    fail_assertion("negative array index");
    _jump1126:;
    if (p.d0 < _43.d0)
    goto _jump1127;
    fail_assertion("index too large");
    _jump1127:;
    if (_44 >= 0)
    goto _jump1128;
    fail_assertion("negative array index");
    _jump1128:;
    if (_44 < _43.d1)
    goto _jump1129;
    fail_assertion("index too large");
    _jump1129:;
    if (_60 >= 0)
    goto _jump1130;
    fail_assertion("negative array index");
    _jump1130:;
    if (_60 < _43.d2)
    goto _jump1131;
    fail_assertion("index too large");
    _jump1131:;
    int64_t _61 = 0;
    _61 *= _43.d0;
    _61 += p.d0;
    _61 *= _43.d1;
    _61 += _44;
    _61 *= _43.d2;
    _61 += _60;
    void_t _62 = _43.data[_61];
    b _63 = { _10, _29, _62 };
    double _64 = _63.b;
    _a2_b _65;
    // Computing bound for w
    _65.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing bound for x
    int64_t _66 = l();
    _65.d1 = _66;
    if (_66 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= p.d0;
    _67 *= _66;
    _67 *= sizeof(b);
    _65.data = jpl_alloc(_67);
    int64_t _68 = 0; // x
    int64_t _69 = 0; // w
    _jump1134:; // Begin body of loop
    double _70 = o(p, h.d1, s);
    double _71 = 84.0;
    double _72 = 41.0;
    double _73 = -_72;
    _a1_double _74;
    _74.d0 = 3;
    _74.data = jpl_alloc(sizeof(double) * 3);
    _74.data[0] = _70;
    _74.data[1] = _71;
    _74.data[2] = _73;
    b _75 = k(_74);
    int64_t _76 = 0;
    _76 *= _65.d0;
    _76 += _69;
    _76 *= _65.d1;
    _76 += _68;
    _65.data[_76] = _75;
    _68++;
    if (_68 < _66)
    goto _jump1134;
    _68 = 0;
    _69++;
    if (_69 < p.d0)
    goto _jump1134;
    // End body of loop
    int64_t _77 = l();
    int64_t _78 = 794;
    if (_77 >= 0)
    goto _jump1135;
    fail_assertion("negative array index");
    _jump1135:;
    if (_77 < _65.d0)
    goto _jump1136;
    fail_assertion("index too large");
    _jump1136:;
    if (_78 >= 0)
    goto _jump1137;
    fail_assertion("negative array index");
    _jump1137:;
    if (_78 < _65.d1)
    goto _jump1138;
    fail_assertion("index too large");
    _jump1138:;
    int64_t _79 = 0;
    _79 *= _65.d0;
    _79 += _77;
    _79 *= _65.d1;
    _79 += _78;
    b _80 = _65.data[_79];
    double _81 = _80.a;
    double _82 = _64 / _81;
    return _82;
    bool _83 = false;
    if (0 != _83)
    goto _jump1139;
    fail_assertion("w");
    _jump1139:;
    int64_t _84 = 389;
    _a1_int64_t _85;
    // Computing bound for z
    int64_t _86 = l();
    _85.d0 = _86;
    if (_86 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= _86;
    _87 *= sizeof(int64_t);
    _85.data = jpl_alloc(_87);
    int64_t _88 = 0; // z
    _jump1141:; // Begin body of loop
    int64_t _89 = 0;
    _89 *= _85.d0;
    _89 += _88;
    _85.data[_89] = r;
    _88++;
    if (_88 < _86)
    goto _jump1141;
    // End body of loop
    _a3__a1_rgba _90;
    // Computing bound for B
    _90.d0 = j;
    if (j > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    // Computing bound for C
    _90.d1 = i;
    if (i > 0) 
    goto _jump1143;
    fail_assertion("non-positive loop bound");
    _jump1143:;
    // Computing bound for D
    _90.d2 = h.d0;
    if (h.d0 > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= j;
    _91 *= i;
    _91 *= h.d0;
    _91 *= sizeof(_a1_rgba);
    _90.data = jpl_alloc(_91);
    int64_t _92 = 0; // D
    int64_t _93 = 0; // C
    int64_t _94 = 0; // B
    _jump1145:; // Begin body of loop
    _a1_rgba _95;
    // Computing bound for E
    _95.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= p.d0;
    _96 *= sizeof(rgba);
    _95.data = jpl_alloc(_96);
    int64_t _97 = 0; // E
    _jump1147:; // Begin body of loop
    double _98 = 46.0;
    double _99 = -_98;
    double _100 = 25.0;
    double _101 = 18.0;
    double _102 = 22.0;
    b _103 = { _101, _102, s };
    double _104 = _103.a;
    double _105 = o(p, _84, s);
    rgba _106 = { _99, _100, _104, _105 };
    int64_t _107 = 0;
    _107 *= _95.d0;
    _107 += _97;
    _95.data[_107] = _106;
    _97++;
    if (_97 < p.d0)
    goto _jump1147;
    // End body of loop
    int64_t _108 = 0;
    _108 *= _90.d0;
    _108 += _94;
    _108 *= _90.d1;
    _108 += _93;
    _108 *= _90.d2;
    _108 += _92;
    _90.data[_108] = _95;
    _92++;
    if (_92 < h.d0)
    goto _jump1145;
    _92 = 0;
    _93++;
    if (_93 < i)
    goto _jump1145;
    _93 = 0;
    _94++;
    if (_94 < j)
    goto _jump1145;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (h.d0 < _90.d0)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    if (_84 >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (_84 < _90.d1)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    if (r >= 0)
    goto _jump1152;
    fail_assertion("negative array index");
    _jump1152:;
    if (r < _90.d2)
    goto _jump1153;
    fail_assertion("index too large");
    _jump1153:;
    int64_t _109 = 0;
    _109 *= _90.d0;
    _109 += h.d0;
    _109 *= _90.d1;
    _109 += _84;
    _109 *= _90.d2;
    _109 += r;
    _a1_rgba _110 = _90.data[_109];
    double _111 = o(_110, e, s);
    return _111;
}

double q() {
    double _0;
    // Computing bound for r
    if (g > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing bound for s
    int64_t _1 = -i;
    int64_t _2 = _1 - e;
    int64_t _3 = _2 / j;
    if (_3 > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    // Computing bound for t
    int64_t _4 = -g;
    if (_4 > 0) 
    goto _jump1157;
    fail_assertion("non-positive loop bound");
    _jump1157:;
    _0 = 0;
    int64_t _5 = 0; // t
    int64_t _6 = 0; // s
    int64_t _7 = 0; // r
    _jump1158:; // Begin body of loop
    double _8 = q();
    double _10 = q();
    double _11 = q();
    bool _12 = _10 == _11;
    bool _9 = _12;
    if (0 == _12)
    goto _jump1159;
    bool _13 = false;
    bool _14 = !_13;
    _9 = _14;
    _jump1159:;
    double _15;
    if (!_9)
    goto _jump1160;
    double _16 = 97.0;
    double _17 = 60.0;
    double _18 = fmod(_16, _17);
    _15 = _18;
    goto _jump1161;
    _jump1160:;
    double _19 = 53.0;
    double _20 = -_19;
    _15 = _20;
    _jump1161:;
    double _21;
    // Computing bound for u
    if (e > 0) 
    goto _jump1162;
    fail_assertion("non-positive loop bound");
    _jump1162:;
    _21 = 0;
    int64_t _22 = 0; // u
    _jump1163:; // Begin body of loop
    if (i >= 0)
    goto _jump1164;
    fail_assertion("negative array index");
    _jump1164:;
    if (i < a.d0)
    goto _jump1165;
    fail_assertion("index too large");
    _jump1165:;
    int64_t _23 = 0;
    _23 *= a.d0;
    _23 += i;
    bool _24 = a.data[_23];
    double _25;
    if (!_24)
    goto _jump1166;
    if (g >= 0)
    goto _jump1167;
    fail_assertion("negative array index");
    _jump1167:;
    if (g < d.d0)
    goto _jump1168;
    fail_assertion("index too large");
    _jump1168:;
    if (e >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (e < d.d1)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    if (_5 >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (_5 < d.d2)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    int64_t _26 = 0;
    _26 *= d.d0;
    _26 += g;
    _26 *= d.d1;
    _26 += e;
    _26 *= d.d2;
    _26 += _5;
    double _27 = d.data[_26];
    _25 = _27;
    goto _jump1173;
    _jump1166:;
    double _28 = 21.0;
    _25 = _28;
    _jump1173:;
    _21 += _25;
    _22++;
    if (_22 < e)
    goto _jump1163;
    // End body of loop
    double _29 = q();
    rgba _30 = { _8, _15, _21, _29 };
    double _31 = q();
    double _32 = -_31;
    double _33 = 39.0;
    double _34 = 18.0;
    double _35 = q();
    double _36 = 77.0;
    double _37 = q();
    double _38 = fmod(_36, _37);
    double _39 = -_38;
    double _40 = _35 / _39;
    rgba _41 = { _32, _33, _34, _40 };
    _a1_rgba _42;
    _42.d0 = 2;
    _42.data = jpl_alloc(sizeof(rgba) * 2);
    _42.data[0] = _30;
    _42.data[1] = _41;
    int64_t _43 = -_7;
    int64_t _44 = g + _43;
    int64_t _45 = g * _44;
    int64_t _46;
    // Computing bound for u
    if (_7 > 0) 
    goto _jump1174;
    fail_assertion("non-positive loop bound");
    _jump1174:;
    // Computing bound for v
    int64_t _47;
    // Computing bound for u
    int64_t _48 = l();
    int64_t _49 = _48 / _5;
    if (_49 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    _47 = 0;
    int64_t _50 = 0; // u
    _jump1176:; // Begin body of loop
    _47 += g;
    _50++;
    if (_50 < _49)
    goto _jump1176;
    // End body of loop
    if (_47 > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing bound for w
    if (_5 > 0) 
    goto _jump1178;
    fail_assertion("non-positive loop bound");
    _jump1178:;
    _46 = 0;
    int64_t _51 = 0; // w
    int64_t _52 = 0; // v
    int64_t _53 = 0; // u
    _jump1179:; // Begin body of loop
    _46 += _52;
    _51++;
    if (_51 < _5)
    goto _jump1179;
    _51 = 0;
    _52++;
    if (_52 < _47)
    goto _jump1179;
    _52 = 0;
    _53++;
    if (_53 < _7)
    goto _jump1179;
    // End body of loop
    int64_t _54 = _45 % _46;
    int64_t _55 = _7 / _54;
    if (_7 >= 0)
    goto _jump1180;
    fail_assertion("negative array index");
    _jump1180:;
    if (_7 < a.d0)
    goto _jump1181;
    fail_assertion("index too large");
    _jump1181:;
    int64_t _56 = 0;
    _56 *= a.d0;
    _56 += _7;
    bool _57 = a.data[_56];
    _a1_double _58;
    if (!_57)
    goto _jump1182;
    _a1_double _59;
    // Computing bound for u
    _59.d0 = g;
    if (g > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= g;
    _60 *= sizeof(double);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // u
    _jump1184:; // Begin body of loop
    double _62;
    // Computing bound for v
    if (_61 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing bound for w
    if (_7 > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    // Computing bound for x
    if (j > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    _62 = 0;
    int64_t _63 = 0; // x
    int64_t _64 = 0; // w
    int64_t _65 = 0; // v
    _jump1188:; // Begin body of loop
    double _66 = q();
    _62 += _66;
    _63++;
    if (_63 < j)
    goto _jump1188;
    _63 = 0;
    _64++;
    if (_64 < _7)
    goto _jump1188;
    _64 = 0;
    _65++;
    if (_65 < _61)
    goto _jump1188;
    // End body of loop
    int64_t _67 = 0;
    _67 *= _59.d0;
    _67 += _61;
    _59.data[_67] = _62;
    _61++;
    if (_61 < g)
    goto _jump1184;
    // End body of loop
    _58 = _59;
    goto _jump1189;
    _jump1182:;
    double _68 = q();
    _a1_double _69;
    _69.d0 = 1;
    _69.data = jpl_alloc(sizeof(double) * 1);
    _69.data[0] = _68;
    _58 = _69;
    _jump1189:;
    b _70 = k(_58);
    void_t _71 = _70.c;
    double _72 = o(_42, _55, _71);
    _0 += _72;
    _5++;
    if (_5 < _4)
    goto _jump1158;
    _5 = 0;
    _6++;
    if (_6 < _3)
    goto _jump1158;
    _6 = 0;
    _7++;
    if (_7 < g)
    goto _jump1158;
    // End body of loop
    return _0;
    _a1_double _73;
    // Computing bound for r
    double _74 = 4.0;
    double _75 = 98.0;
    double _76 = -_75;
    double _77 = 3.0;
    double _78 = q();
    double _79 = 52.0;
    double _80 = _78 * _79;
    rgba _81 = { _74, _76, _77, _80 };
    double _82 = _81.r;
    double _83 = 82.0;
    bool _84 = _82 < _83;
    int64_t _85;
    if (!_84)
    goto _jump1190;
    int64_t _86 = l();
    _85 = _86;
    goto _jump1191;
    _jump1190:;
    _85 = i;
    _jump1191:;
    _73.d0 = _85;
    if (_85 > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= _85;
    _87 *= sizeof(double);
    _73.data = jpl_alloc(_87);
    int64_t _88 = 0; // r
    _jump1193:; // Begin body of loop
    _a1_double _89;
    // Computing bound for s
    _89.d0 = g;
    if (g > 0) 
    goto _jump1194;
    fail_assertion("non-positive loop bound");
    _jump1194:;
    // Computing total size of heap memory to allocate
    int64_t _90 = 1;
    _90 *= g;
    _90 *= sizeof(double);
    _89.data = jpl_alloc(_90);
    int64_t _91 = 0; // s
    _jump1195:; // Begin body of loop
    double _92 = q();
    double _93 = -_92;
    int64_t _94 = 0;
    _94 *= _89.d0;
    _94 += _91;
    _89.data[_94] = _93;
    _91++;
    if (_91 < g)
    goto _jump1195;
    // End body of loop
    int64_t _95 = l();
    if (_95 >= 0)
    goto _jump1196;
    fail_assertion("negative array index");
    _jump1196:;
    if (_95 < _89.d0)
    goto _jump1197;
    fail_assertion("index too large");
    _jump1197:;
    int64_t _96 = 0;
    _96 *= _89.d0;
    _96 += _95;
    double _97 = _89.data[_96];
    double _98 = q();
    double _99 = -_98;
    double _100 = 42.0;
    double _101 = q();
    rgba _102 = { _97, _99, _100, _101 };
    double _103 = _102.a;
    int64_t _104 = 0;
    _104 *= _73.d0;
    _104 += _88;
    _73.data[_104] = _103;
    _88++;
    if (_88 < _85)
    goto _jump1193;
    // End body of loop
    b _105 = k(_73);
    double _107 = q();
    double _108 = -_107;
    double _109 = 60.0;
    bool _110 = _108 != _109;
    bool _111 = false;
    bool _112 = !_111;
    bool _113 = _110 != _112;
    bool _114;
    if (!_113)
    goto _jump1198;
    bool _115 = true;
    bool _116;
    if (!_115)
    goto _jump1199;
    bool _117 = false;
    bool _118 = !_117;
    _116 = _118;
    goto _jump1200;
    _jump1199:;
    int64_t _119 = l();
    bool _120 = n != _119;
    bool _121;
    if (!_120)
    goto _jump1201;
    bool _122 = false;
    _121 = _122;
    goto _jump1202;
    _jump1201:;
    bool _123 = i > j;
    _121 = _123;
    _jump1202:;
    _116 = _121;
    _jump1200:;
    _114 = _116;
    goto _jump1203;
    _jump1198:;
    bool _124 = true;
    bool _125 = !_124;
    _114 = _125;
    _jump1203:;
    bool _106 = _114;
    if (0 == _114)
    goto _jump1204;
    bool _126 = false;
    bool _127 = !_126;
    bool _128 = !_127;
    bool _129;
    if (!_128)
    goto _jump1205;
    double _131 = q();
    double _132 = q();
    bool _133 = _131 > _132;
    bool _130 = _133;
    if (0 == _133)
    goto _jump1206;
    int64_t _134 = l();
    bool _135 = _134 < n;
    _130 = _135;
    _jump1206:;
    _129 = _130;
    goto _jump1207;
    _jump1205:;
    int64_t _136 = l();
    if (_136 >= 0)
    goto _jump1208;
    fail_assertion("negative array index");
    _jump1208:;
    if (_136 < a.d0)
    goto _jump1209;
    fail_assertion("index too large");
    _jump1209:;
    int64_t _137 = 0;
    _137 *= a.d0;
    _137 += _136;
    bool _138 = a.data[_137];
    bool _139 = !_138;
    _129 = _139;
    _jump1207:;
    bool _140;
    if (!_129)
    goto _jump1210;
    int64_t _141 = 262;
    bool _142 = n <= _141;
    bool _143 = !_142;
    bool _144 = !_143;
    _140 = _144;
    goto _jump1211;
    _jump1210:;
    bool _147 = true;
    bool _146 = _147;
    if (0 != _147)
    goto _jump1212;
    bool _148 = true;
    _146 = _148;
    _jump1212:;
    bool _145 = _146;
    if (0 == _146)
    goto _jump1213;
    double _149 = q();
    double _150 = 31.0;
    bool _151 = _149 == _150;
    _145 = _151;
    _jump1213:;
    bool _152 = !_145;
    _140 = _152;
    _jump1211:;
    _106 = _140;
    _jump1204:;
    _a1_rgba _153;
    if (!_106)
    goto _jump1214;
    bool _154 = g > n;
    bool _155 = !_154;
    _a2_rgba _156;
    if (!_155)
    goto _jump1215;
    _a2_rgba _157;
    // Computing bound for t
    int64_t _158 = -n;
    _157.d0 = _158;
    if (_158 > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing bound for u
    _157.d1 = j;
    if (j > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _158;
    _159 *= j;
    _159 *= sizeof(rgba);
    _157.data = jpl_alloc(_159);
    int64_t _160 = 0; // u
    int64_t _161 = 0; // t
    _jump1218:; // Begin body of loop
    double _162 = q();
    double _163 = 48.0;
    double _164 = 32.0;
    double _165 = 83.0;
    rgba _166 = { _162, _163, _164, _165 };
    int64_t _167 = 0;
    _167 *= _157.d0;
    _167 += _161;
    _167 *= _157.d1;
    _167 += _160;
    _157.data[_167] = _166;
    _160++;
    if (_160 < j)
    goto _jump1218;
    _160 = 0;
    _161++;
    if (_161 < _158)
    goto _jump1218;
    // End body of loop
    _156 = _157;
    goto _jump1219;
    _jump1215:;
    _a2_rgba _168;
    // Computing bound for t
    _168.d0 = g;
    if (g > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing bound for u
    _168.d1 = f;
    if (f > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= g;
    _169 *= f;
    _169 *= sizeof(rgba);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // u
    int64_t _171 = 0; // t
    _jump1222:; // Begin body of loop
    double _172 = 34.0;
    double _173 = q();
    double _174 = q();
    double _175 = 52.0;
    rgba _176 = { _172, _173, _174, _175 };
    int64_t _177 = 0;
    _177 *= _168.d0;
    _177 += _171;
    _177 *= _168.d1;
    _177 += _170;
    _168.data[_177] = _176;
    _170++;
    if (_170 < f)
    goto _jump1222;
    _170 = 0;
    _171++;
    if (_171 < g)
    goto _jump1222;
    // End body of loop
    _156 = _168;
    _jump1219:;
    int64_t _178 = 180;
    int64_t _179 = -_178;
    if (i >= 0)
    goto _jump1223;
    fail_assertion("negative array index");
    _jump1223:;
    if (i < _156.d0)
    goto _jump1224;
    fail_assertion("index too large");
    _jump1224:;
    if (_179 >= 0)
    goto _jump1225;
    fail_assertion("negative array index");
    _jump1225:;
    if (_179 < _156.d1)
    goto _jump1226;
    fail_assertion("index too large");
    _jump1226:;
    int64_t _180 = 0;
    _180 *= _156.d0;
    _180 += i;
    _180 *= _156.d1;
    _180 += _179;
    rgba _181 = _156.data[_180];
    double _182 = 45.0;
    double _183 = _105.b;
    bool _184 = _182 != _183;
    double _185;
    if (!_184)
    goto _jump1227;
    double _186;
    // Computing bound for t
    if (n > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    // Computing bound for u
    if (j > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    _186 = 0;
    int64_t _187 = 0; // u
    int64_t _188 = 0; // t
    _jump1230:; // Begin body of loop
    double _189 = 56.0;
    _186 += _189;
    _187++;
    if (_187 < j)
    goto _jump1230;
    _187 = 0;
    _188++;
    if (_188 < n)
    goto _jump1230;
    // End body of loop
    _185 = _186;
    goto _jump1231;
    _jump1227:;
    bool _190 = false;
    b _191;
    if (!_190)
    goto _jump1232;
    _191 = _105;
    goto _jump1233;
    _jump1232:;
    _191 = _105;
    _jump1233:;
    double _192 = _191.b;
    _185 = _192;
    _jump1231:;
    double _193 = 98.0;
    bool _194 = true;
    double _195;
    if (!_194)
    goto _jump1234;
    double _196 = 71.0;
    _195 = _196;
    goto _jump1235;
    _jump1234:;
    double _197 = 86.0;
    _195 = _197;
    _jump1235:;
    double _198 = _193 / _195;
    double _199 = q();
    _a3_double _200;
    // Computing bound for t
    bool _201 = false;
    int64_t _202;
    if (!_201)
    goto _jump1236;
    _202 = n;
    goto _jump1237;
    _jump1236:;
    _202 = f;
    _jump1237:;
    _200.d0 = _202;
    if (_202 > 0) 
    goto _jump1238;
    fail_assertion("non-positive loop bound");
    _jump1238:;
    // Computing bound for u
    int64_t _203 = -j;
    _200.d1 = _203;
    if (_203 > 0) 
    goto _jump1239;
    fail_assertion("non-positive loop bound");
    _jump1239:;
    // Computing bound for v
    int64_t _204 = -f;
    _200.d2 = _204;
    if (_204 > 0) 
    goto _jump1240;
    fail_assertion("non-positive loop bound");
    _jump1240:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _202;
    _205 *= _203;
    _205 *= _204;
    _205 *= sizeof(double);
    _200.data = jpl_alloc(_205);
    int64_t _206 = 0; // v
    int64_t _207 = 0; // u
    int64_t _208 = 0; // t
    _jump1241:; // Begin body of loop
    bool _209 = true;
    double _210;
    if (!_209)
    goto _jump1242;
    double _211 = q();
    _210 = _211;
    goto _jump1243;
    _jump1242:;
    double _212 = 73.0;
    _210 = _212;
    _jump1243:;
    int64_t _213 = 0;
    _213 *= _200.d0;
    _213 += _208;
    _213 *= _200.d1;
    _213 += _207;
    _213 *= _200.d2;
    _213 += _206;
    _200.data[_213] = _210;
    _206++;
    if (_206 < _204)
    goto _jump1241;
    _206 = 0;
    _207++;
    if (_207 < _203)
    goto _jump1241;
    _207 = 0;
    _208++;
    if (_208 < _202)
    goto _jump1241;
    // End body of loop
    int64_t _214 = 651;
    if (i >= 0)
    goto _jump1244;
    fail_assertion("negative array index");
    _jump1244:;
    if (i < _200.d0)
    goto _jump1245;
    fail_assertion("index too large");
    _jump1245:;
    if (_214 >= 0)
    goto _jump1246;
    fail_assertion("negative array index");
    _jump1246:;
    if (_214 < _200.d1)
    goto _jump1247;
    fail_assertion("index too large");
    _jump1247:;
    if (e >= 0)
    goto _jump1248;
    fail_assertion("negative array index");
    _jump1248:;
    if (e < _200.d2)
    goto _jump1249;
    fail_assertion("index too large");
    _jump1249:;
    int64_t _215 = 0;
    _215 *= _200.d0;
    _215 += i;
    _215 *= _200.d1;
    _215 += _214;
    _215 *= _200.d2;
    _215 += e;
    double _216 = _200.data[_215];
    rgba _217 = { _185, _198, _199, _216 };
    _a1_rgba _218;
    _218.d0 = 2;
    _218.data = jpl_alloc(sizeof(rgba) * 2);
    _218.data[0] = _181;
    _218.data[1] = _217;
    _153 = _218;
    goto _jump1250;
    _jump1214:;
    bool _219 = true;
    bool _220 = !_219;
    bool _221 = !_220;
    _a1_rgba _222;
    if (!_221)
    goto _jump1251;
    _a1_rgba _223;
    // Computing bound for t
    _223.d0 = j;
    if (j > 0) 
    goto _jump1252;
    fail_assertion("non-positive loop bound");
    _jump1252:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= j;
    _224 *= sizeof(rgba);
    _223.data = jpl_alloc(_224);
    int64_t _225 = 0; // t
    _jump1253:; // Begin body of loop
    double _226;
    // Computing bound for u
    if (e > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    _226 = 0;
    int64_t _227 = 0; // u
    _jump1255:; // Begin body of loop
    double _228 = q();
    _226 += _228;
    _227++;
    if (_227 < e)
    goto _jump1255;
    // End body of loop
    bool _229 = n != g;
    double _230;
    if (!_229)
    goto _jump1256;
    double _231 = q();
    _230 = _231;
    goto _jump1257;
    _jump1256:;
    double _232 = 38.0;
    double _233 = -_232;
    _230 = _233;
    _jump1257:;
    double _234 = 69.0;
    double _235 = -_234;
    double _236 = q();
    rgba _237 = { _226, _230, _235, _236 };
    int64_t _238 = 0;
    _238 *= _223.d0;
    _238 += _225;
    _223.data[_238] = _237;
    _225++;
    if (_225 < j)
    goto _jump1253;
    // End body of loop
    _222 = _223;
    goto _jump1258;
    _jump1251:;
    _a1_rgba _239;
    // Computing bound for t
    _239.d0 = g;
    if (g > 0) 
    goto _jump1259;
    fail_assertion("non-positive loop bound");
    _jump1259:;
    // Computing total size of heap memory to allocate
    int64_t _240 = 1;
    _240 *= g;
    _240 *= sizeof(rgba);
    _239.data = jpl_alloc(_240);
    int64_t _241 = 0; // t
    _jump1260:; // Begin body of loop
    double _242 = q();
    _a1_double _243;
    _243.d0 = 1;
    _243.data = jpl_alloc(sizeof(double) * 1);
    _243.data[0] = _242;
    b _244 = k(_243);
    _a3_void_t _245;
    // Computing bound for u
    int64_t _246 = l();
    _245.d0 = _246;
    if (_246 > 0) 
    goto _jump1261;
    fail_assertion("non-positive loop bound");
    _jump1261:;
    // Computing bound for v
    _245.d1 = n;
    if (n > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    // Computing bound for w
    int64_t _247;
    // Computing bound for u
    int64_t _248 = l();
    if (_248 > 0) 
    goto _jump1263;
    fail_assertion("non-positive loop bound");
    _jump1263:;
    // Computing bound for v
    int64_t _249 = 416;
    if (_249 > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing bound for w
    if (n > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    _247 = 0;
    int64_t _250 = 0; // w
    int64_t _251 = 0; // v
    int64_t _252 = 0; // u
    _jump1266:; // Begin body of loop
    _247 += _252;
    _250++;
    if (_250 < n)
    goto _jump1266;
    _250 = 0;
    _251++;
    if (_251 < _249)
    goto _jump1266;
    _251 = 0;
    _252++;
    if (_252 < _248)
    goto _jump1266;
    // End body of loop
    _245.d2 = _247;
    if (_247 > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    // Computing total size of heap memory to allocate
    int64_t _253 = 1;
    _253 *= _246;
    _253 *= n;
    _253 *= _247;
    _253 *= sizeof(void_t);
    _245.data = jpl_alloc(_253);
    int64_t _254 = 0; // w
    int64_t _255 = 0; // v
    int64_t _256 = 0; // u
    _jump1268:; // Begin body of loop
    void_t _257 = _105.c;
    int64_t _258 = 0;
    _258 *= _245.d0;
    _258 += _256;
    _258 *= _245.d1;
    _258 += _255;
    _258 *= _245.d2;
    _258 += _254;
    _245.data[_258] = _257;
    _254++;
    if (_254 < _247)
    goto _jump1268;
    _254 = 0;
    _255++;
    if (_255 < n)
    goto _jump1268;
    _255 = 0;
    _256++;
    if (_256 < _246)
    goto _jump1268;
    // End body of loop
    double _259 = 70.0;
    rgba _260 = c(_244, _245, _259);
    int64_t _261 = 0;
    _261 *= _239.d0;
    _261 += _241;
    _239.data[_261] = _260;
    _241++;
    if (_241 < g)
    goto _jump1260;
    // End body of loop
    _222 = _239;
    _jump1258:;
    _153 = _222;
    _jump1250:;
    int64_t _262 = n - f;
    _a1_int64_t _263;
    _263.d0 = 3;
    _263.data = jpl_alloc(sizeof(int64_t) * 3);
    _263.data[0] = i;
    _263.data[1] = i;
    _263.data[2] = g;
    int64_t _264 = 825;
    if (_264 >= 0)
    goto _jump1269;
    fail_assertion("negative array index");
    _jump1269:;
    if (_264 < _263.d0)
    goto _jump1270;
    fail_assertion("index too large");
    _jump1270:;
    int64_t _265 = 0;
    _265 *= _263.d0;
    _265 += _264;
    int64_t _266 = _263.data[_265];
    int64_t _267 = -_266;
    bool _268 = _262 < _267;
    bool _269 = false;
    bool _270 = _268 != _269;
    void_t _271;
    if (!_270)
    goto _jump1271;
    double _272;
    // Computing bound for t
    if (f > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    _272 = 0;
    int64_t _273 = 0; // t
    _jump1273:; // Begin body of loop
    double _274 = 4.0;
    double _275 = -_274;
    _272 += _275;
    _273++;
    if (_273 < f)
    goto _jump1273;
    // End body of loop
    double _276 = 68.0;
    _a1_double _277;
    _277.d0 = 2;
    _277.data = jpl_alloc(sizeof(double) * 2);
    _277.data[0] = _272;
    _277.data[1] = _276;
    b _278 = k(_277);
    void_t _279 = _278.c;
    _271 = _279;
    goto _jump1274;
    _jump1271:;
    double _280;
    // Computing bound for t
    int64_t _281 = l();
    if (_281 > 0) 
    goto _jump1275;
    fail_assertion("non-positive loop bound");
    _jump1275:;
    // Computing bound for u
    if (e > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    _280 = 0;
    int64_t _282 = 0; // u
    int64_t _283 = 0; // t
    _jump1277:; // Begin body of loop
    double _284 = 44.0;
    _280 += _284;
    _282++;
    if (_282 < e)
    goto _jump1277;
    _282 = 0;
    _283++;
    if (_283 < _281)
    goto _jump1277;
    // End body of loop
    double _285;
    // Computing bound for t
    if (i > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing bound for u
    if (n > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    _285 = 0;
    int64_t _286 = 0; // u
    int64_t _287 = 0; // t
    _jump1280:; // Begin body of loop
    double _288 = q();
    _285 += _288;
    _286++;
    if (_286 < n)
    goto _jump1280;
    _286 = 0;
    _287++;
    if (_287 < i)
    goto _jump1280;
    // End body of loop
    double _289 = _280 * _285;
    _a1_double _290;
    // Computing bound for t
    _290.d0 = i;
    if (i > 0) 
    goto _jump1281;
    fail_assertion("non-positive loop bound");
    _jump1281:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= i;
    _291 *= sizeof(double);
    _290.data = jpl_alloc(_291);
    int64_t _292 = 0; // t
    _jump1282:; // Begin body of loop
    double _293 = q();
    int64_t _294 = 0;
    _294 *= _290.d0;
    _294 += _292;
    _290.data[_294] = _293;
    _292++;
    if (_292 < i)
    goto _jump1282;
    // End body of loop
    if (j >= 0)
    goto _jump1283;
    fail_assertion("negative array index");
    _jump1283:;
    if (j < _290.d0)
    goto _jump1284;
    fail_assertion("index too large");
    _jump1284:;
    int64_t _295 = 0;
    _295 *= _290.d0;
    _295 += j;
    double _296 = _290.data[_295];
    bool _297 = _289 == _296;
    b _298;
    if (!_297)
    goto _jump1285;
    bool _299 = false;
    bool _300 = !_299;
    double _301;
    if (!_300)
    goto _jump1286;
    double _302 = 31.0;
    double _303 = 29.0;
    double _304 = _302 + _303;
    _301 = _304;
    goto _jump1287;
    _jump1286:;
    double _305 = q();
    double _306 = 21.0;
    double _307 = _305 - _306;
    _301 = _307;
    _jump1287:;
    double _308 = _105.b;
    bool _309 = n < n;
    void_t _310;
    if (!_309)
    goto _jump1288;
    void_t _311 = _105.c;
    _310 = _311;
    goto _jump1289;
    _jump1288:;
    void_t _312 = _105.c;
    _310 = _312;
    _jump1289:;
    b _313 = { _301, _308, _310 };
    _298 = _313;
    goto _jump1290;
    _jump1285:;
    _a1_double _314;
    // Computing bound for t
    _314.d0 = g;
    if (g > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    // Computing total size of heap memory to allocate
    int64_t _315 = 1;
    _315 *= g;
    _315 *= sizeof(double);
    _314.data = jpl_alloc(_315);
    int64_t _316 = 0; // t
    _jump1292:; // Begin body of loop
    double _317 = q();
    int64_t _318 = 0;
    _318 *= _314.d0;
    _318 += _316;
    _314.data[_318] = _317;
    _316++;
    if (_316 < g)
    goto _jump1292;
    // End body of loop
    b _319 = k(_314);
    _298 = _319;
    _jump1290:;
    void_t _320 = _298.c;
    _271 = _320;
    _jump1274:;
    double _321 = o(_153, g, _271);
    return _321;
    double _322 = 91.0;
    _a1_double _323;
    // Computing bound for u
    _323.d0 = e;
    if (e > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing total size of heap memory to allocate
    int64_t _324 = 1;
    _324 *= e;
    _324 *= sizeof(double);
    _323.data = jpl_alloc(_324);
    int64_t _325 = 0; // u
    _jump1294:; // Begin body of loop
    _a1_b _326;
    // Computing bound for v
    _326.d0 = n;
    if (n > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing total size of heap memory to allocate
    int64_t _327 = 1;
    _327 *= n;
    _327 *= sizeof(b);
    _326.data = jpl_alloc(_327);
    int64_t _328 = 0; // v
    _jump1296:; // Begin body of loop
    int64_t _329 = 0;
    _329 *= _326.d0;
    _329 += _328;
    _326.data[_329] = _105;
    _328++;
    if (_328 < n)
    goto _jump1296;
    // End body of loop
    if (g >= 0)
    goto _jump1297;
    fail_assertion("negative array index");
    _jump1297:;
    if (g < _326.d0)
    goto _jump1298;
    fail_assertion("index too large");
    _jump1298:;
    int64_t _330 = 0;
    _330 *= _326.d0;
    _330 += g;
    b _331 = _326.data[_330];
    double _332 = _331.b;
    double _333 = _105.a;
    double _334 = _332 / _333;
    int64_t _335 = 0;
    _335 *= _323.d0;
    _335 += _325;
    _323.data[_335] = _334;
    _325++;
    if (_325 < e)
    goto _jump1294;
    // End body of loop
    b _336 = k(_323);
    double _337 = _336.a;
    return _337;
    double _338 = 9.0;
    return _338;
}

bool z(int64_t A, _a3_b B, void_t F) {
    bool _0 = true;
    bool _2 = false;
    double _3 = 50.0;
    _a1_double _4;
    _4.d0 = 1;
    _4.data = jpl_alloc(sizeof(double) * 1);
    _4.data[0] = _3;
    if (n >= 0)
    goto _jump1323;
    fail_assertion("negative array index");
    _jump1323:;
    if (n < _4.d0)
    goto _jump1324;
    fail_assertion("index too large");
    _jump1324:;
    int64_t _5 = 0;
    _5 *= _4.d0;
    _5 += n;
    double _6 = _4.data[_5];
    double _7 = 4.0;
    bool _8 = _6 <= _7;
    bool _9 = _2 == _8;
    bool _1 = _9;
    if (0 == _9)
    goto _jump1325;
    int64_t _10 = 372;
    if (_10 >= 0)
    goto _jump1326;
    fail_assertion("negative array index");
    _jump1326:;
    if (_10 < a.d0)
    goto _jump1327;
    fail_assertion("index too large");
    _jump1327:;
    int64_t _11 = 0;
    _11 *= a.d0;
    _11 += _10;
    bool _12 = a.data[_11];
    _a3_bool _13;
    if (!_12)
    goto _jump1328;
    _a3_bool _14;
    // Computing bound for G
    _14.d0 = s;
    if (s > 0) 
    goto _jump1329;
    fail_assertion("non-positive loop bound");
    _jump1329:;
    // Computing bound for H
    _14.d1 = x;
    if (x > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    // Computing bound for I
    _14.d2 = t;
    if (t > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= s;
    _15 *= x;
    _15 *= t;
    _15 *= sizeof(bool);
    _14.data = jpl_alloc(_15);
    int64_t _16 = 0; // I
    int64_t _17 = 0; // H
    int64_t _18 = 0; // G
    _jump1332:; // Begin body of loop
    bool _19 = false;
    int64_t _20 = 0;
    _20 *= _14.d0;
    _20 += _18;
    _20 *= _14.d1;
    _20 += _17;
    _20 *= _14.d2;
    _20 += _16;
    _14.data[_20] = _19;
    _16++;
    if (_16 < t)
    goto _jump1332;
    _16 = 0;
    _17++;
    if (_17 < x)
    goto _jump1332;
    _17 = 0;
    _18++;
    if (_18 < s)
    goto _jump1332;
    // End body of loop
    _13 = _14;
    goto _jump1333;
    _jump1328:;
    _a3__a3_bool _21;
    // Computing bound for G
    _21.d0 = u;
    if (u > 0) 
    goto _jump1334;
    fail_assertion("non-positive loop bound");
    _jump1334:;
    // Computing bound for H
    _21.d1 = e;
    if (e > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    // Computing bound for I
    _21.d2 = e;
    if (e > 0) 
    goto _jump1336;
    fail_assertion("non-positive loop bound");
    _jump1336:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= u;
    _22 *= e;
    _22 *= e;
    _22 *= sizeof(_a3_bool);
    _21.data = jpl_alloc(_22);
    int64_t _23 = 0; // I
    int64_t _24 = 0; // H
    int64_t _25 = 0; // G
    _jump1337:; // Begin body of loop
    _a3_bool _26;
    // Computing bound for J
    _26.d0 = s;
    if (s > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing bound for K
    _26.d1 = j;
    if (j > 0) 
    goto _jump1339;
    fail_assertion("non-positive loop bound");
    _jump1339:;
    // Computing bound for L
    _26.d2 = x;
    if (x > 0) 
    goto _jump1340;
    fail_assertion("non-positive loop bound");
    _jump1340:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= s;
    _27 *= j;
    _27 *= x;
    _27 *= sizeof(bool);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // L
    int64_t _29 = 0; // K
    int64_t _30 = 0; // J
    _jump1341:; // Begin body of loop
    bool _31 = true;
    int64_t _32 = 0;
    _32 *= _26.d0;
    _32 += _30;
    _32 *= _26.d1;
    _32 += _29;
    _32 *= _26.d2;
    _32 += _28;
    _26.data[_32] = _31;
    _28++;
    if (_28 < x)
    goto _jump1341;
    _28 = 0;
    _29++;
    if (_29 < j)
    goto _jump1341;
    _29 = 0;
    _30++;
    if (_30 < s)
    goto _jump1341;
    // End body of loop
    int64_t _33 = 0;
    _33 *= _21.d0;
    _33 += _25;
    _33 *= _21.d1;
    _33 += _24;
    _33 *= _21.d2;
    _33 += _23;
    _21.data[_33] = _26;
    _23++;
    if (_23 < e)
    goto _jump1337;
    _23 = 0;
    _24++;
    if (_24 < e)
    goto _jump1337;
    _24 = 0;
    _25++;
    if (_25 < u)
    goto _jump1337;
    // End body of loop
    int64_t _34 = B.d2 * B.d1;
    if (_34 >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (_34 < _21.d0)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    if (e >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (e < _21.d1)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    if (B.d0 >= 0)
    goto _jump1346;
    fail_assertion("negative array index");
    _jump1346:;
    if (B.d0 < _21.d2)
    goto _jump1347;
    fail_assertion("index too large");
    _jump1347:;
    int64_t _35 = 0;
    _35 *= _21.d0;
    _35 += _34;
    _35 *= _21.d1;
    _35 += e;
    _35 *= _21.d2;
    _35 += B.d0;
    _a3_bool _36 = _21.data[_35];
    _13 = _36;
    _jump1333:;
    _a1_int64_t _37;
    _37.d0 = 1;
    _37.data = jpl_alloc(sizeof(int64_t) * 1);
    _37.data[0] = u;
    int64_t _38;
    // Computing bound for G
    if (w > 0) 
    goto _jump1348;
    fail_assertion("non-positive loop bound");
    _jump1348:;
    _38 = 0;
    int64_t _39 = 0; // G
    _jump1349:; // Begin body of loop
    _38 += B.d1;
    _39++;
    if (_39 < w)
    goto _jump1349;
    // End body of loop
    if (_38 >= 0)
    goto _jump1350;
    fail_assertion("negative array index");
    _jump1350:;
    if (_38 < _37.d0)
    goto _jump1351;
    fail_assertion("index too large");
    _jump1351:;
    int64_t _40 = 0;
    _40 *= _37.d0;
    _40 += _38;
    int64_t _41 = _37.data[_40];
    bool _42 = _41 < s;
    int64_t _43;
    if (!_42)
    goto _jump1352;
    _43 = B.d0;
    goto _jump1353;
    _jump1352:;
    _43 = x;
    _jump1353:;
    if (u >= 0)
    goto _jump1354;
    fail_assertion("negative array index");
    _jump1354:;
    if (u < _13.d0)
    goto _jump1355;
    fail_assertion("index too large");
    _jump1355:;
    if (B.d1 >= 0)
    goto _jump1356;
    fail_assertion("negative array index");
    _jump1356:;
    if (B.d1 < _13.d1)
    goto _jump1357;
    fail_assertion("index too large");
    _jump1357:;
    if (_43 >= 0)
    goto _jump1358;
    fail_assertion("negative array index");
    _jump1358:;
    if (_43 < _13.d2)
    goto _jump1359;
    fail_assertion("index too large");
    _jump1359:;
    int64_t _44 = 0;
    _44 *= _13.d0;
    _44 += u;
    _44 *= _13.d1;
    _44 += B.d1;
    _44 *= _13.d2;
    _44 += _43;
    bool _45 = _13.data[_44];
    _1 = _45;
    _jump1325:;
    bool _46 = _0 != _1;
    if (0 != _46)
    goto _jump1360;
    fail_assertion("G");
    _jump1360:;
    _a1__a3_double _47;
    // Computing bound for G
    _47.d0 = e;
    if (e > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= e;
    _48 *= sizeof(_a3_double);
    _47.data = jpl_alloc(_48);
    int64_t _49 = 0; // G
    _jump1362:; // Begin body of loop
    int64_t _50 = 0;
    _50 *= _47.d0;
    _50 += _49;
    _47.data[_50] = r;
    _49++;
    if (_49 < e)
    goto _jump1362;
    // End body of loop
    int64_t _51 = A * f;
    bool _52 = _51 != _47.d0;
    if (0 != _52)
    goto _jump1363;
    fail_assertion("I");
    _jump1363:;
    bool _53 = true;
    _a3_bool _54;
    if (!_53)
    goto _jump1364;
    _a3_bool _55;
    // Computing bound for R
    _55.d0 = B.d1;
    if (B.d1 > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing bound for S
    _55.d1 = B.d0;
    if (B.d0 > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    // Computing bound for T
    int64_t _56 = 335;
    _55.d2 = _56;
    if (_56 > 0) 
    goto _jump1367;
    fail_assertion("non-positive loop bound");
    _jump1367:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= B.d1;
    _57 *= B.d0;
    _57 *= _56;
    _57 *= sizeof(bool);
    _55.data = jpl_alloc(_57);
    int64_t _58 = 0; // T
    int64_t _59 = 0; // S
    int64_t _60 = 0; // R
    _jump1368:; // Begin body of loop
    double _61 = 1.0;
    double _62 = -_61;
    double _63 = -_62;
    if (j >= 0)
    goto _jump1369;
    fail_assertion("negative array index");
    _jump1369:;
    if (j < B.d0)
    goto _jump1370;
    fail_assertion("index too large");
    _jump1370:;
    if (n >= 0)
    goto _jump1371;
    fail_assertion("negative array index");
    _jump1371:;
    if (n < B.d1)
    goto _jump1372;
    fail_assertion("index too large");
    _jump1372:;
    if (w >= 0)
    goto _jump1373;
    fail_assertion("negative array index");
    _jump1373:;
    if (w < B.d2)
    goto _jump1374;
    fail_assertion("index too large");
    _jump1374:;
    int64_t _64 = 0;
    _64 *= B.d0;
    _64 += j;
    _64 *= B.d1;
    _64 += n;
    _64 *= B.d2;
    _64 += w;
    b _65 = B.data[_64];
    double _66 = _65.b;
    bool _67 = _63 == _66;
    bool _68 = !_67;
    int64_t _69 = 0;
    _69 *= _55.d0;
    _69 += _60;
    _69 *= _55.d1;
    _69 += _59;
    _69 *= _55.d2;
    _69 += _58;
    _55.data[_69] = _68;
    _58++;
    if (_58 < _56)
    goto _jump1368;
    _58 = 0;
    _59++;
    if (_59 < B.d0)
    goto _jump1368;
    _59 = 0;
    _60++;
    if (_60 < B.d1)
    goto _jump1368;
    // End body of loop
    _54 = _55;
    goto _jump1375;
    _jump1364:;
    _a3_bool _70;
    // Computing bound for R
    _70.d0 = B.d2;
    if (B.d2 > 0) 
    goto _jump1376;
    fail_assertion("non-positive loop bound");
    _jump1376:;
    // Computing bound for S
    _70.d1 = r.d2;
    if (r.d2 > 0) 
    goto _jump1377;
    fail_assertion("non-positive loop bound");
    _jump1377:;
    // Computing bound for T
    int64_t _71 = 583;
    bool _72 = _71 == j;
    _a1_int64_t _73;
    if (!_72)
    goto _jump1378;
    int64_t _74 = 993;
    _a1_int64_t _75;
    _75.d0 = 1;
    _75.data = jpl_alloc(sizeof(int64_t) * 1);
    _75.data[0] = _74;
    _73 = _75;
    goto _jump1379;
    _jump1378:;
    _a1_int64_t _76;
    _76.d0 = 1;
    _76.data = jpl_alloc(sizeof(int64_t) * 1);
    _76.data[0] = u;
    _73 = _76;
    _jump1379:;
    if (B.d2 >= 0)
    goto _jump1380;
    fail_assertion("negative array index");
    _jump1380:;
    if (B.d2 < _73.d0)
    goto _jump1381;
    fail_assertion("index too large");
    _jump1381:;
    int64_t _77 = 0;
    _77 *= _73.d0;
    _77 += B.d2;
    int64_t _78 = _73.data[_77];
    _70.d2 = _78;
    if (_78 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= B.d2;
    _79 *= r.d2;
    _79 *= _78;
    _79 *= sizeof(bool);
    _70.data = jpl_alloc(_79);
    int64_t _80 = 0; // T
    int64_t _81 = 0; // S
    int64_t _82 = 0; // R
    _jump1383:; // Begin body of loop
    bool _83 = true;
    int64_t _84 = 0;
    _84 *= _70.d0;
    _84 += _82;
    _84 *= _70.d1;
    _84 += _81;
    _84 *= _70.d2;
    _84 += _80;
    _70.data[_84] = _83;
    _80++;
    if (_80 < _78)
    goto _jump1383;
    _80 = 0;
    _81++;
    if (_81 < r.d2)
    goto _jump1383;
    _81 = 0;
    _82++;
    if (_82 < B.d2)
    goto _jump1383;
    // End body of loop
    _54 = _70;
    _jump1375:;
    if (w >= 0)
    goto _jump1384;
    fail_assertion("negative array index");
    _jump1384:;
    if (w < _54.d0)
    goto _jump1385;
    fail_assertion("index too large");
    _jump1385:;
    if (i >= 0)
    goto _jump1386;
    fail_assertion("negative array index");
    _jump1386:;
    if (i < _54.d1)
    goto _jump1387;
    fail_assertion("index too large");
    _jump1387:;
    if (B.d2 >= 0)
    goto _jump1388;
    fail_assertion("negative array index");
    _jump1388:;
    if (B.d2 < _54.d2)
    goto _jump1389;
    fail_assertion("index too large");
    _jump1389:;
    int64_t _85 = 0;
    _85 *= _54.d0;
    _85 += w;
    _85 *= _54.d1;
    _85 += i;
    _85 *= _54.d2;
    _85 += B.d2;
    bool _86 = _54.data[_85];
    return _86;
}

bool F(double G, _a2__a2_bool H, _a1_void_t K) {
    _a2__a1_bool _0;
    // Computing bound for M
    if (K.d0 >= 0)
    goto _jump1490;
    fail_assertion("negative array index");
    _jump1490:;
    if (K.d0 < p.d0)
    goto _jump1491;
    fail_assertion("index too large");
    _jump1491:;
    int64_t _1 = 0;
    _1 *= p.d0;
    _1 += K.d0;
    int64_t _2 = p.data[_1];
    _0.d0 = _2;
    if (_2 > 0) 
    goto _jump1492;
    fail_assertion("non-positive loop bound");
    _jump1492:;
    // Computing bound for N
    _0.d1 = K.d0;
    if (K.d0 > 0) 
    goto _jump1493;
    fail_assertion("non-positive loop bound");
    _jump1493:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= K.d0;
    _3 *= sizeof(_a1_bool);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // N
    int64_t _5 = 0; // M
    _jump1494:; // Begin body of loop
    int64_t _6 = 0;
    _6 *= _0.d0;
    _6 += _5;
    _6 *= _0.d1;
    _6 += _4;
    _0.data[_6] = a;
    _4++;
    if (_4 < K.d0)
    goto _jump1494;
    _4 = 0;
    _5++;
    if (_5 < _2)
    goto _jump1494;
    // End body of loop
    if (s >= 0)
    goto _jump1495;
    fail_assertion("negative array index");
    _jump1495:;
    if (s < _0.d0)
    goto _jump1496;
    fail_assertion("index too large");
    _jump1496:;
    if (i >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (i < _0.d1)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    int64_t _7 = 0;
    _7 *= _0.d0;
    _7 += s;
    _7 *= _0.d1;
    _7 += i;
    _a1_bool _8 = _0.data[_7];
    if (f >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (f < _8.d0)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    int64_t _9 = 0;
    _9 *= _8.d0;
    _9 += f;
    bool _10 = _8.data[_9];
    bool _11 = true;
    bool _12 = _10 != _11;
    bool _13 = !_12;
    _a2__a2_bool _14;
    if (!_13)
    goto _jump1501;
    _14 = H;
    goto _jump1502;
    _jump1501:;
    _a2__a2_bool _15;
    // Computing bound for M
    _a2_int64_t _16;
    // Computing bound for M
    int64_t _17 = l();
    _16.d0 = _17;
    if (_17 > 0) 
    goto _jump1503;
    fail_assertion("non-positive loop bound");
    _jump1503:;
    // Computing bound for N
    _16.d1 = t;
    if (t > 0) 
    goto _jump1504;
    fail_assertion("non-positive loop bound");
    _jump1504:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= _17;
    _18 *= t;
    _18 *= sizeof(int64_t);
    _16.data = jpl_alloc(_18);
    int64_t _19 = 0; // N
    int64_t _20 = 0; // M
    _jump1505:; // Begin body of loop
    int64_t _21 = 0;
    _21 *= _16.d0;
    _21 += _20;
    _21 *= _16.d1;
    _21 += _19;
    _16.data[_21] = K.d0;
    _19++;
    if (_19 < t)
    goto _jump1505;
    _19 = 0;
    _20++;
    if (_20 < _17)
    goto _jump1505;
    // End body of loop
    bool _22 = true;
    int64_t _23;
    if (!_22)
    goto _jump1506;
    int64_t _24;
    // Computing bound for M
    int64_t _25 = l();
    if (_25 > 0) 
    goto _jump1507;
    fail_assertion("non-positive loop bound");
    _jump1507:;
    // Computing bound for N
    if (n > 0) 
    goto _jump1508;
    fail_assertion("non-positive loop bound");
    _jump1508:;
    _24 = 0;
    int64_t _26 = 0; // N
    int64_t _27 = 0; // M
    _jump1509:; // Begin body of loop
    int64_t _28;
    // Computing bound for O
    if (H.d1 > 0) 
    goto _jump1510;
    fail_assertion("non-positive loop bound");
    _jump1510:;
    _28 = 0;
    int64_t _29 = 0; // O
    _jump1511:; // Begin body of loop
    _28 += H.d1;
    _29++;
    if (_29 < H.d1)
    goto _jump1511;
    // End body of loop
    _24 += _28;
    _26++;
    if (_26 < n)
    goto _jump1509;
    _26 = 0;
    _27++;
    if (_27 < _25)
    goto _jump1509;
    // End body of loop
    _23 = _24;
    goto _jump1512;
    _jump1506:;
    _23 = u;
    _jump1512:;
    int64_t _30 = g * _23;
    if (_30 >= 0)
    goto _jump1513;
    fail_assertion("negative array index");
    _jump1513:;
    if (_30 < _16.d0)
    goto _jump1514;
    fail_assertion("index too large");
    _jump1514:;
    if (u >= 0)
    goto _jump1515;
    fail_assertion("negative array index");
    _jump1515:;
    if (u < _16.d1)
    goto _jump1516;
    fail_assertion("index too large");
    _jump1516:;
    int64_t _31 = 0;
    _31 *= _16.d0;
    _31 += _30;
    _31 *= _16.d1;
    _31 += u;
    int64_t _32 = _16.data[_31];
    _15.d0 = _32;
    if (_32 > 0) 
    goto _jump1517;
    fail_assertion("non-positive loop bound");
    _jump1517:;
    // Computing bound for N
    int64_t _33;
    // Computing bound for M
    int64_t _34 = l();
    if (_34 > 0) 
    goto _jump1518;
    fail_assertion("non-positive loop bound");
    _jump1518:;
    _33 = 0;
    int64_t _35 = 0; // M
    _jump1519:; // Begin body of loop
    _33 += i;
    _35++;
    if (_35 < _34)
    goto _jump1519;
    // End body of loop
    _15.d1 = _33;
    if (_33 > 0) 
    goto _jump1520;
    fail_assertion("non-positive loop bound");
    _jump1520:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _32;
    _36 *= _33;
    _36 *= sizeof(_a2_bool);
    _15.data = jpl_alloc(_36);
    int64_t _37 = 0; // N
    int64_t _38 = 0; // M
    _jump1521:; // Begin body of loop
    _a3__a1__a2_bool _39;
    // Computing bound for O
    int64_t _40;
    // Computing bound for O
    if (u > 0) 
    goto _jump1522;
    fail_assertion("non-positive loop bound");
    _jump1522:;
    // Computing bound for P
    int64_t _41 = l();
    if (_41 > 0) 
    goto _jump1523;
    fail_assertion("non-positive loop bound");
    _jump1523:;
    _40 = 0;
    int64_t _42 = 0; // P
    int64_t _43 = 0; // O
    _jump1524:; // Begin body of loop
    _40 += _37;
    _42++;
    if (_42 < _41)
    goto _jump1524;
    _42 = 0;
    _43++;
    if (_43 < u)
    goto _jump1524;
    // End body of loop
    _39.d0 = _40;
    if (_40 > 0) 
    goto _jump1525;
    fail_assertion("non-positive loop bound");
    _jump1525:;
    // Computing bound for P
    _39.d1 = C;
    if (C > 0) 
    goto _jump1526;
    fail_assertion("non-positive loop bound");
    _jump1526:;
    // Computing bound for Q
    _39.d2 = e;
    if (e > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing total size of heap memory to allocate
    int64_t _44 = 1;
    _44 *= _40;
    _44 *= C;
    _44 *= e;
    _44 *= sizeof(_a1__a2_bool);
    _39.data = jpl_alloc(_44);
    int64_t _45 = 0; // Q
    int64_t _46 = 0; // P
    int64_t _47 = 0; // O
    _jump1528:; // Begin body of loop
    _a2_bool _48;
    // Computing bound for R
    int64_t _49 = l();
    _48.d0 = _49;
    if (_49 > 0) 
    goto _jump1529;
    fail_assertion("non-positive loop bound");
    _jump1529:;
    // Computing bound for S
    _48.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump1530;
    fail_assertion("non-positive loop bound");
    _jump1530:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _49;
    _50 *= H.d0;
    _50 *= sizeof(bool);
    _48.data = jpl_alloc(_50);
    int64_t _51 = 0; // S
    int64_t _52 = 0; // R
    _jump1531:; // Begin body of loop
    bool _53 = false;
    int64_t _54 = 0;
    _54 *= _48.d0;
    _54 += _52;
    _54 *= _48.d1;
    _54 += _51;
    _48.data[_54] = _53;
    _51++;
    if (_51 < H.d0)
    goto _jump1531;
    _51 = 0;
    _52++;
    if (_52 < _49)
    goto _jump1531;
    // End body of loop
    _a1__a2_bool _55;
    _55.d0 = 1;
    _55.data = jpl_alloc(sizeof(_a2_bool) * 1);
    _55.data[0] = _48;
    int64_t _56 = 0;
    _56 *= _39.d0;
    _56 += _47;
    _56 *= _39.d1;
    _56 += _46;
    _56 *= _39.d2;
    _56 += _45;
    _39.data[_56] = _55;
    _45++;
    if (_45 < e)
    goto _jump1528;
    _45 = 0;
    _46++;
    if (_46 < C)
    goto _jump1528;
    _46 = 0;
    _47++;
    if (_47 < _40)
    goto _jump1528;
    // End body of loop
    _a3_int64_t _57;
    // Computing bound for O
    _57.d0 = D;
    if (D > 0) 
    goto _jump1532;
    fail_assertion("non-positive loop bound");
    _jump1532:;
    // Computing bound for P
    _57.d1 = g;
    if (g > 0) 
    goto _jump1533;
    fail_assertion("non-positive loop bound");
    _jump1533:;
    // Computing bound for Q
    int64_t _58 = 181;
    _57.d2 = _58;
    if (_58 > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    // Computing total size of heap memory to allocate
    int64_t _59 = 1;
    _59 *= D;
    _59 *= g;
    _59 *= _58;
    _59 *= sizeof(int64_t);
    _57.data = jpl_alloc(_59);
    int64_t _60 = 0; // Q
    int64_t _61 = 0; // P
    int64_t _62 = 0; // O
    _jump1535:; // Begin body of loop
    int64_t _63 = -x;
    int64_t _64 = 0;
    _64 *= _57.d0;
    _64 += _62;
    _64 *= _57.d1;
    _64 += _61;
    _64 *= _57.d2;
    _64 += _60;
    _57.data[_64] = _63;
    _60++;
    if (_60 < _58)
    goto _jump1535;
    _60 = 0;
    _61++;
    if (_61 < g)
    goto _jump1535;
    _61 = 0;
    _62++;
    if (_62 < D)
    goto _jump1535;
    // End body of loop
    int64_t _65;
    // Computing bound for O
    if (e > 0) 
    goto _jump1536;
    fail_assertion("non-positive loop bound");
    _jump1536:;
    // Computing bound for P
    if (n > 0) 
    goto _jump1537;
    fail_assertion("non-positive loop bound");
    _jump1537:;
    _65 = 0;
    int64_t _66 = 0; // P
    int64_t _67 = 0; // O
    _jump1538:; // Begin body of loop
    int64_t _68;
    // Computing bound for Q
    if (g > 0) 
    goto _jump1539;
    fail_assertion("non-positive loop bound");
    _jump1539:;
    // Computing bound for R
    if (i > 0) 
    goto _jump1540;
    fail_assertion("non-positive loop bound");
    _jump1540:;
    // Computing bound for S
    int64_t _69 = 925;
    if (_69 > 0) 
    goto _jump1541;
    fail_assertion("non-positive loop bound");
    _jump1541:;
    _68 = 0;
    int64_t _70 = 0; // S
    int64_t _71 = 0; // R
    int64_t _72 = 0; // Q
    _jump1542:; // Begin body of loop
    _68 += H.d1;
    _70++;
    if (_70 < _69)
    goto _jump1542;
    _70 = 0;
    _71++;
    if (_71 < i)
    goto _jump1542;
    _71 = 0;
    _72++;
    if (_72 < g)
    goto _jump1542;
    // End body of loop
    _65 += _68;
    _66++;
    if (_66 < n)
    goto _jump1538;
    _66 = 0;
    _67++;
    if (_67 < e)
    goto _jump1538;
    // End body of loop
    if (x >= 0)
    goto _jump1543;
    fail_assertion("negative array index");
    _jump1543:;
    if (x < _57.d0)
    goto _jump1544;
    fail_assertion("index too large");
    _jump1544:;
    if (B >= 0)
    goto _jump1545;
    fail_assertion("negative array index");
    _jump1545:;
    if (B < _57.d1)
    goto _jump1546;
    fail_assertion("index too large");
    _jump1546:;
    if (_65 >= 0)
    goto _jump1547;
    fail_assertion("negative array index");
    _jump1547:;
    if (_65 < _57.d2)
    goto _jump1548;
    fail_assertion("index too large");
    _jump1548:;
    int64_t _73 = 0;
    _73 *= _57.d0;
    _73 += x;
    _73 *= _57.d1;
    _73 += B;
    _73 *= _57.d2;
    _73 += _65;
    int64_t _74 = _57.data[_73];
    bool _75 = true;
    _a3_int64_t _76;
    if (!_75)
    goto _jump1549;
    _a3_int64_t _77;
    // Computing bound for O
    _77.d0 = H.d0;
    if (H.d0 > 0) 
    goto _jump1550;
    fail_assertion("non-positive loop bound");
    _jump1550:;
    // Computing bound for P
    _77.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    // Computing bound for Q
    _77.d2 = u;
    if (u > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= H.d0;
    _78 *= H.d0;
    _78 *= u;
    _78 *= sizeof(int64_t);
    _77.data = jpl_alloc(_78);
    int64_t _79 = 0; // Q
    int64_t _80 = 0; // P
    int64_t _81 = 0; // O
    _jump1553:; // Begin body of loop
    int64_t _82 = 0;
    _82 *= _77.d0;
    _82 += _81;
    _82 *= _77.d1;
    _82 += _80;
    _82 *= _77.d2;
    _82 += _79;
    _77.data[_82] = e;
    _79++;
    if (_79 < u)
    goto _jump1553;
    _79 = 0;
    _80++;
    if (_80 < H.d0)
    goto _jump1553;
    _80 = 0;
    _81++;
    if (_81 < H.d0)
    goto _jump1553;
    // End body of loop
    _76 = _77;
    goto _jump1554;
    _jump1549:;
    _a3_int64_t _83;
    // Computing bound for O
    int64_t _84 = l();
    _83.d0 = _84;
    if (_84 > 0) 
    goto _jump1555;
    fail_assertion("non-positive loop bound");
    _jump1555:;
    // Computing bound for P
    _83.d1 = f;
    if (f > 0) 
    goto _jump1556;
    fail_assertion("non-positive loop bound");
    _jump1556:;
    // Computing bound for Q
    _83.d2 = s;
    if (s > 0) 
    goto _jump1557;
    fail_assertion("non-positive loop bound");
    _jump1557:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= _84;
    _85 *= f;
    _85 *= s;
    _85 *= sizeof(int64_t);
    _83.data = jpl_alloc(_85);
    int64_t _86 = 0; // Q
    int64_t _87 = 0; // P
    int64_t _88 = 0; // O
    _jump1558:; // Begin body of loop
    int64_t _89 = 0;
    _89 *= _83.d0;
    _89 += _88;
    _89 *= _83.d1;
    _89 += _87;
    _89 *= _83.d2;
    _89 += _86;
    _83.data[_89] = i;
    _86++;
    if (_86 < s)
    goto _jump1558;
    _86 = 0;
    _87++;
    if (_87 < f)
    goto _jump1558;
    _87 = 0;
    _88++;
    if (_88 < _84)
    goto _jump1558;
    // End body of loop
    _76 = _83;
    _jump1554:;
    int64_t _90 = E % u;
    int64_t _91 = -_90;
    if (_91 >= 0)
    goto _jump1559;
    fail_assertion("negative array index");
    _jump1559:;
    if (_91 < _76.d0)
    goto _jump1560;
    fail_assertion("index too large");
    _jump1560:;
    if (u >= 0)
    goto _jump1561;
    fail_assertion("negative array index");
    _jump1561:;
    if (u < _76.d1)
    goto _jump1562;
    fail_assertion("index too large");
    _jump1562:;
    if (t >= 0)
    goto _jump1563;
    fail_assertion("negative array index");
    _jump1563:;
    if (t < _76.d2)
    goto _jump1564;
    fail_assertion("index too large");
    _jump1564:;
    int64_t _92 = 0;
    _92 *= _76.d0;
    _92 += _91;
    _92 *= _76.d1;
    _92 += u;
    _92 *= _76.d2;
    _92 += t;
    int64_t _93 = _76.data[_92];
    int64_t _94 = 770;
    if (_74 >= 0)
    goto _jump1565;
    fail_assertion("negative array index");
    _jump1565:;
    if (_74 < _39.d0)
    goto _jump1566;
    fail_assertion("index too large");
    _jump1566:;
    if (_93 >= 0)
    goto _jump1567;
    fail_assertion("negative array index");
    _jump1567:;
    if (_93 < _39.d1)
    goto _jump1568;
    fail_assertion("index too large");
    _jump1568:;
    if (_94 >= 0)
    goto _jump1569;
    fail_assertion("negative array index");
    _jump1569:;
    if (_94 < _39.d2)
    goto _jump1570;
    fail_assertion("index too large");
    _jump1570:;
    int64_t _95 = 0;
    _95 *= _39.d0;
    _95 += _74;
    _95 *= _39.d1;
    _95 += _93;
    _95 *= _39.d2;
    _95 += _94;
    _a1__a2_bool _96 = _39.data[_95];
    if (_38 >= 0)
    goto _jump1571;
    fail_assertion("negative array index");
    _jump1571:;
    if (_38 < _96.d0)
    goto _jump1572;
    fail_assertion("index too large");
    _jump1572:;
    int64_t _97 = 0;
    _97 *= _96.d0;
    _97 += _38;
    _a2_bool _98 = _96.data[_97];
    int64_t _99 = 0;
    _99 *= _15.d0;
    _99 += _38;
    _99 *= _15.d1;
    _99 += _37;
    _15.data[_99] = _98;
    _37++;
    if (_37 < _33)
    goto _jump1521;
    _37 = 0;
    _38++;
    if (_38 < _32)
    goto _jump1521;
    // End body of loop
    _14 = _15;
    _jump1502:;
    int64_t _100 = 141;
    bool _101 = _100 > g;
    if (0 != _101)
    goto _jump1573;
    fail_assertion("S");
    _jump1573:;
    double _102 = q();
    bool _103 = t >= n;
    double _104;
    if (!_103)
    goto _jump1574;
    double _105 = q();
    double _106 = -_105;
    _104 = _106;
    goto _jump1575;
    _jump1574:;
    _104 = G;
    _jump1575:;
    bool _107 = false;
    bool _108;
    if (!_107)
    goto _jump1576;
    double _109 = 18.0;
    bool _110 = G <= _109;
    _108 = _110;
    goto _jump1577;
    _jump1576:;
    bool _111 = e < u;
    _108 = _111;
    _jump1577:;
    double _112;
    if (!_108)
    goto _jump1578;
    double _113 = q();
    _112 = _113;
    goto _jump1579;
    _jump1578:;
    double _114 = 47.0;
    double _115 = q();
    double _116 = 42.0;
    rgba _117 = { _114, G, _115, _116 };
    double _118 = _117.b;
    _112 = _118;
    _jump1579:;
    double _119 = q();
    rgba _120 = { _102, _104, _112, _119 };
    double _121 = _120.b;
    bool _123 = f >= _14.d1;
    bool _124 = !_123;
    bool _122 = _124;
    if (0 == _124)
    goto _jump1580;
    int64_t _125 = 686;
    if (w >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (w < d.d0)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    if (u >= 0)
    goto _jump1583;
    fail_assertion("negative array index");
    _jump1583:;
    if (u < d.d1)
    goto _jump1584;
    fail_assertion("index too large");
    _jump1584:;
    if (_125 >= 0)
    goto _jump1585;
    fail_assertion("negative array index");
    _jump1585:;
    if (_125 < d.d2)
    goto _jump1586;
    fail_assertion("index too large");
    _jump1586:;
    int64_t _126 = 0;
    _126 *= d.d0;
    _126 += w;
    _126 *= d.d1;
    _126 += u;
    _126 *= d.d2;
    _126 += _125;
    double _127 = d.data[_126];
    bool _128 = F(_127, _14, K);
    _122 = _128;
    _jump1580:;
    double _129;
    if (!_122)
    goto _jump1587;
    bool _130 = B > K.d0;
    double _131;
    if (!_130)
    goto _jump1588;
    double _132 = q();
    double _133 = q();
    double _134 = fmod(_132, _133);
    _131 = _134;
    goto _jump1589;
    _jump1588:;
    _131 = G;
    _jump1589:;
    _129 = _131;
    goto _jump1590;
    _jump1587:;
    bool _135 = true;
    _a2__a2_bool _136;
    if (!_135)
    goto _jump1591;
    _136 = H;
    goto _jump1592;
    _jump1591:;
    _136 = H;
    _jump1592:;
    bool _137 = F(G, _136, K);
    double _138;
    if (!_137)
    goto _jump1593;
    _138 = G;
    goto _jump1594;
    _jump1593:;
    _138 = G;
    _jump1594:;
    _129 = _138;
    _jump1590:;
    double _139 = 32.0;
    double _140 = fmod(_129, _139);
    double _141 = q();
    double _142 = q();
    double _143 = -_142;
    double _144 = -_143;
    double _145;
    // Computing bound for S
    if (n > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing bound for T
    if (D > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    _145 = 0;
    int64_t _146 = 0; // T
    int64_t _147 = 0; // S
    _jump1597:; // Begin body of loop
    bool _148 = false;
    double _149;
    if (!_148)
    goto _jump1598;
    double _150 = q();
    _149 = _150;
    goto _jump1599;
    _jump1598:;
    double _151 = q();
    _149 = _151;
    _jump1599:;
    _145 += _149;
    _146++;
    if (_146 < D)
    goto _jump1597;
    _146 = 0;
    _147++;
    if (_147 < n)
    goto _jump1597;
    // End body of loop
    double _152 = q();
    rgba _153 = { _141, _144, _145, _152 };
    double _154 = _153.g;
    _a1_rgba _155;
    // Computing bound for S
    _155.d0 = g;
    if (g > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= g;
    _156 *= sizeof(rgba);
    _155.data = jpl_alloc(_156);
    int64_t _157 = 0; // S
    _jump1601:; // Begin body of loop
    double _158 = q();
    double _159;
    // Computing bound for T
    int64_t _160 = l();
    if (_160 > 0) 
    goto _jump1602;
    fail_assertion("non-positive loop bound");
    _jump1602:;
    // Computing bound for U
    if (e > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    // Computing bound for V
    if (g > 0) 
    goto _jump1604;
    fail_assertion("non-positive loop bound");
    _jump1604:;
    _159 = 0;
    int64_t _161 = 0; // V
    int64_t _162 = 0; // U
    int64_t _163 = 0; // T
    _jump1605:; // Begin body of loop
    double _164 = 9.0;
    _159 += _164;
    _161++;
    if (_161 < g)
    goto _jump1605;
    _161 = 0;
    _162++;
    if (_162 < e)
    goto _jump1605;
    _162 = 0;
    _163++;
    if (_163 < _160)
    goto _jump1605;
    // End body of loop
    rgba _165 = { _158, G, _159, G };
    int64_t _166 = 0;
    _166 *= _155.d0;
    _166 += _157;
    _155.data[_166] = _165;
    _157++;
    if (_157 < g)
    goto _jump1601;
    // End body of loop
    _a2_int64_t _167;
    // Computing bound for S
    _167.d0 = n;
    if (n > 0) 
    goto _jump1606;
    fail_assertion("non-positive loop bound");
    _jump1606:;
    // Computing bound for T
    bool _168 = true;
    int64_t _169;
    if (!_168)
    goto _jump1607;
    _169 = s;
    goto _jump1608;
    _jump1607:;
    _169 = j;
    _jump1608:;
    _167.d1 = _169;
    if (_169 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing total size of heap memory to allocate
    int64_t _170 = 1;
    _170 *= n;
    _170 *= _169;
    _170 *= sizeof(int64_t);
    _167.data = jpl_alloc(_170);
    int64_t _171 = 0; // T
    int64_t _172 = 0; // S
    _jump1610:; // Begin body of loop
    int64_t _173 = 0;
    _173 *= _167.d0;
    _173 += _172;
    _173 *= _167.d1;
    _173 += _171;
    _167.data[_173] = B;
    _171++;
    if (_171 < _169)
    goto _jump1610;
    _171 = 0;
    _172++;
    if (_172 < n)
    goto _jump1610;
    // End body of loop
    if (_14.d0 >= 0)
    goto _jump1611;
    fail_assertion("negative array index");
    _jump1611:;
    if (_14.d0 < _167.d0)
    goto _jump1612;
    fail_assertion("index too large");
    _jump1612:;
    if (e >= 0)
    goto _jump1613;
    fail_assertion("negative array index");
    _jump1613:;
    if (e < _167.d1)
    goto _jump1614;
    fail_assertion("index too large");
    _jump1614:;
    int64_t _174 = 0;
    _174 *= _167.d0;
    _174 += _14.d0;
    _174 *= _167.d1;
    _174 += e;
    int64_t _175 = _167.data[_174];
    if (x >= 0)
    goto _jump1615;
    fail_assertion("negative array index");
    _jump1615:;
    if (x < K.d0)
    goto _jump1616;
    fail_assertion("index too large");
    _jump1616:;
    int64_t _176 = 0;
    _176 *= K.d0;
    _176 += x;
    void_t _177 = K.data[_176];
    double _178 = o(_155, _175, _177);
    double _179 = _154 - _178;
    double _180;
    // Computing bound for S
    if (E > 0) 
    goto _jump1617;
    fail_assertion("non-positive loop bound");
    _jump1617:;
    _180 = 0;
    int64_t _181 = 0; // S
    _jump1618:; // Begin body of loop
    double _182 = 31.0;
    _180 += _182;
    _181++;
    if (_181 < E)
    goto _jump1618;
    // End body of loop
    rgba _183 = { _121, _140, _179, _180 };
    double _184 = _183.b;
    double _185 = q();
    _a1_double _186;
    _186.d0 = 1;
    _186.data = jpl_alloc(sizeof(double) * 1);
    _186.data[0] = _185;
    b _187 = k(_186);
    double _188 = _187.a;
    double _189 = -_188;
    bool _190 = _189 != G;
    _a1__a3_double _191;
    if (!_190)
    goto _jump1619;
    _a2__a1__a3_double _192;
    // Computing bound for T
    _192.d0 = D;
    if (D > 0) 
    goto _jump1620;
    fail_assertion("non-positive loop bound");
    _jump1620:;
    // Computing bound for U
    _192.d1 = e;
    if (e > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= D;
    _193 *= e;
    _193 *= sizeof(_a1__a3_double);
    _192.data = jpl_alloc(_193);
    int64_t _194 = 0; // U
    int64_t _195 = 0; // T
    _jump1622:; // Begin body of loop
    int64_t _196 = 0;
    _196 *= _192.d0;
    _196 += _195;
    _196 *= _192.d1;
    _196 += _194;
    _192.data[_196] = m;
    _194++;
    if (_194 < e)
    goto _jump1622;
    _194 = 0;
    _195++;
    if (_195 < D)
    goto _jump1622;
    // End body of loop
    if (w >= 0)
    goto _jump1623;
    fail_assertion("negative array index");
    _jump1623:;
    if (w < _192.d0)
    goto _jump1624;
    fail_assertion("index too large");
    _jump1624:;
    if (C >= 0)
    goto _jump1625;
    fail_assertion("negative array index");
    _jump1625:;
    if (C < _192.d1)
    goto _jump1626;
    fail_assertion("index too large");
    _jump1626:;
    int64_t _197 = 0;
    _197 *= _192.d0;
    _197 += w;
    _197 *= _192.d1;
    _197 += C;
    _a1__a3_double _198 = _192.data[_197];
    _191 = _198;
    goto _jump1627;
    _jump1619:;
    _a1__a3_double _199;
    // Computing bound for T
    _199.d0 = B;
    if (B > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= B;
    _200 *= sizeof(_a3_double);
    _199.data = jpl_alloc(_200);
    int64_t _201 = 0; // T
    _jump1629:; // Begin body of loop
    int64_t _202 = 0;
    _202 *= _199.d0;
    _202 += _201;
    _199.data[_202] = r;
    _201++;
    if (_201 < B)
    goto _jump1629;
    // End body of loop
    _191 = _199;
    _jump1627:;
    bool _204 = K.d0 > e;
    bool _203 = _204;
    if (0 == _204)
    goto _jump1630;
    bool _205 = true;
    bool _206 = !_205;
    _203 = _206;
    _jump1630:;
    bool _207;
    if (!_203)
    goto _jump1631;
    int64_t _208;
    // Computing bound for V
    if (E > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    // Computing bound for W
    if (K.d0 > 0) 
    goto _jump1633;
    fail_assertion("non-positive loop bound");
    _jump1633:;
    // Computing bound for X
    if (e > 0) 
    goto _jump1634;
    fail_assertion("non-positive loop bound");
    _jump1634:;
    _208 = 0;
    int64_t _209 = 0; // X
    int64_t _210 = 0; // W
    int64_t _211 = 0; // V
    _jump1635:; // Begin body of loop
    _208 += g;
    _209++;
    if (_209 < e)
    goto _jump1635;
    _209 = 0;
    _210++;
    if (_210 < K.d0)
    goto _jump1635;
    _210 = 0;
    _211++;
    if (_211 < E)
    goto _jump1635;
    // End body of loop
    bool _212 = _208 >= e;
    _207 = _212;
    goto _jump1636;
    _jump1631:;
    if (s >= 0)
    goto _jump1637;
    fail_assertion("negative array index");
    _jump1637:;
    if (s < _14.d0)
    goto _jump1638;
    fail_assertion("index too large");
    _jump1638:;
    if (E >= 0)
    goto _jump1639;
    fail_assertion("negative array index");
    _jump1639:;
    if (E < _14.d1)
    goto _jump1640;
    fail_assertion("index too large");
    _jump1640:;
    int64_t _213 = 0;
    _213 *= _14.d0;
    _213 += s;
    _213 *= _14.d1;
    _213 += E;
    _a2_bool _214 = _14.data[_213];
    int64_t _215;
    // Computing bound for V
    int64_t _216 = l();
    if (_216 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    _215 = 0;
    int64_t _217 = 0; // V
    _jump1642:; // Begin body of loop
    _215 += t;
    _217++;
    if (_217 < _216)
    goto _jump1642;
    // End body of loop
    if (_215 >= 0)
    goto _jump1643;
    fail_assertion("negative array index");
    _jump1643:;
    if (_215 < _214.d0)
    goto _jump1644;
    fail_assertion("index too large");
    _jump1644:;
    if (_191.d0 >= 0)
    goto _jump1645;
    fail_assertion("negative array index");
    _jump1645:;
    if (_191.d0 < _214.d1)
    goto _jump1646;
    fail_assertion("index too large");
    _jump1646:;
    int64_t _218 = 0;
    _218 *= _214.d0;
    _218 += _215;
    _218 *= _214.d1;
    _218 += _191.d0;
    bool _219 = _214.data[_218];
    _207 = _219;
    _jump1636:;
    bool _220 = !_207;
    _a3__a3_bool _221;
    if (!_220)
    goto _jump1647;
    _a3__a3_bool _222;
    // Computing bound for V
    _222.d0 = B;
    if (B > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    // Computing bound for W
    _222.d1 = K.d0;
    if (K.d0 > 0) 
    goto _jump1649;
    fail_assertion("non-positive loop bound");
    _jump1649:;
    // Computing bound for X
    int64_t _223 = -E;
    _222.d2 = _223;
    if (_223 > 0) 
    goto _jump1650;
    fail_assertion("non-positive loop bound");
    _jump1650:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= B;
    _224 *= K.d0;
    _224 *= _223;
    _224 *= sizeof(_a3_bool);
    _222.data = jpl_alloc(_224);
    int64_t _225 = 0; // X
    int64_t _226 = 0; // W
    int64_t _227 = 0; // V
    _jump1651:; // Begin body of loop
    _a3_bool _228;
    // Computing bound for Y
    _228.d0 = _14.d0;
    if (_14.d0 > 0) 
    goto _jump1652;
    fail_assertion("non-positive loop bound");
    _jump1652:;
    // Computing bound for Z
    _228.d1 = i;
    if (i > 0) 
    goto _jump1653;
    fail_assertion("non-positive loop bound");
    _jump1653:;
    // Computing bound for aa
    _228.d2 = K.d0;
    if (K.d0 > 0) 
    goto _jump1654;
    fail_assertion("non-positive loop bound");
    _jump1654:;
    // Computing total size of heap memory to allocate
    int64_t _229 = 1;
    _229 *= _14.d0;
    _229 *= i;
    _229 *= K.d0;
    _229 *= sizeof(bool);
    _228.data = jpl_alloc(_229);
    int64_t _230 = 0; // aa
    int64_t _231 = 0; // Z
    int64_t _232 = 0; // Y
    _jump1655:; // Begin body of loop
    bool _233 = false;
    int64_t _234 = 0;
    _234 *= _228.d0;
    _234 += _232;
    _234 *= _228.d1;
    _234 += _231;
    _234 *= _228.d2;
    _234 += _230;
    _228.data[_234] = _233;
    _230++;
    if (_230 < K.d0)
    goto _jump1655;
    _230 = 0;
    _231++;
    if (_231 < i)
    goto _jump1655;
    _231 = 0;
    _232++;
    if (_232 < _14.d0)
    goto _jump1655;
    // End body of loop
    int64_t _235 = 0;
    _235 *= _222.d0;
    _235 += _227;
    _235 *= _222.d1;
    _235 += _226;
    _235 *= _222.d2;
    _235 += _225;
    _222.data[_235] = _228;
    _225++;
    if (_225 < _223)
    goto _jump1651;
    _225 = 0;
    _226++;
    if (_226 < K.d0)
    goto _jump1651;
    _226 = 0;
    _227++;
    if (_227 < B)
    goto _jump1651;
    // End body of loop
    _a1__a3__a3_bool _236;
    _236.d0 = 1;
    _236.data = jpl_alloc(sizeof(_a3__a3_bool) * 1);
    _236.data[0] = _222;
    int64_t _237;
    // Computing bound for V
    int64_t _238;
    // Computing bound for V
    if (K.d0 > 0) 
    goto _jump1656;
    fail_assertion("non-positive loop bound");
    _jump1656:;
    // Computing bound for W
    if (e > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    // Computing bound for X
    if (w > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    _238 = 0;
    int64_t _239 = 0; // X
    int64_t _240 = 0; // W
    int64_t _241 = 0; // V
    _jump1659:; // Begin body of loop
    _238 += K.d0;
    _239++;
    if (_239 < w)
    goto _jump1659;
    _239 = 0;
    _240++;
    if (_240 < e)
    goto _jump1659;
    _240 = 0;
    _241++;
    if (_241 < K.d0)
    goto _jump1659;
    // End body of loop
    int64_t _242 = _238 + w;
    if (_242 > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing bound for W
    int64_t _243 = -w;
    if (_243 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing bound for X
    bool _244 = G != G;
    int64_t _245;
    if (!_244)
    goto _jump1662;
    _245 = H.d1;
    goto _jump1663;
    _jump1662:;
    _245 = e;
    _jump1663:;
    if (_245 > 0) 
    goto _jump1664;
    fail_assertion("non-positive loop bound");
    _jump1664:;
    _237 = 0;
    int64_t _246 = 0; // X
    int64_t _247 = 0; // W
    int64_t _248 = 0; // V
    _jump1665:; // Begin body of loop
    _237 += D;
    _246++;
    if (_246 < _245)
    goto _jump1665;
    _246 = 0;
    _247++;
    if (_247 < _243)
    goto _jump1665;
    _247 = 0;
    _248++;
    if (_248 < _242)
    goto _jump1665;
    // End body of loop
    if (_237 >= 0)
    goto _jump1666;
    fail_assertion("negative array index");
    _jump1666:;
    if (_237 < _236.d0)
    goto _jump1667;
    fail_assertion("index too large");
    _jump1667:;
    int64_t _249 = 0;
    _249 *= _236.d0;
    _249 += _237;
    _a3__a3_bool _250 = _236.data[_249];
    _221 = _250;
    goto _jump1668;
    _jump1647:;
    _a3__a3_bool _251;
    // Computing bound for V
    _251.d0 = e;
    if (e > 0) 
    goto _jump1669;
    fail_assertion("non-positive loop bound");
    _jump1669:;
    // Computing bound for W
    _251.d1 = D;
    if (D > 0) 
    goto _jump1670;
    fail_assertion("non-positive loop bound");
    _jump1670:;
    // Computing bound for X
    _251.d2 = n;
    if (n > 0) 
    goto _jump1671;
    fail_assertion("non-positive loop bound");
    _jump1671:;
    // Computing total size of heap memory to allocate
    int64_t _252 = 1;
    _252 *= e;
    _252 *= D;
    _252 *= n;
    _252 *= sizeof(_a3_bool);
    _251.data = jpl_alloc(_252);
    int64_t _253 = 0; // X
    int64_t _254 = 0; // W
    int64_t _255 = 0; // V
    _jump1672:; // Begin body of loop
    bool _257 = K.d0 == x;
    bool _256 = _257;
    if (0 == _257)
    goto _jump1673;
    bool _258 = K.d0 != C;
    _256 = _258;
    _jump1673:;
    _a3_bool _259;
    if (!_256)
    goto _jump1674;
    _a3_bool _260;
    // Computing bound for Y
    _260.d0 = w;
    if (w > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    // Computing bound for Z
    int64_t _261;
    // Computing bound for Y
    if (e > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing bound for Z
    if (f > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    // Computing bound for aa
    if (g > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    _261 = 0;
    int64_t _262 = 0; // aa
    int64_t _263 = 0; // Z
    int64_t _264 = 0; // Y
    _jump1679:; // Begin body of loop
    _261 += H.d0;
    _262++;
    if (_262 < g)
    goto _jump1679;
    _262 = 0;
    _263++;
    if (_263 < f)
    goto _jump1679;
    _263 = 0;
    _264++;
    if (_264 < e)
    goto _jump1679;
    // End body of loop
    _260.d1 = _261;
    if (_261 > 0) 
    goto _jump1680;
    fail_assertion("non-positive loop bound");
    _jump1680:;
    // Computing bound for aa
    _260.d2 = _254;
    if (_254 > 0) 
    goto _jump1681;
    fail_assertion("non-positive loop bound");
    _jump1681:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= w;
    _265 *= _261;
    _265 *= _254;
    _265 *= sizeof(bool);
    _260.data = jpl_alloc(_265);
    int64_t _266 = 0; // aa
    int64_t _267 = 0; // Z
    int64_t _268 = 0; // Y
    _jump1682:; // Begin body of loop
    if (K.d0 >= 0)
    goto _jump1683;
    fail_assertion("negative array index");
    _jump1683:;
    if (K.d0 < a.d0)
    goto _jump1684;
    fail_assertion("index too large");
    _jump1684:;
    int64_t _269 = 0;
    _269 *= a.d0;
    _269 += K.d0;
    bool _270 = a.data[_269];
    int64_t _271 = 0;
    _271 *= _260.d0;
    _271 += _268;
    _271 *= _260.d1;
    _271 += _267;
    _271 *= _260.d2;
    _271 += _266;
    _260.data[_271] = _270;
    _266++;
    if (_266 < _254)
    goto _jump1682;
    _266 = 0;
    _267++;
    if (_267 < _261)
    goto _jump1682;
    _267 = 0;
    _268++;
    if (_268 < w)
    goto _jump1682;
    // End body of loop
    _259 = _260;
    goto _jump1685;
    _jump1674:;
    _a3_bool _272;
    // Computing bound for Y
    _272.d0 = H.d1;
    if (H.d1 > 0) 
    goto _jump1686;
    fail_assertion("non-positive loop bound");
    _jump1686:;
    // Computing bound for Z
    _272.d1 = D;
    if (D > 0) 
    goto _jump1687;
    fail_assertion("non-positive loop bound");
    _jump1687:;
    // Computing bound for aa
    _272.d2 = f;
    if (f > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= H.d1;
    _273 *= D;
    _273 *= f;
    _273 *= sizeof(bool);
    _272.data = jpl_alloc(_273);
    int64_t _274 = 0; // aa
    int64_t _275 = 0; // Z
    int64_t _276 = 0; // Y
    _jump1689:; // Begin body of loop
    bool _277 = e < C;
    int64_t _278 = 0;
    _278 *= _272.d0;
    _278 += _276;
    _278 *= _272.d1;
    _278 += _275;
    _278 *= _272.d2;
    _278 += _274;
    _272.data[_278] = _277;
    _274++;
    if (_274 < f)
    goto _jump1689;
    _274 = 0;
    _275++;
    if (_275 < D)
    goto _jump1689;
    _275 = 0;
    _276++;
    if (_276 < H.d1)
    goto _jump1689;
    // End body of loop
    _259 = _272;
    _jump1685:;
    int64_t _279 = 0;
    _279 *= _251.d0;
    _279 += _255;
    _279 *= _251.d1;
    _279 += _254;
    _279 *= _251.d2;
    _279 += _253;
    _251.data[_279] = _259;
    _253++;
    if (_253 < n)
    goto _jump1672;
    _253 = 0;
    _254++;
    if (_254 < D)
    goto _jump1672;
    _254 = 0;
    _255++;
    if (_255 < e)
    goto _jump1672;
    // End body of loop
    _221 = _251;
    _jump1668:;
    if (_191.d0 >= 0)
    goto _jump1690;
    fail_assertion("negative array index");
    _jump1690:;
    if (_191.d0 < p.d0)
    goto _jump1691;
    fail_assertion("index too large");
    _jump1691:;
    int64_t _280 = 0;
    _280 *= p.d0;
    _280 += _191.d0;
    int64_t _281 = p.data[_280];
    int64_t _282 = -B;
    if (E >= 0)
    goto _jump1692;
    fail_assertion("negative array index");
    _jump1692:;
    if (E < _221.d0)
    goto _jump1693;
    fail_assertion("index too large");
    _jump1693:;
    if (_281 >= 0)
    goto _jump1694;
    fail_assertion("negative array index");
    _jump1694:;
    if (_281 < _221.d1)
    goto _jump1695;
    fail_assertion("index too large");
    _jump1695:;
    if (_282 >= 0)
    goto _jump1696;
    fail_assertion("negative array index");
    _jump1696:;
    if (_282 < _221.d2)
    goto _jump1697;
    fail_assertion("index too large");
    _jump1697:;
    int64_t _283 = 0;
    _283 *= _221.d0;
    _283 += E;
    _283 *= _221.d1;
    _283 += _281;
    _283 *= _221.d2;
    _283 += _282;
    _a3_bool _284 = _221.data[_283];
    if (D >= 0)
    goto _jump1698;
    fail_assertion("negative array index");
    _jump1698:;
    if (D < _284.d0)
    goto _jump1699;
    fail_assertion("index too large");
    _jump1699:;
    if (j >= 0)
    goto _jump1700;
    fail_assertion("negative array index");
    _jump1700:;
    if (j < _284.d1)
    goto _jump1701;
    fail_assertion("index too large");
    _jump1701:;
    if (f >= 0)
    goto _jump1702;
    fail_assertion("negative array index");
    _jump1702:;
    if (f < _284.d2)
    goto _jump1703;
    fail_assertion("index too large");
    _jump1703:;
    int64_t _285 = 0;
    _285 *= _284.d0;
    _285 += D;
    _285 *= _284.d1;
    _285 += j;
    _285 *= _284.d2;
    _285 += f;
    bool _286 = _284.data[_285];
    return _286;
}

void jpl_main(struct args args) {
    double _2 = 35.0;
    double _3 = -_2;
    double _4;
    // Computing bound for a
    int64_t _5 = 323;
    if (_5 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing bound for b
    int64_t _6 = 470;
    if (_6 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    _4 = 0;
    int64_t _7 = 0; // b
    int64_t _8 = 0; // a
    _jump3:; // Begin body of loop
    double _9 = 87.0;
    _4 += _9;
    _7++;
    if (_7 < _6)
    goto _jump3;
    _7 = 0;
    _8++;
    if (_8 < _5)
    goto _jump3;
    // End body of loop
    double _10 = -_4;
    double _11 = -_10;
    bool _12 = _3 != _11;
    bool _1 = _12;
    if (0 != _12)
    goto _jump4;
    int64_t _14 = 949;
    int64_t _15 = -_14;
    int64_t _16 = 884;
    bool _17 = _15 <= _16;
    int64_t _18 = 231;
    int64_t _19 = 619;
    bool _20 = _18 != _19;
    bool _21 = _17 != _20;
    bool _13 = _21;
    if (0 == _21)
    goto _jump5;
    int64_t _23 = 208;
    int64_t _24 = 453;
    int64_t _25 = 946;
    int64_t _26 = _24 + _25;
    bool _27 = _23 <= _26;
    bool _22 = _27;
    if (0 == _27)
    goto _jump6;
    bool _28 = true;
    bool _29 = !_28;
    _22 = _29;
    _jump6:;
    _13 = _22;
    _jump5:;
    _1 = _13;
    _jump4:;
    bool _0 = _1;
    if (0 != _1)
    goto _jump7;
    bool _30 = true;
    _0 = _30;
    _jump7:;
    double _31;
    // Computing bound for a
    int64_t _32;
    // Computing bound for a
    bool _33 = true;
    bool _34;
    if (!_33)
    goto _jump8;
    bool _35 = false;
    _34 = _35;
    goto _jump9;
    _jump8:;
    bool _36 = false;
    _34 = _36;
    _jump9:;
    bool _37 = !_34;
    int64_t _38;
    if (!_37)
    goto _jump10;
    bool _39 = true;
    bool _40;
    if (!_39)
    goto _jump11;
    bool _41 = false;
    _40 = _41;
    goto _jump12;
    _jump11:;
    bool _42 = false;
    _40 = _42;
    _jump12:;
    int64_t _43;
    if (!_40)
    goto _jump13;
    int64_t _44 = 281;
    _43 = _44;
    goto _jump14;
    _jump13:;
    int64_t _45 = 409;
    int64_t _46 = 735;
    int64_t _47 = _45 * _46;
    _43 = _47;
    _jump14:;
    _38 = _43;
    goto _jump15;
    _jump10:;
    int64_t _48;
    // Computing bound for a
    int64_t _49 = 789;
    if (_49 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    _48 = 0;
    int64_t _50 = 0; // a
    _jump17:; // Begin body of loop
    int64_t _51 = 636;
    int64_t _52 = -_51;
    _48 += _52;
    _50++;
    if (_50 < _49)
    goto _jump17;
    // End body of loop
    _38 = _48;
    _jump15:;
    if (_38 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    // Computing bound for b
    int64_t _53;
    // Computing bound for a
    int64_t _54 = 420;
    int64_t _55 = 159;
    int64_t _56 = _54 / _55;
    if (_56 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    // Computing bound for b
    int64_t _57 = 171;
    int64_t _58 = -_57;
    int64_t _59 = 596;
    int64_t _60 = _58 / _59;
    if (_60 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    // Computing bound for c
    int64_t _61 = 484;
    if (_61 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    _53 = 0;
    int64_t _62 = 0; // c
    int64_t _63 = 0; // b
    int64_t _64 = 0; // a
    _jump22:; // Begin body of loop
    int64_t _65;
    // Computing bound for d
    if (_62 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    _65 = 0;
    int64_t _66 = 0; // d
    _jump24:; // Begin body of loop
    int64_t _67 = _66 - _63;
    _65 += _67;
    _66++;
    if (_66 < _62)
    goto _jump24;
    // End body of loop
    _53 += _65;
    _62++;
    if (_62 < _61)
    goto _jump22;
    _62 = 0;
    _63++;
    if (_63 < _60)
    goto _jump22;
    _63 = 0;
    _64++;
    if (_64 < _56)
    goto _jump22;
    // End body of loop
    if (_53 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for c
    int64_t _68 = 358;
    int64_t _69 = 251;
    int64_t _70 = _68 / _69;
    int64_t _71 = 967;
    int64_t _72 = _70 % _71;
    if (_72 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    _32 = 0;
    int64_t _73 = 0; // c
    int64_t _74 = 0; // b
    int64_t _75 = 0; // a
    _jump27:; // Begin body of loop
    int64_t _76 = 775;
    _32 += _76;
    _73++;
    if (_73 < _72)
    goto _jump27;
    _73 = 0;
    _74++;
    if (_74 < _53)
    goto _jump27;
    _74 = 0;
    _75++;
    if (_75 < _38)
    goto _jump27;
    // End body of loop
    if (_32 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    // Computing bound for b
    int64_t _77;
    // Computing bound for a
    int64_t _78 = 663;
    int64_t _79 = 778;
    int64_t _80 = _78 / _79;
    if (_80 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    // Computing bound for b
    int64_t _81 = 189;
    int64_t _82 = -_81;
    if (_82 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    _77 = 0;
    int64_t _83 = 0; // b
    int64_t _84 = 0; // a
    _jump31:; // Begin body of loop
    int64_t _85 = 879;
    _77 += _85;
    _83++;
    if (_83 < _82)
    goto _jump31;
    _83 = 0;
    _84++;
    if (_84 < _80)
    goto _jump31;
    // End body of loop
    int64_t _86 = -_77;
    int64_t _87 = -_86;
    if (_87 > 0) 
    goto _jump32;
    fail_assertion("non-positive loop bound");
    _jump32:;
    _31 = 0;
    int64_t _88 = 0; // b
    int64_t _89 = 0; // a
    _jump33:; // Begin body of loop
    double _90;
    // Computing bound for c
    if (_89 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    _90 = 0;
    int64_t _91 = 0; // c
    _jump35:; // Begin body of loop
    bool _92 = _88 <= _89;
    double _93;
    if (!_92)
    goto _jump36;
    double _94 = 27.0;
    _93 = _94;
    goto _jump37;
    _jump36:;
    double _95 = 21.0;
    double _96 = -_95;
    _93 = _96;
    _jump37:;
    _90 += _93;
    _91++;
    if (_91 < _89)
    goto _jump35;
    // End body of loop
    double _97 = -_90;
    _31 += _97;
    _88++;
    if (_88 < _87)
    goto _jump33;
    _88 = 0;
    _89++;
    if (_89 < _32)
    goto _jump33;
    // End body of loop
    bool _99 = true;
    bool _100 = !_99;
    bool _98 = _100;
    if (0 == _100)
    goto _jump38;
    bool _101 = false;
    bool _102 = false;
    bool _103 = _101 != _102;
    _98 = _103;
    _jump38:;
    bool _104;
    if (!_98)
    goto _jump39;
    double _105 = 91.0;
    double _106 = 54.0;
    double _107 = _105 + _106;
    double _108 = 2.0;
    bool _109 = _107 > _108;
    _104 = _109;
    goto _jump40;
    _jump39:;
    bool _111 = false;
    bool _110 = _111;
    if (0 != _111)
    goto _jump41;
    bool _112 = true;
    bool _113 = !_112;
    _110 = _113;
    _jump41:;
    _104 = _110;
    _jump40:;
    double _114;
    if (!_104)
    goto _jump42;
    double _115 = 13.0;
    _114 = _115;
    goto _jump43;
    _jump42:;
    double _116 = 74.0;
    double _117 = -_116;
    _114 = _117;
    _jump43:;
    bool _118 = true;
    double _119;
    if (!_118)
    goto _jump44;
    double _120 = 12.0;
    _119 = _120;
    goto _jump45;
    _jump44:;
    double _121 = 89.0;
    _119 = _121;
    _jump45:;
    double _122 = 79.0;
    double _123 = 90.0;
    bool _124 = false;
    bool _125 = true;
    bool _126 = _124 == _125;
    double _127;
    if (!_126)
    goto _jump46;
    bool _128 = false;
    double _129;
    if (!_128)
    goto _jump47;
    double _130 = 67.0;
    _129 = _130;
    goto _jump48;
    _jump47:;
    double _131 = 53.0;
    _129 = _131;
    _jump48:;
    _127 = _129;
    goto _jump49;
    _jump46:;
    double _132 = 38.0;
    double _133 = -_132;
    _127 = _133;
    _jump49:;
    rgba _134 = { _119, _122, _123, _127 };
    double _135 = _134.r;
    double _136 = _114 + _135;
    bool _137 = _31 == _136;
    _a3__a3_bool _138;
    // Computing bound for a
    double _139 = 39.0;
    double _140 = 68.0;
    bool _141 = _139 == _140;
    int64_t _142;
    if (!_141)
    goto _jump50;
    _a2_int64_t _143;
    // Computing bound for a
    int64_t _144 = 342;
    _143.d0 = _144;
    if (_144 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    // Computing bound for b
    int64_t _145 = 433;
    _143.d1 = _145;
    if (_145 > 0) 
    goto _jump52;
    fail_assertion("non-positive loop bound");
    _jump52:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _144;
    _146 *= _145;
    _146 *= sizeof(int64_t);
    _143.data = jpl_alloc(_146);
    int64_t _147 = 0; // b
    int64_t _148 = 0; // a
    _jump53:; // Begin body of loop
    int64_t _149 = 736;
    int64_t _150 = 0;
    _150 *= _143.d0;
    _150 += _148;
    _150 *= _143.d1;
    _150 += _147;
    _143.data[_150] = _149;
    _147++;
    if (_147 < _145)
    goto _jump53;
    _147 = 0;
    _148++;
    if (_148 < _144)
    goto _jump53;
    // End body of loop
    int64_t _151 = 484;
    int64_t _152;
    // Computing bound for a
    int64_t _153 = 699;
    if (_153 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    _152 = 0;
    int64_t _154 = 0; // a
    _jump55:; // Begin body of loop
    _152 += _154;
    _154++;
    if (_154 < _153)
    goto _jump55;
    // End body of loop
    if (_151 >= 0)
    goto _jump56;
    fail_assertion("negative array index");
    _jump56:;
    if (_151 < _143.d0)
    goto _jump57;
    fail_assertion("index too large");
    _jump57:;
    if (_152 >= 0)
    goto _jump58;
    fail_assertion("negative array index");
    _jump58:;
    if (_152 < _143.d1)
    goto _jump59;
    fail_assertion("index too large");
    _jump59:;
    int64_t _155 = 0;
    _155 *= _143.d0;
    _155 += _151;
    _155 *= _143.d1;
    _155 += _152;
    int64_t _156 = _143.data[_155];
    _142 = _156;
    goto _jump60;
    _jump50:;
    int64_t _157 = 571;
    _142 = _157;
    _jump60:;
    _138.d0 = _142;
    if (_142 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing bound for b
    int64_t _158 = 189;
    _138.d1 = _158;
    if (_158 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    // Computing bound for c
    int64_t _159 = 698;
    int64_t _160;
    // Computing bound for a
    int64_t _161 = 502;
    if (_161 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing bound for b
    int64_t _162 = 1000;
    if (_162 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    _160 = 0;
    int64_t _163 = 0; // b
    int64_t _164 = 0; // a
    _jump65:; // Begin body of loop
    _160 += _163;
    _163++;
    if (_163 < _162)
    goto _jump65;
    _163 = 0;
    _164++;
    if (_164 < _161)
    goto _jump65;
    // End body of loop
    int64_t _165 = _159 - _160;
    int64_t _166;
    // Computing bound for a
    int64_t _167 = 268;
    int64_t _168 = -_167;
    if (_168 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    _166 = 0;
    int64_t _169 = 0; // a
    _jump67:; // Begin body of loop
    int64_t _170 = -_169;
    _166 += _170;
    _169++;
    if (_169 < _168)
    goto _jump67;
    // End body of loop
    int64_t _171 = _165 / _166;
    _138.d2 = _171;
    if (_171 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= _142;
    _172 *= _158;
    _172 *= _171;
    _172 *= sizeof(_a3_bool);
    _138.data = jpl_alloc(_172);
    int64_t _173 = 0; // c
    int64_t _174 = 0; // b
    int64_t _175 = 0; // a
    _jump69:; // Begin body of loop
    int64_t _176 = 611;
    int64_t _177 = -_175;
    bool _178 = _176 != _177;
    _a3_bool _179;
    if (!_178)
    goto _jump70;
    _a3_bool _180;
    // Computing bound for d
    _180.d0 = _173;
    if (_173 > 0) 
    goto _jump71;
    fail_assertion("non-positive loop bound");
    _jump71:;
    // Computing bound for e
    _180.d1 = _173;
    if (_173 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing bound for f
    _180.d2 = _174;
    if (_174 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= _173;
    _181 *= _173;
    _181 *= _174;
    _181 *= sizeof(bool);
    _180.data = jpl_alloc(_181);
    int64_t _182 = 0; // f
    int64_t _183 = 0; // e
    int64_t _184 = 0; // d
    _jump74:; // Begin body of loop
    bool _185 = true;
    bool _186 = !_185;
    int64_t _187 = 0;
    _187 *= _180.d0;
    _187 += _184;
    _187 *= _180.d1;
    _187 += _183;
    _187 *= _180.d2;
    _187 += _182;
    _180.data[_187] = _186;
    _182++;
    if (_182 < _174)
    goto _jump74;
    _182 = 0;
    _183++;
    if (_183 < _173)
    goto _jump74;
    _183 = 0;
    _184++;
    if (_184 < _173)
    goto _jump74;
    // End body of loop
    _179 = _180;
    goto _jump75;
    _jump70:;
    _a3_bool _188;
    // Computing bound for d
    _188.d0 = _175;
    if (_175 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for e
    _188.d1 = _175;
    if (_175 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    // Computing bound for f
    int64_t _189 = 444;
    int64_t _190 = _189 / _175;
    _188.d2 = _190;
    if (_190 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing total size of heap memory to allocate
    int64_t _191 = 1;
    _191 *= _175;
    _191 *= _175;
    _191 *= _190;
    _191 *= sizeof(bool);
    _188.data = jpl_alloc(_191);
    int64_t _192 = 0; // f
    int64_t _193 = 0; // e
    int64_t _194 = 0; // d
    _jump79:; // Begin body of loop
    bool _195 = false;
    int64_t _196 = 0;
    _196 *= _188.d0;
    _196 += _194;
    _196 *= _188.d1;
    _196 += _193;
    _196 *= _188.d2;
    _196 += _192;
    _188.data[_196] = _195;
    _192++;
    if (_192 < _190)
    goto _jump79;
    _192 = 0;
    _193++;
    if (_193 < _175)
    goto _jump79;
    _193 = 0;
    _194++;
    if (_194 < _175)
    goto _jump79;
    // End body of loop
    _179 = _188;
    _jump75:;
    int64_t _197 = 0;
    _197 *= _138.d0;
    _197 += _175;
    _197 *= _138.d1;
    _197 += _174;
    _197 *= _138.d2;
    _197 += _173;
    _138.data[_197] = _179;
    _173++;
    if (_173 < _171)
    goto _jump69;
    _173 = 0;
    _174++;
    if (_174 < _158)
    goto _jump69;
    _174 = 0;
    _175++;
    if (_175 < _142)
    goto _jump69;
    // End body of loop
    int64_t _198;
    // Computing bound for a
    int64_t _199;
    // Computing bound for a
    int64_t _200 = 912;
    if (_200 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    _199 = 0;
    int64_t _201 = 0; // a
    _jump81:; // Begin body of loop
    _199 += _201;
    _201++;
    if (_201 < _200)
    goto _jump81;
    // End body of loop
    int64_t _202 = -_199;
    int64_t _203 = 16;
    int64_t _204 = -_203;
    int64_t _205 = _202 + _204;
    if (_205 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    _198 = 0;
    int64_t _206 = 0; // a
    _jump83:; // Begin body of loop
    int64_t _207 = 408;
    _198 += _207;
    _206++;
    if (_206 < _205)
    goto _jump83;
    // End body of loop
    int64_t _208;
    // Computing bound for a
    int64_t _209 = 852;
    int64_t _210 = -_209;
    int64_t _211 = -_210;
    int64_t _212 = 353;
    int64_t _213 = _211 % _212;
    if (_213 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    // Computing bound for b
    bool _214 = true;
    int64_t _215;
    if (!_214)
    goto _jump85;
    int64_t _216 = 666;
    _215 = _216;
    goto _jump86;
    _jump85:;
    int64_t _217 = 925;
    int64_t _218 = 652;
    int64_t _219 = _217 * _218;
    _215 = _219;
    _jump86:;
    if (_215 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    // Computing bound for c
    int64_t _220 = 710;
    int64_t _221 = 203;
    int64_t _222 = -_221;
    int64_t _223 = _220 / _222;
    int64_t _224 = -_223;
    if (_224 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    _208 = 0;
    int64_t _225 = 0; // c
    int64_t _226 = 0; // b
    int64_t _227 = 0; // a
    _jump89:; // Begin body of loop
    int64_t _228;
    // Computing bound for d
    int64_t _229;
    // Computing bound for d
    if (_225 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing bound for e
    if (_226 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    _229 = 0;
    int64_t _230 = 0; // e
    int64_t _231 = 0; // d
    _jump92:; // Begin body of loop
    _229 += _226;
    _230++;
    if (_230 < _226)
    goto _jump92;
    _230 = 0;
    _231++;
    if (_231 < _225)
    goto _jump92;
    // End body of loop
    if (_229 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing bound for e
    if (_226 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    _228 = 0;
    int64_t _232 = 0; // e
    int64_t _233 = 0; // d
    _jump95:; // Begin body of loop
    _228 += _227;
    _232++;
    if (_232 < _226)
    goto _jump95;
    _232 = 0;
    _233++;
    if (_233 < _229)
    goto _jump95;
    // End body of loop
    int64_t _234 = -_228;
    _208 += _234;
    _225++;
    if (_225 < _224)
    goto _jump89;
    _225 = 0;
    _226++;
    if (_226 < _215)
    goto _jump89;
    _226 = 0;
    _227++;
    if (_227 < _213)
    goto _jump89;
    // End body of loop
    int64_t _235;
    // Computing bound for a
    int64_t _236 = 588;
    int64_t _237 = -_236;
    int64_t _238 = -_237;
    if (_238 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing bound for b
    bool _240 = true;
    bool _239 = _240;
    if (0 != _240)
    goto _jump97;
    bool _241 = true;
    _239 = _241;
    _jump97:;
    int64_t _242;
    if (!_239)
    goto _jump98;
    int64_t _243 = 442;
    _242 = _243;
    goto _jump99;
    _jump98:;
    int64_t _244 = 384;
    int64_t _245 = -_244;
    _242 = _245;
    _jump99:;
    int64_t _246 = -_242;
    if (_246 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    // Computing bound for c
    int64_t _247 = 233;
    if (_247 > 0) 
    goto _jump101;
    fail_assertion("non-positive loop bound");
    _jump101:;
    _235 = 0;
    int64_t _248 = 0; // c
    int64_t _249 = 0; // b
    int64_t _250 = 0; // a
    _jump102:; // Begin body of loop
    int64_t _251;
    // Computing bound for d
    int64_t _252;
    // Computing bound for d
    if (_248 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    _252 = 0;
    int64_t _253 = 0; // d
    _jump104:; // Begin body of loop
    _252 += _253;
    _253++;
    if (_253 < _248)
    goto _jump104;
    // End body of loop
    if (_252 > 0) 
    goto _jump105;
    fail_assertion("non-positive loop bound");
    _jump105:;
    // Computing bound for e
    if (_249 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    _251 = 0;
    int64_t _254 = 0; // e
    int64_t _255 = 0; // d
    _jump107:; // Begin body of loop
    _251 += _254;
    _254++;
    if (_254 < _249)
    goto _jump107;
    _254 = 0;
    _255++;
    if (_255 < _252)
    goto _jump107;
    // End body of loop
    int64_t _256 = -_251;
    _235 += _256;
    _248++;
    if (_248 < _247)
    goto _jump102;
    _248 = 0;
    _249++;
    if (_249 < _246)
    goto _jump102;
    _249 = 0;
    _250++;
    if (_250 < _238)
    goto _jump102;
    // End body of loop
    if (_198 >= 0)
    goto _jump108;
    fail_assertion("negative array index");
    _jump108:;
    if (_198 < _138.d0)
    goto _jump109;
    fail_assertion("index too large");
    _jump109:;
    if (_208 >= 0)
    goto _jump110;
    fail_assertion("negative array index");
    _jump110:;
    if (_208 < _138.d1)
    goto _jump111;
    fail_assertion("index too large");
    _jump111:;
    if (_235 >= 0)
    goto _jump112;
    fail_assertion("negative array index");
    _jump112:;
    if (_235 < _138.d2)
    goto _jump113;
    fail_assertion("index too large");
    _jump113:;
    int64_t _257 = 0;
    _257 *= _138.d0;
    _257 += _198;
    _257 *= _138.d1;
    _257 += _208;
    _257 *= _138.d2;
    _257 += _235;
    _a3_bool _258 = _138.data[_257];
    bool _259 = true;
    int64_t _260;
    if (!_259)
    goto _jump114;
    int64_t _261 = 324;
    int64_t _262 = -_261;
    int64_t _263 = 856;
    int64_t _264 = _262 + _263;
    int64_t _265 = -_264;
    _260 = _265;
    goto _jump115;
    _jump114:;
    bool _266 = false;
    int64_t _267;
    if (!_266)
    goto _jump116;
    bool _268 = true;
    int64_t _269;
    if (!_268)
    goto _jump117;
    int64_t _270 = 202;
    _269 = _270;
    goto _jump118;
    _jump117:;
    int64_t _271 = 939;
    _269 = _271;
    _jump118:;
    _267 = _269;
    goto _jump119;
    _jump116:;
    int64_t _272 = 454;
    _267 = _272;
    _jump119:;
    int64_t _273 = 477;
    int64_t _274 = _267 * _273;
    _260 = _274;
    _jump115:;
    int64_t _275;
    // Computing bound for a
    int64_t _276 = 393;
    int64_t _277 = -_276;
    if (_277 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    _275 = 0;
    int64_t _278 = 0; // a
    _jump121:; // Begin body of loop
    int64_t _279 = 522;
    int64_t _280 = _279 - _278;
    _275 += _280;
    _278++;
    if (_278 < _277)
    goto _jump121;
    // End body of loop
    int64_t _281 = 408;
    int64_t _282 = -_281;
    int64_t _283 = _275 - _282;
    int64_t _284;
    // Computing bound for a
    bool _285 = true;
    int64_t _286;
    if (!_285)
    goto _jump122;
    int64_t _287;
    // Computing bound for a
    int64_t _288 = 236;
    int64_t _289 = 602;
    int64_t _290 = _288 * _289;
    if (_290 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    _287 = 0;
    int64_t _291 = 0; // a
    _jump124:; // Begin body of loop
    int64_t _292 = 864;
    int64_t _293 = -_292;
    int64_t _294 = _293 - _291;
    _287 += _294;
    _291++;
    if (_291 < _290)
    goto _jump124;
    // End body of loop
    _286 = _287;
    goto _jump125;
    _jump122:;
    int64_t _295;
    // Computing bound for a
    int64_t _296 = 951;
    int64_t _297 = -_296;
    if (_297 > 0) 
    goto _jump126;
    fail_assertion("non-positive loop bound");
    _jump126:;
    _295 = 0;
    int64_t _298 = 0; // a
    _jump127:; // Begin body of loop
    int64_t _299 = 541;
    int64_t _300 = _299 % _298;
    int64_t _301 = _300 / _298;
    _295 += _301;
    _298++;
    if (_298 < _297)
    goto _jump127;
    // End body of loop
    _286 = _295;
    _jump125:;
    if (_286 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    _284 = 0;
    int64_t _302 = 0; // a
    _jump129:; // Begin body of loop
    _284 += _302;
    _302++;
    if (_302 < _286)
    goto _jump129;
    // End body of loop
    if (_260 >= 0)
    goto _jump130;
    fail_assertion("negative array index");
    _jump130:;
    if (_260 < _258.d0)
    goto _jump131;
    fail_assertion("index too large");
    _jump131:;
    if (_283 >= 0)
    goto _jump132;
    fail_assertion("negative array index");
    _jump132:;
    if (_283 < _258.d1)
    goto _jump133;
    fail_assertion("index too large");
    _jump133:;
    if (_284 >= 0)
    goto _jump134;
    fail_assertion("negative array index");
    _jump134:;
    if (_284 < _258.d2)
    goto _jump135;
    fail_assertion("index too large");
    _jump135:;
    int64_t _303 = 0;
    _303 *= _258.d0;
    _303 += _260;
    _303 *= _258.d1;
    _303 += _283;
    _303 *= _258.d2;
    _303 += _284;
    bool _304 = _258.data[_303];
    _a1_bool _305;
    _305.d0 = 3;
    _305.data = jpl_alloc(sizeof(bool) * 3);
    _305.data[0] = _0;
    _305.data[1] = _137;
    _305.data[2] = _304;
    bool _307 = false;
    bool _306 = _307;
    if (0 != _307)
    goto _jump347;
    bool _308 = false;
    _306 = _308;
    _jump347:;
    _a3_double _309;
    if (!_306)
    goto _jump348;
    _a2_bool _311;
    // Computing bound for d
    int64_t _312 = 87;
    int64_t _313 = -_312;
    int64_t _314;
    // Computing bound for d
    int64_t _315 = 317;
    if (_315 > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing bound for e
    int64_t _316 = 134;
    if (_316 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    _314 = 0;
    int64_t _317 = 0; // e
    int64_t _318 = 0; // d
    _jump351:; // Begin body of loop
    _314 += _318;
    _317++;
    if (_317 < _316)
    goto _jump351;
    _317 = 0;
    _318++;
    if (_318 < _315)
    goto _jump351;
    // End body of loop
    int64_t _319 = _313 / _314;
    _311.d0 = _319;
    if (_319 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    // Computing bound for e
    _a1_int64_t _320;
    // Computing bound for d
    int64_t _321 = 261;
    _320.d0 = _321;
    if (_321 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    // Computing total size of heap memory to allocate
    int64_t _322 = 1;
    _322 *= _321;
    _322 *= sizeof(int64_t);
    _320.data = jpl_alloc(_322);
    int64_t _323 = 0; // d
    _jump354:; // Begin body of loop
    int64_t _324 = 0;
    _324 *= _320.d0;
    _324 += _323;
    _320.data[_324] = _323;
    _323++;
    if (_323 < _321)
    goto _jump354;
    // End body of loop
    int64_t _325 = 917;
    if (_325 >= 0)
    goto _jump355;
    fail_assertion("negative array index");
    _jump355:;
    if (_325 < _320.d0)
    goto _jump356;
    fail_assertion("index too large");
    _jump356:;
    int64_t _326 = 0;
    _326 *= _320.d0;
    _326 += _325;
    int64_t _327 = _320.data[_326];
    _311.d1 = _327;
    if (_327 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    // Computing total size of heap memory to allocate
    int64_t _328 = 1;
    _328 *= _319;
    _328 *= _327;
    _328 *= sizeof(bool);
    _311.data = jpl_alloc(_328);
    int64_t _329 = 0; // e
    int64_t _330 = 0; // d
    _jump358:; // Begin body of loop
    int64_t _331;
    // Computing bound for f
    if (_329 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing bound for g
    if (_329 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing bound for h
    int64_t _332 = 136;
    if (_332 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    _331 = 0;
    int64_t _333 = 0; // h
    int64_t _334 = 0; // g
    int64_t _335 = 0; // f
    _jump362:; // Begin body of loop
    _331 += _333;
    _333++;
    if (_333 < _332)
    goto _jump362;
    _333 = 0;
    _334++;
    if (_334 < _329)
    goto _jump362;
    _334 = 0;
    _335++;
    if (_335 < _329)
    goto _jump362;
    // End body of loop
    if (_331 >= 0)
    goto _jump363;
    fail_assertion("negative array index");
    _jump363:;
    if (_331 < _305.d0)
    goto _jump364;
    fail_assertion("index too large");
    _jump364:;
    int64_t _336 = 0;
    _336 *= _305.d0;
    _336 += _331;
    bool _337 = _305.data[_336];
    int64_t _338 = 0;
    _338 *= _311.d0;
    _338 += _330;
    _338 *= _311.d1;
    _338 += _329;
    _311.data[_338] = _337;
    _329++;
    if (_329 < _327)
    goto _jump358;
    _329 = 0;
    _330++;
    if (_330 < _319)
    goto _jump358;
    // End body of loop
    _a3_int64_t _339;
    // Computing bound for d
    int64_t _340 = 895;
    int64_t _341 = 751;
    int64_t _342 = _340 - _341;
    _339.d0 = _342;
    if (_342 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    // Computing bound for e
    int64_t _343 = 669;
    _339.d1 = _343;
    if (_343 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing bound for f
    int64_t _344 = 826;
    _339.d2 = _344;
    if (_344 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing total size of heap memory to allocate
    int64_t _345 = 1;
    _345 *= _342;
    _345 *= _343;
    _345 *= _344;
    _345 *= sizeof(int64_t);
    _339.data = jpl_alloc(_345);
    int64_t _346 = 0; // f
    int64_t _347 = 0; // e
    int64_t _348 = 0; // d
    _jump368:; // Begin body of loop
    bool _349 = false;
    int64_t _350;
    if (!_349)
    goto _jump369;
    _350 = _346;
    goto _jump370;
    _jump369:;
    int64_t _351 = 92;
    _350 = _351;
    _jump370:;
    int64_t _352 = 0;
    _352 *= _339.d0;
    _352 += _348;
    _352 *= _339.d1;
    _352 += _347;
    _352 *= _339.d2;
    _352 += _346;
    _339.data[_352] = _350;
    _346++;
    if (_346 < _344)
    goto _jump368;
    _346 = 0;
    _347++;
    if (_347 < _343)
    goto _jump368;
    _347 = 0;
    _348++;
    if (_348 < _342)
    goto _jump368;
    // End body of loop
    int64_t _353;
    // Computing bound for d
    int64_t _354 = 205;
    if (_354 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    _353 = 0;
    int64_t _355 = 0; // d
    _jump372:; // Begin body of loop
    int64_t _356 = 967;
    int64_t _357 = -_356;
    _353 += _357;
    _355++;
    if (_355 < _354)
    goto _jump372;
    // End body of loop
    int64_t _358 = 985;
    int64_t _359 = 416;
    int64_t _360 = -_359;
    int64_t _361 = _358 + _360;
    int64_t _362 = 686;
    if (_353 >= 0)
    goto _jump373;
    fail_assertion("negative array index");
    _jump373:;
    if (_353 < _339.d0)
    goto _jump374;
    fail_assertion("index too large");
    _jump374:;
    if (_361 >= 0)
    goto _jump375;
    fail_assertion("negative array index");
    _jump375:;
    if (_361 < _339.d1)
    goto _jump376;
    fail_assertion("index too large");
    _jump376:;
    if (_362 >= 0)
    goto _jump377;
    fail_assertion("negative array index");
    _jump377:;
    if (_362 < _339.d2)
    goto _jump378;
    fail_assertion("index too large");
    _jump378:;
    int64_t _363 = 0;
    _363 *= _339.d0;
    _363 += _353;
    _363 *= _339.d1;
    _363 += _361;
    _363 *= _339.d2;
    _363 += _362;
    int64_t _364 = _339.data[_363];
    int64_t _365 = 932;
    if (_364 >= 0)
    goto _jump379;
    fail_assertion("negative array index");
    _jump379:;
    if (_364 < _311.d0)
    goto _jump380;
    fail_assertion("index too large");
    _jump380:;
    if (_365 >= 0)
    goto _jump381;
    fail_assertion("negative array index");
    _jump381:;
    if (_365 < _311.d1)
    goto _jump382;
    fail_assertion("index too large");
    _jump382:;
    int64_t _366 = 0;
    _366 *= _311.d0;
    _366 += _364;
    _366 *= _311.d1;
    _366 += _365;
    bool _367 = _311.data[_366];
    bool _310 = _367;
    if (0 != _367)
    goto _jump383;
    bool _368 = true;
    _310 = _368;
    _jump383:;
    _a3_double _369;
    if (!_310)
    goto _jump384;
    _a3_double _370;
    // Computing bound for d
    bool _371 = false;
    int64_t _372;
    if (!_371)
    goto _jump385;
    int64_t _373 = 793;
    _372 = _373;
    goto _jump386;
    _jump385:;
    int64_t _374 = 873;
    _372 = _374;
    _jump386:;
    int64_t _375 = -_372;
    _370.d0 = _375;
    if (_375 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    // Computing bound for e
    int64_t _376 = 376;
    _370.d1 = _376;
    if (_376 > 0) 
    goto _jump388;
    fail_assertion("non-positive loop bound");
    _jump388:;
    // Computing bound for f
    int64_t _377 = 462;
    _370.d2 = _377;
    if (_377 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing total size of heap memory to allocate
    int64_t _378 = 1;
    _378 *= _375;
    _378 *= _376;
    _378 *= _377;
    _378 *= sizeof(double);
    _370.data = jpl_alloc(_378);
    int64_t _379 = 0; // f
    int64_t _380 = 0; // e
    int64_t _381 = 0; // d
    _jump390:; // Begin body of loop
    double _382 = 68.0;
    int64_t _383 = 0;
    _383 *= _370.d0;
    _383 += _381;
    _383 *= _370.d1;
    _383 += _380;
    _383 *= _370.d2;
    _383 += _379;
    _370.data[_383] = _382;
    _379++;
    if (_379 < _377)
    goto _jump390;
    _379 = 0;
    _380++;
    if (_380 < _376)
    goto _jump390;
    _380 = 0;
    _381++;
    if (_381 < _375)
    goto _jump390;
    // End body of loop
    _a3_double _384;
    // Computing bound for d
    int64_t _385 = 590;
    _384.d0 = _385;
    if (_385 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for e
    int64_t _386 = 886;
    int64_t _387 = -_386;
    _384.d1 = _387;
    if (_387 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing bound for f
    int64_t _388;
    // Computing bound for d
    int64_t _389 = 390;
    if (_389 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing bound for e
    int64_t _390 = 138;
    if (_390 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing bound for f
    int64_t _391 = 889;
    if (_391 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    _388 = 0;
    int64_t _392 = 0; // f
    int64_t _393 = 0; // e
    int64_t _394 = 0; // d
    _jump396:; // Begin body of loop
    bool _395 = false;
    int64_t _396;
    if (!_395)
    goto _jump397;
    int64_t _397 = 382;
    _396 = _397;
    goto _jump398;
    _jump397:;
    int64_t _398 = 618;
    _396 = _398;
    _jump398:;
    _388 += _396;
    _392++;
    if (_392 < _391)
    goto _jump396;
    _392 = 0;
    _393++;
    if (_393 < _390)
    goto _jump396;
    _393 = 0;
    _394++;
    if (_394 < _389)
    goto _jump396;
    // End body of loop
    _384.d2 = _388;
    if (_388 > 0) 
    goto _jump399;
    fail_assertion("non-positive loop bound");
    _jump399:;
    // Computing total size of heap memory to allocate
    int64_t _399 = 1;
    _399 *= _385;
    _399 *= _387;
    _399 *= _388;
    _399 *= sizeof(double);
    _384.data = jpl_alloc(_399);
    int64_t _400 = 0; // f
    int64_t _401 = 0; // e
    int64_t _402 = 0; // d
    _jump400:; // Begin body of loop
    double _403;
    // Computing bound for g
    if (_400 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    _403 = 0;
    int64_t _404 = 0; // g
    _jump402:; // Begin body of loop
    double _405 = 29.0;
    _403 += _405;
    _404++;
    if (_404 < _400)
    goto _jump402;
    // End body of loop
    int64_t _406 = 0;
    _406 *= _384.d0;
    _406 += _402;
    _406 *= _384.d1;
    _406 += _401;
    _406 *= _384.d2;
    _406 += _400;
    _384.data[_406] = _403;
    _400++;
    if (_400 < _388)
    goto _jump400;
    _400 = 0;
    _401++;
    if (_401 < _387)
    goto _jump400;
    _401 = 0;
    _402++;
    if (_402 < _385)
    goto _jump400;
    // End body of loop
    _a3_double _407;
    // Computing bound for d
    int64_t _408 = 928;
    _407.d0 = _408;
    if (_408 > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    // Computing bound for e
    int64_t _409;
    // Computing bound for d
    int64_t _410 = 962;
    if (_410 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    _409 = 0;
    int64_t _411 = 0; // d
    _jump405:; // Begin body of loop
    int64_t _412 = 872;
    _409 += _412;
    _411++;
    if (_411 < _410)
    goto _jump405;
    // End body of loop
    _407.d1 = _409;
    if (_409 > 0) 
    goto _jump406;
    fail_assertion("non-positive loop bound");
    _jump406:;
    // Computing bound for f
    int64_t _413;
    // Computing bound for d
    int64_t _414 = 623;
    int64_t _415 = -_414;
    if (_415 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    _413 = 0;
    int64_t _416 = 0; // d
    _jump408:; // Begin body of loop
    int64_t _417 = 141;
    _413 += _417;
    _416++;
    if (_416 < _415)
    goto _jump408;
    // End body of loop
    _407.d2 = _413;
    if (_413 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    // Computing total size of heap memory to allocate
    int64_t _418 = 1;
    _418 *= _408;
    _418 *= _409;
    _418 *= _413;
    _418 *= sizeof(double);
    _407.data = jpl_alloc(_418);
    int64_t _419 = 0; // f
    int64_t _420 = 0; // e
    int64_t _421 = 0; // d
    _jump410:; // Begin body of loop
    double _422 = 96.0;
    int64_t _423 = 0;
    _423 *= _407.d0;
    _423 += _421;
    _423 *= _407.d1;
    _423 += _420;
    _423 *= _407.d2;
    _423 += _419;
    _407.data[_423] = _422;
    _419++;
    if (_419 < _413)
    goto _jump410;
    _419 = 0;
    _420++;
    if (_420 < _409)
    goto _jump410;
    _420 = 0;
    _421++;
    if (_421 < _408)
    goto _jump410;
    // End body of loop
    _a1__a3_double _424;
    _424.d0 = 3;
    _424.data = jpl_alloc(sizeof(_a3_double) * 3);
    _424.data[0] = _370;
    _424.data[1] = _384;
    _424.data[2] = _407;
    int64_t _425 = 812;
    if (_425 >= 0)
    goto _jump411;
    fail_assertion("negative array index");
    _jump411:;
    if (_425 < _424.d0)
    goto _jump412;
    fail_assertion("index too large");
    _jump412:;
    int64_t _426 = 0;
    _426 *= _424.d0;
    _426 += _425;
    _a3_double _427 = _424.data[_426];
    _369 = _427;
    goto _jump413;
    _jump384:;
    _a3_double _428;
    // Computing bound for d
    double _429 = 48.0;
    double _430 = -_429;
    double _431 = 74.0;
    double _432 = fmod(_430, _431);
    double _433 = 66.0;
    bool _434 = _432 > _433;
    int64_t _435;
    if (!_434)
    goto _jump414;
    int64_t _436 = 636;
    _435 = _436;
    goto _jump415;
    _jump414:;
    bool _437 = true;
    int64_t _438;
    if (!_437)
    goto _jump416;
    int64_t _439 = 882;
    _438 = _439;
    goto _jump417;
    _jump416:;
    int64_t _440 = 732;
    _438 = _440;
    _jump417:;
    _435 = _438;
    _jump415:;
    _428.d0 = _435;
    if (_435 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing bound for e
    int64_t _441;
    // Computing bound for d
    int64_t _442 = 204;
    if (_442 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    _441 = 0;
    int64_t _443 = 0; // d
    _jump420:; // Begin body of loop
    _441 += _443;
    _443++;
    if (_443 < _442)
    goto _jump420;
    // End body of loop
    int64_t _444 = -_441;
    int64_t _445 = 165;
    int64_t _446 = -_445;
    int64_t _447 = _444 % _446;
    _428.d1 = _447;
    if (_447 > 0) 
    goto _jump421;
    fail_assertion("non-positive loop bound");
    _jump421:;
    // Computing bound for f
    int64_t _448;
    // Computing bound for d
    int64_t _449 = 557;
    if (_449 > 0) 
    goto _jump422;
    fail_assertion("non-positive loop bound");
    _jump422:;
    _448 = 0;
    int64_t _450 = 0; // d
    _jump423:; // Begin body of loop
    bool _451 = true;
    int64_t _452;
    if (!_451)
    goto _jump424;
    _452 = _450;
    goto _jump425;
    _jump424:;
    int64_t _453 = 183;
    _452 = _453;
    _jump425:;
    _448 += _452;
    _450++;
    if (_450 < _449)
    goto _jump423;
    // End body of loop
    if (_448 >= 0)
    goto _jump426;
    fail_assertion("negative array index");
    _jump426:;
    if (_448 < _305.d0)
    goto _jump427;
    fail_assertion("index too large");
    _jump427:;
    int64_t _454 = 0;
    _454 *= _305.d0;
    _454 += _448;
    bool _455 = _305.data[_454];
    int64_t _456;
    if (!_455)
    goto _jump428;
    bool _457 = false;
    bool _458 = !_457;
    bool _459 = !_458;
    int64_t _460;
    if (!_459)
    goto _jump429;
    int64_t _461 = 143;
    int64_t _462 = -_461;
    int64_t _463 = -_462;
    _460 = _463;
    goto _jump430;
    _jump429:;
    int64_t _464 = 699;
    int64_t _465 = 97;
    int64_t _466 = _464 * _465;
    int64_t _467 = 320;
    int64_t _468 = 623;
    int64_t _469 = _467 + _468;
    int64_t _470 = _466 % _469;
    _460 = _470;
    _jump430:;
    _456 = _460;
    goto _jump431;
    _jump428:;
    int64_t _471 = 600;
    _456 = _471;
    _jump431:;
    _428.d2 = _456;
    if (_456 > 0) 
    goto _jump432;
    fail_assertion("non-positive loop bound");
    _jump432:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _435;
    _472 *= _447;
    _472 *= _456;
    _472 *= sizeof(double);
    _428.data = jpl_alloc(_472);
    int64_t _473 = 0; // f
    int64_t _474 = 0; // e
    int64_t _475 = 0; // d
    _jump433:; // Begin body of loop
    double _476;
    // Computing bound for g
    int64_t _477 = 556;
    int64_t _478 = _477 % _473;
    int64_t _479 = 506;
    int64_t _480 = -_479;
    int64_t _481 = _478 - _480;
    if (_481 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing bound for h
    if (_475 > 0) 
    goto _jump435;
    fail_assertion("non-positive loop bound");
    _jump435:;
    _476 = 0;
    int64_t _482 = 0; // h
    int64_t _483 = 0; // g
    _jump436:; // Begin body of loop
    double _484 = 65.0;
    _476 += _484;
    _482++;
    if (_482 < _475)
    goto _jump436;
    _482 = 0;
    _483++;
    if (_483 < _481)
    goto _jump436;
    // End body of loop
    _a1_double _485;
    // Computing bound for g
    _485.d0 = _474;
    if (_474 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _486 = 1;
    _486 *= _474;
    _486 *= sizeof(double);
    _485.data = jpl_alloc(_486);
    int64_t _487 = 0; // g
    _jump438:; // Begin body of loop
    double _488 = 61.0;
    double _489 = -_488;
    int64_t _490 = 0;
    _490 *= _485.d0;
    _490 += _487;
    _485.data[_490] = _489;
    _487++;
    if (_487 < _474)
    goto _jump438;
    // End body of loop
    bool _491 = false;
    int64_t _492;
    if (!_491)
    goto _jump439;
    int64_t _493 = 554;
    _492 = _493;
    goto _jump440;
    _jump439:;
    _492 = _473;
    _jump440:;
    int64_t _494 = _474 - _492;
    if (_494 >= 0)
    goto _jump441;
    fail_assertion("negative array index");
    _jump441:;
    if (_494 < _485.d0)
    goto _jump442;
    fail_assertion("index too large");
    _jump442:;
    int64_t _495 = 0;
    _495 *= _485.d0;
    _495 += _494;
    double _496 = _485.data[_495];
    double _497 = fmod(_476, _496);
    int64_t _498 = 0;
    _498 *= _428.d0;
    _498 += _475;
    _498 *= _428.d1;
    _498 += _474;
    _498 *= _428.d2;
    _498 += _473;
    _428.data[_498] = _497;
    _473++;
    if (_473 < _456)
    goto _jump433;
    _473 = 0;
    _474++;
    if (_474 < _447)
    goto _jump433;
    _474 = 0;
    _475++;
    if (_475 < _435)
    goto _jump433;
    // End body of loop
    _369 = _428;
    _jump413:;
    _309 = _369;
    goto _jump443;
    _jump348:;
    _a2__a3_double _499;
    // Computing bound for d
    int64_t _500;
    // Computing bound for d
    _a1_int64_t _501;
    // Computing bound for d
    int64_t _502 = 214;
    _501.d0 = _502;
    if (_502 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing total size of heap memory to allocate
    int64_t _503 = 1;
    _503 *= _502;
    _503 *= sizeof(int64_t);
    _501.data = jpl_alloc(_503);
    int64_t _504 = 0; // d
    _jump445:; // Begin body of loop
    int64_t _505 = 0;
    _505 *= _501.d0;
    _505 += _504;
    _501.data[_505] = _504;
    _504++;
    if (_504 < _502)
    goto _jump445;
    // End body of loop
    int64_t _506 = 244;
    int64_t _507 = -_506;
    if (_507 >= 0)
    goto _jump446;
    fail_assertion("negative array index");
    _jump446:;
    if (_507 < _501.d0)
    goto _jump447;
    fail_assertion("index too large");
    _jump447:;
    int64_t _508 = 0;
    _508 *= _501.d0;
    _508 += _507;
    int64_t _509 = _501.data[_508];
    if (_509 > 0) 
    goto _jump448;
    fail_assertion("non-positive loop bound");
    _jump448:;
    _500 = 0;
    int64_t _510 = 0; // d
    _jump449:; // Begin body of loop
    int64_t _511 = 322;
    _500 += _511;
    _510++;
    if (_510 < _509)
    goto _jump449;
    // End body of loop
    int64_t _512;
    // Computing bound for d
    int64_t _513 = 889;
    if (_513 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    _512 = 0;
    int64_t _514 = 0; // d
    _jump451:; // Begin body of loop
    int64_t _515 = 629;
    int64_t _516 = -_515;
    int64_t _517 = _514 + _516;
    _512 += _517;
    _514++;
    if (_514 < _513)
    goto _jump451;
    // End body of loop
    int64_t _518 = _500 * _512;
    _499.d0 = _518;
    if (_518 > 0) 
    goto _jump452;
    fail_assertion("non-positive loop bound");
    _jump452:;
    // Computing bound for e
    _a3_int64_t _519;
    // Computing bound for d
    int64_t _520 = 62;
    int64_t _521 = -_520;
    int64_t _522 = -_521;
    _519.d0 = _522;
    if (_522 > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    // Computing bound for e
    int64_t _523 = 683;
    _519.d1 = _523;
    if (_523 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing bound for f
    int64_t _524 = 875;
    int64_t _525 = 944;
    int64_t _526 = _524 + _525;
    int64_t _527 = -_526;
    _519.d2 = _527;
    if (_527 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing total size of heap memory to allocate
    int64_t _528 = 1;
    _528 *= _522;
    _528 *= _523;
    _528 *= _527;
    _528 *= sizeof(int64_t);
    _519.data = jpl_alloc(_528);
    int64_t _529 = 0; // f
    int64_t _530 = 0; // e
    int64_t _531 = 0; // d
    _jump456:; // Begin body of loop
    int64_t _532;
    // Computing bound for g
    int64_t _533 = -_531;
    if (_533 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    _532 = 0;
    int64_t _534 = 0; // g
    _jump458:; // Begin body of loop
    _532 += _529;
    _534++;
    if (_534 < _533)
    goto _jump458;
    // End body of loop
    int64_t _535 = 0;
    _535 *= _519.d0;
    _535 += _531;
    _535 *= _519.d1;
    _535 += _530;
    _535 *= _519.d2;
    _535 += _529;
    _519.data[_535] = _532;
    _529++;
    if (_529 < _527)
    goto _jump456;
    _529 = 0;
    _530++;
    if (_530 < _523)
    goto _jump456;
    _530 = 0;
    _531++;
    if (_531 < _522)
    goto _jump456;
    // End body of loop
    int64_t _536;
    // Computing bound for d
    int64_t _537 = 863;
    int64_t _538 = -_537;
    if (_538 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    _536 = 0;
    int64_t _539 = 0; // d
    _jump460:; // Begin body of loop
    int64_t _540;
    // Computing bound for e
    if (_539 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for f
    int64_t _541 = 616;
    if (_541 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing bound for g
    if (_539 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    _540 = 0;
    int64_t _542 = 0; // g
    int64_t _543 = 0; // f
    int64_t _544 = 0; // e
    _jump464:; // Begin body of loop
    int64_t _545 = 382;
    _540 += _545;
    _542++;
    if (_542 < _539)
    goto _jump464;
    _542 = 0;
    _543++;
    if (_543 < _541)
    goto _jump464;
    _543 = 0;
    _544++;
    if (_544 < _539)
    goto _jump464;
    // End body of loop
    int64_t _546 = _539 / _540;
    _536 += _546;
    _539++;
    if (_539 < _538)
    goto _jump460;
    // End body of loop
    int64_t _547 = 330;
    int64_t _548 = 386;
    int64_t _549;
    // Computing bound for d
    int64_t _550 = 636;
    if (_550 > 0) 
    goto _jump465;
    fail_assertion("non-positive loop bound");
    _jump465:;
    _549 = 0;
    int64_t _551 = 0; // d
    _jump466:; // Begin body of loop
    int64_t _552 = 279;
    _549 += _552;
    _551++;
    if (_551 < _550)
    goto _jump466;
    // End body of loop
    int64_t _553 = 675;
    int64_t _554 = -_553;
    int64_t _555 = _549 % _554;
    int64_t _556 = _548 - _555;
    if (_536 >= 0)
    goto _jump467;
    fail_assertion("negative array index");
    _jump467:;
    if (_536 < _519.d0)
    goto _jump468;
    fail_assertion("index too large");
    _jump468:;
    if (_547 >= 0)
    goto _jump469;
    fail_assertion("negative array index");
    _jump469:;
    if (_547 < _519.d1)
    goto _jump470;
    fail_assertion("index too large");
    _jump470:;
    if (_556 >= 0)
    goto _jump471;
    fail_assertion("negative array index");
    _jump471:;
    if (_556 < _519.d2)
    goto _jump472;
    fail_assertion("index too large");
    _jump472:;
    int64_t _557 = 0;
    _557 *= _519.d0;
    _557 += _536;
    _557 *= _519.d1;
    _557 += _547;
    _557 *= _519.d2;
    _557 += _556;
    int64_t _558 = _519.data[_557];
    _499.d1 = _558;
    if (_558 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing total size of heap memory to allocate
    int64_t _559 = 1;
    _559 *= _518;
    _559 *= _558;
    _559 *= sizeof(_a3_double);
    _499.data = jpl_alloc(_559);
    int64_t _560 = 0; // e
    int64_t _561 = 0; // d
    _jump474:; // Begin body of loop
    _a3_double _562;
    // Computing bound for f
    _562.d0 = _561;
    if (_561 > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing bound for g
    int64_t _563 = 566;
    _562.d1 = _563;
    if (_563 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing bound for h
    _562.d2 = _561;
    if (_561 > 0) 
    goto _jump477;
    fail_assertion("non-positive loop bound");
    _jump477:;
    // Computing total size of heap memory to allocate
    int64_t _564 = 1;
    _564 *= _561;
    _564 *= _563;
    _564 *= _561;
    _564 *= sizeof(double);
    _562.data = jpl_alloc(_564);
    int64_t _565 = 0; // h
    int64_t _566 = 0; // g
    int64_t _567 = 0; // f
    _jump478:; // Begin body of loop
    double _568 = 37.0;
    double _569 = 48.0;
    double _570 = _568 * _569;
    double _571 = -_570;
    int64_t _572 = 0;
    _572 *= _562.d0;
    _572 += _567;
    _572 *= _562.d1;
    _572 += _566;
    _572 *= _562.d2;
    _572 += _565;
    _562.data[_572] = _571;
    _565++;
    if (_565 < _561)
    goto _jump478;
    _565 = 0;
    _566++;
    if (_566 < _563)
    goto _jump478;
    _566 = 0;
    _567++;
    if (_567 < _561)
    goto _jump478;
    // End body of loop
    int64_t _573 = 0;
    _573 *= _499.d0;
    _573 += _561;
    _573 *= _499.d1;
    _573 += _560;
    _499.data[_573] = _562;
    _560++;
    if (_560 < _558)
    goto _jump474;
    _560 = 0;
    _561++;
    if (_561 < _518)
    goto _jump474;
    // End body of loop
    int64_t _574 = 909;
    bool _575 = true;
    int64_t _576;
    if (!_575)
    goto _jump479;
    int64_t _577;
    // Computing bound for d
    int64_t _578 = 748;
    if (_578 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for e
    int64_t _579 = 47;
    if (_579 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    // Computing bound for f
    int64_t _580 = 972;
    if (_580 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    _577 = 0;
    int64_t _581 = 0; // f
    int64_t _582 = 0; // e
    int64_t _583 = 0; // d
    _jump483:; // Begin body of loop
    bool _584 = true;
    int64_t _585;
    if (!_584)
    goto _jump484;
    _585 = _583;
    goto _jump485;
    _jump484:;
    _585 = _582;
    _jump485:;
    _577 += _585;
    _581++;
    if (_581 < _580)
    goto _jump483;
    _581 = 0;
    _582++;
    if (_582 < _579)
    goto _jump483;
    _582 = 0;
    _583++;
    if (_583 < _578)
    goto _jump483;
    // End body of loop
    _576 = _577;
    goto _jump486;
    _jump479:;
    bool _586 = false;
    int64_t _587;
    if (!_586)
    goto _jump487;
    int64_t _588 = 349;
    _587 = _588;
    goto _jump488;
    _jump487:;
    int64_t _589 = 155;
    _587 = _589;
    _jump488:;
    int64_t _590 = 517;
    int64_t _591 = _587 * _590;
    _576 = _591;
    _jump486:;
    bool _592 = _574 >= _576;
    int64_t _593;
    if (!_592)
    goto _jump489;
    bool _595 = true;
    bool _596 = !_595;
    bool _594 = _596;
    if (0 != _596)
    goto _jump490;
    bool _597 = false;
    _594 = _597;
    _jump490:;
    bool _598 = !_594;
    int64_t _599;
    if (!_598)
    goto _jump491;
    int64_t _600 = 627;
    int64_t _601 = 561;
    int64_t _602 = 838;
    int64_t _603 = -_602;
    int64_t _604 = _601 % _603;
    int64_t _605 = _600 % _604;
    _599 = _605;
    goto _jump492;
    _jump491:;
    bool _606 = true;
    int64_t _607;
    if (!_606)
    goto _jump493;
    int64_t _608 = 954;
    _607 = _608;
    goto _jump494;
    _jump493:;
    int64_t _609 = 186;
    _607 = _609;
    _jump494:;
    _599 = _607;
    _jump492:;
    _593 = _599;
    goto _jump495;
    _jump489:;
    bool _610 = false;
    int64_t _611;
    if (!_610)
    goto _jump496;
    _a2_int64_t _612;
    // Computing bound for d
    int64_t _613 = 331;
    int64_t _614 = -_613;
    _612.d0 = _614;
    if (_614 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing bound for e
    int64_t _615 = 511;
    int64_t _616 = -_615;
    _612.d1 = _616;
    if (_616 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing total size of heap memory to allocate
    int64_t _617 = 1;
    _617 *= _614;
    _617 *= _616;
    _617 *= sizeof(int64_t);
    _612.data = jpl_alloc(_617);
    int64_t _618 = 0; // e
    int64_t _619 = 0; // d
    _jump499:; // Begin body of loop
    int64_t _620 = 0;
    _620 *= _612.d0;
    _620 += _619;
    _620 *= _612.d1;
    _620 += _618;
    _612.data[_620] = _619;
    _618++;
    if (_618 < _616)
    goto _jump499;
    _618 = 0;
    _619++;
    if (_619 < _614)
    goto _jump499;
    // End body of loop
    int64_t _621 = 538;
    int64_t _622 = -_621;
    int64_t _623;
    // Computing bound for d
    int64_t _624 = 803;
    if (_624 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    _623 = 0;
    int64_t _625 = 0; // d
    _jump501:; // Begin body of loop
    _623 += _625;
    _625++;
    if (_625 < _624)
    goto _jump501;
    // End body of loop
    if (_622 >= 0)
    goto _jump502;
    fail_assertion("negative array index");
    _jump502:;
    if (_622 < _612.d0)
    goto _jump503;
    fail_assertion("index too large");
    _jump503:;
    if (_623 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (_623 < _612.d1)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    int64_t _626 = 0;
    _626 *= _612.d0;
    _626 += _622;
    _626 *= _612.d1;
    _626 += _623;
    int64_t _627 = _612.data[_626];
    _611 = _627;
    goto _jump506;
    _jump496:;
    int64_t _628;
    // Computing bound for d
    int64_t _629 = 48;
    int64_t _630 = 3;
    int64_t _631 = _629 / _630;
    int64_t _632 = -_631;
    if (_632 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    _628 = 0;
    int64_t _633 = 0; // d
    _jump508:; // Begin body of loop
    int64_t _634;
    // Computing bound for e
    if (_633 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    // Computing bound for f
    int64_t _635;
    // Computing bound for e
    int64_t _636 = 226;
    if (_636 > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing bound for f
    int64_t _637 = 909;
    if (_637 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    _635 = 0;
    int64_t _638 = 0; // f
    int64_t _639 = 0; // e
    _jump512:; // Begin body of loop
    int64_t _640 = 797;
    _635 += _640;
    _638++;
    if (_638 < _637)
    goto _jump512;
    _638 = 0;
    _639++;
    if (_639 < _636)
    goto _jump512;
    // End body of loop
    if (_635 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    _634 = 0;
    int64_t _641 = 0; // f
    int64_t _642 = 0; // e
    _jump514:; // Begin body of loop
    int64_t _643;
    // Computing bound for g
    if (_633 > 0) 
    goto _jump515;
    fail_assertion("non-positive loop bound");
    _jump515:;
    // Computing bound for h
    if (_641 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    _643 = 0;
    int64_t _644 = 0; // h
    int64_t _645 = 0; // g
    _jump517:; // Begin body of loop
    _643 += _633;
    _644++;
    if (_644 < _641)
    goto _jump517;
    _644 = 0;
    _645++;
    if (_645 < _633)
    goto _jump517;
    // End body of loop
    _634 += _643;
    _641++;
    if (_641 < _635)
    goto _jump514;
    _641 = 0;
    _642++;
    if (_642 < _633)
    goto _jump514;
    // End body of loop
    _628 += _634;
    _633++;
    if (_633 < _632)
    goto _jump508;
    // End body of loop
    _611 = _628;
    _jump506:;
    _593 = _611;
    _jump495:;
    bool _647 = true;
    bool _646 = _647;
    if (0 == _647)
    goto _jump518;
    int64_t _648 = 741;
    int64_t _649 = -_648;
    int64_t _650;
    // Computing bound for d
    int64_t _651 = 327;
    if (_651 > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    _650 = 0;
    int64_t _652 = 0; // d
    _jump520:; // Begin body of loop
    int64_t _653 = 980;
    _650 += _653;
    _652++;
    if (_652 < _651)
    goto _jump520;
    // End body of loop
    bool _654 = _649 < _650;
    _646 = _654;
    _jump518:;
    bool _655 = true;
    bool _656 = _646 != _655;
    int64_t _657;
    if (!_656)
    goto _jump521;
    _a1_int64_t _658;
    // Computing bound for d
    int64_t _659 = 374;
    int64_t _660 = -_659;
    _658.d0 = _660;
    if (_660 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing total size of heap memory to allocate
    int64_t _661 = 1;
    _661 *= _660;
    _661 *= sizeof(int64_t);
    _658.data = jpl_alloc(_661);
    int64_t _662 = 0; // d
    _jump523:; // Begin body of loop
    int64_t _663 = 0;
    _663 *= _658.d0;
    _663 += _662;
    _658.data[_663] = _662;
    _662++;
    if (_662 < _660)
    goto _jump523;
    // End body of loop
    int64_t _664 = 410;
    int64_t _665 = -_664;
    int64_t _666 = -_665;
    int64_t _667 = -_666;
    if (_667 >= 0)
    goto _jump524;
    fail_assertion("negative array index");
    _jump524:;
    if (_667 < _658.d0)
    goto _jump525;
    fail_assertion("index too large");
    _jump525:;
    int64_t _668 = 0;
    _668 *= _658.d0;
    _668 += _667;
    int64_t _669 = _658.data[_668];
    _657 = _669;
    goto _jump526;
    _jump521:;
    _a3_int64_t _670;
    // Computing bound for d
    int64_t _671;
    // Computing bound for d
    int64_t _672 = 223;
    int64_t _673 = -_672;
    if (_673 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    _671 = 0;
    int64_t _674 = 0; // d
    _jump528:; // Begin body of loop
    int64_t _675 = 771;
    int64_t _676 = _674 * _675;
    _671 += _676;
    _674++;
    if (_674 < _673)
    goto _jump528;
    // End body of loop
    _670.d0 = _671;
    if (_671 > 0) 
    goto _jump529;
    fail_assertion("non-positive loop bound");
    _jump529:;
    // Computing bound for e
    int64_t _677 = 539;
    _670.d1 = _677;
    if (_677 > 0) 
    goto _jump530;
    fail_assertion("non-positive loop bound");
    _jump530:;
    // Computing bound for f
    int64_t _678;
    // Computing bound for d
    int64_t _679 = 332;
    int64_t _680 = -_679;
    if (_680 > 0) 
    goto _jump531;
    fail_assertion("non-positive loop bound");
    _jump531:;
    // Computing bound for e
    int64_t _681 = 126;
    if (_681 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing bound for f
    int64_t _682;
    // Computing bound for d
    int64_t _683 = 924;
    if (_683 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for e
    int64_t _684 = 870;
    if (_684 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    _682 = 0;
    int64_t _685 = 0; // e
    int64_t _686 = 0; // d
    _jump535:; // Begin body of loop
    int64_t _687 = 355;
    _682 += _687;
    _685++;
    if (_685 < _684)
    goto _jump535;
    _685 = 0;
    _686++;
    if (_686 < _683)
    goto _jump535;
    // End body of loop
    if (_682 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    _678 = 0;
    int64_t _688 = 0; // f
    int64_t _689 = 0; // e
    int64_t _690 = 0; // d
    _jump537:; // Begin body of loop
    int64_t _691 = -_690;
    _678 += _691;
    _688++;
    if (_688 < _682)
    goto _jump537;
    _688 = 0;
    _689++;
    if (_689 < _681)
    goto _jump537;
    _689 = 0;
    _690++;
    if (_690 < _680)
    goto _jump537;
    // End body of loop
    _670.d2 = _678;
    if (_678 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _692 = 1;
    _692 *= _671;
    _692 *= _677;
    _692 *= _678;
    _692 *= sizeof(int64_t);
    _670.data = jpl_alloc(_692);
    int64_t _693 = 0; // f
    int64_t _694 = 0; // e
    int64_t _695 = 0; // d
    _jump539:; // Begin body of loop
    int64_t _696 = 0;
    _696 *= _670.d0;
    _696 += _695;
    _696 *= _670.d1;
    _696 += _694;
    _696 *= _670.d2;
    _696 += _693;
    _670.data[_696] = _694;
    _693++;
    if (_693 < _678)
    goto _jump539;
    _693 = 0;
    _694++;
    if (_694 < _677)
    goto _jump539;
    _694 = 0;
    _695++;
    if (_695 < _671)
    goto _jump539;
    // End body of loop
    int64_t _697 = 247;
    int64_t _698 = 236;
    int64_t _699 = -_698;
    int64_t _700 = -_699;
    int64_t _701 = _697 * _700;
    int64_t _702 = 129;
    int64_t _703 = 942;
    int64_t _704 = -_703;
    int64_t _705 = 385;
    int64_t _706 = -_705;
    _a1_int64_t _707;
    _707.d0 = 2;
    _707.data = jpl_alloc(sizeof(int64_t) * 2);
    _707.data[0] = _704;
    _707.data[1] = _706;
    int64_t _708 = 600;
    int64_t _709 = -_708;
    int64_t _710 = -_709;
    if (_710 >= 0)
    goto _jump540;
    fail_assertion("negative array index");
    _jump540:;
    if (_710 < _707.d0)
    goto _jump541;
    fail_assertion("index too large");
    _jump541:;
    int64_t _711 = 0;
    _711 *= _707.d0;
    _711 += _710;
    int64_t _712 = _707.data[_711];
    if (_701 >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (_701 < _670.d0)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    if (_702 >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (_702 < _670.d1)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    if (_712 >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (_712 < _670.d2)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    int64_t _713 = 0;
    _713 *= _670.d0;
    _713 += _701;
    _713 *= _670.d1;
    _713 += _702;
    _713 *= _670.d2;
    _713 += _712;
    int64_t _714 = _670.data[_713];
    _657 = _714;
    _jump526:;
    if (_593 >= 0)
    goto _jump548;
    fail_assertion("negative array index");
    _jump548:;
    if (_593 < _499.d0)
    goto _jump549;
    fail_assertion("index too large");
    _jump549:;
    if (_657 >= 0)
    goto _jump550;
    fail_assertion("negative array index");
    _jump550:;
    if (_657 < _499.d1)
    goto _jump551;
    fail_assertion("index too large");
    _jump551:;
    int64_t _715 = 0;
    _715 *= _499.d0;
    _715 += _593;
    _715 *= _499.d1;
    _715 += _657;
    _a3_double _716 = _499.data[_715];
    _309 = _716;
    _jump443:;
    int64_t _718 = 437;
    bool _719 = _718 == _309.d2;
    bool _717 = _719;
    if (0 != _719)
    goto _jump552;
    bool _720 = false;
    bool _721;
    if (!_720)
    goto _jump553;
    bool _722 = false;
    _721 = _722;
    goto _jump554;
    _jump553:;
    bool _723 = true;
    _721 = _723;
    _jump554:;
    bool _724 = !_721;
    _717 = _724;
    _jump552:;
    bool _725 = !_717;
    _a3__a3_bool _726;
    if (!_725)
    goto _jump555;
    _a3__a3_bool _727;
    // Computing bound for h
    _727.d0 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing bound for i
    int64_t _728 = _309.d1 * _309.d1;
    int64_t _729 = _309.d1 + _728;
    _727.d1 = _729;
    if (_729 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for j
    _a2_int64_t _730;
    // Computing bound for h
    _730.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing bound for i
    int64_t _731 = 991;
    int64_t _732 = -_731;
    _730.d1 = _732;
    if (_732 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    // Computing total size of heap memory to allocate
    int64_t _733 = 1;
    _733 *= _309.d0;
    _733 *= _732;
    _733 *= sizeof(int64_t);
    _730.data = jpl_alloc(_733);
    int64_t _734 = 0; // i
    int64_t _735 = 0; // h
    _jump560:; // Begin body of loop
    int64_t _736 = 0;
    _736 *= _730.d0;
    _736 += _735;
    _736 *= _730.d1;
    _736 += _734;
    _730.data[_736] = _309.d0;
    _734++;
    if (_734 < _732)
    goto _jump560;
    _734 = 0;
    _735++;
    if (_735 < _309.d0)
    goto _jump560;
    // End body of loop
    int64_t _737 = 636;
    if (_309.d0 >= 0)
    goto _jump561;
    fail_assertion("negative array index");
    _jump561:;
    if (_309.d0 < _730.d0)
    goto _jump562;
    fail_assertion("index too large");
    _jump562:;
    if (_737 >= 0)
    goto _jump563;
    fail_assertion("negative array index");
    _jump563:;
    if (_737 < _730.d1)
    goto _jump564;
    fail_assertion("index too large");
    _jump564:;
    int64_t _738 = 0;
    _738 *= _730.d0;
    _738 += _309.d0;
    _738 *= _730.d1;
    _738 += _737;
    int64_t _739 = _730.data[_738];
    _727.d2 = _739;
    if (_739 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    // Computing total size of heap memory to allocate
    int64_t _740 = 1;
    _740 *= _309.d2;
    _740 *= _729;
    _740 *= _739;
    _740 *= sizeof(_a3_bool);
    _727.data = jpl_alloc(_740);
    int64_t _741 = 0; // j
    int64_t _742 = 0; // i
    int64_t _743 = 0; // h
    _jump566:; // Begin body of loop
    _a3_bool _744;
    // Computing bound for k
    int64_t _745 = 529;
    _744.d0 = _745;
    if (_745 > 0) 
    goto _jump567;
    fail_assertion("non-positive loop bound");
    _jump567:;
    // Computing bound for l
    int64_t _746 = 887;
    _744.d1 = _746;
    if (_746 > 0) 
    goto _jump568;
    fail_assertion("non-positive loop bound");
    _jump568:;
    // Computing bound for m
    int64_t _747;
    // Computing bound for k
    if (_309.d0 > 0) 
    goto _jump569;
    fail_assertion("non-positive loop bound");
    _jump569:;
    // Computing bound for l
    int64_t _748 = 31;
    if (_748 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for m
    if (_743 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    _747 = 0;
    int64_t _749 = 0; // m
    int64_t _750 = 0; // l
    int64_t _751 = 0; // k
    _jump572:; // Begin body of loop
    bool _752 = false;
    int64_t _753;
    if (!_752)
    goto _jump573;
    _753 = _309.d2;
    goto _jump574;
    _jump573:;
    _753 = _751;
    _jump574:;
    _747 += _753;
    _749++;
    if (_749 < _743)
    goto _jump572;
    _749 = 0;
    _750++;
    if (_750 < _748)
    goto _jump572;
    _750 = 0;
    _751++;
    if (_751 < _309.d0)
    goto _jump572;
    // End body of loop
    _744.d2 = _747;
    if (_747 > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    // Computing total size of heap memory to allocate
    int64_t _754 = 1;
    _754 *= _745;
    _754 *= _746;
    _754 *= _747;
    _754 *= sizeof(bool);
    _744.data = jpl_alloc(_754);
    int64_t _755 = 0; // m
    int64_t _756 = 0; // l
    int64_t _757 = 0; // k
    _jump576:; // Begin body of loop
    bool _759 = true;
    bool _760 = !_759;
    bool _758 = _760;
    if (0 != _760)
    goto _jump577;
    bool _761 = _757 <= _755;
    _758 = _761;
    _jump577:;
    int64_t _762 = 0;
    _762 *= _744.d0;
    _762 += _757;
    _762 *= _744.d1;
    _762 += _756;
    _762 *= _744.d2;
    _762 += _755;
    _744.data[_762] = _758;
    _755++;
    if (_755 < _747)
    goto _jump576;
    _755 = 0;
    _756++;
    if (_756 < _746)
    goto _jump576;
    _756 = 0;
    _757++;
    if (_757 < _745)
    goto _jump576;
    // End body of loop
    int64_t _763 = 0;
    _763 *= _727.d0;
    _763 += _743;
    _763 *= _727.d1;
    _763 += _742;
    _763 *= _727.d2;
    _763 += _741;
    _727.data[_763] = _744;
    _741++;
    if (_741 < _739)
    goto _jump566;
    _741 = 0;
    _742++;
    if (_742 < _729)
    goto _jump566;
    _742 = 0;
    _743++;
    if (_743 < _309.d2)
    goto _jump566;
    // End body of loop
    _726 = _727;
    goto _jump578;
    _jump555:;
    _a3__a3__a3_bool _764;
    // Computing bound for h
    _764.d0 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for i
    _764.d1 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    // Computing bound for j
    _764.d2 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing total size of heap memory to allocate
    int64_t _765 = 1;
    _765 *= _309.d2;
    _765 *= _309.d2;
    _765 *= _309.d2;
    _765 *= sizeof(_a3__a3_bool);
    _764.data = jpl_alloc(_765);
    int64_t _766 = 0; // j
    int64_t _767 = 0; // i
    int64_t _768 = 0; // h
    _jump582:; // Begin body of loop
    _a3__a3_bool _769;
    // Computing bound for k
    _769.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump583;
    fail_assertion("non-positive loop bound");
    _jump583:;
    // Computing bound for l
    _769.d1 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing bound for m
    int64_t _770 = 137;
    _769.d2 = _770;
    if (_770 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing total size of heap memory to allocate
    int64_t _771 = 1;
    _771 *= _309.d0;
    _771 *= _309.d2;
    _771 *= _770;
    _771 *= sizeof(_a3_bool);
    _769.data = jpl_alloc(_771);
    int64_t _772 = 0; // m
    int64_t _773 = 0; // l
    int64_t _774 = 0; // k
    _jump586:; // Begin body of loop
    _a3_bool _775;
    // Computing bound for n
    _775.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump587;
    fail_assertion("non-positive loop bound");
    _jump587:;
    // Computing bound for o
    _775.d1 = _773;
    if (_773 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing bound for p
    _775.d2 = _768;
    if (_768 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing total size of heap memory to allocate
    int64_t _776 = 1;
    _776 *= _309.d0;
    _776 *= _773;
    _776 *= _768;
    _776 *= sizeof(bool);
    _775.data = jpl_alloc(_776);
    int64_t _777 = 0; // p
    int64_t _778 = 0; // o
    int64_t _779 = 0; // n
    _jump590:; // Begin body of loop
    bool _780 = false;
    int64_t _781 = 0;
    _781 *= _775.d0;
    _781 += _779;
    _781 *= _775.d1;
    _781 += _778;
    _781 *= _775.d2;
    _781 += _777;
    _775.data[_781] = _780;
    _777++;
    if (_777 < _768)
    goto _jump590;
    _777 = 0;
    _778++;
    if (_778 < _773)
    goto _jump590;
    _778 = 0;
    _779++;
    if (_779 < _309.d0)
    goto _jump590;
    // End body of loop
    int64_t _782 = 0;
    _782 *= _769.d0;
    _782 += _774;
    _782 *= _769.d1;
    _782 += _773;
    _782 *= _769.d2;
    _782 += _772;
    _769.data[_782] = _775;
    _772++;
    if (_772 < _770)
    goto _jump586;
    _772 = 0;
    _773++;
    if (_773 < _309.d2)
    goto _jump586;
    _773 = 0;
    _774++;
    if (_774 < _309.d0)
    goto _jump586;
    // End body of loop
    int64_t _783 = 0;
    _783 *= _764.d0;
    _783 += _768;
    _783 *= _764.d1;
    _783 += _767;
    _783 *= _764.d2;
    _783 += _766;
    _764.data[_783] = _769;
    _766++;
    if (_766 < _309.d2)
    goto _jump582;
    _766 = 0;
    _767++;
    if (_767 < _309.d2)
    goto _jump582;
    _767 = 0;
    _768++;
    if (_768 < _309.d2)
    goto _jump582;
    // End body of loop
    bool _784 = true;
    bool _785 = !_784;
    int64_t _786;
    if (!_785)
    goto _jump591;
    int64_t _787 = 694;
    int64_t _788 = -_787;
    _786 = _788;
    goto _jump592;
    _jump591:;
    int64_t _789 = 918;
    _786 = _789;
    _jump592:;
    if (_309.d1 >= 0)
    goto _jump593;
    fail_assertion("negative array index");
    _jump593:;
    if (_309.d1 < _764.d0)
    goto _jump594;
    fail_assertion("index too large");
    _jump594:;
    if (_309.d0 >= 0)
    goto _jump595;
    fail_assertion("negative array index");
    _jump595:;
    if (_309.d0 < _764.d1)
    goto _jump596;
    fail_assertion("index too large");
    _jump596:;
    if (_786 >= 0)
    goto _jump597;
    fail_assertion("negative array index");
    _jump597:;
    if (_786 < _764.d2)
    goto _jump598;
    fail_assertion("index too large");
    _jump598:;
    int64_t _790 = 0;
    _790 *= _764.d0;
    _790 += _309.d1;
    _790 *= _764.d1;
    _790 += _309.d0;
    _790 *= _764.d2;
    _790 += _786;
    _a3__a3_bool _791 = _764.data[_790];
    _726 = _791;
    _jump578:;
    int64_t _792 = 78;
    _a2_bool _793;
    // Computing bound for h
    int64_t _794;
    // Computing bound for h
    if (_309.d2 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    _794 = 0;
    int64_t _795 = 0; // h
    _jump600:; // Begin body of loop
    _794 += _795;
    _795++;
    if (_795 < _309.d2)
    goto _jump600;
    // End body of loop
    _793.d0 = _794;
    if (_794 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    // Computing bound for i
    int64_t _796 = -_309.d2;
    int64_t _797 = -_796;
    _793.d1 = _797;
    if (_797 > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing total size of heap memory to allocate
    int64_t _798 = 1;
    _798 *= _794;
    _798 *= _797;
    _798 *= sizeof(bool);
    _793.data = jpl_alloc(_798);
    int64_t _799 = 0; // i
    int64_t _800 = 0; // h
    _jump603:; // Begin body of loop
    bool _801 = false;
    int64_t _802 = 0;
    _802 *= _793.d0;
    _802 += _800;
    _802 *= _793.d1;
    _802 += _799;
    _793.data[_802] = _801;
    _799++;
    if (_799 < _797)
    goto _jump603;
    _799 = 0;
    _800++;
    if (_800 < _794)
    goto _jump603;
    // End body of loop
    int64_t _803;
    // Computing bound for h
    _a2_int64_t _804;
    // Computing bound for h
    int64_t _805 = 64;
    _804.d0 = _805;
    if (_805 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    // Computing bound for i
    int64_t _806 = 956;
    _804.d1 = _806;
    if (_806 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing total size of heap memory to allocate
    int64_t _807 = 1;
    _807 *= _805;
    _807 *= _806;
    _807 *= sizeof(int64_t);
    _804.data = jpl_alloc(_807);
    int64_t _808 = 0; // i
    int64_t _809 = 0; // h
    _jump606:; // Begin body of loop
    int64_t _810 = 0;
    _810 *= _804.d0;
    _810 += _809;
    _810 *= _804.d1;
    _810 += _808;
    _804.data[_810] = _309.d2;
    _808++;
    if (_808 < _806)
    goto _jump606;
    _808 = 0;
    _809++;
    if (_809 < _805)
    goto _jump606;
    // End body of loop
    if (_309.d0 >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (_309.d0 < _804.d0)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    if (_309.d2 >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (_309.d2 < _804.d1)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _811 = 0;
    _811 *= _804.d0;
    _811 += _309.d0;
    _811 *= _804.d1;
    _811 += _309.d2;
    int64_t _812 = _804.data[_811];
    if (_812 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for i
    int64_t _813 = -_309.d2;
    if (_813 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    _803 = 0;
    int64_t _814 = 0; // i
    int64_t _815 = 0; // h
    _jump613:; // Begin body of loop
    int64_t _816 = -_309.d0;
    _803 += _816;
    _814++;
    if (_814 < _813)
    goto _jump613;
    _814 = 0;
    _815++;
    if (_815 < _812)
    goto _jump613;
    // End body of loop
    if (_803 >= 0)
    goto _jump614;
    fail_assertion("negative array index");
    _jump614:;
    if (_803 < _793.d0)
    goto _jump615;
    fail_assertion("index too large");
    _jump615:;
    if (_309.d0 >= 0)
    goto _jump616;
    fail_assertion("negative array index");
    _jump616:;
    if (_309.d0 < _793.d1)
    goto _jump617;
    fail_assertion("index too large");
    _jump617:;
    int64_t _817 = 0;
    _817 *= _793.d0;
    _817 += _803;
    _817 *= _793.d1;
    _817 += _309.d0;
    bool _818 = _793.data[_817];
    int64_t _819;
    if (!_818)
    goto _jump618;
    bool _821 = false;
    bool _820 = _821;
    if (0 != _821)
    goto _jump619;
    if (_309.d1 >= 0)
    goto _jump620;
    fail_assertion("negative array index");
    _jump620:;
    if (_309.d1 < _305.d0)
    goto _jump621;
    fail_assertion("index too large");
    _jump621:;
    int64_t _822 = 0;
    _822 *= _305.d0;
    _822 += _309.d1;
    bool _823 = _305.data[_822];
    _820 = _823;
    _jump619:;
    int64_t _824;
    if (!_820)
    goto _jump622;
    _824 = _309.d2;
    goto _jump623;
    _jump622:;
    _824 = _309.d0;
    _jump623:;
    _819 = _824;
    goto _jump624;
    _jump618:;
    _a2_bool _825;
    // Computing bound for h
    int64_t _826 = 299;
    _825.d0 = _826;
    if (_826 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for i
    _825.d1 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    // Computing total size of heap memory to allocate
    int64_t _827 = 1;
    _827 *= _826;
    _827 *= _309.d1;
    _827 *= sizeof(bool);
    _825.data = jpl_alloc(_827);
    int64_t _828 = 0; // i
    int64_t _829 = 0; // h
    _jump627:; // Begin body of loop
    bool _830 = true;
    int64_t _831 = 0;
    _831 *= _825.d0;
    _831 += _829;
    _831 *= _825.d1;
    _831 += _828;
    _825.data[_831] = _830;
    _828++;
    if (_828 < _309.d1)
    goto _jump627;
    _828 = 0;
    _829++;
    if (_829 < _826)
    goto _jump627;
    // End body of loop
    int64_t _832 = 922;
    int64_t _833 = 93;
    if (_832 >= 0)
    goto _jump628;
    fail_assertion("negative array index");
    _jump628:;
    if (_832 < _825.d0)
    goto _jump629;
    fail_assertion("index too large");
    _jump629:;
    if (_833 >= 0)
    goto _jump630;
    fail_assertion("negative array index");
    _jump630:;
    if (_833 < _825.d1)
    goto _jump631;
    fail_assertion("index too large");
    _jump631:;
    int64_t _834 = 0;
    _834 *= _825.d0;
    _834 += _832;
    _834 *= _825.d1;
    _834 += _833;
    bool _835 = _825.data[_834];
    bool _836 = !_835;
    int64_t _837;
    if (!_836)
    goto _jump632;
    _837 = _309.d0;
    goto _jump633;
    _jump632:;
    bool _838 = true;
    bool _840 = true;
    bool _839 = _840;
    if (0 == _840)
    goto _jump634;
    bool _841 = false;
    _839 = _841;
    _jump634:;
    bool _842 = _838 != _839;
    int64_t _843;
    if (!_842)
    goto _jump635;
    _843 = _309.d0;
    goto _jump636;
    _jump635:;
    _843 = _309.d2;
    _jump636:;
    _837 = _843;
    _jump633:;
    _819 = _837;
    _jump624:;
    if (_792 >= 0)
    goto _jump637;
    fail_assertion("negative array index");
    _jump637:;
    if (_792 < _726.d0)
    goto _jump638;
    fail_assertion("index too large");
    _jump638:;
    if (_309.d0 >= 0)
    goto _jump639;
    fail_assertion("negative array index");
    _jump639:;
    if (_309.d0 < _726.d1)
    goto _jump640;
    fail_assertion("index too large");
    _jump640:;
    if (_819 >= 0)
    goto _jump641;
    fail_assertion("negative array index");
    _jump641:;
    if (_819 < _726.d2)
    goto _jump642;
    fail_assertion("index too large");
    _jump642:;
    int64_t _844 = 0;
    _844 *= _726.d0;
    _844 += _792;
    _844 *= _726.d1;
    _844 += _309.d0;
    _844 *= _726.d2;
    _844 += _819;
    _a3_bool _845 = _726.data[_844];
    bool _848 = _309.d1 < _309.d2;
    bool _847 = _848;
    if (0 == _848)
    goto _jump643;
    bool _849 = _309.d1 == _309.d1;
    _847 = _849;
    _jump643:;
    bool _846 = _847;
    if (0 != _847)
    goto _jump644;
    bool _850 = _309.d1 < _309.d1;
    _846 = _850;
    _jump644:;
    bool _851 = !_846;
    bool _852 = !_851;
    int64_t _853;
    if (!_852)
    goto _jump645;
    _853 = _309.d0;
    goto _jump646;
    _jump645:;
    int64_t _854 = 431;
    _853 = _854;
    _jump646:;
    int64_t _855;
    // Computing bound for h
    if (_309.d0 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    _855 = 0;
    int64_t _856 = 0; // h
    _jump648:; // Begin body of loop
    _855 += _309.d1;
    _856++;
    if (_856 < _309.d0)
    goto _jump648;
    // End body of loop
    if (_853 >= 0)
    goto _jump649;
    fail_assertion("negative array index");
    _jump649:;
    if (_853 < _845.d0)
    goto _jump650;
    fail_assertion("index too large");
    _jump650:;
    if (_855 >= 0)
    goto _jump651;
    fail_assertion("negative array index");
    _jump651:;
    if (_855 < _845.d1)
    goto _jump652;
    fail_assertion("index too large");
    _jump652:;
    if (_309.d2 >= 0)
    goto _jump653;
    fail_assertion("negative array index");
    _jump653:;
    if (_309.d2 < _845.d2)
    goto _jump654;
    fail_assertion("index too large");
    _jump654:;
    int64_t _857 = 0;
    _857 *= _845.d0;
    _857 += _853;
    _857 *= _845.d1;
    _857 += _855;
    _857 *= _845.d2;
    _857 += _309.d2;
    bool _858 = _845.data[_857];
    if (0 != _858)
    goto _jump655;
    fail_assertion("h");
    _jump655:;
    _a2__a2__a3_double _859;
    // Computing bound for h
    bool _860 = false;
    int64_t _861;
    if (!_860)
    goto _jump656;
    _861 = _309.d2;
    goto _jump657;
    _jump656:;
    _861 = _309.d0;
    _jump657:;
    int64_t _862 = -_861;
    int64_t _863 = 281;
    int64_t _864 = _862 * _863;
    _859.d0 = _864;
    if (_864 > 0) 
    goto _jump658;
    fail_assertion("non-positive loop bound");
    _jump658:;
    // Computing bound for i
    int64_t _865 = -_309.d1;
    int64_t _866 = _865 / _309.d0;
    _859.d1 = _866;
    if (_866 > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing total size of heap memory to allocate
    int64_t _867 = 1;
    _867 *= _864;
    _867 *= _866;
    _867 *= sizeof(_a2__a3_double);
    _859.data = jpl_alloc(_867);
    int64_t _868 = 0; // i
    int64_t _869 = 0; // h
    _jump660:; // Begin body of loop
    _a2__a3_double _870;
    // Computing bound for j
    _870.d0 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing bound for k
    _870.d1 = _869;
    if (_869 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing total size of heap memory to allocate
    int64_t _871 = 1;
    _871 *= _309.d2;
    _871 *= _869;
    _871 *= sizeof(_a3_double);
    _870.data = jpl_alloc(_871);
    int64_t _872 = 0; // k
    int64_t _873 = 0; // j
    _jump663:; // Begin body of loop
    int64_t _874 = 0;
    _874 *= _870.d0;
    _874 += _873;
    _874 *= _870.d1;
    _874 += _872;
    _870.data[_874] = _309;
    _872++;
    if (_872 < _869)
    goto _jump663;
    _872 = 0;
    _873++;
    if (_873 < _309.d2)
    goto _jump663;
    // End body of loop
    int64_t _875 = 0;
    _875 *= _859.d0;
    _875 += _869;
    _875 *= _859.d1;
    _875 += _868;
    _859.data[_875] = _870;
    _868++;
    if (_868 < _866)
    goto _jump660;
    _868 = 0;
    _869++;
    if (_869 < _864)
    goto _jump660;
    // End body of loop
    int64_t _876;
    // Computing bound for h
    _a3_int64_t _877;
    // Computing bound for h
    int64_t _878;
    // Computing bound for h
    if (_309.d1 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for i
    if (_309.d2 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for j
    if (_309.d2 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    _878 = 0;
    int64_t _879 = 0; // j
    int64_t _880 = 0; // i
    int64_t _881 = 0; // h
    _jump667:; // Begin body of loop
    _878 += _881;
    _879++;
    if (_879 < _309.d2)
    goto _jump667;
    _879 = 0;
    _880++;
    if (_880 < _309.d2)
    goto _jump667;
    _880 = 0;
    _881++;
    if (_881 < _309.d1)
    goto _jump667;
    // End body of loop
    _877.d0 = _878;
    if (_878 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    // Computing bound for i
    int64_t _882 = 203;
    _877.d1 = _882;
    if (_882 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for j
    _877.d2 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    // Computing total size of heap memory to allocate
    int64_t _883 = 1;
    _883 *= _878;
    _883 *= _882;
    _883 *= _309.d0;
    _883 *= sizeof(int64_t);
    _877.data = jpl_alloc(_883);
    int64_t _884 = 0; // j
    int64_t _885 = 0; // i
    int64_t _886 = 0; // h
    _jump671:; // Begin body of loop
    int64_t _887 = 0;
    _887 *= _877.d0;
    _887 += _886;
    _887 *= _877.d1;
    _887 += _885;
    _887 *= _877.d2;
    _887 += _884;
    _877.data[_887] = _309.d1;
    _884++;
    if (_884 < _309.d0)
    goto _jump671;
    _884 = 0;
    _885++;
    if (_885 < _882)
    goto _jump671;
    _885 = 0;
    _886++;
    if (_886 < _878)
    goto _jump671;
    // End body of loop
    bool _888 = false;
    int64_t _889;
    if (!_888)
    goto _jump672;
    int64_t _890 = -_309.d2;
    _889 = _890;
    goto _jump673;
    _jump672:;
    int64_t _891;
    // Computing bound for h
    if (_309.d0 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    _891 = 0;
    int64_t _892 = 0; // h
    _jump675:; // Begin body of loop
    _891 += _309.d1;
    _892++;
    if (_892 < _309.d0)
    goto _jump675;
    // End body of loop
    _889 = _891;
    _jump673:;
    int64_t _893 = 705;
    int64_t _894 = -_893;
    int64_t _895 = 335;
    if (_889 >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (_889 < _877.d0)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    if (_894 >= 0)
    goto _jump678;
    fail_assertion("negative array index");
    _jump678:;
    if (_894 < _877.d1)
    goto _jump679;
    fail_assertion("index too large");
    _jump679:;
    if (_895 >= 0)
    goto _jump680;
    fail_assertion("negative array index");
    _jump680:;
    if (_895 < _877.d2)
    goto _jump681;
    fail_assertion("index too large");
    _jump681:;
    int64_t _896 = 0;
    _896 *= _877.d0;
    _896 += _889;
    _896 *= _877.d1;
    _896 += _894;
    _896 *= _877.d2;
    _896 += _895;
    int64_t _897 = _877.data[_896];
    if (_897 > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing bound for i
    if (_309.d0 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing bound for j
    int64_t _898 = 1;
    int64_t _899 = -_309.d1;
    int64_t _900 = -_899;
    int64_t _901 = _898 % _900;
    if (_901 > 0) 
    goto _jump684;
    fail_assertion("non-positive loop bound");
    _jump684:;
    _876 = 0;
    int64_t _902 = 0; // j
    int64_t _903 = 0; // i
    int64_t _904 = 0; // h
    _jump685:; // Begin body of loop
    _a2_int64_t _905;
    // Computing bound for k
    int64_t _906 = -_309.d1;
    _905.d0 = _906;
    if (_906 > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    // Computing bound for l
    _905.d1 = _904;
    if (_904 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing total size of heap memory to allocate
    int64_t _907 = 1;
    _907 *= _906;
    _907 *= _904;
    _907 *= sizeof(int64_t);
    _905.data = jpl_alloc(_907);
    int64_t _908 = 0; // l
    int64_t _909 = 0; // k
    _jump688:; // Begin body of loop
    int64_t _910 = 0;
    _910 *= _905.d0;
    _910 += _909;
    _910 *= _905.d1;
    _910 += _908;
    _905.data[_910] = _309.d2;
    _908++;
    if (_908 < _904)
    goto _jump688;
    _908 = 0;
    _909++;
    if (_909 < _906)
    goto _jump688;
    // End body of loop
    int64_t _911 = 11;
    if (_911 >= 0)
    goto _jump689;
    fail_assertion("negative array index");
    _jump689:;
    if (_911 < _905.d0)
    goto _jump690;
    fail_assertion("index too large");
    _jump690:;
    if (_903 >= 0)
    goto _jump691;
    fail_assertion("negative array index");
    _jump691:;
    if (_903 < _905.d1)
    goto _jump692;
    fail_assertion("index too large");
    _jump692:;
    int64_t _912 = 0;
    _912 *= _905.d0;
    _912 += _911;
    _912 *= _905.d1;
    _912 += _903;
    int64_t _913 = _905.data[_912];
    _876 += _913;
    _902++;
    if (_902 < _901)
    goto _jump685;
    _902 = 0;
    _903++;
    if (_903 < _309.d0)
    goto _jump685;
    _903 = 0;
    _904++;
    if (_904 < _897)
    goto _jump685;
    // End body of loop
    if (_309.d0 >= 0)
    goto _jump693;
    fail_assertion("negative array index");
    _jump693:;
    if (_309.d0 < _859.d0)
    goto _jump694;
    fail_assertion("index too large");
    _jump694:;
    if (_876 >= 0)
    goto _jump695;
    fail_assertion("negative array index");
    _jump695:;
    if (_876 < _859.d1)
    goto _jump696;
    fail_assertion("index too large");
    _jump696:;
    int64_t _914 = 0;
    _914 *= _859.d0;
    _914 += _309.d0;
    _914 *= _859.d1;
    _914 += _876;
    _a2__a3_double _915 = _859.data[_914];
    int64_t _916;
    // Computing bound for h
    int64_t _917 = 162;
    if (_917 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    // Computing bound for i
    int64_t _918 = 815;
    if (_918 > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    _916 = 0;
    int64_t _919 = 0; // i
    int64_t _920 = 0; // h
    _jump699:; // Begin body of loop
    int64_t _921 = -_309.d0;
    _916 += _921;
    _919++;
    if (_919 < _918)
    goto _jump699;
    _919 = 0;
    _920++;
    if (_920 < _917)
    goto _jump699;
    // End body of loop
    bool _922 = _916 <= _309.d2;
    bool _923;
    if (!_922)
    goto _jump700;
    int64_t _925;
    // Computing bound for h
    int64_t _926 = 243;
    if (_926 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    _925 = 0;
    int64_t _927 = 0; // h
    _jump702:; // Begin body of loop
    _925 += _309.d0;
    _927++;
    if (_927 < _926)
    goto _jump702;
    // End body of loop
    bool _928 = _925 <= _309.d1;
    bool _924 = _928;
    if (0 == _928)
    goto _jump703;
    bool _929 = true;
    _924 = _929;
    _jump703:;
    _923 = _924;
    goto _jump704;
    _jump700:;
    bool _930 = true;
    _923 = _930;
    _jump704:;
    _a2__a3_double _931;
    if (!_923)
    goto _jump705;
    _a3__a2__a3_double _932;
    // Computing bound for h
    int64_t _933 = 74;
    int64_t _934 = _309.d0 * _933;
    _932.d0 = _934;
    if (_934 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    // Computing bound for i
    _932.d1 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    // Computing bound for j
    int64_t _935 = -_309.d2;
    _932.d2 = _935;
    if (_935 > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    // Computing total size of heap memory to allocate
    int64_t _936 = 1;
    _936 *= _934;
    _936 *= _309.d2;
    _936 *= _935;
    _936 *= sizeof(_a2__a3_double);
    _932.data = jpl_alloc(_936);
    int64_t _937 = 0; // j
    int64_t _938 = 0; // i
    int64_t _939 = 0; // h
    _jump709:; // Begin body of loop
    _a2__a3_double _940;
    // Computing bound for k
    _940.d0 = _937;
    if (_937 > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing bound for l
    _940.d1 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    // Computing total size of heap memory to allocate
    int64_t _941 = 1;
    _941 *= _937;
    _941 *= _309.d1;
    _941 *= sizeof(_a3_double);
    _940.data = jpl_alloc(_941);
    int64_t _942 = 0; // l
    int64_t _943 = 0; // k
    _jump712:; // Begin body of loop
    int64_t _944 = 0;
    _944 *= _940.d0;
    _944 += _943;
    _944 *= _940.d1;
    _944 += _942;
    _940.data[_944] = _309;
    _942++;
    if (_942 < _309.d1)
    goto _jump712;
    _942 = 0;
    _943++;
    if (_943 < _937)
    goto _jump712;
    // End body of loop
    int64_t _945 = 0;
    _945 *= _932.d0;
    _945 += _939;
    _945 *= _932.d1;
    _945 += _938;
    _945 *= _932.d2;
    _945 += _937;
    _932.data[_945] = _940;
    _937++;
    if (_937 < _935)
    goto _jump709;
    _937 = 0;
    _938++;
    if (_938 < _309.d2)
    goto _jump709;
    _938 = 0;
    _939++;
    if (_939 < _934)
    goto _jump709;
    // End body of loop
    int64_t _946 = 908;
    int64_t _947 = -_309.d1;
    int64_t _948 = -_947;
    if (_946 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_946 < _932.d0)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    if (_309.d0 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_309.d0 < _932.d1)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    if (_948 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (_948 < _932.d2)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    int64_t _949 = 0;
    _949 *= _932.d0;
    _949 += _946;
    _949 *= _932.d1;
    _949 += _309.d0;
    _949 *= _932.d2;
    _949 += _948;
    _a2__a3_double _950 = _932.data[_949];
    _931 = _950;
    goto _jump719;
    _jump705:;
    _a2__a3_double _951;
    // Computing bound for h
    int64_t _952 = 935;
    int64_t _953 = _952 - _309.d2;
    _951.d0 = _953;
    if (_953 > 0) 
    goto _jump720;
    fail_assertion("non-positive loop bound");
    _jump720:;
    // Computing bound for i
    int64_t _954 = -_309.d2;
    _951.d1 = _954;
    if (_954 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing total size of heap memory to allocate
    int64_t _955 = 1;
    _955 *= _953;
    _955 *= _954;
    _955 *= sizeof(_a3_double);
    _951.data = jpl_alloc(_955);
    int64_t _956 = 0; // i
    int64_t _957 = 0; // h
    _jump722:; // Begin body of loop
    bool _958 = false;
    _a3_double _959;
    if (!_958)
    goto _jump723;
    _959 = _309;
    goto _jump724;
    _jump723:;
    _959 = _309;
    _jump724:;
    int64_t _960 = 0;
    _960 *= _951.d0;
    _960 += _957;
    _960 *= _951.d1;
    _960 += _956;
    _951.data[_960] = _959;
    _956++;
    if (_956 < _954)
    goto _jump722;
    _956 = 0;
    _957++;
    if (_957 < _953)
    goto _jump722;
    // End body of loop
    _a2__a3_double _961;
    // Computing bound for h
    _961.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing bound for i
    _961.d1 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    // Computing total size of heap memory to allocate
    int64_t _962 = 1;
    _962 *= _309.d0;
    _962 *= _309.d1;
    _962 *= sizeof(_a3_double);
    _961.data = jpl_alloc(_962);
    int64_t _963 = 0; // i
    int64_t _964 = 0; // h
    _jump727:; // Begin body of loop
    int64_t _965 = 0;
    _965 *= _961.d0;
    _965 += _964;
    _965 *= _961.d1;
    _965 += _963;
    _961.data[_965] = _309;
    _963++;
    if (_963 < _309.d1)
    goto _jump727;
    _963 = 0;
    _964++;
    if (_964 < _309.d0)
    goto _jump727;
    // End body of loop
    _a2__a3_double _966;
    // Computing bound for h
    _966.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for i
    _966.d1 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing total size of heap memory to allocate
    int64_t _967 = 1;
    _967 *= _309.d0;
    _967 *= _309.d0;
    _967 *= sizeof(_a3_double);
    _966.data = jpl_alloc(_967);
    int64_t _968 = 0; // i
    int64_t _969 = 0; // h
    _jump730:; // Begin body of loop
    int64_t _970 = 0;
    _970 *= _966.d0;
    _970 += _969;
    _970 *= _966.d1;
    _970 += _968;
    _966.data[_970] = _309;
    _968++;
    if (_968 < _309.d0)
    goto _jump730;
    _968 = 0;
    _969++;
    if (_969 < _309.d0)
    goto _jump730;
    // End body of loop
    _a1__a2__a3_double _971;
    _971.d0 = 3;
    _971.data = jpl_alloc(sizeof(_a2__a3_double) * 3);
    _971.data[0] = _951;
    _971.data[1] = _961;
    _971.data[2] = _966;
    if (_309.d0 >= 0)
    goto _jump731;
    fail_assertion("negative array index");
    _jump731:;
    if (_309.d0 < _971.d0)
    goto _jump732;
    fail_assertion("index too large");
    _jump732:;
    int64_t _972 = 0;
    _972 *= _971.d0;
    _972 += _309.d0;
    _a2__a3_double _973 = _971.data[_972];
    _931 = _973;
    _jump719:;
    _a1__a2__a3_double _974;
    _974.d0 = 2;
    _974.data = jpl_alloc(sizeof(_a2__a3_double) * 2);
    _974.data[0] = _915;
    _974.data[1] = _931;
    if (_309.d0 >= 0)
    goto _jump733;
    fail_assertion("negative array index");
    _jump733:;
    if (_309.d0 < _974.d0)
    goto _jump734;
    fail_assertion("index too large");
    _jump734:;
    int64_t _975 = 0;
    _975 *= _974.d0;
    _975 += _309.d0;
    _a2__a3_double _976 = _974.data[_975];
    double _977;
    // Computing bound for m
    if (_309.d0 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing bound for n
    int64_t _978 = -_976.d0;
    int64_t _979 = -_309.d0;
    _a1_int64_t _980;
    _980.d0 = 3;
    _980.data = jpl_alloc(sizeof(int64_t) * 3);
    _980.data[0] = _978;
    _980.data[1] = _979;
    _980.data[2] = _309.d2;
    int64_t _981 = l();
    if (_981 >= 0)
    goto _jump1067;
    fail_assertion("negative array index");
    _jump1067:;
    if (_981 < _980.d0)
    goto _jump1068;
    fail_assertion("index too large");
    _jump1068:;
    int64_t _982 = 0;
    _982 *= _980.d0;
    _982 += _981;
    int64_t _983 = _980.data[_982];
    if (_983 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing bound for o
    int64_t _984 = l();
    if (_984 > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    _977 = 0;
    int64_t _985 = 0; // o
    int64_t _986 = 0; // n
    int64_t _987 = 0; // m
    _jump1071:; // Begin body of loop
    double _988 = 39.0;
    _977 += _988;
    _985++;
    if (_985 < _984)
    goto _jump1071;
    _985 = 0;
    _986++;
    if (_986 < _983)
    goto _jump1071;
    _986 = 0;
    _987++;
    if (_987 < _309.d0)
    goto _jump1071;
    // End body of loop
    double _989 = 39.0;
    double _990 = -_989;
    double _991 = -_990;
    double _992 = _977 + _991;
    int64_t _993 = l();
    bool _994 = _993 > _976.d0;
    double _995;
    if (!_994)
    goto _jump1072;
    double _996 = 54.0;
    _995 = _996;
    goto _jump1073;
    _jump1072:;
    double _997 = 4.0;
    double _998 = 15.0;
    double _999 = _997 - _998;
    double _1000 = 0.0;
    double _1001 = -_1000;
    double _1002 = _999 * _1001;
    _995 = _1002;
    _jump1073:;
    double _1003 = 43.0;
    _a1_double _1004;
    // Computing bound for m
    int64_t _1005 = l();
    _1004.d0 = _1005;
    if (_1005 > 0) 
    goto _jump1074;
    fail_assertion("non-positive loop bound");
    _jump1074:;
    // Computing total size of heap memory to allocate
    int64_t _1006 = 1;
    _1006 *= _1005;
    _1006 *= sizeof(double);
    _1004.data = jpl_alloc(_1006);
    int64_t _1007 = 0; // m
    _jump1075:; // Begin body of loop
    double _1008 = 7.0;
    int64_t _1009 = 0;
    _1009 *= _1004.d0;
    _1009 += _1007;
    _1004.data[_1009] = _1008;
    _1007++;
    if (_1007 < _1005)
    goto _jump1075;
    // End body of loop
    int64_t _1010 = _309.d2 % _309.d2;
    if (_1010 >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (_1010 < _1004.d0)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    int64_t _1011 = 0;
    _1011 *= _1004.d0;
    _1011 += _1010;
    double _1012 = _1004.data[_1011];
    double _1013;
    // Computing bound for m
    if (_976.d0 > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    // Computing bound for n
    if (_976.d1 > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    _1013 = 0;
    int64_t _1014 = 0; // n
    int64_t _1015 = 0; // m
    _jump1080:; // Begin body of loop
    double _1016 = 56.0;
    _1013 += _1016;
    _1014++;
    if (_1014 < _976.d1)
    goto _jump1080;
    _1014 = 0;
    _1015++;
    if (_1015 < _976.d0)
    goto _jump1080;
    // End body of loop
    double _1017 = -_1013;
    double _1018 = _1012 + _1017;
    double _1019 = 13.0;
    rgba _1020 = { _995, _1003, _1018, _1019 };
    double _1021 = _1020.b;
    bool _1022 = _992 > _1021;
    _a1__a3_double _1023;
    if (!_1022)
    goto _jump1081;
    _a1__a3_double _1024;
    _1024.d0 = 1;
    _1024.data = jpl_alloc(sizeof(_a3_double) * 1);
    _1024.data[0] = _309;
    _1023 = _1024;
    goto _jump1082;
    _jump1081:;
    _a1__a3_double _1025;
    // Computing bound for m
    _1025.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing total size of heap memory to allocate
    int64_t _1026 = 1;
    _1026 *= _309.d0;
    _1026 *= sizeof(_a3_double);
    _1025.data = jpl_alloc(_1026);
    int64_t _1027 = 0; // m
    _jump1084:; // Begin body of loop
    int64_t _1028 = 0;
    _1028 *= _1025.d0;
    _1028 += _1027;
    _1025.data[_1028] = _309;
    _1027++;
    if (_1027 < _309.d0)
    goto _jump1084;
    // End body of loop
    _1023 = _1025;
    _jump1082:;
    _a1_int64_t _1029;
    _1029.d0 = 2;
    _1029.data = jpl_alloc(sizeof(int64_t) * 2);
    _1029.data[0] = _1023.d0;
    _1029.data[1] = _309.d1;
    bool _1030 = true;
    bool _1031 = !_1030;
    if (0 != _1031)
    goto _jump1154;
    fail_assertion("q");
    _jump1154:;
    _a2__a2__a3_double _1032;
    // Computing bound for v
    _1032.d0 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump1299;
    fail_assertion("non-positive loop bound");
    _jump1299:;
    // Computing bound for w
    int64_t _1033 = l();
    _1032.d1 = _1033;
    if (_1033 > 0) 
    goto _jump1300;
    fail_assertion("non-positive loop bound");
    _jump1300:;
    // Computing total size of heap memory to allocate
    int64_t _1034 = 1;
    _1034 *= _309.d2;
    _1034 *= _1033;
    _1034 *= sizeof(_a2__a3_double);
    _1032.data = jpl_alloc(_1034);
    int64_t _1035 = 0; // w
    int64_t _1036 = 0; // v
    _jump1301:; // Begin body of loop
    int64_t _1037 = 0;
    _1037 *= _1032.d0;
    _1037 += _1036;
    _1037 *= _1032.d1;
    _1037 += _1035;
    _1032.data[_1037] = _976;
    _1035++;
    if (_1035 < _1033)
    goto _jump1301;
    _1035 = 0;
    _1036++;
    if (_1036 < _309.d2)
    goto _jump1301;
    // End body of loop
    bool _1039 = true;
    bool _1038 = _1039;
    if (0 == _1039)
    goto _jump1302;
    _a3_bool _1040;
    // Computing bound for v
    int64_t _1041 = -_309.d0;
    _1040.d0 = _1041;
    if (_1041 > 0) 
    goto _jump1303;
    fail_assertion("non-positive loop bound");
    _jump1303:;
    // Computing bound for w
    int64_t _1042 = 599;
    _1040.d1 = _1042;
    if (_1042 > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    // Computing bound for x
    _1040.d2 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing total size of heap memory to allocate
    int64_t _1043 = 1;
    _1043 *= _1041;
    _1043 *= _1042;
    _1043 *= _309.d1;
    _1043 *= sizeof(bool);
    _1040.data = jpl_alloc(_1043);
    int64_t _1044 = 0; // x
    int64_t _1045 = 0; // w
    int64_t _1046 = 0; // v
    _jump1306:; // Begin body of loop
    bool _1047 = _1044 <= _309.d0;
    int64_t _1048 = 0;
    _1048 *= _1040.d0;
    _1048 += _1046;
    _1048 *= _1040.d1;
    _1048 += _1045;
    _1048 *= _1040.d2;
    _1048 += _1044;
    _1040.data[_1048] = _1047;
    _1044++;
    if (_1044 < _309.d1)
    goto _jump1306;
    _1044 = 0;
    _1045++;
    if (_1045 < _1042)
    goto _jump1306;
    _1045 = 0;
    _1046++;
    if (_1046 < _1041)
    goto _jump1306;
    // End body of loop
    int64_t _1049 = _309.d2 / _1023.d0;
    if (_1049 >= 0)
    goto _jump1307;
    fail_assertion("negative array index");
    _jump1307:;
    if (_1049 < _1040.d0)
    goto _jump1308;
    fail_assertion("index too large");
    _jump1308:;
    if (_309.d2 >= 0)
    goto _jump1309;
    fail_assertion("negative array index");
    _jump1309:;
    if (_309.d2 < _1040.d1)
    goto _jump1310;
    fail_assertion("index too large");
    _jump1310:;
    if (_976.d1 >= 0)
    goto _jump1311;
    fail_assertion("negative array index");
    _jump1311:;
    if (_976.d1 < _1040.d2)
    goto _jump1312;
    fail_assertion("index too large");
    _jump1312:;
    int64_t _1050 = 0;
    _1050 *= _1040.d0;
    _1050 += _1049;
    _1050 *= _1040.d1;
    _1050 += _309.d2;
    _1050 *= _1040.d2;
    _1050 += _976.d1;
    bool _1051 = _1040.data[_1050];
    _1038 = _1051;
    _jump1302:;
    bool _1052 = _309.d0 >= _1023.d0;
    bool _1053;
    if (!_1052)
    goto _jump1313;
    bool _1054 = false;
    bool _1055 = !_1054;
    _1053 = _1055;
    goto _jump1314;
    _jump1313:;
    bool _1057 = true;
    bool _1056 = _1057;
    if (0 == _1057)
    goto _jump1315;
    bool _1058 = false;
    _1056 = _1058;
    _jump1315:;
    bool _1059 = !_1056;
    _1053 = _1059;
    _jump1314:;
    bool _1060 = !_1053;
    bool _1061 = _1038 == _1060;
    int64_t _1062;
    if (!_1061)
    goto _jump1316;
    _1062 = _976.d1;
    goto _jump1317;
    _jump1316:;
    _1062 = _309.d1;
    _jump1317:;
    if (_1023.d0 >= 0)
    goto _jump1318;
    fail_assertion("negative array index");
    _jump1318:;
    if (_1023.d0 < _1032.d0)
    goto _jump1319;
    fail_assertion("index too large");
    _jump1319:;
    if (_1062 >= 0)
    goto _jump1320;
    fail_assertion("negative array index");
    _jump1320:;
    if (_1062 < _1032.d1)
    goto _jump1321;
    fail_assertion("index too large");
    _jump1321:;
    int64_t _1063 = 0;
    _1063 *= _1032.d0;
    _1063 += _1023.d0;
    _1063 *= _1032.d1;
    _1063 += _1062;
    _a2__a3_double _1064 = _1032.data[_1063];
    _a2_rgba _1065 = read_image("y.png");
    bool _1066 = _309.d2 < _309.d0;
    if (0 != _1066)
    goto _jump1322;
    fail_assertion("z");
    _jump1322:;
    print("z");
    bool _1068 = false;
    bool _1069;
    if (!_1068)
    goto _jump1390;
    bool _1070 = true;
    bool _1071 = !_1070;
    _1069 = _1071;
    goto _jump1391;
    _jump1390:;
    _a3_bool _1072;
    // Computing bound for A
    _1072.d0 = _976.d0;
    if (_976.d0 > 0) 
    goto _jump1392;
    fail_assertion("non-positive loop bound");
    _jump1392:;
    // Computing bound for B
    _1072.d1 = _976.d0;
    if (_976.d0 > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    // Computing bound for C
    _1072.d2 = _1064.d0;
    if (_1064.d0 > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing total size of heap memory to allocate
    int64_t _1073 = 1;
    _1073 *= _976.d0;
    _1073 *= _976.d0;
    _1073 *= _1064.d0;
    _1073 *= sizeof(bool);
    _1072.data = jpl_alloc(_1073);
    int64_t _1074 = 0; // C
    int64_t _1075 = 0; // B
    int64_t _1076 = 0; // A
    _jump1395:; // Begin body of loop
    bool _1077 = false;
    int64_t _1078 = 0;
    _1078 *= _1072.d0;
    _1078 += _1076;
    _1078 *= _1072.d1;
    _1078 += _1075;
    _1078 *= _1072.d2;
    _1078 += _1074;
    _1072.data[_1078] = _1077;
    _1074++;
    if (_1074 < _1064.d0)
    goto _jump1395;
    _1074 = 0;
    _1075++;
    if (_1075 < _976.d0)
    goto _jump1395;
    _1075 = 0;
    _1076++;
    if (_1076 < _976.d0)
    goto _jump1395;
    // End body of loop
    int64_t _1079 = -_309.d0;
    if (_1079 >= 0)
    goto _jump1396;
    fail_assertion("negative array index");
    _jump1396:;
    if (_1079 < _1072.d0)
    goto _jump1397;
    fail_assertion("index too large");
    _jump1397:;
    if (_309.d2 >= 0)
    goto _jump1398;
    fail_assertion("negative array index");
    _jump1398:;
    if (_309.d2 < _1072.d1)
    goto _jump1399;
    fail_assertion("index too large");
    _jump1399:;
    if (_309.d0 >= 0)
    goto _jump1400;
    fail_assertion("negative array index");
    _jump1400:;
    if (_309.d0 < _1072.d2)
    goto _jump1401;
    fail_assertion("index too large");
    _jump1401:;
    int64_t _1080 = 0;
    _1080 *= _1072.d0;
    _1080 += _1079;
    _1080 *= _1072.d1;
    _1080 += _309.d2;
    _1080 *= _1072.d2;
    _1080 += _309.d0;
    bool _1081 = _1072.data[_1080];
    _1069 = _1081;
    _jump1391:;
    bool _1082;
    if (!_1069)
    goto _jump1402;
    bool _1085 = true;
    bool _1084 = _1085;
    if (0 == _1085)
    goto _jump1403;
    bool _1086 = _309.d0 >= _976.d1;
    _1084 = _1086;
    _jump1403:;
    bool _1083 = _1084;
    if (0 == _1084)
    goto _jump1404;
    double _1087 = 89.0;
    double _1088 = q();
    bool _1089 = _1087 != _1088;
    bool _1090;
    if (!_1089)
    goto _jump1405;
    bool _1092 = true;
    bool _1091 = _1092;
    if (0 != _1092)
    goto _jump1406;
    bool _1093 = false;
    _1091 = _1093;
    _jump1406:;
    _1090 = _1091;
    goto _jump1407;
    _jump1405:;
    int64_t _1094 = l();
    bool _1095 = _1094 > _309.d2;
    _1090 = _1095;
    _jump1407:;
    _1083 = _1090;
    _jump1404:;
    _1082 = _1083;
    goto _jump1408;
    _jump1402:;
    bool _1096 = true;
    _1082 = _1096;
    _jump1408:;
    bool _1067 = _1082;
    if (0 != _1082)
    goto _jump1409;
    bool _1097 = _309.d0 < _976.d1;
    double _1099 = 45.0;
    double _1100 = q();
    bool _1101 = _1099 <= _1100;
    bool _1098 = _1101;
    if (0 == _1101)
    goto _jump1410;
    bool _1102 = _976.d0 > _309.d0;
    _1098 = _1102;
    _jump1410:;
    bool _1103 = _1097 != _1098;
    bool _1105 = _309.d1 > _309.d1;
    bool _1104 = _1105;
    if (0 != _1105)
    goto _jump1411;
    int64_t _1106 = l();
    bool _1107 = _976.d1 <= _1106;
    _1104 = _1107;
    _jump1411:;
    bool _1108 = _1103 != _1104;
    _1067 = _1108;
    _jump1409:;
    _a3__a3_double _1109;
    if (!_1067)
    goto _jump1412;
    _a2__a2__a3__a3_double _1110;
    // Computing bound for A
    int64_t _1111;
    // Computing bound for A
    if (_976.d1 > 0) 
    goto _jump1413;
    fail_assertion("non-positive loop bound");
    _jump1413:;
    // Computing bound for B
    if (_1064.d1 > 0) 
    goto _jump1414;
    fail_assertion("non-positive loop bound");
    _jump1414:;
    _1111 = 0;
    int64_t _1112 = 0; // B
    int64_t _1113 = 0; // A
    _jump1415:; // Begin body of loop
    int64_t _1114 = -_1064.d1;
    _1111 += _1114;
    _1112++;
    if (_1112 < _1064.d1)
    goto _jump1415;
    _1112 = 0;
    _1113++;
    if (_1113 < _976.d1)
    goto _jump1415;
    // End body of loop
    _1110.d0 = _1111;
    if (_1111 > 0) 
    goto _jump1416;
    fail_assertion("non-positive loop bound");
    _jump1416:;
    // Computing bound for B
    _1110.d1 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump1417;
    fail_assertion("non-positive loop bound");
    _jump1417:;
    // Computing total size of heap memory to allocate
    int64_t _1115 = 1;
    _1115 *= _1111;
    _1115 *= _309.d2;
    _1115 *= sizeof(_a2__a3__a3_double);
    _1110.data = jpl_alloc(_1115);
    int64_t _1116 = 0; // B
    int64_t _1117 = 0; // A
    _jump1418:; // Begin body of loop
    _a2__a3__a3_double _1118;
    // Computing bound for C
    _1118.d0 = _1064.d1;
    if (_1064.d1 > 0) 
    goto _jump1419;
    fail_assertion("non-positive loop bound");
    _jump1419:;
    // Computing bound for D
    _1118.d1 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing total size of heap memory to allocate
    int64_t _1119 = 1;
    _1119 *= _1064.d1;
    _1119 *= _309.d1;
    _1119 *= sizeof(_a3__a3_double);
    _1118.data = jpl_alloc(_1119);
    int64_t _1120 = 0; // D
    int64_t _1121 = 0; // C
    _jump1421:; // Begin body of loop
    _a3__a3_double _1122;
    // Computing bound for E
    _1122.d0 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump1422;
    fail_assertion("non-positive loop bound");
    _jump1422:;
    // Computing bound for F
    _1122.d1 = _1121;
    if (_1121 > 0) 
    goto _jump1423;
    fail_assertion("non-positive loop bound");
    _jump1423:;
    // Computing bound for G
    int64_t _1123 = 334;
    _1122.d2 = _1123;
    if (_1123 > 0) 
    goto _jump1424;
    fail_assertion("non-positive loop bound");
    _jump1424:;
    // Computing total size of heap memory to allocate
    int64_t _1124 = 1;
    _1124 *= _309.d0;
    _1124 *= _1121;
    _1124 *= _1123;
    _1124 *= sizeof(_a3_double);
    _1122.data = jpl_alloc(_1124);
    int64_t _1125 = 0; // G
    int64_t _1126 = 0; // F
    int64_t _1127 = 0; // E
    _jump1425:; // Begin body of loop
    int64_t _1128 = 0;
    _1128 *= _1122.d0;
    _1128 += _1127;
    _1128 *= _1122.d1;
    _1128 += _1126;
    _1128 *= _1122.d2;
    _1128 += _1125;
    _1122.data[_1128] = _309;
    _1125++;
    if (_1125 < _1123)
    goto _jump1425;
    _1125 = 0;
    _1126++;
    if (_1126 < _1121)
    goto _jump1425;
    _1126 = 0;
    _1127++;
    if (_1127 < _309.d0)
    goto _jump1425;
    // End body of loop
    int64_t _1129 = 0;
    _1129 *= _1118.d0;
    _1129 += _1121;
    _1129 *= _1118.d1;
    _1129 += _1120;
    _1118.data[_1129] = _1122;
    _1120++;
    if (_1120 < _309.d1)
    goto _jump1421;
    _1120 = 0;
    _1121++;
    if (_1121 < _1064.d1)
    goto _jump1421;
    // End body of loop
    int64_t _1130 = 0;
    _1130 *= _1110.d0;
    _1130 += _1117;
    _1130 *= _1110.d1;
    _1130 += _1116;
    _1110.data[_1130] = _1118;
    _1116++;
    if (_1116 < _309.d2)
    goto _jump1418;
    _1116 = 0;
    _1117++;
    if (_1117 < _1111)
    goto _jump1418;
    // End body of loop
    bool _1131 = false;
    int64_t _1132;
    if (!_1131)
    goto _jump1426;
    int64_t _1133;
    // Computing bound for A
    if (_309.d1 > 0) 
    goto _jump1427;
    fail_assertion("non-positive loop bound");
    _jump1427:;
    // Computing bound for B
    if (_976.d1 > 0) 
    goto _jump1428;
    fail_assertion("non-positive loop bound");
    _jump1428:;
    // Computing bound for C
    if (_1023.d0 > 0) 
    goto _jump1429;
    fail_assertion("non-positive loop bound");
    _jump1429:;
    _1133 = 0;
    int64_t _1134 = 0; // C
    int64_t _1135 = 0; // B
    int64_t _1136 = 0; // A
    _jump1430:; // Begin body of loop
    int64_t _1137 = l();
    _1133 += _1137;
    _1134++;
    if (_1134 < _1023.d0)
    goto _jump1430;
    _1134 = 0;
    _1135++;
    if (_1135 < _976.d1)
    goto _jump1430;
    _1135 = 0;
    _1136++;
    if (_1136 < _309.d1)
    goto _jump1430;
    // End body of loop
    _1132 = _1133;
    goto _jump1431;
    _jump1426:;
    int64_t _1138 = _309.d2 * _309.d1;
    _1132 = _1138;
    _jump1431:;
    int64_t _1139 = _1132 % _309.d0;
    if (_1139 >= 0)
    goto _jump1432;
    fail_assertion("negative array index");
    _jump1432:;
    if (_1139 < _1110.d0)
    goto _jump1433;
    fail_assertion("index too large");
    _jump1433:;
    if (_309.d1 >= 0)
    goto _jump1434;
    fail_assertion("negative array index");
    _jump1434:;
    if (_309.d1 < _1110.d1)
    goto _jump1435;
    fail_assertion("index too large");
    _jump1435:;
    int64_t _1140 = 0;
    _1140 *= _1110.d0;
    _1140 += _1139;
    _1140 *= _1110.d1;
    _1140 += _309.d1;
    _a2__a3__a3_double _1141 = _1110.data[_1140];
    if (_309.d2 >= 0)
    goto _jump1436;
    fail_assertion("negative array index");
    _jump1436:;
    if (_309.d2 < _1141.d0)
    goto _jump1437;
    fail_assertion("index too large");
    _jump1437:;
    if (_309.d0 >= 0)
    goto _jump1438;
    fail_assertion("negative array index");
    _jump1438:;
    if (_309.d0 < _1141.d1)
    goto _jump1439;
    fail_assertion("index too large");
    _jump1439:;
    int64_t _1142 = 0;
    _1142 *= _1141.d0;
    _1142 += _309.d2;
    _1142 *= _1141.d1;
    _1142 += _309.d0;
    _a3__a3_double _1143 = _1141.data[_1142];
    _1109 = _1143;
    goto _jump1440;
    _jump1412:;
    double _1144 = q();
    double _1145 = q();
    double _1146 = 41.0;
    double _1147 = -_1146;
    double _1148 = _1145 / _1147;
    double _1149 = -_1148;
    bool _1150 = _1144 != _1149;
    _a3__a3_double _1151;
    if (!_1150)
    goto _jump1441;
    _a3__a3_double _1152;
    // Computing bound for A
    bool _1154 = false;
    bool _1153 = _1154;
    if (0 != _1154)
    goto _jump1442;
    bool _1155 = true;
    _1153 = _1155;
    _jump1442:;
    bool _1156;
    if (!_1153)
    goto _jump1443;
    bool _1157 = _309.d0 != _976.d1;
    _1156 = _1157;
    goto _jump1444;
    _jump1443:;
    bool _1158 = _309.d0 <= _976.d0;
    _1156 = _1158;
    _jump1444:;
    int64_t _1159;
    if (!_1156)
    goto _jump1445;
    int64_t _1160 = 591;
    _1159 = _1160;
    goto _jump1446;
    _jump1445:;
    int64_t _1161;
    // Computing bound for A
    if (_1064.d0 > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    _1161 = 0;
    int64_t _1162 = 0; // A
    _jump1448:; // Begin body of loop
    int64_t _1163 = l();
    _1161 += _1163;
    _1162++;
    if (_1162 < _1064.d0)
    goto _jump1448;
    // End body of loop
    _1159 = _1161;
    _jump1446:;
    _1152.d0 = _1159;
    if (_1159 > 0) 
    goto _jump1449;
    fail_assertion("non-positive loop bound");
    _jump1449:;
    // Computing bound for B
    int64_t _1164 = l();
    int64_t _1165 = _309.d1 / _1164;
    _1152.d1 = _1165;
    if (_1165 > 0) 
    goto _jump1450;
    fail_assertion("non-positive loop bound");
    _jump1450:;
    // Computing bound for C
    _1152.d2 = _309.d2;
    if (_309.d2 > 0) 
    goto _jump1451;
    fail_assertion("non-positive loop bound");
    _jump1451:;
    // Computing total size of heap memory to allocate
    int64_t _1166 = 1;
    _1166 *= _1159;
    _1166 *= _1165;
    _1166 *= _309.d2;
    _1166 *= sizeof(_a3_double);
    _1152.data = jpl_alloc(_1166);
    int64_t _1167 = 0; // C
    int64_t _1168 = 0; // B
    int64_t _1169 = 0; // A
    _jump1452:; // Begin body of loop
    _a3_double _1170;
    // Computing bound for D
    int64_t _1171;
    // Computing bound for D
    if (_1023.d0 > 0) 
    goto _jump1453;
    fail_assertion("non-positive loop bound");
    _jump1453:;
    // Computing bound for E
    bool _1172 = false;
    int64_t _1173;
    if (!_1172)
    goto _jump1454;
    _1173 = _1169;
    goto _jump1455;
    _jump1454:;
    _1173 = _976.d0;
    _jump1455:;
    if (_1173 > 0) 
    goto _jump1456;
    fail_assertion("non-positive loop bound");
    _jump1456:;
    // Computing bound for F
    if (_309.d2 > 0) 
    goto _jump1457;
    fail_assertion("non-positive loop bound");
    _jump1457:;
    _1171 = 0;
    int64_t _1174 = 0; // F
    int64_t _1175 = 0; // E
    int64_t _1176 = 0; // D
    _jump1458:; // Begin body of loop
    int64_t _1177;
    // Computing bound for G
    int64_t _1178 = 498;
    if (_1178 > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    _1177 = 0;
    int64_t _1179 = 0; // G
    _jump1460:; // Begin body of loop
    _1177 += _1179;
    _1179++;
    if (_1179 < _1178)
    goto _jump1460;
    // End body of loop
    _1171 += _1177;
    _1174++;
    if (_1174 < _309.d2)
    goto _jump1458;
    _1174 = 0;
    _1175++;
    if (_1175 < _1173)
    goto _jump1458;
    _1175 = 0;
    _1176++;
    if (_1176 < _1023.d0)
    goto _jump1458;
    // End body of loop
    _1170.d0 = _1171;
    if (_1171 > 0) 
    goto _jump1461;
    fail_assertion("non-positive loop bound");
    _jump1461:;
    // Computing bound for E
    _1170.d1 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump1462;
    fail_assertion("non-positive loop bound");
    _jump1462:;
    // Computing bound for F
    _1170.d2 = _1023.d0;
    if (_1023.d0 > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing total size of heap memory to allocate
    int64_t _1180 = 1;
    _1180 *= _1171;
    _1180 *= _309.d0;
    _1180 *= _1023.d0;
    _1180 *= sizeof(double);
    _1170.data = jpl_alloc(_1180);
    int64_t _1181 = 0; // F
    int64_t _1182 = 0; // E
    int64_t _1183 = 0; // D
    _jump1464:; // Begin body of loop
    double _1184 = 33.0;
    int64_t _1185 = 0;
    _1185 *= _1170.d0;
    _1185 += _1183;
    _1185 *= _1170.d1;
    _1185 += _1182;
    _1185 *= _1170.d2;
    _1185 += _1181;
    _1170.data[_1185] = _1184;
    _1181++;
    if (_1181 < _1023.d0)
    goto _jump1464;
    _1181 = 0;
    _1182++;
    if (_1182 < _309.d0)
    goto _jump1464;
    _1182 = 0;
    _1183++;
    if (_1183 < _1171)
    goto _jump1464;
    // End body of loop
    int64_t _1186 = 0;
    _1186 *= _1152.d0;
    _1186 += _1169;
    _1186 *= _1152.d1;
    _1186 += _1168;
    _1186 *= _1152.d2;
    _1186 += _1167;
    _1152.data[_1186] = _1170;
    _1167++;
    if (_1167 < _309.d2)
    goto _jump1452;
    _1167 = 0;
    _1168++;
    if (_1168 < _1165)
    goto _jump1452;
    _1168 = 0;
    _1169++;
    if (_1169 < _1159)
    goto _jump1452;
    // End body of loop
    _1151 = _1152;
    goto _jump1465;
    _jump1441:;
    bool _1187 = true;
    _a3__a3_double _1188;
    if (!_1187)
    goto _jump1466;
    _a3__a3_double _1189;
    // Computing bound for A
    int64_t _1190;
    // Computing bound for A
    if (_1064.d1 > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    _1190 = 0;
    int64_t _1191 = 0; // A
    _jump1468:; // Begin body of loop
    _1190 += _1064.d0;
    _1191++;
    if (_1191 < _1064.d1)
    goto _jump1468;
    // End body of loop
    _1189.d0 = _1190;
    if (_1190 > 0) 
    goto _jump1469;
    fail_assertion("non-positive loop bound");
    _jump1469:;
    // Computing bound for B
    _1189.d1 = _976.d1;
    if (_976.d1 > 0) 
    goto _jump1470;
    fail_assertion("non-positive loop bound");
    _jump1470:;
    // Computing bound for C
    int64_t _1192 = l();
    _a1_int64_t _1193;
    _1193.d0 = 2;
    _1193.data = jpl_alloc(sizeof(int64_t) * 2);
    _1193.data[0] = _1192;
    _1193.data[1] = _976.d1;
    int64_t _1194 = l();
    if (_1194 >= 0)
    goto _jump1471;
    fail_assertion("negative array index");
    _jump1471:;
    if (_1194 < _1193.d0)
    goto _jump1472;
    fail_assertion("index too large");
    _jump1472:;
    int64_t _1195 = 0;
    _1195 *= _1193.d0;
    _1195 += _1194;
    int64_t _1196 = _1193.data[_1195];
    _1189.d2 = _1196;
    if (_1196 > 0) 
    goto _jump1473;
    fail_assertion("non-positive loop bound");
    _jump1473:;
    // Computing total size of heap memory to allocate
    int64_t _1197 = 1;
    _1197 *= _1190;
    _1197 *= _976.d1;
    _1197 *= _1196;
    _1197 *= sizeof(_a3_double);
    _1189.data = jpl_alloc(_1197);
    int64_t _1198 = 0; // C
    int64_t _1199 = 0; // B
    int64_t _1200 = 0; // A
    _jump1474:; // Begin body of loop
    int64_t _1201 = 0;
    _1201 *= _1189.d0;
    _1201 += _1200;
    _1201 *= _1189.d1;
    _1201 += _1199;
    _1201 *= _1189.d2;
    _1201 += _1198;
    _1189.data[_1201] = _309;
    _1198++;
    if (_1198 < _1196)
    goto _jump1474;
    _1198 = 0;
    _1199++;
    if (_1199 < _976.d1)
    goto _jump1474;
    _1199 = 0;
    _1200++;
    if (_1200 < _1190)
    goto _jump1474;
    // End body of loop
    _1188 = _1189;
    goto _jump1475;
    _jump1466:;
    _a1__a3__a3_double _1202;
    // Computing bound for A
    _1202.d0 = _1023.d0;
    if (_1023.d0 > 0) 
    goto _jump1476;
    fail_assertion("non-positive loop bound");
    _jump1476:;
    // Computing total size of heap memory to allocate
    int64_t _1203 = 1;
    _1203 *= _1023.d0;
    _1203 *= sizeof(_a3__a3_double);
    _1202.data = jpl_alloc(_1203);
    int64_t _1204 = 0; // A
    _jump1477:; // Begin body of loop
    _a3__a3_double _1205;
    // Computing bound for B
    _1205.d0 = _976.d1;
    if (_976.d1 > 0) 
    goto _jump1478;
    fail_assertion("non-positive loop bound");
    _jump1478:;
    // Computing bound for C
    _1205.d1 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump1479;
    fail_assertion("non-positive loop bound");
    _jump1479:;
    // Computing bound for D
    _1205.d2 = _1064.d1;
    if (_1064.d1 > 0) 
    goto _jump1480;
    fail_assertion("non-positive loop bound");
    _jump1480:;
    // Computing total size of heap memory to allocate
    int64_t _1206 = 1;
    _1206 *= _976.d1;
    _1206 *= _309.d0;
    _1206 *= _1064.d1;
    _1206 *= sizeof(_a3_double);
    _1205.data = jpl_alloc(_1206);
    int64_t _1207 = 0; // D
    int64_t _1208 = 0; // C
    int64_t _1209 = 0; // B
    _jump1481:; // Begin body of loop
    int64_t _1210 = 0;
    _1210 *= _1205.d0;
    _1210 += _1209;
    _1210 *= _1205.d1;
    _1210 += _1208;
    _1210 *= _1205.d2;
    _1210 += _1207;
    _1205.data[_1210] = _309;
    _1207++;
    if (_1207 < _1064.d1)
    goto _jump1481;
    _1207 = 0;
    _1208++;
    if (_1208 < _309.d0)
    goto _jump1481;
    _1208 = 0;
    _1209++;
    if (_1209 < _976.d1)
    goto _jump1481;
    // End body of loop
    int64_t _1211 = 0;
    _1211 *= _1202.d0;
    _1211 += _1204;
    _1202.data[_1211] = _1205;
    _1204++;
    if (_1204 < _1023.d0)
    goto _jump1477;
    // End body of loop
    int64_t _1212 = l();
    if (_1212 >= 0)
    goto _jump1482;
    fail_assertion("negative array index");
    _jump1482:;
    if (_1212 < _1202.d0)
    goto _jump1483;
    fail_assertion("index too large");
    _jump1483:;
    int64_t _1213 = 0;
    _1213 *= _1202.d0;
    _1213 += _1212;
    _a3__a3_double _1214 = _1202.data[_1213];
    _1188 = _1214;
    _jump1475:;
    _1151 = _1188;
    _jump1465:;
    _1109 = _1151;
    _jump1440:;
    int64_t _1215 = l();
    if (_1064.d0 >= 0)
    goto _jump1484;
    fail_assertion("negative array index");
    _jump1484:;
    if (_1064.d0 < _1109.d0)
    goto _jump1485;
    fail_assertion("index too large");
    _jump1485:;
    if (_1064.d1 >= 0)
    goto _jump1486;
    fail_assertion("negative array index");
    _jump1486:;
    if (_1064.d1 < _1109.d1)
    goto _jump1487;
    fail_assertion("index too large");
    _jump1487:;
    if (_1215 >= 0)
    goto _jump1488;
    fail_assertion("negative array index");
    _jump1488:;
    if (_1215 < _1109.d2)
    goto _jump1489;
    fail_assertion("index too large");
    _jump1489:;
    int64_t _1216 = 0;
    _1216 *= _1109.d0;
    _1216 += _1064.d0;
    _1216 *= _1109.d1;
    _1216 += _1064.d1;
    _1216 *= _1109.d2;
    _1216 += _1215;
    _a3_double _1217 = _1109.data[_1216];
    print("F");
    int64_t _1221 = 773;
    int64_t _1222 = -_1221;
    if (_1222 >= 0)
    goto _jump1704;
    fail_assertion("negative array index");
    _jump1704:;
    if (_1222 < _305.d0)
    goto _jump1705;
    fail_assertion("index too large");
    _jump1705:;
    int64_t _1223 = 0;
    _1223 *= _305.d0;
    _1223 += _1222;
    bool _1224 = _305.data[_1223];
    bool _1220 = _1224;
    if (0 == _1224)
    goto _jump1706;
    double _1226 = q();
    double _1227 = q();
    bool _1228 = _1226 != _1227;
    bool _1225 = _1228;
    if (0 == _1228)
    goto _jump1707;
    bool _1229 = _309.d1 <= _1217.d0;
    _1225 = _1229;
    _jump1707:;
    bool _1230;
    if (!_1225)
    goto _jump1708;
    int64_t _1231 = l();
    bool _1232 = _309.d2 < _1231;
    _1230 = _1232;
    goto _jump1709;
    _jump1708:;
    bool _1233 = true;
    bool _1234;
    if (!_1233)
    goto _jump1710;
    bool _1235 = _309.d1 == _1217.d1;
    _1234 = _1235;
    goto _jump1711;
    _jump1710:;
    bool _1236 = false;
    _1234 = _1236;
    _jump1711:;
    _1230 = _1234;
    _jump1709:;
    _1220 = _1230;
    _jump1706:;
    bool _1237 = !_1220;
    bool _1219 = _1237;
    if (0 != _1237)
    goto _jump1712;
    bool _1239 = false;
    bool _1238 = _1239;
    if (0 != _1239)
    goto _jump1713;
    int64_t _1240 = 314;
    int64_t _1241 = _976.d0 % _309.d2;
    bool _1242 = _1240 <= _1241;
    _1238 = _1242;
    _jump1713:;
    _1219 = _1238;
    _jump1712:;
    bool _1218 = _1219;
    if (0 == _1219)
    goto _jump1714;
    bool _1243 = _976.d0 != _1023.d0;
    bool _1244 = !_1243;
    _1218 = _1244;
    _jump1714:;
}

