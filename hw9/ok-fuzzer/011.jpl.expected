
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  _a3__a1_bool *data;
} _a1__a3__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_rgba *data;
} _a3__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_void_t *data;
} _a3__a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3__a2_void_t *data;
} _a3__a3__a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

void_t b(_a3_void_t c) {
    _a3_double _0;
    // Computing bound for h
    int64_t _1;
    if (!a)
    goto _jump24;
    _1 = c.d1;
    goto _jump25;
    _jump24:;
    _1 = c.d2;
    _jump25:;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for i
    _0.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    // Computing bound for j
    _0.d2 = c.d2;
    if (c.d2 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= _1;
    _2 *= c.d0;
    _2 *= c.d2;
    _2 *= sizeof(double);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // j
    int64_t _4 = 0; // i
    int64_t _5 = 0; // h
    _jump29:; // Begin body of loop
    double _6 = 25.0;
    double _7 = -_6;
    int64_t _8 = 0;
    _8 *= _0.d0;
    _8 += _5;
    _8 *= _0.d1;
    _8 += _4;
    _8 *= _0.d2;
    _8 += _3;
    _0.data[_8] = _7;
    _3++;
    if (_3 < c.d2)
    goto _jump29;
    _3 = 0;
    _4++;
    if (_4 < c.d0)
    goto _jump29;
    _4 = 0;
    _5++;
    if (_5 < _1)
    goto _jump29;
    // End body of loop
    bool _9 = a;
    if (0 == a)
    goto _jump30;
    _9 = a;
    _jump30:;
    int64_t _10;
    if (!_9)
    goto _jump31;
    _10 = c.d2;
    goto _jump32;
    _jump31:;
    int64_t _11;
    // Computing bound for h
    if (c.d2 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    _11 = 0;
    int64_t _12 = 0; // h
    _jump34:; // Begin body of loop
    _11 += c.d1;
    _12++;
    if (_12 < c.d2)
    goto _jump34;
    // End body of loop
    _10 = _11;
    _jump32:;
    _a3_int64_t _13;
    // Computing bound for h
    _13.d0 = c.d2;
    if (c.d2 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for i
    _13.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    // Computing bound for j
    _13.d2 = c.d2;
    if (c.d2 > 0) 
    goto _jump37;
    fail_assertion("non-positive loop bound");
    _jump37:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= c.d2;
    _14 *= c.d0;
    _14 *= c.d2;
    _14 *= sizeof(int64_t);
    _13.data = jpl_alloc(_14);
    int64_t _15 = 0; // j
    int64_t _16 = 0; // i
    int64_t _17 = 0; // h
    _jump38:; // Begin body of loop
    int64_t _18 = 0;
    _18 *= _13.d0;
    _18 += _17;
    _18 *= _13.d1;
    _18 += _16;
    _18 *= _13.d2;
    _18 += _15;
    _13.data[_18] = _16;
    _15++;
    if (_15 < c.d2)
    goto _jump38;
    _15 = 0;
    _16++;
    if (_16 < c.d0)
    goto _jump38;
    _16 = 0;
    _17++;
    if (_17 < c.d2)
    goto _jump38;
    // End body of loop
    int64_t _19;
    // Computing bound for h
    int64_t _20 = 838;
    if (_20 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    _19 = 0;
    int64_t _21 = 0; // h
    _jump40:; // Begin body of loop
    int64_t _22 = 760;
    _19 += _22;
    _21++;
    if (_21 < _20)
    goto _jump40;
    // End body of loop
    int64_t _23 = 323;
    int64_t _24 = c.d0 * _23;
    if (_19 >= 0)
    goto _jump41;
    fail_assertion("negative array index");
    _jump41:;
    if (_19 < _13.d0)
    goto _jump42;
    fail_assertion("index too large");
    _jump42:;
    if (c.d2 >= 0)
    goto _jump43;
    fail_assertion("negative array index");
    _jump43:;
    if (c.d2 < _13.d1)
    goto _jump44;
    fail_assertion("index too large");
    _jump44:;
    if (_24 >= 0)
    goto _jump45;
    fail_assertion("negative array index");
    _jump45:;
    if (_24 < _13.d2)
    goto _jump46;
    fail_assertion("index too large");
    _jump46:;
    int64_t _25 = 0;
    _25 *= _13.d0;
    _25 += _19;
    _25 *= _13.d1;
    _25 += c.d2;
    _25 *= _13.d2;
    _25 += _24;
    int64_t _26 = _13.data[_25];
    if (_10 >= 0)
    goto _jump47;
    fail_assertion("negative array index");
    _jump47:;
    if (_10 < _0.d0)
    goto _jump48;
    fail_assertion("index too large");
    _jump48:;
    if (_26 >= 0)
    goto _jump49;
    fail_assertion("negative array index");
    _jump49:;
    if (_26 < _0.d1)
    goto _jump50;
    fail_assertion("index too large");
    _jump50:;
    if (c.d1 >= 0)
    goto _jump51;
    fail_assertion("negative array index");
    _jump51:;
    if (c.d1 < _0.d2)
    goto _jump52;
    fail_assertion("index too large");
    _jump52:;
    int64_t _27 = 0;
    _27 *= _0.d0;
    _27 += _10;
    _27 *= _0.d1;
    _27 += _26;
    _27 *= _0.d2;
    _27 += c.d1;
    double _28 = _0.data[_27];
    bool _29 = false;
    bool _30;
    if (!_29)
    goto _jump53;
    bool _31 = true;
    _30 = _31;
    goto _jump54;
    _jump53:;
    _30 = a;
    _jump54:;
    bool _32 = !_30;
    double _33;
    if (!_32)
    goto _jump55;
    double _34;
    // Computing bound for h
    int64_t _35 = c.d2 % c.d1;
    if (_35 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    // Computing bound for i
    int64_t _36 = -c.d2;
    if (_36 > 0) 
    goto _jump57;
    fail_assertion("non-positive loop bound");
    _jump57:;
    _34 = 0;
    int64_t _37 = 0; // i
    int64_t _38 = 0; // h
    _jump58:; // Begin body of loop
    double _39 = 95.0;
    _34 += _39;
    _37++;
    if (_37 < _36)
    goto _jump58;
    _37 = 0;
    _38++;
    if (_38 < _35)
    goto _jump58;
    // End body of loop
    _33 = _34;
    goto _jump59;
    _jump55:;
    _a3_double _40;
    // Computing bound for h
    int64_t _41 = 158;
    _40.d0 = _41;
    if (_41 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    // Computing bound for i
    _40.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing bound for j
    _40.d2 = c.d2;
    if (c.d2 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= _41;
    _42 *= c.d1;
    _42 *= c.d2;
    _42 *= sizeof(double);
    _40.data = jpl_alloc(_42);
    int64_t _43 = 0; // j
    int64_t _44 = 0; // i
    int64_t _45 = 0; // h
    _jump63:; // Begin body of loop
    double _46 = 21.0;
    int64_t _47 = 0;
    _47 *= _40.d0;
    _47 += _45;
    _47 *= _40.d1;
    _47 += _44;
    _47 *= _40.d2;
    _47 += _43;
    _40.data[_47] = _46;
    _43++;
    if (_43 < c.d2)
    goto _jump63;
    _43 = 0;
    _44++;
    if (_44 < c.d1)
    goto _jump63;
    _44 = 0;
    _45++;
    if (_45 < _41)
    goto _jump63;
    // End body of loop
    if (c.d2 >= 0)
    goto _jump64;
    fail_assertion("negative array index");
    _jump64:;
    if (c.d2 < _40.d0)
    goto _jump65;
    fail_assertion("index too large");
    _jump65:;
    if (c.d2 >= 0)
    goto _jump66;
    fail_assertion("negative array index");
    _jump66:;
    if (c.d2 < _40.d1)
    goto _jump67;
    fail_assertion("index too large");
    _jump67:;
    if (c.d2 >= 0)
    goto _jump68;
    fail_assertion("negative array index");
    _jump68:;
    if (c.d2 < _40.d2)
    goto _jump69;
    fail_assertion("index too large");
    _jump69:;
    int64_t _48 = 0;
    _48 *= _40.d0;
    _48 += c.d2;
    _48 *= _40.d1;
    _48 += c.d2;
    _48 *= _40.d2;
    _48 += c.d2;
    double _49 = _40.data[_48];
    _33 = _49;
    _jump59:;
    bool _50 = _28 <= _33;
    bool _51;
    if (!_50)
    goto _jump70;
    bool _52 = a;
    if (0 == a)
    goto _jump71;
    int64_t _53 = -c.d0;
    bool _54 = c.d2 > _53;
    _52 = _54;
    _jump71:;
    bool _55 = !_52;
    _51 = _55;
    goto _jump72;
    _jump70:;
    double _56 = 88.0;
    _a1_double _57;
    // Computing bound for h
    _57.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= c.d1;
    _58 *= sizeof(double);
    _57.data = jpl_alloc(_58);
    int64_t _59 = 0; // h
    _jump74:; // Begin body of loop
    double _60 = 97.0;
    int64_t _61 = 0;
    _61 *= _57.d0;
    _61 += _59;
    _57.data[_61] = _60;
    _59++;
    if (_59 < c.d1)
    goto _jump74;
    // End body of loop
    int64_t _62 = -c.d2;
    int64_t _63 = c.d2 / _62;
    if (_63 >= 0)
    goto _jump75;
    fail_assertion("negative array index");
    _jump75:;
    if (_63 < _57.d0)
    goto _jump76;
    fail_assertion("index too large");
    _jump76:;
    int64_t _64 = 0;
    _64 *= _57.d0;
    _64 += _63;
    double _65 = _57.data[_64];
    bool _66 = _56 != _65;
    _51 = _66;
    _jump72:;
    bool _67;
    if (!_51)
    goto _jump77;
    bool _68 = true;
    _67 = _68;
    goto _jump78;
    _jump77:;
    _a2_bool _69;
    // Computing bound for h
    _69.d0 = c.d2;
    if (c.d2 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing bound for i
    _69.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= c.d2;
    _70 *= c.d1;
    _70 *= sizeof(bool);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // i
    int64_t _72 = 0; // h
    _jump81:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _69.d0;
    _73 += _72;
    _73 *= _69.d1;
    _73 += _71;
    _69.data[_73] = a;
    _71++;
    if (_71 < c.d1)
    goto _jump81;
    _71 = 0;
    _72++;
    if (_72 < c.d2)
    goto _jump81;
    // End body of loop
    int64_t _74 = 252;
    int64_t _75 = c.d2 + c.d1;
    int64_t _76 = -_75;
    if (_74 >= 0)
    goto _jump82;
    fail_assertion("negative array index");
    _jump82:;
    if (_74 < _69.d0)
    goto _jump83;
    fail_assertion("index too large");
    _jump83:;
    if (_76 >= 0)
    goto _jump84;
    fail_assertion("negative array index");
    _jump84:;
    if (_76 < _69.d1)
    goto _jump85;
    fail_assertion("index too large");
    _jump85:;
    int64_t _77 = 0;
    _77 *= _69.d0;
    _77 += _74;
    _77 *= _69.d1;
    _77 += _76;
    bool _78 = _69.data[_77];
    bool _79;
    if (!_78)
    goto _jump86;
    bool _80 = true;
    _79 = _80;
    goto _jump87;
    _jump86:;
    bool _81 = false;
    _79 = _81;
    _jump87:;
    bool _82;
    if (!_79)
    goto _jump88;
    bool _84 = true;
    bool _83 = _84;
    if (0 != _84)
    goto _jump89;
    _83 = a;
    _jump89:;
    int64_t _85;
    if (!_83)
    goto _jump90;
    _a2_int64_t _86;
    // Computing bound for h
    _86.d0 = c.d2;
    if (c.d2 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for i
    _86.d1 = c.d2;
    if (c.d2 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= c.d2;
    _87 *= c.d2;
    _87 *= sizeof(int64_t);
    _86.data = jpl_alloc(_87);
    int64_t _88 = 0; // i
    int64_t _89 = 0; // h
    _jump93:; // Begin body of loop
    int64_t _90 = 478;
    int64_t _91 = 0;
    _91 *= _86.d0;
    _91 += _89;
    _91 *= _86.d1;
    _91 += _88;
    _86.data[_91] = _90;
    _88++;
    if (_88 < c.d2)
    goto _jump93;
    _88 = 0;
    _89++;
    if (_89 < c.d2)
    goto _jump93;
    // End body of loop
    if (c.d1 >= 0)
    goto _jump94;
    fail_assertion("negative array index");
    _jump94:;
    if (c.d1 < _86.d0)
    goto _jump95;
    fail_assertion("index too large");
    _jump95:;
    if (c.d1 >= 0)
    goto _jump96;
    fail_assertion("negative array index");
    _jump96:;
    if (c.d1 < _86.d1)
    goto _jump97;
    fail_assertion("index too large");
    _jump97:;
    int64_t _92 = 0;
    _92 *= _86.d0;
    _92 += c.d1;
    _92 *= _86.d1;
    _92 += c.d1;
    int64_t _93 = _86.data[_92];
    _85 = _93;
    goto _jump98;
    _jump90:;
    bool _94 = !a;
    int64_t _95;
    if (!_94)
    goto _jump99;
    int64_t _96 = c.d2 * c.d2;
    _95 = _96;
    goto _jump100;
    _jump99:;
    int64_t _97 = -c.d0;
    _95 = _97;
    _jump100:;
    _85 = _95;
    _jump98:;
    bool _98 = c.d2 < _85;
    _82 = _98;
    goto _jump101;
    _jump88:;
    double _99 = 26.0;
    double _100 = -_99;
    double _101 = 31.0;
    double _102 = -_101;
    bool _103 = _100 != _102;
    bool _104;
    if (!_103)
    goto _jump102;
    _104 = a;
    goto _jump103;
    _jump102:;
    bool _105 = true;
    bool _106 = a == _105;
    _104 = _106;
    _jump103:;
    bool _107;
    if (!_104)
    goto _jump104;
    _107 = a;
    goto _jump105;
    _jump104:;
    int64_t _108 = c.d1 + c.d2;
    int64_t _109 = 646;
    bool _110 = _108 <= _109;
    _107 = _110;
    _jump105:;
    _82 = _107;
    _jump101:;
    _67 = _82;
    _jump78:;
    bool _111;
    if (!_67)
    goto _jump106;
    bool _112 = false;
    bool _113 = false;
    _a1_bool _114;
    _114.d0 = 2;
    _114.data = jpl_alloc(sizeof(bool) * 2);
    _114.data[0] = _112;
    _114.data[1] = _113;
    int64_t _115 = c.d0 * c.d0;
    if (_115 >= 0)
    goto _jump107;
    fail_assertion("negative array index");
    _jump107:;
    if (_115 < _114.d0)
    goto _jump108;
    fail_assertion("index too large");
    _jump108:;
    int64_t _116 = 0;
    _116 *= _114.d0;
    _116 += _115;
    bool _117 = _114.data[_116];
    _a3_bool _118;
    if (!_117)
    goto _jump109;
    _a3_bool _119;
    // Computing bound for h
    _119.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing bound for i
    int64_t _120 = c.d1 % c.d2;
    _119.d1 = _120;
    if (_120 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing bound for j
    _119.d2 = c.d1;
    if (c.d1 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= c.d0;
    _121 *= _120;
    _121 *= c.d1;
    _121 *= sizeof(bool);
    _119.data = jpl_alloc(_121);
    int64_t _122 = 0; // j
    int64_t _123 = 0; // i
    int64_t _124 = 0; // h
    _jump113:; // Begin body of loop
    int64_t _125 = 464;
    bool _126 = _123 > _125;
    int64_t _127 = 0;
    _127 *= _119.d0;
    _127 += _124;
    _127 *= _119.d1;
    _127 += _123;
    _127 *= _119.d2;
    _127 += _122;
    _119.data[_127] = _126;
    _122++;
    if (_122 < c.d1)
    goto _jump113;
    _122 = 0;
    _123++;
    if (_123 < _120)
    goto _jump113;
    _123 = 0;
    _124++;
    if (_124 < c.d0)
    goto _jump113;
    // End body of loop
    _118 = _119;
    goto _jump114;
    _jump109:;
    _a3_bool _128;
    // Computing bound for h
    int64_t _129 = c.d2 / c.d1;
    _128.d0 = _129;
    if (_129 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing bound for i
    int64_t _130;
    // Computing bound for h
    if (c.d2 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    // Computing bound for i
    if (c.d1 > 0) 
    goto _jump117;
    fail_assertion("non-positive loop bound");
    _jump117:;
    // Computing bound for j
    if (c.d2 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    _130 = 0;
    int64_t _131 = 0; // j
    int64_t _132 = 0; // i
    int64_t _133 = 0; // h
    _jump119:; // Begin body of loop
    _130 += c.d0;
    _131++;
    if (_131 < c.d2)
    goto _jump119;
    _131 = 0;
    _132++;
    if (_132 < c.d1)
    goto _jump119;
    _132 = 0;
    _133++;
    if (_133 < c.d2)
    goto _jump119;
    // End body of loop
    _128.d1 = _130;
    if (_130 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    // Computing bound for j
    _128.d2 = c.d0;
    if (c.d0 > 0) 
    goto _jump121;
    fail_assertion("non-positive loop bound");
    _jump121:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= _129;
    _134 *= _130;
    _134 *= c.d0;
    _134 *= sizeof(bool);
    _128.data = jpl_alloc(_134);
    int64_t _135 = 0; // j
    int64_t _136 = 0; // i
    int64_t _137 = 0; // h
    _jump122:; // Begin body of loop
    bool _138 = true;
    int64_t _139 = 0;
    _139 *= _128.d0;
    _139 += _137;
    _139 *= _128.d1;
    _139 += _136;
    _139 *= _128.d2;
    _139 += _135;
    _128.data[_139] = _138;
    _135++;
    if (_135 < c.d0)
    goto _jump122;
    _135 = 0;
    _136++;
    if (_136 < _130)
    goto _jump122;
    _136 = 0;
    _137++;
    if (_137 < _129)
    goto _jump122;
    // End body of loop
    _118 = _128;
    _jump114:;
    int64_t _140 = 453;
    int64_t _141 = -_140;
    int64_t _142 = -_141;
    int64_t _143;
    // Computing bound for h
    if (c.d0 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    // Computing bound for i
    if (c.d2 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    // Computing bound for j
    if (c.d2 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    _143 = 0;
    int64_t _144 = 0; // j
    int64_t _145 = 0; // i
    int64_t _146 = 0; // h
    _jump126:; // Begin body of loop
    _143 += c.d2;
    _144++;
    if (_144 < c.d2)
    goto _jump126;
    _144 = 0;
    _145++;
    if (_145 < c.d2)
    goto _jump126;
    _145 = 0;
    _146++;
    if (_146 < c.d0)
    goto _jump126;
    // End body of loop
    if (_142 >= 0)
    goto _jump127;
    fail_assertion("negative array index");
    _jump127:;
    if (_142 < _118.d0)
    goto _jump128;
    fail_assertion("index too large");
    _jump128:;
    if (c.d2 >= 0)
    goto _jump129;
    fail_assertion("negative array index");
    _jump129:;
    if (c.d2 < _118.d1)
    goto _jump130;
    fail_assertion("index too large");
    _jump130:;
    if (_143 >= 0)
    goto _jump131;
    fail_assertion("negative array index");
    _jump131:;
    if (_143 < _118.d2)
    goto _jump132;
    fail_assertion("index too large");
    _jump132:;
    int64_t _147 = 0;
    _147 *= _118.d0;
    _147 += _142;
    _147 *= _118.d1;
    _147 += c.d2;
    _147 *= _118.d2;
    _147 += _143;
    bool _148 = _118.data[_147];
    bool _149 = !_148;
    int64_t _150;
    // Computing bound for h
    if (c.d0 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    _150 = 0;
    int64_t _151 = 0; // h
    _jump134:; // Begin body of loop
    bool _152 = !a;
    bool _153 = !_152;
    int64_t _154;
    if (!_153)
    goto _jump135;
    _a2_int64_t _155;
    // Computing bound for i
    _155.d0 = c.d2;
    if (c.d2 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    // Computing bound for j
    _155.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= c.d2;
    _156 *= c.d0;
    _156 *= sizeof(int64_t);
    _155.data = jpl_alloc(_156);
    int64_t _157 = 0; // j
    int64_t _158 = 0; // i
    _jump138:; // Begin body of loop
    int64_t _159 = 727;
    int64_t _160 = 0;
    _160 *= _155.d0;
    _160 += _158;
    _160 *= _155.d1;
    _160 += _157;
    _155.data[_160] = _159;
    _157++;
    if (_157 < c.d0)
    goto _jump138;
    _157 = 0;
    _158++;
    if (_158 < c.d2)
    goto _jump138;
    // End body of loop
    int64_t _161 = 235;
    if (_161 >= 0)
    goto _jump139;
    fail_assertion("negative array index");
    _jump139:;
    if (_161 < _155.d0)
    goto _jump140;
    fail_assertion("index too large");
    _jump140:;
    if (c.d2 >= 0)
    goto _jump141;
    fail_assertion("negative array index");
    _jump141:;
    if (c.d2 < _155.d1)
    goto _jump142;
    fail_assertion("index too large");
    _jump142:;
    int64_t _162 = 0;
    _162 *= _155.d0;
    _162 += _161;
    _162 *= _155.d1;
    _162 += c.d2;
    int64_t _163 = _155.data[_162];
    _154 = _163;
    goto _jump143;
    _jump135:;
    _154 = c.d0;
    _jump143:;
    _150 += _154;
    _151++;
    if (_151 < c.d0)
    goto _jump134;
    // End body of loop
    int64_t _164 = 429;
    bool _165 = _150 > _164;
    bool _166 = _149 == _165;
    _111 = _166;
    goto _jump144;
    _jump106:;
    int64_t _167;
    // Computing bound for h
    if (c.d2 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    _167 = 0;
    int64_t _168 = 0; // h
    _jump146:; // Begin body of loop
    _167 += c.d0;
    _168++;
    if (_168 < c.d2)
    goto _jump146;
    // End body of loop
    int64_t _169 = -_167;
    int64_t _170 = _169 / c.d2;
    int64_t _171 = -c.d2;
    bool _172 = _170 == _171;
    bool _173 = !_172;
    bool _174 = !_173;
    _111 = _174;
    _jump144:;
    if (0 != _111)
    goto _jump147;
    fail_assertion("h");
    _jump147:;
    int64_t _175;
    // Computing bound for h
    if (c.d1 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    // Computing bound for i
    if (c.d2 > 0) 
    goto _jump149;
    fail_assertion("non-positive loop bound");
    _jump149:;
    _175 = 0;
    int64_t _176 = 0; // i
    int64_t _177 = 0; // h
    _jump150:; // Begin body of loop
    bool _179 = a;
    if (0 != a)
    goto _jump151;
    bool _180 = false;
    bool _181 = !_180;
    _179 = _181;
    _jump151:;
    bool _178 = _179;
    if (0 == _179)
    goto _jump152;
    _a3_int64_t _182;
    // Computing bound for j
    _182.d0 = c.d2;
    if (c.d2 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing bound for k
    _182.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for l
    _182.d2 = _177;
    if (_177 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= c.d2;
    _183 *= c.d0;
    _183 *= _177;
    _183 *= sizeof(int64_t);
    _182.data = jpl_alloc(_183);
    int64_t _184 = 0; // l
    int64_t _185 = 0; // k
    int64_t _186 = 0; // j
    _jump156:; // Begin body of loop
    int64_t _187 = 0;
    _187 *= _182.d0;
    _187 += _186;
    _187 *= _182.d1;
    _187 += _185;
    _187 *= _182.d2;
    _187 += _184;
    _182.data[_187] = c.d2;
    _184++;
    if (_184 < _177)
    goto _jump156;
    _184 = 0;
    _185++;
    if (_185 < c.d0)
    goto _jump156;
    _185 = 0;
    _186++;
    if (_186 < c.d2)
    goto _jump156;
    // End body of loop
    int64_t _188 = -c.d1;
    int64_t _189 = -_188;
    if (_176 >= 0)
    goto _jump157;
    fail_assertion("negative array index");
    _jump157:;
    if (_176 < _182.d0)
    goto _jump158;
    fail_assertion("index too large");
    _jump158:;
    if (_176 >= 0)
    goto _jump159;
    fail_assertion("negative array index");
    _jump159:;
    if (_176 < _182.d1)
    goto _jump160;
    fail_assertion("index too large");
    _jump160:;
    if (_189 >= 0)
    goto _jump161;
    fail_assertion("negative array index");
    _jump161:;
    if (_189 < _182.d2)
    goto _jump162;
    fail_assertion("index too large");
    _jump162:;
    int64_t _190 = 0;
    _190 *= _182.d0;
    _190 += _176;
    _190 *= _182.d1;
    _190 += _176;
    _190 *= _182.d2;
    _190 += _189;
    int64_t _191 = _182.data[_190];
    int64_t _192 = 608;
    bool _193 = _191 > _192;
    _178 = _193;
    _jump152:;
    int64_t _194;
    if (!_178)
    goto _jump163;
    int64_t _195;
    // Computing bound for j
    int64_t _196 = 656;
    int64_t _197 = -_196;
    if (_197 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    _195 = 0;
    int64_t _198 = 0; // j
    _jump165:; // Begin body of loop
    int64_t _199 = _176 - c.d1;
    int64_t _200 = _199 - c.d2;
    int64_t _201 = -_200;
    _195 += _201;
    _198++;
    if (_198 < _197)
    goto _jump165;
    // End body of loop
    _194 = _195;
    goto _jump166;
    _jump163:;
    bool _202 = a;
    if (0 != a)
    goto _jump167;
    bool _203;
    if (!a)
    goto _jump168;
    _203 = a;
    goto _jump169;
    _jump168:;
    _203 = a;
    _jump169:;
    bool _204 = !_203;
    _202 = _204;
    _jump167:;
    int64_t _205;
    if (!_202)
    goto _jump170;
    _205 = c.d2;
    goto _jump171;
    _jump170:;
    int64_t _206 = 993;
    int64_t _207 = -_206;
    int64_t _208 = _177 % _207;
    _205 = _208;
    _jump171:;
    int64_t _209 = c.d2 % _205;
    _194 = _209;
    _jump166:;
    _175 += _194;
    _176++;
    if (_176 < c.d2)
    goto _jump150;
    _176 = 0;
    _177++;
    if (_177 < c.d1)
    goto _jump150;
    // End body of loop
    bool _210 = true;
    bool _211 = false;
    bool _212 = _210 == _211;
    if (0 != _212)
    goto _jump172;
    fail_assertion("i");
    _jump172:;
    void_t _213 = b(c);
    return _213;
}

bool c(_a2_double d) {
    _a2_double _0;
    // Computing bound for g
    int64_t _1;
    // Computing bound for g
    int64_t _2 = -d.d0;
    _a1_int64_t _3;
    _3.d0 = 1;
    _3.data = jpl_alloc(sizeof(int64_t) * 1);
    _3.data[0] = _2;
    int64_t _4 = -d.d0;
    int64_t _5 = -_4;
    if (_5 >= 0)
    goto _jump173;
    fail_assertion("negative array index");
    _jump173:;
    if (_5 < _3.d0)
    goto _jump174;
    fail_assertion("index too large");
    _jump174:;
    int64_t _6 = 0;
    _6 *= _3.d0;
    _6 += _5;
    int64_t _7 = _3.data[_6];
    if (_7 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing bound for h
    double _8 = 72.0;
    double _9;
    // Computing bound for g
    int64_t _10 = 72;
    if (_10 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    _9 = 0;
    int64_t _11 = 0; // g
    _jump177:; // Begin body of loop
    double _12 = 77.0;
    _9 += _12;
    _11++;
    if (_11 < _10)
    goto _jump177;
    // End body of loop
    bool _13 = _8 == _9;
    int64_t _14;
    if (!_13)
    goto _jump178;
    _14 = d.d0;
    goto _jump179;
    _jump178:;
    int64_t _15 = 334;
    _14 = _15;
    _jump179:;
    if (_14 > 0) 
    goto _jump180;
    fail_assertion("non-positive loop bound");
    _jump180:;
    // Computing bound for i
    int64_t _16 = 6;
    if (_16 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    _1 = 0;
    int64_t _17 = 0; // i
    int64_t _18 = 0; // h
    int64_t _19 = 0; // g
    _jump182:; // Begin body of loop
    bool _20;
    if (!a)
    goto _jump183;
    bool _21 = false;
    _20 = _21;
    goto _jump184;
    _jump183:;
    bool _22 = true;
    _20 = _22;
    _jump184:;
    bool _23 = !_20;
    int64_t _24;
    if (!_23)
    goto _jump185;
    _a1_int64_t _25;
    // Computing bound for j
    _25.d0 = _17;
    if (_17 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= _17;
    _26 *= sizeof(int64_t);
    _25.data = jpl_alloc(_26);
    int64_t _27 = 0; // j
    _jump187:; // Begin body of loop
    int64_t _28 = 0;
    _28 *= _25.d0;
    _28 += _27;
    _25.data[_28] = _18;
    _27++;
    if (_27 < _17)
    goto _jump187;
    // End body of loop
    int64_t _29 = 469;
    if (_29 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_29 < _25.d0)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    int64_t _30 = 0;
    _30 *= _25.d0;
    _30 += _29;
    int64_t _31 = _25.data[_30];
    _24 = _31;
    goto _jump190;
    _jump185:;
    _a1_int64_t _32;
    // Computing bound for j
    _32.d0 = _18;
    if (_18 > 0) 
    goto _jump191;
    fail_assertion("non-positive loop bound");
    _jump191:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= _18;
    _33 *= sizeof(int64_t);
    _32.data = jpl_alloc(_33);
    int64_t _34 = 0; // j
    _jump192:; // Begin body of loop
    int64_t _35 = 0;
    _35 *= _32.d0;
    _35 += _34;
    _32.data[_35] = _18;
    _34++;
    if (_34 < _18)
    goto _jump192;
    // End body of loop
    if (_17 >= 0)
    goto _jump193;
    fail_assertion("negative array index");
    _jump193:;
    if (_17 < _32.d0)
    goto _jump194;
    fail_assertion("index too large");
    _jump194:;
    int64_t _36 = 0;
    _36 *= _32.d0;
    _36 += _17;
    int64_t _37 = _32.data[_36];
    _24 = _37;
    _jump190:;
    _1 += _24;
    _17++;
    if (_17 < _16)
    goto _jump182;
    _17 = 0;
    _18++;
    if (_18 < _14)
    goto _jump182;
    _18 = 0;
    _19++;
    if (_19 < _7)
    goto _jump182;
    // End body of loop
    int64_t _38 = 582;
    int64_t _39 = _1 * _38;
    _0.d0 = _39;
    if (_39 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    // Computing bound for h
    int64_t _40 = 598;
    _0.d1 = _40;
    if (_40 > 0) 
    goto _jump196;
    fail_assertion("non-positive loop bound");
    _jump196:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= _39;
    _41 *= _40;
    _41 *= sizeof(double);
    _0.data = jpl_alloc(_41);
    int64_t _42 = 0; // h
    int64_t _43 = 0; // g
    _jump197:; // Begin body of loop
    double _44 = 70.0;
    int64_t _45 = 0;
    _45 *= _0.d0;
    _45 += _43;
    _45 *= _0.d1;
    _45 += _42;
    _0.data[_45] = _44;
    _42++;
    if (_42 < _40)
    goto _jump197;
    _42 = 0;
    _43++;
    if (_43 < _39)
    goto _jump197;
    // End body of loop
    bool _46 = c(_0);
    int64_t _47;
    // Computing bound for i
    int64_t _48;
    // Computing bound for i
    int64_t _49 = 371;
    _a1_int64_t _50;
    _50.d0 = 3;
    _50.data = jpl_alloc(sizeof(int64_t) * 3);
    _50.data[0] = d.d0;
    _50.data[1] = d.d1;
    _50.data[2] = _49;
    if (d.d1 >= 0)
    goto _jump198;
    fail_assertion("negative array index");
    _jump198:;
    if (d.d1 < _50.d0)
    goto _jump199;
    fail_assertion("index too large");
    _jump199:;
    int64_t _51 = 0;
    _51 *= _50.d0;
    _51 += d.d1;
    int64_t _52 = _50.data[_51];
    if (_52 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    _48 = 0;
    int64_t _53 = 0; // j
    int64_t _54 = 0; // i
    _jump202:; // Begin body of loop
    _48 += d.d0;
    _53++;
    if (_53 < d.d0)
    goto _jump202;
    _53 = 0;
    _54++;
    if (_54 < _52)
    goto _jump202;
    // End body of loop
    if (_48 > 0) 
    goto _jump203;
    fail_assertion("non-positive loop bound");
    _jump203:;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump204;
    fail_assertion("non-positive loop bound");
    _jump204:;
    // Computing bound for k
    int64_t _55 = 210;
    if (_55 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    _47 = 0;
    int64_t _56 = 0; // k
    int64_t _57 = 0; // j
    int64_t _58 = 0; // i
    _jump206:; // Begin body of loop
    _47 += _56;
    _56++;
    if (_56 < _55)
    goto _jump206;
    _56 = 0;
    _57++;
    if (_57 < d.d1)
    goto _jump206;
    _57 = 0;
    _58++;
    if (_58 < _48)
    goto _jump206;
    // End body of loop
    int64_t _60 = 267;
    int64_t _61 = _60 * d.d0;
    bool _62 = _47 >= _61;
    _a2_bool _63;
    if (!_62)
    goto _jump207;
    _a2_bool _64;
    // Computing bound for j
    int64_t _65 = 361;
    int64_t _66 = d.d0 / _65;
    _64.d0 = _66;
    if (_66 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing bound for k
    _64.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= _66;
    _67 *= d.d1;
    _67 *= sizeof(bool);
    _64.data = jpl_alloc(_67);
    int64_t _68 = 0; // k
    int64_t _69 = 0; // j
    _jump210:; // Begin body of loop
    bool _70 = c(d);
    int64_t _71 = 0;
    _71 *= _64.d0;
    _71 += _69;
    _71 *= _64.d1;
    _71 += _68;
    _64.data[_71] = _70;
    _68++;
    if (_68 < d.d1)
    goto _jump210;
    _68 = 0;
    _69++;
    if (_69 < _66)
    goto _jump210;
    // End body of loop
    _63 = _64;
    goto _jump211;
    _jump207:;
    _a2_bool _72;
    // Computing bound for j
    int64_t _73 = -d.d0;
    _72.d0 = _73;
    if (_73 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for k
    _72.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= _73;
    _74 *= d.d1;
    _74 *= sizeof(bool);
    _72.data = jpl_alloc(_74);
    int64_t _75 = 0; // k
    int64_t _76 = 0; // j
    _jump214:; // Begin body of loop
    bool _77 = false;
    int64_t _78 = 0;
    _78 *= _72.d0;
    _78 += _76;
    _78 *= _72.d1;
    _78 += _75;
    _72.data[_78] = _77;
    _75++;
    if (_75 < d.d1)
    goto _jump214;
    _75 = 0;
    _76++;
    if (_76 < _73)
    goto _jump214;
    // End body of loop
    _63 = _72;
    _jump211:;
    _a2_int64_t _79;
    // Computing bound for j
    int64_t _80 = 541;
    _79.d0 = _80;
    if (_80 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing bound for k
    _79.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump216;
    fail_assertion("non-positive loop bound");
    _jump216:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= _80;
    _81 *= d.d1;
    _81 *= sizeof(int64_t);
    _79.data = jpl_alloc(_81);
    int64_t _82 = 0; // k
    int64_t _83 = 0; // j
    _jump217:; // Begin body of loop
    int64_t _84 = 280;
    int64_t _85 = _84 - d.d1;
    int64_t _86 = 0;
    _86 *= _79.d0;
    _86 += _83;
    _86 *= _79.d1;
    _86 += _82;
    _79.data[_86] = _85;
    _82++;
    if (_82 < d.d1)
    goto _jump217;
    _82 = 0;
    _83++;
    if (_83 < _80)
    goto _jump217;
    // End body of loop
    int64_t _87 = 988;
    if (_87 >= 0)
    goto _jump218;
    fail_assertion("negative array index");
    _jump218:;
    if (_87 < _79.d0)
    goto _jump219;
    fail_assertion("index too large");
    _jump219:;
    if (d.d1 >= 0)
    goto _jump220;
    fail_assertion("negative array index");
    _jump220:;
    if (d.d1 < _79.d1)
    goto _jump221;
    fail_assertion("index too large");
    _jump221:;
    int64_t _88 = 0;
    _88 *= _79.d0;
    _88 += _87;
    _88 *= _79.d1;
    _88 += d.d1;
    int64_t _89 = _79.data[_88];
    if (d.d0 >= 0)
    goto _jump222;
    fail_assertion("negative array index");
    _jump222:;
    if (d.d0 < _63.d0)
    goto _jump223;
    fail_assertion("index too large");
    _jump223:;
    if (_89 >= 0)
    goto _jump224;
    fail_assertion("negative array index");
    _jump224:;
    if (_89 < _63.d1)
    goto _jump225;
    fail_assertion("index too large");
    _jump225:;
    int64_t _90 = 0;
    _90 *= _63.d0;
    _90 += d.d0;
    _90 *= _63.d1;
    _90 += _89;
    bool _91 = _63.data[_90];
    bool _59 = _91;
    if (0 != _91)
    goto _jump226;
    int64_t _92 = 831;
    int64_t _93;
    // Computing bound for j
    int64_t _94 = 76;
    if (_94 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    _93 = 0;
    int64_t _95 = 0; // j
    _jump228:; // Begin body of loop
    _93 += d.d0;
    _95++;
    if (_95 < _94)
    goto _jump228;
    // End body of loop
    bool _96 = _92 == _93;
    _59 = _96;
    _jump226:;
    bool _97 = !_59;
    _a3__a1_bool _98;
    if (!_97)
    goto _jump229;
    _a3__a1_bool _99;
    // Computing bound for j
    int64_t _100;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for k
    int64_t _101;
    if (!_46)
    goto _jump231;
    bool _102;
    if (!a)
    goto _jump232;
    _102 = _46;
    goto _jump233;
    _jump232:;
    bool _103 = c(d);
    _102 = _103;
    _jump233:;
    int64_t _104;
    if (!_102)
    goto _jump234;
    _104 = _47;
    goto _jump235;
    _jump234:;
    _104 = d.d0;
    _jump235:;
    _101 = _104;
    goto _jump236;
    _jump231:;
    int64_t _105 = 113;
    _101 = _105;
    _jump236:;
    if (_101 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing bound for l
    _a3_int64_t _106;
    // Computing bound for j
    int64_t _107;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump238;
    fail_assertion("non-positive loop bound");
    _jump238:;
    // Computing bound for k
    if (d.d1 > 0) 
    goto _jump239;
    fail_assertion("non-positive loop bound");
    _jump239:;
    // Computing bound for l
    int64_t _108 = d.d0 + _47;
    if (_108 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    _107 = 0;
    int64_t _109 = 0; // l
    int64_t _110 = 0; // k
    int64_t _111 = 0; // j
    _jump241:; // Begin body of loop
    _107 += _47;
    _109++;
    if (_109 < _108)
    goto _jump241;
    _109 = 0;
    _110++;
    if (_110 < d.d1)
    goto _jump241;
    _110 = 0;
    _111++;
    if (_111 < d.d0)
    goto _jump241;
    // End body of loop
    _106.d0 = _107;
    if (_107 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing bound for k
    int64_t _112 = 153;
    _106.d1 = _112;
    if (_112 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    // Computing bound for l
    _106.d2 = _47;
    if (_47 > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing total size of heap memory to allocate
    int64_t _113 = 1;
    _113 *= _107;
    _113 *= _112;
    _113 *= _47;
    _113 *= sizeof(int64_t);
    _106.data = jpl_alloc(_113);
    int64_t _114 = 0; // l
    int64_t _115 = 0; // k
    int64_t _116 = 0; // j
    _jump245:; // Begin body of loop
    int64_t _117 = 0;
    _117 *= _106.d0;
    _117 += _116;
    _117 *= _106.d1;
    _117 += _115;
    _117 *= _106.d2;
    _117 += _114;
    _106.data[_117] = _47;
    _114++;
    if (_114 < _47)
    goto _jump245;
    _114 = 0;
    _115++;
    if (_115 < _112)
    goto _jump245;
    _115 = 0;
    _116++;
    if (_116 < _107)
    goto _jump245;
    // End body of loop
    int64_t _118 = 504;
    int64_t _119 = -_118;
    int64_t _120 = -_119;
    int64_t _121 = -_120;
    _a3_int64_t _122;
    // Computing bound for j
    _122.d0 = _47;
    if (_47 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing bound for k
    int64_t _123;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    // Computing bound for k
    if (_47 > 0) 
    goto _jump248;
    fail_assertion("non-positive loop bound");
    _jump248:;
    // Computing bound for l
    if (d.d1 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    _123 = 0;
    int64_t _124 = 0; // l
    int64_t _125 = 0; // k
    int64_t _126 = 0; // j
    _jump250:; // Begin body of loop
    int64_t _127 = 613;
    _123 += _127;
    _124++;
    if (_124 < d.d1)
    goto _jump250;
    _124 = 0;
    _125++;
    if (_125 < _47)
    goto _jump250;
    _125 = 0;
    _126++;
    if (_126 < d.d1)
    goto _jump250;
    // End body of loop
    _122.d1 = _123;
    if (_123 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing bound for l
    int64_t _128;
    // Computing bound for j
    if (d.d1 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    _128 = 0;
    int64_t _129 = 0; // j
    _jump253:; // Begin body of loop
    int64_t _130 = 967;
    _128 += _130;
    _129++;
    if (_129 < d.d1)
    goto _jump253;
    // End body of loop
    _122.d2 = _128;
    if (_128 > 0) 
    goto _jump254;
    fail_assertion("non-positive loop bound");
    _jump254:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= _47;
    _131 *= _123;
    _131 *= _128;
    _131 *= sizeof(int64_t);
    _122.data = jpl_alloc(_131);
    int64_t _132 = 0; // l
    int64_t _133 = 0; // k
    int64_t _134 = 0; // j
    _jump255:; // Begin body of loop
    int64_t _135 = 0;
    _135 *= _122.d0;
    _135 += _134;
    _135 *= _122.d1;
    _135 += _133;
    _135 *= _122.d2;
    _135 += _132;
    _122.data[_135] = _47;
    _132++;
    if (_132 < _128)
    goto _jump255;
    _132 = 0;
    _133++;
    if (_133 < _123)
    goto _jump255;
    _133 = 0;
    _134++;
    if (_134 < _47)
    goto _jump255;
    // End body of loop
    int64_t _136 = 753;
    int64_t _137 = 98;
    if (_136 >= 0)
    goto _jump256;
    fail_assertion("negative array index");
    _jump256:;
    if (_136 < _122.d0)
    goto _jump257;
    fail_assertion("index too large");
    _jump257:;
    if (d.d1 >= 0)
    goto _jump258;
    fail_assertion("negative array index");
    _jump258:;
    if (d.d1 < _122.d1)
    goto _jump259;
    fail_assertion("index too large");
    _jump259:;
    if (_137 >= 0)
    goto _jump260;
    fail_assertion("negative array index");
    _jump260:;
    if (_137 < _122.d2)
    goto _jump261;
    fail_assertion("index too large");
    _jump261:;
    int64_t _138 = 0;
    _138 *= _122.d0;
    _138 += _136;
    _138 *= _122.d1;
    _138 += d.d1;
    _138 *= _122.d2;
    _138 += _137;
    int64_t _139 = _122.data[_138];
    int64_t _140;
    // Computing bound for j
    int64_t _141 = 303;
    if (_141 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing bound for k
    if (_47 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    _140 = 0;
    int64_t _142 = 0; // k
    int64_t _143 = 0; // j
    _jump264:; // Begin body of loop
    _140 += _142;
    _142++;
    if (_142 < _47)
    goto _jump264;
    _142 = 0;
    _143++;
    if (_143 < _141)
    goto _jump264;
    // End body of loop
    int64_t _144 = d.d1 * _140;
    if (_121 >= 0)
    goto _jump265;
    fail_assertion("negative array index");
    _jump265:;
    if (_121 < _106.d0)
    goto _jump266;
    fail_assertion("index too large");
    _jump266:;
    if (_139 >= 0)
    goto _jump267;
    fail_assertion("negative array index");
    _jump267:;
    if (_139 < _106.d1)
    goto _jump268;
    fail_assertion("index too large");
    _jump268:;
    if (_144 >= 0)
    goto _jump269;
    fail_assertion("negative array index");
    _jump269:;
    if (_144 < _106.d2)
    goto _jump270;
    fail_assertion("index too large");
    _jump270:;
    int64_t _145 = 0;
    _145 *= _106.d0;
    _145 += _121;
    _145 *= _106.d1;
    _145 += _139;
    _145 *= _106.d2;
    _145 += _144;
    int64_t _146 = _106.data[_145];
    if (_146 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    _100 = 0;
    int64_t _147 = 0; // l
    int64_t _148 = 0; // k
    int64_t _149 = 0; // j
    _jump272:; // Begin body of loop
    int64_t _150 = 503;
    int64_t _151 = -_150;
    int64_t _152 = -_151;
    _100 += _152;
    _147++;
    if (_147 < _146)
    goto _jump272;
    _147 = 0;
    _148++;
    if (_148 < _101)
    goto _jump272;
    _148 = 0;
    _149++;
    if (_149 < d.d0)
    goto _jump272;
    // End body of loop
    _99.d0 = _100;
    if (_100 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    // Computing bound for k
    int64_t _153 = 781;
    _99.d1 = _153;
    if (_153 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing bound for l
    int64_t _154 = 416;
    int64_t _155 = _47 * _154;
    _99.d2 = _155;
    if (_155 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= _100;
    _156 *= _153;
    _156 *= _155;
    _156 *= sizeof(_a1_bool);
    _99.data = jpl_alloc(_156);
    int64_t _157 = 0; // l
    int64_t _158 = 0; // k
    int64_t _159 = 0; // j
    _jump276:; // Begin body of loop
    double _160;
    // Computing bound for m
    if (d.d1 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for n
    if (_158 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing bound for o
    int64_t _161 = _159 / d.d1;
    if (_161 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    _160 = 0;
    int64_t _162 = 0; // o
    int64_t _163 = 0; // n
    int64_t _164 = 0; // m
    _jump280:; // Begin body of loop
    double _165;
    // Computing bound for p
    if (_162 > 0) 
    goto _jump281;
    fail_assertion("non-positive loop bound");
    _jump281:;
    // Computing bound for q
    if (d.d1 > 0) 
    goto _jump282;
    fail_assertion("non-positive loop bound");
    _jump282:;
    _165 = 0;
    int64_t _166 = 0; // q
    int64_t _167 = 0; // p
    _jump283:; // Begin body of loop
    if (d.d0 >= 0)
    goto _jump284;
    fail_assertion("negative array index");
    _jump284:;
    if (d.d0 < d.d0)
    goto _jump285;
    fail_assertion("index too large");
    _jump285:;
    if (_164 >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (_164 < d.d1)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    int64_t _168 = 0;
    _168 *= d.d0;
    _168 += d.d0;
    _168 *= d.d1;
    _168 += _164;
    double _169 = d.data[_168];
    _165 += _169;
    _166++;
    if (_166 < d.d1)
    goto _jump283;
    _166 = 0;
    _167++;
    if (_167 < _162)
    goto _jump283;
    // End body of loop
    _160 += _165;
    _162++;
    if (_162 < _161)
    goto _jump280;
    _162 = 0;
    _163++;
    if (_163 < _158)
    goto _jump280;
    _163 = 0;
    _164++;
    if (_164 < d.d1)
    goto _jump280;
    // End body of loop
    _a3_double _170;
    // Computing bound for m
    _170.d0 = _47;
    if (_47 > 0) 
    goto _jump288;
    fail_assertion("non-positive loop bound");
    _jump288:;
    // Computing bound for n
    _170.d1 = _47;
    if (_47 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    // Computing bound for o
    _170.d2 = _157;
    if (_157 > 0) 
    goto _jump290;
    fail_assertion("non-positive loop bound");
    _jump290:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _47;
    _171 *= _47;
    _171 *= _157;
    _171 *= sizeof(double);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // o
    int64_t _173 = 0; // n
    int64_t _174 = 0; // m
    _jump291:; // Begin body of loop
    double _175 = 45.0;
    int64_t _176 = 0;
    _176 *= _170.d0;
    _176 += _174;
    _176 *= _170.d1;
    _176 += _173;
    _176 *= _170.d2;
    _176 += _172;
    _170.data[_176] = _175;
    _172++;
    if (_172 < _157)
    goto _jump291;
    _172 = 0;
    _173++;
    if (_173 < _47)
    goto _jump291;
    _173 = 0;
    _174++;
    if (_174 < _47)
    goto _jump291;
    // End body of loop
    int64_t _177;
    // Computing bound for m
    int64_t _178 = 799;
    if (_178 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing bound for n
    if (d.d0 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    _177 = 0;
    int64_t _179 = 0; // n
    int64_t _180 = 0; // m
    _jump294:; // Begin body of loop
    int64_t _181 = -d.d0;
    _177 += _181;
    _179++;
    if (_179 < d.d0)
    goto _jump294;
    _179 = 0;
    _180++;
    if (_180 < _178)
    goto _jump294;
    // End body of loop
    if (_177 >= 0)
    goto _jump295;
    fail_assertion("negative array index");
    _jump295:;
    if (_177 < _170.d0)
    goto _jump296;
    fail_assertion("index too large");
    _jump296:;
    if (d.d1 >= 0)
    goto _jump297;
    fail_assertion("negative array index");
    _jump297:;
    if (d.d1 < _170.d1)
    goto _jump298;
    fail_assertion("index too large");
    _jump298:;
    if (_47 >= 0)
    goto _jump299;
    fail_assertion("negative array index");
    _jump299:;
    if (_47 < _170.d2)
    goto _jump300;
    fail_assertion("index too large");
    _jump300:;
    int64_t _182 = 0;
    _182 *= _170.d0;
    _182 += _177;
    _182 *= _170.d1;
    _182 += d.d1;
    _182 *= _170.d2;
    _182 += _47;
    double _183 = _170.data[_182];
    bool _184 = _160 <= _183;
    int64_t _187 = 152;
    int64_t _188 = -_157;
    bool _189 = _187 == _188;
    bool _186 = _189;
    if (0 != _189)
    goto _jump301;
    bool _190 = true;
    _186 = _190;
    _jump301:;
    bool _185 = _186;
    if (0 == _186)
    goto _jump302;
    _185 = a;
    _jump302:;
    _a3_bool _191;
    // Computing bound for m
    _191.d0 = _157;
    if (_157 > 0) 
    goto _jump303;
    fail_assertion("non-positive loop bound");
    _jump303:;
    // Computing bound for n
    int64_t _192 = -d.d1;
    _191.d1 = _192;
    if (_192 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for o
    int64_t _193 = 146;
    int64_t _194 = _193 + _157;
    _191.d2 = _194;
    if (_194 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= _157;
    _195 *= _192;
    _195 *= _194;
    _195 *= sizeof(bool);
    _191.data = jpl_alloc(_195);
    int64_t _196 = 0; // o
    int64_t _197 = 0; // n
    int64_t _198 = 0; // m
    _jump306:; // Begin body of loop
    int64_t _199 = 0;
    _199 *= _191.d0;
    _199 += _198;
    _199 *= _191.d1;
    _199 += _197;
    _199 *= _191.d2;
    _199 += _196;
    _191.data[_199] = a;
    _196++;
    if (_196 < _194)
    goto _jump306;
    _196 = 0;
    _197++;
    if (_197 < _192)
    goto _jump306;
    _197 = 0;
    _198++;
    if (_198 < _157)
    goto _jump306;
    // End body of loop
    bool _200 = !_46;
    int64_t _201;
    if (!_200)
    goto _jump307;
    int64_t _202 = -d.d0;
    _201 = _202;
    goto _jump308;
    _jump307:;
    bool _203 = false;
    int64_t _204;
    if (!_203)
    goto _jump309;
    _204 = _159;
    goto _jump310;
    _jump309:;
    _204 = _159;
    _jump310:;
    _201 = _204;
    _jump308:;
    int64_t _205 = 215;
    if (_201 >= 0)
    goto _jump311;
    fail_assertion("negative array index");
    _jump311:;
    if (_201 < _191.d0)
    goto _jump312;
    fail_assertion("index too large");
    _jump312:;
    if (_205 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (_205 < _191.d1)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    if (_159 >= 0)
    goto _jump315;
    fail_assertion("negative array index");
    _jump315:;
    if (_159 < _191.d2)
    goto _jump316;
    fail_assertion("index too large");
    _jump316:;
    int64_t _206 = 0;
    _206 *= _191.d0;
    _206 += _201;
    _206 *= _191.d1;
    _206 += _205;
    _206 *= _191.d2;
    _206 += _159;
    bool _207 = _191.data[_206];
    bool _208;
    if (!_207)
    goto _jump317;
    bool _209 = true;
    bool _210;
    if (!_209)
    goto _jump318;
    bool _211 = c(d);
    _210 = _211;
    goto _jump319;
    _jump318:;
    double _212 = 22.0;
    double _213 = -_212;
    double _214 = 48.0;
    bool _215 = _213 < _214;
    _210 = _215;
    _jump319:;
    _208 = _210;
    goto _jump320;
    _jump317:;
    bool _216 = true;
    bool _217 = a != _216;
    bool _218;
    if (!_217)
    goto _jump321;
    int64_t _219 = -_158;
    bool _220 = _219 <= _157;
    _218 = _220;
    goto _jump322;
    _jump321:;
    double _221 = 9.0;
    double _222 = 24.0;
    double _223 = _221 + _222;
    double _224 = 16.0;
    bool _225 = _223 != _224;
    _218 = _225;
    _jump322:;
    _208 = _218;
    _jump320:;
    _a1_bool _226;
    _226.d0 = 3;
    _226.data = jpl_alloc(sizeof(bool) * 3);
    _226.data[0] = _184;
    _226.data[1] = _185;
    _226.data[2] = _208;
    int64_t _227 = 0;
    _227 *= _99.d0;
    _227 += _159;
    _227 *= _99.d1;
    _227 += _158;
    _227 *= _99.d2;
    _227 += _157;
    _99.data[_227] = _226;
    _157++;
    if (_157 < _155)
    goto _jump276;
    _157 = 0;
    _158++;
    if (_158 < _153)
    goto _jump276;
    _158 = 0;
    _159++;
    if (_159 < _100)
    goto _jump276;
    // End body of loop
    _98 = _99;
    goto _jump323;
    _jump229:;
    _a2_double _228;
    // Computing bound for j
    _228.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing bound for k
    _228.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    // Computing total size of heap memory to allocate
    int64_t _229 = 1;
    _229 *= d.d0;
    _229 *= d.d0;
    _229 *= sizeof(double);
    _228.data = jpl_alloc(_229);
    int64_t _230 = 0; // k
    int64_t _231 = 0; // j
    _jump326:; // Begin body of loop
    double _232 = 15.0;
    int64_t _233 = 0;
    _233 *= _228.d0;
    _233 += _231;
    _233 *= _228.d1;
    _233 += _230;
    _228.data[_233] = _232;
    _230++;
    if (_230 < d.d0)
    goto _jump326;
    _230 = 0;
    _231++;
    if (_231 < d.d0)
    goto _jump326;
    // End body of loop
    bool _234 = c(_228);
    bool _235 = _46 != _234;
    _a3__a1_bool _236;
    if (!_235)
    goto _jump327;
    bool _238 = !_46;
    bool _237 = _238;
    if (0 == _238)
    goto _jump328;
    bool _239 = c(d);
    _237 = _239;
    _jump328:;
    _a3__a1_bool _240;
    if (!_237)
    goto _jump329;
    _a3__a1_bool _241;
    // Computing bound for j
    _241.d0 = _47;
    if (_47 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for k
    _241.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing bound for l
    int64_t _242 = d.d1 + d.d0;
    _241.d2 = _242;
    if (_242 > 0) 
    goto _jump332;
    fail_assertion("non-positive loop bound");
    _jump332:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= _47;
    _243 *= d.d0;
    _243 *= _242;
    _243 *= sizeof(_a1_bool);
    _241.data = jpl_alloc(_243);
    int64_t _244 = 0; // l
    int64_t _245 = 0; // k
    int64_t _246 = 0; // j
    _jump333:; // Begin body of loop
    _a1_bool _247;
    // Computing bound for m
    _247.d0 = _245;
    if (_245 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= _245;
    _248 *= sizeof(bool);
    _247.data = jpl_alloc(_248);
    int64_t _249 = 0; // m
    _jump335:; // Begin body of loop
    int64_t _250 = 0;
    _250 *= _247.d0;
    _250 += _249;
    _247.data[_250] = _46;
    _249++;
    if (_249 < _245)
    goto _jump335;
    // End body of loop
    int64_t _251 = 0;
    _251 *= _241.d0;
    _251 += _246;
    _251 *= _241.d1;
    _251 += _245;
    _251 *= _241.d2;
    _251 += _244;
    _241.data[_251] = _247;
    _244++;
    if (_244 < _242)
    goto _jump333;
    _244 = 0;
    _245++;
    if (_245 < d.d0)
    goto _jump333;
    _245 = 0;
    _246++;
    if (_246 < _47)
    goto _jump333;
    // End body of loop
    _240 = _241;
    goto _jump336;
    _jump329:;
    _a3__a1_bool _252;
    // Computing bound for j
    _252.d0 = _47;
    if (_47 > 0) 
    goto _jump337;
    fail_assertion("non-positive loop bound");
    _jump337:;
    // Computing bound for k
    int64_t _253;
    // Computing bound for j
    int64_t _254 = 698;
    if (_254 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for k
    if (_47 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    // Computing bound for l
    if (d.d0 > 0) 
    goto _jump340;
    fail_assertion("non-positive loop bound");
    _jump340:;
    _253 = 0;
    int64_t _255 = 0; // l
    int64_t _256 = 0; // k
    int64_t _257 = 0; // j
    _jump341:; // Begin body of loop
    _253 += d.d1;
    _255++;
    if (_255 < d.d0)
    goto _jump341;
    _255 = 0;
    _256++;
    if (_256 < _47)
    goto _jump341;
    _256 = 0;
    _257++;
    if (_257 < _254)
    goto _jump341;
    // End body of loop
    _252.d1 = _253;
    if (_253 > 0) 
    goto _jump342;
    fail_assertion("non-positive loop bound");
    _jump342:;
    // Computing bound for l
    int64_t _258 = 332;
    int64_t _259 = _258 + _47;
    _252.d2 = _259;
    if (_259 > 0) 
    goto _jump343;
    fail_assertion("non-positive loop bound");
    _jump343:;
    // Computing total size of heap memory to allocate
    int64_t _260 = 1;
    _260 *= _47;
    _260 *= _253;
    _260 *= _259;
    _260 *= sizeof(_a1_bool);
    _252.data = jpl_alloc(_260);
    int64_t _261 = 0; // l
    int64_t _262 = 0; // k
    int64_t _263 = 0; // j
    _jump344:; // Begin body of loop
    _a1_bool _264;
    // Computing bound for m
    _264.d0 = _47;
    if (_47 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= _47;
    _265 *= sizeof(bool);
    _264.data = jpl_alloc(_265);
    int64_t _266 = 0; // m
    _jump346:; // Begin body of loop
    int64_t _267 = 0;
    _267 *= _264.d0;
    _267 += _266;
    _264.data[_267] = a;
    _266++;
    if (_266 < _47)
    goto _jump346;
    // End body of loop
    int64_t _268 = 0;
    _268 *= _252.d0;
    _268 += _263;
    _268 *= _252.d1;
    _268 += _262;
    _268 *= _252.d2;
    _268 += _261;
    _252.data[_268] = _264;
    _261++;
    if (_261 < _259)
    goto _jump344;
    _261 = 0;
    _262++;
    if (_262 < _253)
    goto _jump344;
    _262 = 0;
    _263++;
    if (_263 < _47)
    goto _jump344;
    // End body of loop
    _240 = _252;
    _jump336:;
    _236 = _240;
    goto _jump347;
    _jump327:;
    _a3__a1_bool _269;
    if (!_46)
    goto _jump348;
    _a3__a1_bool _270;
    // Computing bound for j
    int64_t _271 = 359;
    _270.d0 = _271;
    if (_271 > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing bound for k
    int64_t _272 = 302;
    _270.d1 = _272;
    if (_272 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for l
    int64_t _273 = -_47;
    _270.d2 = _273;
    if (_273 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= _271;
    _274 *= _272;
    _274 *= _273;
    _274 *= sizeof(_a1_bool);
    _270.data = jpl_alloc(_274);
    int64_t _275 = 0; // l
    int64_t _276 = 0; // k
    int64_t _277 = 0; // j
    _jump352:; // Begin body of loop
    _a1_bool _278;
    // Computing bound for m
    _278.d0 = _47;
    if (_47 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    // Computing total size of heap memory to allocate
    int64_t _279 = 1;
    _279 *= _47;
    _279 *= sizeof(bool);
    _278.data = jpl_alloc(_279);
    int64_t _280 = 0; // m
    _jump354:; // Begin body of loop
    int64_t _281 = 0;
    _281 *= _278.d0;
    _281 += _280;
    _278.data[_281] = a;
    _280++;
    if (_280 < _47)
    goto _jump354;
    // End body of loop
    int64_t _282 = 0;
    _282 *= _270.d0;
    _282 += _277;
    _282 *= _270.d1;
    _282 += _276;
    _282 *= _270.d2;
    _282 += _275;
    _270.data[_282] = _278;
    _275++;
    if (_275 < _273)
    goto _jump352;
    _275 = 0;
    _276++;
    if (_276 < _272)
    goto _jump352;
    _276 = 0;
    _277++;
    if (_277 < _271)
    goto _jump352;
    // End body of loop
    _269 = _270;
    goto _jump355;
    _jump348:;
    _a3__a1_bool _283;
    // Computing bound for j
    int64_t _284 = 439;
    _283.d0 = _284;
    if (_284 > 0) 
    goto _jump356;
    fail_assertion("non-positive loop bound");
    _jump356:;
    // Computing bound for k
    _283.d1 = d.d1;
    if (d.d1 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    // Computing bound for l
    int64_t _285 = 60;
    _283.d2 = _285;
    if (_285 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= _284;
    _286 *= d.d1;
    _286 *= _285;
    _286 *= sizeof(_a1_bool);
    _283.data = jpl_alloc(_286);
    int64_t _287 = 0; // l
    int64_t _288 = 0; // k
    int64_t _289 = 0; // j
    _jump359:; // Begin body of loop
    _a1_bool _290;
    // Computing bound for m
    _290.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= d.d0;
    _291 *= sizeof(bool);
    _290.data = jpl_alloc(_291);
    int64_t _292 = 0; // m
    _jump361:; // Begin body of loop
    int64_t _293 = 0;
    _293 *= _290.d0;
    _293 += _292;
    _290.data[_293] = a;
    _292++;
    if (_292 < d.d0)
    goto _jump361;
    // End body of loop
    int64_t _294 = 0;
    _294 *= _283.d0;
    _294 += _289;
    _294 *= _283.d1;
    _294 += _288;
    _294 *= _283.d2;
    _294 += _287;
    _283.data[_294] = _290;
    _287++;
    if (_287 < _285)
    goto _jump359;
    _287 = 0;
    _288++;
    if (_288 < d.d1)
    goto _jump359;
    _288 = 0;
    _289++;
    if (_289 < _284)
    goto _jump359;
    // End body of loop
    _269 = _283;
    _jump355:;
    _236 = _269;
    _jump347:;
    _a1__a3__a1_bool _295;
    _295.d0 = 1;
    _295.data = jpl_alloc(sizeof(_a3__a1_bool) * 1);
    _295.data[0] = _236;
    if (d.d0 >= 0)
    goto _jump362;
    fail_assertion("negative array index");
    _jump362:;
    if (d.d0 < _295.d0)
    goto _jump363;
    fail_assertion("index too large");
    _jump363:;
    int64_t _296 = 0;
    _296 *= _295.d0;
    _296 += d.d0;
    _a3__a1_bool _297 = _295.data[_296];
    _98 = _297;
    _jump323:;
    double _298;
    // Computing bound for o
    if (_98.d0 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing bound for p
    if (_98.d0 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    _298 = 0;
    int64_t _299 = 0; // p
    int64_t _300 = 0; // o
    _jump366:; // Begin body of loop
    double _301 = 7.0;
    double _302 = -_301;
    _298 += _302;
    _299++;
    if (_299 < _98.d0)
    goto _jump366;
    _299 = 0;
    _300++;
    if (_300 < _98.d0)
    goto _jump366;
    // End body of loop
    double _303 = -_298;
    double _304 = 8.0;
    double _305 = 38.0;
    _a3_double _306;
    // Computing bound for o
    _306.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing bound for p
    int64_t _307 = 558;
    _306.d1 = _307;
    if (_307 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    // Computing bound for q
    _306.d2 = _98.d0;
    if (_98.d0 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= d.d0;
    _308 *= _307;
    _308 *= _98.d0;
    _308 *= sizeof(double);
    _306.data = jpl_alloc(_308);
    int64_t _309 = 0; // q
    int64_t _310 = 0; // p
    int64_t _311 = 0; // o
    _jump370:; // Begin body of loop
    double _312 = 53.0;
    int64_t _313 = 0;
    _313 *= _306.d0;
    _313 += _311;
    _313 *= _306.d1;
    _313 += _310;
    _313 *= _306.d2;
    _313 += _309;
    _306.data[_313] = _312;
    _309++;
    if (_309 < _98.d0)
    goto _jump370;
    _309 = 0;
    _310++;
    if (_310 < _307)
    goto _jump370;
    _310 = 0;
    _311++;
    if (_311 < d.d0)
    goto _jump370;
    // End body of loop
    int64_t _314 = 582;
    int64_t _315 = -_98.d0;
    if (_314 >= 0)
    goto _jump371;
    fail_assertion("negative array index");
    _jump371:;
    if (_314 < _306.d0)
    goto _jump372;
    fail_assertion("index too large");
    _jump372:;
    if (d.d0 >= 0)
    goto _jump373;
    fail_assertion("negative array index");
    _jump373:;
    if (d.d0 < _306.d1)
    goto _jump374;
    fail_assertion("index too large");
    _jump374:;
    if (_315 >= 0)
    goto _jump375;
    fail_assertion("negative array index");
    _jump375:;
    if (_315 < _306.d2)
    goto _jump376;
    fail_assertion("index too large");
    _jump376:;
    int64_t _316 = 0;
    _316 *= _306.d0;
    _316 += _314;
    _316 *= _306.d1;
    _316 += d.d0;
    _316 *= _306.d2;
    _316 += _315;
    double _317 = _306.data[_316];
    double _318 = -_317;
    double _319 = 87.0;
    rgba _320 = { _304, _305, _318, _319 };
    double _321 = _320.a;
    bool _322 = _303 < _321;
    _a2_double _323;
    if (!_322)
    goto _jump377;
    _a2__a2_double _324;
    // Computing bound for o
    _324.d0 = _98.d2;
    if (_98.d2 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing bound for p
    int64_t _325;
    if (!_46)
    goto _jump379;
    bool _326 = false;
    _a3_int64_t _327;
    if (!_326)
    goto _jump380;
    _a3_int64_t _328;
    // Computing bound for o
    _328.d0 = _98.d1;
    if (_98.d1 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing bound for p
    _328.d1 = _98.d1;
    if (_98.d1 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for q
    _328.d2 = _98.d2;
    if (_98.d2 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _98.d1;
    _329 *= _98.d1;
    _329 *= _98.d2;
    _329 *= sizeof(int64_t);
    _328.data = jpl_alloc(_329);
    int64_t _330 = 0; // q
    int64_t _331 = 0; // p
    int64_t _332 = 0; // o
    _jump384:; // Begin body of loop
    int64_t _333 = 0;
    _333 *= _328.d0;
    _333 += _332;
    _333 *= _328.d1;
    _333 += _331;
    _333 *= _328.d2;
    _333 += _330;
    _328.data[_333] = _331;
    _330++;
    if (_330 < _98.d2)
    goto _jump384;
    _330 = 0;
    _331++;
    if (_331 < _98.d1)
    goto _jump384;
    _331 = 0;
    _332++;
    if (_332 < _98.d1)
    goto _jump384;
    // End body of loop
    _327 = _328;
    goto _jump385;
    _jump380:;
    _a3_int64_t _334;
    // Computing bound for o
    _334.d0 = _47;
    if (_47 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing bound for p
    _334.d1 = _98.d2;
    if (_98.d2 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    // Computing bound for q
    int64_t _335 = 776;
    _334.d2 = _335;
    if (_335 > 0) 
    goto _jump388;
    fail_assertion("non-positive loop bound");
    _jump388:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _47;
    _336 *= _98.d2;
    _336 *= _335;
    _336 *= sizeof(int64_t);
    _334.data = jpl_alloc(_336);
    int64_t _337 = 0; // q
    int64_t _338 = 0; // p
    int64_t _339 = 0; // o
    _jump389:; // Begin body of loop
    int64_t _340 = 0;
    _340 *= _334.d0;
    _340 += _339;
    _340 *= _334.d1;
    _340 += _338;
    _340 *= _334.d2;
    _340 += _337;
    _334.data[_340] = _98.d0;
    _337++;
    if (_337 < _335)
    goto _jump389;
    _337 = 0;
    _338++;
    if (_338 < _98.d2)
    goto _jump389;
    _338 = 0;
    _339++;
    if (_339 < _47)
    goto _jump389;
    // End body of loop
    _327 = _334;
    _jump385:;
    int64_t _341 = 729;
    int64_t _342 = -d.d1;
    if (d.d1 >= 0)
    goto _jump390;
    fail_assertion("negative array index");
    _jump390:;
    if (d.d1 < _327.d0)
    goto _jump391;
    fail_assertion("index too large");
    _jump391:;
    if (_341 >= 0)
    goto _jump392;
    fail_assertion("negative array index");
    _jump392:;
    if (_341 < _327.d1)
    goto _jump393;
    fail_assertion("index too large");
    _jump393:;
    if (_342 >= 0)
    goto _jump394;
    fail_assertion("negative array index");
    _jump394:;
    if (_342 < _327.d2)
    goto _jump395;
    fail_assertion("index too large");
    _jump395:;
    int64_t _343 = 0;
    _343 *= _327.d0;
    _343 += d.d1;
    _343 *= _327.d1;
    _343 += _341;
    _343 *= _327.d2;
    _343 += _342;
    int64_t _344 = _327.data[_343];
    _325 = _344;
    goto _jump396;
    _jump379:;
    _325 = _47;
    _jump396:;
    _324.d1 = _325;
    if (_325 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing total size of heap memory to allocate
    int64_t _345 = 1;
    _345 *= _98.d2;
    _345 *= _325;
    _345 *= sizeof(_a2_double);
    _324.data = jpl_alloc(_345);
    int64_t _346 = 0; // p
    int64_t _347 = 0; // o
    _jump398:; // Begin body of loop
    bool _348 = false;
    _a2_double _349;
    if (!_348)
    goto _jump399;
    _a2_bool _350;
    // Computing bound for q
    _350.d0 = _98.d1;
    if (_98.d1 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for r
    _350.d1 = _98.d2;
    if (_98.d2 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing total size of heap memory to allocate
    int64_t _351 = 1;
    _351 *= _98.d1;
    _351 *= _98.d2;
    _351 *= sizeof(bool);
    _350.data = jpl_alloc(_351);
    int64_t _352 = 0; // r
    int64_t _353 = 0; // q
    _jump402:; // Begin body of loop
    bool _354 = true;
    int64_t _355 = 0;
    _355 *= _350.d0;
    _355 += _353;
    _355 *= _350.d1;
    _355 += _352;
    _350.data[_355] = _354;
    _352++;
    if (_352 < _98.d2)
    goto _jump402;
    _352 = 0;
    _353++;
    if (_353 < _98.d1)
    goto _jump402;
    // End body of loop
    int64_t _356 = d.d1 % _98.d0;
    if (_356 >= 0)
    goto _jump403;
    fail_assertion("negative array index");
    _jump403:;
    if (_356 < _350.d0)
    goto _jump404;
    fail_assertion("index too large");
    _jump404:;
    if (d.d1 >= 0)
    goto _jump405;
    fail_assertion("negative array index");
    _jump405:;
    if (d.d1 < _350.d1)
    goto _jump406;
    fail_assertion("index too large");
    _jump406:;
    int64_t _357 = 0;
    _357 *= _350.d0;
    _357 += _356;
    _357 *= _350.d1;
    _357 += d.d1;
    bool _358 = _350.data[_357];
    _a2_double _359;
    if (!_358)
    goto _jump407;
    _a3__a2_double _360;
    // Computing bound for q
    _360.d0 = _347;
    if (_347 > 0) 
    goto _jump408;
    fail_assertion("non-positive loop bound");
    _jump408:;
    // Computing bound for r
    _360.d1 = _47;
    if (_47 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    // Computing bound for s
    _360.d2 = _98.d1;
    if (_98.d1 > 0) 
    goto _jump410;
    fail_assertion("non-positive loop bound");
    _jump410:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= _347;
    _361 *= _47;
    _361 *= _98.d1;
    _361 *= sizeof(_a2_double);
    _360.data = jpl_alloc(_361);
    int64_t _362 = 0; // s
    int64_t _363 = 0; // r
    int64_t _364 = 0; // q
    _jump411:; // Begin body of loop
    int64_t _365 = 0;
    _365 *= _360.d0;
    _365 += _364;
    _365 *= _360.d1;
    _365 += _363;
    _365 *= _360.d2;
    _365 += _362;
    _360.data[_365] = d;
    _362++;
    if (_362 < _98.d1)
    goto _jump411;
    _362 = 0;
    _363++;
    if (_363 < _47)
    goto _jump411;
    _363 = 0;
    _364++;
    if (_364 < _347)
    goto _jump411;
    // End body of loop
    int64_t _366;
    // Computing bound for q
    int64_t _367 = 423;
    if (_367 > 0) 
    goto _jump412;
    fail_assertion("non-positive loop bound");
    _jump412:;
    // Computing bound for r
    if (_98.d2 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing bound for s
    if (d.d0 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    _366 = 0;
    int64_t _368 = 0; // s
    int64_t _369 = 0; // r
    int64_t _370 = 0; // q
    _jump415:; // Begin body of loop
    _366 += d.d1;
    _368++;
    if (_368 < d.d0)
    goto _jump415;
    _368 = 0;
    _369++;
    if (_369 < _98.d2)
    goto _jump415;
    _369 = 0;
    _370++;
    if (_370 < _367)
    goto _jump415;
    // End body of loop
    int64_t _371 = 251;
    if (_366 >= 0)
    goto _jump416;
    fail_assertion("negative array index");
    _jump416:;
    if (_366 < _360.d0)
    goto _jump417;
    fail_assertion("index too large");
    _jump417:;
    if (_371 >= 0)
    goto _jump418;
    fail_assertion("negative array index");
    _jump418:;
    if (_371 < _360.d1)
    goto _jump419;
    fail_assertion("index too large");
    _jump419:;
    if (_98.d0 >= 0)
    goto _jump420;
    fail_assertion("negative array index");
    _jump420:;
    if (_98.d0 < _360.d2)
    goto _jump421;
    fail_assertion("index too large");
    _jump421:;
    int64_t _372 = 0;
    _372 *= _360.d0;
    _372 += _366;
    _372 *= _360.d1;
    _372 += _371;
    _372 *= _360.d2;
    _372 += _98.d0;
    _a2_double _373 = _360.data[_372];
    _359 = _373;
    goto _jump422;
    _jump407:;
    _359 = d;
    _jump422:;
    _349 = _359;
    goto _jump423;
    _jump399:;
    bool _374 = c(d);
    _a2_double _375;
    if (!_374)
    goto _jump424;
    _375 = d;
    goto _jump425;
    _jump424:;
    double _376 = 96.0;
    double _377 = 49.0;
    bool _378 = _376 != _377;
    _a2_double _379;
    if (!_378)
    goto _jump426;
    _379 = d;
    goto _jump427;
    _jump426:;
    _379 = d;
    _jump427:;
    _375 = _379;
    _jump425:;
    _349 = _375;
    _jump423:;
    int64_t _380 = 0;
    _380 *= _324.d0;
    _380 += _347;
    _380 *= _324.d1;
    _380 += _346;
    _324.data[_380] = _349;
    _346++;
    if (_346 < _325)
    goto _jump398;
    _346 = 0;
    _347++;
    if (_347 < _98.d2)
    goto _jump398;
    // End body of loop
    if (_98.d2 >= 0)
    goto _jump428;
    fail_assertion("negative array index");
    _jump428:;
    if (_98.d2 < _324.d0)
    goto _jump429;
    fail_assertion("index too large");
    _jump429:;
    if (_98.d2 >= 0)
    goto _jump430;
    fail_assertion("negative array index");
    _jump430:;
    if (_98.d2 < _324.d1)
    goto _jump431;
    fail_assertion("index too large");
    _jump431:;
    int64_t _381 = 0;
    _381 *= _324.d0;
    _381 += _98.d2;
    _381 *= _324.d1;
    _381 += _98.d2;
    _a2_double _382 = _324.data[_381];
    _323 = _382;
    goto _jump432;
    _jump377:;
    _323 = d;
    _jump432:;
    bool _383 = false;
    _a2_bool _384;
    if (!_383)
    goto _jump433;
    _a1__a2_bool _385;
    // Computing bound for r
    _385.d0 = _98.d1;
    if (_98.d1 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing total size of heap memory to allocate
    int64_t _386 = 1;
    _386 *= _98.d1;
    _386 *= sizeof(_a2_bool);
    _385.data = jpl_alloc(_386);
    int64_t _387 = 0; // r
    _jump435:; // Begin body of loop
    _a2_bool _388;
    // Computing bound for s
    _388.d0 = _323.d0;
    if (_323.d0 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing bound for t
    _388.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _323.d0;
    _389 *= d.d0;
    _389 *= sizeof(bool);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // t
    int64_t _391 = 0; // s
    _jump438:; // Begin body of loop
    bool _392 = true;
    int64_t _393 = 0;
    _393 *= _388.d0;
    _393 += _391;
    _393 *= _388.d1;
    _393 += _390;
    _388.data[_393] = _392;
    _390++;
    if (_390 < d.d0)
    goto _jump438;
    _390 = 0;
    _391++;
    if (_391 < _323.d0)
    goto _jump438;
    // End body of loop
    int64_t _394 = 0;
    _394 *= _385.d0;
    _394 += _387;
    _385.data[_394] = _388;
    _387++;
    if (_387 < _98.d1)
    goto _jump435;
    // End body of loop
    if (_98.d0 >= 0)
    goto _jump439;
    fail_assertion("negative array index");
    _jump439:;
    if (_98.d0 < _385.d0)
    goto _jump440;
    fail_assertion("index too large");
    _jump440:;
    int64_t _395 = 0;
    _395 *= _385.d0;
    _395 += _98.d0;
    _a2_bool _396 = _385.data[_395];
    _384 = _396;
    goto _jump441;
    _jump433:;
    _a2_bool _397;
    // Computing bound for r
    _397.d0 = _98.d1;
    if (_98.d1 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    // Computing bound for s
    int64_t _398 = 152;
    _397.d1 = _398;
    if (_398 > 0) 
    goto _jump443;
    fail_assertion("non-positive loop bound");
    _jump443:;
    // Computing total size of heap memory to allocate
    int64_t _399 = 1;
    _399 *= _98.d1;
    _399 *= _398;
    _399 *= sizeof(bool);
    _397.data = jpl_alloc(_399);
    int64_t _400 = 0; // s
    int64_t _401 = 0; // r
    _jump444:; // Begin body of loop
    int64_t _402;
    // Computing bound for t
    if (_401 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    // Computing bound for u
    if (_98.d1 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing bound for v
    int64_t _403 = 160;
    if (_403 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    _402 = 0;
    int64_t _404 = 0; // v
    int64_t _405 = 0; // u
    int64_t _406 = 0; // t
    _jump448:; // Begin body of loop
    _402 += _401;
    _404++;
    if (_404 < _403)
    goto _jump448;
    _404 = 0;
    _405++;
    if (_405 < _98.d1)
    goto _jump448;
    _405 = 0;
    _406++;
    if (_406 < _401)
    goto _jump448;
    // End body of loop
    bool _407 = _402 == _401;
    int64_t _408 = 0;
    _408 *= _397.d0;
    _408 += _401;
    _408 *= _397.d1;
    _408 += _400;
    _397.data[_408] = _407;
    _400++;
    if (_400 < _398)
    goto _jump444;
    _400 = 0;
    _401++;
    if (_401 < _98.d1)
    goto _jump444;
    // End body of loop
    _384 = _397;
    _jump441:;
    bool _409 = c(_323);
    _a1_int64_t _410;
    if (!_409)
    goto _jump449;
    int64_t _411 = -_323.d1;
    _a1_int64_t _412;
    _412.d0 = 3;
    _412.data = jpl_alloc(sizeof(int64_t) * 3);
    _412.data[0] = _411;
    _412.data[1] = _47;
    _412.data[2] = _323.d1;
    _410 = _412;
    goto _jump450;
    _jump449:;
    _a1_int64_t _413;
    _413.d0 = 1;
    _413.data = jpl_alloc(sizeof(int64_t) * 1);
    _413.data[0] = d.d0;
    _410 = _413;
    _jump450:;
    if (d.d0 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (d.d0 < _410.d0)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    int64_t _414 = 0;
    _414 *= _410.d0;
    _414 += d.d0;
    int64_t _415 = _410.data[_414];
    if (_415 >= 0)
    goto _jump453;
    fail_assertion("negative array index");
    _jump453:;
    if (_415 < _384.d0)
    goto _jump454;
    fail_assertion("index too large");
    _jump454:;
    if (_323.d1 >= 0)
    goto _jump455;
    fail_assertion("negative array index");
    _jump455:;
    if (_323.d1 < _384.d1)
    goto _jump456;
    fail_assertion("index too large");
    _jump456:;
    int64_t _416 = 0;
    _416 *= _384.d0;
    _416 += _415;
    _416 *= _384.d1;
    _416 += _323.d1;
    bool _417 = _384.data[_416];
    _a2_double _418;
    if (!_417)
    goto _jump457;
    _418 = d;
    goto _jump458;
    _jump457:;
    _418 = d;
    _jump458:;
    bool _419 = c(_418);
    return _419;
}

_a3_bool f(_a3__a2_void_t g, _a3__a1_rgba k) {
    _a2__a3_bool _0;
    // Computing bound for o
    int64_t _1 = 937;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump515;
    fail_assertion("non-positive loop bound");
    _jump515:;
    // Computing bound for p
    _0.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= _1;
    _2 *= k.d2;
    _2 *= sizeof(_a3_bool);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // p
    int64_t _4 = 0; // o
    _jump517:; // Begin body of loop
    int64_t _5 = -_3;
    int64_t _6 = 903;
    int64_t _7 = _3 % _6;
    bool _8 = _5 != _7;
    _a1__a3_bool _9;
    if (!_8)
    goto _jump518;
    int64_t _10;
    // Computing bound for q
    if (_4 > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    _10 = 0;
    int64_t _11 = 0; // q
    _jump520:; // Begin body of loop
    _10 += _11;
    _11++;
    if (_11 < _4)
    goto _jump520;
    // End body of loop
    int64_t _12 = 909;
    bool _13 = _10 != _12;
    _a1__a3_bool _14;
    if (!_13)
    goto _jump521;
    _a1__a3_bool _15;
    // Computing bound for q
    int64_t _16;
    // Computing bound for q
    if (k.d1 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for r
    if (_4 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    _16 = 0;
    int64_t _17 = 0; // r
    int64_t _18 = 0; // q
    _jump524:; // Begin body of loop
    _16 += k.d0;
    _17++;
    if (_17 < _4)
    goto _jump524;
    _17 = 0;
    _18++;
    if (_18 < k.d1)
    goto _jump524;
    // End body of loop
    _15.d0 = _16;
    if (_16 > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= _16;
    _19 *= sizeof(_a3_bool);
    _15.data = jpl_alloc(_19);
    int64_t _20 = 0; // q
    _jump526:; // Begin body of loop
    _a3_bool _21;
    // Computing bound for r
    int64_t _22 = 732;
    _21.d0 = _22;
    if (_22 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing bound for s
    _21.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump528;
    fail_assertion("non-positive loop bound");
    _jump528:;
    // Computing bound for t
    _21.d2 = k.d0;
    if (k.d0 > 0) 
    goto _jump529;
    fail_assertion("non-positive loop bound");
    _jump529:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= _22;
    _23 *= g.d1;
    _23 *= k.d0;
    _23 *= sizeof(bool);
    _21.data = jpl_alloc(_23);
    int64_t _24 = 0; // t
    int64_t _25 = 0; // s
    int64_t _26 = 0; // r
    _jump530:; // Begin body of loop
    int64_t _27 = 0;
    _27 *= _21.d0;
    _27 += _26;
    _27 *= _21.d1;
    _27 += _25;
    _27 *= _21.d2;
    _27 += _24;
    _21.data[_27] = a;
    _24++;
    if (_24 < k.d0)
    goto _jump530;
    _24 = 0;
    _25++;
    if (_25 < g.d1)
    goto _jump530;
    _25 = 0;
    _26++;
    if (_26 < _22)
    goto _jump530;
    // End body of loop
    int64_t _28 = 0;
    _28 *= _15.d0;
    _28 += _20;
    _15.data[_28] = _21;
    _20++;
    if (_20 < _16)
    goto _jump526;
    // End body of loop
    _14 = _15;
    goto _jump531;
    _jump521:;
    _a3_bool _29;
    // Computing bound for q
    _29.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing bound for r
    _29.d1 = _4;
    if (_4 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for s
    _29.d2 = k.d2;
    if (k.d2 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= g.d1;
    _30 *= _4;
    _30 *= k.d2;
    _30 *= sizeof(bool);
    _29.data = jpl_alloc(_30);
    int64_t _31 = 0; // s
    int64_t _32 = 0; // r
    int64_t _33 = 0; // q
    _jump535:; // Begin body of loop
    bool _34 = false;
    int64_t _35 = 0;
    _35 *= _29.d0;
    _35 += _33;
    _35 *= _29.d1;
    _35 += _32;
    _35 *= _29.d2;
    _35 += _31;
    _29.data[_35] = _34;
    _31++;
    if (_31 < k.d2)
    goto _jump535;
    _31 = 0;
    _32++;
    if (_32 < _4)
    goto _jump535;
    _32 = 0;
    _33++;
    if (_33 < g.d1)
    goto _jump535;
    // End body of loop
    _a3_bool _36;
    // Computing bound for q
    _36.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    // Computing bound for r
    _36.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for s
    _36.d2 = g.d2;
    if (g.d2 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= g.d1;
    _37 *= k.d2;
    _37 *= g.d2;
    _37 *= sizeof(bool);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // s
    int64_t _39 = 0; // r
    int64_t _40 = 0; // q
    _jump539:; // Begin body of loop
    int64_t _41 = 0;
    _41 *= _36.d0;
    _41 += _40;
    _41 *= _36.d1;
    _41 += _39;
    _41 *= _36.d2;
    _41 += _38;
    _36.data[_41] = a;
    _38++;
    if (_38 < g.d2)
    goto _jump539;
    _38 = 0;
    _39++;
    if (_39 < k.d2)
    goto _jump539;
    _39 = 0;
    _40++;
    if (_40 < g.d1)
    goto _jump539;
    // End body of loop
    _a1__a3_bool _42;
    _42.d0 = 2;
    _42.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _42.data[0] = _29;
    _42.data[1] = _36;
    _14 = _42;
    _jump531:;
    _9 = _14;
    goto _jump540;
    _jump518:;
    _a1__a3_bool _43;
    // Computing bound for q
    _43.d0 = g.d2;
    if (g.d2 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing total size of heap memory to allocate
    int64_t _44 = 1;
    _44 *= g.d2;
    _44 *= sizeof(_a3_bool);
    _43.data = jpl_alloc(_44);
    int64_t _45 = 0; // q
    _jump542:; // Begin body of loop
    _a3_bool _46;
    // Computing bound for r
    _46.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump543;
    fail_assertion("non-positive loop bound");
    _jump543:;
    // Computing bound for s
    _46.d1 = _4;
    if (_4 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for t
    _46.d2 = k.d0;
    if (k.d0 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= k.d0;
    _47 *= _4;
    _47 *= k.d0;
    _47 *= sizeof(bool);
    _46.data = jpl_alloc(_47);
    int64_t _48 = 0; // t
    int64_t _49 = 0; // s
    int64_t _50 = 0; // r
    _jump546:; // Begin body of loop
    int64_t _51 = 0;
    _51 *= _46.d0;
    _51 += _50;
    _51 *= _46.d1;
    _51 += _49;
    _51 *= _46.d2;
    _51 += _48;
    _46.data[_51] = a;
    _48++;
    if (_48 < k.d0)
    goto _jump546;
    _48 = 0;
    _49++;
    if (_49 < _4)
    goto _jump546;
    _49 = 0;
    _50++;
    if (_50 < k.d0)
    goto _jump546;
    // End body of loop
    int64_t _52 = 0;
    _52 *= _43.d0;
    _52 += _45;
    _43.data[_52] = _46;
    _45++;
    if (_45 < g.d2)
    goto _jump542;
    // End body of loop
    _9 = _43;
    _jump540:;
    if (k.d0 >= 0)
    goto _jump547;
    fail_assertion("negative array index");
    _jump547:;
    if (k.d0 < _9.d0)
    goto _jump548;
    fail_assertion("index too large");
    _jump548:;
    int64_t _53 = 0;
    _53 *= _9.d0;
    _53 += k.d0;
    _a3_bool _54 = _9.data[_53];
    int64_t _55 = 0;
    _55 *= _0.d0;
    _55 += _4;
    _55 *= _0.d1;
    _55 += _3;
    _0.data[_55] = _54;
    _3++;
    if (_3 < k.d2)
    goto _jump517;
    _3 = 0;
    _4++;
    if (_4 < _1)
    goto _jump517;
    // End body of loop
    if (g.d2 >= 0)
    goto _jump549;
    fail_assertion("negative array index");
    _jump549:;
    if (g.d2 < _0.d0)
    goto _jump550;
    fail_assertion("index too large");
    _jump550:;
    if (k.d1 >= 0)
    goto _jump551;
    fail_assertion("negative array index");
    _jump551:;
    if (k.d1 < _0.d1)
    goto _jump552;
    fail_assertion("index too large");
    _jump552:;
    int64_t _56 = 0;
    _56 *= _0.d0;
    _56 += g.d2;
    _56 *= _0.d1;
    _56 += k.d1;
    _a3_bool _57 = _0.data[_56];
    return _57;
    _a2__a3_double _59;
    // Computing bound for o
    _59.d0 = k.d2;
    if (k.d2 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for p
    _59.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= k.d2;
    _60 *= k.d2;
    _60 *= sizeof(_a3_double);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // p
    int64_t _62 = 0; // o
    _jump555:; // Begin body of loop
    _a3_double _63;
    // Computing bound for q
    _63.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing bound for r
    _63.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for s
    _63.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= g.d1;
    _64 *= g.d1;
    _64 *= g.d0;
    _64 *= sizeof(double);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // s
    int64_t _66 = 0; // r
    int64_t _67 = 0; // q
    _jump559:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _63.d0;
    _68 += _67;
    _68 *= _63.d1;
    _68 += _66;
    _68 *= _63.d2;
    _68 += _65;
    _63.data[_68] = e;
    _65++;
    if (_65 < g.d0)
    goto _jump559;
    _65 = 0;
    _66++;
    if (_66 < g.d1)
    goto _jump559;
    _66 = 0;
    _67++;
    if (_67 < g.d1)
    goto _jump559;
    // End body of loop
    int64_t _69 = 0;
    _69 *= _59.d0;
    _69 += _62;
    _69 *= _59.d1;
    _69 += _61;
    _59.data[_69] = _63;
    _61++;
    if (_61 < k.d2)
    goto _jump555;
    _61 = 0;
    _62++;
    if (_62 < k.d2)
    goto _jump555;
    // End body of loop
    int64_t _70 = -g.d1;
    int64_t _71 = _70 + k.d1;
    if (_71 >= 0)
    goto _jump560;
    fail_assertion("negative array index");
    _jump560:;
    if (_71 < _59.d0)
    goto _jump561;
    fail_assertion("index too large");
    _jump561:;
    if (g.d2 >= 0)
    goto _jump562;
    fail_assertion("negative array index");
    _jump562:;
    if (g.d2 < _59.d1)
    goto _jump563;
    fail_assertion("index too large");
    _jump563:;
    int64_t _72 = 0;
    _72 *= _59.d0;
    _72 += _71;
    _72 *= _59.d1;
    _72 += g.d2;
    _a3_double _73 = _59.data[_72];
    if (k.d0 >= 0)
    goto _jump564;
    fail_assertion("negative array index");
    _jump564:;
    if (k.d0 < _73.d0)
    goto _jump565;
    fail_assertion("index too large");
    _jump565:;
    if (g.d0 >= 0)
    goto _jump566;
    fail_assertion("negative array index");
    _jump566:;
    if (g.d0 < _73.d1)
    goto _jump567;
    fail_assertion("index too large");
    _jump567:;
    if (g.d1 >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (g.d1 < _73.d2)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    int64_t _74 = 0;
    _74 *= _73.d0;
    _74 += k.d0;
    _74 *= _73.d1;
    _74 += g.d0;
    _74 *= _73.d2;
    _74 += g.d1;
    double _75 = _73.data[_74];
    double _76 = -_75;
    bool _77 = false;
    bool _78 = a == _77;
    _a1__a2_double _79;
    if (!_78)
    goto _jump570;
    _a1__a2_double _80;
    // Computing bound for o
    _80.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= k.d1;
    _81 *= sizeof(_a2_double);
    _80.data = jpl_alloc(_81);
    int64_t _82 = 0; // o
    _jump572:; // Begin body of loop
    _a2_double _83;
    // Computing bound for p
    _83.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    // Computing bound for q
    _83.d1 = g.d2;
    if (g.d2 > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= g.d0;
    _84 *= g.d2;
    _84 *= sizeof(double);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // q
    int64_t _86 = 0; // p
    _jump575:; // Begin body of loop
    double _87 = 17.0;
    int64_t _88 = 0;
    _88 *= _83.d0;
    _88 += _86;
    _88 *= _83.d1;
    _88 += _85;
    _83.data[_88] = _87;
    _85++;
    if (_85 < g.d2)
    goto _jump575;
    _85 = 0;
    _86++;
    if (_86 < g.d0)
    goto _jump575;
    // End body of loop
    int64_t _89 = 0;
    _89 *= _80.d0;
    _89 += _82;
    _80.data[_89] = _83;
    _82++;
    if (_82 < k.d1)
    goto _jump572;
    // End body of loop
    _79 = _80;
    goto _jump576;
    _jump570:;
    _a2_double _90;
    // Computing bound for o
    _90.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing bound for p
    _90.d1 = k.d1;
    if (k.d1 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= k.d1;
    _91 *= k.d1;
    _91 *= sizeof(double);
    _90.data = jpl_alloc(_91);
    int64_t _92 = 0; // p
    int64_t _93 = 0; // o
    _jump579:; // Begin body of loop
    int64_t _94 = 0;
    _94 *= _90.d0;
    _94 += _93;
    _94 *= _90.d1;
    _94 += _92;
    _90.data[_94] = e;
    _92++;
    if (_92 < k.d1)
    goto _jump579;
    _92 = 0;
    _93++;
    if (_93 < k.d1)
    goto _jump579;
    // End body of loop
    _a1__a2_double _95;
    _95.d0 = 1;
    _95.data = jpl_alloc(sizeof(_a2_double) * 1);
    _95.data[0] = _90;
    _79 = _95;
    _jump576:;
    bool _96 = e != e;
    int64_t _97;
    if (!_96)
    goto _jump580;
    _97 = g.d1;
    goto _jump581;
    _jump580:;
    _97 = g.d1;
    _jump581:;
    int64_t _98 = -_97;
    if (_98 >= 0)
    goto _jump582;
    fail_assertion("negative array index");
    _jump582:;
    if (_98 < _79.d0)
    goto _jump583;
    fail_assertion("index too large");
    _jump583:;
    int64_t _99 = 0;
    _99 *= _79.d0;
    _99 += _98;
    _a2_double _100 = _79.data[_99];
    int64_t _101;
    // Computing bound for o
    int64_t _102 = -g.d1;
    int64_t _103 = g.d2 * _102;
    if (_103 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    _101 = 0;
    int64_t _104 = 0; // o
    _jump585:; // Begin body of loop
    int64_t _105 = 367;
    _101 += _105;
    _104++;
    if (_104 < _103)
    goto _jump585;
    // End body of loop
    if (g.d1 >= 0)
    goto _jump586;
    fail_assertion("negative array index");
    _jump586:;
    if (g.d1 < _100.d0)
    goto _jump587;
    fail_assertion("index too large");
    _jump587:;
    if (_101 >= 0)
    goto _jump588;
    fail_assertion("negative array index");
    _jump588:;
    if (_101 < _100.d1)
    goto _jump589;
    fail_assertion("index too large");
    _jump589:;
    int64_t _106 = 0;
    _106 *= _100.d0;
    _106 += g.d1;
    _106 *= _100.d1;
    _106 += _101;
    double _107 = _100.data[_106];
    bool _108 = _76 != _107;
    bool _58 = _108;
    if (0 == _108)
    goto _jump590;
    double _109 = 73.0;
    _a3__a1_double _110;
    // Computing bound for o
    int64_t _111;
    // Computing bound for o
    if (k.d2 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    _111 = 0;
    int64_t _112 = 0; // o
    _jump592:; // Begin body of loop
    int64_t _113 = 886;
    _111 += _113;
    _112++;
    if (_112 < k.d2)
    goto _jump592;
    // End body of loop
    int64_t _114 = -_111;
    _110.d0 = _114;
    if (_114 > 0) 
    goto _jump593;
    fail_assertion("non-positive loop bound");
    _jump593:;
    // Computing bound for p
    _110.d1 = g.d2;
    if (g.d2 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for q
    int64_t _115 = g.d0 / g.d0;
    _110.d2 = _115;
    if (_115 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= _114;
    _116 *= g.d2;
    _116 *= _115;
    _116 *= sizeof(_a1_double);
    _110.data = jpl_alloc(_116);
    int64_t _117 = 0; // q
    int64_t _118 = 0; // p
    int64_t _119 = 0; // o
    _jump596:; // Begin body of loop
    _a1_double _120;
    // Computing bound for r
    int64_t _121 = -g.d0;
    _120.d0 = _121;
    if (_121 > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _121;
    _122 *= sizeof(double);
    _120.data = jpl_alloc(_122);
    int64_t _123 = 0; // r
    _jump598:; // Begin body of loop
    double _124 = 41.0;
    int64_t _125 = 0;
    _125 *= _120.d0;
    _125 += _123;
    _120.data[_125] = _124;
    _123++;
    if (_123 < _121)
    goto _jump598;
    // End body of loop
    int64_t _126 = 0;
    _126 *= _110.d0;
    _126 += _119;
    _126 *= _110.d1;
    _126 += _118;
    _126 *= _110.d2;
    _126 += _117;
    _110.data[_126] = _120;
    _117++;
    if (_117 < _115)
    goto _jump596;
    _117 = 0;
    _118++;
    if (_118 < g.d2)
    goto _jump596;
    _118 = 0;
    _119++;
    if (_119 < _114)
    goto _jump596;
    // End body of loop
    int64_t _127 = 627;
    int64_t _128;
    // Computing bound for o
    int64_t _129;
    // Computing bound for o
    int64_t _130 = g.d0 / g.d1;
    if (_130 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    // Computing bound for p
    int64_t _131 = 479;
    if (_131 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing bound for q
    int64_t _132 = 360;
    int64_t _133 = -_132;
    if (_133 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    _129 = 0;
    int64_t _134 = 0; // q
    int64_t _135 = 0; // p
    int64_t _136 = 0; // o
    _jump602:; // Begin body of loop
    int64_t _137;
    if (!a)
    goto _jump603;
    _137 = g.d0;
    goto _jump604;
    _jump603:;
    _137 = k.d1;
    _jump604:;
    _129 += _137;
    _134++;
    if (_134 < _133)
    goto _jump602;
    _134 = 0;
    _135++;
    if (_135 < _131)
    goto _jump602;
    _135 = 0;
    _136++;
    if (_136 < _130)
    goto _jump602;
    // End body of loop
    if (_129 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for p
    if (k.d1 > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    // Computing bound for q
    int64_t _138 = 381;
    if (_138 > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    _128 = 0;
    int64_t _139 = 0; // q
    int64_t _140 = 0; // p
    int64_t _141 = 0; // o
    _jump608:; // Begin body of loop
    _128 += _140;
    _139++;
    if (_139 < _138)
    goto _jump608;
    _139 = 0;
    _140++;
    if (_140 < k.d1)
    goto _jump608;
    _140 = 0;
    _141++;
    if (_141 < _129)
    goto _jump608;
    // End body of loop
    if (_127 >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (_127 < _110.d0)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    if (k.d2 >= 0)
    goto _jump611;
    fail_assertion("negative array index");
    _jump611:;
    if (k.d2 < _110.d1)
    goto _jump612;
    fail_assertion("index too large");
    _jump612:;
    if (_128 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (_128 < _110.d2)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    int64_t _142 = 0;
    _142 *= _110.d0;
    _142 += _127;
    _142 *= _110.d1;
    _142 += k.d2;
    _142 *= _110.d2;
    _142 += _128;
    _a1_double _143 = _110.data[_142];
    _a2_int64_t _144;
    // Computing bound for o
    int64_t _145;
    // Computing bound for o
    if (g.d2 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing bound for p
    if (g.d1 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    _145 = 0;
    int64_t _146 = 0; // p
    int64_t _147 = 0; // o
    _jump617:; // Begin body of loop
    int64_t _148 = 703;
    _145 += _148;
    _146++;
    if (_146 < g.d1)
    goto _jump617;
    _146 = 0;
    _147++;
    if (_147 < g.d2)
    goto _jump617;
    // End body of loop
    _144.d0 = _145;
    if (_145 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    // Computing bound for p
    _144.d1 = k.d0;
    if (k.d0 > 0) 
    goto _jump619;
    fail_assertion("non-positive loop bound");
    _jump619:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _145;
    _149 *= k.d0;
    _149 *= sizeof(int64_t);
    _144.data = jpl_alloc(_149);
    int64_t _150 = 0; // p
    int64_t _151 = 0; // o
    _jump620:; // Begin body of loop
    int64_t _152 = 274;
    int64_t _153 = 0;
    _153 *= _144.d0;
    _153 += _151;
    _153 *= _144.d1;
    _153 += _150;
    _144.data[_153] = _152;
    _150++;
    if (_150 < k.d0)
    goto _jump620;
    _150 = 0;
    _151++;
    if (_151 < _145)
    goto _jump620;
    // End body of loop
    if (g.d0 >= 0)
    goto _jump621;
    fail_assertion("negative array index");
    _jump621:;
    if (g.d0 < _144.d0)
    goto _jump622;
    fail_assertion("index too large");
    _jump622:;
    if (g.d2 >= 0)
    goto _jump623;
    fail_assertion("negative array index");
    _jump623:;
    if (g.d2 < _144.d1)
    goto _jump624;
    fail_assertion("index too large");
    _jump624:;
    int64_t _154 = 0;
    _154 *= _144.d0;
    _154 += g.d0;
    _154 *= _144.d1;
    _154 += g.d2;
    int64_t _155 = _144.data[_154];
    if (_155 >= 0)
    goto _jump625;
    fail_assertion("negative array index");
    _jump625:;
    if (_155 < _143.d0)
    goto _jump626;
    fail_assertion("index too large");
    _jump626:;
    int64_t _156 = 0;
    _156 *= _143.d0;
    _156 += _155;
    double _157 = _143.data[_156];
    bool _158 = _109 > _157;
    _58 = _158;
    _jump590:;
    _a3_bool _159;
    // Computing bound for p
    _159.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    // Computing bound for q
    _159.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    // Computing bound for r
    _159.d2 = k.d2;
    if (k.d2 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= g.d0;
    _160 *= k.d2;
    _160 *= k.d2;
    _160 *= sizeof(bool);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // r
    int64_t _162 = 0; // q
    int64_t _163 = 0; // p
    _jump630:; // Begin body of loop
    bool _165 = _161 <= _162;
    bool _166;
    if (!_165)
    goto _jump631;
    _166 = a;
    goto _jump632;
    _jump631:;
    bool _167 = a;
    if (0 != a)
    goto _jump633;
    bool _168 = true;
    _167 = _168;
    _jump633:;
    _166 = _167;
    _jump632:;
    _a2_bool _169;
    if (!_166)
    goto _jump634;
    _a2_bool _170;
    if (!a)
    goto _jump635;
    _a2_bool _171;
    // Computing bound for s
    _171.d0 = _163;
    if (_163 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for t
    _171.d1 = _162;
    if (_162 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing total size of heap memory to allocate
    int64_t _172 = 1;
    _172 *= _163;
    _172 *= _162;
    _172 *= sizeof(bool);
    _171.data = jpl_alloc(_172);
    int64_t _173 = 0; // t
    int64_t _174 = 0; // s
    _jump638:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _171.d0;
    _175 += _174;
    _175 *= _171.d1;
    _175 += _173;
    _171.data[_175] = _58;
    _173++;
    if (_173 < _162)
    goto _jump638;
    _173 = 0;
    _174++;
    if (_174 < _163)
    goto _jump638;
    // End body of loop
    _170 = _171;
    goto _jump639;
    _jump635:;
    _a2_bool _176;
    // Computing bound for s
    _176.d0 = _161;
    if (_161 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for t
    _176.d1 = _163;
    if (_163 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _161;
    _177 *= _163;
    _177 *= sizeof(bool);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // t
    int64_t _179 = 0; // s
    _jump642:; // Begin body of loop
    int64_t _180 = 0;
    _180 *= _176.d0;
    _180 += _179;
    _180 *= _176.d1;
    _180 += _178;
    _176.data[_180] = a;
    _178++;
    if (_178 < _163)
    goto _jump642;
    _178 = 0;
    _179++;
    if (_179 < _161)
    goto _jump642;
    // End body of loop
    _170 = _176;
    _jump639:;
    _169 = _170;
    goto _jump643;
    _jump634:;
    _a2_bool _181;
    // Computing bound for s
    _181.d0 = _161;
    if (_161 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    // Computing bound for t
    _181.d1 = _161;
    if (_161 > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= _161;
    _182 *= _161;
    _182 *= sizeof(bool);
    _181.data = jpl_alloc(_182);
    int64_t _183 = 0; // t
    int64_t _184 = 0; // s
    _jump646:; // Begin body of loop
    bool _185 = false;
    bool _186 = !_185;
    int64_t _187 = 0;
    _187 *= _181.d0;
    _187 += _184;
    _187 *= _181.d1;
    _187 += _183;
    _181.data[_187] = _186;
    _183++;
    if (_183 < _161)
    goto _jump646;
    _183 = 0;
    _184++;
    if (_184 < _161)
    goto _jump646;
    // End body of loop
    _169 = _181;
    _jump643:;
    if (g.d1 >= 0)
    goto _jump647;
    fail_assertion("negative array index");
    _jump647:;
    if (g.d1 < _169.d0)
    goto _jump648;
    fail_assertion("index too large");
    _jump648:;
    if (g.d0 >= 0)
    goto _jump649;
    fail_assertion("negative array index");
    _jump649:;
    if (g.d0 < _169.d1)
    goto _jump650;
    fail_assertion("index too large");
    _jump650:;
    int64_t _188 = 0;
    _188 *= _169.d0;
    _188 += g.d1;
    _188 *= _169.d1;
    _188 += g.d0;
    bool _189 = _169.data[_188];
    bool _164 = _189;
    if (0 == _189)
    goto _jump651;
    double _190 = -e;
    if (_161 >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (_161 < k.d0)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    if (_162 >= 0)
    goto _jump654;
    fail_assertion("negative array index");
    _jump654:;
    if (_162 < k.d1)
    goto _jump655;
    fail_assertion("index too large");
    _jump655:;
    if (_162 >= 0)
    goto _jump656;
    fail_assertion("negative array index");
    _jump656:;
    if (_162 < k.d2)
    goto _jump657;
    fail_assertion("index too large");
    _jump657:;
    int64_t _191 = 0;
    _191 *= k.d0;
    _191 += _161;
    _191 *= k.d1;
    _191 += _162;
    _191 *= k.d2;
    _191 += _162;
    _a1_rgba _192 = k.data[_191];
    int64_t _193 = -_161;
    if (_193 >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (_193 < _192.d0)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    int64_t _194 = 0;
    _194 *= _192.d0;
    _194 += _193;
    rgba _195 = _192.data[_194];
    double _196 = _195.a;
    bool _197 = _190 > _196;
    _164 = _197;
    _jump651:;
    bool _198 = !_164;
    int64_t _199 = 0;
    _199 *= _159.d0;
    _199 += _163;
    _199 *= _159.d1;
    _199 += _162;
    _199 *= _159.d2;
    _199 += _161;
    _159.data[_199] = _198;
    _161++;
    if (_161 < k.d2)
    goto _jump630;
    _161 = 0;
    _162++;
    if (_162 < k.d2)
    goto _jump630;
    _162 = 0;
    _163++;
    if (_163 < g.d0)
    goto _jump630;
    // End body of loop
    return _159;
    _a3_bool _200;
    // Computing bound for p
    int64_t _201 = 208;
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for q
    int64_t _202 = -k.d0;
    _200.d1 = _202;
    if (_202 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing bound for r
    _200.d2 = g.d2;
    if (g.d2 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _201;
    _203 *= _202;
    _203 *= g.d2;
    _203 *= sizeof(bool);
    _200.data = jpl_alloc(_203);
    int64_t _204 = 0; // r
    int64_t _205 = 0; // q
    int64_t _206 = 0; // p
    _jump663:; // Begin body of loop
    int64_t _207 = 0;
    _207 *= _200.d0;
    _207 += _206;
    _207 *= _200.d1;
    _207 += _205;
    _207 *= _200.d2;
    _207 += _204;
    _200.data[_207] = a;
    _204++;
    if (_204 < g.d2)
    goto _jump663;
    _204 = 0;
    _205++;
    if (_205 < _202)
    goto _jump663;
    _205 = 0;
    _206++;
    if (_206 < _201)
    goto _jump663;
    // End body of loop
    return _200;
    _a3__a3_bool _208;
    // Computing bound for p
    int64_t _209 = 596;
    _208.d0 = _209;
    if (_209 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for q
    _208.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for r
    _a1__a3_int64_t _210;
    // Computing bound for p
    int64_t _211 = -k.d0;
    _210.d0 = _211;
    if (_211 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= _211;
    _212 *= sizeof(_a3_int64_t);
    _210.data = jpl_alloc(_212);
    int64_t _213 = 0; // p
    _jump667:; // Begin body of loop
    _a3_int64_t _214;
    // Computing bound for q
    _214.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    // Computing bound for r
    _214.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for s
    int64_t _215;
    // Computing bound for q
    if (k.d1 > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    _215 = 0;
    int64_t _216 = 0; // q
    _jump671:; // Begin body of loop
    _215 += k.d0;
    _216++;
    if (_216 < k.d1)
    goto _jump671;
    // End body of loop
    _214.d2 = _215;
    if (_215 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= k.d0;
    _217 *= g.d0;
    _217 *= _215;
    _217 *= sizeof(int64_t);
    _214.data = jpl_alloc(_217);
    int64_t _218 = 0; // s
    int64_t _219 = 0; // r
    int64_t _220 = 0; // q
    _jump673:; // Begin body of loop
    int64_t _221 = 0;
    _221 *= _214.d0;
    _221 += _220;
    _221 *= _214.d1;
    _221 += _219;
    _221 *= _214.d2;
    _221 += _218;
    _214.data[_221] = g.d2;
    _218++;
    if (_218 < _215)
    goto _jump673;
    _218 = 0;
    _219++;
    if (_219 < g.d0)
    goto _jump673;
    _219 = 0;
    _220++;
    if (_220 < k.d0)
    goto _jump673;
    // End body of loop
    int64_t _222 = 0;
    _222 *= _210.d0;
    _222 += _213;
    _210.data[_222] = _214;
    _213++;
    if (_213 < _211)
    goto _jump667;
    // End body of loop
    int64_t _223 = 261;
    if (_223 >= 0)
    goto _jump674;
    fail_assertion("negative array index");
    _jump674:;
    if (_223 < _210.d0)
    goto _jump675;
    fail_assertion("index too large");
    _jump675:;
    int64_t _224 = 0;
    _224 *= _210.d0;
    _224 += _223;
    _a3_int64_t _225 = _210.data[_224];
    if (k.d1 >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (k.d1 < _225.d0)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    if (k.d1 >= 0)
    goto _jump678;
    fail_assertion("negative array index");
    _jump678:;
    if (k.d1 < _225.d1)
    goto _jump679;
    fail_assertion("index too large");
    _jump679:;
    if (k.d0 >= 0)
    goto _jump680;
    fail_assertion("negative array index");
    _jump680:;
    if (k.d0 < _225.d2)
    goto _jump681;
    fail_assertion("index too large");
    _jump681:;
    int64_t _226 = 0;
    _226 *= _225.d0;
    _226 += k.d1;
    _226 *= _225.d1;
    _226 += k.d1;
    _226 *= _225.d2;
    _226 += k.d0;
    int64_t _227 = _225.data[_226];
    _208.d2 = _227;
    if (_227 > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= _209;
    _228 *= g.d1;
    _228 *= _227;
    _228 *= sizeof(_a3_bool);
    _208.data = jpl_alloc(_228);
    int64_t _229 = 0; // r
    int64_t _230 = 0; // q
    int64_t _231 = 0; // p
    _jump683:; // Begin body of loop
    bool _232 = _58 != a;
    _a3__a2_void_t _233;
    if (!_232)
    goto _jump684;
    _233 = g;
    goto _jump685;
    _jump684:;
    _233 = g;
    _jump685:;
    _a3_bool _234 = f(_233, k);
    int64_t _235 = 0;
    _235 *= _208.d0;
    _235 += _231;
    _235 *= _208.d1;
    _235 += _230;
    _235 *= _208.d2;
    _235 += _229;
    _208.data[_235] = _234;
    _229++;
    if (_229 < _227)
    goto _jump683;
    _229 = 0;
    _230++;
    if (_230 < g.d1)
    goto _jump683;
    _230 = 0;
    _231++;
    if (_231 < _209)
    goto _jump683;
    // End body of loop
    bool _236 = false;
    _a1_bool _237;
    if (!_236)
    goto _jump686;
    _a1_bool _238;
    // Computing bound for p
    _238.d0 = k.d2;
    if (k.d2 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing total size of heap memory to allocate
    int64_t _239 = 1;
    _239 *= k.d2;
    _239 *= sizeof(bool);
    _238.data = jpl_alloc(_239);
    int64_t _240 = 0; // p
    _jump688:; // Begin body of loop
    int64_t _241 = 0;
    _241 *= _238.d0;
    _241 += _240;
    _238.data[_241] = a;
    _240++;
    if (_240 < k.d2)
    goto _jump688;
    // End body of loop
    _237 = _238;
    goto _jump689;
    _jump686:;
    _a1_bool _242;
    // Computing bound for p
    _242.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= g.d0;
    _243 *= sizeof(bool);
    _242.data = jpl_alloc(_243);
    int64_t _244 = 0; // p
    _jump691:; // Begin body of loop
    bool _245 = true;
    int64_t _246 = 0;
    _246 *= _242.d0;
    _246 += _244;
    _242.data[_246] = _245;
    _244++;
    if (_244 < g.d0)
    goto _jump691;
    // End body of loop
    _237 = _242;
    _jump689:;
    if (k.d1 >= 0)
    goto _jump692;
    fail_assertion("negative array index");
    _jump692:;
    if (k.d1 < _237.d0)
    goto _jump693;
    fail_assertion("index too large");
    _jump693:;
    int64_t _247 = 0;
    _247 *= _237.d0;
    _247 += k.d1;
    bool _248 = _237.data[_247];
    int64_t _249;
    if (!_248)
    goto _jump694;
    int64_t _250;
    // Computing bound for p
    int64_t _251 = -g.d0;
    if (_251 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for q
    if (g.d1 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for r
    int64_t _252;
    if (!a)
    goto _jump697;
    _252 = g.d2;
    goto _jump698;
    _jump697:;
    _252 = g.d0;
    _jump698:;
    if (_252 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    _250 = 0;
    int64_t _253 = 0; // r
    int64_t _254 = 0; // q
    int64_t _255 = 0; // p
    _jump700:; // Begin body of loop
    int64_t _256 = 264;
    int64_t _257 = k.d1 % _256;
    _250 += _257;
    _253++;
    if (_253 < _252)
    goto _jump700;
    _253 = 0;
    _254++;
    if (_254 < g.d1)
    goto _jump700;
    _254 = 0;
    _255++;
    if (_255 < _251)
    goto _jump700;
    // End body of loop
    int64_t _258 = -_250;
    _249 = _258;
    goto _jump701;
    _jump694:;
    _249 = g.d1;
    _jump701:;
    int64_t _259 = _249 + g.d2;
    int64_t _260 = -_259;
    _a1_int64_t _261;
    // Computing bound for p
    _261.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    // Computing total size of heap memory to allocate
    int64_t _262 = 1;
    _262 *= g.d0;
    _262 *= sizeof(int64_t);
    _261.data = jpl_alloc(_262);
    int64_t _263 = 0; // p
    _jump703:; // Begin body of loop
    int64_t _264 = 0;
    _264 *= _261.d0;
    _264 += _263;
    _261.data[_264] = g.d1;
    _263++;
    if (_263 < g.d0)
    goto _jump703;
    // End body of loop
    _a2_int64_t _265;
    // Computing bound for p
    _265.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for q
    _265.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing total size of heap memory to allocate
    int64_t _266 = 1;
    _266 *= g.d1;
    _266 *= g.d1;
    _266 *= sizeof(int64_t);
    _265.data = jpl_alloc(_266);
    int64_t _267 = 0; // q
    int64_t _268 = 0; // p
    _jump706:; // Begin body of loop
    int64_t _269 = 0;
    _269 *= _265.d0;
    _269 += _268;
    _269 *= _265.d1;
    _269 += _267;
    _265.data[_269] = k.d1;
    _267++;
    if (_267 < g.d1)
    goto _jump706;
    _267 = 0;
    _268++;
    if (_268 < g.d1)
    goto _jump706;
    // End body of loop
    int64_t _270;
    // Computing bound for p
    if (g.d0 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    _270 = 0;
    int64_t _271 = 0; // p
    _jump708:; // Begin body of loop
    _270 += g.d1;
    _271++;
    if (_271 < g.d0)
    goto _jump708;
    // End body of loop
    if (_270 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (_270 < _265.d0)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    if (g.d0 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (g.d0 < _265.d1)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    int64_t _272 = 0;
    _272 *= _265.d0;
    _272 += _270;
    _272 *= _265.d1;
    _272 += g.d0;
    int64_t _273 = _265.data[_272];
    if (_273 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_273 < _261.d0)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    int64_t _274 = 0;
    _274 *= _261.d0;
    _274 += _273;
    int64_t _275 = _261.data[_274];
    if (_260 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_260 < _208.d0)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    if (g.d1 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (g.d1 < _208.d1)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    if (_275 >= 0)
    goto _jump719;
    fail_assertion("negative array index");
    _jump719:;
    if (_275 < _208.d2)
    goto _jump720;
    fail_assertion("index too large");
    _jump720:;
    int64_t _276 = 0;
    _276 *= _208.d0;
    _276 += _260;
    _276 *= _208.d1;
    _276 += g.d1;
    _276 *= _208.d2;
    _276 += _275;
    _a3_bool _277 = _208.data[_276];
    return _277;
    _a3__a3__a3__a2_void_t _278;
    // Computing bound for p
    _278.d0 = g.d2;
    if (g.d2 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for q
    bool _279 = _58;
    if (0 == _58)
    goto _jump722;
    if (g.d0 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (g.d0 < d.d0)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    int64_t _280 = 0;
    _280 *= d.d0;
    _280 += g.d0;
    bool _281 = d.data[_280];
    _279 = _281;
    _jump722:;
    int64_t _282;
    if (!_279)
    goto _jump725;
    int64_t _283 = -k.d2;
    _282 = _283;
    goto _jump726;
    _jump725:;
    _a2_int64_t _284;
    // Computing bound for p
    int64_t _285 = 588;
    _284.d0 = _285;
    if (_285 > 0) 
    goto _jump727;
    fail_assertion("non-positive loop bound");
    _jump727:;
    // Computing bound for q
    _284.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= _285;
    _286 *= k.d2;
    _286 *= sizeof(int64_t);
    _284.data = jpl_alloc(_286);
    int64_t _287 = 0; // q
    int64_t _288 = 0; // p
    _jump729:; // Begin body of loop
    int64_t _289 = 0;
    _289 *= _284.d0;
    _289 += _288;
    _289 *= _284.d1;
    _289 += _287;
    _284.data[_289] = k.d0;
    _287++;
    if (_287 < k.d2)
    goto _jump729;
    _287 = 0;
    _288++;
    if (_288 < _285)
    goto _jump729;
    // End body of loop
    if (g.d2 >= 0)
    goto _jump730;
    fail_assertion("negative array index");
    _jump730:;
    if (g.d2 < _284.d0)
    goto _jump731;
    fail_assertion("index too large");
    _jump731:;
    if (g.d1 >= 0)
    goto _jump732;
    fail_assertion("negative array index");
    _jump732:;
    if (g.d1 < _284.d1)
    goto _jump733;
    fail_assertion("index too large");
    _jump733:;
    int64_t _290 = 0;
    _290 *= _284.d0;
    _290 += g.d2;
    _290 *= _284.d1;
    _290 += g.d1;
    int64_t _291 = _284.data[_290];
    _282 = _291;
    _jump726:;
    _278.d1 = _282;
    if (_282 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing bound for r
    int64_t _292 = 506;
    _278.d2 = _292;
    if (_292 > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing total size of heap memory to allocate
    int64_t _293 = 1;
    _293 *= g.d2;
    _293 *= _282;
    _293 *= _292;
    _293 *= sizeof(_a3__a3__a2_void_t);
    _278.data = jpl_alloc(_293);
    int64_t _294 = 0; // r
    int64_t _295 = 0; // q
    int64_t _296 = 0; // p
    _jump736:; // Begin body of loop
    _a3__a3__a2_void_t _297;
    // Computing bound for s
    _297.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    // Computing bound for t
    _297.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump738;
    fail_assertion("non-positive loop bound");
    _jump738:;
    // Computing bound for u
    _297.d2 = k.d2;
    if (k.d2 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing total size of heap memory to allocate
    int64_t _298 = 1;
    _298 *= g.d1;
    _298 *= k.d2;
    _298 *= k.d2;
    _298 *= sizeof(_a3__a2_void_t);
    _297.data = jpl_alloc(_298);
    int64_t _299 = 0; // u
    int64_t _300 = 0; // t
    int64_t _301 = 0; // s
    _jump740:; // Begin body of loop
    bool _302 = !a;
    _a3__a2_void_t _303;
    if (!_302)
    goto _jump741;
    _303 = g;
    goto _jump742;
    _jump741:;
    _303 = g;
    _jump742:;
    int64_t _304 = 0;
    _304 *= _297.d0;
    _304 += _301;
    _304 *= _297.d1;
    _304 += _300;
    _304 *= _297.d2;
    _304 += _299;
    _297.data[_304] = _303;
    _299++;
    if (_299 < k.d2)
    goto _jump740;
    _299 = 0;
    _300++;
    if (_300 < k.d2)
    goto _jump740;
    _300 = 0;
    _301++;
    if (_301 < g.d1)
    goto _jump740;
    // End body of loop
    int64_t _305 = 0;
    _305 *= _278.d0;
    _305 += _296;
    _305 *= _278.d1;
    _305 += _295;
    _305 *= _278.d2;
    _305 += _294;
    _278.data[_305] = _297;
    _294++;
    if (_294 < _292)
    goto _jump736;
    _294 = 0;
    _295++;
    if (_295 < _282)
    goto _jump736;
    _295 = 0;
    _296++;
    if (_296 < g.d2)
    goto _jump736;
    // End body of loop
    int64_t _306;
    // Computing bound for p
    if (k.d0 > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing bound for q
    if (k.d1 > 0) 
    goto _jump744;
    fail_assertion("non-positive loop bound");
    _jump744:;
    _306 = 0;
    int64_t _307 = 0; // q
    int64_t _308 = 0; // p
    _jump745:; // Begin body of loop
    int64_t _309;
    // Computing bound for r
    int64_t _310 = g.d0 + g.d1;
    if (_310 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing bound for s
    if (_308 > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    _309 = 0;
    int64_t _311 = 0; // s
    int64_t _312 = 0; // r
    _jump748:; // Begin body of loop
    int64_t _313 = -k.d1;
    _309 += _313;
    _311++;
    if (_311 < _308)
    goto _jump748;
    _311 = 0;
    _312++;
    if (_312 < _310)
    goto _jump748;
    // End body of loop
    _306 += _309;
    _307++;
    if (_307 < k.d1)
    goto _jump745;
    _307 = 0;
    _308++;
    if (_308 < k.d0)
    goto _jump745;
    // End body of loop
    int64_t _314;
    if (!_58)
    goto _jump749;
    _314 = g.d2;
    goto _jump750;
    _jump749:;
    _314 = k.d0;
    _jump750:;
    if (k.d2 >= 0)
    goto _jump751;
    fail_assertion("negative array index");
    _jump751:;
    if (k.d2 < _278.d0)
    goto _jump752;
    fail_assertion("index too large");
    _jump752:;
    if (_306 >= 0)
    goto _jump753;
    fail_assertion("negative array index");
    _jump753:;
    if (_306 < _278.d1)
    goto _jump754;
    fail_assertion("index too large");
    _jump754:;
    if (_314 >= 0)
    goto _jump755;
    fail_assertion("negative array index");
    _jump755:;
    if (_314 < _278.d2)
    goto _jump756;
    fail_assertion("index too large");
    _jump756:;
    int64_t _315 = 0;
    _315 *= _278.d0;
    _315 += k.d2;
    _315 *= _278.d1;
    _315 += _306;
    _315 *= _278.d2;
    _315 += _314;
    _a3__a3__a2_void_t _316 = _278.data[_315];
    if (g.d2 >= 0)
    goto _jump757;
    fail_assertion("negative array index");
    _jump757:;
    if (g.d2 < _316.d0)
    goto _jump758;
    fail_assertion("index too large");
    _jump758:;
    if (k.d1 >= 0)
    goto _jump759;
    fail_assertion("negative array index");
    _jump759:;
    if (k.d1 < _316.d1)
    goto _jump760;
    fail_assertion("index too large");
    _jump760:;
    if (g.d0 >= 0)
    goto _jump761;
    fail_assertion("negative array index");
    _jump761:;
    if (g.d0 < _316.d2)
    goto _jump762;
    fail_assertion("index too large");
    _jump762:;
    int64_t _317 = 0;
    _317 *= _316.d0;
    _317 += g.d2;
    _317 *= _316.d1;
    _317 += k.d1;
    _317 *= _316.d2;
    _317 += g.d0;
    _a3__a2_void_t _318 = _316.data[_317];
    _a3_bool _319 = f(_318, k);
    _a3_bool _320;
    // Computing bound for q
    _a2_bool _321;
    // Computing bound for q
    _321.d0 = g.d2;
    if (g.d2 > 0) 
    goto _jump763;
    fail_assertion("non-positive loop bound");
    _jump763:;
    // Computing bound for r
    int64_t _322;
    if (!a)
    goto _jump764;
    _322 = k.d1;
    goto _jump765;
    _jump764:;
    _322 = k.d1;
    _jump765:;
    _321.d1 = _322;
    if (_322 > 0) 
    goto _jump766;
    fail_assertion("non-positive loop bound");
    _jump766:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= g.d2;
    _323 *= _322;
    _323 *= sizeof(bool);
    _321.data = jpl_alloc(_323);
    int64_t _324 = 0; // r
    int64_t _325 = 0; // q
    _jump767:; // Begin body of loop
    double _326 = 27.0;
    bool _327 = e < _326;
    int64_t _328 = 0;
    _328 *= _321.d0;
    _328 += _325;
    _328 *= _321.d1;
    _328 += _324;
    _321.data[_328] = _327;
    _324++;
    if (_324 < _322)
    goto _jump767;
    _324 = 0;
    _325++;
    if (_325 < g.d2)
    goto _jump767;
    // End body of loop
    int64_t _329 = 523;
    if (_329 >= 0)
    goto _jump768;
    fail_assertion("negative array index");
    _jump768:;
    if (_329 < _321.d0)
    goto _jump769;
    fail_assertion("index too large");
    _jump769:;
    if (g.d0 >= 0)
    goto _jump770;
    fail_assertion("negative array index");
    _jump770:;
    if (g.d0 < _321.d1)
    goto _jump771;
    fail_assertion("index too large");
    _jump771:;
    int64_t _330 = 0;
    _330 *= _321.d0;
    _330 += _329;
    _330 *= _321.d1;
    _330 += g.d0;
    bool _331 = _321.data[_330];
    double _332;
    if (!_331)
    goto _jump772;
    _a2_double _333;
    // Computing bound for q
    _333.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing bound for r
    int64_t _334;
    // Computing bound for q
    if (g.d1 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    _334 = 0;
    int64_t _335 = 0; // q
    _jump775:; // Begin body of loop
    _334 += g.d1;
    _335++;
    if (_335 < g.d1)
    goto _jump775;
    // End body of loop
    _333.d1 = _334;
    if (_334 > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= g.d0;
    _336 *= _334;
    _336 *= sizeof(double);
    _333.data = jpl_alloc(_336);
    int64_t _337 = 0; // r
    int64_t _338 = 0; // q
    _jump777:; // Begin body of loop
    double _339 = 97.0;
    int64_t _340 = 0;
    _340 *= _333.d0;
    _340 += _338;
    _340 *= _333.d1;
    _340 += _337;
    _333.data[_340] = _339;
    _337++;
    if (_337 < _334)
    goto _jump777;
    _337 = 0;
    _338++;
    if (_338 < g.d0)
    goto _jump777;
    // End body of loop
    int64_t _341;
    if (!a)
    goto _jump778;
    _341 = k.d1;
    goto _jump779;
    _jump778:;
    _341 = k.d0;
    _jump779:;
    int64_t _342 = -_341;
    int64_t _343 = 184;
    if (_342 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_342 < _333.d0)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    if (_343 >= 0)
    goto _jump782;
    fail_assertion("negative array index");
    _jump782:;
    if (_343 < _333.d1)
    goto _jump783;
    fail_assertion("index too large");
    _jump783:;
    int64_t _344 = 0;
    _344 *= _333.d0;
    _344 += _342;
    _344 *= _333.d1;
    _344 += _343;
    double _345 = _333.data[_344];
    _332 = _345;
    goto _jump784;
    _jump772:;
    double _346;
    if (!a)
    goto _jump785;
    double _347;
    // Computing bound for q
    if (g.d1 > 0) 
    goto _jump786;
    fail_assertion("non-positive loop bound");
    _jump786:;
    _347 = 0;
    int64_t _348 = 0; // q
    _jump787:; // Begin body of loop
    double _349 = 85.0;
    _347 += _349;
    _348++;
    if (_348 < g.d1)
    goto _jump787;
    // End body of loop
    _346 = _347;
    goto _jump788;
    _jump785:;
    double _350 = 10.0;
    double _351 = 36.0;
    double _352 = _350 / _351;
    _346 = _352;
    _jump788:;
    double _353;
    // Computing bound for q
    if (g.d1 > 0) 
    goto _jump789;
    fail_assertion("non-positive loop bound");
    _jump789:;
    _353 = 0;
    int64_t _354 = 0; // q
    _jump790:; // Begin body of loop
    double _355 = -e;
    _353 += _355;
    _354++;
    if (_354 < g.d1)
    goto _jump790;
    // End body of loop
    double _356 = _346 - _353;
    _332 = _356;
    _jump784:;
    double _357;
    // Computing bound for q
    if (k.d0 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for r
    if (k.d1 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing bound for s
    if (k.d2 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    _357 = 0;
    int64_t _358 = 0; // s
    int64_t _359 = 0; // r
    int64_t _360 = 0; // q
    _jump794:; // Begin body of loop
    _a2_double _361;
    // Computing bound for t
    _361.d0 = _358;
    if (_358 > 0) 
    goto _jump795;
    fail_assertion("non-positive loop bound");
    _jump795:;
    // Computing bound for u
    _361.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing total size of heap memory to allocate
    int64_t _362 = 1;
    _362 *= _358;
    _362 *= g.d0;
    _362 *= sizeof(double);
    _361.data = jpl_alloc(_362);
    int64_t _363 = 0; // u
    int64_t _364 = 0; // t
    _jump797:; // Begin body of loop
    double _365 = 88.0;
    int64_t _366 = 0;
    _366 *= _361.d0;
    _366 += _364;
    _366 *= _361.d1;
    _366 += _363;
    _361.data[_366] = _365;
    _363++;
    if (_363 < g.d0)
    goto _jump797;
    _363 = 0;
    _364++;
    if (_364 < _358)
    goto _jump797;
    // End body of loop
    bool _367 = c(_361);
    double _368;
    if (!_367)
    goto _jump798;
    double _369;
    if (!a)
    goto _jump799;
    _369 = e;
    goto _jump800;
    _jump799:;
    _369 = e;
    _jump800:;
    _368 = _369;
    goto _jump801;
    _jump798:;
    _368 = e;
    _jump801:;
    _357 += _368;
    _358++;
    if (_358 < k.d2)
    goto _jump794;
    _358 = 0;
    _359++;
    if (_359 < k.d1)
    goto _jump794;
    _359 = 0;
    _360++;
    if (_360 < k.d0)
    goto _jump794;
    // End body of loop
    bool _370 = _332 != _357;
    int64_t _371;
    if (!_370)
    goto _jump802;
    _371 = k.d1;
    goto _jump803;
    _jump802:;
    _371 = k.d0;
    _jump803:;
    _320.d0 = _371;
    if (_371 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing bound for r
    int64_t _372;
    // Computing bound for q
    if (g.d0 > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing bound for r
    if (k.d0 > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    // Computing bound for s
    _a2_int64_t _373;
    // Computing bound for q
    _373.d0 = g.d2;
    if (g.d2 > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing bound for r
    _373.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing total size of heap memory to allocate
    int64_t _374 = 1;
    _374 *= g.d2;
    _374 *= k.d2;
    _374 *= sizeof(int64_t);
    _373.data = jpl_alloc(_374);
    int64_t _375 = 0; // r
    int64_t _376 = 0; // q
    _jump809:; // Begin body of loop
    int64_t _377 = 0;
    _377 *= _373.d0;
    _377 += _376;
    _377 *= _373.d1;
    _377 += _375;
    _373.data[_377] = g.d1;
    _375++;
    if (_375 < k.d2)
    goto _jump809;
    _375 = 0;
    _376++;
    if (_376 < g.d2)
    goto _jump809;
    // End body of loop
    int64_t _378;
    if (!a)
    goto _jump810;
    int64_t _379 = -k.d0;
    int64_t _380 = 333;
    int64_t _381 = _379 + _380;
    _378 = _381;
    goto _jump811;
    _jump810:;
    _378 = k.d2;
    _jump811:;
    int64_t _382 = -_378;
    int64_t _383 = 766;
    if (_382 >= 0)
    goto _jump812;
    fail_assertion("negative array index");
    _jump812:;
    if (_382 < _373.d0)
    goto _jump813;
    fail_assertion("index too large");
    _jump813:;
    if (_383 >= 0)
    goto _jump814;
    fail_assertion("negative array index");
    _jump814:;
    if (_383 < _373.d1)
    goto _jump815;
    fail_assertion("index too large");
    _jump815:;
    int64_t _384 = 0;
    _384 *= _373.d0;
    _384 += _382;
    _384 *= _373.d1;
    _384 += _383;
    int64_t _385 = _373.data[_384];
    if (_385 > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    _372 = 0;
    int64_t _386 = 0; // s
    int64_t _387 = 0; // r
    int64_t _388 = 0; // q
    _jump817:; // Begin body of loop
    int64_t _389 = -k.d2;
    _372 += _389;
    _386++;
    if (_386 < _385)
    goto _jump817;
    _386 = 0;
    _387++;
    if (_387 < k.d0)
    goto _jump817;
    _387 = 0;
    _388++;
    if (_388 < g.d0)
    goto _jump817;
    // End body of loop
    _320.d1 = _372;
    if (_372 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for s
    int64_t _390 = 345;
    _320.d2 = _390;
    if (_390 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= _371;
    _391 *= _372;
    _391 *= _390;
    _391 *= sizeof(bool);
    _320.data = jpl_alloc(_391);
    int64_t _392 = 0; // s
    int64_t _393 = 0; // r
    int64_t _394 = 0; // q
    _jump820:; // Begin body of loop
    bool _395 = true;
    int64_t _396 = 0;
    _396 *= _320.d0;
    _396 += _394;
    _396 *= _320.d1;
    _396 += _393;
    _396 *= _320.d2;
    _396 += _392;
    _320.data[_396] = _395;
    _392++;
    if (_392 < _390)
    goto _jump820;
    _392 = 0;
    _393++;
    if (_393 < _372)
    goto _jump820;
    _393 = 0;
    _394++;
    if (_394 < _371)
    goto _jump820;
    // End body of loop
    return _320;
}

bool l() {
    _a3_int64_t _0;
    // Computing bound for m
    int64_t _1 = 186;
    int64_t _2;
    // Computing bound for m
    _a3__a2_int64_t _3;
    // Computing bound for m
    int64_t _4 = 941;
    int64_t _5 = -_4;
    _3.d0 = _5;
    if (_5 > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing bound for n
    int64_t _6 = 161;
    _3.d1 = _6;
    if (_6 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing bound for o
    _3.d2 = h;
    if (h > 0) 
    goto _jump1021;
    fail_assertion("non-positive loop bound");
    _jump1021:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= _5;
    _7 *= _6;
    _7 *= h;
    _7 *= sizeof(_a2_int64_t);
    _3.data = jpl_alloc(_7);
    int64_t _8 = 0; // o
    int64_t _9 = 0; // n
    int64_t _10 = 0; // m
    _jump1022:; // Begin body of loop
    _a2_int64_t _11;
    // Computing bound for p
    _11.d0 = _8;
    if (_8 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing bound for q
    _11.d1 = _9;
    if (_9 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _8;
    _12 *= _9;
    _12 *= sizeof(int64_t);
    _11.data = jpl_alloc(_12);
    int64_t _13 = 0; // q
    int64_t _14 = 0; // p
    _jump1025:; // Begin body of loop
    int64_t _15 = 0;
    _15 *= _11.d0;
    _15 += _14;
    _15 *= _11.d1;
    _15 += _13;
    _11.data[_15] = _8;
    _13++;
    if (_13 < _9)
    goto _jump1025;
    _13 = 0;
    _14++;
    if (_14 < _8)
    goto _jump1025;
    // End body of loop
    int64_t _16 = 0;
    _16 *= _3.d0;
    _16 += _10;
    _16 *= _3.d1;
    _16 += _9;
    _16 *= _3.d2;
    _16 += _8;
    _3.data[_16] = _11;
    _8++;
    if (_8 < h)
    goto _jump1022;
    _8 = 0;
    _9++;
    if (_9 < _6)
    goto _jump1022;
    _9 = 0;
    _10++;
    if (_10 < _5)
    goto _jump1022;
    // End body of loop
    int64_t _17 = 3;
    int64_t _18 = -_17;
    int64_t _19 = 246;
    bool _20 = l();
    int64_t _21;
    if (!_20)
    goto _jump1026;
    _21 = h;
    goto _jump1027;
    _jump1026:;
    _21 = h;
    _jump1027:;
    int64_t _22 = _19 - _21;
    int64_t _23 = 225;
    bool _24 = h <= _23;
    int64_t _25;
    if (!_24)
    goto _jump1028;
    int64_t _26 = 694;
    int64_t _27 = -_26;
    _25 = _27;
    goto _jump1029;
    _jump1028:;
    _25 = h;
    _jump1029:;
    if (_18 >= 0)
    goto _jump1030;
    fail_assertion("negative array index");
    _jump1030:;
    if (_18 < _3.d0)
    goto _jump1031;
    fail_assertion("index too large");
    _jump1031:;
    if (_22 >= 0)
    goto _jump1032;
    fail_assertion("negative array index");
    _jump1032:;
    if (_22 < _3.d1)
    goto _jump1033;
    fail_assertion("index too large");
    _jump1033:;
    if (_25 >= 0)
    goto _jump1034;
    fail_assertion("negative array index");
    _jump1034:;
    if (_25 < _3.d2)
    goto _jump1035;
    fail_assertion("index too large");
    _jump1035:;
    int64_t _28 = 0;
    _28 *= _3.d0;
    _28 += _18;
    _28 *= _3.d1;
    _28 += _22;
    _28 *= _3.d2;
    _28 += _25;
    _a2_int64_t _29 = _3.data[_28];
    _a1_bool _30;
    // Computing bound for m
    _30.d0 = h;
    if (h > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= h;
    _31 *= sizeof(bool);
    _30.data = jpl_alloc(_31);
    int64_t _32 = 0; // m
    _jump1037:; // Begin body of loop
    int64_t _33 = 0;
    _33 *= _30.d0;
    _33 += _32;
    _30.data[_33] = a;
    _32++;
    if (_32 < h)
    goto _jump1037;
    // End body of loop
    int64_t _34 = 676;
    if (_34 >= 0)
    goto _jump1038;
    fail_assertion("negative array index");
    _jump1038:;
    if (_34 < _30.d0)
    goto _jump1039;
    fail_assertion("index too large");
    _jump1039:;
    int64_t _35 = 0;
    _35 *= _30.d0;
    _35 += _34;
    bool _36 = _30.data[_35];
    int64_t _37;
    if (!_36)
    goto _jump1040;
    int64_t _38;
    // Computing bound for m
    int64_t _39 = 985;
    if (_39 > 0) 
    goto _jump1041;
    fail_assertion("non-positive loop bound");
    _jump1041:;
    _38 = 0;
    int64_t _40 = 0; // m
    _jump1042:; // Begin body of loop
    _38 += _40;
    _40++;
    if (_40 < _39)
    goto _jump1042;
    // End body of loop
    if (_38 >= 0)
    goto _jump1043;
    fail_assertion("negative array index");
    _jump1043:;
    if (_38 < g.d0)
    goto _jump1044;
    fail_assertion("index too large");
    _jump1044:;
    int64_t _41 = 0;
    _41 *= g.d0;
    _41 += _38;
    int64_t _42 = g.data[_41];
    _37 = _42;
    goto _jump1045;
    _jump1040:;
    _a3_int64_t _43;
    // Computing bound for m
    _43.d0 = h;
    if (h > 0) 
    goto _jump1046;
    fail_assertion("non-positive loop bound");
    _jump1046:;
    // Computing bound for n
    int64_t _44 = 146;
    _43.d1 = _44;
    if (_44 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing bound for o
    int64_t _45 = 190;
    _43.d2 = _45;
    if (_45 > 0) 
    goto _jump1048;
    fail_assertion("non-positive loop bound");
    _jump1048:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= h;
    _46 *= _44;
    _46 *= _45;
    _46 *= sizeof(int64_t);
    _43.data = jpl_alloc(_46);
    int64_t _47 = 0; // o
    int64_t _48 = 0; // n
    int64_t _49 = 0; // m
    _jump1049:; // Begin body of loop
    int64_t _50 = 0;
    _50 *= _43.d0;
    _50 += _49;
    _50 *= _43.d1;
    _50 += _48;
    _50 *= _43.d2;
    _50 += _47;
    _43.data[_50] = _48;
    _47++;
    if (_47 < _45)
    goto _jump1049;
    _47 = 0;
    _48++;
    if (_48 < _44)
    goto _jump1049;
    _48 = 0;
    _49++;
    if (_49 < h)
    goto _jump1049;
    // End body of loop
    int64_t _51 = 37;
    int64_t _52 = 60;
    if (h >= 0)
    goto _jump1050;
    fail_assertion("negative array index");
    _jump1050:;
    if (h < _43.d0)
    goto _jump1051;
    fail_assertion("index too large");
    _jump1051:;
    if (_51 >= 0)
    goto _jump1052;
    fail_assertion("negative array index");
    _jump1052:;
    if (_51 < _43.d1)
    goto _jump1053;
    fail_assertion("index too large");
    _jump1053:;
    if (_52 >= 0)
    goto _jump1054;
    fail_assertion("negative array index");
    _jump1054:;
    if (_52 < _43.d2)
    goto _jump1055;
    fail_assertion("index too large");
    _jump1055:;
    int64_t _53 = 0;
    _53 *= _43.d0;
    _53 += h;
    _53 *= _43.d1;
    _53 += _51;
    _53 *= _43.d2;
    _53 += _52;
    int64_t _54 = _43.data[_53];
    _37 = _54;
    _jump1045:;
    int64_t _55 = 850;
    if (_37 >= 0)
    goto _jump1056;
    fail_assertion("negative array index");
    _jump1056:;
    if (_37 < _29.d0)
    goto _jump1057;
    fail_assertion("index too large");
    _jump1057:;
    if (_55 >= 0)
    goto _jump1058;
    fail_assertion("negative array index");
    _jump1058:;
    if (_55 < _29.d1)
    goto _jump1059;
    fail_assertion("index too large");
    _jump1059:;
    int64_t _56 = 0;
    _56 *= _29.d0;
    _56 += _37;
    _56 *= _29.d1;
    _56 += _55;
    int64_t _57 = _29.data[_56];
    if (_57 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    _2 = 0;
    int64_t _58 = 0; // m
    _jump1061:; // Begin body of loop
    _a2_int64_t _59;
    // Computing bound for n
    int64_t _60 = -_58;
    _59.d0 = _60;
    if (_60 > 0) 
    goto _jump1062;
    fail_assertion("non-positive loop bound");
    _jump1062:;
    // Computing bound for o
    int64_t _61 = 858;
    _59.d1 = _61;
    if (_61 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing total size of heap memory to allocate
    int64_t _62 = 1;
    _62 *= _60;
    _62 *= _61;
    _62 *= sizeof(int64_t);
    _59.data = jpl_alloc(_62);
    int64_t _63 = 0; // o
    int64_t _64 = 0; // n
    _jump1064:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _59.d0;
    _65 += _64;
    _65 *= _59.d1;
    _65 += _63;
    _59.data[_65] = _63;
    _63++;
    if (_63 < _61)
    goto _jump1064;
    _63 = 0;
    _64++;
    if (_64 < _60)
    goto _jump1064;
    // End body of loop
    int64_t _66;
    // Computing bound for n
    if (h > 0) 
    goto _jump1065;
    fail_assertion("non-positive loop bound");
    _jump1065:;
    _66 = 0;
    int64_t _67 = 0; // n
    _jump1066:; // Begin body of loop
    int64_t _68 = 830;
    int64_t _69 = -_68;
    _66 += _69;
    _67++;
    if (_67 < h)
    goto _jump1066;
    // End body of loop
    int64_t _70 = 894;
    int64_t _71 = _70 % _58;
    int64_t _72 = _66 - _71;
    if (_58 >= 0)
    goto _jump1067;
    fail_assertion("negative array index");
    _jump1067:;
    if (_58 < _59.d0)
    goto _jump1068;
    fail_assertion("index too large");
    _jump1068:;
    if (_72 >= 0)
    goto _jump1069;
    fail_assertion("negative array index");
    _jump1069:;
    if (_72 < _59.d1)
    goto _jump1070;
    fail_assertion("index too large");
    _jump1070:;
    int64_t _73 = 0;
    _73 *= _59.d0;
    _73 += _58;
    _73 *= _59.d1;
    _73 += _72;
    int64_t _74 = _59.data[_73];
    _2 += _74;
    _58++;
    if (_58 < _57)
    goto _jump1061;
    // End body of loop
    int64_t _75 = _1 % _2;
    _0.d0 = _75;
    if (_75 > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing bound for n
    int64_t _76 = 986;
    if (_76 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (_76 < d.d0)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    int64_t _77 = 0;
    _77 *= d.d0;
    _77 += _76;
    bool _78 = d.data[_77];
    int64_t _79;
    if (!_78)
    goto _jump1074;
    _79 = h;
    goto _jump1075;
    _jump1074:;
    bool _80 = true;
    int64_t _81;
    if (!_80)
    goto _jump1076;
    int64_t _82 = -h;
    _81 = _82;
    goto _jump1077;
    _jump1076:;
    int64_t _83 = 648;
    _81 = _83;
    _jump1077:;
    _79 = _81;
    _jump1075:;
    int64_t _84 = 304;
    if (_84 >= 0)
    goto _jump1078;
    fail_assertion("negative array index");
    _jump1078:;
    if (_84 < g.d0)
    goto _jump1079;
    fail_assertion("index too large");
    _jump1079:;
    int64_t _85 = 0;
    _85 *= g.d0;
    _85 += _84;
    int64_t _86 = g.data[_85];
    int64_t _87 = _79 + _86;
    bool _88 = false;
    bool _89 = !_88;
    bool _90 = _89 != a;
    int64_t _91;
    if (!_90)
    goto _jump1080;
    int64_t _92 = 68;
    _91 = _92;
    goto _jump1081;
    _jump1080:;
    int64_t _93 = 314;
    int64_t _94 = 174;
    int64_t _95 = _93 + _94;
    int64_t _96 = 718;
    int64_t _97 = _95 * _96;
    _91 = _97;
    _jump1081:;
    int64_t _98 = -_91;
    int64_t _99 = _87 / _98;
    int64_t _100 = h - _99;
    _0.d1 = _100;
    if (_100 > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    // Computing bound for o
    int64_t _101 = 416;
    _0.d2 = _101;
    if (_101 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= _75;
    _102 *= _100;
    _102 *= _101;
    _102 *= sizeof(int64_t);
    _0.data = jpl_alloc(_102);
    int64_t _103 = 0; // o
    int64_t _104 = 0; // n
    int64_t _105 = 0; // m
    _jump1084:; // Begin body of loop
    int64_t _106 = -_103;
    int64_t _107 = 0;
    _107 *= _0.d0;
    _107 += _105;
    _107 *= _0.d1;
    _107 += _104;
    _107 *= _0.d2;
    _107 += _103;
    _0.data[_107] = _106;
    _103++;
    if (_103 < _101)
    goto _jump1084;
    _103 = 0;
    _104++;
    if (_104 < _100)
    goto _jump1084;
    _104 = 0;
    _105++;
    if (_105 < _75)
    goto _jump1084;
    // End body of loop
    _a3_int64_t _108;
    // Computing bound for s
    int64_t _109;
    if (!a)
    goto _jump1085;
    _109 = _0.d0;
    goto _jump1086;
    _jump1085:;
    _109 = _0.d0;
    _jump1086:;
    int64_t _110 = -_109;
    int64_t _111 = -_110;
    _108.d0 = _111;
    if (_111 > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing bound for t
    _a3_int64_t _112;
    // Computing bound for s
    bool _113 = false;
    int64_t _114;
    if (!_113)
    goto _jump1088;
    int64_t _115 = 484;
    _114 = _115;
    goto _jump1089;
    _jump1088:;
    int64_t _116 = 742;
    _114 = _116;
    _jump1089:;
    _112.d0 = _114;
    if (_114 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for t
    if (_0.d1 >= 0)
    goto _jump1091;
    fail_assertion("negative array index");
    _jump1091:;
    if (_0.d1 < g.d0)
    goto _jump1092;
    fail_assertion("index too large");
    _jump1092:;
    int64_t _117 = 0;
    _117 *= g.d0;
    _117 += _0.d1;
    int64_t _118 = g.data[_117];
    _112.d1 = _118;
    if (_118 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing bound for u
    int64_t _119 = -_0.d1;
    int64_t _120 = _119 * h;
    _112.d2 = _120;
    if (_120 > 0) 
    goto _jump1094;
    fail_assertion("non-positive loop bound");
    _jump1094:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= _114;
    _121 *= _118;
    _121 *= _120;
    _121 *= sizeof(int64_t);
    _112.data = jpl_alloc(_121);
    int64_t _122 = 0; // u
    int64_t _123 = 0; // t
    int64_t _124 = 0; // s
    _jump1095:; // Begin body of loop
    int64_t _125 = 0;
    _125 *= _112.d0;
    _125 += _124;
    _125 *= _112.d1;
    _125 += _123;
    _125 *= _112.d2;
    _125 += _122;
    _112.data[_125] = _0.d0;
    _122++;
    if (_122 < _120)
    goto _jump1095;
    _122 = 0;
    _123++;
    if (_123 < _118)
    goto _jump1095;
    _123 = 0;
    _124++;
    if (_124 < _114)
    goto _jump1095;
    // End body of loop
    int64_t _126;
    if (!a)
    goto _jump1096;
    _126 = h;
    goto _jump1097;
    _jump1096:;
    int64_t _127;
    // Computing bound for s
    if (_0.d2 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    // Computing bound for t
    int64_t _128 = 443;
    if (_128 > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    _127 = 0;
    int64_t _129 = 0; // t
    int64_t _130 = 0; // s
    _jump1100:; // Begin body of loop
    _127 += _130;
    _129++;
    if (_129 < _128)
    goto _jump1100;
    _129 = 0;
    _130++;
    if (_130 < _0.d2)
    goto _jump1100;
    // End body of loop
    _126 = _127;
    _jump1097:;
    if (_126 >= 0)
    goto _jump1101;
    fail_assertion("negative array index");
    _jump1101:;
    if (_126 < _112.d0)
    goto _jump1102;
    fail_assertion("index too large");
    _jump1102:;
    if (_0.d2 >= 0)
    goto _jump1103;
    fail_assertion("negative array index");
    _jump1103:;
    if (_0.d2 < _112.d1)
    goto _jump1104;
    fail_assertion("index too large");
    _jump1104:;
    if (_0.d2 >= 0)
    goto _jump1105;
    fail_assertion("negative array index");
    _jump1105:;
    if (_0.d2 < _112.d2)
    goto _jump1106;
    fail_assertion("index too large");
    _jump1106:;
    int64_t _131 = 0;
    _131 *= _112.d0;
    _131 += _126;
    _131 *= _112.d1;
    _131 += _0.d2;
    _131 *= _112.d2;
    _131 += _0.d2;
    int64_t _132 = _112.data[_131];
    _108.d1 = _132;
    if (_132 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    // Computing bound for u
    int64_t _133;
    if (!j)
    goto _jump1108;
    _133 = _0.d0;
    goto _jump1109;
    _jump1108:;
    _133 = h;
    _jump1109:;
    int64_t _134 = _0.d2 + _133;
    int64_t _135 = _134 * h;
    int64_t _136 = _135 + _0.d2;
    _108.d2 = _136;
    if (_136 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing total size of heap memory to allocate
    int64_t _137 = 1;
    _137 *= _111;
    _137 *= _132;
    _137 *= _136;
    _137 *= sizeof(int64_t);
    _108.data = jpl_alloc(_137);
    int64_t _138 = 0; // u
    int64_t _139 = 0; // t
    int64_t _140 = 0; // s
    _jump1111:; // Begin body of loop
    int64_t _141;
    if (!a)
    goto _jump1112;
    _141 = h;
    goto _jump1113;
    _jump1112:;
    _141 = _138;
    _jump1113:;
    int64_t _142 = 0;
    _142 *= _108.d0;
    _142 += _140;
    _142 *= _108.d1;
    _142 += _139;
    _142 *= _108.d2;
    _142 += _138;
    _108.data[_142] = _141;
    _138++;
    if (_138 < _136)
    goto _jump1111;
    _138 = 0;
    _139++;
    if (_139 < _132)
    goto _jump1111;
    _139 = 0;
    _140++;
    if (_140 < _111)
    goto _jump1111;
    // End body of loop
    _a2_int64_t _143;
    if (!a)
    goto _jump1114;
    _a2_int64_t _144;
    if (!a)
    goto _jump1115;
    _a2_int64_t _145;
    // Computing bound for s
    _145.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for t
    _145.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _0.d0;
    _146 *= _0.d0;
    _146 *= sizeof(int64_t);
    _145.data = jpl_alloc(_146);
    int64_t _147 = 0; // t
    int64_t _148 = 0; // s
    _jump1118:; // Begin body of loop
    int64_t _149 = 0;
    _149 *= _145.d0;
    _149 += _148;
    _149 *= _145.d1;
    _149 += _147;
    _145.data[_149] = _0.d0;
    _147++;
    if (_147 < _0.d0)
    goto _jump1118;
    _147 = 0;
    _148++;
    if (_148 < _0.d0)
    goto _jump1118;
    // End body of loop
    _144 = _145;
    goto _jump1119;
    _jump1115:;
    _a2_int64_t _150;
    // Computing bound for s
    int64_t _151 = 593;
    _150.d0 = _151;
    if (_151 > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing bound for t
    _150.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= _151;
    _152 *= _0.d0;
    _152 *= sizeof(int64_t);
    _150.data = jpl_alloc(_152);
    int64_t _153 = 0; // t
    int64_t _154 = 0; // s
    _jump1122:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _150.d0;
    _155 += _154;
    _155 *= _150.d1;
    _155 += _153;
    _150.data[_155] = _0.d1;
    _153++;
    if (_153 < _0.d0)
    goto _jump1122;
    _153 = 0;
    _154++;
    if (_154 < _151)
    goto _jump1122;
    // End body of loop
    _144 = _150;
    _jump1119:;
    _143 = _144;
    goto _jump1123;
    _jump1114:;
    _a2_int64_t _156;
    // Computing bound for s
    int64_t _157;
    // Computing bound for s
    if (_0.d0 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing bound for t
    if (_0.d2 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    _157 = 0;
    int64_t _158 = 0; // t
    int64_t _159 = 0; // s
    _jump1126:; // Begin body of loop
    _157 += _0.d2;
    _158++;
    if (_158 < _0.d2)
    goto _jump1126;
    _158 = 0;
    _159++;
    if (_159 < _0.d0)
    goto _jump1126;
    // End body of loop
    _156.d0 = _157;
    if (_157 > 0) 
    goto _jump1127;
    fail_assertion("non-positive loop bound");
    _jump1127:;
    // Computing bound for t
    int64_t _160 = 715;
    _156.d1 = _160;
    if (_160 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    // Computing total size of heap memory to allocate
    int64_t _161 = 1;
    _161 *= _157;
    _161 *= _160;
    _161 *= sizeof(int64_t);
    _156.data = jpl_alloc(_161);
    int64_t _162 = 0; // t
    int64_t _163 = 0; // s
    _jump1129:; // Begin body of loop
    int64_t _164 = 0;
    _164 *= _156.d0;
    _164 += _163;
    _164 *= _156.d1;
    _164 += _162;
    _156.data[_164] = _0.d1;
    _162++;
    if (_162 < _160)
    goto _jump1129;
    _162 = 0;
    _163++;
    if (_163 < _157)
    goto _jump1129;
    // End body of loop
    _143 = _156;
    _jump1123:;
    if (_0.d1 >= 0)
    goto _jump1130;
    fail_assertion("negative array index");
    _jump1130:;
    if (_0.d1 < _143.d0)
    goto _jump1131;
    fail_assertion("index too large");
    _jump1131:;
    if (_0.d1 >= 0)
    goto _jump1132;
    fail_assertion("negative array index");
    _jump1132:;
    if (_0.d1 < _143.d1)
    goto _jump1133;
    fail_assertion("index too large");
    _jump1133:;
    int64_t _165 = 0;
    _165 *= _143.d0;
    _165 += _0.d1;
    _165 *= _143.d1;
    _165 += _0.d1;
    int64_t _166 = _143.data[_165];
    int64_t _167 = 244;
    int64_t _168 = _167 / _0.d2;
    if (_0.d2 >= 0)
    goto _jump1134;
    fail_assertion("negative array index");
    _jump1134:;
    if (_0.d2 < g.d0)
    goto _jump1135;
    fail_assertion("index too large");
    _jump1135:;
    int64_t _169 = 0;
    _169 *= g.d0;
    _169 += _0.d2;
    int64_t _170 = g.data[_169];
    int64_t _171 = _168 * _170;
    int64_t _172 = h - _171;
    int64_t _173 = _172 % _0.d1;
    if (_166 >= 0)
    goto _jump1136;
    fail_assertion("negative array index");
    _jump1136:;
    if (_166 < _0.d0)
    goto _jump1137;
    fail_assertion("index too large");
    _jump1137:;
    if (_173 >= 0)
    goto _jump1138;
    fail_assertion("negative array index");
    _jump1138:;
    if (_173 < _0.d1)
    goto _jump1139;
    fail_assertion("index too large");
    _jump1139:;
    if (_0.d0 >= 0)
    goto _jump1140;
    fail_assertion("negative array index");
    _jump1140:;
    if (_0.d0 < _0.d2)
    goto _jump1141;
    fail_assertion("index too large");
    _jump1141:;
    int64_t _174 = 0;
    _174 *= _0.d0;
    _174 += _166;
    _174 *= _0.d1;
    _174 += _173;
    _174 *= _0.d2;
    _174 += _0.d0;
    int64_t _175 = _0.data[_174];
    bool _176 = l();
    int64_t _177;
    if (!_176)
    goto _jump1142;
    int64_t _178;
    // Computing bound for s
    int64_t _179 = 670;
    if (_179 > 0) 
    goto _jump1143;
    fail_assertion("non-positive loop bound");
    _jump1143:;
    // Computing bound for t
    int64_t _180;
    // Computing bound for s
    if (_0.d1 > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    // Computing bound for t
    int64_t _181 = -h;
    if (_181 > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing bound for u
    int64_t _182 = 336;
    if (_182 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    _180 = 0;
    int64_t _183 = 0; // u
    int64_t _184 = 0; // t
    int64_t _185 = 0; // s
    _jump1147:; // Begin body of loop
    _180 += _0.d2;
    _183++;
    if (_183 < _182)
    goto _jump1147;
    _183 = 0;
    _184++;
    if (_184 < _181)
    goto _jump1147;
    _184 = 0;
    _185++;
    if (_185 < _0.d1)
    goto _jump1147;
    // End body of loop
    if (_180 > 0) 
    goto _jump1148;
    fail_assertion("non-positive loop bound");
    _jump1148:;
    // Computing bound for u
    if (_0.d1 > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    _178 = 0;
    int64_t _186 = 0; // u
    int64_t _187 = 0; // t
    int64_t _188 = 0; // s
    _jump1150:; // Begin body of loop
    _178 += _187;
    _186++;
    if (_186 < _0.d1)
    goto _jump1150;
    _186 = 0;
    _187++;
    if (_187 < _180)
    goto _jump1150;
    _187 = 0;
    _188++;
    if (_188 < _179)
    goto _jump1150;
    // End body of loop
    _177 = _178;
    goto _jump1151;
    _jump1142:;
    _177 = _0.d1;
    _jump1151:;
    if (_0.d2 >= 0)
    goto _jump1152;
    fail_assertion("negative array index");
    _jump1152:;
    if (_0.d2 < _108.d0)
    goto _jump1153;
    fail_assertion("index too large");
    _jump1153:;
    if (_175 >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (_175 < _108.d1)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    if (_177 >= 0)
    goto _jump1156;
    fail_assertion("negative array index");
    _jump1156:;
    if (_177 < _108.d2)
    goto _jump1157;
    fail_assertion("index too large");
    _jump1157:;
    int64_t _189 = 0;
    _189 *= _108.d0;
    _189 += _0.d2;
    _189 *= _108.d1;
    _189 += _175;
    _189 *= _108.d2;
    _189 += _177;
    int64_t _190 = _108.data[_189];
    bool _191 = h == _190;
    return _191;
    if (0 != a)
    goto _jump1158;
    fail_assertion("s");
    _jump1158:;
    bool _192;
    if (!a)
    goto _jump1159;
    _192 = j;
    goto _jump1160;
    _jump1159:;
    if (h >= 0)
    goto _jump1161;
    fail_assertion("negative array index");
    _jump1161:;
    if (h < d.d0)
    goto _jump1162;
    fail_assertion("index too large");
    _jump1162:;
    int64_t _193 = 0;
    _193 *= d.d0;
    _193 += h;
    bool _194 = d.data[_193];
    _192 = _194;
    _jump1160:;
    if (0 != _192)
    goto _jump1163;
    fail_assertion("s");
    _jump1163:;
    bool _195 = true;
    return _195;
}

int64_t F(_a1_rgba G, rgba I, _a2__a2_double J) {
    if (J.d1 >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (J.d1 < d.d0)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    int64_t _0 = 0;
    _0 *= d.d0;
    _0 += J.d1;
    bool _1 = d.data[_0];
    if (0 != _1)
    goto _jump1344;
    fail_assertion("M");
    _jump1344:;
    _a1_int64_t _2;
    // Computing bound for M
    _2.d0 = y;
    if (y > 0) 
    goto _jump1345;
    fail_assertion("non-positive loop bound");
    _jump1345:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= y;
    _3 *= sizeof(int64_t);
    _2.data = jpl_alloc(_3);
    int64_t _4 = 0; // M
    _jump1346:; // Begin body of loop
    int64_t _5 = 0;
    _5 *= _2.d0;
    _5 += _4;
    _2.data[_5] = o;
    _4++;
    if (_4 < y)
    goto _jump1346;
    // End body of loop
    if (0 != j)
    goto _jump1347;
    fail_assertion("S");
    _jump1347:;
    return y;
}

void jpl_main(struct args args) {
    int64_t _1 = 970;
    int64_t _2 = 894;
    int64_t _3 = 885;
    int64_t _4 = _2 * _3;
    int64_t _5 = 594;
    int64_t _6 = -_5;
    bool _7 = _4 >= _6;
    int64_t _8;
    if (!_7)
    goto _jump1;
    int64_t _9 = 369;
    int64_t _10 = 479;
    int64_t _11 = 529;
    _a1_int64_t _12;
    _12.d0 = 3;
    _12.data = jpl_alloc(sizeof(int64_t) * 3);
    _12.data[0] = _9;
    _12.data[1] = _10;
    _12.data[2] = _11;
    int64_t _13 = 164;
    int64_t _14 = 918;
    int64_t _15 = _13 % _14;
    if (_15 >= 0)
    goto _jump2;
    fail_assertion("negative array index");
    _jump2:;
    if (_15 < _12.d0)
    goto _jump3;
    fail_assertion("index too large");
    _jump3:;
    int64_t _16 = 0;
    _16 *= _12.d0;
    _16 += _15;
    int64_t _17 = _12.data[_16];
    _8 = _17;
    goto _jump4;
    _jump1:;
    int64_t _18 = 15;
    _8 = _18;
    _jump4:;
    _a3_int64_t _19;
    // Computing bound for a
    int64_t _20 = 914;
    int64_t _21 = 208;
    int64_t _22 = _20 * _21;
    _19.d0 = _22;
    if (_22 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing bound for b
    int64_t _23 = 783;
    _19.d1 = _23;
    if (_23 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    // Computing bound for c
    int64_t _24 = 656;
    _19.d2 = _24;
    if (_24 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= _22;
    _25 *= _23;
    _25 *= _24;
    _25 *= sizeof(int64_t);
    _19.data = jpl_alloc(_25);
    int64_t _26 = 0; // c
    int64_t _27 = 0; // b
    int64_t _28 = 0; // a
    _jump8:; // Begin body of loop
    bool _29 = true;
    int64_t _30;
    if (!_29)
    goto _jump9;
    _30 = _28;
    goto _jump10;
    _jump9:;
    int64_t _31 = 403;
    _30 = _31;
    _jump10:;
    int64_t _32 = 0;
    _32 *= _19.d0;
    _32 += _28;
    _32 *= _19.d1;
    _32 += _27;
    _32 *= _19.d2;
    _32 += _26;
    _19.data[_32] = _30;
    _26++;
    if (_26 < _24)
    goto _jump8;
    _26 = 0;
    _27++;
    if (_27 < _23)
    goto _jump8;
    _27 = 0;
    _28++;
    if (_28 < _22)
    goto _jump8;
    // End body of loop
    int64_t _33 = 361;
    int64_t _34 = -_33;
    bool _35 = false;
    int64_t _36;
    if (!_35)
    goto _jump11;
    int64_t _37 = 123;
    _36 = _37;
    goto _jump12;
    _jump11:;
    int64_t _38 = 436;
    _36 = _38;
    _jump12:;
    int64_t _39 = -_36;
    int64_t _40 = 259;
    int64_t _41 = -_40;
    if (_34 >= 0)
    goto _jump13;
    fail_assertion("negative array index");
    _jump13:;
    if (_34 < _19.d0)
    goto _jump14;
    fail_assertion("index too large");
    _jump14:;
    if (_39 >= 0)
    goto _jump15;
    fail_assertion("negative array index");
    _jump15:;
    if (_39 < _19.d1)
    goto _jump16;
    fail_assertion("index too large");
    _jump16:;
    if (_41 >= 0)
    goto _jump17;
    fail_assertion("negative array index");
    _jump17:;
    if (_41 < _19.d2)
    goto _jump18;
    fail_assertion("index too large");
    _jump18:;
    int64_t _42 = 0;
    _42 *= _19.d0;
    _42 += _34;
    _42 *= _19.d1;
    _42 += _39;
    _42 *= _19.d2;
    _42 += _41;
    int64_t _43 = _19.data[_42];
    int64_t _44 = _8 % _43;
    bool _45 = _1 == _44;
    bool _0 = _45;
    if (0 == _45)
    goto _jump19;
    int64_t _46 = 502;
    int64_t _47;
    // Computing bound for a
    int64_t _48 = 925;
    if (_48 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _47 = 0;
    int64_t _49 = 0; // a
    _jump21:; // Begin body of loop
    _47 += _49;
    _49++;
    if (_49 < _48)
    goto _jump21;
    // End body of loop
    int64_t _50 = 582;
    int64_t _51 = 731;
    int64_t _52 = _50 / _51;
    bool _53 = _47 <= _52;
    int64_t _54;
    if (!_53)
    goto _jump22;
    int64_t _55 = 876;
    _54 = _55;
    goto _jump23;
    _jump22:;
    int64_t _56 = 351;
    int64_t _57 = -_56;
    _54 = _57;
    _jump23:;
    bool _58 = _46 == _54;
    bool _59 = !_58;
    _0 = _59;
    _jump19:;
    bool _60 = !_0;
    _a3_double _61;
    // Computing bound for d
    int64_t _62 = 387;
    int64_t _63;
    // Computing bound for d
    int64_t _64 = 959;
    if (_64 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    _63 = 0;
    int64_t _65 = 0; // d
    _jump460:; // Begin body of loop
    _63 += _65;
    _65++;
    if (_65 < _64)
    goto _jump460;
    // End body of loop
    int64_t _66 = _62 + _63;
    int64_t _67;
    // Computing bound for d
    int64_t _68 = 869;
    int64_t _69 = -_68;
    if (_69 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for e
    int64_t _70 = 303;
    int64_t _71 = -_70;
    if (_71 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    _67 = 0;
    int64_t _72 = 0; // e
    int64_t _73 = 0; // d
    _jump463:; // Begin body of loop
    int64_t _74 = 238;
    int64_t _75 = -_74;
    _67 += _75;
    _72++;
    if (_72 < _71)
    goto _jump463;
    _72 = 0;
    _73++;
    if (_73 < _69)
    goto _jump463;
    // End body of loop
    int64_t _76 = _66 % _67;
    _61.d0 = _76;
    if (_76 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing bound for e
    int64_t _77 = 199;
    _61.d1 = _77;
    if (_77 > 0) 
    goto _jump465;
    fail_assertion("non-positive loop bound");
    _jump465:;
    // Computing bound for f
    int64_t _78 = 812;
    _61.d2 = _78;
    if (_78 > 0) 
    goto _jump466;
    fail_assertion("non-positive loop bound");
    _jump466:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= _76;
    _79 *= _77;
    _79 *= _78;
    _79 *= sizeof(double);
    _61.data = jpl_alloc(_79);
    int64_t _80 = 0; // f
    int64_t _81 = 0; // e
    int64_t _82 = 0; // d
    _jump467:; // Begin body of loop
    _a3_double _83;
    // Computing bound for g
    int64_t _84 = 943;
    _83.d0 = _84;
    if (_84 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for h
    _83.d1 = _81;
    if (_81 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    // Computing bound for i
    _83.d2 = _82;
    if (_82 > 0) 
    goto _jump470;
    fail_assertion("non-positive loop bound");
    _jump470:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= _84;
    _85 *= _81;
    _85 *= _82;
    _85 *= sizeof(double);
    _83.data = jpl_alloc(_85);
    int64_t _86 = 0; // i
    int64_t _87 = 0; // h
    int64_t _88 = 0; // g
    _jump471:; // Begin body of loop
    double _89 = 88.0;
    int64_t _90 = 0;
    _90 *= _83.d0;
    _90 += _88;
    _90 *= _83.d1;
    _90 += _87;
    _90 *= _83.d2;
    _90 += _86;
    _83.data[_90] = _89;
    _86++;
    if (_86 < _82)
    goto _jump471;
    _86 = 0;
    _87++;
    if (_87 < _81)
    goto _jump471;
    _87 = 0;
    _88++;
    if (_88 < _84)
    goto _jump471;
    // End body of loop
    int64_t _91 = 267;
    int64_t _92;
    // Computing bound for g
    if (_81 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for h
    if (_80 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    _92 = 0;
    int64_t _93 = 0; // h
    int64_t _94 = 0; // g
    _jump474:; // Begin body of loop
    int64_t _95 = 332;
    _92 += _95;
    _93++;
    if (_93 < _80)
    goto _jump474;
    _93 = 0;
    _94++;
    if (_94 < _81)
    goto _jump474;
    // End body of loop
    int64_t _96 = -_92;
    if (_80 >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (_80 < _83.d0)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    if (_91 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_91 < _83.d1)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    if (_96 >= 0)
    goto _jump479;
    fail_assertion("negative array index");
    _jump479:;
    if (_96 < _83.d2)
    goto _jump480;
    fail_assertion("index too large");
    _jump480:;
    int64_t _97 = 0;
    _97 *= _83.d0;
    _97 += _80;
    _97 *= _83.d1;
    _97 += _91;
    _97 *= _83.d2;
    _97 += _96;
    double _98 = _83.data[_97];
    int64_t _99 = 0;
    _99 *= _61.d0;
    _99 += _82;
    _99 *= _61.d1;
    _99 += _81;
    _99 *= _61.d2;
    _99 += _80;
    _61.data[_99] = _98;
    _80++;
    if (_80 < _78)
    goto _jump467;
    _80 = 0;
    _81++;
    if (_81 < _77)
    goto _jump467;
    _81 = 0;
    _82++;
    if (_82 < _76)
    goto _jump467;
    // End body of loop
    int64_t _100;
    // Computing bound for d
    int64_t _101 = 22;
    if (_101 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    // Computing bound for e
    bool _102 = true;
    int64_t _103;
    if (!_102)
    goto _jump482;
    int64_t _104 = 554;
    int64_t _105 = 526;
    int64_t _106 = _104 * _105;
    _103 = _106;
    goto _jump483;
    _jump482:;
    int64_t _107 = 803;
    _103 = _107;
    _jump483:;
    if (_103 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing bound for f
    bool _108 = true;
    int64_t _109;
    if (!_108)
    goto _jump485;
    int64_t _110 = 618;
    int64_t _111 = -_110;
    _109 = _111;
    goto _jump486;
    _jump485:;
    int64_t _112 = 316;
    _109 = _112;
    _jump486:;
    if (_109 > 0) 
    goto _jump487;
    fail_assertion("non-positive loop bound");
    _jump487:;
    _100 = 0;
    int64_t _113 = 0; // f
    int64_t _114 = 0; // e
    int64_t _115 = 0; // d
    _jump488:; // Begin body of loop
    _a1_int64_t _116;
    // Computing bound for g
    int64_t _117 = 426;
    _116.d0 = _117;
    if (_117 > 0) 
    goto _jump489;
    fail_assertion("non-positive loop bound");
    _jump489:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= _117;
    _118 *= sizeof(int64_t);
    _116.data = jpl_alloc(_118);
    int64_t _119 = 0; // g
    _jump490:; // Begin body of loop
    int64_t _120 = 1;
    int64_t _121 = 0;
    _121 *= _116.d0;
    _121 += _119;
    _116.data[_121] = _120;
    _119++;
    if (_119 < _117)
    goto _jump490;
    // End body of loop
    int64_t _122;
    // Computing bound for g
    int64_t _123 = 32;
    if (_123 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    _122 = 0;
    int64_t _124 = 0; // g
    _jump492:; // Begin body of loop
    _122 += _113;
    _124++;
    if (_124 < _123)
    goto _jump492;
    // End body of loop
    if (_122 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_122 < _116.d0)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    int64_t _125 = 0;
    _125 *= _116.d0;
    _125 += _122;
    int64_t _126 = _116.data[_125];
    _100 += _126;
    _113++;
    if (_113 < _109)
    goto _jump488;
    _113 = 0;
    _114++;
    if (_114 < _103)
    goto _jump488;
    _114 = 0;
    _115++;
    if (_115 < _101)
    goto _jump488;
    // End body of loop
    int64_t _127 = -_100;
    bool _129 = false;
    bool _128 = _129;
    if (0 != _129)
    goto _jump495;
    _128 = _60;
    _jump495:;
    int64_t _130;
    if (!_128)
    goto _jump496;
    int64_t _131 = 603;
    _130 = _131;
    goto _jump497;
    _jump496:;
    int64_t _132 = 375;
    int64_t _133 = -_132;
    _130 = _133;
    _jump497:;
    int64_t _134 = 681;
    int64_t _135 = 909;
    int64_t _136 = _134 + _135;
    bool _137 = _130 > _136;
    int64_t _138;
    if (!_137)
    goto _jump498;
    int64_t _139 = 864;
    _138 = _139;
    goto _jump499;
    _jump498:;
    int64_t _140 = 671;
    _138 = _140;
    _jump499:;
    bool _141 = false;
    bool _142;
    if (!_141)
    goto _jump500;
    _142 = _60;
    goto _jump501;
    _jump500:;
    _142 = _60;
    _jump501:;
    int64_t _143;
    if (!_142)
    goto _jump502;
    int64_t _144 = 309;
    _143 = _144;
    goto _jump503;
    _jump502:;
    int64_t _145 = 155;
    int64_t _146 = 275;
    int64_t _147 = _145 % _146;
    int64_t _148 = -_147;
    _143 = _148;
    _jump503:;
    int64_t _149 = 647;
    int64_t _150 = _143 - _149;
    if (_127 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (_127 < _61.d0)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    if (_138 >= 0)
    goto _jump506;
    fail_assertion("negative array index");
    _jump506:;
    if (_138 < _61.d1)
    goto _jump507;
    fail_assertion("index too large");
    _jump507:;
    if (_150 >= 0)
    goto _jump508;
    fail_assertion("negative array index");
    _jump508:;
    if (_150 < _61.d2)
    goto _jump509;
    fail_assertion("index too large");
    _jump509:;
    int64_t _151 = 0;
    _151 *= _61.d0;
    _151 += _127;
    _151 *= _61.d1;
    _151 += _138;
    _151 *= _61.d2;
    _151 += _150;
    double _152 = _61.data[_151];
    double _153 = 18.0;
    bool _154 = _152 == _153;
    _a2_double _155;
    // Computing bound for d
    int64_t _156 = 577;
    int64_t _157 = -_156;
    int64_t _158 = -_157;
    _155.d0 = _158;
    if (_158 > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing bound for e
    int64_t _159;
    if (!_60)
    goto _jump511;
    int64_t _160 = 730;
    int64_t _161 = -_160;
    _159 = _161;
    goto _jump512;
    _jump511:;
    int64_t _162 = 961;
    _159 = _162;
    _jump512:;
    _155.d1 = _159;
    if (_159 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= _158;
    _163 *= _159;
    _163 *= sizeof(double);
    _155.data = jpl_alloc(_163);
    int64_t _164 = 0; // e
    int64_t _165 = 0; // d
    _jump514:; // Begin body of loop
    double _166 = 29.0;
    double _167 = 32.0;
    double _168 = -_167;
    double _169 = fmod(_166, _168);
    double _170 = 13.0;
    double _171 = _169 / _170;
    int64_t _172 = 0;
    _172 *= _155.d0;
    _172 += _165;
    _172 *= _155.d1;
    _172 += _164;
    _155.data[_172] = _171;
    _164++;
    if (_164 < _159)
    goto _jump514;
    _164 = 0;
    _165++;
    if (_165 < _158)
    goto _jump514;
    // End body of loop
    bool _173 = c(_155);
    bool _174 = !_173;
    _a1_bool _175;
    _175.d0 = 2;
    _175.data = jpl_alloc(sizeof(bool) * 2);
    _175.data[0] = _154;
    _175.data[1] = _174;
    double _176 = 94.0;
    int64_t _177;
    if (!_60)
    goto _jump821;
    int64_t _178;
    // Computing bound for g
    int64_t _179 = 438;
    int64_t _180 = 744;
    int64_t _181 = _179 + _180;
    int64_t _182 = 117;
    int64_t _183 = -_182;
    int64_t _184 = _181 * _183;
    if (_184 > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    // Computing bound for h
    int64_t _185 = 17;
    int64_t _186 = -_185;
    int64_t _187 = -_186;
    if (_187 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing bound for i
    int64_t _188;
    // Computing bound for g
    int64_t _189 = 972;
    if (_189 > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    _188 = 0;
    int64_t _190 = 0; // g
    _jump825:; // Begin body of loop
    _188 += _190;
    _190++;
    if (_190 < _189)
    goto _jump825;
    // End body of loop
    if (_188 > 0) 
    goto _jump826;
    fail_assertion("non-positive loop bound");
    _jump826:;
    _178 = 0;
    int64_t _191 = 0; // i
    int64_t _192 = 0; // h
    int64_t _193 = 0; // g
    _jump827:; // Begin body of loop
    int64_t _194 = _193 * _193;
    _178 += _194;
    _191++;
    if (_191 < _188)
    goto _jump827;
    _191 = 0;
    _192++;
    if (_192 < _187)
    goto _jump827;
    _192 = 0;
    _193++;
    if (_193 < _184)
    goto _jump827;
    // End body of loop
    int64_t _195;
    // Computing bound for g
    int64_t _196 = 304;
    if (_196 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing bound for h
    int64_t _197 = 613;
    if (_197 > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    _195 = 0;
    int64_t _198 = 0; // h
    int64_t _199 = 0; // g
    _jump830:; // Begin body of loop
    _195 += _198;
    _198++;
    if (_198 < _197)
    goto _jump830;
    _198 = 0;
    _199++;
    if (_199 < _196)
    goto _jump830;
    // End body of loop
    int64_t _200 = -_195;
    int64_t _201 = _178 / _200;
    _177 = _201;
    goto _jump831;
    _jump821:;
    int64_t _202;
    // Computing bound for g
    int64_t _203 = 251;
    if (_203 > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    // Computing bound for h
    int64_t _204;
    // Computing bound for g
    int64_t _205 = 615;
    int64_t _206 = -_205;
    int64_t _207 = 961;
    int64_t _208 = _206 + _207;
    if (_208 > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for h
    int64_t _209 = 377;
    int64_t _210 = -_209;
    if (_210 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    _204 = 0;
    int64_t _211 = 0; // h
    int64_t _212 = 0; // g
    _jump835:; // Begin body of loop
    int64_t _213 = -_211;
    _204 += _213;
    _211++;
    if (_211 < _210)
    goto _jump835;
    _211 = 0;
    _212++;
    if (_212 < _208)
    goto _jump835;
    // End body of loop
    if (_204 > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for i
    int64_t _214 = 466;
    int64_t _215;
    // Computing bound for g
    int64_t _216 = 653;
    int64_t _217 = -_216;
    if (_217 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for h
    int64_t _218 = 481;
    if (_218 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    _215 = 0;
    int64_t _219 = 0; // h
    int64_t _220 = 0; // g
    _jump839:; // Begin body of loop
    _215 += _219;
    _219++;
    if (_219 < _218)
    goto _jump839;
    _219 = 0;
    _220++;
    if (_220 < _217)
    goto _jump839;
    // End body of loop
    int64_t _221 = _214 / _215;
    if (_221 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    _202 = 0;
    int64_t _222 = 0; // i
    int64_t _223 = 0; // h
    int64_t _224 = 0; // g
    _jump841:; // Begin body of loop
    _a3_int64_t _225;
    // Computing bound for j
    int64_t _226;
    // Computing bound for j
    if (_222 > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    _226 = 0;
    int64_t _227 = 0; // j
    _jump843:; // Begin body of loop
    _226 += _224;
    _227++;
    if (_227 < _222)
    goto _jump843;
    // End body of loop
    _225.d0 = _226;
    if (_226 > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    // Computing bound for k
    _225.d1 = _224;
    if (_224 > 0) 
    goto _jump845;
    fail_assertion("non-positive loop bound");
    _jump845:;
    // Computing bound for l
    _225.d2 = _224;
    if (_224 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= _226;
    _228 *= _224;
    _228 *= _224;
    _228 *= sizeof(int64_t);
    _225.data = jpl_alloc(_228);
    int64_t _229 = 0; // l
    int64_t _230 = 0; // k
    int64_t _231 = 0; // j
    _jump847:; // Begin body of loop
    int64_t _232 = -_231;
    int64_t _233 = 0;
    _233 *= _225.d0;
    _233 += _231;
    _233 *= _225.d1;
    _233 += _230;
    _233 *= _225.d2;
    _233 += _229;
    _225.data[_233] = _232;
    _229++;
    if (_229 < _224)
    goto _jump847;
    _229 = 0;
    _230++;
    if (_230 < _224)
    goto _jump847;
    _230 = 0;
    _231++;
    if (_231 < _226)
    goto _jump847;
    // End body of loop
    int64_t _234 = 315;
    int64_t _235 = -_234;
    int64_t _236 = 64;
    if (_235 >= 0)
    goto _jump848;
    fail_assertion("negative array index");
    _jump848:;
    if (_235 < _225.d0)
    goto _jump849;
    fail_assertion("index too large");
    _jump849:;
    if (_222 >= 0)
    goto _jump850;
    fail_assertion("negative array index");
    _jump850:;
    if (_222 < _225.d1)
    goto _jump851;
    fail_assertion("index too large");
    _jump851:;
    if (_236 >= 0)
    goto _jump852;
    fail_assertion("negative array index");
    _jump852:;
    if (_236 < _225.d2)
    goto _jump853;
    fail_assertion("index too large");
    _jump853:;
    int64_t _237 = 0;
    _237 *= _225.d0;
    _237 += _235;
    _237 *= _225.d1;
    _237 += _222;
    _237 *= _225.d2;
    _237 += _236;
    int64_t _238 = _225.data[_237];
    _202 += _238;
    _222++;
    if (_222 < _221)
    goto _jump841;
    _222 = 0;
    _223++;
    if (_223 < _204)
    goto _jump841;
    _223 = 0;
    _224++;
    if (_224 < _203)
    goto _jump841;
    // End body of loop
    _177 = _202;
    _jump831:;
    int64_t _239;
    // Computing bound for g
    _a3_int64_t _240;
    // Computing bound for g
    int64_t _241 = 920;
    _240.d0 = _241;
    if (_241 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing bound for h
    int64_t _242;
    // Computing bound for g
    int64_t _243 = 343;
    if (_243 > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    _242 = 0;
    int64_t _244 = 0; // g
    _jump856:; // Begin body of loop
    int64_t _245 = 934;
    _242 += _245;
    _244++;
    if (_244 < _243)
    goto _jump856;
    // End body of loop
    _240.d1 = _242;
    if (_242 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    // Computing bound for i
    int64_t _246 = 664;
    _240.d2 = _246;
    if (_246 > 0) 
    goto _jump858;
    fail_assertion("non-positive loop bound");
    _jump858:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= _241;
    _247 *= _242;
    _247 *= _246;
    _247 *= sizeof(int64_t);
    _240.data = jpl_alloc(_247);
    int64_t _248 = 0; // i
    int64_t _249 = 0; // h
    int64_t _250 = 0; // g
    _jump859:; // Begin body of loop
    int64_t _251 = 0;
    _251 *= _240.d0;
    _251 += _250;
    _251 *= _240.d1;
    _251 += _249;
    _251 *= _240.d2;
    _251 += _248;
    _240.data[_251] = _249;
    _248++;
    if (_248 < _246)
    goto _jump859;
    _248 = 0;
    _249++;
    if (_249 < _242)
    goto _jump859;
    _249 = 0;
    _250++;
    if (_250 < _241)
    goto _jump859;
    // End body of loop
    int64_t _252 = 953;
    int64_t _253;
    // Computing bound for g
    int64_t _254 = 627;
    int64_t _255 = 885;
    int64_t _256 = _254 * _255;
    if (_256 > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    // Computing bound for h
    int64_t _257 = 358;
    if (_257 > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    _253 = 0;
    int64_t _258 = 0; // h
    int64_t _259 = 0; // g
    _jump862:; // Begin body of loop
    int64_t _260 = 51;
    bool _261 = _258 == _260;
    int64_t _262;
    if (!_261)
    goto _jump863;
    _262 = _258;
    goto _jump864;
    _jump863:;
    bool _263 = false;
    int64_t _264;
    if (!_263)
    goto _jump865;
    int64_t _265 = 892;
    _264 = _265;
    goto _jump866;
    _jump865:;
    int64_t _266 = 350;
    _264 = _266;
    _jump866:;
    _262 = _264;
    _jump864:;
    _253 += _262;
    _258++;
    if (_258 < _257)
    goto _jump862;
    _258 = 0;
    _259++;
    if (_259 < _256)
    goto _jump862;
    // End body of loop
    int64_t _267;
    if (!_60)
    goto _jump867;
    int64_t _268 = 60;
    int64_t _269 = 171;
    int64_t _270 = _268 / _269;
    _267 = _270;
    goto _jump868;
    _jump867:;
    int64_t _271 = 143;
    _267 = _271;
    _jump868:;
    if (_252 >= 0)
    goto _jump869;
    fail_assertion("negative array index");
    _jump869:;
    if (_252 < _240.d0)
    goto _jump870;
    fail_assertion("index too large");
    _jump870:;
    if (_253 >= 0)
    goto _jump871;
    fail_assertion("negative array index");
    _jump871:;
    if (_253 < _240.d1)
    goto _jump872;
    fail_assertion("index too large");
    _jump872:;
    if (_267 >= 0)
    goto _jump873;
    fail_assertion("negative array index");
    _jump873:;
    if (_267 < _240.d2)
    goto _jump874;
    fail_assertion("index too large");
    _jump874:;
    int64_t _272 = 0;
    _272 *= _240.d0;
    _272 += _252;
    _272 *= _240.d1;
    _272 += _253;
    _272 *= _240.d2;
    _272 += _267;
    int64_t _273 = _240.data[_272];
    if (_273 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for h
    bool _274 = true;
    bool _275 = !_274;
    int64_t _276;
    if (!_275)
    goto _jump876;
    int64_t _277 = 993;
    int64_t _278 = 638;
    _a1_int64_t _279;
    _279.d0 = 2;
    _279.data = jpl_alloc(sizeof(int64_t) * 2);
    _279.data[0] = _277;
    _279.data[1] = _278;
    int64_t _280 = 564;
    if (_280 >= 0)
    goto _jump877;
    fail_assertion("negative array index");
    _jump877:;
    if (_280 < _279.d0)
    goto _jump878;
    fail_assertion("index too large");
    _jump878:;
    int64_t _281 = 0;
    _281 *= _279.d0;
    _281 += _280;
    int64_t _282 = _279.data[_281];
    _276 = _282;
    goto _jump879;
    _jump876:;
    int64_t _283 = 568;
    int64_t _284 = -_283;
    int64_t _285 = -_284;
    _276 = _285;
    _jump879:;
    int64_t _286;
    // Computing bound for g
    int64_t _287;
    // Computing bound for g
    int64_t _288 = 255;
    if (_288 > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    // Computing bound for h
    int64_t _289 = 625;
    if (_289 > 0) 
    goto _jump881;
    fail_assertion("non-positive loop bound");
    _jump881:;
    _287 = 0;
    int64_t _290 = 0; // h
    int64_t _291 = 0; // g
    _jump882:; // Begin body of loop
    int64_t _292 = 542;
    int64_t _293 = -_292;
    _287 += _293;
    _290++;
    if (_290 < _289)
    goto _jump882;
    _290 = 0;
    _291++;
    if (_291 < _288)
    goto _jump882;
    // End body of loop
    if (_287 > 0) 
    goto _jump883;
    fail_assertion("non-positive loop bound");
    _jump883:;
    // Computing bound for h
    int64_t _294 = 766;
    int64_t _295 = 787;
    int64_t _296 = -_295;
    int64_t _297 = _294 * _296;
    if (_297 > 0) 
    goto _jump884;
    fail_assertion("non-positive loop bound");
    _jump884:;
    // Computing bound for i
    int64_t _298;
    // Computing bound for g
    int64_t _299 = 189;
    if (_299 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing bound for h
    int64_t _300 = 937;
    if (_300 > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing bound for i
    int64_t _301;
    // Computing bound for g
    int64_t _302 = 600;
    if (_302 > 0) 
    goto _jump887;
    fail_assertion("non-positive loop bound");
    _jump887:;
    // Computing bound for h
    int64_t _303 = 167;
    if (_303 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    _301 = 0;
    int64_t _304 = 0; // h
    int64_t _305 = 0; // g
    _jump889:; // Begin body of loop
    int64_t _306 = 719;
    _301 += _306;
    _304++;
    if (_304 < _303)
    goto _jump889;
    _304 = 0;
    _305++;
    if (_305 < _302)
    goto _jump889;
    // End body of loop
    if (_301 > 0) 
    goto _jump890;
    fail_assertion("non-positive loop bound");
    _jump890:;
    _298 = 0;
    int64_t _307 = 0; // i
    int64_t _308 = 0; // h
    int64_t _309 = 0; // g
    _jump891:; // Begin body of loop
    int64_t _310;
    if (!_60)
    goto _jump892;
    _310 = _307;
    goto _jump893;
    _jump892:;
    int64_t _311 = 888;
    _310 = _311;
    _jump893:;
    _298 += _310;
    _307++;
    if (_307 < _301)
    goto _jump891;
    _307 = 0;
    _308++;
    if (_308 < _300)
    goto _jump891;
    _308 = 0;
    _309++;
    if (_309 < _299)
    goto _jump891;
    // End body of loop
    if (_298 > 0) 
    goto _jump894;
    fail_assertion("non-positive loop bound");
    _jump894:;
    _286 = 0;
    int64_t _312 = 0; // i
    int64_t _313 = 0; // h
    int64_t _314 = 0; // g
    _jump895:; // Begin body of loop
    _a1_int64_t _315;
    _315.d0 = 1;
    _315.data = jpl_alloc(sizeof(int64_t) * 1);
    _315.data[0] = _312;
    int64_t _316 = 70;
    int64_t _317 = _312 + _316;
    if (_317 >= 0)
    goto _jump896;
    fail_assertion("negative array index");
    _jump896:;
    if (_317 < _315.d0)
    goto _jump897;
    fail_assertion("index too large");
    _jump897:;
    int64_t _318 = 0;
    _318 *= _315.d0;
    _318 += _317;
    int64_t _319 = _315.data[_318];
    _286 += _319;
    _312++;
    if (_312 < _298)
    goto _jump895;
    _312 = 0;
    _313++;
    if (_313 < _297)
    goto _jump895;
    _313 = 0;
    _314++;
    if (_314 < _287)
    goto _jump895;
    // End body of loop
    int64_t _320 = _276 + _286;
    if (_320 > 0) 
    goto _jump898;
    fail_assertion("non-positive loop bound");
    _jump898:;
    _239 = 0;
    int64_t _321 = 0; // h
    int64_t _322 = 0; // g
    _jump899:; // Begin body of loop
    bool _323 = true;
    bool _324;
    if (!_323)
    goto _jump900;
    _324 = _60;
    goto _jump901;
    _jump900:;
    bool _325 = _60;
    if (0 == _60)
    goto _jump902;
    _325 = _60;
    _jump902:;
    _324 = _325;
    _jump901:;
    _a1_int64_t _326;
    if (!_324)
    goto _jump903;
    int64_t _327 = 709;
    _a1_int64_t _328;
    _328.d0 = 3;
    _328.data = jpl_alloc(sizeof(int64_t) * 3);
    _328.data[0] = _322;
    _328.data[1] = _327;
    _328.data[2] = _321;
    _326 = _328;
    goto _jump904;
    _jump903:;
    _a1_int64_t _329;
    // Computing bound for i
    int64_t _330 = 380;
    _329.d0 = _330;
    if (_330 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= _330;
    _331 *= sizeof(int64_t);
    _329.data = jpl_alloc(_331);
    int64_t _332 = 0; // i
    _jump906:; // Begin body of loop
    int64_t _333 = 0;
    _333 *= _329.d0;
    _333 += _332;
    _329.data[_333] = _322;
    _332++;
    if (_332 < _330)
    goto _jump906;
    // End body of loop
    _326 = _329;
    _jump904:;
    int64_t _334 = -_322;
    if (_334 >= 0)
    goto _jump907;
    fail_assertion("negative array index");
    _jump907:;
    if (_334 < _326.d0)
    goto _jump908;
    fail_assertion("index too large");
    _jump908:;
    int64_t _335 = 0;
    _335 *= _326.d0;
    _335 += _334;
    int64_t _336 = _326.data[_335];
    _239 += _336;
    _321++;
    if (_321 < _320)
    goto _jump899;
    _321 = 0;
    _322++;
    if (_322 < _273)
    goto _jump899;
    // End body of loop
    bool _337 = _177 != _239;
    _a1_int64_t _338;
    if (!_337)
    goto _jump909;
    _a1_int64_t _339;
    // Computing bound for g
    int64_t _340;
    if (!_60)
    goto _jump910;
    bool _342 = !_60;
    bool _341 = _342;
    if (0 != _342)
    goto _jump911;
    bool _343 = true;
    bool _344 = _60 != _343;
    _341 = _344;
    _jump911:;
    int64_t _345;
    if (!_341)
    goto _jump912;
    int64_t _346 = 380;
    int64_t _347 = -_346;
    _345 = _347;
    goto _jump913;
    _jump912:;
    int64_t _348;
    if (!_60)
    goto _jump914;
    bool _349 = true;
    int64_t _350;
    if (!_349)
    goto _jump915;
    int64_t _351 = 622;
    _350 = _351;
    goto _jump916;
    _jump915:;
    int64_t _352 = 358;
    _350 = _352;
    _jump916:;
    _348 = _350;
    goto _jump917;
    _jump914:;
    int64_t _353 = 374;
    _348 = _353;
    _jump917:;
    _345 = _348;
    _jump913:;
    int64_t _354 = 776;
    int64_t _355 = -_354;
    int64_t _356 = _345 * _355;
    _340 = _356;
    goto _jump918;
    _jump910:;
    bool _357 = !_60;
    bool _358;
    if (!_357)
    goto _jump919;
    double _359 = 79.0;
    bool _360 = _359 <= _176;
    _358 = _360;
    goto _jump920;
    _jump919:;
    _358 = _60;
    _jump920:;
    int64_t _361;
    if (!_358)
    goto _jump921;
    int64_t _362 = 635;
    int64_t _363 = -_362;
    int64_t _364 = 498;
    int64_t _365 = _363 - _364;
    _361 = _365;
    goto _jump922;
    _jump921:;
    int64_t _366 = 340;
    _361 = _366;
    _jump922:;
    int64_t _367 = -_361;
    _340 = _367;
    _jump918:;
    _339.d0 = _340;
    if (_340 > 0) 
    goto _jump923;
    fail_assertion("non-positive loop bound");
    _jump923:;
    // Computing total size of heap memory to allocate
    int64_t _368 = 1;
    _368 *= _340;
    _368 *= sizeof(int64_t);
    _339.data = jpl_alloc(_368);
    int64_t _369 = 0; // g
    _jump924:; // Begin body of loop
    int64_t _370;
    // Computing bound for h
    if (_369 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for i
    bool _371 = false;
    bool _372;
    if (!_371)
    goto _jump926;
    _372 = _60;
    goto _jump927;
    _jump926:;
    _372 = _60;
    _jump927:;
    _a1_int64_t _373;
    if (!_372)
    goto _jump928;
    _a1_int64_t _374;
    // Computing bound for h
    int64_t _375 = 801;
    _374.d0 = _375;
    if (_375 > 0) 
    goto _jump929;
    fail_assertion("non-positive loop bound");
    _jump929:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= _375;
    _376 *= sizeof(int64_t);
    _374.data = jpl_alloc(_376);
    int64_t _377 = 0; // h
    _jump930:; // Begin body of loop
    int64_t _378 = 124;
    int64_t _379 = 0;
    _379 *= _374.d0;
    _379 += _377;
    _374.data[_379] = _378;
    _377++;
    if (_377 < _375)
    goto _jump930;
    // End body of loop
    _373 = _374;
    goto _jump931;
    _jump928:;
    _a1_int64_t _380;
    // Computing bound for h
    _380.d0 = _369;
    if (_369 > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= _369;
    _381 *= sizeof(int64_t);
    _380.data = jpl_alloc(_381);
    int64_t _382 = 0; // h
    _jump933:; // Begin body of loop
    int64_t _383;
    // Computing bound for i
    int64_t _384 = 405;
    if (_384 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    _383 = 0;
    int64_t _385 = 0; // i
    _jump935:; // Begin body of loop
    _383 += _382;
    _385++;
    if (_385 < _384)
    goto _jump935;
    // End body of loop
    int64_t _386 = 0;
    _386 *= _380.d0;
    _386 += _382;
    _380.data[_386] = _383;
    _382++;
    if (_382 < _369)
    goto _jump933;
    // End body of loop
    _373 = _380;
    _jump931:;
    int64_t _387;
    // Computing bound for h
    int64_t _388 = 478;
    int64_t _389 = -_388;
    if (_389 > 0) 
    goto _jump936;
    fail_assertion("non-positive loop bound");
    _jump936:;
    _387 = 0;
    int64_t _390 = 0; // h
    _jump937:; // Begin body of loop
    int64_t _391 = -_369;
    int64_t _392 = -_391;
    _387 += _392;
    _390++;
    if (_390 < _389)
    goto _jump937;
    // End body of loop
    if (_387 >= 0)
    goto _jump938;
    fail_assertion("negative array index");
    _jump938:;
    if (_387 < _373.d0)
    goto _jump939;
    fail_assertion("index too large");
    _jump939:;
    int64_t _393 = 0;
    _393 *= _373.d0;
    _393 += _387;
    int64_t _394 = _373.data[_393];
    if (_394 > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    _370 = 0;
    int64_t _395 = 0; // i
    int64_t _396 = 0; // h
    _jump941:; // Begin body of loop
    int64_t _397 = 494;
    _370 += _397;
    _395++;
    if (_395 < _394)
    goto _jump941;
    _395 = 0;
    _396++;
    if (_396 < _369)
    goto _jump941;
    // End body of loop
    int64_t _398 = 0;
    _398 *= _339.d0;
    _398 += _369;
    _339.data[_398] = _370;
    _369++;
    if (_369 < _340)
    goto _jump924;
    // End body of loop
    _338 = _339;
    goto _jump942;
    _jump909:;
    int64_t _399;
    // Computing bound for g
    int64_t _400 = 325;
    if (_400 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    _399 = 0;
    int64_t _401 = 0; // g
    _jump944:; // Begin body of loop
    int64_t _402 = 471;
    if (_402 >= 0)
    goto _jump945;
    fail_assertion("negative array index");
    _jump945:;
    if (_402 < _175.d0)
    goto _jump946;
    fail_assertion("index too large");
    _jump946:;
    int64_t _403 = 0;
    _403 *= _175.d0;
    _403 += _402;
    bool _404 = _175.data[_403];
    bool _405 = !_404;
    int64_t _406;
    if (!_405)
    goto _jump947;
    _406 = _401;
    goto _jump948;
    _jump947:;
    int64_t _407 = 76;
    int64_t _408 = _401 % _407;
    _406 = _408;
    _jump948:;
    _399 += _406;
    _401++;
    if (_401 < _400)
    goto _jump944;
    // End body of loop
    int64_t _409 = -_399;
    int64_t _410;
    // Computing bound for g
    int64_t _411 = 876;
    if (_411 > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    _410 = 0;
    int64_t _412 = 0; // g
    _jump950:; // Begin body of loop
    int64_t _413 = 194;
    _a1_int64_t _414;
    _414.d0 = 1;
    _414.data = jpl_alloc(sizeof(int64_t) * 1);
    _414.data[0] = _413;
    int64_t _415 = -_412;
    if (_415 >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (_415 < _414.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    int64_t _416 = 0;
    _416 *= _414.d0;
    _416 += _415;
    int64_t _417 = _414.data[_416];
    _410 += _417;
    _412++;
    if (_412 < _411)
    goto _jump950;
    // End body of loop
    _a1_int64_t _418;
    _418.d0 = 2;
    _418.data = jpl_alloc(sizeof(int64_t) * 2);
    _418.data[0] = _409;
    _418.data[1] = _410;
    _338 = _418;
    _jump942:;
    _a2_rgba _419 = read_image("i.png");
    double _420 = get_time();
    bool _421 = true;
    double _422 = get_time();
    print_time(_422 - _420);
    print("k");
    bool _423 = true;
    bool _424 = !_423;
    double _425;
    if (!_424)
    goto _jump953;
    double _426 = 35.0;
    _425 = _426;
    goto _jump954;
    _jump953:;
    double _427;
    // Computing bound for k
    if (_338.d0 > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing bound for l
    if (_338.d0 > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for m
    bool _428 = !_421;
    int64_t _429;
    if (!_428)
    goto _jump957;
    int64_t _430 = 12;
    _429 = _430;
    goto _jump958;
    _jump957:;
    int64_t _431;
    // Computing bound for k
    int64_t _432 = 164;
    if (_432 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    _431 = 0;
    int64_t _433 = 0; // k
    _jump960:; // Begin body of loop
    _431 += _338.d0;
    _433++;
    if (_433 < _432)
    goto _jump960;
    // End body of loop
    _429 = _431;
    _jump958:;
    if (_429 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    _427 = 0;
    int64_t _434 = 0; // m
    int64_t _435 = 0; // l
    int64_t _436 = 0; // k
    _jump962:; // Begin body of loop
    double _437 = 3.0;
    _427 += _437;
    _434++;
    if (_434 < _429)
    goto _jump962;
    _434 = 0;
    _435++;
    if (_435 < _338.d0)
    goto _jump962;
    _435 = 0;
    _436++;
    if (_436 < _338.d0)
    goto _jump962;
    // End body of loop
    double _438;
    // Computing bound for k
    int64_t _439 = 624;
    if (_439 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    _438 = 0;
    int64_t _440 = 0; // k
    _jump964:; // Begin body of loop
    double _441;
    // Computing bound for l
    int64_t _442 = -_338.d0;
    if (_442 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    _441 = 0;
    int64_t _443 = 0; // l
    _jump966:; // Begin body of loop
    bool _444 = true;
    double _445;
    if (!_444)
    goto _jump967;
    double _446 = 49.0;
    _445 = _446;
    goto _jump968;
    _jump967:;
    _445 = _176;
    _jump968:;
    _441 += _445;
    _443++;
    if (_443 < _442)
    goto _jump966;
    // End body of loop
    _438 += _441;
    _440++;
    if (_440 < _439)
    goto _jump964;
    // End body of loop
    double _447 = fmod(_427, _438);
    _425 = _447;
    _jump954:;
    _a2_bool _448;
    // Computing bound for k
    int64_t _449;
    if (!_60)
    goto _jump969;
    _449 = _338.d0;
    goto _jump970;
    _jump969:;
    _449 = _338.d0;
    _jump970:;
    _448.d0 = _449;
    if (_449 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    // Computing bound for l
    _448.d1 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump972;
    fail_assertion("non-positive loop bound");
    _jump972:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= _449;
    _450 *= _338.d0;
    _450 *= sizeof(bool);
    _448.data = jpl_alloc(_450);
    int64_t _451 = 0; // l
    int64_t _452 = 0; // k
    _jump973:; // Begin body of loop
    int64_t _453 = 0;
    _453 *= _448.d0;
    _453 += _452;
    _453 *= _448.d1;
    _453 += _451;
    _448.data[_453] = _60;
    _451++;
    if (_451 < _338.d0)
    goto _jump973;
    _451 = 0;
    _452++;
    if (_452 < _449)
    goto _jump973;
    // End body of loop
    int64_t _454 = _338.d0 * _338.d0;
    if (_338.d0 >= 0)
    goto _jump974;
    fail_assertion("negative array index");
    _jump974:;
    if (_338.d0 < _448.d0)
    goto _jump975;
    fail_assertion("index too large");
    _jump975:;
    if (_454 >= 0)
    goto _jump976;
    fail_assertion("negative array index");
    _jump976:;
    if (_454 < _448.d1)
    goto _jump977;
    fail_assertion("index too large");
    _jump977:;
    int64_t _455 = 0;
    _455 *= _448.d0;
    _455 += _338.d0;
    _455 *= _448.d1;
    _455 += _454;
    bool _456 = _448.data[_455];
    rgba _457;
    if (!_456)
    goto _jump978;
    double _458 = 89.0;
    double _459 = 47.0;
    double _460 = _458 / _459;
    double _461 = -_460;
    double _462 = 89.0;
    _a1_double _463;
    _463.d0 = 1;
    _463.data = jpl_alloc(sizeof(double) * 1);
    _463.data[0] = _462;
    bool _464 = true;
    int64_t _465;
    if (!_464)
    goto _jump979;
    _465 = _338.d0;
    goto _jump980;
    _jump979:;
    int64_t _466 = 695;
    _465 = _466;
    _jump980:;
    if (_465 >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (_465 < _463.d0)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    int64_t _467 = 0;
    _467 *= _463.d0;
    _467 += _465;
    double _468 = _463.data[_467];
    double _469 = 87.0;
    double _470 = 59.0;
    rgba _471 = { _176, _469, _470, _176 };
    double _472 = _471.r;
    rgba _473 = { _461, _468, _472, _176 };
    _457 = _473;
    goto _jump983;
    _jump978:;
    int64_t _474 = -_338.d0;
    int64_t _475;
    // Computing bound for k
    if (_338.d0 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing bound for l
    int64_t _476 = -_338.d0;
    if (_476 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    _475 = 0;
    int64_t _477 = 0; // l
    int64_t _478 = 0; // k
    _jump986:; // Begin body of loop
    int64_t _479 = -_477;
    _475 += _479;
    _477++;
    if (_477 < _476)
    goto _jump986;
    _477 = 0;
    _478++;
    if (_478 < _338.d0)
    goto _jump986;
    // End body of loop
    if (_474 >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (_474 < _419.d0)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    if (_475 >= 0)
    goto _jump989;
    fail_assertion("negative array index");
    _jump989:;
    if (_475 < _419.d1)
    goto _jump990;
    fail_assertion("index too large");
    _jump990:;
    int64_t _480 = 0;
    _480 *= _419.d0;
    _480 += _474;
    _480 *= _419.d1;
    _480 += _475;
    rgba _481 = _419.data[_480];
    _457 = _481;
    _jump983:;
    double _482 = _457.r;
    bool _483;
    if (!_421)
    goto _jump991;
    _483 = _421;
    goto _jump992;
    _jump991:;
    _483 = _60;
    _jump992:;
    rgba _484;
    if (!_483)
    goto _jump993;
    double _485;
    // Computing bound for k
    int64_t _486 = 228;
    if (_486 > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    // Computing bound for l
    int64_t _487 = 230;
    if (_487 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    _485 = 0;
    int64_t _488 = 0; // l
    int64_t _489 = 0; // k
    _jump996:; // Begin body of loop
    _485 += _176;
    _488++;
    if (_488 < _487)
    goto _jump996;
    _488 = 0;
    _489++;
    if (_489 < _486)
    goto _jump996;
    // End body of loop
    double _490 = 65.0;
    rgba _491 = { _485, _490, _176, _176 };
    _484 = _491;
    goto _jump997;
    _jump993:;
    bool _492 = false;
    _a2_rgba _493;
    if (!_492)
    goto _jump998;
    _493 = _419;
    goto _jump999;
    _jump998:;
    _493 = _419;
    _jump999:;
    int64_t _494 = 202;
    int64_t _495 = -_494;
    int64_t _496 = 306;
    if (_495 >= 0)
    goto _jump1000;
    fail_assertion("negative array index");
    _jump1000:;
    if (_495 < _493.d0)
    goto _jump1001;
    fail_assertion("index too large");
    _jump1001:;
    if (_496 >= 0)
    goto _jump1002;
    fail_assertion("negative array index");
    _jump1002:;
    if (_496 < _493.d1)
    goto _jump1003;
    fail_assertion("index too large");
    _jump1003:;
    int64_t _497 = 0;
    _497 *= _493.d0;
    _497 += _495;
    _497 *= _493.d1;
    _497 += _496;
    rgba _498 = _493.data[_497];
    _484 = _498;
    _jump997:;
    double _499 = _484.g;
    double _500 = -_499;
    _a2_double _501;
    // Computing bound for k
    int64_t _502 = 260;
    _501.d0 = _502;
    if (_502 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for l
    _501.d1 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing total size of heap memory to allocate
    int64_t _503 = 1;
    _503 *= _502;
    _503 *= _338.d0;
    _503 *= sizeof(double);
    _501.data = jpl_alloc(_503);
    int64_t _504 = 0; // l
    int64_t _505 = 0; // k
    _jump1006:; // Begin body of loop
    int64_t _506 = 0;
    _506 *= _501.d0;
    _506 += _505;
    _506 *= _501.d1;
    _506 += _504;
    _501.data[_506] = _176;
    _504++;
    if (_504 < _338.d0)
    goto _jump1006;
    _504 = 0;
    _505++;
    if (_505 < _502)
    goto _jump1006;
    // End body of loop
    bool _507 = c(_501);
    double _508;
    if (!_507)
    goto _jump1007;
    double _509 = 99.0;
    double _510 = 8.0;
    double _511 = _510 - _176;
    double _512 = fmod(_509, _511);
    _508 = _512;
    goto _jump1008;
    _jump1007:;
    _508 = _176;
    _jump1008:;
    _a1_double _513;
    // Computing bound for k
    int64_t _514 = 967;
    int64_t _515 = _514 + _338.d0;
    _513.d0 = _515;
    if (_515 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing total size of heap memory to allocate
    int64_t _516 = 1;
    _516 *= _515;
    _516 *= sizeof(double);
    _513.data = jpl_alloc(_516);
    int64_t _517 = 0; // k
    _jump1010:; // Begin body of loop
    double _518 = 89.0;
    double _519 = -_518;
    int64_t _520 = 0;
    _520 *= _513.d0;
    _520 += _517;
    _513.data[_520] = _519;
    _517++;
    if (_517 < _515)
    goto _jump1010;
    // End body of loop
    int64_t _521 = 603;
    if (_521 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (_521 < _513.d0)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    int64_t _522 = 0;
    _522 *= _513.d0;
    _522 += _521;
    double _523 = _513.data[_522];
    double _524 = _508 / _523;
    double _525;
    // Computing bound for k
    int64_t _526;
    // Computing bound for k
    if (_338.d0 > 0) 
    goto _jump1013;
    fail_assertion("non-positive loop bound");
    _jump1013:;
    _526 = 0;
    int64_t _527 = 0; // k
    _jump1014:; // Begin body of loop
    int64_t _528;
    if (!_60)
    goto _jump1015;
    int64_t _529 = 821;
    int64_t _530 = _529 - _338.d0;
    _528 = _530;
    goto _jump1016;
    _jump1015:;
    _528 = _338.d0;
    _jump1016:;
    _526 += _528;
    _527++;
    if (_527 < _338.d0)
    goto _jump1014;
    // End body of loop
    if (_526 > 0) 
    goto _jump1017;
    fail_assertion("non-positive loop bound");
    _jump1017:;
    _525 = 0;
    int64_t _531 = 0; // k
    _jump1018:; // Begin body of loop
    double _532 = _176 - _176;
    _525 += _532;
    _531++;
    if (_531 < _526)
    goto _jump1018;
    // End body of loop
    double _533 = _524 / _525;
    rgba _534 = { _425, _482, _500, _533 };
    double _535 = _534.a;
    show("(FloatType)", &_535);
    bool _536 = _176 < _535;
    bool _537 = !_536;
    _a3_int64_t _538;
    if (!_537)
    goto _jump1164;
    _a3_int64_t _539;
    // Computing bound for m
    int64_t _540 = 859;
    int64_t _541 = 475;
    int64_t _542 = _541 * _338.d0;
    int64_t _543 = 65;
    int64_t _544 = 664;
    int64_t _545 = _338.d0 % _544;
    int64_t _546 = _543 - _545;
    _a1_int64_t _547;
    _547.d0 = 3;
    _547.data = jpl_alloc(sizeof(int64_t) * 3);
    _547.data[0] = _540;
    _547.data[1] = _542;
    _547.data[2] = _546;
    int64_t _548;
    // Computing bound for m
    if (_338.d0 > 0) 
    goto _jump1165;
    fail_assertion("non-positive loop bound");
    _jump1165:;
    // Computing bound for n
    if (_338.d0 > 0) 
    goto _jump1166;
    fail_assertion("non-positive loop bound");
    _jump1166:;
    // Computing bound for o
    int64_t _549 = 302;
    if (_549 > 0) 
    goto _jump1167;
    fail_assertion("non-positive loop bound");
    _jump1167:;
    _548 = 0;
    int64_t _550 = 0; // o
    int64_t _551 = 0; // n
    int64_t _552 = 0; // m
    _jump1168:; // Begin body of loop
    _548 += _551;
    _550++;
    if (_550 < _549)
    goto _jump1168;
    _550 = 0;
    _551++;
    if (_551 < _338.d0)
    goto _jump1168;
    _551 = 0;
    _552++;
    if (_552 < _338.d0)
    goto _jump1168;
    // End body of loop
    if (_548 >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (_548 < _547.d0)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    int64_t _553 = 0;
    _553 *= _547.d0;
    _553 += _548;
    int64_t _554 = _547.data[_553];
    _a2_double _555;
    // Computing bound for m
    int64_t _556 = 496;
    _555.d0 = _556;
    if (_556 > 0) 
    goto _jump1171;
    fail_assertion("non-positive loop bound");
    _jump1171:;
    // Computing bound for n
    _555.d1 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1172;
    fail_assertion("non-positive loop bound");
    _jump1172:;
    // Computing total size of heap memory to allocate
    int64_t _557 = 1;
    _557 *= _556;
    _557 *= _338.d0;
    _557 *= sizeof(double);
    _555.data = jpl_alloc(_557);
    int64_t _558 = 0; // n
    int64_t _559 = 0; // m
    _jump1173:; // Begin body of loop
    int64_t _560 = 0;
    _560 *= _555.d0;
    _560 += _559;
    _560 *= _555.d1;
    _560 += _558;
    _555.data[_560] = _535;
    _558++;
    if (_558 < _338.d0)
    goto _jump1173;
    _558 = 0;
    _559++;
    if (_559 < _556)
    goto _jump1173;
    // End body of loop
    int64_t _561 = 369;
    int64_t _562 = _338.d0 + _338.d0;
    if (_561 >= 0)
    goto _jump1174;
    fail_assertion("negative array index");
    _jump1174:;
    if (_561 < _555.d0)
    goto _jump1175;
    fail_assertion("index too large");
    _jump1175:;
    if (_562 >= 0)
    goto _jump1176;
    fail_assertion("negative array index");
    _jump1176:;
    if (_562 < _555.d1)
    goto _jump1177;
    fail_assertion("index too large");
    _jump1177:;
    int64_t _563 = 0;
    _563 *= _555.d0;
    _563 += _561;
    _563 *= _555.d1;
    _563 += _562;
    double _564 = _555.data[_563];
    double _565;
    // Computing bound for m
    int64_t _566 = 580;
    int64_t _567 = _566 - _338.d0;
    if (_567 > 0) 
    goto _jump1178;
    fail_assertion("non-positive loop bound");
    _jump1178:;
    // Computing bound for n
    if (_338.d0 > 0) 
    goto _jump1179;
    fail_assertion("non-positive loop bound");
    _jump1179:;
    // Computing bound for o
    int64_t _568 = 519;
    if (_568 > 0) 
    goto _jump1180;
    fail_assertion("non-positive loop bound");
    _jump1180:;
    _565 = 0;
    int64_t _569 = 0; // o
    int64_t _570 = 0; // n
    int64_t _571 = 0; // m
    _jump1181:; // Begin body of loop
    _565 += _535;
    _569++;
    if (_569 < _568)
    goto _jump1181;
    _569 = 0;
    _570++;
    if (_570 < _338.d0)
    goto _jump1181;
    _570 = 0;
    _571++;
    if (_571 < _567)
    goto _jump1181;
    // End body of loop
    bool _572 = _564 != _565;
    int64_t _573;
    if (!_572)
    goto _jump1182;
    _a1_int64_t _574;
    _574.d0 = 1;
    _574.data = jpl_alloc(sizeof(int64_t) * 1);
    _574.data[0] = _338.d0;
    if (_338.d0 >= 0)
    goto _jump1183;
    fail_assertion("negative array index");
    _jump1183:;
    if (_338.d0 < _574.d0)
    goto _jump1184;
    fail_assertion("index too large");
    _jump1184:;
    int64_t _575 = 0;
    _575 *= _574.d0;
    _575 += _338.d0;
    int64_t _576 = _574.data[_575];
    _573 = _576;
    goto _jump1185;
    _jump1182:;
    bool _577 = _421;
    if (0 != _421)
    goto _jump1186;
    _577 = _421;
    _jump1186:;
    int64_t _578;
    if (!_577)
    goto _jump1187;
    _578 = _338.d0;
    goto _jump1188;
    _jump1187:;
    _578 = _338.d0;
    _jump1188:;
    int64_t _579 = -_578;
    _573 = _579;
    _jump1185:;
    int64_t _580 = _554 / _573;
    _539.d0 = _580;
    if (_580 > 0) 
    goto _jump1189;
    fail_assertion("non-positive loop bound");
    _jump1189:;
    // Computing bound for n
    _a2_int64_t _581;
    // Computing bound for m
    _581.d0 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1190;
    fail_assertion("non-positive loop bound");
    _jump1190:;
    // Computing bound for n
    int64_t _582;
    // Computing bound for m
    int64_t _583 = 744;
    if (_583 > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    _582 = 0;
    int64_t _584 = 0; // m
    _jump1192:; // Begin body of loop
    int64_t _585 = 118;
    _582 += _585;
    _584++;
    if (_584 < _583)
    goto _jump1192;
    // End body of loop
    _581.d1 = _582;
    if (_582 > 0) 
    goto _jump1193;
    fail_assertion("non-positive loop bound");
    _jump1193:;
    // Computing total size of heap memory to allocate
    int64_t _586 = 1;
    _586 *= _338.d0;
    _586 *= _582;
    _586 *= sizeof(int64_t);
    _581.data = jpl_alloc(_586);
    int64_t _587 = 0; // n
    int64_t _588 = 0; // m
    _jump1194:; // Begin body of loop
    bool _590 = l();
    bool _589 = _590;
    if (0 != _590)
    goto _jump1195;
    bool _591 = false;
    _589 = _591;
    _jump1195:;
    bool _592;
    if (!_589)
    goto _jump1196;
    bool _593 = true;
    _592 = _593;
    goto _jump1197;
    _jump1196:;
    _592 = _421;
    _jump1197:;
    int64_t _594;
    if (!_592)
    goto _jump1198;
    int64_t _595 = 590;
    _594 = _595;
    goto _jump1199;
    _jump1198:;
    int64_t _596 = -_588;
    int64_t _597 = -_596;
    _594 = _597;
    _jump1199:;
    int64_t _598 = 0;
    _598 *= _581.d0;
    _598 += _588;
    _598 *= _581.d1;
    _598 += _587;
    _581.data[_598] = _594;
    _587++;
    if (_587 < _582)
    goto _jump1194;
    _587 = 0;
    _588++;
    if (_588 < _338.d0)
    goto _jump1194;
    // End body of loop
    bool _599 = _421;
    if (0 == _421)
    goto _jump1200;
    _599 = _421;
    _jump1200:;
    _a2_int64_t _600;
    if (!_599)
    goto _jump1201;
    _a2_int64_t _601;
    // Computing bound for m
    _601.d0 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for n
    _601.d1 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing total size of heap memory to allocate
    int64_t _602 = 1;
    _602 *= _338.d0;
    _602 *= _338.d0;
    _602 *= sizeof(int64_t);
    _601.data = jpl_alloc(_602);
    int64_t _603 = 0; // n
    int64_t _604 = 0; // m
    _jump1204:; // Begin body of loop
    int64_t _605 = 0;
    _605 *= _601.d0;
    _605 += _604;
    _605 *= _601.d1;
    _605 += _603;
    _601.data[_605] = _603;
    _603++;
    if (_603 < _338.d0)
    goto _jump1204;
    _603 = 0;
    _604++;
    if (_604 < _338.d0)
    goto _jump1204;
    // End body of loop
    _600 = _601;
    goto _jump1205;
    _jump1201:;
    _a2_int64_t _606;
    // Computing bound for m
    _606.d0 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    // Computing bound for n
    _606.d1 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1207;
    fail_assertion("non-positive loop bound");
    _jump1207:;
    // Computing total size of heap memory to allocate
    int64_t _607 = 1;
    _607 *= _338.d0;
    _607 *= _338.d0;
    _607 *= sizeof(int64_t);
    _606.data = jpl_alloc(_607);
    int64_t _608 = 0; // n
    int64_t _609 = 0; // m
    _jump1208:; // Begin body of loop
    int64_t _610 = 24;
    int64_t _611 = 0;
    _611 *= _606.d0;
    _611 += _609;
    _611 *= _606.d1;
    _611 += _608;
    _606.data[_611] = _610;
    _608++;
    if (_608 < _338.d0)
    goto _jump1208;
    _608 = 0;
    _609++;
    if (_609 < _338.d0)
    goto _jump1208;
    // End body of loop
    _600 = _606;
    _jump1205:;
    int64_t _612;
    // Computing bound for m
    int64_t _613 = 896;
    if (_613 >= 0)
    goto _jump1209;
    fail_assertion("negative array index");
    _jump1209:;
    if (_613 < _338.d0)
    goto _jump1210;
    fail_assertion("index too large");
    _jump1210:;
    int64_t _614 = 0;
    _614 *= _338.d0;
    _614 += _613;
    int64_t _615 = _338.data[_614];
    if (_615 > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing bound for n
    int64_t _616 = 156;
    if (_616 > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    _612 = 0;
    int64_t _617 = 0; // n
    int64_t _618 = 0; // m
    _jump1213:; // Begin body of loop
    int64_t _619 = 294;
    int64_t _620 = _618 * _619;
    _612 += _620;
    _617++;
    if (_617 < _616)
    goto _jump1213;
    _617 = 0;
    _618++;
    if (_618 < _615)
    goto _jump1213;
    // End body of loop
    int64_t _621 = 802;
    int64_t _622 = -_621;
    if (_612 >= 0)
    goto _jump1214;
    fail_assertion("negative array index");
    _jump1214:;
    if (_612 < _600.d0)
    goto _jump1215;
    fail_assertion("index too large");
    _jump1215:;
    if (_622 >= 0)
    goto _jump1216;
    fail_assertion("negative array index");
    _jump1216:;
    if (_622 < _600.d1)
    goto _jump1217;
    fail_assertion("index too large");
    _jump1217:;
    int64_t _623 = 0;
    _623 *= _600.d0;
    _623 += _612;
    _623 *= _600.d1;
    _623 += _622;
    int64_t _624 = _600.data[_623];
    int64_t _625;
    if (!_60)
    goto _jump1218;
    int64_t _626 = 790;
    int64_t _627 = _338.d0 - _626;
    _625 = _627;
    goto _jump1219;
    _jump1218:;
    int64_t _628;
    // Computing bound for m
    if (_338.d0 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    _628 = 0;
    int64_t _629 = 0; // m
    _jump1221:; // Begin body of loop
    int64_t _630 = 412;
    int64_t _631 = 727;
    int64_t _632 = _630 + _631;
    _628 += _632;
    _629++;
    if (_629 < _338.d0)
    goto _jump1221;
    // End body of loop
    _625 = _628;
    _jump1219:;
    int64_t _633 = _624 / _625;
    int64_t _634 = 397;
    if (_633 >= 0)
    goto _jump1222;
    fail_assertion("negative array index");
    _jump1222:;
    if (_633 < _581.d0)
    goto _jump1223;
    fail_assertion("index too large");
    _jump1223:;
    if (_634 >= 0)
    goto _jump1224;
    fail_assertion("negative array index");
    _jump1224:;
    if (_634 < _581.d1)
    goto _jump1225;
    fail_assertion("index too large");
    _jump1225:;
    int64_t _635 = 0;
    _635 *= _581.d0;
    _635 += _633;
    _635 *= _581.d1;
    _635 += _634;
    int64_t _636 = _581.data[_635];
    _539.d1 = _636;
    if (_636 > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for o
    int64_t _637 = 707;
    _539.d2 = _637;
    if (_637 > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing total size of heap memory to allocate
    int64_t _638 = 1;
    _638 *= _580;
    _638 *= _636;
    _638 *= _637;
    _638 *= sizeof(int64_t);
    _539.data = jpl_alloc(_638);
    int64_t _639 = 0; // o
    int64_t _640 = 0; // n
    int64_t _641 = 0; // m
    _jump1228:; // Begin body of loop
    int64_t _642 = 0;
    _642 *= _539.d0;
    _642 += _641;
    _642 *= _539.d1;
    _642 += _640;
    _642 *= _539.d2;
    _642 += _639;
    _539.data[_642] = _338.d0;
    _639++;
    if (_639 < _637)
    goto _jump1228;
    _639 = 0;
    _640++;
    if (_640 < _636)
    goto _jump1228;
    _640 = 0;
    _641++;
    if (_641 < _580)
    goto _jump1228;
    // End body of loop
    _538 = _539;
    goto _jump1229;
    _jump1164:;
    _a3_int64_t _643;
    // Computing bound for m
    bool _644 = l();
    double _645;
    if (!_644)
    goto _jump1230;
    double _646 = 62.0;
    _645 = _646;
    goto _jump1231;
    _jump1230:;
    double _647 = 25.0;
    _645 = _647;
    _jump1231:;
    double _648;
    if (!_60)
    goto _jump1232;
    _648 = _176;
    goto _jump1233;
    _jump1232:;
    double _649 = _535 + _535;
    _648 = _649;
    _jump1233:;
    bool _650 = _645 <= _648;
    int64_t _651;
    if (!_650)
    goto _jump1234;
    int64_t _652;
    if (!_60)
    goto _jump1235;
    int64_t _653 = -_338.d0;
    int64_t _654 = -_653;
    _652 = _654;
    goto _jump1236;
    _jump1235:;
    bool _655 = false;
    int64_t _656;
    if (!_655)
    goto _jump1237;
    int64_t _657 = 255;
    int64_t _658 = _338.d0 - _657;
    _656 = _658;
    goto _jump1238;
    _jump1237:;
    if (_338.d0 >= 0)
    goto _jump1239;
    fail_assertion("negative array index");
    _jump1239:;
    if (_338.d0 < _338.d0)
    goto _jump1240;
    fail_assertion("index too large");
    _jump1240:;
    int64_t _659 = 0;
    _659 *= _338.d0;
    _659 += _338.d0;
    int64_t _660 = _338.data[_659];
    _656 = _660;
    _jump1238:;
    _652 = _656;
    _jump1236:;
    _651 = _652;
    goto _jump1241;
    _jump1234:;
    bool _661 = l();
    bool _662;
    if (!_661)
    goto _jump1242;
    bool _663 = l();
    _662 = _663;
    goto _jump1243;
    _jump1242:;
    bool _664 = l();
    _662 = _664;
    _jump1243:;
    int64_t _665;
    if (!_662)
    goto _jump1244;
    int64_t _666;
    // Computing bound for m
    int64_t _667 = 716;
    if (_667 > 0) 
    goto _jump1245;
    fail_assertion("non-positive loop bound");
    _jump1245:;
    _666 = 0;
    int64_t _668 = 0; // m
    _jump1246:; // Begin body of loop
    _666 += _338.d0;
    _668++;
    if (_668 < _667)
    goto _jump1246;
    // End body of loop
    _665 = _666;
    goto _jump1247;
    _jump1244:;
    int64_t _669;
    if (!_60)
    goto _jump1248;
    _669 = _338.d0;
    goto _jump1249;
    _jump1248:;
    int64_t _670 = 364;
    _669 = _670;
    _jump1249:;
    _665 = _669;
    _jump1247:;
    int64_t _671 = -_665;
    _651 = _671;
    _jump1241:;
    int64_t _672;
    // Computing bound for m
    int64_t _673 = 716;
    if (_673 > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing bound for n
    int64_t _674 = 750;
    if (_674 > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    // Computing bound for o
    int64_t _675 = 509;
    int64_t _676 = -_675;
    if (_676 > 0) 
    goto _jump1252;
    fail_assertion("non-positive loop bound");
    _jump1252:;
    _672 = 0;
    int64_t _677 = 0; // o
    int64_t _678 = 0; // n
    int64_t _679 = 0; // m
    _jump1253:; // Begin body of loop
    _672 += _677;
    _677++;
    if (_677 < _676)
    goto _jump1253;
    _677 = 0;
    _678++;
    if (_678 < _674)
    goto _jump1253;
    _678 = 0;
    _679++;
    if (_679 < _673)
    goto _jump1253;
    // End body of loop
    bool _680 = l();
    bool _681;
    if (!_680)
    goto _jump1254;
    _681 = _421;
    goto _jump1255;
    _jump1254:;
    _681 = _60;
    _jump1255:;
    int64_t _682;
    if (!_681)
    goto _jump1256;
    int64_t _683 = 626;
    _682 = _683;
    goto _jump1257;
    _jump1256:;
    int64_t _684;
    if (!_421)
    goto _jump1258;
    int64_t _685 = 673;
    _684 = _685;
    goto _jump1259;
    _jump1258:;
    int64_t _686 = 481;
    _684 = _686;
    _jump1259:;
    _682 = _684;
    _jump1257:;
    int64_t _687 = _672 / _682;
    int64_t _688 = _338.d0 * _687;
    int64_t _689 = _651 / _688;
    _643.d0 = _689;
    if (_689 > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    // Computing bound for n
    int64_t _690 = 479;
    _643.d1 = _690;
    if (_690 > 0) 
    goto _jump1261;
    fail_assertion("non-positive loop bound");
    _jump1261:;
    // Computing bound for o
    int64_t _691;
    // Computing bound for m
    int64_t _692;
    if (!_421)
    goto _jump1262;
    bool _693 = false;
    int64_t _694;
    if (!_693)
    goto _jump1263;
    bool _695 = false;
    int64_t _696;
    if (!_695)
    goto _jump1264;
    _696 = _338.d0;
    goto _jump1265;
    _jump1264:;
    _696 = _338.d0;
    _jump1265:;
    _694 = _696;
    goto _jump1266;
    _jump1263:;
    _694 = _338.d0;
    _jump1266:;
    _692 = _694;
    goto _jump1267;
    _jump1262:;
    int64_t _697;
    // Computing bound for m
    int64_t _698 = 317;
    int64_t _699 = _338.d0 + _698;
    if (_699 > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    _697 = 0;
    int64_t _700 = 0; // m
    _jump1269:; // Begin body of loop
    int64_t _701;
    // Computing bound for n
    int64_t _702 = 670;
    if (_702 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    _701 = 0;
    int64_t _703 = 0; // n
    _jump1271:; // Begin body of loop
    _701 += _700;
    _703++;
    if (_703 < _702)
    goto _jump1271;
    // End body of loop
    _697 += _701;
    _700++;
    if (_700 < _699)
    goto _jump1269;
    // End body of loop
    _692 = _697;
    _jump1267:;
    if (_692 > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    _691 = 0;
    int64_t _704 = 0; // m
    _jump1273:; // Begin body of loop
    _691 += _704;
    _704++;
    if (_704 < _692)
    goto _jump1273;
    // End body of loop
    int64_t _705 = _691 * _338.d0;
    _643.d2 = _705;
    if (_705 > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    // Computing total size of heap memory to allocate
    int64_t _706 = 1;
    _706 *= _689;
    _706 *= _690;
    _706 *= _705;
    _706 *= sizeof(int64_t);
    _643.data = jpl_alloc(_706);
    int64_t _707 = 0; // o
    int64_t _708 = 0; // n
    int64_t _709 = 0; // m
    _jump1275:; // Begin body of loop
    int64_t _710 = 503;
    int64_t _711 = 0;
    _711 *= _643.d0;
    _711 += _709;
    _711 *= _643.d1;
    _711 += _708;
    _711 *= _643.d2;
    _711 += _707;
    _643.data[_711] = _710;
    _707++;
    if (_707 < _705)
    goto _jump1275;
    _707 = 0;
    _708++;
    if (_708 < _690)
    goto _jump1275;
    _708 = 0;
    _709++;
    if (_709 < _689)
    goto _jump1275;
    // End body of loop
    _538 = _643;
    _jump1229:;
    bool _712 = _538.d2 <= _538.d1;
    if (0 != _712)
    goto _jump1276;
    fail_assertion("q");
    _jump1276:;
    _a3__a1_rgba _713;
    // Computing bound for q
    _713.d0 = _538.d2;
    if (_538.d2 > 0) 
    goto _jump1277;
    fail_assertion("non-positive loop bound");
    _jump1277:;
    // Computing bound for r
    _713.d1 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing bound for s
    double _714 = -_176;
    bool _715 = _714 == _176;
    bool _716;
    if (!_715)
    goto _jump1279;
    bool _717 = l();
    _716 = _717;
    goto _jump1280;
    _jump1279:;
    bool _718 = l();
    bool _719 = _718 == _60;
    _716 = _719;
    _jump1280:;
    _a2_int64_t _720;
    if (!_716)
    goto _jump1281;
    _a1__a2_int64_t _721;
    // Computing bound for q
    int64_t _722 = _538.d1 % _538.d1;
    _721.d0 = _722;
    if (_722 > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing total size of heap memory to allocate
    int64_t _723 = 1;
    _723 *= _722;
    _723 *= sizeof(_a2_int64_t);
    _721.data = jpl_alloc(_723);
    int64_t _724 = 0; // q
    _jump1283:; // Begin body of loop
    _a2_int64_t _725;
    // Computing bound for r
    _725.d0 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing bound for s
    _725.d1 = _724;
    if (_724 > 0) 
    goto _jump1285;
    fail_assertion("non-positive loop bound");
    _jump1285:;
    // Computing total size of heap memory to allocate
    int64_t _726 = 1;
    _726 *= _338.d0;
    _726 *= _724;
    _726 *= sizeof(int64_t);
    _725.data = jpl_alloc(_726);
    int64_t _727 = 0; // s
    int64_t _728 = 0; // r
    _jump1286:; // Begin body of loop
    int64_t _729 = 0;
    _729 *= _725.d0;
    _729 += _728;
    _729 *= _725.d1;
    _729 += _727;
    _725.data[_729] = _728;
    _727++;
    if (_727 < _724)
    goto _jump1286;
    _727 = 0;
    _728++;
    if (_728 < _338.d0)
    goto _jump1286;
    // End body of loop
    int64_t _730 = 0;
    _730 *= _721.d0;
    _730 += _724;
    _721.data[_730] = _725;
    _724++;
    if (_724 < _722)
    goto _jump1283;
    // End body of loop
    int64_t _731 = 777;
    int64_t _732 = -_731;
    if (_732 >= 0)
    goto _jump1287;
    fail_assertion("negative array index");
    _jump1287:;
    if (_732 < _721.d0)
    goto _jump1288;
    fail_assertion("index too large");
    _jump1288:;
    int64_t _733 = 0;
    _733 *= _721.d0;
    _733 += _732;
    _a2_int64_t _734 = _721.data[_733];
    _720 = _734;
    goto _jump1289;
    _jump1281:;
    _a2_int64_t _735;
    // Computing bound for q
    int64_t _736;
    // Computing bound for q
    bool _737 = l();
    int64_t _738;
    if (!_737)
    goto _jump1290;
    _738 = _538.d2;
    goto _jump1291;
    _jump1290:;
    _738 = _538.d0;
    _jump1291:;
    if (_738 > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing bound for r
    bool _739 = l();
    int64_t _740;
    if (!_739)
    goto _jump1293;
    _740 = _538.d2;
    goto _jump1294;
    _jump1293:;
    _740 = _538.d2;
    _jump1294:;
    if (_740 > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    _736 = 0;
    int64_t _741 = 0; // r
    int64_t _742 = 0; // q
    _jump1296:; // Begin body of loop
    _736 += _742;
    _741++;
    if (_741 < _740)
    goto _jump1296;
    _741 = 0;
    _742++;
    if (_742 < _738)
    goto _jump1296;
    // End body of loop
    _735.d0 = _736;
    if (_736 > 0) 
    goto _jump1297;
    fail_assertion("non-positive loop bound");
    _jump1297:;
    // Computing bound for r
    int64_t _743 = _338.d0 * _538.d0;
    _735.d1 = _743;
    if (_743 > 0) 
    goto _jump1298;
    fail_assertion("non-positive loop bound");
    _jump1298:;
    // Computing total size of heap memory to allocate
    int64_t _744 = 1;
    _744 *= _736;
    _744 *= _743;
    _744 *= sizeof(int64_t);
    _735.data = jpl_alloc(_744);
    int64_t _745 = 0; // r
    int64_t _746 = 0; // q
    _jump1299:; // Begin body of loop
    int64_t _747 = 726;
    bool _748 = _747 != _338.d0;
    int64_t _749;
    if (!_748)
    goto _jump1300;
    _749 = _745;
    goto _jump1301;
    _jump1300:;
    _749 = _745;
    _jump1301:;
    int64_t _750 = 0;
    _750 *= _735.d0;
    _750 += _746;
    _750 *= _735.d1;
    _750 += _745;
    _735.data[_750] = _749;
    _745++;
    if (_745 < _743)
    goto _jump1299;
    _745 = 0;
    _746++;
    if (_746 < _736)
    goto _jump1299;
    // End body of loop
    _720 = _735;
    _jump1289:;
    bool _751 = _60;
    if (0 != _60)
    goto _jump1302;
    _751 = _421;
    _jump1302:;
    _a3_int64_t _752;
    if (!_751)
    goto _jump1303;
    _a3_int64_t _753;
    // Computing bound for q
    _753.d0 = _538.d1;
    if (_538.d1 > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    // Computing bound for r
    if (_538.d2 >= 0)
    goto _jump1305;
    fail_assertion("negative array index");
    _jump1305:;
    if (_538.d2 < _338.d0)
    goto _jump1306;
    fail_assertion("index too large");
    _jump1306:;
    int64_t _754 = 0;
    _754 *= _338.d0;
    _754 += _538.d2;
    int64_t _755 = _338.data[_754];
    _753.d1 = _755;
    if (_755 > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing bound for s
    _753.d2 = _538.d2;
    if (_538.d2 > 0) 
    goto _jump1308;
    fail_assertion("non-positive loop bound");
    _jump1308:;
    // Computing total size of heap memory to allocate
    int64_t _756 = 1;
    _756 *= _538.d1;
    _756 *= _755;
    _756 *= _538.d2;
    _756 *= sizeof(int64_t);
    _753.data = jpl_alloc(_756);
    int64_t _757 = 0; // s
    int64_t _758 = 0; // r
    int64_t _759 = 0; // q
    _jump1309:; // Begin body of loop
    int64_t _760;
    if (!_60)
    goto _jump1310;
    int64_t _761 = 289;
    _760 = _761;
    goto _jump1311;
    _jump1310:;
    _760 = _759;
    _jump1311:;
    int64_t _762 = 0;
    _762 *= _753.d0;
    _762 += _759;
    _762 *= _753.d1;
    _762 += _758;
    _762 *= _753.d2;
    _762 += _757;
    _753.data[_762] = _760;
    _757++;
    if (_757 < _538.d2)
    goto _jump1309;
    _757 = 0;
    _758++;
    if (_758 < _755)
    goto _jump1309;
    _758 = 0;
    _759++;
    if (_759 < _538.d1)
    goto _jump1309;
    // End body of loop
    _752 = _753;
    goto _jump1312;
    _jump1303:;
    _752 = _538;
    _jump1312:;
    if (_338.d0 >= 0)
    goto _jump1313;
    fail_assertion("negative array index");
    _jump1313:;
    if (_338.d0 < _752.d0)
    goto _jump1314;
    fail_assertion("index too large");
    _jump1314:;
    if (_538.d0 >= 0)
    goto _jump1315;
    fail_assertion("negative array index");
    _jump1315:;
    if (_538.d0 < _752.d1)
    goto _jump1316;
    fail_assertion("index too large");
    _jump1316:;
    if (_538.d1 >= 0)
    goto _jump1317;
    fail_assertion("negative array index");
    _jump1317:;
    if (_538.d1 < _752.d2)
    goto _jump1318;
    fail_assertion("index too large");
    _jump1318:;
    int64_t _763 = 0;
    _763 *= _752.d0;
    _763 += _338.d0;
    _763 *= _752.d1;
    _763 += _538.d0;
    _763 *= _752.d2;
    _763 += _538.d1;
    int64_t _764 = _752.data[_763];
    if (_764 >= 0)
    goto _jump1319;
    fail_assertion("negative array index");
    _jump1319:;
    if (_764 < _720.d0)
    goto _jump1320;
    fail_assertion("index too large");
    _jump1320:;
    if (_538.d2 >= 0)
    goto _jump1321;
    fail_assertion("negative array index");
    _jump1321:;
    if (_538.d2 < _720.d1)
    goto _jump1322;
    fail_assertion("index too large");
    _jump1322:;
    int64_t _765 = 0;
    _765 *= _720.d0;
    _765 += _764;
    _765 *= _720.d1;
    _765 += _538.d2;
    int64_t _766 = _720.data[_765];
    int64_t _767 = _766 / _338.d0;
    _713.d2 = _767;
    if (_767 > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    // Computing total size of heap memory to allocate
    int64_t _768 = 1;
    _768 *= _538.d2;
    _768 *= _338.d0;
    _768 *= _767;
    _768 *= sizeof(_a1_rgba);
    _713.data = jpl_alloc(_768);
    int64_t _769 = 0; // s
    int64_t _770 = 0; // r
    int64_t _771 = 0; // q
    _jump1324:; // Begin body of loop
    _a1_rgba _772;
    // Computing bound for t
    _772.d0 = _538.d0;
    if (_538.d0 > 0) 
    goto _jump1325;
    fail_assertion("non-positive loop bound");
    _jump1325:;
    // Computing total size of heap memory to allocate
    int64_t _773 = 1;
    _773 *= _538.d0;
    _773 *= sizeof(rgba);
    _772.data = jpl_alloc(_773);
    int64_t _774 = 0; // t
    _jump1326:; // Begin body of loop
    double _775 = -_176;
    double _776;
    // Computing bound for u
    int64_t _777 = _538.d1 % _771;
    if (_777 > 0) 
    goto _jump1327;
    fail_assertion("non-positive loop bound");
    _jump1327:;
    _776 = 0;
    int64_t _778 = 0; // u
    _jump1328:; // Begin body of loop
    _776 += _535;
    _778++;
    if (_778 < _777)
    goto _jump1328;
    // End body of loop
    double _779;
    if (!_60)
    goto _jump1329;
    double _780 = 84.0;
    _779 = _780;
    goto _jump1330;
    _jump1329:;
    double _781 = 25.0;
    _779 = _781;
    _jump1330:;
    double _782 = -_779;
    double _783;
    // Computing bound for u
    if (_538.d0 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    // Computing bound for v
    if (_771 > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    // Computing bound for w
    int64_t _784 = 77;
    int64_t _785 = -_784;
    if (_785 > 0) 
    goto _jump1333;
    fail_assertion("non-positive loop bound");
    _jump1333:;
    _783 = 0;
    int64_t _786 = 0; // w
    int64_t _787 = 0; // v
    int64_t _788 = 0; // u
    _jump1334:; // Begin body of loop
    double _789 = 60.0;
    _783 += _789;
    _786++;
    if (_786 < _785)
    goto _jump1334;
    _786 = 0;
    _787++;
    if (_787 < _771)
    goto _jump1334;
    _787 = 0;
    _788++;
    if (_788 < _538.d0)
    goto _jump1334;
    // End body of loop
    rgba _790 = { _776, _782, _783, _535 };
    double _791 = _790.r;
    rgba _792 = { _775, _176, _176, _791 };
    int64_t _793 = 0;
    _793 *= _772.d0;
    _793 += _774;
    _772.data[_793] = _792;
    _774++;
    if (_774 < _538.d0)
    goto _jump1326;
    // End body of loop
    int64_t _794 = 0;
    _794 *= _713.d0;
    _794 += _771;
    _794 *= _713.d1;
    _794 += _770;
    _794 *= _713.d2;
    _794 += _769;
    _713.data[_794] = _772;
    _769++;
    if (_769 < _767)
    goto _jump1324;
    _769 = 0;
    _770++;
    if (_770 < _338.d0)
    goto _jump1324;
    _770 = 0;
    _771++;
    if (_771 < _538.d2)
    goto _jump1324;
    // End body of loop
    _a2__a3_int64_t _795;
    // Computing bound for B
    _795.d0 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    // Computing bound for C
    _795.d1 = _713.d2;
    if (_713.d2 > 0) 
    goto _jump1336;
    fail_assertion("non-positive loop bound");
    _jump1336:;
    // Computing total size of heap memory to allocate
    int64_t _796 = 1;
    _796 *= _338.d0;
    _796 *= _713.d2;
    _796 *= sizeof(_a3_int64_t);
    _795.data = jpl_alloc(_796);
    int64_t _797 = 0; // C
    int64_t _798 = 0; // B
    _jump1337:; // Begin body of loop
    int64_t _799 = 0;
    _799 *= _795.d0;
    _799 += _798;
    _799 *= _795.d1;
    _799 += _797;
    _795.data[_799] = _538;
    _797++;
    if (_797 < _713.d2)
    goto _jump1337;
    _797 = 0;
    _798++;
    if (_798 < _338.d0)
    goto _jump1337;
    // End body of loop
    if (_338.d0 >= 0)
    goto _jump1338;
    fail_assertion("negative array index");
    _jump1338:;
    if (_338.d0 < _795.d0)
    goto _jump1339;
    fail_assertion("index too large");
    _jump1339:;
    if (_713.d2 >= 0)
    goto _jump1340;
    fail_assertion("negative array index");
    _jump1340:;
    if (_713.d2 < _795.d1)
    goto _jump1341;
    fail_assertion("index too large");
    _jump1341:;
    int64_t _800 = 0;
    _800 *= _795.d0;
    _800 += _338.d0;
    _800 *= _795.d1;
    _800 += _713.d2;
    _a3_int64_t _801 = _795.data[_800];
    int64_t _802 = _801.d2 % _538.d2;
    int64_t _803 = -_802;
    bool _804 = _538.d0 != _803;
    if (0 != _804)
    goto _jump1348;
    fail_assertion("G");
    _jump1348:;
    _a1_int64_t _805;
    // Computing bound for G
    _805.d0 = _338.d0;
    if (_338.d0 > 0) 
    goto _jump1349;
    fail_assertion("non-positive loop bound");
    _jump1349:;
    // Computing total size of heap memory to allocate
    int64_t _806 = 1;
    _806 *= _338.d0;
    _806 *= sizeof(int64_t);
    _805.data = jpl_alloc(_806);
    int64_t _807 = 0; // G
    _jump1350:; // Begin body of loop
    int64_t _808 = 0;
    _808 *= _805.d0;
    _808 += _807;
    _805.data[_808] = _338.d0;
    _807++;
    if (_807 < _338.d0)
    goto _jump1350;
    // End body of loop
    bool _809 = false;
}

