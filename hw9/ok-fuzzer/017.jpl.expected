
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  _a1__a2_bool *data;
} _a1__a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_int64_t *data;
} _a3__a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_double *data;
} _a3__a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_int64_t *data;
} _a3__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3__a3_int64_t *data;
} _a1__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1__a2_bool *data;
} _a3__a1__a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_int64_t *data;
} _a3__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_void_t *data;
} _a2__a2_void_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  _a1_void_t *data;
} _a1__a1_void_t;

typedef struct {
    double a;
} p;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  p *data;
} _a2_p;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  p *data;
} _a3_p;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1__a2_bool *data;
} _a2__a1__a1__a2_bool;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3__a2_rgba *data;
} _a1__a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
    _a3_void_t a;
    bool b;
    rgba c;
} C;

typedef struct {
  int64_t d0;
  p *data;
} _a1_p;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  _a1_p *data;
} _a1__a1_p;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_p *data;
} _a3__a1_p;

typedef struct {
  int64_t d0;
  C *data;
} _a1_C;

typedef struct {
  int64_t d0;
  int64_t d1;
  C *data;
} _a2_C;

rgba e(_a3_double f, _a1_bool j) {
    _a1_int64_t _0;
    // Computing bound for l
    int64_t _1;
    // Computing bound for l
    if (f.d0 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    _1 = 0;
    int64_t _2 = 0; // l
    _jump342:; // Begin body of loop
    bool _3 = true;
    int64_t _4;
    if (!_3)
    goto _jump343;
    _4 = j.d0;
    goto _jump344;
    _jump343:;
    _4 = f.d2;
    _jump344:;
    int64_t _5 = -_4;
    _1 += _5;
    _2++;
    if (_2 < f.d0)
    goto _jump342;
    // End body of loop
    int64_t _6 = j.d0 - _1;
    _0.d0 = _6;
    if (_6 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= _6;
    _7 *= sizeof(int64_t);
    _0.data = jpl_alloc(_7);
    int64_t _8 = 0; // l
    _jump346:; // Begin body of loop
    int64_t _9 = 0;
    _9 *= _0.d0;
    _9 += _8;
    _0.data[_9] = f.d0;
    _8++;
    if (_8 < _6)
    goto _jump346;
    // End body of loop
    _a1__a1_int64_t _10;
    _10.d0 = 1;
    _10.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _10.data[0] = _0;
    if (c >= 0)
    goto _jump347;
    fail_assertion("negative array index");
    _jump347:;
    if (c < _10.d0)
    goto _jump348;
    fail_assertion("index too large");
    _jump348:;
    int64_t _11 = 0;
    _11 *= _10.d0;
    _11 += c;
    _a1_int64_t _12 = _10.data[_11];
    _a3_int64_t _13;
    // Computing bound for n
    _13.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing bound for o
    int64_t _14 = -f.d1;
    _13.d1 = _14;
    if (_14 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for p
    _13.d2 = _12.d0;
    if (_12.d0 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= f.d0;
    _15 *= _14;
    _15 *= _12.d0;
    _15 *= sizeof(int64_t);
    _13.data = jpl_alloc(_15);
    int64_t _16 = 0; // p
    int64_t _17 = 0; // o
    int64_t _18 = 0; // n
    _jump352:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _13.d0;
    _19 += _18;
    _19 *= _13.d1;
    _19 += _17;
    _19 *= _13.d2;
    _19 += _16;
    _13.data[_19] = f.d2;
    _16++;
    if (_16 < _12.d0)
    goto _jump352;
    _16 = 0;
    _17++;
    if (_17 < _14)
    goto _jump352;
    _17 = 0;
    _18++;
    if (_18 < f.d0)
    goto _jump352;
    // End body of loop
    bool _21 = true;
    bool _20 = _21;
    if (0 != _21)
    goto _jump353;
    bool _22 = d > f.d0;
    _20 = _22;
    _jump353:;
    double _23;
    if (!_20)
    goto _jump354;
    rgba _24 = e(f, j);
    double _25 = _24.b;
    _a1_double _26;
    // Computing bound for r
    int64_t _27 = 708;
    _26.d0 = _27;
    if (_27 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing total size of heap memory to allocate
    int64_t _28 = 1;
    _28 *= _27;
    _28 *= sizeof(double);
    _26.data = jpl_alloc(_28);
    int64_t _29 = 0; // r
    _jump356:; // Begin body of loop
    double _30 = 37.0;
    int64_t _31 = 0;
    _31 *= _26.d0;
    _31 += _29;
    _26.data[_31] = _30;
    _29++;
    if (_29 < _27)
    goto _jump356;
    // End body of loop
    if (f.d1 >= 0)
    goto _jump357;
    fail_assertion("negative array index");
    _jump357:;
    if (f.d1 < _26.d0)
    goto _jump358;
    fail_assertion("index too large");
    _jump358:;
    int64_t _32 = 0;
    _32 *= _26.d0;
    _32 += f.d1;
    double _33 = _26.data[_32];
    double _34 = 50.0;
    double _35 = 17.0;
    double _36 = 86.0;
    double _37 = 42.0;
    rgba _38 = { _34, _35, _36, _37 };
    double _39 = _38.a;
    double _40 = 60.0;
    rgba _41 = { _25, _33, _39, _40 };
    double _42 = _41.a;
    _23 = _42;
    goto _jump359;
    _jump354:;
    bool _43 = false;
    bool _44 = !_43;
    double _45;
    if (!_44)
    goto _jump360;
    double _46;
    // Computing bound for r
    if (d > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    // Computing bound for s
    if (_13.d1 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing bound for t
    if (_13.d2 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    _46 = 0;
    int64_t _47 = 0; // t
    int64_t _48 = 0; // s
    int64_t _49 = 0; // r
    _jump364:; // Begin body of loop
    double _50;
    // Computing bound for u
    if (f.d0 > 0) 
    goto _jump365;
    fail_assertion("non-positive loop bound");
    _jump365:;
    _50 = 0;
    int64_t _51 = 0; // u
    _jump366:; // Begin body of loop
    double _52 = 96.0;
    _50 += _52;
    _51++;
    if (_51 < f.d0)
    goto _jump366;
    // End body of loop
    _46 += _50;
    _47++;
    if (_47 < _13.d2)
    goto _jump364;
    _47 = 0;
    _48++;
    if (_48 < _13.d1)
    goto _jump364;
    _48 = 0;
    _49++;
    if (_49 < d)
    goto _jump364;
    // End body of loop
    double _53 = -_46;
    _45 = _53;
    goto _jump367;
    _jump360:;
    double _54;
    // Computing bound for r
    int64_t _55;
    // Computing bound for r
    if (b > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    // Computing bound for s
    if (_13.d1 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    // Computing bound for t
    if (_12.d0 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    _55 = 0;
    int64_t _56 = 0; // t
    int64_t _57 = 0; // s
    int64_t _58 = 0; // r
    _jump371:; // Begin body of loop
    _55 += _57;
    _56++;
    if (_56 < _12.d0)
    goto _jump371;
    _56 = 0;
    _57++;
    if (_57 < _13.d1)
    goto _jump371;
    _57 = 0;
    _58++;
    if (_58 < b)
    goto _jump371;
    // End body of loop
    if (_55 >= 0)
    goto _jump372;
    fail_assertion("negative array index");
    _jump372:;
    if (_55 < _13.d0)
    goto _jump373;
    fail_assertion("index too large");
    _jump373:;
    if (_13.d1 >= 0)
    goto _jump374;
    fail_assertion("negative array index");
    _jump374:;
    if (_13.d1 < _13.d1)
    goto _jump375;
    fail_assertion("index too large");
    _jump375:;
    if (c >= 0)
    goto _jump376;
    fail_assertion("negative array index");
    _jump376:;
    if (c < _13.d2)
    goto _jump377;
    fail_assertion("index too large");
    _jump377:;
    int64_t _59 = 0;
    _59 *= _13.d0;
    _59 += _55;
    _59 *= _13.d1;
    _59 += _13.d1;
    _59 *= _13.d2;
    _59 += c;
    int64_t _60 = _13.data[_59];
    if (_60 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing bound for s
    int64_t _61 = -j.d0;
    if (_61 > 0) 
    goto _jump379;
    fail_assertion("non-positive loop bound");
    _jump379:;
    // Computing bound for t
    bool _63 = false;
    bool _62 = _63;
    if (0 != _63)
    goto _jump380;
    bool _64 = false;
    _62 = _64;
    _jump380:;
    int64_t _65;
    if (!_62)
    goto _jump381;
    int64_t _66;
    // Computing bound for r
    if (j.d0 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for s
    if (c > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing bound for t
    if (c > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    _66 = 0;
    int64_t _67 = 0; // t
    int64_t _68 = 0; // s
    int64_t _69 = 0; // r
    _jump385:; // Begin body of loop
    _66 += f.d0;
    _67++;
    if (_67 < c)
    goto _jump385;
    _67 = 0;
    _68++;
    if (_68 < c)
    goto _jump385;
    _68 = 0;
    _69++;
    if (_69 < j.d0)
    goto _jump385;
    // End body of loop
    _65 = _66;
    goto _jump386;
    _jump381:;
    _65 = f.d0;
    _jump386:;
    if (_65 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    _54 = 0;
    int64_t _70 = 0; // t
    int64_t _71 = 0; // s
    int64_t _72 = 0; // r
    _jump388:; // Begin body of loop
    double _73 = 97.0;
    double _74 = -_73;
    _54 += _74;
    _70++;
    if (_70 < _65)
    goto _jump388;
    _70 = 0;
    _71++;
    if (_71 < _61)
    goto _jump388;
    _71 = 0;
    _72++;
    if (_72 < _60)
    goto _jump388;
    // End body of loop
    _45 = _54;
    _jump367:;
    _23 = _45;
    _jump359:;
    bool _76 = true;
    bool _75 = _76;
    if (0 == _76)
    goto _jump389;
    bool _77 = f.d0 != c;
    _75 = _77;
    _jump389:;
    _a3_double _78;
    if (!_75)
    goto _jump390;
    _78 = f;
    goto _jump391;
    _jump390:;
    _a3_double _79;
    // Computing bound for r
    _79.d0 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing bound for s
    _79.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing bound for t
    _79.d2 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= _13.d0;
    _80 *= j.d0;
    _80 *= _13.d0;
    _80 *= sizeof(double);
    _79.data = jpl_alloc(_80);
    int64_t _81 = 0; // t
    int64_t _82 = 0; // s
    int64_t _83 = 0; // r
    _jump395:; // Begin body of loop
    double _84 = 64.0;
    int64_t _85 = 0;
    _85 *= _79.d0;
    _85 += _83;
    _85 *= _79.d1;
    _85 += _82;
    _85 *= _79.d2;
    _85 += _81;
    _79.data[_85] = _84;
    _81++;
    if (_81 < _13.d0)
    goto _jump395;
    _81 = 0;
    _82++;
    if (_82 < j.d0)
    goto _jump395;
    _82 = 0;
    _83++;
    if (_83 < _13.d0)
    goto _jump395;
    // End body of loop
    _78 = _79;
    _jump391:;
    bool _86 = f.d0 <= f.d0;
    double _87 = 55.0;
    double _88 = 44.0;
    bool _89 = _87 < _88;
    bool _90 = _86 == _89;
    bool _91 = f.d0 > f.d0;
    _a1_bool _92;
    _92.d0 = 2;
    _92.data = jpl_alloc(sizeof(bool) * 2);
    _92.data[0] = _90;
    _92.data[1] = _91;
    rgba _93 = e(_78, _92);
    double _94 = _93.g;
    double _95 = _23 - _94;
    bool _96 = b == f.d0;
    double _97;
    if (!_96)
    goto _jump396;
    _a1_rgba _98;
    // Computing bound for r
    _98.d0 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= _13.d0;
    _99 *= sizeof(rgba);
    _98.data = jpl_alloc(_99);
    int64_t _100 = 0; // r
    _jump398:; // Begin body of loop
    bool _101 = false;
    _a3_double _102;
    if (!_101)
    goto _jump399;
    _102 = f;
    goto _jump400;
    _jump399:;
    _102 = f;
    _jump400:;
    _a1_bool _103;
    // Computing bound for s
    _103.d0 = _12.d0;
    if (_12.d0 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= _12.d0;
    _104 *= sizeof(bool);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // s
    _jump402:; // Begin body of loop
    bool _106 = true;
    int64_t _107 = 0;
    _107 *= _103.d0;
    _107 += _105;
    _103.data[_107] = _106;
    _105++;
    if (_105 < _12.d0)
    goto _jump402;
    // End body of loop
    rgba _108 = e(_102, _103);
    int64_t _109 = 0;
    _109 *= _98.d0;
    _109 += _100;
    _98.data[_109] = _108;
    _100++;
    if (_100 < _13.d0)
    goto _jump398;
    // End body of loop
    int64_t _110;
    // Computing bound for r
    if (f.d2 > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    _110 = 0;
    int64_t _111 = 0; // r
    _jump404:; // Begin body of loop
    _110 += j.d0;
    _111++;
    if (_111 < f.d2)
    goto _jump404;
    // End body of loop
    if (_110 >= 0)
    goto _jump405;
    fail_assertion("negative array index");
    _jump405:;
    if (_110 < _98.d0)
    goto _jump406;
    fail_assertion("index too large");
    _jump406:;
    int64_t _112 = 0;
    _112 *= _98.d0;
    _112 += _110;
    rgba _113 = _98.data[_112];
    double _114 = _113.b;
    _97 = _114;
    goto _jump407;
    _jump396:;
    double _115;
    // Computing bound for r
    if (d > 0) 
    goto _jump408;
    fail_assertion("non-positive loop bound");
    _jump408:;
    // Computing bound for s
    bool _116 = false;
    int64_t _117;
    if (!_116)
    goto _jump409;
    _117 = f.d2;
    goto _jump410;
    _jump409:;
    _117 = f.d0;
    _jump410:;
    if (_117 > 0) 
    goto _jump411;
    fail_assertion("non-positive loop bound");
    _jump411:;
    _115 = 0;
    int64_t _118 = 0; // s
    int64_t _119 = 0; // r
    _jump412:; // Begin body of loop
    double _120 = 16.0;
    double _121 = 82.0;
    double _122 = _120 / _121;
    _115 += _122;
    _118++;
    if (_118 < _117)
    goto _jump412;
    _118 = 0;
    _119++;
    if (_119 < d)
    goto _jump412;
    // End body of loop
    _97 = _115;
    _jump407:;
    int64_t _123 = 900;
    bool _124 = _13.d2 != _123;
    double _125;
    if (!_124)
    goto _jump413;
    double _126 = 68.0;
    _125 = _126;
    goto _jump414;
    _jump413:;
    double _128 = 57.0;
    double _129 = 76.0;
    bool _130 = _128 != _129;
    bool _127 = _130;
    if (0 != _130)
    goto _jump415;
    bool _132 = true;
    bool _131 = _132;
    if (0 != _132)
    goto _jump416;
    bool _133 = true;
    _131 = _133;
    _jump416:;
    _127 = _131;
    _jump415:;
    _a3_double _134;
    if (!_127)
    goto _jump417;
    bool _136 = false;
    bool _135 = _136;
    if (0 != _136)
    goto _jump418;
    bool _137 = true;
    _135 = _137;
    _jump418:;
    _a3_double _138;
    if (!_135)
    goto _jump419;
    bool _139 = false;
    _a3_double _140;
    if (!_139)
    goto _jump420;
    _140 = f;
    goto _jump421;
    _jump420:;
    _140 = f;
    _jump421:;
    _138 = _140;
    goto _jump422;
    _jump419:;
    _a3_double _141;
    // Computing bound for r
    _141.d0 = f.d1;
    if (f.d1 > 0) 
    goto _jump423;
    fail_assertion("non-positive loop bound");
    _jump423:;
    // Computing bound for s
    _141.d1 = _13.d2;
    if (_13.d2 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing bound for t
    _141.d2 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= f.d1;
    _142 *= _13.d2;
    _142 *= _13.d0;
    _142 *= sizeof(double);
    _141.data = jpl_alloc(_142);
    int64_t _143 = 0; // t
    int64_t _144 = 0; // s
    int64_t _145 = 0; // r
    _jump426:; // Begin body of loop
    double _146 = 19.0;
    int64_t _147 = 0;
    _147 *= _141.d0;
    _147 += _145;
    _147 *= _141.d1;
    _147 += _144;
    _147 *= _141.d2;
    _147 += _143;
    _141.data[_147] = _146;
    _143++;
    if (_143 < _13.d0)
    goto _jump426;
    _143 = 0;
    _144++;
    if (_144 < _13.d2)
    goto _jump426;
    _144 = 0;
    _145++;
    if (_145 < f.d1)
    goto _jump426;
    // End body of loop
    _138 = _141;
    _jump422:;
    _134 = _138;
    goto _jump427;
    _jump417:;
    _134 = f;
    _jump427:;
    double _148 = 72.0;
    double _149 = 36.0;
    double _150 = 95.0;
    double _151 = _149 * _150;
    bool _152 = _148 != _151;
    _a1_bool _153;
    if (!_152)
    goto _jump428;
    _a1__a1_bool _154;
    _154.d0 = 2;
    _154.data = jpl_alloc(sizeof(_a1_bool) * 2);
    _154.data[0] = j;
    _154.data[1] = j;
    int64_t _155;
    // Computing bound for r
    if (_13.d0 > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    // Computing bound for s
    if (d > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing bound for t
    if (f.d0 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    _155 = 0;
    int64_t _156 = 0; // t
    int64_t _157 = 0; // s
    int64_t _158 = 0; // r
    _jump432:; // Begin body of loop
    _155 += _158;
    _156++;
    if (_156 < f.d0)
    goto _jump432;
    _156 = 0;
    _157++;
    if (_157 < d)
    goto _jump432;
    _157 = 0;
    _158++;
    if (_158 < _13.d0)
    goto _jump432;
    // End body of loop
    if (_155 >= 0)
    goto _jump433;
    fail_assertion("negative array index");
    _jump433:;
    if (_155 < _154.d0)
    goto _jump434;
    fail_assertion("index too large");
    _jump434:;
    int64_t _159 = 0;
    _159 *= _154.d0;
    _159 += _155;
    _a1_bool _160 = _154.data[_159];
    _153 = _160;
    goto _jump435;
    _jump428:;
    _153 = j;
    _jump435:;
    rgba _161 = e(_134, _153);
    double _162 = _161.g;
    _125 = _162;
    _jump414:;
    _a3_bool _164;
    // Computing bound for r
    _164.d0 = d;
    if (d > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing bound for s
    _164.d1 = d;
    if (d > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing bound for t
    int64_t _165 = -_13.d2;
    _164.d2 = _165;
    if (_165 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= d;
    _166 *= d;
    _166 *= _165;
    _166 *= sizeof(bool);
    _164.data = jpl_alloc(_166);
    int64_t _167 = 0; // t
    int64_t _168 = 0; // s
    int64_t _169 = 0; // r
    _jump439:; // Begin body of loop
    double _170 = 82.0;
    double _171 = 58.0;
    bool _172 = _170 < _171;
    int64_t _173 = 0;
    _173 *= _164.d0;
    _173 += _169;
    _173 *= _164.d1;
    _173 += _168;
    _173 *= _164.d2;
    _173 += _167;
    _164.data[_173] = _172;
    _167++;
    if (_167 < _165)
    goto _jump439;
    _167 = 0;
    _168++;
    if (_168 < d)
    goto _jump439;
    _168 = 0;
    _169++;
    if (_169 < d)
    goto _jump439;
    // End body of loop
    if (_13.d0 >= 0)
    goto _jump440;
    fail_assertion("negative array index");
    _jump440:;
    if (_13.d0 < _164.d0)
    goto _jump441;
    fail_assertion("index too large");
    _jump441:;
    if (_13.d2 >= 0)
    goto _jump442;
    fail_assertion("negative array index");
    _jump442:;
    if (_13.d2 < _164.d1)
    goto _jump443;
    fail_assertion("index too large");
    _jump443:;
    if (f.d0 >= 0)
    goto _jump444;
    fail_assertion("negative array index");
    _jump444:;
    if (f.d0 < _164.d2)
    goto _jump445;
    fail_assertion("index too large");
    _jump445:;
    int64_t _174 = 0;
    _174 *= _164.d0;
    _174 += _13.d0;
    _174 *= _164.d1;
    _174 += _13.d2;
    _174 *= _164.d2;
    _174 += f.d0;
    bool _175 = _164.data[_174];
    bool _163 = _175;
    if (0 == _175)
    goto _jump446;
    double _176;
    // Computing bound for r
    bool _177 = false;
    _a3_int64_t _178;
    if (!_177)
    goto _jump447;
    _178 = _13;
    goto _jump448;
    _jump447:;
    _178 = _13;
    _jump448:;
    int64_t _179 = -_13.d0;
    if (f.d0 >= 0)
    goto _jump449;
    fail_assertion("negative array index");
    _jump449:;
    if (f.d0 < _178.d0)
    goto _jump450;
    fail_assertion("index too large");
    _jump450:;
    if (_179 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (_179 < _178.d1)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    if (c >= 0)
    goto _jump453;
    fail_assertion("negative array index");
    _jump453:;
    if (c < _178.d2)
    goto _jump454;
    fail_assertion("index too large");
    _jump454:;
    int64_t _180 = 0;
    _180 *= _178.d0;
    _180 += f.d0;
    _180 *= _178.d1;
    _180 += _179;
    _180 *= _178.d2;
    _180 += c;
    int64_t _181 = _178.data[_180];
    if (_181 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for s
    int64_t _182 = 731;
    if (_12.d0 >= 0)
    goto _jump456;
    fail_assertion("negative array index");
    _jump456:;
    if (_12.d0 < _12.d0)
    goto _jump457;
    fail_assertion("index too large");
    _jump457:;
    int64_t _183 = 0;
    _183 *= _12.d0;
    _183 += _12.d0;
    int64_t _184 = _12.data[_183];
    int64_t _185 = _182 / _184;
    if (_185 > 0) 
    goto _jump458;
    fail_assertion("non-positive loop bound");
    _jump458:;
    // Computing bound for t
    if (b > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    _176 = 0;
    int64_t _186 = 0; // t
    int64_t _187 = 0; // s
    int64_t _188 = 0; // r
    _jump460:; // Begin body of loop
    double _189 = 94.0;
    double _190 = 26.0;
    double _191 = fmod(_189, _190);
    double _192 = -_191;
    _176 += _192;
    _186++;
    if (_186 < b)
    goto _jump460;
    _186 = 0;
    _187++;
    if (_187 < _185)
    goto _jump460;
    _187 = 0;
    _188++;
    if (_188 < _181)
    goto _jump460;
    // End body of loop
    double _193 = 59.0;
    bool _194 = _176 != _193;
    _163 = _194;
    _jump446:;
    double _195;
    if (!_163)
    goto _jump461;
    int64_t _196 = 831;
    if (_196 >= 0)
    goto _jump462;
    fail_assertion("negative array index");
    _jump462:;
    if (_196 < j.d0)
    goto _jump463;
    fail_assertion("index too large");
    _jump463:;
    int64_t _197 = 0;
    _197 *= j.d0;
    _197 += _196;
    bool _198 = j.data[_197];
    double _199;
    if (!_198)
    goto _jump464;
    bool _200 = true;
    _a3_double _201;
    if (!_200)
    goto _jump465;
    _201 = f;
    goto _jump466;
    _jump465:;
    _201 = f;
    _jump466:;
    if (f.d2 >= 0)
    goto _jump467;
    fail_assertion("negative array index");
    _jump467:;
    if (f.d2 < _13.d0)
    goto _jump468;
    fail_assertion("index too large");
    _jump468:;
    if (_13.d1 >= 0)
    goto _jump469;
    fail_assertion("negative array index");
    _jump469:;
    if (_13.d1 < _13.d1)
    goto _jump470;
    fail_assertion("index too large");
    _jump470:;
    if (_13.d0 >= 0)
    goto _jump471;
    fail_assertion("negative array index");
    _jump471:;
    if (_13.d0 < _13.d2)
    goto _jump472;
    fail_assertion("index too large");
    _jump472:;
    int64_t _202 = 0;
    _202 *= _13.d0;
    _202 += f.d2;
    _202 *= _13.d1;
    _202 += _13.d1;
    _202 *= _13.d2;
    _202 += _13.d0;
    int64_t _203 = _13.data[_202];
    if (d >= 0)
    goto _jump473;
    fail_assertion("negative array index");
    _jump473:;
    if (d < _201.d0)
    goto _jump474;
    fail_assertion("index too large");
    _jump474:;
    if (c >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (c < _201.d1)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    if (_203 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_203 < _201.d2)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    int64_t _204 = 0;
    _204 *= _201.d0;
    _204 += d;
    _204 *= _201.d1;
    _204 += c;
    _204 *= _201.d2;
    _204 += _203;
    double _205 = _201.data[_204];
    _199 = _205;
    goto _jump479;
    _jump464:;
    double _206 = 94.0;
    _199 = _206;
    _jump479:;
    double _207 = 85.0;
    double _208 = 87.0;
    double _209 = 63.0;
    double _210 = _208 + _209;
    double _211 = fmod(_207, _210);
    double _212 = 16.0;
    double _213 = -_212;
    double _214 = -_213;
    double _215 = _211 / _214;
    double _216 = _199 - _215;
    double _217 = -_216;
    _195 = _217;
    goto _jump480;
    _jump461:;
    _a1_double _218;
    // Computing bound for r
    int64_t _219 = -d;
    _218.d0 = _219;
    if (_219 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    // Computing total size of heap memory to allocate
    int64_t _220 = 1;
    _220 *= _219;
    _220 *= sizeof(double);
    _218.data = jpl_alloc(_220);
    int64_t _221 = 0; // r
    _jump482:; // Begin body of loop
    double _222 = 68.0;
    double _223 = 49.0;
    double _224 = _222 + _223;
    double _225 = 44.0;
    double _226 = -_225;
    bool _227 = _224 != _226;
    double _228;
    if (!_227)
    goto _jump483;
    double _229 = 75.0;
    _228 = _229;
    goto _jump484;
    _jump483:;
    if (j.d0 >= 0)
    goto _jump485;
    fail_assertion("negative array index");
    _jump485:;
    if (j.d0 < f.d0)
    goto _jump486;
    fail_assertion("index too large");
    _jump486:;
    if (f.d2 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (f.d2 < f.d1)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (b >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (b < f.d2)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _230 = 0;
    _230 *= f.d0;
    _230 += j.d0;
    _230 *= f.d1;
    _230 += f.d2;
    _230 *= f.d2;
    _230 += b;
    double _231 = f.data[_230];
    double _232 = 92.0;
    double _233 = _231 * _232;
    _228 = _233;
    _jump484:;
    int64_t _234 = 0;
    _234 *= _218.d0;
    _234 += _221;
    _218.data[_234] = _228;
    _221++;
    if (_221 < _219)
    goto _jump482;
    // End body of loop
    _a2__a3_int64_t _235;
    // Computing bound for r
    int64_t _236;
    // Computing bound for r
    if (_13.d1 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for s
    if (_13.d2 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    _236 = 0;
    int64_t _237 = 0; // s
    int64_t _238 = 0; // r
    _jump493:; // Begin body of loop
    _236 += _13.d1;
    _237++;
    if (_237 < _13.d2)
    goto _jump493;
    _237 = 0;
    _238++;
    if (_238 < _13.d1)
    goto _jump493;
    // End body of loop
    _235.d0 = _236;
    if (_236 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing bound for s
    int64_t _239 = c + j.d0;
    _235.d1 = _239;
    if (_239 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing total size of heap memory to allocate
    int64_t _240 = 1;
    _240 *= _236;
    _240 *= _239;
    _240 *= sizeof(_a3_int64_t);
    _235.data = jpl_alloc(_240);
    int64_t _241 = 0; // s
    int64_t _242 = 0; // r
    _jump496:; // Begin body of loop
    _a3_int64_t _243;
    // Computing bound for t
    _243.d0 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing bound for u
    _243.d1 = _242;
    if (_242 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing bound for v
    _243.d2 = _242;
    if (_242 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= _13.d0;
    _244 *= _242;
    _244 *= _242;
    _244 *= sizeof(int64_t);
    _243.data = jpl_alloc(_244);
    int64_t _245 = 0; // v
    int64_t _246 = 0; // u
    int64_t _247 = 0; // t
    _jump500:; // Begin body of loop
    int64_t _248 = 0;
    _248 *= _243.d0;
    _248 += _247;
    _248 *= _243.d1;
    _248 += _246;
    _248 *= _243.d2;
    _248 += _245;
    _243.data[_248] = _12.d0;
    _245++;
    if (_245 < _242)
    goto _jump500;
    _245 = 0;
    _246++;
    if (_246 < _242)
    goto _jump500;
    _246 = 0;
    _247++;
    if (_247 < _13.d0)
    goto _jump500;
    // End body of loop
    int64_t _249 = 0;
    _249 *= _235.d0;
    _249 += _242;
    _249 *= _235.d1;
    _249 += _241;
    _235.data[_249] = _243;
    _241++;
    if (_241 < _239)
    goto _jump496;
    _241 = 0;
    _242++;
    if (_242 < _236)
    goto _jump496;
    // End body of loop
    if (f.d0 >= 0)
    goto _jump501;
    fail_assertion("negative array index");
    _jump501:;
    if (f.d0 < _235.d0)
    goto _jump502;
    fail_assertion("index too large");
    _jump502:;
    if (c >= 0)
    goto _jump503;
    fail_assertion("negative array index");
    _jump503:;
    if (c < _235.d1)
    goto _jump504;
    fail_assertion("index too large");
    _jump504:;
    int64_t _250 = 0;
    _250 *= _235.d0;
    _250 += f.d0;
    _250 *= _235.d1;
    _250 += c;
    _a3_int64_t _251 = _235.data[_250];
    int64_t _252;
    // Computing bound for r
    if (_13.d0 > 0) 
    goto _jump505;
    fail_assertion("non-positive loop bound");
    _jump505:;
    // Computing bound for s
    if (f.d1 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for t
    if (_13.d1 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    _252 = 0;
    int64_t _253 = 0; // t
    int64_t _254 = 0; // s
    int64_t _255 = 0; // r
    _jump508:; // Begin body of loop
    bool _256 = false;
    int64_t _257;
    if (!_256)
    goto _jump509;
    _257 = _254;
    goto _jump510;
    _jump509:;
    _257 = f.d2;
    _jump510:;
    _252 += _257;
    _253++;
    if (_253 < _13.d1)
    goto _jump508;
    _253 = 0;
    _254++;
    if (_254 < f.d1)
    goto _jump508;
    _254 = 0;
    _255++;
    if (_255 < _13.d0)
    goto _jump508;
    // End body of loop
    if (_252 >= 0)
    goto _jump511;
    fail_assertion("negative array index");
    _jump511:;
    if (_252 < _251.d0)
    goto _jump512;
    fail_assertion("index too large");
    _jump512:;
    if (j.d0 >= 0)
    goto _jump513;
    fail_assertion("negative array index");
    _jump513:;
    if (j.d0 < _251.d1)
    goto _jump514;
    fail_assertion("index too large");
    _jump514:;
    if (b >= 0)
    goto _jump515;
    fail_assertion("negative array index");
    _jump515:;
    if (b < _251.d2)
    goto _jump516;
    fail_assertion("index too large");
    _jump516:;
    int64_t _258 = 0;
    _258 *= _251.d0;
    _258 += _252;
    _258 *= _251.d1;
    _258 += j.d0;
    _258 *= _251.d2;
    _258 += b;
    int64_t _259 = _251.data[_258];
    if (_259 >= 0)
    goto _jump517;
    fail_assertion("negative array index");
    _jump517:;
    if (_259 < _218.d0)
    goto _jump518;
    fail_assertion("index too large");
    _jump518:;
    int64_t _260 = 0;
    _260 *= _218.d0;
    _260 += _259;
    double _261 = _218.data[_260];
    _195 = _261;
    _jump480:;
    rgba _262 = { _95, _97, _125, _195 };
    double _263 = _262.r;
    _a2_bool _264;
    // Computing bound for t
    _264.d0 = b;
    if (b > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    // Computing bound for u
    int64_t _265 = j.d0 % f.d1;
    _264.d1 = _265;
    if (_265 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing total size of heap memory to allocate
    int64_t _266 = 1;
    _266 *= b;
    _266 *= _265;
    _266 *= sizeof(bool);
    _264.data = jpl_alloc(_266);
    int64_t _267 = 0; // u
    int64_t _268 = 0; // t
    _jump521:; // Begin body of loop
    _a2_bool _270;
    // Computing bound for v
    _270.d0 = j.d0;
    if (j.d0 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for w
    _270.d1 = _13.d1;
    if (_13.d1 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= j.d0;
    _271 *= _13.d1;
    _271 *= sizeof(bool);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // w
    int64_t _273 = 0; // v
    _jump524:; // Begin body of loop
    if (_13.d0 >= 0)
    goto _jump525;
    fail_assertion("negative array index");
    _jump525:;
    if (_13.d0 < f.d0)
    goto _jump526;
    fail_assertion("index too large");
    _jump526:;
    if (_13.d1 >= 0)
    goto _jump527;
    fail_assertion("negative array index");
    _jump527:;
    if (_13.d1 < f.d1)
    goto _jump528;
    fail_assertion("index too large");
    _jump528:;
    if (_13.d1 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (_13.d1 < f.d2)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    int64_t _274 = 0;
    _274 *= f.d0;
    _274 += _13.d0;
    _274 *= f.d1;
    _274 += _13.d1;
    _274 *= f.d2;
    _274 += _13.d1;
    double _275 = f.data[_274];
    bool _276 = _263 >= _275;
    bool _277;
    if (!_276)
    goto _jump531;
    bool _278 = true;
    _277 = _278;
    goto _jump532;
    _jump531:;
    double _279 = 49.0;
    double _280 = _263 * _279;
    double _281;
    // Computing bound for x
    if (j.d0 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for y
    if (_12.d0 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    _281 = 0;
    int64_t _282 = 0; // y
    int64_t _283 = 0; // x
    _jump535:; // Begin body of loop
    _281 += _263;
    _282++;
    if (_282 < _12.d0)
    goto _jump535;
    _282 = 0;
    _283++;
    if (_283 < j.d0)
    goto _jump535;
    // End body of loop
    bool _284 = _280 != _281;
    _277 = _284;
    _jump532:;
    int64_t _285 = 0;
    _285 *= _270.d0;
    _285 += _273;
    _285 *= _270.d1;
    _285 += _272;
    _270.data[_285] = _277;
    _272++;
    if (_272 < _13.d1)
    goto _jump524;
    _272 = 0;
    _273++;
    if (_273 < j.d0)
    goto _jump524;
    // End body of loop
    if (d >= 0)
    goto _jump536;
    fail_assertion("negative array index");
    _jump536:;
    if (d < _270.d0)
    goto _jump537;
    fail_assertion("index too large");
    _jump537:;
    if (_13.d2 >= 0)
    goto _jump538;
    fail_assertion("negative array index");
    _jump538:;
    if (_13.d2 < _270.d1)
    goto _jump539;
    fail_assertion("index too large");
    _jump539:;
    int64_t _286 = 0;
    _286 *= _270.d0;
    _286 += d;
    _286 *= _270.d1;
    _286 += _13.d2;
    bool _287 = _270.data[_286];
    bool _269 = _287;
    if (0 != _287)
    goto _jump540;
    _a2_bool _288;
    // Computing bound for v
    _288.d0 = f.d2;
    if (f.d2 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing bound for w
    _288.d1 = _267;
    if (_267 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    // Computing total size of heap memory to allocate
    int64_t _289 = 1;
    _289 *= f.d2;
    _289 *= _267;
    _289 *= sizeof(bool);
    _288.data = jpl_alloc(_289);
    int64_t _290 = 0; // w
    int64_t _291 = 0; // v
    _jump543:; // Begin body of loop
    bool _292 = false;
    int64_t _293 = 0;
    _293 *= _288.d0;
    _293 += _291;
    _293 *= _288.d1;
    _293 += _290;
    _288.data[_293] = _292;
    _290++;
    if (_290 < _267)
    goto _jump543;
    _290 = 0;
    _291++;
    if (_291 < f.d2)
    goto _jump543;
    // End body of loop
    if (f.d0 >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (f.d0 < _288.d0)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    if (d >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (d < _288.d1)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    int64_t _294 = 0;
    _294 *= _288.d0;
    _294 += f.d0;
    _294 *= _288.d1;
    _294 += d;
    bool _295 = _288.data[_294];
    bool _296 = !_295;
    bool _297;
    if (!_296)
    goto _jump548;
    bool _299 = true;
    bool _298 = _299;
    if (0 == _299)
    goto _jump549;
    bool _301 = false;
    bool _300 = _301;
    if (0 == _301)
    goto _jump550;
    int64_t _302;
    // Computing bound for v
    if (_13.d2 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    _302 = 0;
    int64_t _303 = 0; // v
    _jump552:; // Begin body of loop
    _302 += d;
    _303++;
    if (_303 < _13.d2)
    goto _jump552;
    // End body of loop
    bool _304 = _13.d2 <= _302;
    _300 = _304;
    _jump550:;
    _298 = _300;
    _jump549:;
    _297 = _298;
    goto _jump553;
    _jump548:;
    _a3_bool _306;
    // Computing bound for v
    _306.d0 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for w
    _306.d1 = _268;
    if (_268 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing bound for x
    int64_t _307;
    // Computing bound for v
    if (d > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    _307 = 0;
    int64_t _308 = 0; // v
    _jump557:; // Begin body of loop
    _307 += _12.d0;
    _308++;
    if (_308 < d)
    goto _jump557;
    // End body of loop
    _306.d2 = _307;
    if (_307 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing total size of heap memory to allocate
    int64_t _309 = 1;
    _309 *= _13.d0;
    _309 *= _268;
    _309 *= _307;
    _309 *= sizeof(bool);
    _306.data = jpl_alloc(_309);
    int64_t _310 = 0; // x
    int64_t _311 = 0; // w
    int64_t _312 = 0; // v
    _jump559:; // Begin body of loop
    bool _313 = false;
    bool _314;
    if (!_313)
    goto _jump560;
    bool _315 = false;
    _314 = _315;
    goto _jump561;
    _jump560:;
    bool _316 = false;
    _314 = _316;
    _jump561:;
    int64_t _317 = 0;
    _317 *= _306.d0;
    _317 += _312;
    _317 *= _306.d1;
    _317 += _311;
    _317 *= _306.d2;
    _317 += _310;
    _306.data[_317] = _314;
    _310++;
    if (_310 < _307)
    goto _jump559;
    _310 = 0;
    _311++;
    if (_311 < _268)
    goto _jump559;
    _311 = 0;
    _312++;
    if (_312 < _13.d0)
    goto _jump559;
    // End body of loop
    int64_t _318;
    // Computing bound for v
    if (c > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    _318 = 0;
    int64_t _319 = 0; // v
    _jump563:; // Begin body of loop
    int64_t _320 = 616;
    int64_t _321 = _320 / _267;
    _318 += _321;
    _319++;
    if (_319 < c)
    goto _jump563;
    // End body of loop
    if (j.d0 >= 0)
    goto _jump564;
    fail_assertion("negative array index");
    _jump564:;
    if (j.d0 < _306.d0)
    goto _jump565;
    fail_assertion("index too large");
    _jump565:;
    if (d >= 0)
    goto _jump566;
    fail_assertion("negative array index");
    _jump566:;
    if (d < _306.d1)
    goto _jump567;
    fail_assertion("index too large");
    _jump567:;
    if (_318 >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (_318 < _306.d2)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    int64_t _322 = 0;
    _322 *= _306.d0;
    _322 += j.d0;
    _322 *= _306.d1;
    _322 += d;
    _322 *= _306.d2;
    _322 += _318;
    bool _323 = _306.data[_322];
    bool _305 = _323;
    if (0 != _323)
    goto _jump570;
    bool _324 = false;
    bool _325 = !_324;
    _305 = _325;
    _jump570:;
    _297 = _305;
    _jump553:;
    _269 = _297;
    _jump540:;
    int64_t _326 = 0;
    _326 *= _264.d0;
    _326 += _268;
    _326 *= _264.d1;
    _326 += _267;
    _264.data[_326] = _269;
    _267++;
    if (_267 < _265)
    goto _jump521;
    _267 = 0;
    _268++;
    if (_268 < b)
    goto _jump521;
    // End body of loop
    _a2_bool _327;
    // Computing bound for w
    int64_t _328 = c * _13.d0;
    _327.d0 = _328;
    if (_328 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing bound for x
    _327.d1 = d;
    if (d > 0) 
    goto _jump572;
    fail_assertion("non-positive loop bound");
    _jump572:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _328;
    _329 *= d;
    _329 *= sizeof(bool);
    _327.data = jpl_alloc(_329);
    int64_t _330 = 0; // x
    int64_t _331 = 0; // w
    _jump573:; // Begin body of loop
    _a1_bool _332;
    // Computing bound for y
    _332.d0 = b;
    if (b > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing total size of heap memory to allocate
    int64_t _333 = 1;
    _333 *= b;
    _333 *= sizeof(bool);
    _332.data = jpl_alloc(_333);
    int64_t _334 = 0; // y
    _jump575:; // Begin body of loop
    bool _335 = false;
    bool _336 = !_335;
    int64_t _337 = 0;
    _337 *= _332.d0;
    _337 += _334;
    _332.data[_337] = _336;
    _334++;
    if (_334 < b)
    goto _jump575;
    // End body of loop
    if (_13.d1 >= 0)
    goto _jump576;
    fail_assertion("negative array index");
    _jump576:;
    if (_13.d1 < _332.d0)
    goto _jump577;
    fail_assertion("index too large");
    _jump577:;
    int64_t _338 = 0;
    _338 *= _332.d0;
    _338 += _13.d1;
    bool _339 = _332.data[_338];
    int64_t _340 = 0;
    _340 *= _327.d0;
    _340 += _331;
    _340 *= _327.d1;
    _340 += _330;
    _327.data[_340] = _339;
    _330++;
    if (_330 < d)
    goto _jump573;
    _330 = 0;
    _331++;
    if (_331 < _328)
    goto _jump573;
    // End body of loop
    _a3_int64_t _341;
    // Computing bound for w
    _341.d0 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing bound for x
    _341.d1 = d;
    if (d > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for y
    _341.d2 = f.d0;
    if (f.d0 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    // Computing total size of heap memory to allocate
    int64_t _342 = 1;
    _342 *= _13.d0;
    _342 *= d;
    _342 *= f.d0;
    _342 *= sizeof(int64_t);
    _341.data = jpl_alloc(_342);
    int64_t _343 = 0; // y
    int64_t _344 = 0; // x
    int64_t _345 = 0; // w
    _jump581:; // Begin body of loop
    int64_t _346 = 0;
    _346 *= _341.d0;
    _346 += _345;
    _346 *= _341.d1;
    _346 += _344;
    _346 *= _341.d2;
    _346 += _343;
    _341.data[_346] = _345;
    _343++;
    if (_343 < f.d0)
    goto _jump581;
    _343 = 0;
    _344++;
    if (_344 < d)
    goto _jump581;
    _344 = 0;
    _345++;
    if (_345 < _13.d0)
    goto _jump581;
    // End body of loop
    if (_264.d1 >= 0)
    goto _jump582;
    fail_assertion("negative array index");
    _jump582:;
    if (_264.d1 < _341.d0)
    goto _jump583;
    fail_assertion("index too large");
    _jump583:;
    if (_264.d1 >= 0)
    goto _jump584;
    fail_assertion("negative array index");
    _jump584:;
    if (_264.d1 < _341.d1)
    goto _jump585;
    fail_assertion("index too large");
    _jump585:;
    if (b >= 0)
    goto _jump586;
    fail_assertion("negative array index");
    _jump586:;
    if (b < _341.d2)
    goto _jump587;
    fail_assertion("index too large");
    _jump587:;
    int64_t _347 = 0;
    _347 *= _341.d0;
    _347 += _264.d1;
    _347 *= _341.d1;
    _347 += _264.d1;
    _347 *= _341.d2;
    _347 += b;
    int64_t _348 = _341.data[_347];
    if (_348 >= 0)
    goto _jump588;
    fail_assertion("negative array index");
    _jump588:;
    if (_348 < _327.d0)
    goto _jump589;
    fail_assertion("index too large");
    _jump589:;
    if (f.d2 >= 0)
    goto _jump590;
    fail_assertion("negative array index");
    _jump590:;
    if (f.d2 < _327.d1)
    goto _jump591;
    fail_assertion("index too large");
    _jump591:;
    int64_t _349 = 0;
    _349 *= _327.d0;
    _349 += _348;
    _349 *= _327.d1;
    _349 += f.d2;
    bool _350 = _327.data[_349];
    _a1_bool _351;
    // Computing bound for w
    _351.d0 = _12.d0;
    if (_12.d0 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    // Computing total size of heap memory to allocate
    int64_t _352 = 1;
    _352 *= _12.d0;
    _352 *= sizeof(bool);
    _351.data = jpl_alloc(_352);
    int64_t _353 = 0; // w
    _jump593:; // Begin body of loop
    bool _354 = true;
    bool _355 = !_354;
    bool _356 = !_355;
    bool _357 = !_356;
    int64_t _358 = 0;
    _358 *= _351.d0;
    _358 += _353;
    _351.data[_358] = _357;
    _353++;
    if (_353 < _12.d0)
    goto _jump593;
    // End body of loop
    int64_t _359 = j.d0 * f.d1;
    if (_359 >= 0)
    goto _jump594;
    fail_assertion("negative array index");
    _jump594:;
    if (_359 < _351.d0)
    goto _jump595;
    fail_assertion("index too large");
    _jump595:;
    int64_t _360 = 0;
    _360 *= _351.d0;
    _360 += _359;
    bool _361 = _351.data[_360];
    bool _362 = !_361;
    bool _363 = _350 == _362;
    if (0 != _363)
    goto _jump596;
    fail_assertion("w");
    _jump596:;
    bool _365 = _13.d1 != _13.d0;
    bool _364 = _365;
    if (0 != _365)
    goto _jump597;
    bool _366 = c == _13.d0;
    _364 = _366;
    _jump597:;
    bool _367 = !_364;
    if (_12.d0 >= 0)
    goto _jump598;
    fail_assertion("negative array index");
    _jump598:;
    if (_12.d0 < _264.d0)
    goto _jump599;
    fail_assertion("index too large");
    _jump599:;
    if (_13.d2 >= 0)
    goto _jump600;
    fail_assertion("negative array index");
    _jump600:;
    if (_13.d2 < _264.d1)
    goto _jump601;
    fail_assertion("index too large");
    _jump601:;
    int64_t _368 = 0;
    _368 *= _264.d0;
    _368 += _12.d0;
    _368 *= _264.d1;
    _368 += _13.d2;
    bool _369 = _264.data[_368];
    double _370;
    if (!_369)
    goto _jump602;
    double _371 = -_263;
    _370 = _371;
    goto _jump603;
    _jump602:;
    double _372 = 88.0;
    _370 = _372;
    _jump603:;
    bool _373 = f.d0 != _13.d2;
    double _374;
    if (!_373)
    goto _jump604;
    double _375 = 70.0;
    double _376 = -_375;
    _374 = _376;
    goto _jump605;
    _jump604:;
    double _377 = _262.g;
    _374 = _377;
    _jump605:;
    bool _378 = _370 >= _374;
    bool _379 = _367 != _378;
    double _380;
    if (!_379)
    goto _jump606;
    _380 = _263;
    goto _jump607;
    _jump606:;
    double _381 = _262.a;
    _380 = _381;
    _jump607:;
    double _382 = -_380;
    double _383;
    // Computing bound for w
    if (_13.d2 > 0) 
    goto _jump608;
    fail_assertion("non-positive loop bound");
    _jump608:;
    // Computing bound for x
    if (b > 0) 
    goto _jump609;
    fail_assertion("non-positive loop bound");
    _jump609:;
    _383 = 0;
    int64_t _384 = 0; // x
    int64_t _385 = 0; // w
    _jump610:; // Begin body of loop
    _a2_double _386;
    // Computing bound for y
    _386.d0 = _13.d1;
    if (_13.d1 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for z
    bool _387 = true;
    bool _388 = !_387;
    bool _389;
    if (!_388)
    goto _jump612;
    if (_264.d1 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (_264.d1 < _264.d0)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    if (_385 >= 0)
    goto _jump615;
    fail_assertion("negative array index");
    _jump615:;
    if (_385 < _264.d1)
    goto _jump616;
    fail_assertion("index too large");
    _jump616:;
    int64_t _390 = 0;
    _390 *= _264.d0;
    _390 += _264.d1;
    _390 *= _264.d1;
    _390 += _385;
    bool _391 = _264.data[_390];
    _389 = _391;
    goto _jump617;
    _jump612:;
    bool _392 = false;
    _389 = _392;
    _jump617:;
    int64_t _393;
    if (!_389)
    goto _jump618;
    _393 = _264.d0;
    goto _jump619;
    _jump618:;
    _393 = f.d2;
    _jump619:;
    _386.d1 = _393;
    if (_393 > 0) 
    goto _jump620;
    fail_assertion("non-positive loop bound");
    _jump620:;
    // Computing total size of heap memory to allocate
    int64_t _394 = 1;
    _394 *= _13.d1;
    _394 *= _393;
    _394 *= sizeof(double);
    _386.data = jpl_alloc(_394);
    int64_t _395 = 0; // z
    int64_t _396 = 0; // y
    _jump621:; // Begin body of loop
    double _397 = 75.0;
    double _398 = -_397;
    double _399 = -_398;
    double _400 = -_399;
    int64_t _401 = 0;
    _401 *= _386.d0;
    _401 += _396;
    _401 *= _386.d1;
    _401 += _395;
    _386.data[_401] = _400;
    _395++;
    if (_395 < _393)
    goto _jump621;
    _395 = 0;
    _396++;
    if (_396 < _13.d1)
    goto _jump621;
    // End body of loop
    int64_t _402;
    // Computing bound for y
    bool _403 = _12.d0 == f.d2;
    bool _404 = !_403;
    int64_t _405;
    if (!_404)
    goto _jump622;
    _405 = _384;
    goto _jump623;
    _jump622:;
    _405 = _264.d1;
    _jump623:;
    if (_405 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    // Computing bound for z
    if (j.d0 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for A
    int64_t _406;
    // Computing bound for y
    if (f.d1 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    // Computing bound for z
    int64_t _407 = 949;
    if (_407 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    _406 = 0;
    int64_t _408 = 0; // z
    int64_t _409 = 0; // y
    _jump628:; // Begin body of loop
    _406 += _409;
    _408++;
    if (_408 < _407)
    goto _jump628;
    _408 = 0;
    _409++;
    if (_409 < f.d1)
    goto _jump628;
    // End body of loop
    if (_406 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    _402 = 0;
    int64_t _410 = 0; // A
    int64_t _411 = 0; // z
    int64_t _412 = 0; // y
    _jump630:; // Begin body of loop
    _402 += b;
    _410++;
    if (_410 < _406)
    goto _jump630;
    _410 = 0;
    _411++;
    if (_411 < j.d0)
    goto _jump630;
    _411 = 0;
    _412++;
    if (_412 < _405)
    goto _jump630;
    // End body of loop
    if (f.d1 >= 0)
    goto _jump631;
    fail_assertion("negative array index");
    _jump631:;
    if (f.d1 < _386.d0)
    goto _jump632;
    fail_assertion("index too large");
    _jump632:;
    if (_402 >= 0)
    goto _jump633;
    fail_assertion("negative array index");
    _jump633:;
    if (_402 < _386.d1)
    goto _jump634;
    fail_assertion("index too large");
    _jump634:;
    int64_t _413 = 0;
    _413 *= _386.d0;
    _413 += f.d1;
    _413 *= _386.d1;
    _413 += _402;
    double _414 = _386.data[_413];
    _383 += _414;
    _384++;
    if (_384 < b)
    goto _jump610;
    _384 = 0;
    _385++;
    if (_385 < _13.d2)
    goto _jump610;
    // End body of loop
    _a3_double _415;
    // Computing bound for w
    if (_13.d0 >= 0)
    goto _jump635;
    fail_assertion("negative array index");
    _jump635:;
    if (_13.d0 < a.d0)
    goto _jump636;
    fail_assertion("index too large");
    _jump636:;
    if (f.d1 >= 0)
    goto _jump637;
    fail_assertion("negative array index");
    _jump637:;
    if (f.d1 < a.d1)
    goto _jump638;
    fail_assertion("index too large");
    _jump638:;
    if (_13.d1 >= 0)
    goto _jump639;
    fail_assertion("negative array index");
    _jump639:;
    if (_13.d1 < a.d2)
    goto _jump640;
    fail_assertion("index too large");
    _jump640:;
    int64_t _416 = 0;
    _416 *= a.d0;
    _416 += _13.d0;
    _416 *= a.d1;
    _416 += f.d1;
    _416 *= a.d2;
    _416 += _13.d1;
    bool _417 = a.data[_416];
    int64_t _418;
    if (!_417)
    goto _jump641;
    _418 = j.d0;
    goto _jump642;
    _jump641:;
    int64_t _419;
    // Computing bound for w
    if (d > 0) 
    goto _jump643;
    fail_assertion("non-positive loop bound");
    _jump643:;
    _419 = 0;
    int64_t _420 = 0; // w
    _jump644:; // Begin body of loop
    _419 += _13.d1;
    _420++;
    if (_420 < d)
    goto _jump644;
    // End body of loop
    _418 = _419;
    _jump642:;
    int64_t _421 = -_418;
    _415.d0 = _421;
    if (_421 > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    // Computing bound for x
    _415.d1 = j.d0;
    if (j.d0 > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing bound for y
    _415.d2 = _13.d0;
    if (_13.d0 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    // Computing total size of heap memory to allocate
    int64_t _422 = 1;
    _422 *= _421;
    _422 *= j.d0;
    _422 *= _13.d0;
    _422 *= sizeof(double);
    _415.data = jpl_alloc(_422);
    int64_t _423 = 0; // y
    int64_t _424 = 0; // x
    int64_t _425 = 0; // w
    _jump648:; // Begin body of loop
    double _426 = 40.0;
    int64_t _427 = 0;
    _427 *= _415.d0;
    _427 += _425;
    _427 *= _415.d1;
    _427 += _424;
    _427 *= _415.d2;
    _427 += _423;
    _415.data[_427] = _426;
    _423++;
    if (_423 < _13.d0)
    goto _jump648;
    _423 = 0;
    _424++;
    if (_424 < j.d0)
    goto _jump648;
    _424 = 0;
    _425++;
    if (_425 < _421)
    goto _jump648;
    // End body of loop
    int64_t _428 = _13.d0 % j.d0;
    bool _429 = j.d0 == _428;
    _a1_bool _430;
    if (!_429)
    goto _jump649;
    _a1_bool _431;
    // Computing bound for w
    _431.d0 = _12.d0;
    if (_12.d0 > 0) 
    goto _jump650;
    fail_assertion("non-positive loop bound");
    _jump650:;
    // Computing total size of heap memory to allocate
    int64_t _432 = 1;
    _432 *= _12.d0;
    _432 *= sizeof(bool);
    _431.data = jpl_alloc(_432);
    int64_t _433 = 0; // w
    _jump651:; // Begin body of loop
    bool _435 = true;
    bool _436 = !_435;
    bool _434 = _436;
    if (0 != _436)
    goto _jump652;
    bool _437 = f.d0 != c;
    _434 = _437;
    _jump652:;
    int64_t _438 = 0;
    _438 *= _431.d0;
    _438 += _433;
    _431.data[_438] = _434;
    _433++;
    if (_433 < _12.d0)
    goto _jump651;
    // End body of loop
    _430 = _431;
    goto _jump653;
    _jump649:;
    _a2__a1_bool _439;
    // Computing bound for w
    _439.d0 = c;
    if (c > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing bound for x
    int64_t _440;
    // Computing bound for w
    if (j.d0 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for x
    if (f.d2 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    _440 = 0;
    int64_t _441 = 0; // x
    int64_t _442 = 0; // w
    _jump657:; // Begin body of loop
    _440 += _264.d0;
    _441++;
    if (_441 < f.d2)
    goto _jump657;
    _441 = 0;
    _442++;
    if (_442 < j.d0)
    goto _jump657;
    // End body of loop
    _439.d1 = _440;
    if (_440 > 0) 
    goto _jump658;
    fail_assertion("non-positive loop bound");
    _jump658:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= c;
    _443 *= _440;
    _443 *= sizeof(_a1_bool);
    _439.data = jpl_alloc(_443);
    int64_t _444 = 0; // x
    int64_t _445 = 0; // w
    _jump659:; // Begin body of loop
    int64_t _446 = 0;
    _446 *= _439.d0;
    _446 += _445;
    _446 *= _439.d1;
    _446 += _444;
    _439.data[_446] = j;
    _444++;
    if (_444 < _440)
    goto _jump659;
    _444 = 0;
    _445++;
    if (_445 < c)
    goto _jump659;
    // End body of loop
    if (f.d2 >= 0)
    goto _jump660;
    fail_assertion("negative array index");
    _jump660:;
    if (f.d2 < _439.d0)
    goto _jump661;
    fail_assertion("index too large");
    _jump661:;
    if (_264.d0 >= 0)
    goto _jump662;
    fail_assertion("negative array index");
    _jump662:;
    if (_264.d0 < _439.d1)
    goto _jump663;
    fail_assertion("index too large");
    _jump663:;
    int64_t _447 = 0;
    _447 *= _439.d0;
    _447 += f.d2;
    _447 *= _439.d1;
    _447 += _264.d0;
    _a1_bool _448 = _439.data[_447];
    _430 = _448;
    _jump653:;
    rgba _449 = e(_415, _430);
    double _450 = _449.a;
    double _451 = 79.0;
    rgba _452 = { _382, _383, _450, _451 };
    return _452;
}

_a3__a3_int64_t f(_a1__a1__a2_bool g, _a3_rgba i) {
    _a1_int64_t _0;
    _0.d0 = 2;
    _0.data = jpl_alloc(sizeof(int64_t) * 2);
    _0.data[0] = i.d1;
    _0.data[1] = i.d2;
    _a1_int64_t _1;
    // Computing bound for o
    int64_t _2 = 679;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= sizeof(int64_t);
    _1.data = jpl_alloc(_3);
    int64_t _4 = 0; // o
    _jump665:; // Begin body of loop
    int64_t _5;
    // Computing bound for p
    if (g.d0 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    _5 = 0;
    int64_t _6 = 0; // p
    _jump667:; // Begin body of loop
    _5 += i.d1;
    _6++;
    if (_6 < g.d0)
    goto _jump667;
    // End body of loop
    int64_t _7 = 0;
    _7 *= _1.d0;
    _7 += _4;
    _1.data[_7] = _5;
    _4++;
    if (_4 < _2)
    goto _jump665;
    // End body of loop
    _a3__a3__a2_int64_t _8;
    // Computing bound for q
    _8.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    // Computing bound for r
    int64_t _9 = -d;
    int64_t _10 = d - _9;
    _8.d1 = _10;
    if (_10 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing bound for s
    _8.d2 = c;
    if (c > 0) 
    goto _jump670;
    fail_assertion("non-positive loop bound");
    _jump670:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= i.d1;
    _11 *= _10;
    _11 *= c;
    _11 *= sizeof(_a3__a2_int64_t);
    _8.data = jpl_alloc(_11);
    int64_t _12 = 0; // s
    int64_t _13 = 0; // r
    int64_t _14 = 0; // q
    _jump671:; // Begin body of loop
    _a3__a2_int64_t _15;
    // Computing bound for t
    _15.d0 = _14;
    if (_14 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing bound for u
    _15.d1 = _13;
    if (_13 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    // Computing bound for v
    int64_t _16;
    // Computing bound for t
    int64_t _17 = -b;
    if (_17 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing bound for u
    if (i.d0 > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    // Computing bound for v
    if (_12 > 0) 
    goto _jump676;
    fail_assertion("non-positive loop bound");
    _jump676:;
    _16 = 0;
    int64_t _18 = 0; // v
    int64_t _19 = 0; // u
    int64_t _20 = 0; // t
    _jump677:; // Begin body of loop
    int64_t _21 = d + _20;
    _16 += _21;
    _18++;
    if (_18 < _12)
    goto _jump677;
    _18 = 0;
    _19++;
    if (_19 < i.d0)
    goto _jump677;
    _19 = 0;
    _20++;
    if (_20 < _17)
    goto _jump677;
    // End body of loop
    _15.d2 = _16;
    if (_16 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= _14;
    _22 *= _13;
    _22 *= _16;
    _22 *= sizeof(_a2_int64_t);
    _15.data = jpl_alloc(_22);
    int64_t _23 = 0; // v
    int64_t _24 = 0; // u
    int64_t _25 = 0; // t
    _jump679:; // Begin body of loop
    _a2_int64_t _26;
    // Computing bound for w
    _26.d0 = _13;
    if (_13 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing bound for x
    int64_t _27 = 848;
    _26.d1 = _27;
    if (_27 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    // Computing total size of heap memory to allocate
    int64_t _28 = 1;
    _28 *= _13;
    _28 *= _27;
    _28 *= sizeof(int64_t);
    _26.data = jpl_alloc(_28);
    int64_t _29 = 0; // x
    int64_t _30 = 0; // w
    _jump682:; // Begin body of loop
    int64_t _31 = 0;
    _31 *= _26.d0;
    _31 += _30;
    _31 *= _26.d1;
    _31 += _29;
    _26.data[_31] = i.d1;
    _29++;
    if (_29 < _27)
    goto _jump682;
    _29 = 0;
    _30++;
    if (_30 < _13)
    goto _jump682;
    // End body of loop
    int64_t _32 = 0;
    _32 *= _15.d0;
    _32 += _25;
    _32 *= _15.d1;
    _32 += _24;
    _32 *= _15.d2;
    _32 += _23;
    _15.data[_32] = _26;
    _23++;
    if (_23 < _16)
    goto _jump679;
    _23 = 0;
    _24++;
    if (_24 < _13)
    goto _jump679;
    _24 = 0;
    _25++;
    if (_25 < _14)
    goto _jump679;
    // End body of loop
    int64_t _33 = 0;
    _33 *= _8.d0;
    _33 += _14;
    _33 *= _8.d1;
    _33 += _13;
    _33 *= _8.d2;
    _33 += _12;
    _8.data[_33] = _15;
    _12++;
    if (_12 < c)
    goto _jump671;
    _12 = 0;
    _13++;
    if (_13 < _10)
    goto _jump671;
    _13 = 0;
    _14++;
    if (_14 < i.d1)
    goto _jump671;
    // End body of loop
    if (g.d0 >= 0)
    goto _jump683;
    fail_assertion("negative array index");
    _jump683:;
    if (g.d0 < _8.d0)
    goto _jump684;
    fail_assertion("index too large");
    _jump684:;
    if (_0.d0 >= 0)
    goto _jump685;
    fail_assertion("negative array index");
    _jump685:;
    if (_0.d0 < _8.d1)
    goto _jump686;
    fail_assertion("index too large");
    _jump686:;
    if (i.d2 >= 0)
    goto _jump687;
    fail_assertion("negative array index");
    _jump687:;
    if (i.d2 < _8.d2)
    goto _jump688;
    fail_assertion("index too large");
    _jump688:;
    int64_t _34 = 0;
    _34 *= _8.d0;
    _34 += g.d0;
    _34 *= _8.d1;
    _34 += _0.d0;
    _34 *= _8.d2;
    _34 += i.d2;
    _a3__a2_int64_t _35 = _8.data[_34];
    int64_t _36 = -i.d2;
    if (_36 >= 0)
    goto _jump689;
    fail_assertion("negative array index");
    _jump689:;
    if (_36 < _35.d0)
    goto _jump690;
    fail_assertion("index too large");
    _jump690:;
    if (c >= 0)
    goto _jump691;
    fail_assertion("negative array index");
    _jump691:;
    if (c < _35.d1)
    goto _jump692;
    fail_assertion("index too large");
    _jump692:;
    if (b >= 0)
    goto _jump693;
    fail_assertion("negative array index");
    _jump693:;
    if (b < _35.d2)
    goto _jump694;
    fail_assertion("index too large");
    _jump694:;
    int64_t _37 = 0;
    _37 *= _35.d0;
    _37 += _36;
    _37 *= _35.d1;
    _37 += c;
    _37 *= _35.d2;
    _37 += b;
    _a2_int64_t _38 = _35.data[_37];
    if (_0.d0 >= 0)
    goto _jump695;
    fail_assertion("negative array index");
    _jump695:;
    if (_0.d0 < _38.d0)
    goto _jump696;
    fail_assertion("index too large");
    _jump696:;
    if (c >= 0)
    goto _jump697;
    fail_assertion("negative array index");
    _jump697:;
    if (c < _38.d1)
    goto _jump698;
    fail_assertion("index too large");
    _jump698:;
    int64_t _39 = 0;
    _39 *= _38.d0;
    _39 += _0.d0;
    _39 *= _38.d1;
    _39 += c;
    int64_t _40 = _38.data[_39];
    _a1__a2_bool _41;
    // Computing bound for r
    _41.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= i.d2;
    _42 *= sizeof(_a2_bool);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // r
    _jump700:; // Begin body of loop
    _a2_bool _44;
    // Computing bound for s
    int64_t _45 = 297;
    _44.d0 = _45;
    if (_45 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing bound for t
    _44.d1 = c;
    if (c > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= _45;
    _46 *= c;
    _46 *= sizeof(bool);
    _44.data = jpl_alloc(_46);
    int64_t _47 = 0; // t
    int64_t _48 = 0; // s
    _jump703:; // Begin body of loop
    bool _49 = _40 == _47;
    int64_t _50 = 0;
    _50 *= _44.d0;
    _50 += _48;
    _50 *= _44.d1;
    _50 += _47;
    _44.data[_50] = _49;
    _47++;
    if (_47 < c)
    goto _jump703;
    _47 = 0;
    _48++;
    if (_48 < _45)
    goto _jump703;
    // End body of loop
    int64_t _51 = 0;
    _51 *= _41.d0;
    _51 += _43;
    _41.data[_51] = _44;
    _43++;
    if (_43 < i.d2)
    goto _jump700;
    // End body of loop
    _a1__a2_bool _52;
    // Computing bound for r
    _52.d0 = b;
    if (b > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= b;
    _53 *= sizeof(_a2_bool);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // r
    _jump705:; // Begin body of loop
    _a2_bool _55;
    // Computing bound for s
    _55.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    // Computing bound for t
    int64_t _56 = g.d0 % _0.d0;
    _55.d1 = _56;
    if (_56 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= _0.d0;
    _57 *= _56;
    _57 *= sizeof(bool);
    _55.data = jpl_alloc(_57);
    int64_t _58 = 0; // t
    int64_t _59 = 0; // s
    _jump708:; // Begin body of loop
    bool _60 = false;
    bool _61 = !_60;
    int64_t _62 = 0;
    _62 *= _55.d0;
    _62 += _59;
    _62 *= _55.d1;
    _62 += _58;
    _55.data[_62] = _61;
    _58++;
    if (_58 < _56)
    goto _jump708;
    _58 = 0;
    _59++;
    if (_59 < _0.d0)
    goto _jump708;
    // End body of loop
    int64_t _63 = 0;
    _63 *= _52.d0;
    _63 += _54;
    _52.data[_63] = _55;
    _54++;
    if (_54 < b)
    goto _jump705;
    // End body of loop
    _a1__a1__a2_bool _64;
    _64.d0 = 2;
    _64.data = jpl_alloc(sizeof(_a1__a2_bool) * 2);
    _64.data[0] = _41;
    _64.data[1] = _52;
    _a3__a3_int64_t _65 = f(_64, i);
    int64_t _66;
    // Computing bound for r
    if (i.d0 > 0) 
    goto _jump709;
    fail_assertion("non-positive loop bound");
    _jump709:;
    // Computing bound for s
    if (_0.d0 > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing bound for t
    if (g.d0 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    _66 = 0;
    int64_t _67 = 0; // t
    int64_t _68 = 0; // s
    int64_t _69 = 0; // r
    _jump712:; // Begin body of loop
    int64_t _70 = i.d0 + _0.d0;
    _66 += _70;
    _67++;
    if (_67 < g.d0)
    goto _jump712;
    _67 = 0;
    _68++;
    if (_68 < _0.d0)
    goto _jump712;
    _68 = 0;
    _69++;
    if (_69 < i.d0)
    goto _jump712;
    // End body of loop
    int64_t _71 = i.d1 + _66;
    if (_71 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_71 < _65.d0)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    if (_0.d0 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_0.d0 < _65.d1)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    if (i.d2 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (i.d2 < _65.d2)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    int64_t _72 = 0;
    _72 *= _65.d0;
    _72 += _71;
    _72 *= _65.d1;
    _72 += _0.d0;
    _72 *= _65.d2;
    _72 += i.d2;
    _a3_int64_t _73 = _65.data[_72];
    _a3__a3__a3_double _74;
    // Computing bound for v
    int64_t _75;
    // Computing bound for v
    int64_t _76;
    // Computing bound for v
    if (g.d0 > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing bound for w
    if (_73.d1 > 0) 
    goto _jump720;
    fail_assertion("non-positive loop bound");
    _jump720:;
    // Computing bound for x
    if (i.d2 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    _76 = 0;
    int64_t _77 = 0; // x
    int64_t _78 = 0; // w
    int64_t _79 = 0; // v
    _jump722:; // Begin body of loop
    _76 += _77;
    _77++;
    if (_77 < i.d2)
    goto _jump722;
    _77 = 0;
    _78++;
    if (_78 < _73.d1)
    goto _jump722;
    _78 = 0;
    _79++;
    if (_79 < g.d0)
    goto _jump722;
    // End body of loop
    if (_76 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    _75 = 0;
    int64_t _80 = 0; // v
    _jump724:; // Begin body of loop
    _75 += _73.d2;
    _80++;
    if (_80 < _76)
    goto _jump724;
    // End body of loop
    _74.d0 = _75;
    if (_75 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing bound for w
    int64_t _81 = b % _73.d0;
    _74.d1 = _81;
    if (_81 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    // Computing bound for x
    _74.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump727;
    fail_assertion("non-positive loop bound");
    _jump727:;
    // Computing total size of heap memory to allocate
    int64_t _82 = 1;
    _82 *= _75;
    _82 *= _81;
    _82 *= i.d0;
    _82 *= sizeof(_a3__a3_double);
    _74.data = jpl_alloc(_82);
    int64_t _83 = 0; // x
    int64_t _84 = 0; // w
    int64_t _85 = 0; // v
    _jump728:; // Begin body of loop
    _a3__a3_double _86;
    // Computing bound for y
    _86.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing bound for z
    int64_t _87 = 912;
    _86.d1 = _87;
    if (_87 > 0) 
    goto _jump730;
    fail_assertion("non-positive loop bound");
    _jump730:;
    // Computing bound for A
    _86.d2 = _84;
    if (_84 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= _0.d0;
    _88 *= _87;
    _88 *= _84;
    _88 *= sizeof(_a3_double);
    _86.data = jpl_alloc(_88);
    int64_t _89 = 0; // A
    int64_t _90 = 0; // z
    int64_t _91 = 0; // y
    _jump732:; // Begin body of loop
    _a3_double _92;
    // Computing bound for B
    _92.d0 = _85;
    if (_85 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for C
    _92.d1 = _40;
    if (_40 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing bound for D
    _92.d2 = _85;
    if (_85 > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= _85;
    _93 *= _40;
    _93 *= _85;
    _93 *= sizeof(double);
    _92.data = jpl_alloc(_93);
    int64_t _94 = 0; // D
    int64_t _95 = 0; // C
    int64_t _96 = 0; // B
    _jump736:; // Begin body of loop
    double _97 = 59.0;
    int64_t _98 = 0;
    _98 *= _92.d0;
    _98 += _96;
    _98 *= _92.d1;
    _98 += _95;
    _98 *= _92.d2;
    _98 += _94;
    _92.data[_98] = _97;
    _94++;
    if (_94 < _85)
    goto _jump736;
    _94 = 0;
    _95++;
    if (_95 < _40)
    goto _jump736;
    _95 = 0;
    _96++;
    if (_96 < _85)
    goto _jump736;
    // End body of loop
    int64_t _99 = 0;
    _99 *= _86.d0;
    _99 += _91;
    _99 *= _86.d1;
    _99 += _90;
    _99 *= _86.d2;
    _99 += _89;
    _86.data[_99] = _92;
    _89++;
    if (_89 < _84)
    goto _jump732;
    _89 = 0;
    _90++;
    if (_90 < _87)
    goto _jump732;
    _90 = 0;
    _91++;
    if (_91 < _0.d0)
    goto _jump732;
    // End body of loop
    int64_t _100 = 0;
    _100 *= _74.d0;
    _100 += _85;
    _100 *= _74.d1;
    _100 += _84;
    _100 *= _74.d2;
    _100 += _83;
    _74.data[_100] = _86;
    _83++;
    if (_83 < i.d0)
    goto _jump728;
    _83 = 0;
    _84++;
    if (_84 < _81)
    goto _jump728;
    _84 = 0;
    _85++;
    if (_85 < _75)
    goto _jump728;
    // End body of loop
    if (g.d0 >= 0)
    goto _jump737;
    fail_assertion("negative array index");
    _jump737:;
    if (g.d0 < _74.d0)
    goto _jump738;
    fail_assertion("index too large");
    _jump738:;
    if (_73.d1 >= 0)
    goto _jump739;
    fail_assertion("negative array index");
    _jump739:;
    if (_73.d1 < _74.d1)
    goto _jump740;
    fail_assertion("index too large");
    _jump740:;
    if (_40 >= 0)
    goto _jump741;
    fail_assertion("negative array index");
    _jump741:;
    if (_40 < _74.d2)
    goto _jump742;
    fail_assertion("index too large");
    _jump742:;
    int64_t _101 = 0;
    _101 *= _74.d0;
    _101 += g.d0;
    _101 *= _74.d1;
    _101 += _73.d1;
    _101 *= _74.d2;
    _101 += _40;
    _a3__a3_double _102 = _74.data[_101];
    int64_t _103 = 640;
    if (i.d0 >= 0)
    goto _jump743;
    fail_assertion("negative array index");
    _jump743:;
    if (i.d0 < _102.d0)
    goto _jump744;
    fail_assertion("index too large");
    _jump744:;
    if (c >= 0)
    goto _jump745;
    fail_assertion("negative array index");
    _jump745:;
    if (c < _102.d1)
    goto _jump746;
    fail_assertion("index too large");
    _jump746:;
    if (_103 >= 0)
    goto _jump747;
    fail_assertion("negative array index");
    _jump747:;
    if (_103 < _102.d2)
    goto _jump748;
    fail_assertion("index too large");
    _jump748:;
    int64_t _104 = 0;
    _104 *= _102.d0;
    _104 += i.d0;
    _104 *= _102.d1;
    _104 += c;
    _104 *= _102.d2;
    _104 += _103;
    _a3_double _105 = _102.data[_104];
    int64_t _106 = 447;
    if (c >= 0)
    goto _jump749;
    fail_assertion("negative array index");
    _jump749:;
    if (c < _105.d0)
    goto _jump750;
    fail_assertion("index too large");
    _jump750:;
    if (_106 >= 0)
    goto _jump751;
    fail_assertion("negative array index");
    _jump751:;
    if (_106 < _105.d1)
    goto _jump752;
    fail_assertion("index too large");
    _jump752:;
    if (c >= 0)
    goto _jump753;
    fail_assertion("negative array index");
    _jump753:;
    if (c < _105.d2)
    goto _jump754;
    fail_assertion("index too large");
    _jump754:;
    int64_t _107 = 0;
    _107 *= _105.d0;
    _107 += c;
    _107 *= _105.d1;
    _107 += _106;
    _107 *= _105.d2;
    _107 += c;
    double _108 = _105.data[_107];
    double _109;
    // Computing bound for v
    int64_t _110 = _73.d0 - _73.d0;
    if (_110 > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    _109 = 0;
    int64_t _111 = 0; // v
    _jump756:; // Begin body of loop
    double _112 = 30.0;
    double _113 = 44.0;
    double _114 = _112 - _113;
    double _115 = 91.0;
    double _116 = -_115;
    double _117 = -_116;
    double _118 = -_117;
    double _119 = 55.0;
    _a1_double _120;
    _120.d0 = 3;
    _120.data = jpl_alloc(sizeof(double) * 3);
    _120.data[0] = _114;
    _120.data[1] = _118;
    _120.data[2] = _119;
    if (i.d1 >= 0)
    goto _jump757;
    fail_assertion("negative array index");
    _jump757:;
    if (i.d1 < _120.d0)
    goto _jump758;
    fail_assertion("index too large");
    _jump758:;
    int64_t _121 = 0;
    _121 *= _120.d0;
    _121 += i.d1;
    double _122 = _120.data[_121];
    _109 += _122;
    _111++;
    if (_111 < _110)
    goto _jump756;
    // End body of loop
    bool _123 = _108 <= _109;
    _a3__a3__a3_int64_t _124;
    // Computing bound for w
    _124.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing bound for x
    int64_t _125 = c + i.d2;
    _124.d1 = _125;
    if (_125 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    // Computing bound for y
    _124.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    // Computing total size of heap memory to allocate
    int64_t _126 = 1;
    _126 *= g.d0;
    _126 *= _125;
    _126 *= _0.d0;
    _126 *= sizeof(_a3__a3_int64_t);
    _124.data = jpl_alloc(_126);
    int64_t _127 = 0; // y
    int64_t _128 = 0; // x
    int64_t _129 = 0; // w
    _jump762:; // Begin body of loop
    bool _131 = _123;
    if (0 == _123)
    goto _jump763;
    if (_127 >= 0)
    goto _jump764;
    fail_assertion("negative array index");
    _jump764:;
    if (_127 < a.d0)
    goto _jump765;
    fail_assertion("index too large");
    _jump765:;
    if (i.d1 >= 0)
    goto _jump766;
    fail_assertion("negative array index");
    _jump766:;
    if (i.d1 < a.d1)
    goto _jump767;
    fail_assertion("index too large");
    _jump767:;
    if (_127 >= 0)
    goto _jump768;
    fail_assertion("negative array index");
    _jump768:;
    if (_127 < a.d2)
    goto _jump769;
    fail_assertion("index too large");
    _jump769:;
    int64_t _132 = 0;
    _132 *= a.d0;
    _132 += _127;
    _132 *= a.d1;
    _132 += i.d1;
    _132 *= a.d2;
    _132 += _127;
    bool _133 = a.data[_132];
    _131 = _133;
    _jump763:;
    bool _130 = _131;
    if (0 == _131)
    goto _jump770;
    bool _134;
    if (!_123)
    goto _jump771;
    bool _135 = !_123;
    _134 = _135;
    goto _jump772;
    _jump771:;
    if (_73.d2 >= 0)
    goto _jump773;
    fail_assertion("negative array index");
    _jump773:;
    if (_73.d2 < a.d0)
    goto _jump774;
    fail_assertion("index too large");
    _jump774:;
    if (i.d1 >= 0)
    goto _jump775;
    fail_assertion("negative array index");
    _jump775:;
    if (i.d1 < a.d1)
    goto _jump776;
    fail_assertion("index too large");
    _jump776:;
    if (_73.d2 >= 0)
    goto _jump777;
    fail_assertion("negative array index");
    _jump777:;
    if (_73.d2 < a.d2)
    goto _jump778;
    fail_assertion("index too large");
    _jump778:;
    int64_t _136 = 0;
    _136 *= a.d0;
    _136 += _73.d2;
    _136 *= a.d1;
    _136 += i.d1;
    _136 *= a.d2;
    _136 += _73.d2;
    bool _137 = a.data[_136];
    _134 = _137;
    _jump772:;
    _130 = _134;
    _jump770:;
    bool _138;
    if (!_130)
    goto _jump779;
    double _140 = 29.0;
    double _141 = 56.0;
    bool _142 = _140 != _141;
    bool _139 = _142;
    if (0 == _142)
    goto _jump780;
    bool _143 = i.d0 == _73.d0;
    bool _144 = true;
    bool _145 = _143 != _144;
    _139 = _145;
    _jump780:;
    _138 = _139;
    goto _jump781;
    _jump779:;
    double _146 = 98.0;
    double _147 = -_146;
    double _148;
    // Computing bound for z
    if (i.d1 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing bound for A
    if (_73.d1 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    _148 = 0;
    int64_t _149 = 0; // A
    int64_t _150 = 0; // z
    _jump784:; // Begin body of loop
    double _151 = 43.0;
    _148 += _151;
    _149++;
    if (_149 < _73.d1)
    goto _jump784;
    _149 = 0;
    _150++;
    if (_150 < i.d1)
    goto _jump784;
    // End body of loop
    bool _152 = _147 >= _148;
    bool _153;
    if (!_152)
    goto _jump785;
    bool _154 = true;
    _153 = _154;
    goto _jump786;
    _jump785:;
    double _155 = 41.0;
    double _156 = -_155;
    double _157 = 70.0;
    double _158 = -_157;
    bool _159 = _156 > _158;
    _153 = _159;
    _jump786:;
    _138 = _153;
    _jump781:;
    _a3__a3_int64_t _160;
    if (!_138)
    goto _jump787;
    bool _161 = !_123;
    _a3__a3_int64_t _162;
    if (!_161)
    goto _jump788;
    _a3__a3_int64_t _163;
    // Computing bound for z
    _163.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump789;
    fail_assertion("non-positive loop bound");
    _jump789:;
    // Computing bound for A
    _163.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for B
    _163.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= g.d0;
    _164 *= _0.d0;
    _164 *= i.d1;
    _164 *= sizeof(_a3_int64_t);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // B
    int64_t _166 = 0; // A
    int64_t _167 = 0; // z
    _jump792:; // Begin body of loop
    int64_t _168 = 0;
    _168 *= _163.d0;
    _168 += _167;
    _168 *= _163.d1;
    _168 += _166;
    _168 *= _163.d2;
    _168 += _165;
    _163.data[_168] = _73;
    _165++;
    if (_165 < i.d1)
    goto _jump792;
    _165 = 0;
    _166++;
    if (_166 < _0.d0)
    goto _jump792;
    _166 = 0;
    _167++;
    if (_167 < g.d0)
    goto _jump792;
    // End body of loop
    _162 = _163;
    goto _jump793;
    _jump788:;
    _a3__a3_int64_t _169;
    // Computing bound for z
    _169.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    // Computing bound for A
    _169.d1 = _73.d0;
    if (_73.d0 > 0) 
    goto _jump795;
    fail_assertion("non-positive loop bound");
    _jump795:;
    // Computing bound for B
    int64_t _170 = 497;
    _169.d2 = _170;
    if (_170 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _0.d0;
    _171 *= _73.d0;
    _171 *= _170;
    _171 *= sizeof(_a3_int64_t);
    _169.data = jpl_alloc(_171);
    int64_t _172 = 0; // B
    int64_t _173 = 0; // A
    int64_t _174 = 0; // z
    _jump797:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _169.d0;
    _175 += _174;
    _175 *= _169.d1;
    _175 += _173;
    _175 *= _169.d2;
    _175 += _172;
    _169.data[_175] = _73;
    _172++;
    if (_172 < _170)
    goto _jump797;
    _172 = 0;
    _173++;
    if (_173 < _73.d0)
    goto _jump797;
    _173 = 0;
    _174++;
    if (_174 < _0.d0)
    goto _jump797;
    // End body of loop
    _a1__a3__a3_int64_t _176;
    _176.d0 = 1;
    _176.data = jpl_alloc(sizeof(_a3__a3_int64_t) * 1);
    _176.data[0] = _169;
    if (_0.d0 >= 0)
    goto _jump798;
    fail_assertion("negative array index");
    _jump798:;
    if (_0.d0 < _176.d0)
    goto _jump799;
    fail_assertion("index too large");
    _jump799:;
    int64_t _177 = 0;
    _177 *= _176.d0;
    _177 += _0.d0;
    _a3__a3_int64_t _178 = _176.data[_177];
    _162 = _178;
    _jump793:;
    _160 = _162;
    goto _jump800;
    _jump787:;
    bool _179 = _40 <= i.d2;
    _a3__a3_int64_t _180;
    if (!_179)
    goto _jump801;
    _a3__a3_int64_t _181;
    // Computing bound for z
    _181.d0 = _73.d2;
    if (_73.d2 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing bound for A
    _181.d1 = _73.d0;
    if (_73.d0 > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    // Computing bound for B
    _a1_int64_t _182;
    // Computing bound for z
    _182.d0 = c;
    if (c > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= c;
    _183 *= sizeof(int64_t);
    _182.data = jpl_alloc(_183);
    int64_t _184 = 0; // z
    _jump805:; // Begin body of loop
    int64_t _185 = 0;
    _185 *= _182.d0;
    _185 += _184;
    _182.data[_185] = _127;
    _184++;
    if (_184 < c)
    goto _jump805;
    // End body of loop
    if (b >= 0)
    goto _jump806;
    fail_assertion("negative array index");
    _jump806:;
    if (b < _182.d0)
    goto _jump807;
    fail_assertion("index too large");
    _jump807:;
    int64_t _186 = 0;
    _186 *= _182.d0;
    _186 += b;
    int64_t _187 = _182.data[_186];
    _181.d2 = _187;
    if (_187 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= _73.d2;
    _188 *= _73.d0;
    _188 *= _187;
    _188 *= sizeof(_a3_int64_t);
    _181.data = jpl_alloc(_188);
    int64_t _189 = 0; // B
    int64_t _190 = 0; // A
    int64_t _191 = 0; // z
    _jump809:; // Begin body of loop
    int64_t _192 = 0;
    _192 *= _181.d0;
    _192 += _191;
    _192 *= _181.d1;
    _192 += _190;
    _192 *= _181.d2;
    _192 += _189;
    _181.data[_192] = _73;
    _189++;
    if (_189 < _187)
    goto _jump809;
    _189 = 0;
    _190++;
    if (_190 < _73.d0)
    goto _jump809;
    _190 = 0;
    _191++;
    if (_191 < _73.d2)
    goto _jump809;
    // End body of loop
    _180 = _181;
    goto _jump810;
    _jump801:;
    _a3__a1__a1__a2_bool _193;
    // Computing bound for z
    _193.d0 = _73.d1;
    if (_73.d1 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    // Computing bound for A
    _193.d1 = b;
    if (b > 0) 
    goto _jump812;
    fail_assertion("non-positive loop bound");
    _jump812:;
    // Computing bound for B
    _193.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= _73.d1;
    _194 *= b;
    _194 *= i.d1;
    _194 *= sizeof(_a1__a1__a2_bool);
    _193.data = jpl_alloc(_194);
    int64_t _195 = 0; // B
    int64_t _196 = 0; // A
    int64_t _197 = 0; // z
    _jump814:; // Begin body of loop
    int64_t _198 = 0;
    _198 *= _193.d0;
    _198 += _197;
    _198 *= _193.d1;
    _198 += _196;
    _198 *= _193.d2;
    _198 += _195;
    _193.data[_198] = g;
    _195++;
    if (_195 < i.d1)
    goto _jump814;
    _195 = 0;
    _196++;
    if (_196 < b)
    goto _jump814;
    _196 = 0;
    _197++;
    if (_197 < _73.d1)
    goto _jump814;
    // End body of loop
    int64_t _199 = 721;
    int64_t _200 = 478;
    if (_199 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (_199 < _193.d0)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    if (_200 >= 0)
    goto _jump817;
    fail_assertion("negative array index");
    _jump817:;
    if (_200 < _193.d1)
    goto _jump818;
    fail_assertion("index too large");
    _jump818:;
    if (b >= 0)
    goto _jump819;
    fail_assertion("negative array index");
    _jump819:;
    if (b < _193.d2)
    goto _jump820;
    fail_assertion("index too large");
    _jump820:;
    int64_t _201 = 0;
    _201 *= _193.d0;
    _201 += _199;
    _201 *= _193.d1;
    _201 += _200;
    _201 *= _193.d2;
    _201 += b;
    _a1__a1__a2_bool _202 = _193.data[_201];
    _a3__a3_int64_t _203 = f(_202, i);
    _180 = _203;
    _jump810:;
    _160 = _180;
    _jump800:;
    int64_t _204 = 0;
    _204 *= _124.d0;
    _204 += _129;
    _204 *= _124.d1;
    _204 += _128;
    _204 *= _124.d2;
    _204 += _127;
    _124.data[_204] = _160;
    _127++;
    if (_127 < _0.d0)
    goto _jump762;
    _127 = 0;
    _128++;
    if (_128 < _125)
    goto _jump762;
    _128 = 0;
    _129++;
    if (_129 < g.d0)
    goto _jump762;
    // End body of loop
    if (d >= 0)
    goto _jump821;
    fail_assertion("negative array index");
    _jump821:;
    if (d < _124.d0)
    goto _jump822;
    fail_assertion("index too large");
    _jump822:;
    if (_0.d0 >= 0)
    goto _jump823;
    fail_assertion("negative array index");
    _jump823:;
    if (_0.d0 < _124.d1)
    goto _jump824;
    fail_assertion("index too large");
    _jump824:;
    if (_73.d0 >= 0)
    goto _jump825;
    fail_assertion("negative array index");
    _jump825:;
    if (_73.d0 < _124.d2)
    goto _jump826;
    fail_assertion("index too large");
    _jump826:;
    int64_t _205 = 0;
    _205 *= _124.d0;
    _205 += d;
    _205 *= _124.d1;
    _205 += _0.d0;
    _205 *= _124.d2;
    _205 += _73.d0;
    _a3__a3_int64_t _206 = _124.data[_205];
    return _206;
}

_a1_rgba k(double l, void_t m) {
    double _0 = 6.0;
    bool _2 = true;
    bool _1 = _2;
    if (0 == _2)
    goto _jump1018;
    bool _3 = h >= h;
    bool _4;
    if (!_3)
    goto _jump1019;
    int64_t _5;
    // Computing bound for o
    int64_t _6 = -i;
    if (_6 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing bound for p
    int64_t _7 = 495;
    if (_7 > 0) 
    goto _jump1021;
    fail_assertion("non-positive loop bound");
    _jump1021:;
    _5 = 0;
    int64_t _8 = 0; // p
    int64_t _9 = 0; // o
    _jump1022:; // Begin body of loop
    _5 += i;
    _8++;
    if (_8 < _7)
    goto _jump1022;
    _8 = 0;
    _9++;
    if (_9 < _6)
    goto _jump1022;
    // End body of loop
    bool _10 = h > _5;
    _4 = _10;
    goto _jump1023;
    _jump1019:;
    double _11 = 21.0;
    double _12 = _0 - _0;
    bool _13 = _11 <= _12;
    _4 = _13;
    _jump1023:;
    _1 = _4;
    _jump1018:;
    if (0 != _1)
    goto _jump1024;
    fail_assertion("o");
    _jump1024:;
    bool _15 = b < i;
    bool _14 = _15;
    if (0 != _15)
    goto _jump1025;
    bool _16 = true;
    _14 = _16;
    _jump1025:;
    bool _18 = true;
    bool _17 = _18;
    if (0 != _18)
    goto _jump1026;
    bool _19 = h < d;
    _17 = _19;
    _jump1026:;
    bool _20 = !_17;
    bool _21;
    if (!_20)
    goto _jump1027;
    _a2_bool _22;
    // Computing bound for o
    _22.d0 = j;
    if (j > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing bound for p
    int64_t _23 = 344;
    _22.d1 = _23;
    if (_23 > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= j;
    _24 *= _23;
    _24 *= sizeof(bool);
    _22.data = jpl_alloc(_24);
    int64_t _25 = 0; // p
    int64_t _26 = 0; // o
    _jump1030:; // Begin body of loop
    bool _27 = false;
    int64_t _28 = 0;
    _28 *= _22.d0;
    _28 += _26;
    _28 *= _22.d1;
    _28 += _25;
    _22.data[_28] = _27;
    _25++;
    if (_25 < _23)
    goto _jump1030;
    _25 = 0;
    _26++;
    if (_26 < j)
    goto _jump1030;
    // End body of loop
    if (j >= 0)
    goto _jump1031;
    fail_assertion("negative array index");
    _jump1031:;
    if (j < _22.d0)
    goto _jump1032;
    fail_assertion("index too large");
    _jump1032:;
    if (c >= 0)
    goto _jump1033;
    fail_assertion("negative array index");
    _jump1033:;
    if (c < _22.d1)
    goto _jump1034;
    fail_assertion("index too large");
    _jump1034:;
    int64_t _29 = 0;
    _29 *= _22.d0;
    _29 += j;
    _29 *= _22.d1;
    _29 += c;
    bool _30 = _22.data[_29];
    bool _31;
    if (!_30)
    goto _jump1035;
    bool _32 = false;
    _31 = _32;
    goto _jump1036;
    _jump1035:;
    bool _33 = false;
    _31 = _33;
    _jump1036:;
    _21 = _31;
    goto _jump1037;
    _jump1027:;
    bool _34 = true;
    bool _35 = !_34;
    bool _36 = !_35;
    _21 = _36;
    _jump1037:;
    bool _37 = _14 == _21;
    _a1__a2_int64_t _38;
    if (!_37)
    goto _jump1038;
    _a3__a2_int64_t _39;
    // Computing bound for o
    int64_t _40 = -b;
    _39.d0 = _40;
    if (_40 > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    // Computing bound for p
    int64_t _41;
    // Computing bound for o
    if (j > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    _41 = 0;
    int64_t _42 = 0; // o
    _jump1041:; // Begin body of loop
    _41 += _42;
    _42++;
    if (_42 < j)
    goto _jump1041;
    // End body of loop
    _39.d1 = _41;
    if (_41 > 0) 
    goto _jump1042;
    fail_assertion("non-positive loop bound");
    _jump1042:;
    // Computing bound for q
    _39.d2 = i;
    if (i > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= _40;
    _43 *= _41;
    _43 *= i;
    _43 *= sizeof(_a2_int64_t);
    _39.data = jpl_alloc(_43);
    int64_t _44 = 0; // q
    int64_t _45 = 0; // p
    int64_t _46 = 0; // o
    _jump1044:; // Begin body of loop
    _a2_int64_t _47;
    // Computing bound for r
    _47.d0 = j;
    if (j > 0) 
    goto _jump1045;
    fail_assertion("non-positive loop bound");
    _jump1045:;
    // Computing bound for s
    int64_t _48 = 511;
    int64_t _49 = _48 - _46;
    _47.d1 = _49;
    if (_49 > 0) 
    goto _jump1046;
    fail_assertion("non-positive loop bound");
    _jump1046:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= j;
    _50 *= _49;
    _50 *= sizeof(int64_t);
    _47.data = jpl_alloc(_50);
    int64_t _51 = 0; // s
    int64_t _52 = 0; // r
    _jump1047:; // Begin body of loop
    int64_t _53 = 0;
    _53 *= _47.d0;
    _53 += _52;
    _53 *= _47.d1;
    _53 += _51;
    _47.data[_53] = c;
    _51++;
    if (_51 < _49)
    goto _jump1047;
    _51 = 0;
    _52++;
    if (_52 < j)
    goto _jump1047;
    // End body of loop
    int64_t _54 = 0;
    _54 *= _39.d0;
    _54 += _46;
    _54 *= _39.d1;
    _54 += _45;
    _54 *= _39.d2;
    _54 += _44;
    _39.data[_54] = _47;
    _44++;
    if (_44 < i)
    goto _jump1044;
    _44 = 0;
    _45++;
    if (_45 < _41)
    goto _jump1044;
    _45 = 0;
    _46++;
    if (_46 < _40)
    goto _jump1044;
    // End body of loop
    bool _55 = false;
    int64_t _56;
    if (!_55)
    goto _jump1048;
    _56 = b;
    goto _jump1049;
    _jump1048:;
    _56 = i;
    _jump1049:;
    if (b >= 0)
    goto _jump1050;
    fail_assertion("negative array index");
    _jump1050:;
    if (b < _39.d0)
    goto _jump1051;
    fail_assertion("index too large");
    _jump1051:;
    if (_56 >= 0)
    goto _jump1052;
    fail_assertion("negative array index");
    _jump1052:;
    if (_56 < _39.d1)
    goto _jump1053;
    fail_assertion("index too large");
    _jump1053:;
    if (c >= 0)
    goto _jump1054;
    fail_assertion("negative array index");
    _jump1054:;
    if (c < _39.d2)
    goto _jump1055;
    fail_assertion("index too large");
    _jump1055:;
    int64_t _57 = 0;
    _57 *= _39.d0;
    _57 += b;
    _57 *= _39.d1;
    _57 += _56;
    _57 *= _39.d2;
    _57 += c;
    _a2_int64_t _58 = _39.data[_57];
    _a2_int64_t _59;
    // Computing bound for o
    _59.d0 = h;
    if (h > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    // Computing bound for p
    bool _60 = false;
    int64_t _61;
    if (!_60)
    goto _jump1057;
    _61 = c;
    goto _jump1058;
    _jump1057:;
    int64_t _62 = 72;
    _61 = _62;
    _jump1058:;
    _59.d1 = _61;
    if (_61 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= h;
    _63 *= _61;
    _63 *= sizeof(int64_t);
    _59.data = jpl_alloc(_63);
    int64_t _64 = 0; // p
    int64_t _65 = 0; // o
    _jump1060:; // Begin body of loop
    int64_t _66 = 0;
    _66 *= _59.d0;
    _66 += _65;
    _66 *= _59.d1;
    _66 += _64;
    _59.data[_66] = i;
    _64++;
    if (_64 < _61)
    goto _jump1060;
    _64 = 0;
    _65++;
    if (_65 < h)
    goto _jump1060;
    // End body of loop
    _a1__a2_int64_t _67;
    _67.d0 = 2;
    _67.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _67.data[0] = _58;
    _67.data[1] = _59;
    _38 = _67;
    goto _jump1061;
    _jump1038:;
    int64_t _68;
    // Computing bound for o
    if (j > 0) 
    goto _jump1062;
    fail_assertion("non-positive loop bound");
    _jump1062:;
    // Computing bound for p
    if (h > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    _68 = 0;
    int64_t _69 = 0; // p
    int64_t _70 = 0; // o
    _jump1064:; // Begin body of loop
    _68 += _70;
    _69++;
    if (_69 < h)
    goto _jump1064;
    _69 = 0;
    _70++;
    if (_70 < j)
    goto _jump1064;
    // End body of loop
    int64_t _71 = b % j;
    int64_t _72 = 147;
    int64_t _73 = _71 % _72;
    bool _74 = _68 != _73;
    _a2_int64_t _75;
    if (!_74)
    goto _jump1065;
    _a2_int64_t _76;
    // Computing bound for o
    int64_t _77 = 84;
    _76.d0 = _77;
    if (_77 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing bound for p
    _76.d1 = h;
    if (h > 0) 
    goto _jump1067;
    fail_assertion("non-positive loop bound");
    _jump1067:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= _77;
    _78 *= h;
    _78 *= sizeof(int64_t);
    _76.data = jpl_alloc(_78);
    int64_t _79 = 0; // p
    int64_t _80 = 0; // o
    _jump1068:; // Begin body of loop
    int64_t _81 = 779;
    int64_t _82 = 0;
    _82 *= _76.d0;
    _82 += _80;
    _82 *= _76.d1;
    _82 += _79;
    _76.data[_82] = _81;
    _79++;
    if (_79 < h)
    goto _jump1068;
    _79 = 0;
    _80++;
    if (_80 < _77)
    goto _jump1068;
    // End body of loop
    _75 = _76;
    goto _jump1069;
    _jump1065:;
    _a2_int64_t _83;
    // Computing bound for o
    _83.d0 = j;
    if (j > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing bound for p
    _83.d1 = i;
    if (i > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= j;
    _84 *= i;
    _84 *= sizeof(int64_t);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // p
    int64_t _86 = 0; // o
    _jump1072:; // Begin body of loop
    int64_t _87 = 0;
    _87 *= _83.d0;
    _87 += _86;
    _87 *= _83.d1;
    _87 += _85;
    _83.data[_87] = c;
    _85++;
    if (_85 < i)
    goto _jump1072;
    _85 = 0;
    _86++;
    if (_86 < j)
    goto _jump1072;
    // End body of loop
    _a2_int64_t _88;
    // Computing bound for o
    _88.d0 = c;
    if (c > 0) 
    goto _jump1073;
    fail_assertion("non-positive loop bound");
    _jump1073:;
    // Computing bound for p
    _88.d1 = j;
    if (j > 0) 
    goto _jump1074;
    fail_assertion("non-positive loop bound");
    _jump1074:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= c;
    _89 *= j;
    _89 *= sizeof(int64_t);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // p
    int64_t _91 = 0; // o
    _jump1075:; // Begin body of loop
    int64_t _92 = 10;
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _91;
    _93 *= _88.d1;
    _93 += _90;
    _88.data[_93] = _92;
    _90++;
    if (_90 < j)
    goto _jump1075;
    _90 = 0;
    _91++;
    if (_91 < c)
    goto _jump1075;
    // End body of loop
    _a1__a2_int64_t _94;
    _94.d0 = 2;
    _94.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _94.data[0] = _83;
    _94.data[1] = _88;
    double _95 = 22.0;
    bool _96 = _95 <= _0;
    int64_t _97;
    if (!_96)
    goto _jump1076;
    _97 = b;
    goto _jump1077;
    _jump1076:;
    int64_t _98 = 501;
    _97 = _98;
    _jump1077:;
    if (_97 >= 0)
    goto _jump1078;
    fail_assertion("negative array index");
    _jump1078:;
    if (_97 < _94.d0)
    goto _jump1079;
    fail_assertion("index too large");
    _jump1079:;
    int64_t _99 = 0;
    _99 *= _94.d0;
    _99 += _97;
    _a2_int64_t _100 = _94.data[_99];
    _75 = _100;
    _jump1069:;
    _a1__a2_int64_t _101;
    // Computing bound for o
    _101.d0 = j;
    if (j > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= j;
    _102 *= sizeof(_a2_int64_t);
    _101.data = jpl_alloc(_102);
    int64_t _103 = 0; // o
    _jump1081:; // Begin body of loop
    _a2_int64_t _104;
    // Computing bound for p
    int64_t _105;
    // Computing bound for p
    if (j > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    // Computing bound for q
    int64_t _106 = 705;
    if (_106 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    _105 = 0;
    int64_t _107 = 0; // q
    int64_t _108 = 0; // p
    _jump1084:; // Begin body of loop
    _105 += i;
    _107++;
    if (_107 < _106)
    goto _jump1084;
    _107 = 0;
    _108++;
    if (_108 < j)
    goto _jump1084;
    // End body of loop
    _104.d0 = _105;
    if (_105 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing bound for q
    _104.d1 = h;
    if (h > 0) 
    goto _jump1086;
    fail_assertion("non-positive loop bound");
    _jump1086:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= _105;
    _109 *= h;
    _109 *= sizeof(int64_t);
    _104.data = jpl_alloc(_109);
    int64_t _110 = 0; // q
    int64_t _111 = 0; // p
    _jump1087:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _104.d0;
    _112 += _111;
    _112 *= _104.d1;
    _112 += _110;
    _104.data[_112] = h;
    _110++;
    if (_110 < h)
    goto _jump1087;
    _110 = 0;
    _111++;
    if (_111 < _105)
    goto _jump1087;
    // End body of loop
    int64_t _113 = 0;
    _113 *= _101.d0;
    _113 += _103;
    _101.data[_113] = _104;
    _103++;
    if (_103 < j)
    goto _jump1081;
    // End body of loop
    bool _114 = h != h;
    int64_t _115;
    if (!_114)
    goto _jump1088;
    _115 = i;
    goto _jump1089;
    _jump1088:;
    _115 = c;
    _jump1089:;
    if (_115 >= 0)
    goto _jump1090;
    fail_assertion("negative array index");
    _jump1090:;
    if (_115 < _101.d0)
    goto _jump1091;
    fail_assertion("index too large");
    _jump1091:;
    int64_t _116 = 0;
    _116 *= _101.d0;
    _116 += _115;
    _a2_int64_t _117 = _101.data[_116];
    _a1__a2_int64_t _118;
    _118.d0 = 2;
    _118.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _118.data[0] = _75;
    _118.data[1] = _117;
    _38 = _118;
    _jump1061:;
    bool _120 = j <= h;
    bool _121;
    if (!_120)
    goto _jump1092;
    bool _122 = false;
    _121 = _122;
    goto _jump1093;
    _jump1092:;
    bool _123 = true;
    bool _124 = !_123;
    _121 = _124;
    _jump1093:;
    bool _125 = !_121;
    bool _119 = _125;
    if (0 != _125)
    goto _jump1094;
    _a3_double _126;
    // Computing bound for o
    int64_t _127 = 460;
    _126.d0 = _127;
    if (_127 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing bound for p
    _126.d1 = h;
    if (h > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    // Computing bound for q
    _126.d2 = b;
    if (b > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _127;
    _128 *= h;
    _128 *= b;
    _128 *= sizeof(double);
    _126.data = jpl_alloc(_128);
    int64_t _129 = 0; // q
    int64_t _130 = 0; // p
    int64_t _131 = 0; // o
    _jump1098:; // Begin body of loop
    double _132 = 39.0;
    int64_t _133 = 0;
    _133 *= _126.d0;
    _133 += _131;
    _133 *= _126.d1;
    _133 += _130;
    _133 *= _126.d2;
    _133 += _129;
    _126.data[_133] = _132;
    _129++;
    if (_129 < b)
    goto _jump1098;
    _129 = 0;
    _130++;
    if (_130 < h)
    goto _jump1098;
    _130 = 0;
    _131++;
    if (_131 < _127)
    goto _jump1098;
    // End body of loop
    if (c >= 0)
    goto _jump1099;
    fail_assertion("negative array index");
    _jump1099:;
    if (c < _126.d0)
    goto _jump1100;
    fail_assertion("index too large");
    _jump1100:;
    if (i >= 0)
    goto _jump1101;
    fail_assertion("negative array index");
    _jump1101:;
    if (i < _126.d1)
    goto _jump1102;
    fail_assertion("index too large");
    _jump1102:;
    if (c >= 0)
    goto _jump1103;
    fail_assertion("negative array index");
    _jump1103:;
    if (c < _126.d2)
    goto _jump1104;
    fail_assertion("index too large");
    _jump1104:;
    int64_t _134 = 0;
    _134 *= _126.d0;
    _134 += c;
    _134 *= _126.d1;
    _134 += i;
    _134 *= _126.d2;
    _134 += c;
    double _135 = _126.data[_134];
    double _136;
    // Computing bound for o
    int64_t _137 = 16;
    if (_137 > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing bound for p
    if (i > 0) 
    goto _jump1106;
    fail_assertion("non-positive loop bound");
    _jump1106:;
    // Computing bound for q
    if (j > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    _136 = 0;
    int64_t _138 = 0; // q
    int64_t _139 = 0; // p
    int64_t _140 = 0; // o
    _jump1108:; // Begin body of loop
    _136 += _0;
    _138++;
    if (_138 < j)
    goto _jump1108;
    _138 = 0;
    _139++;
    if (_139 < i)
    goto _jump1108;
    _139 = 0;
    _140++;
    if (_140 < _137)
    goto _jump1108;
    // End body of loop
    double _141 = -_136;
    bool _142 = _135 < _141;
    _119 = _142;
    _jump1094:;
    int64_t _143;
    if (!_119)
    goto _jump1109;
    int64_t _144;
    // Computing bound for o
    if (i > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for p
    int64_t _145;
    // Computing bound for o
    int64_t _146 = 732;
    if (_146 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for p
    if (i > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing bound for q
    int64_t _147 = 539;
    int64_t _148 = -_147;
    if (_148 > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    _145 = 0;
    int64_t _149 = 0; // q
    int64_t _150 = 0; // p
    int64_t _151 = 0; // o
    _jump1114:; // Begin body of loop
    _145 += j;
    _149++;
    if (_149 < _148)
    goto _jump1114;
    _149 = 0;
    _150++;
    if (_150 < i)
    goto _jump1114;
    _150 = 0;
    _151++;
    if (_151 < _146)
    goto _jump1114;
    // End body of loop
    if (_145 > 0) 
    goto _jump1115;
    fail_assertion("non-positive loop bound");
    _jump1115:;
    // Computing bound for q
    _a2_int64_t _152;
    // Computing bound for o
    _152.d0 = d;
    if (d > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for p
    int64_t _153 = 302;
    _152.d1 = _153;
    if (_153 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= d;
    _154 *= _153;
    _154 *= sizeof(int64_t);
    _152.data = jpl_alloc(_154);
    int64_t _155 = 0; // p
    int64_t _156 = 0; // o
    _jump1118:; // Begin body of loop
    int64_t _157 = -h;
    int64_t _158 = 0;
    _158 *= _152.d0;
    _158 += _156;
    _158 *= _152.d1;
    _158 += _155;
    _152.data[_158] = _157;
    _155++;
    if (_155 < _153)
    goto _jump1118;
    _155 = 0;
    _156++;
    if (_156 < d)
    goto _jump1118;
    // End body of loop
    if (c >= 0)
    goto _jump1119;
    fail_assertion("negative array index");
    _jump1119:;
    if (c < _152.d0)
    goto _jump1120;
    fail_assertion("index too large");
    _jump1120:;
    if (d >= 0)
    goto _jump1121;
    fail_assertion("negative array index");
    _jump1121:;
    if (d < _152.d1)
    goto _jump1122;
    fail_assertion("index too large");
    _jump1122:;
    int64_t _159 = 0;
    _159 *= _152.d0;
    _159 += c;
    _159 *= _152.d1;
    _159 += d;
    int64_t _160 = _152.data[_159];
    if (_160 > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    _144 = 0;
    int64_t _161 = 0; // q
    int64_t _162 = 0; // p
    int64_t _163 = 0; // o
    _jump1124:; // Begin body of loop
    int64_t _164 = _162 * b;
    _144 += _164;
    _161++;
    if (_161 < _160)
    goto _jump1124;
    _161 = 0;
    _162++;
    if (_162 < _145)
    goto _jump1124;
    _162 = 0;
    _163++;
    if (_163 < i)
    goto _jump1124;
    // End body of loop
    _143 = _144;
    goto _jump1125;
    _jump1109:;
    int64_t _165 = -b;
    _143 = _165;
    _jump1125:;
    int64_t _166 = -c;
    int64_t _167 = _143 - _166;
    if (_167 >= 0)
    goto _jump1126;
    fail_assertion("negative array index");
    _jump1126:;
    if (_167 < _38.d0)
    goto _jump1127;
    fail_assertion("index too large");
    _jump1127:;
    int64_t _168 = 0;
    _168 *= _38.d0;
    _168 += _167;
    _a2_int64_t _169 = _38.data[_168];
    int64_t _170 = -c;
    _a2_double _171;
    // Computing bound for t
    _171.d0 = _169.d0;
    if (_169.d0 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    // Computing bound for u
    int64_t _172;
    // Computing bound for t
    if (i > 0) 
    goto _jump1129;
    fail_assertion("non-positive loop bound");
    _jump1129:;
    // Computing bound for u
    int64_t _173 = 623;
    if (_173 > 0) 
    goto _jump1130;
    fail_assertion("non-positive loop bound");
    _jump1130:;
    _172 = 0;
    int64_t _174 = 0; // u
    int64_t _175 = 0; // t
    _jump1131:; // Begin body of loop
    _172 += i;
    _174++;
    if (_174 < _173)
    goto _jump1131;
    _174 = 0;
    _175++;
    if (_175 < i)
    goto _jump1131;
    // End body of loop
    _171.d1 = _172;
    if (_172 > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= _169.d0;
    _176 *= _172;
    _176 *= sizeof(double);
    _171.data = jpl_alloc(_176);
    int64_t _177 = 0; // u
    int64_t _178 = 0; // t
    _jump1133:; // Begin body of loop
    int64_t _179 = 0;
    _179 *= _171.d0;
    _179 += _178;
    _179 *= _171.d1;
    _179 += _177;
    _171.data[_179] = _0;
    _177++;
    if (_177 < _172)
    goto _jump1133;
    _177 = 0;
    _178++;
    if (_178 < _169.d0)
    goto _jump1133;
    // End body of loop
    _a3_bool _180;
    // Computing bound for t
    int64_t _181 = 71;
    int64_t _182 = _169.d0 + _181;
    _180.d0 = _182;
    if (_182 > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    // Computing bound for u
    _180.d1 = b;
    if (b > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    // Computing bound for v
    _180.d2 = c;
    if (c > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= _182;
    _183 *= b;
    _183 *= c;
    _183 *= sizeof(bool);
    _180.data = jpl_alloc(_183);
    int64_t _184 = 0; // v
    int64_t _185 = 0; // u
    int64_t _186 = 0; // t
    _jump1137:; // Begin body of loop
    bool _187 = _170 != i;
    int64_t _188 = 0;
    _188 *= _180.d0;
    _188 += _186;
    _188 *= _180.d1;
    _188 += _185;
    _188 *= _180.d2;
    _188 += _184;
    _180.data[_188] = _187;
    _184++;
    if (_184 < c)
    goto _jump1137;
    _184 = 0;
    _185++;
    if (_185 < b)
    goto _jump1137;
    _185 = 0;
    _186++;
    if (_186 < _182)
    goto _jump1137;
    // End body of loop
    if (_170 >= 0)
    goto _jump1138;
    fail_assertion("negative array index");
    _jump1138:;
    if (_170 < _180.d0)
    goto _jump1139;
    fail_assertion("index too large");
    _jump1139:;
    if (_169.d1 >= 0)
    goto _jump1140;
    fail_assertion("negative array index");
    _jump1140:;
    if (_169.d1 < _180.d1)
    goto _jump1141;
    fail_assertion("index too large");
    _jump1141:;
    if (d >= 0)
    goto _jump1142;
    fail_assertion("negative array index");
    _jump1142:;
    if (d < _180.d2)
    goto _jump1143;
    fail_assertion("index too large");
    _jump1143:;
    int64_t _189 = 0;
    _189 *= _180.d0;
    _189 += _170;
    _189 *= _180.d1;
    _189 += _169.d1;
    _189 *= _180.d2;
    _189 += d;
    bool _190 = _180.data[_189];
    _a1_int64_t _191;
    if (!_190)
    goto _jump1144;
    _a1_int64_t _192;
    // Computing bound for t
    _192.d0 = h;
    if (h > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= h;
    _193 *= sizeof(int64_t);
    _192.data = jpl_alloc(_193);
    int64_t _194 = 0; // t
    _jump1146:; // Begin body of loop
    int64_t _195 = -_169.d1;
    int64_t _196 = 0;
    _196 *= _192.d0;
    _196 += _194;
    _192.data[_196] = _195;
    _194++;
    if (_194 < h)
    goto _jump1146;
    // End body of loop
    _191 = _192;
    goto _jump1147;
    _jump1144:;
    _a3__a1_int64_t _197;
    // Computing bound for t
    _197.d0 = j;
    if (j > 0) 
    goto _jump1148;
    fail_assertion("non-positive loop bound");
    _jump1148:;
    // Computing bound for u
    _197.d1 = i;
    if (i > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    // Computing bound for v
    int64_t _198;
    // Computing bound for t
    if (_170 > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    // Computing bound for u
    if (j > 0) 
    goto _jump1151;
    fail_assertion("non-positive loop bound");
    _jump1151:;
    _198 = 0;
    int64_t _199 = 0; // u
    int64_t _200 = 0; // t
    _jump1152:; // Begin body of loop
    _198 += _169.d1;
    _199++;
    if (_199 < j)
    goto _jump1152;
    _199 = 0;
    _200++;
    if (_200 < _170)
    goto _jump1152;
    // End body of loop
    _197.d2 = _198;
    if (_198 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    // Computing total size of heap memory to allocate
    int64_t _201 = 1;
    _201 *= j;
    _201 *= i;
    _201 *= _198;
    _201 *= sizeof(_a1_int64_t);
    _197.data = jpl_alloc(_201);
    int64_t _202 = 0; // v
    int64_t _203 = 0; // u
    int64_t _204 = 0; // t
    _jump1154:; // Begin body of loop
    int64_t _205 = 993;
    _a1_int64_t _206;
    _206.d0 = 3;
    _206.data = jpl_alloc(sizeof(int64_t) * 3);
    _206.data[0] = _205;
    _206.data[1] = _170;
    _206.data[2] = _169.d1;
    int64_t _207 = 0;
    _207 *= _197.d0;
    _207 += _204;
    _207 *= _197.d1;
    _207 += _203;
    _207 *= _197.d2;
    _207 += _202;
    _197.data[_207] = _206;
    _202++;
    if (_202 < _198)
    goto _jump1154;
    _202 = 0;
    _203++;
    if (_203 < i)
    goto _jump1154;
    _203 = 0;
    _204++;
    if (_204 < j)
    goto _jump1154;
    // End body of loop
    bool _208 = false;
    int64_t _209;
    if (!_208)
    goto _jump1155;
    _209 = d;
    goto _jump1156;
    _jump1155:;
    _209 = j;
    _jump1156:;
    int64_t _210 = _169.d1 - j;
    if (_169.d1 >= 0)
    goto _jump1157;
    fail_assertion("negative array index");
    _jump1157:;
    if (_169.d1 < _197.d0)
    goto _jump1158;
    fail_assertion("index too large");
    _jump1158:;
    if (_209 >= 0)
    goto _jump1159;
    fail_assertion("negative array index");
    _jump1159:;
    if (_209 < _197.d1)
    goto _jump1160;
    fail_assertion("index too large");
    _jump1160:;
    if (_210 >= 0)
    goto _jump1161;
    fail_assertion("negative array index");
    _jump1161:;
    if (_210 < _197.d2)
    goto _jump1162;
    fail_assertion("index too large");
    _jump1162:;
    int64_t _211 = 0;
    _211 *= _197.d0;
    _211 += _169.d1;
    _211 *= _197.d1;
    _211 += _209;
    _211 *= _197.d2;
    _211 += _210;
    _a1_int64_t _212 = _197.data[_211];
    _191 = _212;
    _jump1147:;
    if (j >= 0)
    goto _jump1163;
    fail_assertion("negative array index");
    _jump1163:;
    if (j < _191.d0)
    goto _jump1164;
    fail_assertion("index too large");
    _jump1164:;
    int64_t _213 = 0;
    _213 *= _191.d0;
    _213 += j;
    int64_t _214 = _191.data[_213];
    if (h >= 0)
    goto _jump1165;
    fail_assertion("negative array index");
    _jump1165:;
    if (h < _171.d0)
    goto _jump1166;
    fail_assertion("index too large");
    _jump1166:;
    if (_214 >= 0)
    goto _jump1167;
    fail_assertion("negative array index");
    _jump1167:;
    if (_214 < _171.d1)
    goto _jump1168;
    fail_assertion("index too large");
    _jump1168:;
    int64_t _215 = 0;
    _215 *= _171.d0;
    _215 += h;
    _215 *= _171.d1;
    _215 += _214;
    double _216 = _171.data[_215];
    int64_t _217 = 861;
    if (h >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (h < _169.d0)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    if (_217 >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (_217 < _169.d1)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    int64_t _218 = 0;
    _218 *= _169.d0;
    _218 += h;
    _218 *= _169.d1;
    _218 += _217;
    int64_t _219 = _169.data[_218];
    int64_t _220 = -b;
    bool _221 = _219 > _220;
    double _222 = 77.0;
    double _223 = 46.0;
    bool _224 = _222 != _223;
    bool _225 = _221 == _224;
    bool _226 = !_225;
    bool _227;
    if (!_226)
    goto _jump1173;
    int64_t _229 = 22;
    bool _230 = d > _229;
    bool _228 = _230;
    if (0 == _230)
    goto _jump1174;
    _a2_bool _231;
    // Computing bound for t
    _231.d0 = h;
    if (h > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    // Computing bound for u
    _231.d1 = b;
    if (b > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= h;
    _232 *= b;
    _232 *= sizeof(bool);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // u
    int64_t _234 = 0; // t
    _jump1177:; // Begin body of loop
    bool _235 = true;
    int64_t _236 = 0;
    _236 *= _231.d0;
    _236 += _234;
    _236 *= _231.d1;
    _236 += _233;
    _231.data[_236] = _235;
    _233++;
    if (_233 < b)
    goto _jump1177;
    _233 = 0;
    _234++;
    if (_234 < h)
    goto _jump1177;
    // End body of loop
    if (_169.d0 >= 0)
    goto _jump1178;
    fail_assertion("negative array index");
    _jump1178:;
    if (_169.d0 < _231.d0)
    goto _jump1179;
    fail_assertion("index too large");
    _jump1179:;
    if (_170 >= 0)
    goto _jump1180;
    fail_assertion("negative array index");
    _jump1180:;
    if (_170 < _231.d1)
    goto _jump1181;
    fail_assertion("index too large");
    _jump1181:;
    int64_t _237 = 0;
    _237 *= _231.d0;
    _237 += _169.d0;
    _237 *= _231.d1;
    _237 += _170;
    bool _238 = _231.data[_237];
    bool _240 = l >= l;
    bool _239 = _240;
    if (0 != _240)
    goto _jump1182;
    bool _241 = true;
    _239 = _241;
    _jump1182:;
    bool _242 = _238 == _239;
    _228 = _242;
    _jump1174:;
    _227 = _228;
    goto _jump1183;
    _jump1173:;
    bool _243 = j == j;
    bool _244 = !_243;
    _227 = _244;
    _jump1183:;
    void_t _245;
    if (!_227)
    goto _jump1184;
    _245 = m;
    goto _jump1185;
    _jump1184:;
    _245 = m;
    _jump1185:;
    _a1_rgba _246 = k(_216, _245);
    double _247;
    // Computing bound for v
    if (_169.d1 > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    _247 = 0;
    int64_t _248 = 0; // v
    _jump1187:; // Begin body of loop
    double _249 = 98.0;
    double _250;
    // Computing bound for w
    if (_169.d1 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    _250 = 0;
    int64_t _251 = 0; // w
    _jump1189:; // Begin body of loop
    double _252 = 25.0;
    _250 += _252;
    _251++;
    if (_251 < _169.d1)
    goto _jump1189;
    // End body of loop
    double _253 = _249 / _250;
    double _254 = -_253;
    _247 += _254;
    _248++;
    if (_248 < _169.d1)
    goto _jump1187;
    // End body of loop
    bool _256 = false;
    bool _257 = !_256;
    bool _255 = _257;
    if (0 != _257)
    goto _jump1190;
    bool _258 = true;
    _255 = _258;
    _jump1190:;
    bool _259;
    if (!_255)
    goto _jump1191;
    bool _260 = c > _246.d0;
    _259 = _260;
    goto _jump1192;
    _jump1191:;
    bool _261 = false;
    _259 = _261;
    _jump1192:;
    _a3_bool _262;
    if (!_259)
    goto _jump1193;
    bool _263 = false;
    _a3_bool _264;
    if (!_263)
    goto _jump1194;
    _264 = a;
    goto _jump1195;
    _jump1194:;
    _264 = a;
    _jump1195:;
    _a1__a3_bool _265;
    _265.d0 = 1;
    _265.data = jpl_alloc(sizeof(_a3_bool) * 1);
    _265.data[0] = _264;
    if (i >= 0)
    goto _jump1196;
    fail_assertion("negative array index");
    _jump1196:;
    if (i < _265.d0)
    goto _jump1197;
    fail_assertion("index too large");
    _jump1197:;
    int64_t _266 = 0;
    _266 *= _265.d0;
    _266 += i;
    _a3_bool _267 = _265.data[_266];
    _262 = _267;
    goto _jump1198;
    _jump1193:;
    bool _268 = false;
    _a2__a3_bool _269;
    if (!_268)
    goto _jump1199;
    _a2__a3_bool _270;
    // Computing bound for v
    _270.d0 = _246.d0;
    if (_246.d0 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing bound for w
    _270.d1 = b;
    if (b > 0) 
    goto _jump1201;
    fail_assertion("non-positive loop bound");
    _jump1201:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= _246.d0;
    _271 *= b;
    _271 *= sizeof(_a3_bool);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // w
    int64_t _273 = 0; // v
    _jump1202:; // Begin body of loop
    int64_t _274 = 0;
    _274 *= _270.d0;
    _274 += _273;
    _274 *= _270.d1;
    _274 += _272;
    _270.data[_274] = a;
    _272++;
    if (_272 < b)
    goto _jump1202;
    _272 = 0;
    _273++;
    if (_273 < _246.d0)
    goto _jump1202;
    // End body of loop
    _269 = _270;
    goto _jump1203;
    _jump1199:;
    _a2__a3_bool _275;
    // Computing bound for v
    _275.d0 = _246.d0;
    if (_246.d0 > 0) 
    goto _jump1204;
    fail_assertion("non-positive loop bound");
    _jump1204:;
    // Computing bound for w
    int64_t _276 = 675;
    _275.d1 = _276;
    if (_276 > 0) 
    goto _jump1205;
    fail_assertion("non-positive loop bound");
    _jump1205:;
    // Computing total size of heap memory to allocate
    int64_t _277 = 1;
    _277 *= _246.d0;
    _277 *= _276;
    _277 *= sizeof(_a3_bool);
    _275.data = jpl_alloc(_277);
    int64_t _278 = 0; // w
    int64_t _279 = 0; // v
    _jump1206:; // Begin body of loop
    int64_t _280 = 0;
    _280 *= _275.d0;
    _280 += _279;
    _280 *= _275.d1;
    _280 += _278;
    _275.data[_280] = a;
    _278++;
    if (_278 < _276)
    goto _jump1206;
    _278 = 0;
    _279++;
    if (_279 < _246.d0)
    goto _jump1206;
    // End body of loop
    _269 = _275;
    _jump1203:;
    int64_t _281;
    // Computing bound for v
    if (b > 0) 
    goto _jump1207;
    fail_assertion("non-positive loop bound");
    _jump1207:;
    // Computing bound for w
    if (_170 > 0) 
    goto _jump1208;
    fail_assertion("non-positive loop bound");
    _jump1208:;
    // Computing bound for x
    if (j > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    _281 = 0;
    int64_t _282 = 0; // x
    int64_t _283 = 0; // w
    int64_t _284 = 0; // v
    _jump1210:; // Begin body of loop
    _281 += i;
    _282++;
    if (_282 < j)
    goto _jump1210;
    _282 = 0;
    _283++;
    if (_283 < _170)
    goto _jump1210;
    _283 = 0;
    _284++;
    if (_284 < b)
    goto _jump1210;
    // End body of loop
    if (d >= 0)
    goto _jump1211;
    fail_assertion("negative array index");
    _jump1211:;
    if (d < _269.d0)
    goto _jump1212;
    fail_assertion("index too large");
    _jump1212:;
    if (_281 >= 0)
    goto _jump1213;
    fail_assertion("negative array index");
    _jump1213:;
    if (_281 < _269.d1)
    goto _jump1214;
    fail_assertion("index too large");
    _jump1214:;
    int64_t _285 = 0;
    _285 *= _269.d0;
    _285 += d;
    _285 *= _269.d1;
    _285 += _281;
    _a3_bool _286 = _269.data[_285];
    _262 = _286;
    _jump1198:;
    int64_t _287;
    // Computing bound for v
    if (_170 > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    // Computing bound for w
    if (b > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    _287 = 0;
    int64_t _288 = 0; // w
    int64_t _289 = 0; // v
    _jump1217:; // Begin body of loop
    _287 += _169.d0;
    _288++;
    if (_288 < b)
    goto _jump1217;
    _288 = 0;
    _289++;
    if (_289 < _170)
    goto _jump1217;
    // End body of loop
    bool _290 = b == _287;
    bool _291 = !_290;
    int64_t _292;
    if (!_291)
    goto _jump1218;
    _292 = h;
    goto _jump1219;
    _jump1218:;
    _292 = i;
    _jump1219:;
    _a3_int64_t _293;
    // Computing bound for v
    int64_t _294 = 78;
    bool _295 = _169.d1 >= _294;
    int64_t _296;
    if (!_295)
    goto _jump1220;
    _296 = b;
    goto _jump1221;
    _jump1220:;
    _296 = _169.d1;
    _jump1221:;
    _293.d0 = _296;
    if (_296 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for w
    _293.d1 = h;
    if (h > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing bound for x
    _293.d2 = _169.d0;
    if (_169.d0 > 0) 
    goto _jump1224;
    fail_assertion("non-positive loop bound");
    _jump1224:;
    // Computing total size of heap memory to allocate
    int64_t _297 = 1;
    _297 *= _296;
    _297 *= h;
    _297 *= _169.d0;
    _297 *= sizeof(int64_t);
    _293.data = jpl_alloc(_297);
    int64_t _298 = 0; // x
    int64_t _299 = 0; // w
    int64_t _300 = 0; // v
    _jump1225:; // Begin body of loop
    bool _301 = false;
    int64_t _302;
    if (!_301)
    goto _jump1226;
    int64_t _303 = 262;
    _302 = _303;
    goto _jump1227;
    _jump1226:;
    _302 = _299;
    _jump1227:;
    int64_t _304 = _302 % _299;
    int64_t _305 = 0;
    _305 *= _293.d0;
    _305 += _300;
    _305 *= _293.d1;
    _305 += _299;
    _305 *= _293.d2;
    _305 += _298;
    _293.data[_305] = _304;
    _298++;
    if (_298 < _169.d0)
    goto _jump1225;
    _298 = 0;
    _299++;
    if (_299 < h)
    goto _jump1225;
    _299 = 0;
    _300++;
    if (_300 < _296)
    goto _jump1225;
    // End body of loop
    int64_t _306 = j / j;
    int64_t _307 = i * _306;
    if (_307 >= 0)
    goto _jump1228;
    fail_assertion("negative array index");
    _jump1228:;
    if (_307 < _293.d0)
    goto _jump1229;
    fail_assertion("index too large");
    _jump1229:;
    if (h >= 0)
    goto _jump1230;
    fail_assertion("negative array index");
    _jump1230:;
    if (h < _293.d1)
    goto _jump1231;
    fail_assertion("index too large");
    _jump1231:;
    if (j >= 0)
    goto _jump1232;
    fail_assertion("negative array index");
    _jump1232:;
    if (j < _293.d2)
    goto _jump1233;
    fail_assertion("index too large");
    _jump1233:;
    int64_t _308 = 0;
    _308 *= _293.d0;
    _308 += _307;
    _308 *= _293.d1;
    _308 += h;
    _308 *= _293.d2;
    _308 += j;
    int64_t _309 = _293.data[_308];
    if (c >= 0)
    goto _jump1234;
    fail_assertion("negative array index");
    _jump1234:;
    if (c < _262.d0)
    goto _jump1235;
    fail_assertion("index too large");
    _jump1235:;
    if (_292 >= 0)
    goto _jump1236;
    fail_assertion("negative array index");
    _jump1236:;
    if (_292 < _262.d1)
    goto _jump1237;
    fail_assertion("index too large");
    _jump1237:;
    if (_309 >= 0)
    goto _jump1238;
    fail_assertion("negative array index");
    _jump1238:;
    if (_309 < _262.d2)
    goto _jump1239;
    fail_assertion("index too large");
    _jump1239:;
    int64_t _310 = 0;
    _310 *= _262.d0;
    _310 += c;
    _310 *= _262.d1;
    _310 += _292;
    _310 *= _262.d2;
    _310 += _309;
    bool _311 = _262.data[_310];
    void_t _312;
    if (!_311)
    goto _jump1240;
    _a3__a2_void_t _313;
    // Computing bound for v
    int64_t _314 = d + h;
    int64_t _315 = -_314;
    _313.d0 = _315;
    if (_315 > 0) 
    goto _jump1241;
    fail_assertion("non-positive loop bound");
    _jump1241:;
    // Computing bound for w
    _313.d1 = b;
    if (b > 0) 
    goto _jump1242;
    fail_assertion("non-positive loop bound");
    _jump1242:;
    // Computing bound for x
    int64_t _316 = 502;
    _313.d2 = _316;
    if (_316 > 0) 
    goto _jump1243;
    fail_assertion("non-positive loop bound");
    _jump1243:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= _315;
    _317 *= b;
    _317 *= _316;
    _317 *= sizeof(_a2_void_t);
    _313.data = jpl_alloc(_317);
    int64_t _318 = 0; // x
    int64_t _319 = 0; // w
    int64_t _320 = 0; // v
    _jump1244:; // Begin body of loop
    double _321 = 32.0;
    bool _322 = l != _321;
    _a2_void_t _323;
    if (!_322)
    goto _jump1245;
    _a2_void_t _324;
    // Computing bound for y
    _324.d0 = _319;
    if (_319 > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing bound for z
    _324.d1 = _170;
    if (_170 > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= _319;
    _325 *= _170;
    _325 *= sizeof(void_t);
    _324.data = jpl_alloc(_325);
    int64_t _326 = 0; // z
    int64_t _327 = 0; // y
    _jump1248:; // Begin body of loop
    int64_t _328 = 0;
    _328 *= _324.d0;
    _328 += _327;
    _328 *= _324.d1;
    _328 += _326;
    _324.data[_328] = m;
    _326++;
    if (_326 < _170)
    goto _jump1248;
    _326 = 0;
    _327++;
    if (_327 < _319)
    goto _jump1248;
    // End body of loop
    _323 = _324;
    goto _jump1249;
    _jump1245:;
    _a2_void_t _329;
    // Computing bound for y
    _329.d0 = c;
    if (c > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing bound for z
    _329.d1 = h;
    if (h > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= c;
    _330 *= h;
    _330 *= sizeof(void_t);
    _329.data = jpl_alloc(_330);
    int64_t _331 = 0; // z
    int64_t _332 = 0; // y
    _jump1252:; // Begin body of loop
    int64_t _333 = 0;
    _333 *= _329.d0;
    _333 += _332;
    _333 *= _329.d1;
    _333 += _331;
    _329.data[_333] = m;
    _331++;
    if (_331 < h)
    goto _jump1252;
    _331 = 0;
    _332++;
    if (_332 < c)
    goto _jump1252;
    // End body of loop
    _323 = _329;
    _jump1249:;
    int64_t _334 = 0;
    _334 *= _313.d0;
    _334 += _320;
    _334 *= _313.d1;
    _334 += _319;
    _334 *= _313.d2;
    _334 += _318;
    _313.data[_334] = _323;
    _318++;
    if (_318 < _316)
    goto _jump1244;
    _318 = 0;
    _319++;
    if (_319 < b)
    goto _jump1244;
    _319 = 0;
    _320++;
    if (_320 < _315)
    goto _jump1244;
    // End body of loop
    int64_t _335 = 265;
    int64_t _336;
    // Computing bound for v
    if (c > 0) 
    goto _jump1253;
    fail_assertion("non-positive loop bound");
    _jump1253:;
    // Computing bound for w
    if (h > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    _336 = 0;
    int64_t _337 = 0; // w
    int64_t _338 = 0; // v
    _jump1255:; // Begin body of loop
    _336 += b;
    _337++;
    if (_337 < h)
    goto _jump1255;
    _337 = 0;
    _338++;
    if (_338 < c)
    goto _jump1255;
    // End body of loop
    if (_246.d0 >= 0)
    goto _jump1256;
    fail_assertion("negative array index");
    _jump1256:;
    if (_246.d0 < _313.d0)
    goto _jump1257;
    fail_assertion("index too large");
    _jump1257:;
    if (_335 >= 0)
    goto _jump1258;
    fail_assertion("negative array index");
    _jump1258:;
    if (_335 < _313.d1)
    goto _jump1259;
    fail_assertion("index too large");
    _jump1259:;
    if (_336 >= 0)
    goto _jump1260;
    fail_assertion("negative array index");
    _jump1260:;
    if (_336 < _313.d2)
    goto _jump1261;
    fail_assertion("index too large");
    _jump1261:;
    int64_t _339 = 0;
    _339 *= _313.d0;
    _339 += _246.d0;
    _339 *= _313.d1;
    _339 += _335;
    _339 *= _313.d2;
    _339 += _336;
    _a2_void_t _340 = _313.data[_339];
    int64_t _341 = 136;
    int64_t _342 = 776;
    int64_t _343 = _341 - _342;
    if (_343 >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (_343 < _340.d0)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    if (h >= 0)
    goto _jump1264;
    fail_assertion("negative array index");
    _jump1264:;
    if (h < _340.d1)
    goto _jump1265;
    fail_assertion("index too large");
    _jump1265:;
    int64_t _344 = 0;
    _344 *= _340.d0;
    _344 += _343;
    _344 *= _340.d1;
    _344 += h;
    void_t _345 = _340.data[_344];
    _312 = _345;
    goto _jump1266;
    _jump1240:;
    _a1_bool _346;
    // Computing bound for v
    _346.d0 = d;
    if (d > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    // Computing total size of heap memory to allocate
    int64_t _347 = 1;
    _347 *= d;
    _347 *= sizeof(bool);
    _346.data = jpl_alloc(_347);
    int64_t _348 = 0; // v
    _jump1268:; // Begin body of loop
    bool _349 = false;
    int64_t _350 = 0;
    _350 *= _346.d0;
    _350 += _348;
    _346.data[_350] = _349;
    _348++;
    if (_348 < d)
    goto _jump1268;
    // End body of loop
    int64_t _351 = 132;
    if (_351 >= 0)
    goto _jump1269;
    fail_assertion("negative array index");
    _jump1269:;
    if (_351 < _346.d0)
    goto _jump1270;
    fail_assertion("index too large");
    _jump1270:;
    int64_t _352 = 0;
    _352 *= _346.d0;
    _352 += _351;
    bool _353 = _346.data[_352];
    _a2_void_t _354;
    if (!_353)
    goto _jump1271;
    _a2__a2_void_t _355;
    // Computing bound for v
    _355.d0 = _169.d1;
    if (_169.d1 > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for w
    int64_t _356 = -j;
    _355.d1 = _356;
    if (_356 > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing total size of heap memory to allocate
    int64_t _357 = 1;
    _357 *= _169.d1;
    _357 *= _356;
    _357 *= sizeof(_a2_void_t);
    _355.data = jpl_alloc(_357);
    int64_t _358 = 0; // w
    int64_t _359 = 0; // v
    _jump1274:; // Begin body of loop
    _a2_void_t _360;
    // Computing bound for x
    _360.d0 = b;
    if (b > 0) 
    goto _jump1275;
    fail_assertion("non-positive loop bound");
    _jump1275:;
    // Computing bound for y
    _360.d1 = d;
    if (d > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= b;
    _361 *= d;
    _361 *= sizeof(void_t);
    _360.data = jpl_alloc(_361);
    int64_t _362 = 0; // y
    int64_t _363 = 0; // x
    _jump1277:; // Begin body of loop
    int64_t _364 = 0;
    _364 *= _360.d0;
    _364 += _363;
    _364 *= _360.d1;
    _364 += _362;
    _360.data[_364] = m;
    _362++;
    if (_362 < d)
    goto _jump1277;
    _362 = 0;
    _363++;
    if (_363 < b)
    goto _jump1277;
    // End body of loop
    int64_t _365 = 0;
    _365 *= _355.d0;
    _365 += _359;
    _365 *= _355.d1;
    _365 += _358;
    _355.data[_365] = _360;
    _358++;
    if (_358 < _356)
    goto _jump1274;
    _358 = 0;
    _359++;
    if (_359 < _169.d1)
    goto _jump1274;
    // End body of loop
    if (c >= 0)
    goto _jump1278;
    fail_assertion("negative array index");
    _jump1278:;
    if (c < _355.d0)
    goto _jump1279;
    fail_assertion("index too large");
    _jump1279:;
    if (_169.d0 >= 0)
    goto _jump1280;
    fail_assertion("negative array index");
    _jump1280:;
    if (_169.d0 < _355.d1)
    goto _jump1281;
    fail_assertion("index too large");
    _jump1281:;
    int64_t _366 = 0;
    _366 *= _355.d0;
    _366 += c;
    _366 *= _355.d1;
    _366 += _169.d0;
    _a2_void_t _367 = _355.data[_366];
    _354 = _367;
    goto _jump1282;
    _jump1271:;
    _a2__a2_void_t _368;
    // Computing bound for v
    _368.d0 = i;
    if (i > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for w
    int64_t _369 = 701;
    _368.d1 = _369;
    if (_369 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing total size of heap memory to allocate
    int64_t _370 = 1;
    _370 *= i;
    _370 *= _369;
    _370 *= sizeof(_a2_void_t);
    _368.data = jpl_alloc(_370);
    int64_t _371 = 0; // w
    int64_t _372 = 0; // v
    _jump1285:; // Begin body of loop
    _a2_void_t _373;
    // Computing bound for x
    _373.d0 = _371;
    if (_371 > 0) 
    goto _jump1286;
    fail_assertion("non-positive loop bound");
    _jump1286:;
    // Computing bound for y
    _373.d1 = d;
    if (d > 0) 
    goto _jump1287;
    fail_assertion("non-positive loop bound");
    _jump1287:;
    // Computing total size of heap memory to allocate
    int64_t _374 = 1;
    _374 *= _371;
    _374 *= d;
    _374 *= sizeof(void_t);
    _373.data = jpl_alloc(_374);
    int64_t _375 = 0; // y
    int64_t _376 = 0; // x
    _jump1288:; // Begin body of loop
    int64_t _377 = 0;
    _377 *= _373.d0;
    _377 += _376;
    _377 *= _373.d1;
    _377 += _375;
    _373.data[_377] = m;
    _375++;
    if (_375 < d)
    goto _jump1288;
    _375 = 0;
    _376++;
    if (_376 < _371)
    goto _jump1288;
    // End body of loop
    int64_t _378 = 0;
    _378 *= _368.d0;
    _378 += _372;
    _378 *= _368.d1;
    _378 += _371;
    _368.data[_378] = _373;
    _371++;
    if (_371 < _369)
    goto _jump1285;
    _371 = 0;
    _372++;
    if (_372 < i)
    goto _jump1285;
    // End body of loop
    if (d >= 0)
    goto _jump1289;
    fail_assertion("negative array index");
    _jump1289:;
    if (d < _368.d0)
    goto _jump1290;
    fail_assertion("index too large");
    _jump1290:;
    if (c >= 0)
    goto _jump1291;
    fail_assertion("negative array index");
    _jump1291:;
    if (c < _368.d1)
    goto _jump1292;
    fail_assertion("index too large");
    _jump1292:;
    int64_t _379 = 0;
    _379 *= _368.d0;
    _379 += d;
    _379 *= _368.d1;
    _379 += c;
    _a2_void_t _380 = _368.data[_379];
    _354 = _380;
    _jump1282:;
    int64_t _381 = 620;
    if (_381 >= 0)
    goto _jump1293;
    fail_assertion("negative array index");
    _jump1293:;
    if (_381 < g.d0)
    goto _jump1294;
    fail_assertion("index too large");
    _jump1294:;
    if (_170 >= 0)
    goto _jump1295;
    fail_assertion("negative array index");
    _jump1295:;
    if (_170 < g.d1)
    goto _jump1296;
    fail_assertion("index too large");
    _jump1296:;
    if (c >= 0)
    goto _jump1297;
    fail_assertion("negative array index");
    _jump1297:;
    if (c < g.d2)
    goto _jump1298;
    fail_assertion("index too large");
    _jump1298:;
    int64_t _382 = 0;
    _382 *= g.d0;
    _382 += _381;
    _382 *= g.d1;
    _382 += _170;
    _382 *= g.d2;
    _382 += c;
    int64_t _383 = g.data[_382];
    if (h >= 0)
    goto _jump1299;
    fail_assertion("negative array index");
    _jump1299:;
    if (h < _169.d0)
    goto _jump1300;
    fail_assertion("index too large");
    _jump1300:;
    if (b >= 0)
    goto _jump1301;
    fail_assertion("negative array index");
    _jump1301:;
    if (b < _169.d1)
    goto _jump1302;
    fail_assertion("index too large");
    _jump1302:;
    int64_t _384 = 0;
    _384 *= _169.d0;
    _384 += h;
    _384 *= _169.d1;
    _384 += b;
    int64_t _385 = _169.data[_384];
    if (_383 >= 0)
    goto _jump1303;
    fail_assertion("negative array index");
    _jump1303:;
    if (_383 < _354.d0)
    goto _jump1304;
    fail_assertion("index too large");
    _jump1304:;
    if (_385 >= 0)
    goto _jump1305;
    fail_assertion("negative array index");
    _jump1305:;
    if (_385 < _354.d1)
    goto _jump1306;
    fail_assertion("index too large");
    _jump1306:;
    int64_t _386 = 0;
    _386 *= _354.d0;
    _386 += _383;
    _386 *= _354.d1;
    _386 += _385;
    void_t _387 = _354.data[_386];
    _312 = _387;
    _jump1266:;
    _a1_rgba _388 = k(_247, _312);
    return _388;
}

void_t l() {
    void_t _0 = l();
    return _0;
    _a2_void_t _1;
    // Computing bound for m
    int64_t _2 = 596;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing bound for n
    double _3 = 79.0;
    double _4 = -_3;
    double _5 = 58.0;
    double _6 = _4 - _5;
    double _7 = 26.0;
    double _8 = -_7;
    bool _9 = _6 < _8;
    _a1_int64_t _10;
    if (!_9)
    goto _jump1308;
    bool _11 = true;
    _a1_int64_t _12;
    if (!_11)
    goto _jump1309;
    int64_t _13 = h - b;
    _a1_int64_t _14;
    _14.d0 = 1;
    _14.data = jpl_alloc(sizeof(int64_t) * 1);
    _14.data[0] = _13;
    _12 = _14;
    goto _jump1310;
    _jump1309:;
    _a1_int64_t _15;
    _15.d0 = 2;
    _15.data = jpl_alloc(sizeof(int64_t) * 2);
    _15.data[0] = i;
    _15.data[1] = d;
    _12 = _15;
    _jump1310:;
    _10 = _12;
    goto _jump1311;
    _jump1308:;
    int64_t _16 = 264;
    bool _17 = _16 > j;
    _a1_int64_t _18;
    if (!_17)
    goto _jump1312;
    _a1_int64_t _19;
    _19.d0 = 3;
    _19.data = jpl_alloc(sizeof(int64_t) * 3);
    _19.data[0] = h;
    _19.data[1] = j;
    _19.data[2] = b;
    _18 = _19;
    goto _jump1313;
    _jump1312:;
    int64_t _20 = 957;
    _a1_int64_t _21;
    _21.d0 = 2;
    _21.data = jpl_alloc(sizeof(int64_t) * 2);
    _21.data[0] = d;
    _21.data[1] = _20;
    _18 = _21;
    _jump1313:;
    _10 = _18;
    _jump1311:;
    if (d >= 0)
    goto _jump1314;
    fail_assertion("negative array index");
    _jump1314:;
    if (d < _10.d0)
    goto _jump1315;
    fail_assertion("index too large");
    _jump1315:;
    int64_t _22 = 0;
    _22 *= _10.d0;
    _22 += d;
    int64_t _23 = _10.data[_22];
    _1.d1 = _23;
    if (_23 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= _2;
    _24 *= _23;
    _24 *= sizeof(void_t);
    _1.data = jpl_alloc(_24);
    int64_t _25 = 0; // n
    int64_t _26 = 0; // m
    _jump1317:; // Begin body of loop
    bool _27 = true;
    bool _28 = !_27;
    void_t _29;
    if (!_28)
    goto _jump1318;
    void_t _30 = l();
    _29 = _30;
    goto _jump1319;
    _jump1318:;
    void_t _31 = l();
    _29 = _31;
    _jump1319:;
    int64_t _32 = 0;
    _32 *= _1.d0;
    _32 += _26;
    _32 *= _1.d1;
    _32 += _25;
    _1.data[_32] = _29;
    _25++;
    if (_25 < _23)
    goto _jump1317;
    _25 = 0;
    _26++;
    if (_26 < _2)
    goto _jump1317;
    // End body of loop
    int64_t _33 = 303;
    if (_33 >= 0)
    goto _jump1320;
    fail_assertion("negative array index");
    _jump1320:;
    if (_33 < _1.d0)
    goto _jump1321;
    fail_assertion("index too large");
    _jump1321:;
    if (i >= 0)
    goto _jump1322;
    fail_assertion("negative array index");
    _jump1322:;
    if (i < _1.d1)
    goto _jump1323;
    fail_assertion("index too large");
    _jump1323:;
    int64_t _34 = 0;
    _34 *= _1.d0;
    _34 += _33;
    _34 *= _1.d1;
    _34 += i;
    void_t _35 = _1.data[_34];
    return _35;
    _a2_int64_t _36;
    // Computing bound for m
    _36.d0 = i;
    if (i > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing bound for n
    bool _37 = true;
    int64_t _38;
    if (!_37)
    goto _jump1325;
    _38 = c;
    goto _jump1326;
    _jump1325:;
    _38 = c;
    _jump1326:;
    int64_t _39 = _38 % d;
    _36.d1 = _39;
    if (_39 > 0) 
    goto _jump1327;
    fail_assertion("non-positive loop bound");
    _jump1327:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= i;
    _40 *= _39;
    _40 *= sizeof(int64_t);
    _36.data = jpl_alloc(_40);
    int64_t _41 = 0; // n
    int64_t _42 = 0; // m
    _jump1328:; // Begin body of loop
    int64_t _43 = 0;
    _43 *= _36.d0;
    _43 += _42;
    _43 *= _36.d1;
    _43 += _41;
    _36.data[_43] = _41;
    _41++;
    if (_41 < _39)
    goto _jump1328;
    _41 = 0;
    _42++;
    if (_42 < i)
    goto _jump1328;
    // End body of loop
    _a3_bool _45;
    // Computing bound for p
    int64_t _46;
    // Computing bound for p
    if (d > 0) 
    goto _jump1329;
    fail_assertion("non-positive loop bound");
    _jump1329:;
    _46 = 0;
    int64_t _47 = 0; // p
    _jump1330:; // Begin body of loop
    int64_t _48 = 903;
    _46 += _48;
    _47++;
    if (_47 < d)
    goto _jump1330;
    // End body of loop
    _45.d0 = _46;
    if (_46 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    // Computing bound for q
    _45.d1 = b;
    if (b > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    // Computing bound for r
    _45.d2 = c;
    if (c > 0) 
    goto _jump1333;
    fail_assertion("non-positive loop bound");
    _jump1333:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= _46;
    _49 *= b;
    _49 *= c;
    _49 *= sizeof(bool);
    _45.data = jpl_alloc(_49);
    int64_t _50 = 0; // r
    int64_t _51 = 0; // q
    int64_t _52 = 0; // p
    _jump1334:; // Begin body of loop
    bool _53 = false;
    int64_t _54 = 0;
    _54 *= _45.d0;
    _54 += _52;
    _54 *= _45.d1;
    _54 += _51;
    _54 *= _45.d2;
    _54 += _50;
    _45.data[_54] = _53;
    _50++;
    if (_50 < c)
    goto _jump1334;
    _50 = 0;
    _51++;
    if (_51 < b)
    goto _jump1334;
    _51 = 0;
    _52++;
    if (_52 < _46)
    goto _jump1334;
    // End body of loop
    int64_t _55 = 382;
    if (b >= 0)
    goto _jump1335;
    fail_assertion("negative array index");
    _jump1335:;
    if (b < _45.d0)
    goto _jump1336;
    fail_assertion("index too large");
    _jump1336:;
    if (d >= 0)
    goto _jump1337;
    fail_assertion("negative array index");
    _jump1337:;
    if (d < _45.d1)
    goto _jump1338;
    fail_assertion("index too large");
    _jump1338:;
    if (_55 >= 0)
    goto _jump1339;
    fail_assertion("negative array index");
    _jump1339:;
    if (_55 < _45.d2)
    goto _jump1340;
    fail_assertion("index too large");
    _jump1340:;
    int64_t _56 = 0;
    _56 *= _45.d0;
    _56 += b;
    _56 *= _45.d1;
    _56 += d;
    _56 *= _45.d2;
    _56 += _55;
    bool _57 = _45.data[_56];
    double _58;
    if (!_57)
    goto _jump1341;
    if (b >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (b < a.d0)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    if (i >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (i < a.d1)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    if (_36.d1 >= 0)
    goto _jump1346;
    fail_assertion("negative array index");
    _jump1346:;
    if (_36.d1 < a.d2)
    goto _jump1347;
    fail_assertion("index too large");
    _jump1347:;
    int64_t _60 = 0;
    _60 *= a.d0;
    _60 += b;
    _60 *= a.d1;
    _60 += i;
    _60 *= a.d2;
    _60 += _36.d1;
    bool _61 = a.data[_60];
    bool _59 = _61;
    if (0 != _61)
    goto _jump1348;
    int64_t _62 = 160;
    bool _63 = _62 >= _36.d0;
    _59 = _63;
    _jump1348:;
    double _64;
    if (!_59)
    goto _jump1349;
    bool _65 = false;
    double _66;
    if (!_65)
    goto _jump1350;
    double _67 = 86.0;
    _66 = _67;
    goto _jump1351;
    _jump1350:;
    double _68 = 32.0;
    _66 = _68;
    _jump1351:;
    double _69 = -_66;
    _64 = _69;
    goto _jump1352;
    _jump1349:;
    bool _70 = false;
    double _71;
    if (!_70)
    goto _jump1353;
    double _72 = 18.0;
    _71 = _72;
    goto _jump1354;
    _jump1353:;
    double _73 = 67.0;
    _71 = _73;
    _jump1354:;
    double _74 = -_71;
    _64 = _74;
    _jump1352:;
    _58 = _64;
    goto _jump1355;
    _jump1341:;
    double _75 = 21.0;
    _58 = _75;
    _jump1355:;
    _a1_double _76;
    // Computing bound for p
    _76.d0 = _36.d1;
    if (_36.d1 > 0) 
    goto _jump1356;
    fail_assertion("non-positive loop bound");
    _jump1356:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _36.d1;
    _77 *= sizeof(double);
    _76.data = jpl_alloc(_77);
    int64_t _78 = 0; // p
    _jump1357:; // Begin body of loop
    bool _79 = false;
    double _80;
    if (!_79)
    goto _jump1358;
    double _81 = 39.0;
    _80 = _81;
    goto _jump1359;
    _jump1358:;
    double _82 = 72.0;
    _80 = _82;
    _jump1359:;
    int64_t _83 = 0;
    _83 *= _76.d0;
    _83 += _78;
    _76.data[_83] = _80;
    _78++;
    if (_78 < _36.d1)
    goto _jump1357;
    // End body of loop
    if (d >= 0)
    goto _jump1360;
    fail_assertion("negative array index");
    _jump1360:;
    if (d < _76.d0)
    goto _jump1361;
    fail_assertion("index too large");
    _jump1361:;
    int64_t _84 = 0;
    _84 *= _76.d0;
    _84 += d;
    double _85 = _76.data[_84];
    double _86 = 41.0;
    double _87 = 39.0;
    double _88 = _86 * _87;
    _a1_double _89;
    // Computing bound for p
    _89.d0 = c;
    if (c > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    // Computing total size of heap memory to allocate
    int64_t _90 = 1;
    _90 *= c;
    _90 *= sizeof(double);
    _89.data = jpl_alloc(_90);
    int64_t _91 = 0; // p
    _jump1363:; // Begin body of loop
    double _92 = 7.0;
    int64_t _93 = 0;
    _93 *= _89.d0;
    _93 += _91;
    _89.data[_93] = _92;
    _91++;
    if (_91 < c)
    goto _jump1363;
    // End body of loop
    int64_t _94;
    // Computing bound for p
    if (j > 0) 
    goto _jump1364;
    fail_assertion("non-positive loop bound");
    _jump1364:;
    // Computing bound for q
    if (h > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing bound for r
    if (_36.d1 > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    _94 = 0;
    int64_t _95 = 0; // r
    int64_t _96 = 0; // q
    int64_t _97 = 0; // p
    _jump1367:; // Begin body of loop
    _94 += d;
    _95++;
    if (_95 < _36.d1)
    goto _jump1367;
    _95 = 0;
    _96++;
    if (_96 < h)
    goto _jump1367;
    _96 = 0;
    _97++;
    if (_97 < j)
    goto _jump1367;
    // End body of loop
    if (_94 >= 0)
    goto _jump1368;
    fail_assertion("negative array index");
    _jump1368:;
    if (_94 < _89.d0)
    goto _jump1369;
    fail_assertion("index too large");
    _jump1369:;
    int64_t _98 = 0;
    _98 *= _89.d0;
    _98 += _94;
    double _99 = _89.data[_98];
    double _100 = _88 + _99;
    double _101 = _85 * _100;
    bool _102 = _58 < _101;
    bool _44 = _102;
    if (0 == _102)
    goto _jump1370;
    bool _103 = h < _36.d1;
    bool _104;
    if (!_103)
    goto _jump1371;
    int64_t _105 = 949;
    int64_t _106 = 259;
    bool _107 = _105 >= _106;
    bool _108;
    if (!_107)
    goto _jump1372;
    bool _109 = true;
    bool _110 = !_109;
    _108 = _110;
    goto _jump1373;
    _jump1372:;
    bool _111 = i >= b;
    _108 = _111;
    _jump1373:;
    _104 = _108;
    goto _jump1374;
    _jump1371:;
    int64_t _112 = 528;
    bool _113 = _112 != b;
    bool _114;
    if (!_113)
    goto _jump1375;
    bool _115 = false;
    bool _116 = !_115;
    _114 = _116;
    goto _jump1376;
    _jump1375:;
    bool _117 = d != _36.d1;
    _114 = _117;
    _jump1376:;
    _104 = _114;
    _jump1374:;
    _a1_bool _118;
    _118.d0 = 1;
    _118.data = jpl_alloc(sizeof(bool) * 1);
    _118.data[0] = _104;
    if (c >= 0)
    goto _jump1377;
    fail_assertion("negative array index");
    _jump1377:;
    if (c < _118.d0)
    goto _jump1378;
    fail_assertion("index too large");
    _jump1378:;
    int64_t _119 = 0;
    _119 *= _118.d0;
    _119 += c;
    bool _120 = _118.data[_119];
    _44 = _120;
    _jump1370:;
    bool _121;
    if (!_44)
    goto _jump1379;
    bool _122 = true;
    bool _123 = !_122;
    bool _124;
    if (!_123)
    goto _jump1380;
    bool _125 = false;
    _124 = _125;
    goto _jump1381;
    _jump1380:;
    double _127 = 84.0;
    double _128 = -_127;
    double _129 = 21.0;
    double _130 = -_129;
    bool _131 = _128 > _130;
    bool _126 = _131;
    if (0 == _131)
    goto _jump1382;
    bool _132 = _36.d0 >= _36.d1;
    _126 = _132;
    _jump1382:;
    bool _133;
    if (!_126)
    goto _jump1383;
    _a2__a3_bool _134;
    // Computing bound for p
    _134.d0 = i;
    if (i > 0) 
    goto _jump1384;
    fail_assertion("non-positive loop bound");
    _jump1384:;
    // Computing bound for q
    _134.d1 = b;
    if (b > 0) 
    goto _jump1385;
    fail_assertion("non-positive loop bound");
    _jump1385:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= i;
    _135 *= b;
    _135 *= sizeof(_a3_bool);
    _134.data = jpl_alloc(_135);
    int64_t _136 = 0; // q
    int64_t _137 = 0; // p
    _jump1386:; // Begin body of loop
    int64_t _138 = 0;
    _138 *= _134.d0;
    _138 += _137;
    _138 *= _134.d1;
    _138 += _136;
    _134.data[_138] = a;
    _136++;
    if (_136 < b)
    goto _jump1386;
    _136 = 0;
    _137++;
    if (_137 < i)
    goto _jump1386;
    // End body of loop
    if (_36.d0 >= 0)
    goto _jump1387;
    fail_assertion("negative array index");
    _jump1387:;
    if (_36.d0 < _134.d0)
    goto _jump1388;
    fail_assertion("index too large");
    _jump1388:;
    if (h >= 0)
    goto _jump1389;
    fail_assertion("negative array index");
    _jump1389:;
    if (h < _134.d1)
    goto _jump1390;
    fail_assertion("index too large");
    _jump1390:;
    int64_t _139 = 0;
    _139 *= _134.d0;
    _139 += _36.d0;
    _139 *= _134.d1;
    _139 += h;
    _a3_bool _140 = _134.data[_139];
    if (d >= 0)
    goto _jump1391;
    fail_assertion("negative array index");
    _jump1391:;
    if (d < _140.d0)
    goto _jump1392;
    fail_assertion("index too large");
    _jump1392:;
    if (d >= 0)
    goto _jump1393;
    fail_assertion("negative array index");
    _jump1393:;
    if (d < _140.d1)
    goto _jump1394;
    fail_assertion("index too large");
    _jump1394:;
    if (i >= 0)
    goto _jump1395;
    fail_assertion("negative array index");
    _jump1395:;
    if (i < _140.d2)
    goto _jump1396;
    fail_assertion("index too large");
    _jump1396:;
    int64_t _141 = 0;
    _141 *= _140.d0;
    _141 += d;
    _141 *= _140.d1;
    _141 += d;
    _141 *= _140.d2;
    _141 += i;
    bool _142 = _140.data[_141];
    _133 = _142;
    goto _jump1397;
    _jump1383:;
    bool _143 = i <= i;
    _133 = _143;
    _jump1397:;
    bool _144 = !_133;
    _124 = _144;
    _jump1381:;
    _121 = _124;
    goto _jump1398;
    _jump1379:;
    bool _145 = false;
    _a3_bool _146;
    if (!_145)
    goto _jump1399;
    _146 = a;
    goto _jump1400;
    _jump1399:;
    _146 = a;
    _jump1400:;
    int64_t _147 = 435;
    if (_147 >= 0)
    goto _jump1401;
    fail_assertion("negative array index");
    _jump1401:;
    if (_147 < _146.d0)
    goto _jump1402;
    fail_assertion("index too large");
    _jump1402:;
    if (_36.d0 >= 0)
    goto _jump1403;
    fail_assertion("negative array index");
    _jump1403:;
    if (_36.d0 < _146.d1)
    goto _jump1404;
    fail_assertion("index too large");
    _jump1404:;
    if (i >= 0)
    goto _jump1405;
    fail_assertion("negative array index");
    _jump1405:;
    if (i < _146.d2)
    goto _jump1406;
    fail_assertion("index too large");
    _jump1406:;
    int64_t _148 = 0;
    _148 *= _146.d0;
    _148 += _147;
    _148 *= _146.d1;
    _148 += _36.d0;
    _148 *= _146.d2;
    _148 += i;
    bool _149 = _146.data[_148];
    bool _150;
    if (!_149)
    goto _jump1407;
    int64_t _151 = -b;
    bool _152 = _36.d1 < _151;
    bool _153;
    if (!_152)
    goto _jump1408;
    bool _154 = true;
    int64_t _155 = 760;
    bool _156 = _155 <= _36.d1;
    bool _157 = _154 == _156;
    _153 = _157;
    goto _jump1409;
    _jump1408:;
    bool _159 = true;
    bool _160 = !_159;
    bool _158 = _160;
    if (0 != _160)
    goto _jump1410;
    int64_t _161 = 549;
    if (_161 >= 0)
    goto _jump1411;
    fail_assertion("negative array index");
    _jump1411:;
    if (_161 < a.d0)
    goto _jump1412;
    fail_assertion("index too large");
    _jump1412:;
    if (i >= 0)
    goto _jump1413;
    fail_assertion("negative array index");
    _jump1413:;
    if (i < a.d1)
    goto _jump1414;
    fail_assertion("index too large");
    _jump1414:;
    if (_36.d0 >= 0)
    goto _jump1415;
    fail_assertion("negative array index");
    _jump1415:;
    if (_36.d0 < a.d2)
    goto _jump1416;
    fail_assertion("index too large");
    _jump1416:;
    int64_t _162 = 0;
    _162 *= a.d0;
    _162 += _161;
    _162 *= a.d1;
    _162 += i;
    _162 *= a.d2;
    _162 += _36.d0;
    bool _163 = a.data[_162];
    _158 = _163;
    _jump1410:;
    _153 = _158;
    _jump1409:;
    _150 = _153;
    goto _jump1417;
    _jump1407:;
    bool _166 = false;
    bool _167 = true;
    bool _168 = _166 != _167;
    bool _165 = _168;
    if (0 != _168)
    goto _jump1418;
    bool _170 = true;
    bool _169 = _170;
    if (0 != _170)
    goto _jump1419;
    bool _171 = true;
    _169 = _171;
    _jump1419:;
    _165 = _169;
    _jump1418:;
    bool _164 = _165;
    if (0 != _165)
    goto _jump1420;
    int64_t _172 = 788;
    bool _173 = j < _172;
    bool _174 = !_173;
    _164 = _174;
    _jump1420:;
    _150 = _164;
    _jump1417:;
    _a1_bool _175;
    if (!_150)
    goto _jump1421;
    _a1_bool _176;
    // Computing bound for p
    _176.d0 = i;
    if (i > 0) 
    goto _jump1422;
    fail_assertion("non-positive loop bound");
    _jump1422:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= i;
    _177 *= sizeof(bool);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // p
    _jump1423:; // Begin body of loop
    bool _179 = true;
    bool _180;
    if (!_179)
    goto _jump1424;
    bool _182 = false;
    bool _181 = _182;
    if (0 == _182)
    goto _jump1425;
    bool _183 = true;
    _181 = _183;
    _jump1425:;
    _180 = _181;
    goto _jump1426;
    _jump1424:;
    bool _184 = false;
    _180 = _184;
    _jump1426:;
    bool _185;
    if (!_180)
    goto _jump1427;
    int64_t _186 = -_36.d0;
    bool _187 = _186 > d;
    _185 = _187;
    goto _jump1428;
    _jump1427:;
    bool _189 = false;
    bool _188 = _189;
    if (0 != _189)
    goto _jump1429;
    bool _190 = true;
    bool _191;
    if (!_190)
    goto _jump1430;
    bool _192 = false;
    _191 = _192;
    goto _jump1431;
    _jump1430:;
    bool _193 = false;
    _191 = _193;
    _jump1431:;
    _188 = _191;
    _jump1429:;
    _185 = _188;
    _jump1428:;
    int64_t _194 = 0;
    _194 *= _176.d0;
    _194 += _178;
    _176.data[_194] = _185;
    _178++;
    if (_178 < i)
    goto _jump1423;
    // End body of loop
    _175 = _176;
    goto _jump1432;
    _jump1421:;
    if (_36.d0 >= 0)
    goto _jump1433;
    fail_assertion("negative array index");
    _jump1433:;
    if (_36.d0 < a.d0)
    goto _jump1434;
    fail_assertion("index too large");
    _jump1434:;
    if (d >= 0)
    goto _jump1435;
    fail_assertion("negative array index");
    _jump1435:;
    if (d < a.d1)
    goto _jump1436;
    fail_assertion("index too large");
    _jump1436:;
    if (i >= 0)
    goto _jump1437;
    fail_assertion("negative array index");
    _jump1437:;
    if (i < a.d2)
    goto _jump1438;
    fail_assertion("index too large");
    _jump1438:;
    int64_t _195 = 0;
    _195 *= a.d0;
    _195 += _36.d0;
    _195 *= a.d1;
    _195 += d;
    _195 *= a.d2;
    _195 += i;
    bool _196 = a.data[_195];
    bool _197 = !_196;
    bool _198 = !_197;
    _a1_bool _199;
    if (!_198)
    goto _jump1439;
    _a1_bool _200;
    // Computing bound for p
    int64_t _201 = -d;
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump1440;
    fail_assertion("non-positive loop bound");
    _jump1440:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _201;
    _202 *= sizeof(bool);
    _200.data = jpl_alloc(_202);
    int64_t _203 = 0; // p
    _jump1441:; // Begin body of loop
    bool _204 = false;
    int64_t _205 = 0;
    _205 *= _200.d0;
    _205 += _203;
    _200.data[_205] = _204;
    _203++;
    if (_203 < _201)
    goto _jump1441;
    // End body of loop
    _199 = _200;
    goto _jump1442;
    _jump1439:;
    _a1_bool _206;
    // Computing bound for p
    int64_t _207;
    // Computing bound for p
    int64_t _208 = 219;
    if (_208 > 0) 
    goto _jump1443;
    fail_assertion("non-positive loop bound");
    _jump1443:;
    // Computing bound for q
    int64_t _209 = 422;
    if (_209 > 0) 
    goto _jump1444;
    fail_assertion("non-positive loop bound");
    _jump1444:;
    _207 = 0;
    int64_t _210 = 0; // q
    int64_t _211 = 0; // p
    _jump1445:; // Begin body of loop
    _207 += j;
    _210++;
    if (_210 < _209)
    goto _jump1445;
    _210 = 0;
    _211++;
    if (_211 < _208)
    goto _jump1445;
    // End body of loop
    _206.d0 = _207;
    if (_207 > 0) 
    goto _jump1446;
    fail_assertion("non-positive loop bound");
    _jump1446:;
    // Computing total size of heap memory to allocate
    int64_t _212 = 1;
    _212 *= _207;
    _212 *= sizeof(bool);
    _206.data = jpl_alloc(_212);
    int64_t _213 = 0; // p
    _jump1447:; // Begin body of loop
    int64_t _214 = 729;
    bool _215 = _214 > _213;
    bool _216 = !_215;
    int64_t _217 = 0;
    _217 *= _206.d0;
    _217 += _213;
    _206.data[_217] = _216;
    _213++;
    if (_213 < _207)
    goto _jump1447;
    // End body of loop
    _199 = _206;
    _jump1442:;
    _175 = _199;
    _jump1432:;
    bool _218 = false;
    _a1_int64_t _219;
    if (!_218)
    goto _jump1448;
    int64_t _220 = -h;
    bool _221 = _220 == d;
    _a1_int64_t _222;
    if (!_221)
    goto _jump1449;
    int64_t _223 = 835;
    int64_t _224 = -b;
    _a1_int64_t _225;
    _225.d0 = 2;
    _225.data = jpl_alloc(sizeof(int64_t) * 2);
    _225.data[0] = _223;
    _225.data[1] = _224;
    _222 = _225;
    goto _jump1450;
    _jump1449:;
    _a1_int64_t _226;
    // Computing bound for p
    _226.d0 = j;
    if (j > 0) 
    goto _jump1451;
    fail_assertion("non-positive loop bound");
    _jump1451:;
    // Computing total size of heap memory to allocate
    int64_t _227 = 1;
    _227 *= j;
    _227 *= sizeof(int64_t);
    _226.data = jpl_alloc(_227);
    int64_t _228 = 0; // p
    _jump1452:; // Begin body of loop
    int64_t _229 = 0;
    _229 *= _226.d0;
    _229 += _228;
    _226.data[_229] = b;
    _228++;
    if (_228 < j)
    goto _jump1452;
    // End body of loop
    _222 = _226;
    _jump1450:;
    _219 = _222;
    goto _jump1453;
    _jump1448:;
    _a3__a1_int64_t _230;
    // Computing bound for p
    _230.d0 = d;
    if (d > 0) 
    goto _jump1454;
    fail_assertion("non-positive loop bound");
    _jump1454:;
    // Computing bound for q
    _230.d1 = _36.d1;
    if (_36.d1 > 0) 
    goto _jump1455;
    fail_assertion("non-positive loop bound");
    _jump1455:;
    // Computing bound for r
    _230.d2 = _36.d1;
    if (_36.d1 > 0) 
    goto _jump1456;
    fail_assertion("non-positive loop bound");
    _jump1456:;
    // Computing total size of heap memory to allocate
    int64_t _231 = 1;
    _231 *= d;
    _231 *= _36.d1;
    _231 *= _36.d1;
    _231 *= sizeof(_a1_int64_t);
    _230.data = jpl_alloc(_231);
    int64_t _232 = 0; // r
    int64_t _233 = 0; // q
    int64_t _234 = 0; // p
    _jump1457:; // Begin body of loop
    _a1_int64_t _235;
    _235.d0 = 3;
    _235.data = jpl_alloc(sizeof(int64_t) * 3);
    _235.data[0] = _234;
    _235.data[1] = i;
    _235.data[2] = _36.d0;
    int64_t _236 = 0;
    _236 *= _230.d0;
    _236 += _234;
    _236 *= _230.d1;
    _236 += _233;
    _236 *= _230.d2;
    _236 += _232;
    _230.data[_236] = _235;
    _232++;
    if (_232 < _36.d1)
    goto _jump1457;
    _232 = 0;
    _233++;
    if (_233 < _36.d1)
    goto _jump1457;
    _233 = 0;
    _234++;
    if (_234 < d)
    goto _jump1457;
    // End body of loop
    _a2_int64_t _237;
    // Computing bound for p
    _237.d0 = _36.d0;
    if (_36.d0 > 0) 
    goto _jump1458;
    fail_assertion("non-positive loop bound");
    _jump1458:;
    // Computing bound for q
    _237.d1 = _36.d0;
    if (_36.d0 > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    // Computing total size of heap memory to allocate
    int64_t _238 = 1;
    _238 *= _36.d0;
    _238 *= _36.d0;
    _238 *= sizeof(int64_t);
    _237.data = jpl_alloc(_238);
    int64_t _239 = 0; // q
    int64_t _240 = 0; // p
    _jump1460:; // Begin body of loop
    int64_t _241 = 0;
    _241 *= _237.d0;
    _241 += _240;
    _241 *= _237.d1;
    _241 += _239;
    _237.data[_241] = h;
    _239++;
    if (_239 < _36.d0)
    goto _jump1460;
    _239 = 0;
    _240++;
    if (_240 < _36.d0)
    goto _jump1460;
    // End body of loop
    int64_t _242 = 619;
    int64_t _243 = -_242;
    if (i >= 0)
    goto _jump1461;
    fail_assertion("negative array index");
    _jump1461:;
    if (i < _237.d0)
    goto _jump1462;
    fail_assertion("index too large");
    _jump1462:;
    if (_243 >= 0)
    goto _jump1463;
    fail_assertion("negative array index");
    _jump1463:;
    if (_243 < _237.d1)
    goto _jump1464;
    fail_assertion("index too large");
    _jump1464:;
    int64_t _244 = 0;
    _244 *= _237.d0;
    _244 += i;
    _244 *= _237.d1;
    _244 += _243;
    int64_t _245 = _237.data[_244];
    int64_t _246;
    // Computing bound for p
    if (b > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    // Computing bound for q
    if (i > 0) 
    goto _jump1466;
    fail_assertion("non-positive loop bound");
    _jump1466:;
    _246 = 0;
    int64_t _247 = 0; // q
    int64_t _248 = 0; // p
    _jump1467:; // Begin body of loop
    _246 += j;
    _247++;
    if (_247 < i)
    goto _jump1467;
    _247 = 0;
    _248++;
    if (_248 < b)
    goto _jump1467;
    // End body of loop
    int64_t _249 = j - _246;
    int64_t _250;
    // Computing bound for p
    if (c > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing bound for q
    if (j > 0) 
    goto _jump1469;
    fail_assertion("non-positive loop bound");
    _jump1469:;
    // Computing bound for r
    int64_t _251 = 134;
    if (_251 > 0) 
    goto _jump1470;
    fail_assertion("non-positive loop bound");
    _jump1470:;
    _250 = 0;
    int64_t _252 = 0; // r
    int64_t _253 = 0; // q
    int64_t _254 = 0; // p
    _jump1471:; // Begin body of loop
    _250 += _253;
    _252++;
    if (_252 < _251)
    goto _jump1471;
    _252 = 0;
    _253++;
    if (_253 < j)
    goto _jump1471;
    _253 = 0;
    _254++;
    if (_254 < c)
    goto _jump1471;
    // End body of loop
    if (_250 >= 0)
    goto _jump1472;
    fail_assertion("negative array index");
    _jump1472:;
    if (_250 < g.d0)
    goto _jump1473;
    fail_assertion("index too large");
    _jump1473:;
    if (_36.d0 >= 0)
    goto _jump1474;
    fail_assertion("negative array index");
    _jump1474:;
    if (_36.d0 < g.d1)
    goto _jump1475;
    fail_assertion("index too large");
    _jump1475:;
    if (i >= 0)
    goto _jump1476;
    fail_assertion("negative array index");
    _jump1476:;
    if (i < g.d2)
    goto _jump1477;
    fail_assertion("index too large");
    _jump1477:;
    int64_t _255 = 0;
    _255 *= g.d0;
    _255 += _250;
    _255 *= g.d1;
    _255 += _36.d0;
    _255 *= g.d2;
    _255 += i;
    int64_t _256 = g.data[_255];
    if (_245 >= 0)
    goto _jump1478;
    fail_assertion("negative array index");
    _jump1478:;
    if (_245 < _230.d0)
    goto _jump1479;
    fail_assertion("index too large");
    _jump1479:;
    if (_249 >= 0)
    goto _jump1480;
    fail_assertion("negative array index");
    _jump1480:;
    if (_249 < _230.d1)
    goto _jump1481;
    fail_assertion("index too large");
    _jump1481:;
    if (_256 >= 0)
    goto _jump1482;
    fail_assertion("negative array index");
    _jump1482:;
    if (_256 < _230.d2)
    goto _jump1483;
    fail_assertion("index too large");
    _jump1483:;
    int64_t _257 = 0;
    _257 *= _230.d0;
    _257 += _245;
    _257 *= _230.d1;
    _257 += _249;
    _257 *= _230.d2;
    _257 += _256;
    _a1_int64_t _258 = _230.data[_257];
    _219 = _258;
    _jump1453:;
    if (d >= 0)
    goto _jump1484;
    fail_assertion("negative array index");
    _jump1484:;
    if (d < _219.d0)
    goto _jump1485;
    fail_assertion("index too large");
    _jump1485:;
    int64_t _259 = 0;
    _259 *= _219.d0;
    _259 += d;
    int64_t _260 = _219.data[_259];
    if (_260 >= 0)
    goto _jump1486;
    fail_assertion("negative array index");
    _jump1486:;
    if (_260 < _175.d0)
    goto _jump1487;
    fail_assertion("index too large");
    _jump1487:;
    int64_t _261 = 0;
    _261 *= _175.d0;
    _261 += _260;
    bool _262 = _175.data[_261];
    _121 = _262;
    _jump1398:;
    if (0 != _121)
    goto _jump1488;
    fail_assertion("p");
    _jump1488:;
    int64_t _264 = -_36.d0;
    bool _265 = _36.d1 < _264;
    bool _266 = !_265;
    bool _267;
    if (!_266)
    goto _jump1489;
    int64_t _268 = 153;
    bool _269 = j == _268;
    bool _270;
    if (!_269)
    goto _jump1490;
    int64_t _271 = c / c;
    bool _272 = _271 <= _36.d1;
    bool _273 = !_272;
    _270 = _273;
    goto _jump1491;
    _jump1490:;
    bool _274 = false;
    bool _275;
    if (!_274)
    goto _jump1492;
    bool _276 = true;
    _a1_bool _277;
    _277.d0 = 1;
    _277.data = jpl_alloc(sizeof(bool) * 1);
    _277.data[0] = _276;
    if (_36.d1 >= 0)
    goto _jump1493;
    fail_assertion("negative array index");
    _jump1493:;
    if (_36.d1 < _277.d0)
    goto _jump1494;
    fail_assertion("index too large");
    _jump1494:;
    int64_t _278 = 0;
    _278 *= _277.d0;
    _278 += _36.d1;
    bool _279 = _277.data[_278];
    _275 = _279;
    goto _jump1495;
    _jump1492:;
    bool _280 = _36.d0 >= c;
    _275 = _280;
    _jump1495:;
    _270 = _275;
    _jump1491:;
    bool _281;
    if (!_270)
    goto _jump1496;
    bool _282 = false;
    bool _283;
    if (!_282)
    goto _jump1497;
    int64_t _285 = 82;
    if (h >= 0)
    goto _jump1498;
    fail_assertion("negative array index");
    _jump1498:;
    if (h < a.d0)
    goto _jump1499;
    fail_assertion("index too large");
    _jump1499:;
    if (j >= 0)
    goto _jump1500;
    fail_assertion("negative array index");
    _jump1500:;
    if (j < a.d1)
    goto _jump1501;
    fail_assertion("index too large");
    _jump1501:;
    if (_285 >= 0)
    goto _jump1502;
    fail_assertion("negative array index");
    _jump1502:;
    if (_285 < a.d2)
    goto _jump1503;
    fail_assertion("index too large");
    _jump1503:;
    int64_t _286 = 0;
    _286 *= a.d0;
    _286 += h;
    _286 *= a.d1;
    _286 += j;
    _286 *= a.d2;
    _286 += _285;
    bool _287 = a.data[_286];
    bool _284 = _287;
    if (0 == _287)
    goto _jump1504;
    bool _288 = false;
    _284 = _288;
    _jump1504:;
    _283 = _284;
    goto _jump1505;
    _jump1497:;
    bool _289 = false;
    bool _290 = !_289;
    _283 = _290;
    _jump1505:;
    bool _291 = !_283;
    _281 = _291;
    goto _jump1506;
    _jump1496:;
    bool _292 = true;
    bool _293;
    if (!_292)
    goto _jump1507;
    int64_t _294 = 306;
    int64_t _295 = j % _294;
    int64_t _296;
    // Computing bound for p
    if (d > 0) 
    goto _jump1508;
    fail_assertion("non-positive loop bound");
    _jump1508:;
    _296 = 0;
    int64_t _297 = 0; // p
    _jump1509:; // Begin body of loop
    _296 += _297;
    _297++;
    if (_297 < d)
    goto _jump1509;
    // End body of loop
    if (j >= 0)
    goto _jump1510;
    fail_assertion("negative array index");
    _jump1510:;
    if (j < a.d0)
    goto _jump1511;
    fail_assertion("index too large");
    _jump1511:;
    if (_295 >= 0)
    goto _jump1512;
    fail_assertion("negative array index");
    _jump1512:;
    if (_295 < a.d1)
    goto _jump1513;
    fail_assertion("index too large");
    _jump1513:;
    if (_296 >= 0)
    goto _jump1514;
    fail_assertion("negative array index");
    _jump1514:;
    if (_296 < a.d2)
    goto _jump1515;
    fail_assertion("index too large");
    _jump1515:;
    int64_t _298 = 0;
    _298 *= a.d0;
    _298 += j;
    _298 *= a.d1;
    _298 += _295;
    _298 *= a.d2;
    _298 += _296;
    bool _299 = a.data[_298];
    _293 = _299;
    goto _jump1516;
    _jump1507:;
    bool _300 = true;
    bool _301;
    if (!_300)
    goto _jump1517;
    int64_t _302 = -_36.d0;
    bool _303 = b == _302;
    _301 = _303;
    goto _jump1518;
    _jump1517:;
    bool _304 = true;
    _301 = _304;
    _jump1518:;
    _293 = _301;
    _jump1516:;
    _281 = _293;
    _jump1506:;
    _267 = _281;
    goto _jump1519;
    _jump1489:;
    bool _305 = i == b;
    bool _306;
    if (!_305)
    goto _jump1520;
    bool _307 = true;
    bool _308 = !_307;
    _306 = _308;
    goto _jump1521;
    _jump1520:;
    bool _309 = c > h;
    _306 = _309;
    _jump1521:;
    _a2_double _310;
    if (!_306)
    goto _jump1522;
    _a2_double _311;
    // Computing bound for p
    _311.d0 = _36.d0;
    if (_36.d0 > 0) 
    goto _jump1523;
    fail_assertion("non-positive loop bound");
    _jump1523:;
    // Computing bound for q
    _311.d1 = _36.d1;
    if (_36.d1 > 0) 
    goto _jump1524;
    fail_assertion("non-positive loop bound");
    _jump1524:;
    // Computing total size of heap memory to allocate
    int64_t _312 = 1;
    _312 *= _36.d0;
    _312 *= _36.d1;
    _312 *= sizeof(double);
    _311.data = jpl_alloc(_312);
    int64_t _313 = 0; // q
    int64_t _314 = 0; // p
    _jump1525:; // Begin body of loop
    double _315;
    // Computing bound for r
    if (h > 0) 
    goto _jump1526;
    fail_assertion("non-positive loop bound");
    _jump1526:;
    // Computing bound for s
    if (i > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing bound for t
    if (_314 > 0) 
    goto _jump1528;
    fail_assertion("non-positive loop bound");
    _jump1528:;
    _315 = 0;
    int64_t _316 = 0; // t
    int64_t _317 = 0; // s
    int64_t _318 = 0; // r
    _jump1529:; // Begin body of loop
    double _319 = 79.0;
    _315 += _319;
    _316++;
    if (_316 < _314)
    goto _jump1529;
    _316 = 0;
    _317++;
    if (_317 < i)
    goto _jump1529;
    _317 = 0;
    _318++;
    if (_318 < h)
    goto _jump1529;
    // End body of loop
    int64_t _320 = 0;
    _320 *= _311.d0;
    _320 += _314;
    _320 *= _311.d1;
    _320 += _313;
    _311.data[_320] = _315;
    _313++;
    if (_313 < _36.d1)
    goto _jump1525;
    _313 = 0;
    _314++;
    if (_314 < _36.d0)
    goto _jump1525;
    // End body of loop
    _310 = _311;
    goto _jump1530;
    _jump1522:;
    _a2_double _321;
    // Computing bound for p
    int64_t _322 = -h;
    _321.d0 = _322;
    if (_322 > 0) 
    goto _jump1531;
    fail_assertion("non-positive loop bound");
    _jump1531:;
    // Computing bound for q
    _321.d1 = b;
    if (b > 0) 
    goto _jump1532;
    fail_assertion("non-positive loop bound");
    _jump1532:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= _322;
    _323 *= b;
    _323 *= sizeof(double);
    _321.data = jpl_alloc(_323);
    int64_t _324 = 0; // q
    int64_t _325 = 0; // p
    _jump1533:; // Begin body of loop
    double _326;
    // Computing bound for r
    if (c > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    // Computing bound for s
    if (b > 0) 
    goto _jump1535;
    fail_assertion("non-positive loop bound");
    _jump1535:;
    // Computing bound for t
    if (i > 0) 
    goto _jump1536;
    fail_assertion("non-positive loop bound");
    _jump1536:;
    _326 = 0;
    int64_t _327 = 0; // t
    int64_t _328 = 0; // s
    int64_t _329 = 0; // r
    _jump1537:; // Begin body of loop
    double _330 = 50.0;
    _326 += _330;
    _327++;
    if (_327 < i)
    goto _jump1537;
    _327 = 0;
    _328++;
    if (_328 < b)
    goto _jump1537;
    _328 = 0;
    _329++;
    if (_329 < c)
    goto _jump1537;
    // End body of loop
    int64_t _331 = 0;
    _331 *= _321.d0;
    _331 += _325;
    _331 *= _321.d1;
    _331 += _324;
    _321.data[_331] = _326;
    _324++;
    if (_324 < b)
    goto _jump1533;
    _324 = 0;
    _325++;
    if (_325 < _322)
    goto _jump1533;
    // End body of loop
    _310 = _321;
    _jump1530:;
    if (_36.d0 >= 0)
    goto _jump1538;
    fail_assertion("negative array index");
    _jump1538:;
    if (_36.d0 < _310.d0)
    goto _jump1539;
    fail_assertion("index too large");
    _jump1539:;
    if (h >= 0)
    goto _jump1540;
    fail_assertion("negative array index");
    _jump1540:;
    if (h < _310.d1)
    goto _jump1541;
    fail_assertion("index too large");
    _jump1541:;
    int64_t _332 = 0;
    _332 *= _310.d0;
    _332 += _36.d0;
    _332 *= _310.d1;
    _332 += h;
    double _333 = _310.data[_332];
    double _334 = 48.0;
    double _335 = 26.0;
    bool _336 = false;
    bool _337;
    if (!_336)
    goto _jump1542;
    bool _338 = true;
    _337 = _338;
    goto _jump1543;
    _jump1542:;
    bool _339 = false;
    _337 = _339;
    _jump1543:;
    double _340;
    if (!_337)
    goto _jump1544;
    double _341 = 16.0;
    _340 = _341;
    goto _jump1545;
    _jump1544:;
    double _342 = 79.0;
    _340 = _342;
    _jump1545:;
    double _343 = 86.0;
    rgba _344 = { _334, _335, _340, _343 };
    double _345 = _344.g;
    bool _346 = _333 <= _345;
    _267 = _346;
    _jump1519:;
    bool _263 = _267;
    if (0 != _267)
    goto _jump1546;
    int64_t _349 = 787;
    bool _350 = h < _349;
    bool _351 = true;
    bool _352 = _350 != _351;
    bool _348 = _352;
    if (0 != _352)
    goto _jump1547;
    bool _353 = d > i;
    _348 = _353;
    _jump1547:;
    bool _347 = _348;
    if (0 != _348)
    goto _jump1548;
    bool _354 = c == b;
    _347 = _354;
    _jump1548:;
    _263 = _347;
    _jump1546:;
    bool _355 = true;
    double _356;
    if (!_355)
    goto _jump1549;
    bool _357 = _263;
    if (0 == _263)
    goto _jump1550;
    _a1_bool _358;
    // Computing bound for q
    bool _359 = false;
    int64_t _360;
    if (!_359)
    goto _jump1551;
    _360 = i;
    goto _jump1552;
    _jump1551:;
    _360 = c;
    _jump1552:;
    _358.d0 = _360;
    if (_360 > 0) 
    goto _jump1553;
    fail_assertion("non-positive loop bound");
    _jump1553:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= _360;
    _361 *= sizeof(bool);
    _358.data = jpl_alloc(_361);
    int64_t _362 = 0; // q
    _jump1554:; // Begin body of loop
    int64_t _363 = 0;
    _363 *= _358.d0;
    _363 += _362;
    _358.data[_363] = _263;
    _362++;
    if (_362 < _360)
    goto _jump1554;
    // End body of loop
    if (d >= 0)
    goto _jump1555;
    fail_assertion("negative array index");
    _jump1555:;
    if (d < _358.d0)
    goto _jump1556;
    fail_assertion("index too large");
    _jump1556:;
    int64_t _364 = 0;
    _364 *= _358.d0;
    _364 += d;
    bool _365 = _358.data[_364];
    _357 = _365;
    _jump1550:;
    double _366;
    if (!_357)
    goto _jump1557;
    double _367;
    // Computing bound for q
    int64_t _368 = 816;
    if (_368 > 0) 
    goto _jump1558;
    fail_assertion("non-positive loop bound");
    _jump1558:;
    // Computing bound for r
    int64_t _369 = 585;
    if (_369 > 0) 
    goto _jump1559;
    fail_assertion("non-positive loop bound");
    _jump1559:;
    _367 = 0;
    int64_t _370 = 0; // r
    int64_t _371 = 0; // q
    _jump1560:; // Begin body of loop
    _a3_double _372;
    // Computing bound for s
    int64_t _373 = -_371;
    _372.d0 = _373;
    if (_373 > 0) 
    goto _jump1561;
    fail_assertion("non-positive loop bound");
    _jump1561:;
    // Computing bound for t
    _372.d1 = c;
    if (c > 0) 
    goto _jump1562;
    fail_assertion("non-positive loop bound");
    _jump1562:;
    // Computing bound for u
    _372.d2 = _370;
    if (_370 > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing total size of heap memory to allocate
    int64_t _374 = 1;
    _374 *= _373;
    _374 *= c;
    _374 *= _370;
    _374 *= sizeof(double);
    _372.data = jpl_alloc(_374);
    int64_t _375 = 0; // u
    int64_t _376 = 0; // t
    int64_t _377 = 0; // s
    _jump1564:; // Begin body of loop
    double _378;
    // Computing bound for v
    if (c > 0) 
    goto _jump1565;
    fail_assertion("non-positive loop bound");
    _jump1565:;
    // Computing bound for w
    if (i > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    _378 = 0;
    int64_t _379 = 0; // w
    int64_t _380 = 0; // v
    _jump1567:; // Begin body of loop
    double _381 = 86.0;
    _378 += _381;
    _379++;
    if (_379 < i)
    goto _jump1567;
    _379 = 0;
    _380++;
    if (_380 < c)
    goto _jump1567;
    // End body of loop
    int64_t _382 = 0;
    _382 *= _372.d0;
    _382 += _377;
    _382 *= _372.d1;
    _382 += _376;
    _382 *= _372.d2;
    _382 += _375;
    _372.data[_382] = _378;
    _375++;
    if (_375 < _370)
    goto _jump1564;
    _375 = 0;
    _376++;
    if (_376 < c)
    goto _jump1564;
    _376 = 0;
    _377++;
    if (_377 < _373)
    goto _jump1564;
    // End body of loop
    if (c >= 0)
    goto _jump1568;
    fail_assertion("negative array index");
    _jump1568:;
    if (c < _372.d0)
    goto _jump1569;
    fail_assertion("index too large");
    _jump1569:;
    if (j >= 0)
    goto _jump1570;
    fail_assertion("negative array index");
    _jump1570:;
    if (j < _372.d1)
    goto _jump1571;
    fail_assertion("index too large");
    _jump1571:;
    if (_36.d1 >= 0)
    goto _jump1572;
    fail_assertion("negative array index");
    _jump1572:;
    if (_36.d1 < _372.d2)
    goto _jump1573;
    fail_assertion("index too large");
    _jump1573:;
    int64_t _383 = 0;
    _383 *= _372.d0;
    _383 += c;
    _383 *= _372.d1;
    _383 += j;
    _383 *= _372.d2;
    _383 += _36.d1;
    double _384 = _372.data[_383];
    _367 += _384;
    _370++;
    if (_370 < _369)
    goto _jump1560;
    _370 = 0;
    _371++;
    if (_371 < _368)
    goto _jump1560;
    // End body of loop
    _366 = _367;
    goto _jump1574;
    _jump1557:;
    _a2_bool _385;
    // Computing bound for q
    _385.d0 = _36.d1;
    if (_36.d1 > 0) 
    goto _jump1575;
    fail_assertion("non-positive loop bound");
    _jump1575:;
    // Computing bound for r
    int64_t _386 = i % c;
    _385.d1 = _386;
    if (_386 > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    // Computing total size of heap memory to allocate
    int64_t _387 = 1;
    _387 *= _36.d1;
    _387 *= _386;
    _387 *= sizeof(bool);
    _385.data = jpl_alloc(_387);
    int64_t _388 = 0; // r
    int64_t _389 = 0; // q
    _jump1577:; // Begin body of loop
    bool _390;
    if (!_263)
    goto _jump1578;
    _390 = _263;
    goto _jump1579;
    _jump1578:;
    _390 = _263;
    _jump1579:;
    int64_t _391 = 0;
    _391 *= _385.d0;
    _391 += _389;
    _391 *= _385.d1;
    _391 += _388;
    _385.data[_391] = _390;
    _388++;
    if (_388 < _386)
    goto _jump1577;
    _388 = 0;
    _389++;
    if (_389 < _36.d1)
    goto _jump1577;
    // End body of loop
    int64_t _392;
    if (!_263)
    goto _jump1580;
    _392 = j;
    goto _jump1581;
    _jump1580:;
    int64_t _393 = j + h;
    _392 = _393;
    _jump1581:;
    if (_392 >= 0)
    goto _jump1582;
    fail_assertion("negative array index");
    _jump1582:;
    if (_392 < _385.d0)
    goto _jump1583;
    fail_assertion("index too large");
    _jump1583:;
    if (h >= 0)
    goto _jump1584;
    fail_assertion("negative array index");
    _jump1584:;
    if (h < _385.d1)
    goto _jump1585;
    fail_assertion("index too large");
    _jump1585:;
    int64_t _394 = 0;
    _394 *= _385.d0;
    _394 += _392;
    _394 *= _385.d1;
    _394 += h;
    bool _395 = _385.data[_394];
    double _396;
    if (!_395)
    goto _jump1586;
    _a3_double _397;
    // Computing bound for q
    int64_t _398 = 254;
    int64_t _399 = 84;
    if (j >= 0)
    goto _jump1587;
    fail_assertion("negative array index");
    _jump1587:;
    if (j < g.d0)
    goto _jump1588;
    fail_assertion("index too large");
    _jump1588:;
    if (_398 >= 0)
    goto _jump1589;
    fail_assertion("negative array index");
    _jump1589:;
    if (_398 < g.d1)
    goto _jump1590;
    fail_assertion("index too large");
    _jump1590:;
    if (_399 >= 0)
    goto _jump1591;
    fail_assertion("negative array index");
    _jump1591:;
    if (_399 < g.d2)
    goto _jump1592;
    fail_assertion("index too large");
    _jump1592:;
    int64_t _400 = 0;
    _400 *= g.d0;
    _400 += j;
    _400 *= g.d1;
    _400 += _398;
    _400 *= g.d2;
    _400 += _399;
    int64_t _401 = g.data[_400];
    _397.d0 = _401;
    if (_401 > 0) 
    goto _jump1593;
    fail_assertion("non-positive loop bound");
    _jump1593:;
    // Computing bound for r
    _397.d1 = b;
    if (b > 0) 
    goto _jump1594;
    fail_assertion("non-positive loop bound");
    _jump1594:;
    // Computing bound for s
    _397.d2 = j;
    if (j > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing total size of heap memory to allocate
    int64_t _402 = 1;
    _402 *= _401;
    _402 *= b;
    _402 *= j;
    _402 *= sizeof(double);
    _397.data = jpl_alloc(_402);
    int64_t _403 = 0; // s
    int64_t _404 = 0; // r
    int64_t _405 = 0; // q
    _jump1596:; // Begin body of loop
    double _406 = 65.0;
    int64_t _407 = 0;
    _407 *= _397.d0;
    _407 += _405;
    _407 *= _397.d1;
    _407 += _404;
    _407 *= _397.d2;
    _407 += _403;
    _397.data[_407] = _406;
    _403++;
    if (_403 < j)
    goto _jump1596;
    _403 = 0;
    _404++;
    if (_404 < b)
    goto _jump1596;
    _404 = 0;
    _405++;
    if (_405 < _401)
    goto _jump1596;
    // End body of loop
    int64_t _408 = _36.d1 - j;
    bool _409 = true;
    int64_t _410;
    if (!_409)
    goto _jump1597;
    int64_t _411 = 972;
    _410 = _411;
    goto _jump1598;
    _jump1597:;
    int64_t _412 = 284;
    _410 = _412;
    _jump1598:;
    int64_t _413 = _410 + _36.d0;
    _a3_int64_t _414;
    // Computing bound for q
    _414.d0 = b;
    if (b > 0) 
    goto _jump1599;
    fail_assertion("non-positive loop bound");
    _jump1599:;
    // Computing bound for r
    int64_t _415 = 694;
    _414.d1 = _415;
    if (_415 > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing bound for s
    _414.d2 = b;
    if (b > 0) 
    goto _jump1601;
    fail_assertion("non-positive loop bound");
    _jump1601:;
    // Computing total size of heap memory to allocate
    int64_t _416 = 1;
    _416 *= b;
    _416 *= _415;
    _416 *= b;
    _416 *= sizeof(int64_t);
    _414.data = jpl_alloc(_416);
    int64_t _417 = 0; // s
    int64_t _418 = 0; // r
    int64_t _419 = 0; // q
    _jump1602:; // Begin body of loop
    int64_t _420 = 0;
    _420 *= _414.d0;
    _420 += _419;
    _420 *= _414.d1;
    _420 += _418;
    _420 *= _414.d2;
    _420 += _417;
    _414.data[_420] = b;
    _417++;
    if (_417 < b)
    goto _jump1602;
    _417 = 0;
    _418++;
    if (_418 < _415)
    goto _jump1602;
    _418 = 0;
    _419++;
    if (_419 < b)
    goto _jump1602;
    // End body of loop
    int64_t _421;
    if (!_263)
    goto _jump1603;
    _421 = _36.d1;
    goto _jump1604;
    _jump1603:;
    int64_t _422 = 969;
    _421 = _422;
    _jump1604:;
    if (_36.d0 >= 0)
    goto _jump1605;
    fail_assertion("negative array index");
    _jump1605:;
    if (_36.d0 < _414.d0)
    goto _jump1606;
    fail_assertion("index too large");
    _jump1606:;
    if (b >= 0)
    goto _jump1607;
    fail_assertion("negative array index");
    _jump1607:;
    if (b < _414.d1)
    goto _jump1608;
    fail_assertion("index too large");
    _jump1608:;
    if (_421 >= 0)
    goto _jump1609;
    fail_assertion("negative array index");
    _jump1609:;
    if (_421 < _414.d2)
    goto _jump1610;
    fail_assertion("index too large");
    _jump1610:;
    int64_t _423 = 0;
    _423 *= _414.d0;
    _423 += _36.d0;
    _423 *= _414.d1;
    _423 += b;
    _423 *= _414.d2;
    _423 += _421;
    int64_t _424 = _414.data[_423];
    if (_408 >= 0)
    goto _jump1611;
    fail_assertion("negative array index");
    _jump1611:;
    if (_408 < _397.d0)
    goto _jump1612;
    fail_assertion("index too large");
    _jump1612:;
    if (_413 >= 0)
    goto _jump1613;
    fail_assertion("negative array index");
    _jump1613:;
    if (_413 < _397.d1)
    goto _jump1614;
    fail_assertion("index too large");
    _jump1614:;
    if (_424 >= 0)
    goto _jump1615;
    fail_assertion("negative array index");
    _jump1615:;
    if (_424 < _397.d2)
    goto _jump1616;
    fail_assertion("index too large");
    _jump1616:;
    int64_t _425 = 0;
    _425 *= _397.d0;
    _425 += _408;
    _425 *= _397.d1;
    _425 += _413;
    _425 *= _397.d2;
    _425 += _424;
    double _426 = _397.data[_425];
    _396 = _426;
    goto _jump1617;
    _jump1586:;
    bool _427 = !_263;
    double _428;
    if (!_427)
    goto _jump1618;
    double _429;
    // Computing bound for q
    if (d > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    _429 = 0;
    int64_t _430 = 0; // q
    _jump1620:; // Begin body of loop
    double _431 = 53.0;
    _429 += _431;
    _430++;
    if (_430 < d)
    goto _jump1620;
    // End body of loop
    _428 = _429;
    goto _jump1621;
    _jump1618:;
    double _432;
    // Computing bound for q
    if (c > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    // Computing bound for r
    if (_36.d0 > 0) 
    goto _jump1623;
    fail_assertion("non-positive loop bound");
    _jump1623:;
    // Computing bound for s
    if (j > 0) 
    goto _jump1624;
    fail_assertion("non-positive loop bound");
    _jump1624:;
    _432 = 0;
    int64_t _433 = 0; // s
    int64_t _434 = 0; // r
    int64_t _435 = 0; // q
    _jump1625:; // Begin body of loop
    double _436 = 14.0;
    _432 += _436;
    _433++;
    if (_433 < j)
    goto _jump1625;
    _433 = 0;
    _434++;
    if (_434 < _36.d0)
    goto _jump1625;
    _434 = 0;
    _435++;
    if (_435 < c)
    goto _jump1625;
    // End body of loop
    double _437 = -_432;
    _428 = _437;
    _jump1621:;
    _396 = _428;
    _jump1617:;
    _366 = _396;
    _jump1574:;
    _356 = _366;
    goto _jump1626;
    _jump1549:;
    double _438 = 69.0;
    _356 = _438;
    _jump1626:;
    _a1__a1_void_t _439;
    // Computing bound for q
    int64_t _440;
    // Computing bound for q
    _a2_int64_t _441;
    // Computing bound for q
    _441.d0 = i;
    if (i > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing bound for r
    _441.d1 = j;
    if (j > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing total size of heap memory to allocate
    int64_t _442 = 1;
    _442 *= i;
    _442 *= j;
    _442 *= sizeof(int64_t);
    _441.data = jpl_alloc(_442);
    int64_t _443 = 0; // r
    int64_t _444 = 0; // q
    _jump1629:; // Begin body of loop
    int64_t _445 = 0;
    _445 *= _441.d0;
    _445 += _444;
    _445 *= _441.d1;
    _445 += _443;
    _441.data[_445] = _36.d1;
    _443++;
    if (_443 < j)
    goto _jump1629;
    _443 = 0;
    _444++;
    if (_444 < i)
    goto _jump1629;
    // End body of loop
    if (_36.d0 >= 0)
    goto _jump1630;
    fail_assertion("negative array index");
    _jump1630:;
    if (_36.d0 < _441.d0)
    goto _jump1631;
    fail_assertion("index too large");
    _jump1631:;
    if (j >= 0)
    goto _jump1632;
    fail_assertion("negative array index");
    _jump1632:;
    if (j < _441.d1)
    goto _jump1633;
    fail_assertion("index too large");
    _jump1633:;
    int64_t _446 = 0;
    _446 *= _441.d0;
    _446 += _36.d0;
    _446 *= _441.d1;
    _446 += j;
    int64_t _447 = _441.data[_446];
    if (_447 > 0) 
    goto _jump1634;
    fail_assertion("non-positive loop bound");
    _jump1634:;
    // Computing bound for r
    if (b > 0) 
    goto _jump1635;
    fail_assertion("non-positive loop bound");
    _jump1635:;
    _440 = 0;
    int64_t _448 = 0; // r
    int64_t _449 = 0; // q
    _jump1636:; // Begin body of loop
    int64_t _450;
    // Computing bound for s
    if (_449 > 0) 
    goto _jump1637;
    fail_assertion("non-positive loop bound");
    _jump1637:;
    // Computing bound for t
    if (i > 0) 
    goto _jump1638;
    fail_assertion("non-positive loop bound");
    _jump1638:;
    // Computing bound for u
    if (h > 0) 
    goto _jump1639;
    fail_assertion("non-positive loop bound");
    _jump1639:;
    _450 = 0;
    int64_t _451 = 0; // u
    int64_t _452 = 0; // t
    int64_t _453 = 0; // s
    _jump1640:; // Begin body of loop
    _450 += b;
    _451++;
    if (_451 < h)
    goto _jump1640;
    _451 = 0;
    _452++;
    if (_452 < i)
    goto _jump1640;
    _452 = 0;
    _453++;
    if (_453 < _449)
    goto _jump1640;
    // End body of loop
    int64_t _454 = -_450;
    _440 += _454;
    _448++;
    if (_448 < b)
    goto _jump1636;
    _448 = 0;
    _449++;
    if (_449 < _447)
    goto _jump1636;
    // End body of loop
    _439.d0 = _440;
    if (_440 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    // Computing total size of heap memory to allocate
    int64_t _455 = 1;
    _455 *= _440;
    _455 *= sizeof(_a1_void_t);
    _439.data = jpl_alloc(_455);
    int64_t _456 = 0; // q
    _jump1642:; // Begin body of loop
    void_t _457 = l();
    _a1_void_t _458;
    _458.d0 = 1;
    _458.data = jpl_alloc(sizeof(void_t) * 1);
    _458.data[0] = _457;
    int64_t _459 = 0;
    _459 *= _439.d0;
    _459 += _456;
    _439.data[_459] = _458;
    _456++;
    if (_456 < _440)
    goto _jump1642;
    // End body of loop
    _a1_int64_t _460;
    _460.d0 = 1;
    _460.data = jpl_alloc(sizeof(int64_t) * 1);
    _460.data[0] = j;
    int64_t _461 = -_36.d0;
    if (d >= 0)
    goto _jump1643;
    fail_assertion("negative array index");
    _jump1643:;
    if (d < g.d0)
    goto _jump1644;
    fail_assertion("index too large");
    _jump1644:;
    if (d >= 0)
    goto _jump1645;
    fail_assertion("negative array index");
    _jump1645:;
    if (d < g.d1)
    goto _jump1646;
    fail_assertion("index too large");
    _jump1646:;
    if (_461 >= 0)
    goto _jump1647;
    fail_assertion("negative array index");
    _jump1647:;
    if (_461 < g.d2)
    goto _jump1648;
    fail_assertion("index too large");
    _jump1648:;
    int64_t _462 = 0;
    _462 *= g.d0;
    _462 += d;
    _462 *= g.d1;
    _462 += d;
    _462 *= g.d2;
    _462 += _461;
    int64_t _463 = g.data[_462];
    if (_463 >= 0)
    goto _jump1649;
    fail_assertion("negative array index");
    _jump1649:;
    if (_463 < _460.d0)
    goto _jump1650;
    fail_assertion("index too large");
    _jump1650:;
    int64_t _464 = 0;
    _464 *= _460.d0;
    _464 += _463;
    int64_t _465 = _460.data[_464];
    if (h >= 0)
    goto _jump1651;
    fail_assertion("negative array index");
    _jump1651:;
    if (h < _36.d0)
    goto _jump1652;
    fail_assertion("index too large");
    _jump1652:;
    if (_465 >= 0)
    goto _jump1653;
    fail_assertion("negative array index");
    _jump1653:;
    if (_465 < _36.d1)
    goto _jump1654;
    fail_assertion("index too large");
    _jump1654:;
    int64_t _466 = 0;
    _466 *= _36.d0;
    _466 += h;
    _466 *= _36.d1;
    _466 += _465;
    int64_t _467 = _36.data[_466];
    if (_467 >= 0)
    goto _jump1655;
    fail_assertion("negative array index");
    _jump1655:;
    if (_467 < _439.d0)
    goto _jump1656;
    fail_assertion("index too large");
    _jump1656:;
    int64_t _468 = 0;
    _468 *= _439.d0;
    _468 += _467;
    _a1_void_t _469 = _439.data[_468];
    if (_36.d1 >= 0)
    goto _jump1657;
    fail_assertion("negative array index");
    _jump1657:;
    if (_36.d1 < _469.d0)
    goto _jump1658;
    fail_assertion("index too large");
    _jump1658:;
    int64_t _470 = 0;
    _470 *= _469.d0;
    _470 += _36.d1;
    void_t _471 = _469.data[_470];
    _a1_rgba _472 = k(_356, _471);
    void_t _473 = l();
    return _473;
}

_a2_double v(_a3_int64_t w, rgba A) {
    bool _0 = false;
    rgba _1;
    if (!_0)
    goto _jump1728;
    bool _2 = false;
    bool _3 = !_2;
    bool _4 = true;
    bool _5 = _3 == _4;
    rgba _6;
    if (!_5)
    goto _jump1729;
    _a3_double _7;
    // Computing bound for B
    _7.d0 = d;
    if (d > 0) 
    goto _jump1730;
    fail_assertion("non-positive loop bound");
    _jump1730:;
    // Computing bound for C
    _7.d1 = w.d0;
    if (w.d0 > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    // Computing bound for D
    _7.d2 = b;
    if (b > 0) 
    goto _jump1732;
    fail_assertion("non-positive loop bound");
    _jump1732:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= d;
    _8 *= w.d0;
    _8 *= b;
    _8 *= sizeof(double);
    _7.data = jpl_alloc(_8);
    int64_t _9 = 0; // D
    int64_t _10 = 0; // C
    int64_t _11 = 0; // B
    _jump1733:; // Begin body of loop
    int64_t _12 = 0;
    _12 *= _7.d0;
    _12 += _11;
    _12 *= _7.d1;
    _12 += _10;
    _12 *= _7.d2;
    _12 += _9;
    _7.data[_12] = t;
    _9++;
    if (_9 < b)
    goto _jump1733;
    _9 = 0;
    _10++;
    if (_10 < w.d0)
    goto _jump1733;
    _10 = 0;
    _11++;
    if (_11 < d)
    goto _jump1733;
    // End body of loop
    rgba _13 = e(_7, q);
    _6 = _13;
    goto _jump1734;
    _jump1729:;
    _a3_double _14;
    // Computing bound for B
    _14.d0 = c;
    if (c > 0) 
    goto _jump1735;
    fail_assertion("non-positive loop bound");
    _jump1735:;
    // Computing bound for C
    _14.d1 = w.d2;
    if (w.d2 > 0) 
    goto _jump1736;
    fail_assertion("non-positive loop bound");
    _jump1736:;
    // Computing bound for D
    _14.d2 = r;
    if (r > 0) 
    goto _jump1737;
    fail_assertion("non-positive loop bound");
    _jump1737:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= c;
    _15 *= w.d2;
    _15 *= r;
    _15 *= sizeof(double);
    _14.data = jpl_alloc(_15);
    int64_t _16 = 0; // D
    int64_t _17 = 0; // C
    int64_t _18 = 0; // B
    _jump1738:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _14.d0;
    _19 += _18;
    _19 *= _14.d1;
    _19 += _17;
    _19 *= _14.d2;
    _19 += _16;
    _14.data[_19] = t;
    _16++;
    if (_16 < r)
    goto _jump1738;
    _16 = 0;
    _17++;
    if (_17 < w.d2)
    goto _jump1738;
    _17 = 0;
    _18++;
    if (_18 < c)
    goto _jump1738;
    // End body of loop
    _a1_bool _20;
    // Computing bound for B
    _20.d0 = u;
    if (u > 0) 
    goto _jump1739;
    fail_assertion("non-positive loop bound");
    _jump1739:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= u;
    _21 *= sizeof(bool);
    _20.data = jpl_alloc(_21);
    int64_t _22 = 0; // B
    _jump1740:; // Begin body of loop
    bool _23 = false;
    int64_t _24 = 0;
    _24 *= _20.d0;
    _24 += _22;
    _20.data[_24] = _23;
    _22++;
    if (_22 < u)
    goto _jump1740;
    // End body of loop
    rgba _25 = e(_14, _20);
    _6 = _25;
    _jump1734:;
    _1 = _6;
    goto _jump1741;
    _jump1728:;
    bool _26 = t == t;
    _a3_double _27;
    if (!_26)
    goto _jump1742;
    _a3_double _28;
    // Computing bound for B
    int64_t _29 = 705;
    _28.d0 = _29;
    if (_29 > 0) 
    goto _jump1743;
    fail_assertion("non-positive loop bound");
    _jump1743:;
    // Computing bound for C
    _28.d1 = w.d0;
    if (w.d0 > 0) 
    goto _jump1744;
    fail_assertion("non-positive loop bound");
    _jump1744:;
    // Computing bound for D
    _28.d2 = h;
    if (h > 0) 
    goto _jump1745;
    fail_assertion("non-positive loop bound");
    _jump1745:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _29;
    _30 *= w.d0;
    _30 *= h;
    _30 *= sizeof(double);
    _28.data = jpl_alloc(_30);
    int64_t _31 = 0; // D
    int64_t _32 = 0; // C
    int64_t _33 = 0; // B
    _jump1746:; // Begin body of loop
    double _34 = 96.0;
    int64_t _35 = 0;
    _35 *= _28.d0;
    _35 += _33;
    _35 *= _28.d1;
    _35 += _32;
    _35 *= _28.d2;
    _35 += _31;
    _28.data[_35] = _34;
    _31++;
    if (_31 < h)
    goto _jump1746;
    _31 = 0;
    _32++;
    if (_32 < w.d0)
    goto _jump1746;
    _32 = 0;
    _33++;
    if (_33 < _29)
    goto _jump1746;
    // End body of loop
    _27 = _28;
    goto _jump1747;
    _jump1742:;
    _a3_double _36;
    // Computing bound for B
    _36.d0 = j;
    if (j > 0) 
    goto _jump1748;
    fail_assertion("non-positive loop bound");
    _jump1748:;
    // Computing bound for C
    _36.d1 = j;
    if (j > 0) 
    goto _jump1749;
    fail_assertion("non-positive loop bound");
    _jump1749:;
    // Computing bound for D
    _36.d2 = u;
    if (u > 0) 
    goto _jump1750;
    fail_assertion("non-positive loop bound");
    _jump1750:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= j;
    _37 *= j;
    _37 *= u;
    _37 *= sizeof(double);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // D
    int64_t _39 = 0; // C
    int64_t _40 = 0; // B
    _jump1751:; // Begin body of loop
    int64_t _41 = 0;
    _41 *= _36.d0;
    _41 += _40;
    _41 *= _36.d1;
    _41 += _39;
    _41 *= _36.d2;
    _41 += _38;
    _36.data[_41] = t;
    _38++;
    if (_38 < u)
    goto _jump1751;
    _38 = 0;
    _39++;
    if (_39 < j)
    goto _jump1751;
    _39 = 0;
    _40++;
    if (_40 < j)
    goto _jump1751;
    // End body of loop
    _27 = _36;
    _jump1747:;
    if (n >= 0)
    goto _jump1752;
    fail_assertion("negative array index");
    _jump1752:;
    if (n < s.d0)
    goto _jump1753;
    fail_assertion("index too large");
    _jump1753:;
    int64_t _42 = 0;
    _42 *= s.d0;
    _42 += n;
    bool _43 = s.data[_42];
    _a1_bool _44;
    if (!_43)
    goto _jump1754;
    _a1_bool _45;
    // Computing bound for B
    _45.d0 = j;
    if (j > 0) 
    goto _jump1755;
    fail_assertion("non-positive loop bound");
    _jump1755:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= j;
    _46 *= sizeof(bool);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // B
    _jump1756:; // Begin body of loop
    bool _48 = false;
    int64_t _49 = 0;
    _49 *= _45.d0;
    _49 += _47;
    _45.data[_49] = _48;
    _47++;
    if (_47 < j)
    goto _jump1756;
    // End body of loop
    _44 = _45;
    goto _jump1757;
    _jump1754:;
    bool _50 = false;
    _a1_bool _51;
    if (!_50)
    goto _jump1758;
    _51 = q;
    goto _jump1759;
    _jump1758:;
    _51 = s;
    _jump1759:;
    _44 = _51;
    _jump1757:;
    rgba _52 = e(_27, _44);
    _1 = _52;
    _jump1741:;
    _a2_double _53 = v(g, _1);
    _a2_int64_t _54;
    // Computing bound for B
    _54.d0 = w.d2;
    if (w.d2 > 0) 
    goto _jump1760;
    fail_assertion("non-positive loop bound");
    _jump1760:;
    // Computing bound for C
    _54.d1 = u;
    if (u > 0) 
    goto _jump1761;
    fail_assertion("non-positive loop bound");
    _jump1761:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= w.d2;
    _55 *= u;
    _55 *= sizeof(int64_t);
    _54.data = jpl_alloc(_55);
    int64_t _56 = 0; // C
    int64_t _57 = 0; // B
    _jump1762:; // Begin body of loop
    int64_t _58 = 0;
    _58 *= _54.d0;
    _58 += _57;
    _58 *= _54.d1;
    _58 += _56;
    _54.data[_58] = w.d2;
    _56++;
    if (_56 < u)
    goto _jump1762;
    _56 = 0;
    _57++;
    if (_57 < w.d2)
    goto _jump1762;
    // End body of loop
    _a1__a2_int64_t _59;
    _59.d0 = 1;
    _59.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _59.data[0] = _54;
    if (h >= 0)
    goto _jump1763;
    fail_assertion("negative array index");
    _jump1763:;
    if (h < _59.d0)
    goto _jump1764;
    fail_assertion("index too large");
    _jump1764:;
    int64_t _60 = 0;
    _60 *= _59.d0;
    _60 += h;
    _a2_int64_t _61 = _59.data[_60];
    if (h >= 0)
    goto _jump1765;
    fail_assertion("negative array index");
    _jump1765:;
    if (h < _61.d0)
    goto _jump1766;
    fail_assertion("index too large");
    _jump1766:;
    if (b >= 0)
    goto _jump1767;
    fail_assertion("negative array index");
    _jump1767:;
    if (b < _61.d1)
    goto _jump1768;
    fail_assertion("index too large");
    _jump1768:;
    int64_t _62 = 0;
    _62 *= _61.d0;
    _62 += h;
    _62 *= _61.d1;
    _62 += b;
    int64_t _63 = _61.data[_62];
    int64_t _64 = 913;
    int64_t _65 = _63 % _64;
    if (h >= 0)
    goto _jump1769;
    fail_assertion("negative array index");
    _jump1769:;
    if (h < _53.d0)
    goto _jump1770;
    fail_assertion("index too large");
    _jump1770:;
    if (_65 >= 0)
    goto _jump1771;
    fail_assertion("negative array index");
    _jump1771:;
    if (_65 < _53.d1)
    goto _jump1772;
    fail_assertion("index too large");
    _jump1772:;
    int64_t _66 = 0;
    _66 *= _53.d0;
    _66 += h;
    _66 *= _53.d1;
    _66 += _65;
    double _67 = _53.data[_66];
    double _68 = 58.0;
    bool _69 = _67 < _68;
    if (0 != _69)
    goto _jump1773;
    fail_assertion("B");
    _jump1773:;
    bool _71 = false;
    bool _70 = _71;
    if (0 != _71)
    goto _jump1774;
    bool _73 = o > n;
    bool _72 = _73;
    if (0 == _73)
    goto _jump1775;
    double _74 = 86.0;
    double _75 = 83.0;
    double _76 = _74 + _75;
    double _77 = t + _76;
    double _78 = -_77;
    _a3_double _79;
    // Computing bound for B
    _79.d0 = u;
    if (u > 0) 
    goto _jump1776;
    fail_assertion("non-positive loop bound");
    _jump1776:;
    // Computing bound for C
    _79.d1 = w.d1;
    if (w.d1 > 0) 
    goto _jump1777;
    fail_assertion("non-positive loop bound");
    _jump1777:;
    // Computing bound for D
    _79.d2 = o;
    if (o > 0) 
    goto _jump1778;
    fail_assertion("non-positive loop bound");
    _jump1778:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= u;
    _80 *= w.d1;
    _80 *= o;
    _80 *= sizeof(double);
    _79.data = jpl_alloc(_80);
    int64_t _81 = 0; // D
    int64_t _82 = 0; // C
    int64_t _83 = 0; // B
    _jump1779:; // Begin body of loop
    double _84 = 84.0;
    double _85 = fmod(t, _84);
    int64_t _86 = 0;
    _86 *= _79.d0;
    _86 += _83;
    _86 *= _79.d1;
    _86 += _82;
    _86 *= _79.d2;
    _86 += _81;
    _79.data[_86] = _85;
    _81++;
    if (_81 < o)
    goto _jump1779;
    _81 = 0;
    _82++;
    if (_82 < w.d1)
    goto _jump1779;
    _82 = 0;
    _83++;
    if (_83 < u)
    goto _jump1779;
    // End body of loop
    int64_t _87;
    // Computing bound for B
    if (d > 0) 
    goto _jump1780;
    fail_assertion("non-positive loop bound");
    _jump1780:;
    // Computing bound for C
    if (b > 0) 
    goto _jump1781;
    fail_assertion("non-positive loop bound");
    _jump1781:;
    _87 = 0;
    int64_t _88 = 0; // C
    int64_t _89 = 0; // B
    _jump1782:; // Begin body of loop
    _87 += w.d1;
    _88++;
    if (_88 < b)
    goto _jump1782;
    _88 = 0;
    _89++;
    if (_89 < d)
    goto _jump1782;
    // End body of loop
    int64_t _90 = o - _87;
    if (i >= 0)
    goto _jump1783;
    fail_assertion("negative array index");
    _jump1783:;
    if (i < _79.d0)
    goto _jump1784;
    fail_assertion("index too large");
    _jump1784:;
    if (o >= 0)
    goto _jump1785;
    fail_assertion("negative array index");
    _jump1785:;
    if (o < _79.d1)
    goto _jump1786;
    fail_assertion("index too large");
    _jump1786:;
    if (_90 >= 0)
    goto _jump1787;
    fail_assertion("negative array index");
    _jump1787:;
    if (_90 < _79.d2)
    goto _jump1788;
    fail_assertion("index too large");
    _jump1788:;
    int64_t _91 = 0;
    _91 *= _79.d0;
    _91 += i;
    _91 *= _79.d1;
    _91 += o;
    _91 *= _79.d2;
    _91 += _90;
    double _92 = _79.data[_91];
    bool _93 = _78 < _92;
    bool _94 = !_93;
    _72 = _94;
    _jump1775:;
    _70 = _72;
    _jump1774:;
    if (0 != _70)
    goto _jump1789;
    fail_assertion("B");
    _jump1789:;
    bool _95 = true;
    if (0 != _95)
    goto _jump1790;
    fail_assertion("B");
    _jump1790:;
    _a2_double _96;
    // Computing bound for B
    _96.d0 = j;
    if (j > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    // Computing bound for C
    _96.d1 = i;
    if (i > 0) 
    goto _jump1792;
    fail_assertion("non-positive loop bound");
    _jump1792:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= j;
    _97 *= i;
    _97 *= sizeof(double);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // C
    int64_t _99 = 0; // B
    _jump1793:; // Begin body of loop
    double _100;
    // Computing bound for D
    int64_t _101 = b % w.d1;
    if (_101 > 0) 
    goto _jump1794;
    fail_assertion("non-positive loop bound");
    _jump1794:;
    // Computing bound for E
    if (w.d1 > 0) 
    goto _jump1795;
    fail_assertion("non-positive loop bound");
    _jump1795:;
    _100 = 0;
    int64_t _102 = 0; // E
    int64_t _103 = 0; // D
    _jump1796:; // Begin body of loop
    _a2__a3_double _104;
    // Computing bound for F
    _104.d0 = c;
    if (c > 0) 
    goto _jump1797;
    fail_assertion("non-positive loop bound");
    _jump1797:;
    // Computing bound for G
    _104.d1 = _102;
    if (_102 > 0) 
    goto _jump1798;
    fail_assertion("non-positive loop bound");
    _jump1798:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= c;
    _105 *= _102;
    _105 *= sizeof(_a3_double);
    _104.data = jpl_alloc(_105);
    int64_t _106 = 0; // G
    int64_t _107 = 0; // F
    _jump1799:; // Begin body of loop
    _a3_double _108;
    // Computing bound for H
    _108.d0 = _103;
    if (_103 > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for I
    _108.d1 = u;
    if (u > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing bound for J
    int64_t _109 = 203;
    _108.d2 = _109;
    if (_109 > 0) 
    goto _jump1802;
    fail_assertion("non-positive loop bound");
    _jump1802:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= _103;
    _110 *= u;
    _110 *= _109;
    _110 *= sizeof(double);
    _108.data = jpl_alloc(_110);
    int64_t _111 = 0; // J
    int64_t _112 = 0; // I
    int64_t _113 = 0; // H
    _jump1803:; // Begin body of loop
    double _114 = 13.0;
    int64_t _115 = 0;
    _115 *= _108.d0;
    _115 += _113;
    _115 *= _108.d1;
    _115 += _112;
    _115 *= _108.d2;
    _115 += _111;
    _108.data[_115] = _114;
    _111++;
    if (_111 < _109)
    goto _jump1803;
    _111 = 0;
    _112++;
    if (_112 < u)
    goto _jump1803;
    _112 = 0;
    _113++;
    if (_113 < _103)
    goto _jump1803;
    // End body of loop
    int64_t _116 = 0;
    _116 *= _104.d0;
    _116 += _107;
    _116 *= _104.d1;
    _116 += _106;
    _104.data[_116] = _108;
    _106++;
    if (_106 < _102)
    goto _jump1799;
    _106 = 0;
    _107++;
    if (_107 < c)
    goto _jump1799;
    // End body of loop
    if (h >= 0)
    goto _jump1804;
    fail_assertion("negative array index");
    _jump1804:;
    if (h < _104.d0)
    goto _jump1805;
    fail_assertion("index too large");
    _jump1805:;
    if (w.d2 >= 0)
    goto _jump1806;
    fail_assertion("negative array index");
    _jump1806:;
    if (w.d2 < _104.d1)
    goto _jump1807;
    fail_assertion("index too large");
    _jump1807:;
    int64_t _117 = 0;
    _117 *= _104.d0;
    _117 += h;
    _117 *= _104.d1;
    _117 += w.d2;
    _a3_double _118 = _104.data[_117];
    rgba _119 = e(_118, s);
    double _120 = _119.a;
    _100 += _120;
    _102++;
    if (_102 < w.d1)
    goto _jump1796;
    _102 = 0;
    _103++;
    if (_103 < _101)
    goto _jump1796;
    // End body of loop
    int64_t _121 = 0;
    _121 *= _96.d0;
    _121 += _99;
    _121 *= _96.d1;
    _121 += _98;
    _96.data[_121] = _100;
    _98++;
    if (_98 < i)
    goto _jump1793;
    _98 = 0;
    _99++;
    if (_99 < j)
    goto _jump1793;
    // End body of loop
    return _96;
    bool _122 = i == w.d2;
    bool _123;
    if (!_122)
    goto _jump1808;
    double _124 = 96.0;
    double _125 = 28.0;
    bool _126 = _124 != _125;
    if (m.d0 >= 0)
    goto _jump1809;
    fail_assertion("negative array index");
    _jump1809:;
    if (m.d0 < m.d0)
    goto _jump1810;
    fail_assertion("index too large");
    _jump1810:;
    if (u >= 0)
    goto _jump1811;
    fail_assertion("negative array index");
    _jump1811:;
    if (u < m.d1)
    goto _jump1812;
    fail_assertion("index too large");
    _jump1812:;
    int64_t _127 = 0;
    _127 *= m.d0;
    _127 += m.d0;
    _127 *= m.d1;
    _127 += u;
    bool _128 = m.data[_127];
    bool _129 = !_128;
    bool _130 = _126 == _129;
    _123 = _130;
    goto _jump1813;
    _jump1808:;
    bool _132 = true;
    bool _131 = _132;
    if (0 == _132)
    goto _jump1814;
    bool _133 = false;
    _131 = _133;
    _jump1814:;
    bool _134;
    if (!_131)
    goto _jump1815;
    bool _136 = d == w.d0;
    bool _137;
    if (!_136)
    goto _jump1816;
    int64_t _138 = 959;
    bool _139 = _138 < u;
    _137 = _139;
    goto _jump1817;
    _jump1816:;
    if (m.d0 >= 0)
    goto _jump1818;
    fail_assertion("negative array index");
    _jump1818:;
    if (m.d0 < m.d0)
    goto _jump1819;
    fail_assertion("index too large");
    _jump1819:;
    if (o >= 0)
    goto _jump1820;
    fail_assertion("negative array index");
    _jump1820:;
    if (o < m.d1)
    goto _jump1821;
    fail_assertion("index too large");
    _jump1821:;
    int64_t _140 = 0;
    _140 *= m.d0;
    _140 += m.d0;
    _140 *= m.d1;
    _140 += o;
    bool _141 = m.data[_140];
    _137 = _141;
    _jump1817:;
    bool _142;
    if (!_137)
    goto _jump1822;
    bool _143 = false;
    _142 = _143;
    goto _jump1823;
    _jump1822:;
    bool _144 = true;
    _142 = _144;
    _jump1823:;
    bool _135 = _142;
    if (0 == _142)
    goto _jump1824;
    double _146 = A.a;
    bool _147 = t >= _146;
    bool _145 = _147;
    if (0 == _147)
    goto _jump1825;
    if (u >= 0)
    goto _jump1826;
    fail_assertion("negative array index");
    _jump1826:;
    if (u < m.d0)
    goto _jump1827;
    fail_assertion("index too large");
    _jump1827:;
    if (r >= 0)
    goto _jump1828;
    fail_assertion("negative array index");
    _jump1828:;
    if (r < m.d1)
    goto _jump1829;
    fail_assertion("index too large");
    _jump1829:;
    int64_t _148 = 0;
    _148 *= m.d0;
    _148 += u;
    _148 *= m.d1;
    _148 += r;
    bool _149 = m.data[_148];
    bool _150 = !_149;
    _145 = _150;
    _jump1825:;
    _135 = _145;
    _jump1824:;
    _134 = _135;
    goto _jump1830;
    _jump1815:;
    double _151;
    // Computing bound for E
    if (j > 0) 
    goto _jump1831;
    fail_assertion("non-positive loop bound");
    _jump1831:;
    // Computing bound for F
    if (w.d2 > 0) 
    goto _jump1832;
    fail_assertion("non-positive loop bound");
    _jump1832:;
    // Computing bound for G
    if (c > 0) 
    goto _jump1833;
    fail_assertion("non-positive loop bound");
    _jump1833:;
    _151 = 0;
    int64_t _152 = 0; // G
    int64_t _153 = 0; // F
    int64_t _154 = 0; // E
    _jump1834:; // Begin body of loop
    double _155;
    // Computing bound for H
    int64_t _156 = -o;
    if (_156 > 0) 
    goto _jump1835;
    fail_assertion("non-positive loop bound");
    _jump1835:;
    // Computing bound for I
    if (_154 > 0) 
    goto _jump1836;
    fail_assertion("non-positive loop bound");
    _jump1836:;
    // Computing bound for J
    if (w.d2 > 0) 
    goto _jump1837;
    fail_assertion("non-positive loop bound");
    _jump1837:;
    _155 = 0;
    int64_t _157 = 0; // J
    int64_t _158 = 0; // I
    int64_t _159 = 0; // H
    _jump1838:; // Begin body of loop
    double _160 = A.g;
    _155 += _160;
    _157++;
    if (_157 < w.d2)
    goto _jump1838;
    _157 = 0;
    _158++;
    if (_158 < _154)
    goto _jump1838;
    _158 = 0;
    _159++;
    if (_159 < _156)
    goto _jump1838;
    // End body of loop
    _151 += _155;
    _152++;
    if (_152 < c)
    goto _jump1834;
    _152 = 0;
    _153++;
    if (_153 < w.d2)
    goto _jump1834;
    _153 = 0;
    _154++;
    if (_154 < j)
    goto _jump1834;
    // End body of loop
    _a1_double _161;
    // Computing bound for E
    _161.d0 = m.d0;
    if (m.d0 > 0) 
    goto _jump1839;
    fail_assertion("non-positive loop bound");
    _jump1839:;
    // Computing total size of heap memory to allocate
    int64_t _162 = 1;
    _162 *= m.d0;
    _162 *= sizeof(double);
    _161.data = jpl_alloc(_162);
    int64_t _163 = 0; // E
    _jump1840:; // Begin body of loop
    int64_t _164 = 0;
    _164 *= _161.d0;
    _164 += _163;
    _161.data[_164] = t;
    _163++;
    if (_163 < m.d0)
    goto _jump1840;
    // End body of loop
    if (i >= 0)
    goto _jump1841;
    fail_assertion("negative array index");
    _jump1841:;
    if (i < _161.d0)
    goto _jump1842;
    fail_assertion("index too large");
    _jump1842:;
    int64_t _165 = 0;
    _165 *= _161.d0;
    _165 += i;
    double _166 = _161.data[_165];
    bool _167 = _151 <= _166;
    _134 = _167;
    _jump1830:;
    _123 = _134;
    _jump1813:;
    _a2_double _168;
    if (!_123)
    goto _jump1843;
    if (m.d0 >= 0)
    goto _jump1844;
    fail_assertion("negative array index");
    _jump1844:;
    if (m.d0 < q.d0)
    goto _jump1845;
    fail_assertion("index too large");
    _jump1845:;
    int64_t _169 = 0;
    _169 *= q.d0;
    _169 += m.d0;
    bool _170 = q.data[_169];
    bool _171 = !_170;
    rgba _172;
    if (!_171)
    goto _jump1846;
    bool _173 = false;
    rgba _174;
    if (!_173)
    goto _jump1847;
    double _175 = 84.0;
    double _176 = t + _175;
    double _177 = A.b;
    bool _178 = _176 < _177;
    rgba _179;
    if (!_178)
    goto _jump1848;
    bool _180 = j == w.d2;
    rgba _181;
    if (!_180)
    goto _jump1849;
    _181 = A;
    goto _jump1850;
    _jump1849:;
    double _182 = 21.0;
    double _183 = 18.0;
    double _184 = 52.0;
    rgba _185 = { t, _182, _183, _184 };
    _181 = _185;
    _jump1850:;
    _179 = _181;
    goto _jump1851;
    _jump1848:;
    _179 = A;
    _jump1851:;
    _174 = _179;
    goto _jump1852;
    _jump1847:;
    _174 = A;
    _jump1852:;
    _172 = _174;
    goto _jump1853;
    _jump1846:;
    _172 = A;
    _jump1853:;
    _a2_double _186 = v(w, _172);
    _168 = _186;
    goto _jump1854;
    _jump1843:;
    _a2_double _187;
    // Computing bound for E
    int64_t _188 = w.d0 / h;
    _187.d0 = _188;
    if (_188 > 0) 
    goto _jump1855;
    fail_assertion("non-positive loop bound");
    _jump1855:;
    // Computing bound for F
    _187.d1 = w.d0;
    if (w.d0 > 0) 
    goto _jump1856;
    fail_assertion("non-positive loop bound");
    _jump1856:;
    // Computing total size of heap memory to allocate
    int64_t _189 = 1;
    _189 *= _188;
    _189 *= w.d0;
    _189 *= sizeof(double);
    _187.data = jpl_alloc(_189);
    int64_t _190 = 0; // F
    int64_t _191 = 0; // E
    _jump1857:; // Begin body of loop
    double _192;
    // Computing bound for G
    if (b >= 0)
    goto _jump1858;
    fail_assertion("negative array index");
    _jump1858:;
    if (b < q.d0)
    goto _jump1859;
    fail_assertion("index too large");
    _jump1859:;
    int64_t _193 = 0;
    _193 *= q.d0;
    _193 += b;
    bool _194 = q.data[_193];
    int64_t _195;
    if (!_194)
    goto _jump1860;
    _195 = _190;
    goto _jump1861;
    _jump1860:;
    bool _196 = c >= _191;
    _a2_int64_t _197;
    if (!_196)
    goto _jump1862;
    _a2_int64_t _198;
    // Computing bound for G
    _198.d0 = i;
    if (i > 0) 
    goto _jump1863;
    fail_assertion("non-positive loop bound");
    _jump1863:;
    // Computing bound for H
    _198.d1 = r;
    if (r > 0) 
    goto _jump1864;
    fail_assertion("non-positive loop bound");
    _jump1864:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= i;
    _199 *= r;
    _199 *= sizeof(int64_t);
    _198.data = jpl_alloc(_199);
    int64_t _200 = 0; // H
    int64_t _201 = 0; // G
    _jump1865:; // Begin body of loop
    int64_t _202 = 0;
    _202 *= _198.d0;
    _202 += _201;
    _202 *= _198.d1;
    _202 += _200;
    _198.data[_202] = r;
    _200++;
    if (_200 < r)
    goto _jump1865;
    _200 = 0;
    _201++;
    if (_201 < i)
    goto _jump1865;
    // End body of loop
    _197 = _198;
    goto _jump1866;
    _jump1862:;
    _a2_int64_t _203;
    // Computing bound for G
    _203.d0 = i;
    if (i > 0) 
    goto _jump1867;
    fail_assertion("non-positive loop bound");
    _jump1867:;
    // Computing bound for H
    _203.d1 = _190;
    if (_190 > 0) 
    goto _jump1868;
    fail_assertion("non-positive loop bound");
    _jump1868:;
    // Computing total size of heap memory to allocate
    int64_t _204 = 1;
    _204 *= i;
    _204 *= _190;
    _204 *= sizeof(int64_t);
    _203.data = jpl_alloc(_204);
    int64_t _205 = 0; // H
    int64_t _206 = 0; // G
    _jump1869:; // Begin body of loop
    int64_t _207 = 0;
    _207 *= _203.d0;
    _207 += _206;
    _207 *= _203.d1;
    _207 += _205;
    _203.data[_207] = w.d1;
    _205++;
    if (_205 < _190)
    goto _jump1869;
    _205 = 0;
    _206++;
    if (_206 < i)
    goto _jump1869;
    // End body of loop
    _197 = _203;
    _jump1866:;
    if (h >= 0)
    goto _jump1870;
    fail_assertion("negative array index");
    _jump1870:;
    if (h < _197.d0)
    goto _jump1871;
    fail_assertion("index too large");
    _jump1871:;
    if (w.d0 >= 0)
    goto _jump1872;
    fail_assertion("negative array index");
    _jump1872:;
    if (w.d0 < _197.d1)
    goto _jump1873;
    fail_assertion("index too large");
    _jump1873:;
    int64_t _208 = 0;
    _208 *= _197.d0;
    _208 += h;
    _208 *= _197.d1;
    _208 += w.d0;
    int64_t _209 = _197.data[_208];
    _195 = _209;
    _jump1861:;
    if (_195 > 0) 
    goto _jump1874;
    fail_assertion("non-positive loop bound");
    _jump1874:;
    // Computing bound for H
    if (o > 0) 
    goto _jump1875;
    fail_assertion("non-positive loop bound");
    _jump1875:;
    _192 = 0;
    int64_t _210 = 0; // H
    int64_t _211 = 0; // G
    _jump1876:; // Begin body of loop
    bool _212 = true;
    _a3_bool _213;
    if (!_212)
    goto _jump1877;
    _213 = a;
    goto _jump1878;
    _jump1877:;
    _213 = a;
    _jump1878:;
    int64_t _214 = 896;
    if (u >= 0)
    goto _jump1879;
    fail_assertion("negative array index");
    _jump1879:;
    if (u < _213.d0)
    goto _jump1880;
    fail_assertion("index too large");
    _jump1880:;
    if (_214 >= 0)
    goto _jump1881;
    fail_assertion("negative array index");
    _jump1881:;
    if (_214 < _213.d1)
    goto _jump1882;
    fail_assertion("index too large");
    _jump1882:;
    if (o >= 0)
    goto _jump1883;
    fail_assertion("negative array index");
    _jump1883:;
    if (o < _213.d2)
    goto _jump1884;
    fail_assertion("index too large");
    _jump1884:;
    int64_t _215 = 0;
    _215 *= _213.d0;
    _215 += u;
    _215 *= _213.d1;
    _215 += _214;
    _215 *= _213.d2;
    _215 += o;
    bool _216 = _213.data[_215];
    rgba _217;
    if (!_216)
    goto _jump1885;
    double _218 = 16.0;
    double _219 = -_218;
    double _220 = 36.0;
    rgba _221 = { _219, _220, t, t };
    _217 = _221;
    goto _jump1886;
    _jump1885:;
    _217 = A;
    _jump1886:;
    double _222 = _217.b;
    _192 += _222;
    _210++;
    if (_210 < o)
    goto _jump1876;
    _210 = 0;
    _211++;
    if (_211 < _195)
    goto _jump1876;
    // End body of loop
    int64_t _223 = 0;
    _223 *= _187.d0;
    _223 += _191;
    _223 *= _187.d1;
    _223 += _190;
    _187.data[_223] = _192;
    _190++;
    if (_190 < w.d0)
    goto _jump1857;
    _190 = 0;
    _191++;
    if (_191 < _188)
    goto _jump1857;
    // End body of loop
    _168 = _187;
    _jump1854:;
    return _168;
}

p w(_a3_bool x) {
    _a2_bool _1;
    // Computing bound for B
    bool _2 = b < d;
    int64_t _3;
    if (!_2)
    goto _jump1887;
    _3 = j;
    goto _jump1888;
    _jump1887:;
    int64_t _4;
    // Computing bound for B
    if (o > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    // Computing bound for C
    if (i > 0) 
    goto _jump1890;
    fail_assertion("non-positive loop bound");
    _jump1890:;
    _4 = 0;
    int64_t _5 = 0; // C
    int64_t _6 = 0; // B
    _jump1891:; // Begin body of loop
    _4 += o;
    _5++;
    if (_5 < i)
    goto _jump1891;
    _5 = 0;
    _6++;
    if (_6 < o)
    goto _jump1891;
    // End body of loop
    _3 = _4;
    _jump1888:;
    int64_t _7 = r - _3;
    _1.d0 = _7;
    if (_7 > 0) 
    goto _jump1892;
    fail_assertion("non-positive loop bound");
    _jump1892:;
    // Computing bound for C
    int64_t _8;
    // Computing bound for B
    if (n > 0) 
    goto _jump1893;
    fail_assertion("non-positive loop bound");
    _jump1893:;
    _8 = 0;
    int64_t _9 = 0; // B
    _jump1894:; // Begin body of loop
    int64_t _10;
    // Computing bound for C
    if (x.d2 > 0) 
    goto _jump1895;
    fail_assertion("non-positive loop bound");
    _jump1895:;
    // Computing bound for D
    if (d > 0) 
    goto _jump1896;
    fail_assertion("non-positive loop bound");
    _jump1896:;
    _10 = 0;
    int64_t _11 = 0; // D
    int64_t _12 = 0; // C
    _jump1897:; // Begin body of loop
    int64_t _13 = 391;
    _10 += _13;
    _11++;
    if (_11 < d)
    goto _jump1897;
    _11 = 0;
    _12++;
    if (_12 < x.d2)
    goto _jump1897;
    // End body of loop
    _8 += _10;
    _9++;
    if (_9 < n)
    goto _jump1894;
    // End body of loop
    int64_t _14 = -_8;
    _1.d1 = _14;
    if (_14 > 0) 
    goto _jump1898;
    fail_assertion("non-positive loop bound");
    _jump1898:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= _7;
    _15 *= _14;
    _15 *= sizeof(bool);
    _1.data = jpl_alloc(_15);
    int64_t _16 = 0; // C
    int64_t _17 = 0; // B
    _jump1899:; // Begin body of loop
    if (r >= 0)
    goto _jump1900;
    fail_assertion("negative array index");
    _jump1900:;
    if (r < m.d0)
    goto _jump1901;
    fail_assertion("index too large");
    _jump1901:;
    if (u >= 0)
    goto _jump1902;
    fail_assertion("negative array index");
    _jump1902:;
    if (u < m.d1)
    goto _jump1903;
    fail_assertion("index too large");
    _jump1903:;
    int64_t _19 = 0;
    _19 *= m.d0;
    _19 += r;
    _19 *= m.d1;
    _19 += u;
    bool _20 = m.data[_19];
    bool _18 = _20;
    if (0 == _20)
    goto _jump1904;
    bool _21 = i == n;
    bool _22 = !_21;
    _18 = _22;
    _jump1904:;
    int64_t _23 = 0;
    _23 *= _1.d0;
    _23 += _17;
    _23 *= _1.d1;
    _23 += _16;
    _1.data[_23] = _18;
    _16++;
    if (_16 < _14)
    goto _jump1899;
    _16 = 0;
    _17++;
    if (_17 < _7)
    goto _jump1899;
    // End body of loop
    int64_t _24 = 106;
    if (_24 >= 0)
    goto _jump1905;
    fail_assertion("negative array index");
    _jump1905:;
    if (_24 < _1.d0)
    goto _jump1906;
    fail_assertion("index too large");
    _jump1906:;
    if (j >= 0)
    goto _jump1907;
    fail_assertion("negative array index");
    _jump1907:;
    if (j < _1.d1)
    goto _jump1908;
    fail_assertion("index too large");
    _jump1908:;
    int64_t _25 = 0;
    _25 *= _1.d0;
    _25 += _24;
    _25 *= _1.d1;
    _25 += j;
    bool _26 = _1.data[_25];
    bool _0 = _26;
    if (0 == _26)
    goto _jump1909;
    if (b >= 0)
    goto _jump1910;
    fail_assertion("negative array index");
    _jump1910:;
    if (b < m.d0)
    goto _jump1911;
    fail_assertion("index too large");
    _jump1911:;
    if (j >= 0)
    goto _jump1912;
    fail_assertion("negative array index");
    _jump1912:;
    if (j < m.d1)
    goto _jump1913;
    fail_assertion("index too large");
    _jump1913:;
    int64_t _28 = 0;
    _28 *= m.d0;
    _28 += b;
    _28 *= m.d1;
    _28 += j;
    bool _29 = m.data[_28];
    bool _27 = _29;
    if (0 != _29)
    goto _jump1914;
    if (o >= 0)
    goto _jump1915;
    fail_assertion("negative array index");
    _jump1915:;
    if (o < s.d0)
    goto _jump1916;
    fail_assertion("index too large");
    _jump1916:;
    int64_t _30 = 0;
    _30 *= s.d0;
    _30 += o;
    bool _31 = s.data[_30];
    _27 = _31;
    _jump1914:;
    bool _32 = !_27;
    _0 = _32;
    _jump1909:;
    bool _33;
    if (!_0)
    goto _jump1917;
    if (u >= 0)
    goto _jump1918;
    fail_assertion("negative array index");
    _jump1918:;
    if (u < x.d0)
    goto _jump1919;
    fail_assertion("index too large");
    _jump1919:;
    if (h >= 0)
    goto _jump1920;
    fail_assertion("negative array index");
    _jump1920:;
    if (h < x.d1)
    goto _jump1921;
    fail_assertion("index too large");
    _jump1921:;
    if (h >= 0)
    goto _jump1922;
    fail_assertion("negative array index");
    _jump1922:;
    if (h < x.d2)
    goto _jump1923;
    fail_assertion("index too large");
    _jump1923:;
    int64_t _35 = 0;
    _35 *= x.d0;
    _35 += u;
    _35 *= x.d1;
    _35 += h;
    _35 *= x.d2;
    _35 += h;
    bool _36 = x.data[_35];
    bool _34 = _36;
    if (0 != _36)
    goto _jump1924;
    bool _39 = true;
    bool _38 = _39;
    if (0 == _39)
    goto _jump1925;
    if (j >= 0)
    goto _jump1926;
    fail_assertion("negative array index");
    _jump1926:;
    if (j < s.d0)
    goto _jump1927;
    fail_assertion("index too large");
    _jump1927:;
    int64_t _42 = 0;
    _42 *= s.d0;
    _42 += j;
    bool _43 = s.data[_42];
    bool _41 = _43;
    if (0 != _43)
    goto _jump1928;
    bool _44 = false;
    bool _45 = !_44;
    _41 = _45;
    _jump1928:;
    bool _40 = _41;
    if (0 != _41)
    goto _jump1929;
    if (b >= 0)
    goto _jump1930;
    fail_assertion("negative array index");
    _jump1930:;
    if (b < s.d0)
    goto _jump1931;
    fail_assertion("index too large");
    _jump1931:;
    int64_t _46 = 0;
    _46 *= s.d0;
    _46 += b;
    bool _47 = s.data[_46];
    bool _48 = !_47;
    _40 = _48;
    _jump1929:;
    _38 = _40;
    _jump1925:;
    bool _37 = _38;
    if (0 == _38)
    goto _jump1932;
    int64_t _50;
    // Computing bound for B
    if (n > 0) 
    goto _jump1933;
    fail_assertion("non-positive loop bound");
    _jump1933:;
    // Computing bound for C
    if (x.d1 > 0) 
    goto _jump1934;
    fail_assertion("non-positive loop bound");
    _jump1934:;
    // Computing bound for D
    if (n > 0) 
    goto _jump1935;
    fail_assertion("non-positive loop bound");
    _jump1935:;
    _50 = 0;
    int64_t _51 = 0; // D
    int64_t _52 = 0; // C
    int64_t _53 = 0; // B
    _jump1936:; // Begin body of loop
    _50 += r;
    _51++;
    if (_51 < n)
    goto _jump1936;
    _51 = 0;
    _52++;
    if (_52 < x.d1)
    goto _jump1936;
    _52 = 0;
    _53++;
    if (_53 < n)
    goto _jump1936;
    // End body of loop
    bool _54 = r > _50;
    bool _49 = _54;
    if (0 == _54)
    goto _jump1937;
    bool _55 = i <= x.d2;
    bool _56;
    if (!_55)
    goto _jump1938;
    bool _57 = false;
    _56 = _57;
    goto _jump1939;
    _jump1938:;
    bool _58 = true;
    bool _59 = !_58;
    _56 = _59;
    _jump1939:;
    bool _60;
    if (!_56)
    goto _jump1940;
    int64_t _61 = 740;
    if (_61 >= 0)
    goto _jump1941;
    fail_assertion("negative array index");
    _jump1941:;
    if (_61 < q.d0)
    goto _jump1942;
    fail_assertion("index too large");
    _jump1942:;
    int64_t _62 = 0;
    _62 *= q.d0;
    _62 += _61;
    bool _63 = q.data[_62];
    _60 = _63;
    goto _jump1943;
    _jump1940:;
    bool _64 = d >= i;
    bool _65 = false;
    bool _66 = !_65;
    bool _67 = _64 != _66;
    _60 = _67;
    _jump1943:;
    _49 = _60;
    _jump1937:;
    _37 = _49;
    _jump1932:;
    _34 = _37;
    _jump1924:;
    _33 = _34;
    goto _jump1944;
    _jump1917:;
    bool _68 = true;
    _a1_bool _69;
    if (!_68)
    goto _jump1945;
    _69 = s;
    goto _jump1946;
    _jump1945:;
    _69 = q;
    _jump1946:;
    if (u >= 0)
    goto _jump1947;
    fail_assertion("negative array index");
    _jump1947:;
    if (u < _69.d0)
    goto _jump1948;
    fail_assertion("index too large");
    _jump1948:;
    int64_t _70 = 0;
    _70 *= _69.d0;
    _70 += u;
    bool _71 = _69.data[_70];
    bool _72 = !_71;
    bool _73;
    if (!_72)
    goto _jump1949;
    int64_t _74 = n * h;
    bool _75 = _74 >= o;
    bool _76 = !_75;
    _73 = _76;
    goto _jump1950;
    _jump1949:;
    int64_t _78 = 106;
    if (x.d1 >= 0)
    goto _jump1951;
    fail_assertion("negative array index");
    _jump1951:;
    if (x.d1 < x.d0)
    goto _jump1952;
    fail_assertion("index too large");
    _jump1952:;
    if (_78 >= 0)
    goto _jump1953;
    fail_assertion("negative array index");
    _jump1953:;
    if (_78 < x.d1)
    goto _jump1954;
    fail_assertion("index too large");
    _jump1954:;
    if (b >= 0)
    goto _jump1955;
    fail_assertion("negative array index");
    _jump1955:;
    if (b < x.d2)
    goto _jump1956;
    fail_assertion("index too large");
    _jump1956:;
    int64_t _79 = 0;
    _79 *= x.d0;
    _79 += x.d1;
    _79 *= x.d1;
    _79 += _78;
    _79 *= x.d2;
    _79 += b;
    bool _80 = x.data[_79];
    bool _77 = _80;
    if (0 != _80)
    goto _jump1957;
    bool _81 = h == u;
    _77 = _81;
    _jump1957:;
    bool _82;
    if (!_77)
    goto _jump1958;
    bool _83 = false;
    _82 = _83;
    goto _jump1959;
    _jump1958:;
    int64_t _84 = 70;
    int64_t _85 = -c;
    bool _86 = _84 != _85;
    _82 = _86;
    _jump1959:;
    _73 = _82;
    _jump1950:;
    bool _87;
    if (!_73)
    goto _jump1960;
    bool _88 = c != n;
    bool _89;
    if (!_88)
    goto _jump1961;
    if (b >= 0)
    goto _jump1962;
    fail_assertion("negative array index");
    _jump1962:;
    if (b < m.d0)
    goto _jump1963;
    fail_assertion("index too large");
    _jump1963:;
    if (x.d0 >= 0)
    goto _jump1964;
    fail_assertion("negative array index");
    _jump1964:;
    if (x.d0 < m.d1)
    goto _jump1965;
    fail_assertion("index too large");
    _jump1965:;
    int64_t _91 = 0;
    _91 *= m.d0;
    _91 += b;
    _91 *= m.d1;
    _91 += x.d0;
    bool _92 = m.data[_91];
    bool _90 = _92;
    if (0 != _92)
    goto _jump1966;
    if (x.d1 >= 0)
    goto _jump1967;
    fail_assertion("negative array index");
    _jump1967:;
    if (x.d1 < x.d0)
    goto _jump1968;
    fail_assertion("index too large");
    _jump1968:;
    if (h >= 0)
    goto _jump1969;
    fail_assertion("negative array index");
    _jump1969:;
    if (h < x.d1)
    goto _jump1970;
    fail_assertion("index too large");
    _jump1970:;
    if (b >= 0)
    goto _jump1971;
    fail_assertion("negative array index");
    _jump1971:;
    if (b < x.d2)
    goto _jump1972;
    fail_assertion("index too large");
    _jump1972:;
    int64_t _93 = 0;
    _93 *= x.d0;
    _93 += x.d1;
    _93 *= x.d1;
    _93 += h;
    _93 *= x.d2;
    _93 += b;
    bool _94 = x.data[_93];
    _90 = _94;
    _jump1966:;
    bool _95;
    if (!_90)
    goto _jump1973;
    if (j >= 0)
    goto _jump1974;
    fail_assertion("negative array index");
    _jump1974:;
    if (j < a.d0)
    goto _jump1975;
    fail_assertion("index too large");
    _jump1975:;
    if (x.d1 >= 0)
    goto _jump1976;
    fail_assertion("negative array index");
    _jump1976:;
    if (x.d1 < a.d1)
    goto _jump1977;
    fail_assertion("index too large");
    _jump1977:;
    if (j >= 0)
    goto _jump1978;
    fail_assertion("negative array index");
    _jump1978:;
    if (j < a.d2)
    goto _jump1979;
    fail_assertion("index too large");
    _jump1979:;
    int64_t _96 = 0;
    _96 *= a.d0;
    _96 += j;
    _96 *= a.d1;
    _96 += x.d1;
    _96 *= a.d2;
    _96 += j;
    bool _97 = a.data[_96];
    _95 = _97;
    goto _jump1980;
    _jump1973:;
    _a1_bool _98;
    // Computing bound for B
    _98.d0 = h;
    if (h > 0) 
    goto _jump1981;
    fail_assertion("non-positive loop bound");
    _jump1981:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= h;
    _99 *= sizeof(bool);
    _98.data = jpl_alloc(_99);
    int64_t _100 = 0; // B
    _jump1982:; // Begin body of loop
    bool _101 = true;
    int64_t _102 = 0;
    _102 *= _98.d0;
    _102 += _100;
    _98.data[_102] = _101;
    _100++;
    if (_100 < h)
    goto _jump1982;
    // End body of loop
    if (h >= 0)
    goto _jump1983;
    fail_assertion("negative array index");
    _jump1983:;
    if (h < _98.d0)
    goto _jump1984;
    fail_assertion("index too large");
    _jump1984:;
    int64_t _103 = 0;
    _103 *= _98.d0;
    _103 += h;
    bool _104 = _98.data[_103];
    _95 = _104;
    _jump1980:;
    _89 = _95;
    goto _jump1985;
    _jump1961:;
    double _106 = 52.0;
    double _107 = 75.0;
    bool _108 = _106 != _107;
    bool _105 = _108;
    if (0 == _108)
    goto _jump1986;
    double _109 = 49.0;
    bool _110 = t == _109;
    _105 = _110;
    _jump1986:;
    _89 = _105;
    _jump1985:;
    _87 = _89;
    goto _jump1987;
    _jump1960:;
    bool _111 = true;
    _87 = _111;
    _jump1987:;
    bool _112 = !_87;
    _33 = _112;
    _jump1944:;
    if (0 != _33)
    goto _jump1988;
    fail_assertion("B");
    _jump1988:;
    bool _113 = i != j;
    if (0 != _113)
    goto _jump1989;
    fail_assertion("C");
    _jump1989:;
    int64_t _114 = -c;
    bool _115 = x.d1 == _114;
    bool _116 = !_115;
    bool _117 = !_116;
    _a2_bool _118;
    if (!_117)
    goto _jump1990;
    _118 = m;
    goto _jump1991;
    _jump1990:;
    _a2_bool _119;
    // Computing bound for C
    _119.d0 = c;
    if (c > 0) 
    goto _jump1992;
    fail_assertion("non-positive loop bound");
    _jump1992:;
    // Computing bound for D
    _119.d1 = x.d1;
    if (x.d1 > 0) 
    goto _jump1993;
    fail_assertion("non-positive loop bound");
    _jump1993:;
    // Computing total size of heap memory to allocate
    int64_t _120 = 1;
    _120 *= c;
    _120 *= x.d1;
    _120 *= sizeof(bool);
    _119.data = jpl_alloc(_120);
    int64_t _121 = 0; // D
    int64_t _122 = 0; // C
    _jump1994:; // Begin body of loop
    bool _123 = false;
    double _124;
    if (!_123)
    goto _jump1995;
    double _125 = 82.0;
    _124 = _125;
    goto _jump1996;
    _jump1995:;
    _124 = t;
    _jump1996:;
    double _126;
    // Computing bound for E
    if (j > 0) 
    goto _jump1997;
    fail_assertion("non-positive loop bound");
    _jump1997:;
    // Computing bound for F
    if (_122 > 0) 
    goto _jump1998;
    fail_assertion("non-positive loop bound");
    _jump1998:;
    // Computing bound for G
    if (_122 > 0) 
    goto _jump1999;
    fail_assertion("non-positive loop bound");
    _jump1999:;
    _126 = 0;
    int64_t _127 = 0; // G
    int64_t _128 = 0; // F
    int64_t _129 = 0; // E
    _jump2000:; // Begin body of loop
    _126 += t;
    _127++;
    if (_127 < _122)
    goto _jump2000;
    _127 = 0;
    _128++;
    if (_128 < _122)
    goto _jump2000;
    _128 = 0;
    _129++;
    if (_129 < j)
    goto _jump2000;
    // End body of loop
    bool _130 = _124 >= _126;
    bool _131 = true;
    bool _132 = _130 == _131;
    int64_t _133 = 0;
    _133 *= _119.d0;
    _133 += _122;
    _133 *= _119.d1;
    _133 += _121;
    _119.data[_133] = _132;
    _121++;
    if (_121 < x.d1)
    goto _jump1994;
    _121 = 0;
    _122++;
    if (_122 < c)
    goto _jump1994;
    // End body of loop
    _118 = _119;
    _jump1991:;
    if (x.d2 >= 0)
    goto _jump2001;
    fail_assertion("negative array index");
    _jump2001:;
    if (x.d2 < _118.d0)
    goto _jump2002;
    fail_assertion("index too large");
    _jump2002:;
    if (o >= 0)
    goto _jump2003;
    fail_assertion("negative array index");
    _jump2003:;
    if (o < _118.d1)
    goto _jump2004;
    fail_assertion("index too large");
    _jump2004:;
    int64_t _134 = 0;
    _134 *= _118.d0;
    _134 += x.d2;
    _134 *= _118.d1;
    _134 += o;
    bool _135 = _118.data[_134];
    p _136;
    if (!_135)
    goto _jump2005;
    int64_t _137 = 200;
    bool _138 = r > _137;
    p _139;
    if (!_138)
    goto _jump2006;
    p _140 = w(x);
    double _141 = _140.a;
    double _142;
    // Computing bound for C
    int64_t _143 = 329;
    bool _144 = _143 > j;
    int64_t _145;
    if (!_144)
    goto _jump2007;
    _145 = c;
    goto _jump2008;
    _jump2007:;
    _145 = x.d2;
    _jump2008:;
    if (_145 > 0) 
    goto _jump2009;
    fail_assertion("non-positive loop bound");
    _jump2009:;
    _142 = 0;
    int64_t _146 = 0; // C
    _jump2010:; // Begin body of loop
    _142 += t;
    _146++;
    if (_146 < _145)
    goto _jump2010;
    // End body of loop
    bool _147 = _141 < _142;
    p _148;
    if (!_147)
    goto _jump2011;
    if (b >= 0)
    goto _jump2012;
    fail_assertion("negative array index");
    _jump2012:;
    if (b < m.d0)
    goto _jump2013;
    fail_assertion("index too large");
    _jump2013:;
    if (r >= 0)
    goto _jump2014;
    fail_assertion("negative array index");
    _jump2014:;
    if (r < m.d1)
    goto _jump2015;
    fail_assertion("index too large");
    _jump2015:;
    int64_t _149 = 0;
    _149 *= m.d0;
    _149 += b;
    _149 *= m.d1;
    _149 += r;
    bool _150 = m.data[_149];
    p _151;
    if (!_150)
    goto _jump2016;
    _a3_bool _152;
    // Computing bound for C
    _152.d0 = x.d1;
    if (x.d1 > 0) 
    goto _jump2017;
    fail_assertion("non-positive loop bound");
    _jump2017:;
    // Computing bound for D
    _152.d1 = c;
    if (c > 0) 
    goto _jump2018;
    fail_assertion("non-positive loop bound");
    _jump2018:;
    // Computing bound for E
    _152.d2 = n;
    if (n > 0) 
    goto _jump2019;
    fail_assertion("non-positive loop bound");
    _jump2019:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= x.d1;
    _153 *= c;
    _153 *= n;
    _153 *= sizeof(bool);
    _152.data = jpl_alloc(_153);
    int64_t _154 = 0; // E
    int64_t _155 = 0; // D
    int64_t _156 = 0; // C
    _jump2020:; // Begin body of loop
    bool _157 = r >= i;
    int64_t _158 = 0;
    _158 *= _152.d0;
    _158 += _156;
    _158 *= _152.d1;
    _158 += _155;
    _158 *= _152.d2;
    _158 += _154;
    _152.data[_158] = _157;
    _154++;
    if (_154 < n)
    goto _jump2020;
    _154 = 0;
    _155++;
    if (_155 < c)
    goto _jump2020;
    _155 = 0;
    _156++;
    if (_156 < x.d1)
    goto _jump2020;
    // End body of loop
    p _159 = w(_152);
    _151 = _159;
    goto _jump2021;
    _jump2016:;
    _a2_p _160;
    // Computing bound for C
    _160.d0 = c;
    if (c > 0) 
    goto _jump2022;
    fail_assertion("non-positive loop bound");
    _jump2022:;
    // Computing bound for D
    _160.d1 = j;
    if (j > 0) 
    goto _jump2023;
    fail_assertion("non-positive loop bound");
    _jump2023:;
    // Computing total size of heap memory to allocate
    int64_t _161 = 1;
    _161 *= c;
    _161 *= j;
    _161 *= sizeof(p);
    _160.data = jpl_alloc(_161);
    int64_t _162 = 0; // D
    int64_t _163 = 0; // C
    _jump2024:; // Begin body of loop
    p _164 = { t };
    int64_t _165 = 0;
    _165 *= _160.d0;
    _165 += _163;
    _165 *= _160.d1;
    _165 += _162;
    _160.data[_165] = _164;
    _162++;
    if (_162 < j)
    goto _jump2024;
    _162 = 0;
    _163++;
    if (_163 < c)
    goto _jump2024;
    // End body of loop
    int64_t _166 = x.d1 + n;
    int64_t _167 = _166 + x.d0;
    if (o >= 0)
    goto _jump2025;
    fail_assertion("negative array index");
    _jump2025:;
    if (o < _160.d0)
    goto _jump2026;
    fail_assertion("index too large");
    _jump2026:;
    if (_167 >= 0)
    goto _jump2027;
    fail_assertion("negative array index");
    _jump2027:;
    if (_167 < _160.d1)
    goto _jump2028;
    fail_assertion("index too large");
    _jump2028:;
    int64_t _168 = 0;
    _168 *= _160.d0;
    _168 += o;
    _168 *= _160.d1;
    _168 += _167;
    p _169 = _160.data[_168];
    _151 = _169;
    _jump2021:;
    _148 = _151;
    goto _jump2029;
    _jump2011:;
    _a3_p _170;
    // Computing bound for C
    _170.d0 = r;
    if (r > 0) 
    goto _jump2030;
    fail_assertion("non-positive loop bound");
    _jump2030:;
    // Computing bound for D
    _170.d1 = i;
    if (i > 0) 
    goto _jump2031;
    fail_assertion("non-positive loop bound");
    _jump2031:;
    // Computing bound for E
    int64_t _171;
    // Computing bound for C
    if (o > 0) 
    goto _jump2032;
    fail_assertion("non-positive loop bound");
    _jump2032:;
    _171 = 0;
    int64_t _172 = 0; // C
    _jump2033:; // Begin body of loop
    _171 += h;
    _172++;
    if (_172 < o)
    goto _jump2033;
    // End body of loop
    _170.d2 = _171;
    if (_171 > 0) 
    goto _jump2034;
    fail_assertion("non-positive loop bound");
    _jump2034:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= r;
    _173 *= i;
    _173 *= _171;
    _173 *= sizeof(p);
    _170.data = jpl_alloc(_173);
    int64_t _174 = 0; // E
    int64_t _175 = 0; // D
    int64_t _176 = 0; // C
    _jump2035:; // Begin body of loop
    _a3_bool _177;
    // Computing bound for F
    _177.d0 = x.d1;
    if (x.d1 > 0) 
    goto _jump2036;
    fail_assertion("non-positive loop bound");
    _jump2036:;
    // Computing bound for G
    _177.d1 = b;
    if (b > 0) 
    goto _jump2037;
    fail_assertion("non-positive loop bound");
    _jump2037:;
    // Computing bound for H
    _177.d2 = i;
    if (i > 0) 
    goto _jump2038;
    fail_assertion("non-positive loop bound");
    _jump2038:;
    // Computing total size of heap memory to allocate
    int64_t _178 = 1;
    _178 *= x.d1;
    _178 *= b;
    _178 *= i;
    _178 *= sizeof(bool);
    _177.data = jpl_alloc(_178);
    int64_t _179 = 0; // H
    int64_t _180 = 0; // G
    int64_t _181 = 0; // F
    _jump2039:; // Begin body of loop
    bool _182 = false;
    int64_t _183 = 0;
    _183 *= _177.d0;
    _183 += _181;
    _183 *= _177.d1;
    _183 += _180;
    _183 *= _177.d2;
    _183 += _179;
    _177.data[_183] = _182;
    _179++;
    if (_179 < i)
    goto _jump2039;
    _179 = 0;
    _180++;
    if (_180 < b)
    goto _jump2039;
    _180 = 0;
    _181++;
    if (_181 < x.d1)
    goto _jump2039;
    // End body of loop
    p _184 = w(_177);
    int64_t _185 = 0;
    _185 *= _170.d0;
    _185 += _176;
    _185 *= _170.d1;
    _185 += _175;
    _185 *= _170.d2;
    _185 += _174;
    _170.data[_185] = _184;
    _174++;
    if (_174 < _171)
    goto _jump2035;
    _174 = 0;
    _175++;
    if (_175 < i)
    goto _jump2035;
    _175 = 0;
    _176++;
    if (_176 < r)
    goto _jump2035;
    // End body of loop
    int64_t _186;
    // Computing bound for C
    if (j > 0) 
    goto _jump2040;
    fail_assertion("non-positive loop bound");
    _jump2040:;
    // Computing bound for D
    if (j > 0) 
    goto _jump2041;
    fail_assertion("non-positive loop bound");
    _jump2041:;
    _186 = 0;
    int64_t _187 = 0; // D
    int64_t _188 = 0; // C
    _jump2042:; // Begin body of loop
    _186 += b;
    _187++;
    if (_187 < j)
    goto _jump2042;
    _187 = 0;
    _188++;
    if (_188 < j)
    goto _jump2042;
    // End body of loop
    if (j >= 0)
    goto _jump2043;
    fail_assertion("negative array index");
    _jump2043:;
    if (j < _170.d0)
    goto _jump2044;
    fail_assertion("index too large");
    _jump2044:;
    if (_186 >= 0)
    goto _jump2045;
    fail_assertion("negative array index");
    _jump2045:;
    if (_186 < _170.d1)
    goto _jump2046;
    fail_assertion("index too large");
    _jump2046:;
    if (b >= 0)
    goto _jump2047;
    fail_assertion("negative array index");
    _jump2047:;
    if (b < _170.d2)
    goto _jump2048;
    fail_assertion("index too large");
    _jump2048:;
    int64_t _189 = 0;
    _189 *= _170.d0;
    _189 += j;
    _189 *= _170.d1;
    _189 += _186;
    _189 *= _170.d2;
    _189 += b;
    p _190 = _170.data[_189];
    _148 = _190;
    _jump2029:;
    _139 = _148;
    goto _jump2049;
    _jump2006:;
    _a3_p _191;
    // Computing bound for C
    int64_t _192 = 627;
    _191.d0 = _192;
    if (_192 > 0) 
    goto _jump2050;
    fail_assertion("non-positive loop bound");
    _jump2050:;
    // Computing bound for D
    _191.d1 = i;
    if (i > 0) 
    goto _jump2051;
    fail_assertion("non-positive loop bound");
    _jump2051:;
    // Computing bound for E
    _191.d2 = x.d2;
    if (x.d2 > 0) 
    goto _jump2052;
    fail_assertion("non-positive loop bound");
    _jump2052:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= _192;
    _193 *= i;
    _193 *= x.d2;
    _193 *= sizeof(p);
    _191.data = jpl_alloc(_193);
    int64_t _194 = 0; // E
    int64_t _195 = 0; // D
    int64_t _196 = 0; // C
    _jump2053:; // Begin body of loop
    double _197 = 15.0;
    double _198 = t - _197;
    double _199 = 55.0;
    double _200 = _198 * _199;
    p _201 = { _200 };
    int64_t _202 = 0;
    _202 *= _191.d0;
    _202 += _196;
    _202 *= _191.d1;
    _202 += _195;
    _202 *= _191.d2;
    _202 += _194;
    _191.data[_202] = _201;
    _194++;
    if (_194 < x.d2)
    goto _jump2053;
    _194 = 0;
    _195++;
    if (_195 < i)
    goto _jump2053;
    _195 = 0;
    _196++;
    if (_196 < _192)
    goto _jump2053;
    // End body of loop
    int64_t _203;
    // Computing bound for C
    if (x.d2 > 0) 
    goto _jump2054;
    fail_assertion("non-positive loop bound");
    _jump2054:;
    _203 = 0;
    int64_t _204 = 0; // C
    _jump2055:; // Begin body of loop
    _203 += u;
    _204++;
    if (_204 < x.d2)
    goto _jump2055;
    // End body of loop
    _a2__a1_int64_t _205;
    // Computing bound for C
    int64_t _206 = 147;
    _205.d0 = _206;
    if (_206 > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing bound for D
    _205.d1 = d;
    if (d > 0) 
    goto _jump2057;
    fail_assertion("non-positive loop bound");
    _jump2057:;
    // Computing total size of heap memory to allocate
    int64_t _207 = 1;
    _207 *= _206;
    _207 *= d;
    _207 *= sizeof(_a1_int64_t);
    _205.data = jpl_alloc(_207);
    int64_t _208 = 0; // D
    int64_t _209 = 0; // C
    _jump2058:; // Begin body of loop
    _a1_int64_t _210;
    _210.d0 = 2;
    _210.data = jpl_alloc(sizeof(int64_t) * 2);
    _210.data[0] = b;
    _210.data[1] = x.d1;
    int64_t _211 = 0;
    _211 *= _205.d0;
    _211 += _209;
    _211 *= _205.d1;
    _211 += _208;
    _205.data[_211] = _210;
    _208++;
    if (_208 < d)
    goto _jump2058;
    _208 = 0;
    _209++;
    if (_209 < _206)
    goto _jump2058;
    // End body of loop
    int64_t _212 = n - c;
    if (_212 >= 0)
    goto _jump2059;
    fail_assertion("negative array index");
    _jump2059:;
    if (_212 < _205.d0)
    goto _jump2060;
    fail_assertion("index too large");
    _jump2060:;
    if (r >= 0)
    goto _jump2061;
    fail_assertion("negative array index");
    _jump2061:;
    if (r < _205.d1)
    goto _jump2062;
    fail_assertion("index too large");
    _jump2062:;
    int64_t _213 = 0;
    _213 *= _205.d0;
    _213 += _212;
    _213 *= _205.d1;
    _213 += r;
    _a1_int64_t _214 = _205.data[_213];
    _a2_int64_t _215;
    // Computing bound for C
    _215.d0 = x.d1;
    if (x.d1 > 0) 
    goto _jump2063;
    fail_assertion("non-positive loop bound");
    _jump2063:;
    // Computing bound for D
    _215.d1 = c;
    if (c > 0) 
    goto _jump2064;
    fail_assertion("non-positive loop bound");
    _jump2064:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= x.d1;
    _216 *= c;
    _216 *= sizeof(int64_t);
    _215.data = jpl_alloc(_216);
    int64_t _217 = 0; // D
    int64_t _218 = 0; // C
    _jump2065:; // Begin body of loop
    int64_t _219 = 877;
    int64_t _220 = 0;
    _220 *= _215.d0;
    _220 += _218;
    _220 *= _215.d1;
    _220 += _217;
    _215.data[_220] = _219;
    _217++;
    if (_217 < c)
    goto _jump2065;
    _217 = 0;
    _218++;
    if (_218 < x.d1)
    goto _jump2065;
    // End body of loop
    int64_t _221 = -x.d1;
    if (u >= 0)
    goto _jump2066;
    fail_assertion("negative array index");
    _jump2066:;
    if (u < _215.d0)
    goto _jump2067;
    fail_assertion("index too large");
    _jump2067:;
    if (_221 >= 0)
    goto _jump2068;
    fail_assertion("negative array index");
    _jump2068:;
    if (_221 < _215.d1)
    goto _jump2069;
    fail_assertion("index too large");
    _jump2069:;
    int64_t _222 = 0;
    _222 *= _215.d0;
    _222 += u;
    _222 *= _215.d1;
    _222 += _221;
    int64_t _223 = _215.data[_222];
    int64_t _224 = _223 + j;
    if (_224 >= 0)
    goto _jump2070;
    fail_assertion("negative array index");
    _jump2070:;
    if (_224 < _214.d0)
    goto _jump2071;
    fail_assertion("index too large");
    _jump2071:;
    int64_t _225 = 0;
    _225 *= _214.d0;
    _225 += _224;
    int64_t _226 = _214.data[_225];
    if (_203 >= 0)
    goto _jump2072;
    fail_assertion("negative array index");
    _jump2072:;
    if (_203 < _191.d0)
    goto _jump2073;
    fail_assertion("index too large");
    _jump2073:;
    if (_226 >= 0)
    goto _jump2074;
    fail_assertion("negative array index");
    _jump2074:;
    if (_226 < _191.d1)
    goto _jump2075;
    fail_assertion("index too large");
    _jump2075:;
    if (x.d2 >= 0)
    goto _jump2076;
    fail_assertion("negative array index");
    _jump2076:;
    if (x.d2 < _191.d2)
    goto _jump2077;
    fail_assertion("index too large");
    _jump2077:;
    int64_t _227 = 0;
    _227 *= _191.d0;
    _227 += _203;
    _227 *= _191.d1;
    _227 += _226;
    _227 *= _191.d2;
    _227 += x.d2;
    p _228 = _191.data[_227];
    _139 = _228;
    _jump2049:;
    _136 = _139;
    goto _jump2078;
    _jump2005:;
    p _229 = { t };
    _136 = _229;
    _jump2078:;
    return _136;
    _a3__a1_double _230;
    // Computing bound for C
    int64_t _231 = -x.d2;
    _230.d0 = _231;
    if (_231 > 0) 
    goto _jump2079;
    fail_assertion("non-positive loop bound");
    _jump2079:;
    // Computing bound for D
    int64_t _232;
    // Computing bound for C
    if (b > 0) 
    goto _jump2080;
    fail_assertion("non-positive loop bound");
    _jump2080:;
    _232 = 0;
    int64_t _233 = 0; // C
    _jump2081:; // Begin body of loop
    _232 += x.d0;
    _233++;
    if (_233 < b)
    goto _jump2081;
    // End body of loop
    _230.d1 = _232;
    if (_232 > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing bound for E
    _230.d2 = r;
    if (r > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= _231;
    _234 *= _232;
    _234 *= r;
    _234 *= sizeof(_a1_double);
    _230.data = jpl_alloc(_234);
    int64_t _235 = 0; // E
    int64_t _236 = 0; // D
    int64_t _237 = 0; // C
    _jump2084:; // Begin body of loop
    double _238;
    // Computing bound for F
    if (_237 > 0) 
    goto _jump2085;
    fail_assertion("non-positive loop bound");
    _jump2085:;
    // Computing bound for G
    if (d > 0) 
    goto _jump2086;
    fail_assertion("non-positive loop bound");
    _jump2086:;
    _238 = 0;
    int64_t _239 = 0; // G
    int64_t _240 = 0; // F
    _jump2087:; // Begin body of loop
    double _241 = 62.0;
    _238 += _241;
    _239++;
    if (_239 < d)
    goto _jump2087;
    _239 = 0;
    _240++;
    if (_240 < _237)
    goto _jump2087;
    // End body of loop
    double _242 = 90.0;
    double _243 = -_242;
    _a1_double _244;
    _244.d0 = 3;
    _244.data = jpl_alloc(sizeof(double) * 3);
    _244.data[0] = t;
    _244.data[1] = _238;
    _244.data[2] = _243;
    int64_t _245 = 0;
    _245 *= _230.d0;
    _245 += _237;
    _245 *= _230.d1;
    _245 += _236;
    _245 *= _230.d2;
    _245 += _235;
    _230.data[_245] = _244;
    _235++;
    if (_235 < r)
    goto _jump2084;
    _235 = 0;
    _236++;
    if (_236 < _232)
    goto _jump2084;
    _236 = 0;
    _237++;
    if (_237 < _231)
    goto _jump2084;
    // End body of loop
    if (c >= 0)
    goto _jump2088;
    fail_assertion("negative array index");
    _jump2088:;
    if (c < m.d0)
    goto _jump2089;
    fail_assertion("index too large");
    _jump2089:;
    if (d >= 0)
    goto _jump2090;
    fail_assertion("negative array index");
    _jump2090:;
    if (d < m.d1)
    goto _jump2091;
    fail_assertion("index too large");
    _jump2091:;
    int64_t _246 = 0;
    _246 *= m.d0;
    _246 += c;
    _246 *= m.d1;
    _246 += d;
    bool _247 = m.data[_246];
    _a1_int64_t _248;
    if (!_247)
    goto _jump2092;
    int64_t _249 = 949;
    _a1_int64_t _250;
    _250.d0 = 3;
    _250.data = jpl_alloc(sizeof(int64_t) * 3);
    _250.data[0] = h;
    _250.data[1] = _249;
    _250.data[2] = x.d1;
    _248 = _250;
    goto _jump2093;
    _jump2092:;
    _a1_int64_t _251;
    _251.d0 = 3;
    _251.data = jpl_alloc(sizeof(int64_t) * 3);
    _251.data[0] = c;
    _251.data[1] = j;
    _251.data[2] = r;
    _248 = _251;
    _jump2093:;
    if (x.d0 >= 0)
    goto _jump2094;
    fail_assertion("negative array index");
    _jump2094:;
    if (x.d0 < _248.d0)
    goto _jump2095;
    fail_assertion("index too large");
    _jump2095:;
    int64_t _252 = 0;
    _252 *= _248.d0;
    _252 += x.d0;
    int64_t _253 = _248.data[_252];
    if (_253 >= 0)
    goto _jump2096;
    fail_assertion("negative array index");
    _jump2096:;
    if (_253 < _230.d0)
    goto _jump2097;
    fail_assertion("index too large");
    _jump2097:;
    if (d >= 0)
    goto _jump2098;
    fail_assertion("negative array index");
    _jump2098:;
    if (d < _230.d1)
    goto _jump2099;
    fail_assertion("index too large");
    _jump2099:;
    if (j >= 0)
    goto _jump2100;
    fail_assertion("negative array index");
    _jump2100:;
    if (j < _230.d2)
    goto _jump2101;
    fail_assertion("index too large");
    _jump2101:;
    int64_t _254 = 0;
    _254 *= _230.d0;
    _254 += _253;
    _254 *= _230.d1;
    _254 += d;
    _254 *= _230.d2;
    _254 += j;
    _a1_double _255 = _230.data[_254];
    if (r >= 0)
    goto _jump2102;
    fail_assertion("negative array index");
    _jump2102:;
    if (r < _255.d0)
    goto _jump2103;
    fail_assertion("index too large");
    _jump2103:;
    int64_t _256 = 0;
    _256 *= _255.d0;
    _256 += r;
    double _257 = _255.data[_256];
    bool _258 = h >= c;
    void_t _259;
    if (!_258)
    goto _jump2104;
    void_t _260 = l();
    _a1_void_t _261;
    _261.d0 = 1;
    _261.data = jpl_alloc(sizeof(void_t) * 1);
    _261.data[0] = _260;
    if (c >= 0)
    goto _jump2105;
    fail_assertion("negative array index");
    _jump2105:;
    if (c < _261.d0)
    goto _jump2106;
    fail_assertion("index too large");
    _jump2106:;
    int64_t _262 = 0;
    _262 *= _261.d0;
    _262 += c;
    void_t _263 = _261.data[_262];
    _259 = _263;
    goto _jump2107;
    _jump2104:;
    bool _264 = true;
    _a1_bool _265;
    // Computing bound for C
    _265.d0 = c;
    if (c > 0) 
    goto _jump2108;
    fail_assertion("non-positive loop bound");
    _jump2108:;
    // Computing total size of heap memory to allocate
    int64_t _266 = 1;
    _266 *= c;
    _266 *= sizeof(bool);
    _265.data = jpl_alloc(_266);
    int64_t _267 = 0; // C
    _jump2109:; // Begin body of loop
    bool _268 = j >= x.d2;
    int64_t _269 = 0;
    _269 *= _265.d0;
    _269 += _267;
    _265.data[_269] = _268;
    _267++;
    if (_267 < c)
    goto _jump2109;
    // End body of loop
    if (c >= 0)
    goto _jump2110;
    fail_assertion("negative array index");
    _jump2110:;
    if (c < _265.d0)
    goto _jump2111;
    fail_assertion("index too large");
    _jump2111:;
    int64_t _270 = 0;
    _270 *= _265.d0;
    _270 += c;
    bool _271 = _265.data[_270];
    bool _272 = _264 == _271;
    void_t _273;
    if (!_272)
    goto _jump2112;
    void_t _274 = l();
    _273 = _274;
    goto _jump2113;
    _jump2112:;
    bool _275 = false;
    bool _276;
    if (!_275)
    goto _jump2114;
    double _277 = 64.0;
    double _278 = 11.0;
    double _279 = t * _278;
    bool _280 = _277 <= _279;
    _276 = _280;
    goto _jump2115;
    _jump2114:;
    if (d >= 0)
    goto _jump2116;
    fail_assertion("negative array index");
    _jump2116:;
    if (d < q.d0)
    goto _jump2117;
    fail_assertion("index too large");
    _jump2117:;
    int64_t _281 = 0;
    _281 *= q.d0;
    _281 += d;
    bool _282 = q.data[_281];
    bool _283 = !_282;
    _276 = _283;
    _jump2115:;
    void_t _284;
    if (!_276)
    goto _jump2118;
    void_t _285 = l();
    void_t _286 = l();
    _a1_void_t _287;
    _287.d0 = 2;
    _287.data = jpl_alloc(sizeof(void_t) * 2);
    _287.data[0] = _285;
    _287.data[1] = _286;
    if (x.d0 >= 0)
    goto _jump2119;
    fail_assertion("negative array index");
    _jump2119:;
    if (x.d0 < _287.d0)
    goto _jump2120;
    fail_assertion("index too large");
    _jump2120:;
    int64_t _288 = 0;
    _288 *= _287.d0;
    _288 += x.d0;
    void_t _289 = _287.data[_288];
    _284 = _289;
    goto _jump2121;
    _jump2118:;
    void_t _290 = l();
    _284 = _290;
    _jump2121:;
    _273 = _284;
    _jump2113:;
    _259 = _273;
    _jump2107:;
    _a1_rgba _291 = k(_257, _259);
    double _292;
    // Computing bound for D
    int64_t _293;
    // Computing bound for D
    if (h > 0) 
    goto _jump2122;
    fail_assertion("non-positive loop bound");
    _jump2122:;
    // Computing bound for E
    bool _294 = false;
    int64_t _295;
    if (!_294)
    goto _jump2123;
    _295 = i;
    goto _jump2124;
    _jump2123:;
    _295 = h;
    _jump2124:;
    int64_t _296 = -_295;
    int64_t _297 = d + _296;
    if (_297 > 0) 
    goto _jump2125;
    fail_assertion("non-positive loop bound");
    _jump2125:;
    _293 = 0;
    int64_t _298 = 0; // E
    int64_t _299 = 0; // D
    _jump2126:; // Begin body of loop
    int64_t _300 = c * i;
    _293 += _300;
    _298++;
    if (_298 < _297)
    goto _jump2126;
    _298 = 0;
    _299++;
    if (_299 < h)
    goto _jump2126;
    // End body of loop
    if (_293 > 0) 
    goto _jump2127;
    fail_assertion("non-positive loop bound");
    _jump2127:;
    _292 = 0;
    int64_t _301 = 0; // D
    _jump2128:; // Begin body of loop
    _292 += t;
    _301++;
    if (_301 < _293)
    goto _jump2128;
    // End body of loop
    double _302;
    // Computing bound for E
    if (i > 0) 
    goto _jump2129;
    fail_assertion("non-positive loop bound");
    _jump2129:;
    // Computing bound for F
    if (u > 0) 
    goto _jump2130;
    fail_assertion("non-positive loop bound");
    _jump2130:;
    // Computing bound for G
    if (c > 0) 
    goto _jump2131;
    fail_assertion("non-positive loop bound");
    _jump2131:;
    _302 = 0;
    int64_t _303 = 0; // G
    int64_t _304 = 0; // F
    int64_t _305 = 0; // E
    _jump2132:; // Begin body of loop
    int64_t _307 = -_305;
    if (_307 >= 0)
    goto _jump2133;
    fail_assertion("negative array index");
    _jump2133:;
    if (_307 < a.d0)
    goto _jump2134;
    fail_assertion("index too large");
    _jump2134:;
    if (_304 >= 0)
    goto _jump2135;
    fail_assertion("negative array index");
    _jump2135:;
    if (_304 < a.d1)
    goto _jump2136;
    fail_assertion("index too large");
    _jump2136:;
    if (x.d1 >= 0)
    goto _jump2137;
    fail_assertion("negative array index");
    _jump2137:;
    if (x.d1 < a.d2)
    goto _jump2138;
    fail_assertion("index too large");
    _jump2138:;
    int64_t _308 = 0;
    _308 *= a.d0;
    _308 += _307;
    _308 *= a.d1;
    _308 += _304;
    _308 *= a.d2;
    _308 += x.d1;
    bool _309 = a.data[_308];
    bool _306 = _309;
    if (0 == _309)
    goto _jump2139;
    int64_t _310;
    // Computing bound for H
    if (n > 0) 
    goto _jump2140;
    fail_assertion("non-positive loop bound");
    _jump2140:;
    // Computing bound for I
    if (h > 0) 
    goto _jump2141;
    fail_assertion("non-positive loop bound");
    _jump2141:;
    // Computing bound for J
    if (x.d1 > 0) 
    goto _jump2142;
    fail_assertion("non-positive loop bound");
    _jump2142:;
    _310 = 0;
    int64_t _311 = 0; // J
    int64_t _312 = 0; // I
    int64_t _313 = 0; // H
    _jump2143:; // Begin body of loop
    _310 += o;
    _311++;
    if (_311 < x.d1)
    goto _jump2143;
    _311 = 0;
    _312++;
    if (_312 < h)
    goto _jump2143;
    _312 = 0;
    _313++;
    if (_313 < n)
    goto _jump2143;
    // End body of loop
    bool _314 = b != _310;
    _306 = _314;
    _jump2139:;
    p _315;
    if (!_306)
    goto _jump2144;
    double _316;
    // Computing bound for H
    int64_t _317 = 407;
    if (_317 > 0) 
    goto _jump2145;
    fail_assertion("non-positive loop bound");
    _jump2145:;
    // Computing bound for I
    if (h > 0) 
    goto _jump2146;
    fail_assertion("non-positive loop bound");
    _jump2146:;
    _316 = 0;
    int64_t _318 = 0; // I
    int64_t _319 = 0; // H
    _jump2147:; // Begin body of loop
    _316 += t;
    _318++;
    if (_318 < h)
    goto _jump2147;
    _318 = 0;
    _319++;
    if (_319 < _317)
    goto _jump2147;
    // End body of loop
    double _320;
    // Computing bound for H
    if (j > 0) 
    goto _jump2148;
    fail_assertion("non-positive loop bound");
    _jump2148:;
    _320 = 0;
    int64_t _321 = 0; // H
    _jump2149:; // Begin body of loop
    _320 += t;
    _321++;
    if (_321 < j)
    goto _jump2149;
    // End body of loop
    double _322 = _316 / _320;
    p _323 = { _322 };
    _315 = _323;
    goto _jump2150;
    _jump2144:;
    double _324;
    // Computing bound for H
    int64_t _325 = 371;
    if (_325 > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    // Computing bound for I
    if (_304 > 0) 
    goto _jump2152;
    fail_assertion("non-positive loop bound");
    _jump2152:;
    _324 = 0;
    int64_t _326 = 0; // I
    int64_t _327 = 0; // H
    _jump2153:; // Begin body of loop
    double _328 = 19.0;
    _324 += _328;
    _326++;
    if (_326 < _304)
    goto _jump2153;
    _326 = 0;
    _327++;
    if (_327 < _325)
    goto _jump2153;
    // End body of loop
    p _329 = { _324 };
    _315 = _329;
    _jump2150:;
    double _330 = _315.a;
    _302 += _330;
    _303++;
    if (_303 < c)
    goto _jump2132;
    _303 = 0;
    _304++;
    if (_304 < u)
    goto _jump2132;
    _304 = 0;
    _305++;
    if (_305 < i)
    goto _jump2132;
    // End body of loop
    p _331 = { _302 };
    return _331;
}

rgba B(void_t C, rgba D) {
    _a3_int64_t _0;
    if (!y)
    goto _jump2318;
    _0 = g;
    goto _jump2319;
    _jump2318:;
    _0 = g;
    _jump2319:;
    _a2_double _1 = v(_0, D);
    if (0 != y)
    goto _jump2320;
    fail_assertion("R");
    _jump2320:;
    double _2;
    // Computing bound for R
    if (i > 0) 
    goto _jump2321;
    fail_assertion("non-positive loop bound");
    _jump2321:;
    // Computing bound for S
    if (_1.d0 > 0) 
    goto _jump2322;
    fail_assertion("non-positive loop bound");
    _jump2322:;
    _2 = 0;
    int64_t _3 = 0; // S
    int64_t _4 = 0; // R
    _jump2323:; // Begin body of loop
    double _5 = 39.0;
    _2 += _5;
    _3++;
    if (_3 < _1.d0)
    goto _jump2323;
    _3 = 0;
    _4++;
    if (_4 < i)
    goto _jump2323;
    // End body of loop
    p _6 = w(a);
    double _7 = _6.a;
    bool _8 = _2 != _7;
    int64_t _9;
    if (!_8)
    goto _jump2324;
    _9 = h;
    goto _jump2325;
    _jump2324:;
    _9 = c;
    _jump2325:;
    if (_9 >= 0)
    goto _jump2326;
    fail_assertion("negative array index");
    _jump2326:;
    if (_9 < m.d0)
    goto _jump2327;
    fail_assertion("index too large");
    _jump2327:;
    if (_0.d2 >= 0)
    goto _jump2328;
    fail_assertion("negative array index");
    _jump2328:;
    if (_0.d2 < m.d1)
    goto _jump2329;
    fail_assertion("index too large");
    _jump2329:;
    int64_t _10 = 0;
    _10 *= m.d0;
    _10 += _9;
    _10 *= m.d1;
    _10 += _0.d2;
    bool _11 = m.data[_10];
    _a3_double _12;
    if (!_11)
    goto _jump2330;
    _a3_double _13;
    // Computing bound for R
    _13.d0 = o;
    if (o > 0) 
    goto _jump2331;
    fail_assertion("non-positive loop bound");
    _jump2331:;
    // Computing bound for S
    _13.d1 = a.d2;
    if (a.d2 > 0) 
    goto _jump2332;
    fail_assertion("non-positive loop bound");
    _jump2332:;
    // Computing bound for T
    _13.d2 = n;
    if (n > 0) 
    goto _jump2333;
    fail_assertion("non-positive loop bound");
    _jump2333:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= o;
    _14 *= a.d2;
    _14 *= n;
    _14 *= sizeof(double);
    _13.data = jpl_alloc(_14);
    int64_t _15 = 0; // T
    int64_t _16 = 0; // S
    int64_t _17 = 0; // R
    _jump2334:; // Begin body of loop
    int64_t _18 = 0;
    _18 *= _13.d0;
    _18 += _17;
    _18 *= _13.d1;
    _18 += _16;
    _18 *= _13.d2;
    _18 += _15;
    _13.data[_18] = t;
    _15++;
    if (_15 < n)
    goto _jump2334;
    _15 = 0;
    _16++;
    if (_16 < a.d2)
    goto _jump2334;
    _16 = 0;
    _17++;
    if (_17 < o)
    goto _jump2334;
    // End body of loop
    _12 = _13;
    goto _jump2335;
    _jump2330:;
    _a3_double _19;
    // Computing bound for R
    _a1__a3_int64_t _20;
    // Computing bound for R
    _20.d0 = a.d1;
    if (a.d1 > 0) 
    goto _jump2336;
    fail_assertion("non-positive loop bound");
    _jump2336:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= a.d1;
    _21 *= sizeof(_a3_int64_t);
    _20.data = jpl_alloc(_21);
    int64_t _22 = 0; // R
    _jump2337:; // Begin body of loop
    int64_t _23 = 0;
    _23 *= _20.d0;
    _23 += _22;
    _20.data[_23] = g;
    _22++;
    if (_22 < a.d1)
    goto _jump2337;
    // End body of loop
    if (b >= 0)
    goto _jump2338;
    fail_assertion("negative array index");
    _jump2338:;
    if (b < _20.d0)
    goto _jump2339;
    fail_assertion("index too large");
    _jump2339:;
    int64_t _24 = 0;
    _24 *= _20.d0;
    _24 += b;
    _a3_int64_t _25 = _20.data[_24];
    int64_t _26 = 650;
    if (n >= 0)
    goto _jump2340;
    fail_assertion("negative array index");
    _jump2340:;
    if (n < _25.d0)
    goto _jump2341;
    fail_assertion("index too large");
    _jump2341:;
    if (_26 >= 0)
    goto _jump2342;
    fail_assertion("negative array index");
    _jump2342:;
    if (_26 < _25.d1)
    goto _jump2343;
    fail_assertion("index too large");
    _jump2343:;
    if (i >= 0)
    goto _jump2344;
    fail_assertion("negative array index");
    _jump2344:;
    if (i < _25.d2)
    goto _jump2345;
    fail_assertion("index too large");
    _jump2345:;
    int64_t _27 = 0;
    _27 *= _25.d0;
    _27 += n;
    _27 *= _25.d1;
    _27 += _26;
    _27 *= _25.d2;
    _27 += i;
    int64_t _28 = _25.data[_27];
    _19.d0 = _28;
    if (_28 > 0) 
    goto _jump2346;
    fail_assertion("non-positive loop bound");
    _jump2346:;
    // Computing bound for S
    int64_t _29 = 639;
    int64_t _30 = -_29;
    _19.d1 = _30;
    if (_30 > 0) 
    goto _jump2347;
    fail_assertion("non-positive loop bound");
    _jump2347:;
    // Computing bound for T
    _19.d2 = h;
    if (h > 0) 
    goto _jump2348;
    fail_assertion("non-positive loop bound");
    _jump2348:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= _28;
    _31 *= _30;
    _31 *= h;
    _31 *= sizeof(double);
    _19.data = jpl_alloc(_31);
    int64_t _32 = 0; // T
    int64_t _33 = 0; // S
    int64_t _34 = 0; // R
    _jump2349:; // Begin body of loop
    double _35 = D.b;
    int64_t _36 = 0;
    _36 *= _19.d0;
    _36 += _34;
    _36 *= _19.d1;
    _36 += _33;
    _36 *= _19.d2;
    _36 += _32;
    _19.data[_36] = _35;
    _32++;
    if (_32 < h)
    goto _jump2349;
    _32 = 0;
    _33++;
    if (_33 < _30)
    goto _jump2349;
    _33 = 0;
    _34++;
    if (_34 < _28)
    goto _jump2349;
    // End body of loop
    _12 = _19;
    _jump2335:;
    rgba _37 = e(_12, s);
    return _37;
}

C E(void_t F, _a1_p G) {
    void_t _0 = l();
    void_t _1 = l();
    _a1_p _2;
    _2.d0 = 3;
    _2.data = jpl_alloc(sizeof(p) * 3);
    _2.data[0] = A;
    _2.data[1] = A;
    _2.data[2] = A;
    C _3 = E(_1, _2);
    rgba _4 = _3.c;
    rgba _5 = B(_0, _4);
    double _6 = _5.a;
    bool _8 = true;
    double _9;
    if (!_8)
    goto _jump2350;
    double _10 = 6.0;
    _9 = _10;
    goto _jump2351;
    _jump2350:;
    _9 = t;
    _jump2351:;
    double _11 = -t;
    bool _12 = _9 <= _11;
    bool _7 = _12;
    if (0 != _12)
    goto _jump2352;
    bool _13 = true;
    _7 = _13;
    _jump2352:;
    p _14;
    if (!_7)
    goto _jump2353;
    double _15;
    if (!y)
    goto _jump2354;
    double _16;
    // Computing bound for I
    if (n > 0) 
    goto _jump2355;
    fail_assertion("non-positive loop bound");
    _jump2355:;
    // Computing bound for J
    if (d > 0) 
    goto _jump2356;
    fail_assertion("non-positive loop bound");
    _jump2356:;
    _16 = 0;
    int64_t _17 = 0; // J
    int64_t _18 = 0; // I
    _jump2357:; // Begin body of loop
    _16 += t;
    _17++;
    if (_17 < d)
    goto _jump2357;
    _17 = 0;
    _18++;
    if (_18 < n)
    goto _jump2357;
    // End body of loop
    _15 = _16;
    goto _jump2358;
    _jump2354:;
    double _19 = 84.0;
    _15 = _19;
    _jump2358:;
    p _20 = { _15 };
    _14 = _20;
    goto _jump2359;
    _jump2353:;
    p _21;
    if (!y)
    goto _jump2360;
    double _22 = 54.0;
    p _23 = { _22 };
    _21 = _23;
    goto _jump2361;
    _jump2360:;
    double _24 = A.a;
    p _25 = { _24 };
    _21 = _25;
    _jump2361:;
    _14 = _21;
    _jump2359:;
    double _26 = _14.a;
    bool _27 = false;
    _a1_p _28;
    if (!_27)
    goto _jump2362;
    _28 = G;
    goto _jump2363;
    _jump2362:;
    _28 = G;
    _jump2363:;
    C _29 = E(F, _28);
    rgba _30 = _29.c;
    double _31 = _30.b;
    _a1_double _32;
    if (!y)
    goto _jump2364;
    bool _33;
    if (!y)
    goto _jump2365;
    bool _34 = true;
    _33 = _34;
    goto _jump2366;
    _jump2365:;
    _33 = y;
    _jump2366:;
    _a1_double _35;
    if (!_33)
    goto _jump2367;
    _a1_double _36;
    // Computing bound for I
    _36.d0 = b;
    if (b > 0) 
    goto _jump2368;
    fail_assertion("non-positive loop bound");
    _jump2368:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= b;
    _37 *= sizeof(double);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // I
    _jump2369:; // Begin body of loop
    double _39 = 0.0;
    int64_t _40 = 0;
    _40 *= _36.d0;
    _40 += _38;
    _36.data[_40] = _39;
    _38++;
    if (_38 < b)
    goto _jump2369;
    // End body of loop
    _35 = _36;
    goto _jump2370;
    _jump2367:;
    _a1_double _41;
    // Computing bound for I
    _41.d0 = d;
    if (d > 0) 
    goto _jump2371;
    fail_assertion("non-positive loop bound");
    _jump2371:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= d;
    _42 *= sizeof(double);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // I
    _jump2372:; // Begin body of loop
    double _44 = 23.0;
    int64_t _45 = 0;
    _45 *= _41.d0;
    _45 += _43;
    _41.data[_45] = _44;
    _43++;
    if (_43 < d)
    goto _jump2372;
    // End body of loop
    _35 = _41;
    _jump2370:;
    _32 = _35;
    goto _jump2373;
    _jump2364:;
    _a1_double _46;
    // Computing bound for I
    _46.d0 = G.d0;
    if (G.d0 > 0) 
    goto _jump2374;
    fail_assertion("non-positive loop bound");
    _jump2374:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= G.d0;
    _47 *= sizeof(double);
    _46.data = jpl_alloc(_47);
    int64_t _48 = 0; // I
    _jump2375:; // Begin body of loop
    double _49 = 96.0;
    int64_t _50 = 0;
    _50 *= _46.d0;
    _50 += _48;
    _46.data[_50] = _49;
    _48++;
    if (_48 < G.d0)
    goto _jump2375;
    // End body of loop
    _32 = _46;
    _jump2373:;
    int64_t _51;
    // Computing bound for I
    if (o > 0) 
    goto _jump2376;
    fail_assertion("non-positive loop bound");
    _jump2376:;
    // Computing bound for J
    if (h > 0) 
    goto _jump2377;
    fail_assertion("non-positive loop bound");
    _jump2377:;
    // Computing bound for K
    int64_t _52 = -o;
    if (_52 > 0) 
    goto _jump2378;
    fail_assertion("non-positive loop bound");
    _jump2378:;
    _51 = 0;
    int64_t _53 = 0; // K
    int64_t _54 = 0; // J
    int64_t _55 = 0; // I
    _jump2379:; // Begin body of loop
    _51 += c;
    _53++;
    if (_53 < _52)
    goto _jump2379;
    _53 = 0;
    _54++;
    if (_54 < h)
    goto _jump2379;
    _54 = 0;
    _55++;
    if (_55 < o)
    goto _jump2379;
    // End body of loop
    if (_51 >= 0)
    goto _jump2380;
    fail_assertion("negative array index");
    _jump2380:;
    if (_51 < _32.d0)
    goto _jump2381;
    fail_assertion("index too large");
    _jump2381:;
    int64_t _56 = 0;
    _56 *= _32.d0;
    _56 += _51;
    double _57 = _32.data[_56];
    double _58 = fmod(_31, _57);
    double _59 = fmod(_26, _58);
    double _60;
    // Computing bound for I
    if (u > 0) 
    goto _jump2382;
    fail_assertion("non-positive loop bound");
    _jump2382:;
    // Computing bound for J
    if (r > 0) 
    goto _jump2383;
    fail_assertion("non-positive loop bound");
    _jump2383:;
    // Computing bound for K
    int64_t _61;
    // Computing bound for I
    int64_t _62 = 928;
    if (_62 > 0) 
    goto _jump2384;
    fail_assertion("non-positive loop bound");
    _jump2384:;
    // Computing bound for J
    if (n > 0) 
    goto _jump2385;
    fail_assertion("non-positive loop bound");
    _jump2385:;
    // Computing bound for K
    int64_t _63 = 448;
    if (_63 > 0) 
    goto _jump2386;
    fail_assertion("non-positive loop bound");
    _jump2386:;
    _61 = 0;
    int64_t _64 = 0; // K
    int64_t _65 = 0; // J
    int64_t _66 = 0; // I
    _jump2387:; // Begin body of loop
    _61 += G.d0;
    _64++;
    if (_64 < _63)
    goto _jump2387;
    _64 = 0;
    _65++;
    if (_65 < n)
    goto _jump2387;
    _65 = 0;
    _66++;
    if (_66 < _62)
    goto _jump2387;
    // End body of loop
    int64_t _67 = h + _61;
    if (_67 > 0) 
    goto _jump2388;
    fail_assertion("non-positive loop bound");
    _jump2388:;
    _60 = 0;
    int64_t _68 = 0; // K
    int64_t _69 = 0; // J
    int64_t _70 = 0; // I
    _jump2389:; // Begin body of loop
    double _71;
    // Computing bound for L
    if (c > 0) 
    goto _jump2390;
    fail_assertion("non-positive loop bound");
    _jump2390:;
    _71 = 0;
    int64_t _72 = 0; // L
    _jump2391:; // Begin body of loop
    double _73 = A.a;
    double _74 = -_73;
    double _75 = 2.0;
    double _76 = _74 * _75;
    _71 += _76;
    _72++;
    if (_72 < c)
    goto _jump2391;
    // End body of loop
    _60 += _71;
    _68++;
    if (_68 < _67)
    goto _jump2389;
    _68 = 0;
    _69++;
    if (_69 < r)
    goto _jump2389;
    _69 = 0;
    _70++;
    if (_70 < u)
    goto _jump2389;
    // End body of loop
    double _77 = 28.0;
    p _78 = { _77 };
    double _79 = _78.a;
    double _80 = _60 + _79;
    rgba _81 = { _6, _59, t, _80 };
    bool _82 = true;
    bool _83 = !_82;
    C _84;
    if (!_83)
    goto _jump2392;
    bool _85 = false;
    bool _86 = !_85;
    C _87;
    if (!_86)
    goto _jump2393;
    _a3_void_t _88;
    // Computing bound for J
    _88.d0 = i;
    if (i > 0) 
    goto _jump2394;
    fail_assertion("non-positive loop bound");
    _jump2394:;
    // Computing bound for K
    _88.d1 = d;
    if (d > 0) 
    goto _jump2395;
    fail_assertion("non-positive loop bound");
    _jump2395:;
    // Computing bound for L
    _88.d2 = c;
    if (c > 0) 
    goto _jump2396;
    fail_assertion("non-positive loop bound");
    _jump2396:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= i;
    _89 *= d;
    _89 *= c;
    _89 *= sizeof(void_t);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // L
    int64_t _91 = 0; // K
    int64_t _92 = 0; // J
    _jump2397:; // Begin body of loop
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _92;
    _93 *= _88.d1;
    _93 += _91;
    _93 *= _88.d2;
    _93 += _90;
    _88.data[_93] = F;
    _90++;
    if (_90 < c)
    goto _jump2397;
    _90 = 0;
    _91++;
    if (_91 < d)
    goto _jump2397;
    _91 = 0;
    _92++;
    if (_92 < i)
    goto _jump2397;
    // End body of loop
    C _94 = { _88, y, _81 };
    _87 = _94;
    goto _jump2398;
    _jump2393:;
    _a1_p _95;
    _95.d0 = 1;
    _95.data = jpl_alloc(sizeof(p) * 1);
    _95.data[0] = A;
    C _96 = E(F, _95);
    _87 = _96;
    _jump2398:;
    _84 = _87;
    goto _jump2399;
    _jump2392:;
    void_t _97;
    if (!y)
    goto _jump2400;
    void_t _98;
    if (!y)
    goto _jump2401;
    _98 = F;
    goto _jump2402;
    _jump2401:;
    void_t _99 = l();
    _98 = _99;
    _jump2402:;
    _97 = _98;
    goto _jump2403;
    _jump2400:;
    void_t _100 = l();
    _97 = _100;
    _jump2403:;
    int64_t _101 = 176;
    bool _102 = c <= _101;
    _a1_p _103;
    if (!_102)
    goto _jump2404;
    _a1_p _104;
    // Computing bound for J
    _104.d0 = u;
    if (u > 0) 
    goto _jump2405;
    fail_assertion("non-positive loop bound");
    _jump2405:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= u;
    _105 *= sizeof(p);
    _104.data = jpl_alloc(_105);
    int64_t _106 = 0; // J
    _jump2406:; // Begin body of loop
    int64_t _107 = 0;
    _107 *= _104.d0;
    _107 += _106;
    _104.data[_107] = A;
    _106++;
    if (_106 < u)
    goto _jump2406;
    // End body of loop
    _103 = _104;
    goto _jump2407;
    _jump2404:;
    bool _108 = false;
    _a1_p _109;
    if (!_108)
    goto _jump2408;
    _109 = G;
    goto _jump2409;
    _jump2408:;
    _109 = G;
    _jump2409:;
    _103 = _109;
    _jump2407:;
    C _110 = E(_97, _103);
    _84 = _110;
    _jump2399:;
    bool _111 = _84.b;
    _a3_double _112;
    if (!_111)
    goto _jump2410;
    _a3_double _113;
    // Computing bound for J
    _113.d0 = o;
    if (o > 0) 
    goto _jump2411;
    fail_assertion("non-positive loop bound");
    _jump2411:;
    // Computing bound for K
    _113.d1 = G.d0;
    if (G.d0 > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    // Computing bound for L
    int64_t _114;
    // Computing bound for J
    bool _116 = true;
    bool _115 = _116;
    if (0 == _116)
    goto _jump2413;
    _115 = y;
    _jump2413:;
    _a1_int64_t _117;
    if (!_115)
    goto _jump2414;
    _a1_int64_t _118;
    _118.d0 = 2;
    _118.data = jpl_alloc(sizeof(int64_t) * 2);
    _118.data[0] = c;
    _118.data[1] = b;
    _117 = _118;
    goto _jump2415;
    _jump2414:;
    _a1_int64_t _119;
    // Computing bound for J
    _119.d0 = h;
    if (h > 0) 
    goto _jump2416;
    fail_assertion("non-positive loop bound");
    _jump2416:;
    // Computing total size of heap memory to allocate
    int64_t _120 = 1;
    _120 *= h;
    _120 *= sizeof(int64_t);
    _119.data = jpl_alloc(_120);
    int64_t _121 = 0; // J
    _jump2417:; // Begin body of loop
    int64_t _122 = 0;
    _122 *= _119.d0;
    _122 += _121;
    _119.data[_122] = G.d0;
    _121++;
    if (_121 < h)
    goto _jump2417;
    // End body of loop
    _117 = _119;
    _jump2415:;
    if (o >= 0)
    goto _jump2418;
    fail_assertion("negative array index");
    _jump2418:;
    if (o < _117.d0)
    goto _jump2419;
    fail_assertion("index too large");
    _jump2419:;
    int64_t _123 = 0;
    _123 *= _117.d0;
    _123 += o;
    int64_t _124 = _117.data[_123];
    if (_124 > 0) 
    goto _jump2420;
    fail_assertion("non-positive loop bound");
    _jump2420:;
    // Computing bound for K
    if (b > 0) 
    goto _jump2421;
    fail_assertion("non-positive loop bound");
    _jump2421:;
    _114 = 0;
    int64_t _125 = 0; // K
    int64_t _126 = 0; // J
    _jump2422:; // Begin body of loop
    _114 += j;
    _125++;
    if (_125 < b)
    goto _jump2422;
    _125 = 0;
    _126++;
    if (_126 < _124)
    goto _jump2422;
    // End body of loop
    _113.d2 = _114;
    if (_114 > 0) 
    goto _jump2423;
    fail_assertion("non-positive loop bound");
    _jump2423:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= o;
    _127 *= G.d0;
    _127 *= _114;
    _127 *= sizeof(double);
    _113.data = jpl_alloc(_127);
    int64_t _128 = 0; // L
    int64_t _129 = 0; // K
    int64_t _130 = 0; // J
    _jump2424:; // Begin body of loop
    double _131 = 12.0;
    int64_t _132 = 0;
    _132 *= _113.d0;
    _132 += _130;
    _132 *= _113.d1;
    _132 += _129;
    _132 *= _113.d2;
    _132 += _128;
    _113.data[_132] = _131;
    _128++;
    if (_128 < _114)
    goto _jump2424;
    _128 = 0;
    _129++;
    if (_129 < G.d0)
    goto _jump2424;
    _129 = 0;
    _130++;
    if (_130 < o)
    goto _jump2424;
    // End body of loop
    _112 = _113;
    goto _jump2425;
    _jump2410:;
    _a3_double _133;
    // Computing bound for J
    int64_t _134;
    // Computing bound for J
    if (G.d0 > 0) 
    goto _jump2426;
    fail_assertion("non-positive loop bound");
    _jump2426:;
    // Computing bound for K
    int64_t _135;
    // Computing bound for J
    int64_t _136 = 657;
    if (_136 > 0) 
    goto _jump2427;
    fail_assertion("non-positive loop bound");
    _jump2427:;
    // Computing bound for K
    if (n > 0) 
    goto _jump2428;
    fail_assertion("non-positive loop bound");
    _jump2428:;
    // Computing bound for L
    int64_t _137 = -b;
    if (_137 > 0) 
    goto _jump2429;
    fail_assertion("non-positive loop bound");
    _jump2429:;
    _135 = 0;
    int64_t _138 = 0; // L
    int64_t _139 = 0; // K
    int64_t _140 = 0; // J
    _jump2430:; // Begin body of loop
    _135 += j;
    _138++;
    if (_138 < _137)
    goto _jump2430;
    _138 = 0;
    _139++;
    if (_139 < n)
    goto _jump2430;
    _139 = 0;
    _140++;
    if (_140 < _136)
    goto _jump2430;
    // End body of loop
    if (_135 > 0) 
    goto _jump2431;
    fail_assertion("non-positive loop bound");
    _jump2431:;
    _134 = 0;
    int64_t _141 = 0; // K
    int64_t _142 = 0; // J
    _jump2432:; // Begin body of loop
    bool _143 = !y;
    bool _144 = !_143;
    int64_t _145;
    if (!_144)
    goto _jump2433;
    _145 = o;
    goto _jump2434;
    _jump2433:;
    _145 = o;
    _jump2434:;
    _134 += _145;
    _141++;
    if (_141 < _135)
    goto _jump2432;
    _141 = 0;
    _142++;
    if (_142 < G.d0)
    goto _jump2432;
    // End body of loop
    _133.d0 = _134;
    if (_134 > 0) 
    goto _jump2435;
    fail_assertion("non-positive loop bound");
    _jump2435:;
    // Computing bound for K
    _133.d1 = o;
    if (o > 0) 
    goto _jump2436;
    fail_assertion("non-positive loop bound");
    _jump2436:;
    // Computing bound for L
    _133.d2 = o;
    if (o > 0) 
    goto _jump2437;
    fail_assertion("non-positive loop bound");
    _jump2437:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _134;
    _146 *= o;
    _146 *= o;
    _146 *= sizeof(double);
    _133.data = jpl_alloc(_146);
    int64_t _147 = 0; // L
    int64_t _148 = 0; // K
    int64_t _149 = 0; // J
    _jump2438:; // Begin body of loop
    double _150;
    // Computing bound for M
    if (o > 0) 
    goto _jump2439;
    fail_assertion("non-positive loop bound");
    _jump2439:;
    // Computing bound for N
    if (n > 0) 
    goto _jump2440;
    fail_assertion("non-positive loop bound");
    _jump2440:;
    // Computing bound for O
    if (r > 0) 
    goto _jump2441;
    fail_assertion("non-positive loop bound");
    _jump2441:;
    _150 = 0;
    int64_t _151 = 0; // O
    int64_t _152 = 0; // N
    int64_t _153 = 0; // M
    _jump2442:; // Begin body of loop
    double _154;
    // Computing bound for P
    if (_148 > 0) 
    goto _jump2443;
    fail_assertion("non-positive loop bound");
    _jump2443:;
    _154 = 0;
    int64_t _155 = 0; // P
    _jump2444:; // Begin body of loop
    p _156 = { t };
    double _157 = _156.a;
    _154 += _157;
    _155++;
    if (_155 < _148)
    goto _jump2444;
    // End body of loop
    _150 += _154;
    _151++;
    if (_151 < r)
    goto _jump2442;
    _151 = 0;
    _152++;
    if (_152 < n)
    goto _jump2442;
    _152 = 0;
    _153++;
    if (_153 < o)
    goto _jump2442;
    // End body of loop
    int64_t _158 = 0;
    _158 *= _133.d0;
    _158 += _149;
    _158 *= _133.d1;
    _158 += _148;
    _158 *= _133.d2;
    _158 += _147;
    _133.data[_158] = _150;
    _147++;
    if (_147 < o)
    goto _jump2438;
    _147 = 0;
    _148++;
    if (_148 < o)
    goto _jump2438;
    _148 = 0;
    _149++;
    if (_149 < _134)
    goto _jump2438;
    // End body of loop
    _112 = _133;
    _jump2425:;
    bool _159 = true;
    _a2__a1_bool _160;
    if (!_159)
    goto _jump2445;
    _a2__a1_bool _161;
    // Computing bound for J
    _161.d0 = j;
    if (j > 0) 
    goto _jump2446;
    fail_assertion("non-positive loop bound");
    _jump2446:;
    // Computing bound for K
    _161.d1 = j;
    if (j > 0) 
    goto _jump2447;
    fail_assertion("non-positive loop bound");
    _jump2447:;
    // Computing total size of heap memory to allocate
    int64_t _162 = 1;
    _162 *= j;
    _162 *= j;
    _162 *= sizeof(_a1_bool);
    _161.data = jpl_alloc(_162);
    int64_t _163 = 0; // K
    int64_t _164 = 0; // J
    _jump2448:; // Begin body of loop
    int64_t _165 = 0;
    _165 *= _161.d0;
    _165 += _164;
    _165 *= _161.d1;
    _165 += _163;
    _161.data[_165] = q;
    _163++;
    if (_163 < j)
    goto _jump2448;
    _163 = 0;
    _164++;
    if (_164 < j)
    goto _jump2448;
    // End body of loop
    _160 = _161;
    goto _jump2449;
    _jump2445:;
    _a2__a1_bool _166;
    // Computing bound for J
    bool _167 = !y;
    bool _168 = !_167;
    int64_t _169;
    if (!_168)
    goto _jump2450;
    _169 = o;
    goto _jump2451;
    _jump2450:;
    _a2_int64_t _170;
    // Computing bound for J
    _170.d0 = o;
    if (o > 0) 
    goto _jump2452;
    fail_assertion("non-positive loop bound");
    _jump2452:;
    // Computing bound for K
    _170.d1 = G.d0;
    if (G.d0 > 0) 
    goto _jump2453;
    fail_assertion("non-positive loop bound");
    _jump2453:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= o;
    _171 *= G.d0;
    _171 *= sizeof(int64_t);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // K
    int64_t _173 = 0; // J
    _jump2454:; // Begin body of loop
    int64_t _174 = 0;
    _174 *= _170.d0;
    _174 += _173;
    _174 *= _170.d1;
    _174 += _172;
    _170.data[_174] = u;
    _172++;
    if (_172 < G.d0)
    goto _jump2454;
    _172 = 0;
    _173++;
    if (_173 < o)
    goto _jump2454;
    // End body of loop
    int64_t _175 = r * b;
    if (_175 >= 0)
    goto _jump2455;
    fail_assertion("negative array index");
    _jump2455:;
    if (_175 < _170.d0)
    goto _jump2456;
    fail_assertion("index too large");
    _jump2456:;
    if (c >= 0)
    goto _jump2457;
    fail_assertion("negative array index");
    _jump2457:;
    if (c < _170.d1)
    goto _jump2458;
    fail_assertion("index too large");
    _jump2458:;
    int64_t _176 = 0;
    _176 *= _170.d0;
    _176 += _175;
    _176 *= _170.d1;
    _176 += c;
    int64_t _177 = _170.data[_176];
    _169 = _177;
    _jump2451:;
    _166.d0 = _169;
    if (_169 > 0) 
    goto _jump2459;
    fail_assertion("non-positive loop bound");
    _jump2459:;
    // Computing bound for K
    int64_t _178 = i / r;
    _a1_int64_t _179;
    _179.d0 = 3;
    _179.data = jpl_alloc(sizeof(int64_t) * 3);
    _179.data[0] = c;
    _179.data[1] = d;
    _179.data[2] = _178;
    int64_t _180 = 137;
    if (_180 >= 0)
    goto _jump2460;
    fail_assertion("negative array index");
    _jump2460:;
    if (_180 < _179.d0)
    goto _jump2461;
    fail_assertion("index too large");
    _jump2461:;
    int64_t _181 = 0;
    _181 *= _179.d0;
    _181 += _180;
    int64_t _182 = _179.data[_181];
    _166.d1 = _182;
    if (_182 > 0) 
    goto _jump2462;
    fail_assertion("non-positive loop bound");
    _jump2462:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= _169;
    _183 *= _182;
    _183 *= sizeof(_a1_bool);
    _166.data = jpl_alloc(_183);
    int64_t _184 = 0; // K
    int64_t _185 = 0; // J
    _jump2463:; // Begin body of loop
    double _186 = 63.0;
    bool _187 = _186 > t;
    bool _188 = !_187;
    _a1_bool _189;
    _189.d0 = 1;
    _189.data = jpl_alloc(sizeof(bool) * 1);
    _189.data[0] = _188;
    int64_t _190 = 0;
    _190 *= _166.d0;
    _190 += _185;
    _190 *= _166.d1;
    _190 += _184;
    _166.data[_190] = _189;
    _184++;
    if (_184 < _182)
    goto _jump2463;
    _184 = 0;
    _185++;
    if (_185 < _169)
    goto _jump2463;
    // End body of loop
    _160 = _166;
    _jump2449:;
    int64_t _191 = -i;
    if (G.d0 >= 0)
    goto _jump2464;
    fail_assertion("negative array index");
    _jump2464:;
    if (G.d0 < _160.d0)
    goto _jump2465;
    fail_assertion("index too large");
    _jump2465:;
    if (_191 >= 0)
    goto _jump2466;
    fail_assertion("negative array index");
    _jump2466:;
    if (_191 < _160.d1)
    goto _jump2467;
    fail_assertion("index too large");
    _jump2467:;
    int64_t _192 = 0;
    _192 *= _160.d0;
    _192 += G.d0;
    _192 *= _160.d1;
    _192 += _191;
    _a1_bool _193 = _160.data[_192];
    rgba _194 = e(_112, _193);
    double _195 = 5.0;
    double _196 = _195 / t;
    void_t _197 = l();
    C _198 = E(_197, G);
    bool _199 = _198.b;
    _a3_void_t _200;
    if (!_199)
    goto _jump2468;
    _a3_void_t _201;
    // Computing bound for K
    _201.d0 = c;
    if (c > 0) 
    goto _jump2469;
    fail_assertion("non-positive loop bound");
    _jump2469:;
    // Computing bound for L
    _201.d1 = b;
    if (b > 0) 
    goto _jump2470;
    fail_assertion("non-positive loop bound");
    _jump2470:;
    // Computing bound for M
    _201.d2 = G.d0;
    if (G.d0 > 0) 
    goto _jump2471;
    fail_assertion("non-positive loop bound");
    _jump2471:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= c;
    _202 *= b;
    _202 *= G.d0;
    _202 *= sizeof(void_t);
    _201.data = jpl_alloc(_202);
    int64_t _203 = 0; // M
    int64_t _204 = 0; // L
    int64_t _205 = 0; // K
    _jump2472:; // Begin body of loop
    void_t _206 = l();
    int64_t _207 = 0;
    _207 *= _201.d0;
    _207 += _205;
    _207 *= _201.d1;
    _207 += _204;
    _207 *= _201.d2;
    _207 += _203;
    _201.data[_207] = _206;
    _203++;
    if (_203 < G.d0)
    goto _jump2472;
    _203 = 0;
    _204++;
    if (_204 < b)
    goto _jump2472;
    _204 = 0;
    _205++;
    if (_205 < c)
    goto _jump2472;
    // End body of loop
    _200 = _201;
    goto _jump2473;
    _jump2468:;
    _a3_void_t _208;
    // Computing bound for K
    _208.d0 = G.d0;
    if (G.d0 > 0) 
    goto _jump2474;
    fail_assertion("non-positive loop bound");
    _jump2474:;
    // Computing bound for L
    _208.d1 = c;
    if (c > 0) 
    goto _jump2475;
    fail_assertion("non-positive loop bound");
    _jump2475:;
    // Computing bound for M
    _208.d2 = u;
    if (u > 0) 
    goto _jump2476;
    fail_assertion("non-positive loop bound");
    _jump2476:;
    // Computing total size of heap memory to allocate
    int64_t _209 = 1;
    _209 *= G.d0;
    _209 *= c;
    _209 *= u;
    _209 *= sizeof(void_t);
    _208.data = jpl_alloc(_209);
    int64_t _210 = 0; // M
    int64_t _211 = 0; // L
    int64_t _212 = 0; // K
    _jump2477:; // Begin body of loop
    void_t _213 = l();
    int64_t _214 = 0;
    _214 *= _208.d0;
    _214 += _212;
    _214 *= _208.d1;
    _214 += _211;
    _214 *= _208.d2;
    _214 += _210;
    _208.data[_214] = _213;
    _210++;
    if (_210 < u)
    goto _jump2477;
    _210 = 0;
    _211++;
    if (_211 < c)
    goto _jump2477;
    _211 = 0;
    _212++;
    if (_212 < G.d0)
    goto _jump2477;
    // End body of loop
    _200 = _208;
    _jump2473:;
    rgba _215;
    if (!y)
    goto _jump2478;
    _215 = _194;
    goto _jump2479;
    _jump2478:;
    _215 = _81;
    _jump2479:;
    C _216 = { _200, y, _215 };
    bool _217 = _216.b;
    void_t _218;
    if (!_217)
    goto _jump2480;
    bool _219 = h >= o;
    void_t _220;
    if (!_219)
    goto _jump2481;
    void_t _221 = l();
    _220 = _221;
    goto _jump2482;
    _jump2481:;
    void_t _222 = l();
    _220 = _222;
    _jump2482:;
    _218 = _220;
    goto _jump2483;
    _jump2480:;
    _218 = F;
    _jump2483:;
    _a1_rgba _223 = k(_196, _218);
    _a2_bool _224;
    if (!y)
    goto _jump2484;
    _224 = D;
    goto _jump2485;
    _jump2484:;
    _224 = m;
    _jump2485:;
    bool _225 = n != s.d0;
    C _226;
    if (!_225)
    goto _jump2486;
    C _227;
    if (!y)
    goto _jump2487;
    _a1_p _228;
    // Computing bound for Q
    _228.d0 = d;
    if (d > 0) 
    goto _jump2488;
    fail_assertion("non-positive loop bound");
    _jump2488:;
    // Computing total size of heap memory to allocate
    int64_t _229 = 1;
    _229 *= d;
    _229 *= sizeof(p);
    _228.data = jpl_alloc(_229);
    int64_t _230 = 0; // Q
    _jump2489:; // Begin body of loop
    _a3_p _231;
    // Computing bound for R
    _231.d0 = _224.d0;
    if (_224.d0 > 0) 
    goto _jump2490;
    fail_assertion("non-positive loop bound");
    _jump2490:;
    // Computing bound for S
    _231.d1 = u;
    if (u > 0) 
    goto _jump2491;
    fail_assertion("non-positive loop bound");
    _jump2491:;
    // Computing bound for T
    _231.d2 = G.d0;
    if (G.d0 > 0) 
    goto _jump2492;
    fail_assertion("non-positive loop bound");
    _jump2492:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= _224.d0;
    _232 *= u;
    _232 *= G.d0;
    _232 *= sizeof(p);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // T
    int64_t _234 = 0; // S
    int64_t _235 = 0; // R
    _jump2493:; // Begin body of loop
    int64_t _236 = 0;
    _236 *= _231.d0;
    _236 += _235;
    _236 *= _231.d1;
    _236 += _234;
    _236 *= _231.d2;
    _236 += _233;
    _231.data[_236] = A;
    _233++;
    if (_233 < G.d0)
    goto _jump2493;
    _233 = 0;
    _234++;
    if (_234 < u)
    goto _jump2493;
    _234 = 0;
    _235++;
    if (_235 < _224.d0)
    goto _jump2493;
    // End body of loop
    if (_224.d1 >= 0)
    goto _jump2494;
    fail_assertion("negative array index");
    _jump2494:;
    if (_224.d1 < _231.d0)
    goto _jump2495;
    fail_assertion("index too large");
    _jump2495:;
    if (h >= 0)
    goto _jump2496;
    fail_assertion("negative array index");
    _jump2496:;
    if (h < _231.d1)
    goto _jump2497;
    fail_assertion("index too large");
    _jump2497:;
    if (i >= 0)
    goto _jump2498;
    fail_assertion("negative array index");
    _jump2498:;
    if (i < _231.d2)
    goto _jump2499;
    fail_assertion("index too large");
    _jump2499:;
    int64_t _237 = 0;
    _237 *= _231.d0;
    _237 += _224.d1;
    _237 *= _231.d1;
    _237 += h;
    _237 *= _231.d2;
    _237 += i;
    p _238 = _231.data[_237];
    int64_t _239 = 0;
    _239 *= _228.d0;
    _239 += _230;
    _228.data[_239] = _238;
    _230++;
    if (_230 < d)
    goto _jump2489;
    // End body of loop
    C _240 = E(F, _228);
    _227 = _240;
    goto _jump2500;
    _jump2487:;
    _a2__a3_void_t _241;
    // Computing bound for Q
    int64_t _242 = 477;
    _241.d0 = _242;
    if (_242 > 0) 
    goto _jump2501;
    fail_assertion("non-positive loop bound");
    _jump2501:;
    // Computing bound for R
    _241.d1 = j;
    if (j > 0) 
    goto _jump2502;
    fail_assertion("non-positive loop bound");
    _jump2502:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= _242;
    _243 *= j;
    _243 *= sizeof(_a3_void_t);
    _241.data = jpl_alloc(_243);
    int64_t _244 = 0; // R
    int64_t _245 = 0; // Q
    _jump2503:; // Begin body of loop
    _a3_void_t _246;
    // Computing bound for S
    _246.d0 = _224.d1;
    if (_224.d1 > 0) 
    goto _jump2504;
    fail_assertion("non-positive loop bound");
    _jump2504:;
    // Computing bound for T
    _246.d1 = o;
    if (o > 0) 
    goto _jump2505;
    fail_assertion("non-positive loop bound");
    _jump2505:;
    // Computing bound for U
    _246.d2 = G.d0;
    if (G.d0 > 0) 
    goto _jump2506;
    fail_assertion("non-positive loop bound");
    _jump2506:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= _224.d1;
    _247 *= o;
    _247 *= G.d0;
    _247 *= sizeof(void_t);
    _246.data = jpl_alloc(_247);
    int64_t _248 = 0; // U
    int64_t _249 = 0; // T
    int64_t _250 = 0; // S
    _jump2507:; // Begin body of loop
    void_t _251 = l();
    int64_t _252 = 0;
    _252 *= _246.d0;
    _252 += _250;
    _252 *= _246.d1;
    _252 += _249;
    _252 *= _246.d2;
    _252 += _248;
    _246.data[_252] = _251;
    _248++;
    if (_248 < G.d0)
    goto _jump2507;
    _248 = 0;
    _249++;
    if (_249 < o)
    goto _jump2507;
    _249 = 0;
    _250++;
    if (_250 < _224.d1)
    goto _jump2507;
    // End body of loop
    int64_t _253 = 0;
    _253 *= _241.d0;
    _253 += _245;
    _253 *= _241.d1;
    _253 += _244;
    _241.data[_253] = _246;
    _244++;
    if (_244 < j)
    goto _jump2503;
    _244 = 0;
    _245++;
    if (_245 < _242)
    goto _jump2503;
    // End body of loop
    int64_t _254 = 952;
    int64_t _255 = 273;
    if (_254 >= 0)
    goto _jump2508;
    fail_assertion("negative array index");
    _jump2508:;
    if (_254 < _241.d0)
    goto _jump2509;
    fail_assertion("index too large");
    _jump2509:;
    if (_255 >= 0)
    goto _jump2510;
    fail_assertion("negative array index");
    _jump2510:;
    if (_255 < _241.d1)
    goto _jump2511;
    fail_assertion("index too large");
    _jump2511:;
    int64_t _256 = 0;
    _256 *= _241.d0;
    _256 += _254;
    _256 *= _241.d1;
    _256 += _255;
    _a3_void_t _257 = _241.data[_256];
    bool _259 = true;
    bool _260 = !_259;
    bool _258 = _260;
    if (0 != _260)
    goto _jump2512;
    _258 = y;
    _jump2512:;
    double _261 = 17.0;
    double _262 = _81.r;
    double _263 = -_262;
    double _264;
    // Computing bound for Q
    int64_t _265 = 248;
    if (_265 > 0) 
    goto _jump2513;
    fail_assertion("non-positive loop bound");
    _jump2513:;
    _264 = 0;
    int64_t _266 = 0; // Q
    _jump2514:; // Begin body of loop
    double _267;
    if (!y)
    goto _jump2515;
    _267 = t;
    goto _jump2516;
    _jump2515:;
    _267 = t;
    _jump2516:;
    _264 += _267;
    _266++;
    if (_266 < _265)
    goto _jump2514;
    // End body of loop
    double _268 = 3.0;
    _a1_double _269;
    _269.d0 = 1;
    _269.data = jpl_alloc(sizeof(double) * 1);
    _269.data[0] = _268;
    if (o >= 0)
    goto _jump2517;
    fail_assertion("negative array index");
    _jump2517:;
    if (o < _269.d0)
    goto _jump2518;
    fail_assertion("index too large");
    _jump2518:;
    int64_t _270 = 0;
    _270 *= _269.d0;
    _270 += o;
    double _271 = _269.data[_270];
    rgba _272 = { _261, _263, _264, _271 };
    C _273 = { _257, _258, _272 };
    _227 = _273;
    _jump2500:;
    _226 = _227;
    goto _jump2519;
    _jump2486:;
    void_t _274 = l();
    _a1__a1_p _275;
    _275.d0 = 1;
    _275.data = jpl_alloc(sizeof(_a1_p) * 1);
    _275.data[0] = G;
    if (s.d0 >= 0)
    goto _jump2520;
    fail_assertion("negative array index");
    _jump2520:;
    if (s.d0 < _275.d0)
    goto _jump2521;
    fail_assertion("index too large");
    _jump2521:;
    int64_t _276 = 0;
    _276 *= _275.d0;
    _276 += s.d0;
    _a1_p _277 = _275.data[_276];
    C _278 = E(_274, _277);
    bool _279 = _278.b;
    C _280;
    if (!_279)
    goto _jump2522;
    bool _281;
    if (!y)
    goto _jump2523;
    bool _282 = h == j;
    _281 = _282;
    goto _jump2524;
    _jump2523:;
    bool _283 = false;
    _281 = _283;
    _jump2524:;
    void_t _284;
    if (!_281)
    goto _jump2525;
    _284 = F;
    goto _jump2526;
    _jump2525:;
    void_t _285 = l();
    _284 = _285;
    _jump2526:;
    _a3__a1_p _286;
    // Computing bound for Q
    _286.d0 = n;
    if (n > 0) 
    goto _jump2527;
    fail_assertion("non-positive loop bound");
    _jump2527:;
    // Computing bound for R
    int64_t _287;
    // Computing bound for Q
    int64_t _288 = 998;
    if (_288 > 0) 
    goto _jump2528;
    fail_assertion("non-positive loop bound");
    _jump2528:;
    _287 = 0;
    int64_t _289 = 0; // Q
    _jump2529:; // Begin body of loop
    _287 += r;
    _289++;
    if (_289 < _288)
    goto _jump2529;
    // End body of loop
    _286.d1 = _287;
    if (_287 > 0) 
    goto _jump2530;
    fail_assertion("non-positive loop bound");
    _jump2530:;
    // Computing bound for S
    _286.d2 = _224.d1;
    if (_224.d1 > 0) 
    goto _jump2531;
    fail_assertion("non-positive loop bound");
    _jump2531:;
    // Computing total size of heap memory to allocate
    int64_t _290 = 1;
    _290 *= n;
    _290 *= _287;
    _290 *= _224.d1;
    _290 *= sizeof(_a1_p);
    _286.data = jpl_alloc(_290);
    int64_t _291 = 0; // S
    int64_t _292 = 0; // R
    int64_t _293 = 0; // Q
    _jump2532:; // Begin body of loop
    int64_t _294 = 0;
    _294 *= _286.d0;
    _294 += _293;
    _294 *= _286.d1;
    _294 += _292;
    _294 *= _286.d2;
    _294 += _291;
    _286.data[_294] = G;
    _291++;
    if (_291 < _224.d1)
    goto _jump2532;
    _291 = 0;
    _292++;
    if (_292 < _287)
    goto _jump2532;
    _292 = 0;
    _293++;
    if (_293 < n)
    goto _jump2532;
    // End body of loop
    if (b >= 0)
    goto _jump2533;
    fail_assertion("negative array index");
    _jump2533:;
    if (b < _286.d0)
    goto _jump2534;
    fail_assertion("index too large");
    _jump2534:;
    if (_224.d1 >= 0)
    goto _jump2535;
    fail_assertion("negative array index");
    _jump2535:;
    if (_224.d1 < _286.d1)
    goto _jump2536;
    fail_assertion("index too large");
    _jump2536:;
    if (G.d0 >= 0)
    goto _jump2537;
    fail_assertion("negative array index");
    _jump2537:;
    if (G.d0 < _286.d2)
    goto _jump2538;
    fail_assertion("index too large");
    _jump2538:;
    int64_t _295 = 0;
    _295 *= _286.d0;
    _295 += b;
    _295 *= _286.d1;
    _295 += _224.d1;
    _295 *= _286.d2;
    _295 += G.d0;
    _a1_p _296 = _286.data[_295];
    C _297 = E(_284, _296);
    _280 = _297;
    goto _jump2539;
    _jump2522:;
    _a1_C _298;
    // Computing bound for Q
    bool _299 = true;
    int64_t _300;
    if (!_299)
    goto _jump2540;
    _300 = o;
    goto _jump2541;
    _jump2540:;
    int64_t _301 = 429;
    _300 = _301;
    _jump2541:;
    _298.d0 = _300;
    if (_300 > 0) 
    goto _jump2542;
    fail_assertion("non-positive loop bound");
    _jump2542:;
    // Computing total size of heap memory to allocate
    int64_t _302 = 1;
    _302 *= _300;
    _302 *= sizeof(C);
    _298.data = jpl_alloc(_302);
    int64_t _303 = 0; // Q
    _jump2543:; // Begin body of loop
    void_t _304 = l();
    C _305 = E(_304, G);
    int64_t _306 = 0;
    _306 *= _298.d0;
    _306 += _303;
    _298.data[_306] = _305;
    _303++;
    if (_303 < _300)
    goto _jump2543;
    // End body of loop
    if (c >= 0)
    goto _jump2544;
    fail_assertion("negative array index");
    _jump2544:;
    if (c < _298.d0)
    goto _jump2545;
    fail_assertion("index too large");
    _jump2545:;
    int64_t _307 = 0;
    _307 *= _298.d0;
    _307 += c;
    C _308 = _298.data[_307];
    _280 = _308;
    _jump2539:;
    _226 = _280;
    _jump2519:;
    bool _309 = _226.b;
    if (0 != _309)
    goto _jump2546;
    fail_assertion("Q");
    _jump2546:;
    _a2_C _310;
    // Computing bound for Q
    int64_t _311;
    // Computing bound for Q
    if (b > 0) 
    goto _jump2547;
    fail_assertion("non-positive loop bound");
    _jump2547:;
    _311 = 0;
    int64_t _312 = 0; // Q
    _jump2548:; // Begin body of loop
    _311 += j;
    _312++;
    if (_312 < b)
    goto _jump2548;
    // End body of loop
    int64_t _313 = -_311;
    _310.d0 = _313;
    if (_313 > 0) 
    goto _jump2549;
    fail_assertion("non-positive loop bound");
    _jump2549:;
    // Computing bound for R
    _a1_int64_t _314;
    // Computing bound for Q
    _a2_int64_t _315;
    // Computing bound for Q
    _315.d0 = G.d0;
    if (G.d0 > 0) 
    goto _jump2550;
    fail_assertion("non-positive loop bound");
    _jump2550:;
    // Computing bound for R
    _315.d1 = i;
    if (i > 0) 
    goto _jump2551;
    fail_assertion("non-positive loop bound");
    _jump2551:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= G.d0;
    _316 *= i;
    _316 *= sizeof(int64_t);
    _315.data = jpl_alloc(_316);
    int64_t _317 = 0; // R
    int64_t _318 = 0; // Q
    _jump2552:; // Begin body of loop
    int64_t _319 = 0;
    _319 *= _315.d0;
    _319 += _318;
    _319 *= _315.d1;
    _319 += _317;
    _315.data[_319] = _224.d0;
    _317++;
    if (_317 < i)
    goto _jump2552;
    _317 = 0;
    _318++;
    if (_318 < G.d0)
    goto _jump2552;
    // End body of loop
    if (h >= 0)
    goto _jump2553;
    fail_assertion("negative array index");
    _jump2553:;
    if (h < _315.d0)
    goto _jump2554;
    fail_assertion("index too large");
    _jump2554:;
    if (o >= 0)
    goto _jump2555;
    fail_assertion("negative array index");
    _jump2555:;
    if (o < _315.d1)
    goto _jump2556;
    fail_assertion("index too large");
    _jump2556:;
    int64_t _320 = 0;
    _320 *= _315.d0;
    _320 += h;
    _320 *= _315.d1;
    _320 += o;
    int64_t _321 = _315.data[_320];
    _314.d0 = _321;
    if (_321 > 0) 
    goto _jump2557;
    fail_assertion("non-positive loop bound");
    _jump2557:;
    // Computing total size of heap memory to allocate
    int64_t _322 = 1;
    _322 *= _321;
    _322 *= sizeof(int64_t);
    _314.data = jpl_alloc(_322);
    int64_t _323 = 0; // Q
    _jump2558:; // Begin body of loop
    int64_t _324 = 0;
    _324 *= _314.d0;
    _324 += _323;
    _314.data[_324] = b;
    _323++;
    if (_323 < _321)
    goto _jump2558;
    // End body of loop
    _a3__a3_int64_t _325;
    // Computing bound for Q
    _325.d0 = o;
    if (o > 0) 
    goto _jump2559;
    fail_assertion("non-positive loop bound");
    _jump2559:;
    // Computing bound for R
    _325.d1 = d;
    if (d > 0) 
    goto _jump2560;
    fail_assertion("non-positive loop bound");
    _jump2560:;
    // Computing bound for S
    _325.d2 = i;
    if (i > 0) 
    goto _jump2561;
    fail_assertion("non-positive loop bound");
    _jump2561:;
    // Computing total size of heap memory to allocate
    int64_t _326 = 1;
    _326 *= o;
    _326 *= d;
    _326 *= i;
    _326 *= sizeof(_a3_int64_t);
    _325.data = jpl_alloc(_326);
    int64_t _327 = 0; // S
    int64_t _328 = 0; // R
    int64_t _329 = 0; // Q
    _jump2562:; // Begin body of loop
    _a3_int64_t _330;
    // Computing bound for T
    _330.d0 = b;
    if (b > 0) 
    goto _jump2563;
    fail_assertion("non-positive loop bound");
    _jump2563:;
    // Computing bound for U
    _330.d1 = _224.d1;
    if (_224.d1 > 0) 
    goto _jump2564;
    fail_assertion("non-positive loop bound");
    _jump2564:;
    // Computing bound for V
    _330.d2 = c;
    if (c > 0) 
    goto _jump2565;
    fail_assertion("non-positive loop bound");
    _jump2565:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= b;
    _331 *= _224.d1;
    _331 *= c;
    _331 *= sizeof(int64_t);
    _330.data = jpl_alloc(_331);
    int64_t _332 = 0; // V
    int64_t _333 = 0; // U
    int64_t _334 = 0; // T
    _jump2566:; // Begin body of loop
    int64_t _335 = 0;
    _335 *= _330.d0;
    _335 += _334;
    _335 *= _330.d1;
    _335 += _333;
    _335 *= _330.d2;
    _335 += _332;
    _330.data[_335] = u;
    _332++;
    if (_332 < c)
    goto _jump2566;
    _332 = 0;
    _333++;
    if (_333 < _224.d1)
    goto _jump2566;
    _333 = 0;
    _334++;
    if (_334 < b)
    goto _jump2566;
    // End body of loop
    int64_t _336 = 0;
    _336 *= _325.d0;
    _336 += _329;
    _336 *= _325.d1;
    _336 += _328;
    _336 *= _325.d2;
    _336 += _327;
    _325.data[_336] = _330;
    _327++;
    if (_327 < i)
    goto _jump2562;
    _327 = 0;
    _328++;
    if (_328 < d)
    goto _jump2562;
    _328 = 0;
    _329++;
    if (_329 < o)
    goto _jump2562;
    // End body of loop
    int64_t _337;
    // Computing bound for Q
    if (G.d0 > 0) 
    goto _jump2567;
    fail_assertion("non-positive loop bound");
    _jump2567:;
    // Computing bound for R
    if (o > 0) 
    goto _jump2568;
    fail_assertion("non-positive loop bound");
    _jump2568:;
    _337 = 0;
    int64_t _338 = 0; // R
    int64_t _339 = 0; // Q
    _jump2569:; // Begin body of loop
    _337 += b;
    _338++;
    if (_338 < o)
    goto _jump2569;
    _338 = 0;
    _339++;
    if (_339 < G.d0)
    goto _jump2569;
    // End body of loop
    _a2_int64_t _340;
    // Computing bound for Q
    _340.d0 = h;
    if (h > 0) 
    goto _jump2570;
    fail_assertion("non-positive loop bound");
    _jump2570:;
    // Computing bound for R
    _340.d1 = i;
    if (i > 0) 
    goto _jump2571;
    fail_assertion("non-positive loop bound");
    _jump2571:;
    // Computing total size of heap memory to allocate
    int64_t _341 = 1;
    _341 *= h;
    _341 *= i;
    _341 *= sizeof(int64_t);
    _340.data = jpl_alloc(_341);
    int64_t _342 = 0; // R
    int64_t _343 = 0; // Q
    _jump2572:; // Begin body of loop
    int64_t _344 = 0;
    _344 *= _340.d0;
    _344 += _343;
    _344 *= _340.d1;
    _344 += _342;
    _340.data[_344] = r;
    _342++;
    if (_342 < i)
    goto _jump2572;
    _342 = 0;
    _343++;
    if (_343 < h)
    goto _jump2572;
    // End body of loop
    if (d >= 0)
    goto _jump2573;
    fail_assertion("negative array index");
    _jump2573:;
    if (d < _340.d0)
    goto _jump2574;
    fail_assertion("index too large");
    _jump2574:;
    if (h >= 0)
    goto _jump2575;
    fail_assertion("negative array index");
    _jump2575:;
    if (h < _340.d1)
    goto _jump2576;
    fail_assertion("index too large");
    _jump2576:;
    int64_t _345 = 0;
    _345 *= _340.d0;
    _345 += d;
    _345 *= _340.d1;
    _345 += h;
    int64_t _346 = _340.data[_345];
    if (_337 >= 0)
    goto _jump2577;
    fail_assertion("negative array index");
    _jump2577:;
    if (_337 < _325.d0)
    goto _jump2578;
    fail_assertion("index too large");
    _jump2578:;
    if (_346 >= 0)
    goto _jump2579;
    fail_assertion("negative array index");
    _jump2579:;
    if (_346 < _325.d1)
    goto _jump2580;
    fail_assertion("index too large");
    _jump2580:;
    if (j >= 0)
    goto _jump2581;
    fail_assertion("negative array index");
    _jump2581:;
    if (j < _325.d2)
    goto _jump2582;
    fail_assertion("index too large");
    _jump2582:;
    int64_t _347 = 0;
    _347 *= _325.d0;
    _347 += _337;
    _347 *= _325.d1;
    _347 += _346;
    _347 *= _325.d2;
    _347 += j;
    _a3_int64_t _348 = _325.data[_347];
    if (u >= 0)
    goto _jump2583;
    fail_assertion("negative array index");
    _jump2583:;
    if (u < _348.d0)
    goto _jump2584;
    fail_assertion("index too large");
    _jump2584:;
    if (n >= 0)
    goto _jump2585;
    fail_assertion("negative array index");
    _jump2585:;
    if (n < _348.d1)
    goto _jump2586;
    fail_assertion("index too large");
    _jump2586:;
    if (i >= 0)
    goto _jump2587;
    fail_assertion("negative array index");
    _jump2587:;
    if (i < _348.d2)
    goto _jump2588;
    fail_assertion("index too large");
    _jump2588:;
    int64_t _349 = 0;
    _349 *= _348.d0;
    _349 += u;
    _349 *= _348.d1;
    _349 += n;
    _349 *= _348.d2;
    _349 += i;
    int64_t _350 = _348.data[_349];
    if (_350 >= 0)
    goto _jump2589;
    fail_assertion("negative array index");
    _jump2589:;
    if (_350 < _314.d0)
    goto _jump2590;
    fail_assertion("index too large");
    _jump2590:;
    int64_t _351 = 0;
    _351 *= _314.d0;
    _351 += _350;
    int64_t _352 = _314.data[_351];
    _310.d1 = _352;
    if (_352 > 0) 
    goto _jump2591;
    fail_assertion("non-positive loop bound");
    _jump2591:;
    // Computing total size of heap memory to allocate
    int64_t _353 = 1;
    _353 *= _313;
    _353 *= _352;
    _353 *= sizeof(C);
    _310.data = jpl_alloc(_353);
    int64_t _354 = 0; // R
    int64_t _355 = 0; // Q
    _jump2592:; // Begin body of loop
    _a3_void_t _356;
    if (!y)
    goto _jump2593;
    _a3_void_t _357;
    // Computing bound for S
    int64_t _358 = -_354;
    _357.d0 = _358;
    if (_358 > 0) 
    goto _jump2594;
    fail_assertion("non-positive loop bound");
    _jump2594:;
    // Computing bound for T
    _357.d1 = n;
    if (n > 0) 
    goto _jump2595;
    fail_assertion("non-positive loop bound");
    _jump2595:;
    // Computing bound for U
    bool _359 = o != s.d0;
    int64_t _360;
    if (!_359)
    goto _jump2596;
    _360 = b;
    goto _jump2597;
    _jump2596:;
    _360 = G.d0;
    _jump2597:;
    _357.d2 = _360;
    if (_360 > 0) 
    goto _jump2598;
    fail_assertion("non-positive loop bound");
    _jump2598:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= _358;
    _361 *= n;
    _361 *= _360;
    _361 *= sizeof(void_t);
    _357.data = jpl_alloc(_361);
    int64_t _362 = 0; // U
    int64_t _363 = 0; // T
    int64_t _364 = 0; // S
    _jump2599:; // Begin body of loop
    int64_t _365 = 0;
    _365 *= _357.d0;
    _365 += _364;
    _365 *= _357.d1;
    _365 += _363;
    _365 *= _357.d2;
    _365 += _362;
    _357.data[_365] = F;
    _362++;
    if (_362 < _360)
    goto _jump2599;
    _362 = 0;
    _363++;
    if (_363 < n)
    goto _jump2599;
    _363 = 0;
    _364++;
    if (_364 < _358)
    goto _jump2599;
    // End body of loop
    _356 = _357;
    goto _jump2600;
    _jump2593:;
    double _366 = A.a;
    double _367;
    // Computing bound for S
    if (h > 0) 
    goto _jump2601;
    fail_assertion("non-positive loop bound");
    _jump2601:;
    _367 = 0;
    int64_t _368 = 0; // S
    _jump2602:; // Begin body of loop
    double _369 = 97.0;
    _367 += _369;
    _368++;
    if (_368 < h)
    goto _jump2602;
    // End body of loop
    bool _370 = _366 <= _367;
    _a3_void_t _371;
    if (!_370)
    goto _jump2603;
    _a3_void_t _372;
    // Computing bound for S
    _372.d0 = s.d0;
    if (s.d0 > 0) 
    goto _jump2604;
    fail_assertion("non-positive loop bound");
    _jump2604:;
    // Computing bound for T
    _372.d1 = j;
    if (j > 0) 
    goto _jump2605;
    fail_assertion("non-positive loop bound");
    _jump2605:;
    // Computing bound for U
    _372.d2 = s.d0;
    if (s.d0 > 0) 
    goto _jump2606;
    fail_assertion("non-positive loop bound");
    _jump2606:;
    // Computing total size of heap memory to allocate
    int64_t _373 = 1;
    _373 *= s.d0;
    _373 *= j;
    _373 *= s.d0;
    _373 *= sizeof(void_t);
    _372.data = jpl_alloc(_373);
    int64_t _374 = 0; // U
    int64_t _375 = 0; // T
    int64_t _376 = 0; // S
    _jump2607:; // Begin body of loop
    void_t _377 = l();
    int64_t _378 = 0;
    _378 *= _372.d0;
    _378 += _376;
    _378 *= _372.d1;
    _378 += _375;
    _378 *= _372.d2;
    _378 += _374;
    _372.data[_378] = _377;
    _374++;
    if (_374 < s.d0)
    goto _jump2607;
    _374 = 0;
    _375++;
    if (_375 < j)
    goto _jump2607;
    _375 = 0;
    _376++;
    if (_376 < s.d0)
    goto _jump2607;
    // End body of loop
    _371 = _372;
    goto _jump2608;
    _jump2603:;
    _a3_void_t _379;
    // Computing bound for S
    int64_t _380 = u % d;
    _379.d0 = _380;
    if (_380 > 0) 
    goto _jump2609;
    fail_assertion("non-positive loop bound");
    _jump2609:;
    // Computing bound for T
    _379.d1 = _224.d0;
    if (_224.d0 > 0) 
    goto _jump2610;
    fail_assertion("non-positive loop bound");
    _jump2610:;
    // Computing bound for U
    _379.d2 = _355;
    if (_355 > 0) 
    goto _jump2611;
    fail_assertion("non-positive loop bound");
    _jump2611:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= _380;
    _381 *= _224.d0;
    _381 *= _355;
    _381 *= sizeof(void_t);
    _379.data = jpl_alloc(_381);
    int64_t _382 = 0; // U
    int64_t _383 = 0; // T
    int64_t _384 = 0; // S
    _jump2612:; // Begin body of loop
    bool _385 = true;
    void_t _386;
    if (!_385)
    goto _jump2613;
    _386 = F;
    goto _jump2614;
    _jump2613:;
    void_t _387 = l();
    _386 = _387;
    _jump2614:;
    int64_t _388 = 0;
    _388 *= _379.d0;
    _388 += _384;
    _388 *= _379.d1;
    _388 += _383;
    _388 *= _379.d2;
    _388 += _382;
    _379.data[_388] = _386;
    _382++;
    if (_382 < _355)
    goto _jump2612;
    _382 = 0;
    _383++;
    if (_383 < _224.d0)
    goto _jump2612;
    _383 = 0;
    _384++;
    if (_384 < _380)
    goto _jump2612;
    // End body of loop
    _371 = _379;
    _jump2608:;
    _356 = _371;
    _jump2600:;
    bool _390 = y;
    if (0 == y)
    goto _jump2615;
    bool _391 = true;
    bool _392;
    if (!_391)
    goto _jump2616;
    _392 = y;
    goto _jump2617;
    _jump2616:;
    bool _393 = false;
    _392 = _393;
    _jump2617:;
    bool _394;
    if (!_392)
    goto _jump2618;
    bool _395 = true;
    bool _396 = !_395;
    _394 = _396;
    goto _jump2619;
    _jump2618:;
    _394 = y;
    _jump2619:;
    _390 = _394;
    _jump2615:;
    bool _389 = _390;
    if (0 == _390)
    goto _jump2620;
    bool _397 = _224.d1 <= b;
    double _398 = _194.g;
    bool _399 = _398 == t;
    bool _400 = _397 != _399;
    _389 = _400;
    _jump2620:;
    C _401 = { _356, _389, _81 };
    int64_t _402 = 0;
    _402 *= _310.d0;
    _402 += _355;
    _402 *= _310.d1;
    _402 += _354;
    _310.data[_402] = _401;
    _354++;
    if (_354 < _352)
    goto _jump2592;
    _354 = 0;
    _355++;
    if (_355 < _313)
    goto _jump2592;
    // End body of loop
    if (n >= 0)
    goto _jump2621;
    fail_assertion("negative array index");
    _jump2621:;
    if (n < _310.d0)
    goto _jump2622;
    fail_assertion("index too large");
    _jump2622:;
    if (n >= 0)
    goto _jump2623;
    fail_assertion("negative array index");
    _jump2623:;
    if (n < _310.d1)
    goto _jump2624;
    fail_assertion("index too large");
    _jump2624:;
    int64_t _403 = 0;
    _403 *= _310.d0;
    _403 += n;
    _403 *= _310.d1;
    _403 += n;
    C _404 = _310.data[_403];
    return _404;
}

void jpl_main(struct args args) {
    _a1_bool _1;
    // Computing bound for a
    int64_t _2 = 331;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= sizeof(bool);
    _1.data = jpl_alloc(_3);
    int64_t _4 = 0; // a
    _jump2:; // Begin body of loop
    bool _5 = false;
    int64_t _6 = 0;
    _6 *= _1.d0;
    _6 += _4;
    _1.data[_6] = _5;
    _4++;
    if (_4 < _2)
    goto _jump2;
    // End body of loop
    _a2_int64_t _7;
    // Computing bound for a
    int64_t _8 = 284;
    _7.d0 = _8;
    if (_8 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing bound for b
    int64_t _9 = 418;
    _7.d1 = _9;
    if (_9 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _8;
    _10 *= _9;
    _10 *= sizeof(int64_t);
    _7.data = jpl_alloc(_10);
    int64_t _11 = 0; // b
    int64_t _12 = 0; // a
    _jump5:; // Begin body of loop
    int64_t _13 = 19;
    int64_t _14 = 0;
    _14 *= _7.d0;
    _14 += _12;
    _14 *= _7.d1;
    _14 += _11;
    _7.data[_14] = _13;
    _11++;
    if (_11 < _9)
    goto _jump5;
    _11 = 0;
    _12++;
    if (_12 < _8)
    goto _jump5;
    // End body of loop
    int64_t _15 = 369;
    int64_t _16 = 280;
    int64_t _17 = _15 / _16;
    int64_t _18 = 773;
    int64_t _19 = -_18;
    if (_17 >= 0)
    goto _jump6;
    fail_assertion("negative array index");
    _jump6:;
    if (_17 < _7.d0)
    goto _jump7;
    fail_assertion("index too large");
    _jump7:;
    if (_19 >= 0)
    goto _jump8;
    fail_assertion("negative array index");
    _jump8:;
    if (_19 < _7.d1)
    goto _jump9;
    fail_assertion("index too large");
    _jump9:;
    int64_t _20 = 0;
    _20 *= _7.d0;
    _20 += _17;
    _20 *= _7.d1;
    _20 += _19;
    int64_t _21 = _7.data[_20];
    if (_21 >= 0)
    goto _jump10;
    fail_assertion("negative array index");
    _jump10:;
    if (_21 < _1.d0)
    goto _jump11;
    fail_assertion("index too large");
    _jump11:;
    int64_t _22 = 0;
    _22 *= _1.d0;
    _22 += _21;
    bool _23 = _1.data[_22];
    bool _0 = _23;
    if (0 != _23)
    goto _jump12;
    double _24 = 67.0;
    double _25 = -_24;
    bool _26 = true;
    double _27;
    if (!_26)
    goto _jump13;
    double _28 = 98.0;
    _27 = _28;
    goto _jump14;
    _jump13:;
    double _29 = 68.0;
    _27 = _29;
    _jump14:;
    bool _30 = _25 <= _27;
    bool _31 = !_30;
    _0 = _31;
    _jump12:;
    _a1_bool _32;
    if (!_0)
    goto _jump15;
    bool _34 = false;
    bool _33 = _34;
    if (0 == _34)
    goto _jump16;
    int64_t _35 = 228;
    int64_t _36 = -_35;
    int64_t _37 = 895;
    bool _38 = _36 < _37;
    _33 = _38;
    _jump16:;
    _a1_bool _39;
    if (!_33)
    goto _jump17;
    bool _40 = false;
    bool _41 = true;
    double _42 = 54.0;
    double _43 = -_42;
    double _44;
    // Computing bound for a
    int64_t _45 = 154;
    if (_45 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    _44 = 0;
    int64_t _46 = 0; // a
    _jump19:; // Begin body of loop
    double _47 = 46.0;
    _44 += _47;
    _46++;
    if (_46 < _45)
    goto _jump19;
    // End body of loop
    bool _48 = _43 > _44;
    _a1_bool _49;
    _49.d0 = 3;
    _49.data = jpl_alloc(sizeof(bool) * 3);
    _49.data[0] = _40;
    _49.data[1] = _41;
    _49.data[2] = _48;
    _39 = _49;
    goto _jump20;
    _jump17:;
    _a1_bool _50;
    // Computing bound for a
    int64_t _51 = 320;
    _50.d0 = _51;
    if (_51 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= _51;
    _52 *= sizeof(bool);
    _50.data = jpl_alloc(_52);
    int64_t _53 = 0; // a
    _jump22:; // Begin body of loop
    bool _54 = false;
    int64_t _55 = 0;
    _55 *= _50.d0;
    _55 += _53;
    _50.data[_55] = _54;
    _53++;
    if (_53 < _51)
    goto _jump22;
    // End body of loop
    _39 = _50;
    _jump20:;
    _32 = _39;
    goto _jump23;
    _jump15:;
    bool _57 = false;
    bool _58 = !_57;
    bool _56 = _58;
    if (0 == _58)
    goto _jump24;
    bool _59 = true;
    _56 = _59;
    _jump24:;
    _a1_bool _60;
    _60.d0 = 1;
    _60.data = jpl_alloc(sizeof(bool) * 1);
    _60.data[0] = _56;
    _32 = _60;
    _jump23:;
    bool _61 = true;
    int64_t _62;
    // Computing bound for a
    int64_t _63 = 613;
    if (_63 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    _62 = 0;
    int64_t _64 = 0; // a
    _jump26:; // Begin body of loop
    _62 += _64;
    _64++;
    if (_64 < _63)
    goto _jump26;
    // End body of loop
    int64_t _65 = 807;
    int64_t _66 = -_65;
    bool _67 = _62 == _66;
    _a1_bool _68;
    _68.d0 = 2;
    _68.data = jpl_alloc(sizeof(bool) * 2);
    _68.data[0] = _61;
    _68.data[1] = _67;
    int64_t _69;
    // Computing bound for a
    int64_t _70 = 268;
    if (_70 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _69 = 0;
    int64_t _71 = 0; // a
    _jump28:; // Begin body of loop
    _69 += _71;
    _71++;
    if (_71 < _70)
    goto _jump28;
    // End body of loop
    int64_t _72 = -_69;
    bool _73 = false;
    int64_t _74;
    if (!_73)
    goto _jump29;
    bool _75 = false;
    int64_t _76;
    if (!_75)
    goto _jump30;
    int64_t _77 = 112;
    _76 = _77;
    goto _jump31;
    _jump30:;
    int64_t _78 = 82;
    _76 = _78;
    _jump31:;
    _74 = _76;
    goto _jump32;
    _jump29:;
    int64_t _79 = 16;
    int64_t _80 = -_79;
    _74 = _80;
    _jump32:;
    int64_t _81 = _72 + _74;
    if (_81 >= 0)
    goto _jump33;
    fail_assertion("negative array index");
    _jump33:;
    if (_81 < _68.d0)
    goto _jump34;
    fail_assertion("index too large");
    _jump34:;
    int64_t _82 = 0;
    _82 *= _68.d0;
    _82 += _81;
    bool _83 = _68.data[_82];
    int64_t _84;
    if (!_83)
    goto _jump35;
    int64_t _85;
    // Computing bound for a
    int64_t _86 = 992;
    int64_t _87 = -_86;
    int64_t _88 = -_87;
    if (_88 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    _85 = 0;
    int64_t _89 = 0; // a
    _jump37:; // Begin body of loop
    int64_t _90 = 223;
    int64_t _91 = -_90;
    _85 += _91;
    _89++;
    if (_89 < _88)
    goto _jump37;
    // End body of loop
    int64_t _92 = -_85;
    _84 = _92;
    goto _jump38;
    _jump35:;
    int64_t _93;
    // Computing bound for a
    int64_t _94 = 823;
    int64_t _95 = -_94;
    if (_95 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    _93 = 0;
    int64_t _96 = 0; // a
    _jump40:; // Begin body of loop
    int64_t _97 = 200;
    _93 += _97;
    _96++;
    if (_96 < _95)
    goto _jump40;
    // End body of loop
    int64_t _98 = 190;
    int64_t _99 = _93 + _98;
    bool _101 = true;
    bool _100 = _101;
    if (0 == _101)
    goto _jump41;
    bool _102 = false;
    _100 = _102;
    _jump41:;
    bool _103;
    if (!_100)
    goto _jump42;
    bool _104 = false;
    bool _105 = !_104;
    _103 = _105;
    goto _jump43;
    _jump42:;
    bool _106 = false;
    _103 = _106;
    _jump43:;
    int64_t _107;
    if (!_103)
    goto _jump44;
    int64_t _108 = 92;
    int64_t _109 = -_108;
    _107 = _109;
    goto _jump45;
    _jump44:;
    int64_t _110;
    // Computing bound for a
    int64_t _111 = 284;
    int64_t _112 = 428;
    int64_t _113 = _111 + _112;
    if (_113 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    // Computing bound for b
    int64_t _114;
    // Computing bound for a
    int64_t _115 = 689;
    if (_115 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    _114 = 0;
    int64_t _116 = 0; // a
    _jump48:; // Begin body of loop
    _114 += _116;
    _116++;
    if (_116 < _115)
    goto _jump48;
    // End body of loop
    if (_114 > 0) 
    goto _jump49;
    fail_assertion("non-positive loop bound");
    _jump49:;
    _110 = 0;
    int64_t _117 = 0; // b
    int64_t _118 = 0; // a
    _jump50:; // Begin body of loop
    _110 += _117;
    _117++;
    if (_117 < _114)
    goto _jump50;
    _117 = 0;
    _118++;
    if (_118 < _113)
    goto _jump50;
    // End body of loop
    _107 = _110;
    _jump45:;
    int64_t _119 = _99 - _107;
    _84 = _119;
    _jump38:;
    if (_84 >= 0)
    goto _jump51;
    fail_assertion("negative array index");
    _jump51:;
    if (_84 < _32.d0)
    goto _jump52;
    fail_assertion("index too large");
    _jump52:;
    int64_t _120 = 0;
    _120 *= _32.d0;
    _120 += _84;
    bool _121 = _32.data[_120];
    _a2_rgba _122;
    if (!_121)
    goto _jump53;
    _a3_bool _123;
    // Computing bound for a
    int64_t _124 = 426;
    _123.d0 = _124;
    if (_124 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for b
    int64_t _125 = 26;
    _123.d1 = _125;
    if (_125 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    // Computing bound for c
    int64_t _126 = 2;
    _123.d2 = _126;
    if (_126 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= _124;
    _127 *= _125;
    _127 *= _126;
    _127 *= sizeof(bool);
    _123.data = jpl_alloc(_127);
    int64_t _128 = 0; // c
    int64_t _129 = 0; // b
    int64_t _130 = 0; // a
    _jump57:; // Begin body of loop
    bool _131 = true;
    int64_t _132 = 0;
    _132 *= _123.d0;
    _132 += _130;
    _132 *= _123.d1;
    _132 += _129;
    _132 *= _123.d2;
    _132 += _128;
    _123.data[_132] = _131;
    _128++;
    if (_128 < _126)
    goto _jump57;
    _128 = 0;
    _129++;
    if (_129 < _125)
    goto _jump57;
    _129 = 0;
    _130++;
    if (_130 < _124)
    goto _jump57;
    // End body of loop
    _a1__a3_bool _133;
    _133.d0 = 1;
    _133.data = jpl_alloc(sizeof(_a3_bool) * 1);
    _133.data[0] = _123;
    int64_t _134;
    // Computing bound for a
    int64_t _135 = 263;
    int64_t _136 = -_135;
    if (_136 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    _134 = 0;
    int64_t _137 = 0; // a
    _jump59:; // Begin body of loop
    _134 += _137;
    _137++;
    if (_137 < _136)
    goto _jump59;
    // End body of loop
    if (_134 >= 0)
    goto _jump60;
    fail_assertion("negative array index");
    _jump60:;
    if (_134 < _133.d0)
    goto _jump61;
    fail_assertion("index too large");
    _jump61:;
    int64_t _138 = 0;
    _138 *= _133.d0;
    _138 += _134;
    _a3_bool _139 = _133.data[_138];
    int64_t _140 = 998;
    int64_t _141 = -_140;
    int64_t _142;
    // Computing bound for a
    int64_t _143 = 495;
    int64_t _144 = -_143;
    if (_144 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    _142 = 0;
    int64_t _145 = 0; // a
    _jump63:; // Begin body of loop
    int64_t _146 = 497;
    _142 += _146;
    _145++;
    if (_145 < _144)
    goto _jump63;
    // End body of loop
    int64_t _147 = 648;
    int64_t _148 = 753;
    int64_t _149 = -_148;
    int64_t _150 = _147 % _149;
    int64_t _151 = _142 % _150;
    bool _152 = false;
    bool _153 = !_152;
    int64_t _154;
    if (!_153)
    goto _jump64;
    int64_t _155 = 421;
    _154 = _155;
    goto _jump65;
    _jump64:;
    int64_t _156 = 35;
    _154 = _156;
    _jump65:;
    int64_t _157 = -_154;
    if (_141 >= 0)
    goto _jump66;
    fail_assertion("negative array index");
    _jump66:;
    if (_141 < _139.d0)
    goto _jump67;
    fail_assertion("index too large");
    _jump67:;
    if (_151 >= 0)
    goto _jump68;
    fail_assertion("negative array index");
    _jump68:;
    if (_151 < _139.d1)
    goto _jump69;
    fail_assertion("index too large");
    _jump69:;
    if (_157 >= 0)
    goto _jump70;
    fail_assertion("negative array index");
    _jump70:;
    if (_157 < _139.d2)
    goto _jump71;
    fail_assertion("index too large");
    _jump71:;
    int64_t _158 = 0;
    _158 *= _139.d0;
    _158 += _141;
    _158 *= _139.d1;
    _158 += _151;
    _158 *= _139.d2;
    _158 += _157;
    bool _159 = _139.data[_158];
    bool _160 = !_159;
    _a2_rgba _161;
    if (!_160)
    goto _jump72;
    _a2_rgba _162;
    // Computing bound for a
    int64_t _163 = 913;
    _162.d0 = _163;
    if (_163 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing bound for b
    int64_t _164;
    // Computing bound for a
    bool _165 = true;
    bool _166 = !_165;
    int64_t _167;
    if (!_166)
    goto _jump74;
    int64_t _168 = 925;
    int64_t _169 = -_168;
    int64_t _170 = 0;
    int64_t _171 = _169 + _170;
    _167 = _171;
    goto _jump75;
    _jump74:;
    int64_t _172;
    // Computing bound for a
    int64_t _173 = 988;
    if (_173 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for b
    int64_t _174 = 593;
    if (_174 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    _172 = 0;
    int64_t _175 = 0; // b
    int64_t _176 = 0; // a
    _jump78:; // Begin body of loop
    int64_t _177 = 763;
    int64_t _178 = _175 - _177;
    _172 += _178;
    _175++;
    if (_175 < _174)
    goto _jump78;
    _175 = 0;
    _176++;
    if (_176 < _173)
    goto _jump78;
    // End body of loop
    _167 = _172;
    _jump75:;
    if (_167 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing bound for b
    double _179 = 30.0;
    double _180 = 33.0;
    bool _181 = _179 <= _180;
    int64_t _182;
    if (!_181)
    goto _jump80;
    int64_t _183 = 124;
    _182 = _183;
    goto _jump81;
    _jump80:;
    int64_t _184 = 98;
    _182 = _184;
    _jump81:;
    int64_t _185;
    // Computing bound for a
    int64_t _186;
    // Computing bound for a
    int64_t _187 = 282;
    if (_187 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing bound for b
    int64_t _188 = 438;
    if (_188 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    _186 = 0;
    int64_t _189 = 0; // b
    int64_t _190 = 0; // a
    _jump84:; // Begin body of loop
    int64_t _191 = 554;
    _186 += _191;
    _189++;
    if (_189 < _188)
    goto _jump84;
    _189 = 0;
    _190++;
    if (_190 < _187)
    goto _jump84;
    // End body of loop
    if (_186 > 0) 
    goto _jump85;
    fail_assertion("non-positive loop bound");
    _jump85:;
    // Computing bound for b
    int64_t _192 = 225;
    if (_192 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    _185 = 0;
    int64_t _193 = 0; // b
    int64_t _194 = 0; // a
    _jump87:; // Begin body of loop
    int64_t _195 = -_194;
    _185 += _195;
    _193++;
    if (_193 < _192)
    goto _jump87;
    _193 = 0;
    _194++;
    if (_194 < _186)
    goto _jump87;
    // End body of loop
    int64_t _196 = _182 + _185;
    if (_196 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    _164 = 0;
    int64_t _197 = 0; // b
    int64_t _198 = 0; // a
    _jump89:; // Begin body of loop
    int64_t _199;
    // Computing bound for c
    if (_197 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing bound for d
    if (_197 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for e
    if (_197 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    _199 = 0;
    int64_t _200 = 0; // e
    int64_t _201 = 0; // d
    int64_t _202 = 0; // c
    _jump93:; // Begin body of loop
    _199 += _197;
    _200++;
    if (_200 < _197)
    goto _jump93;
    _200 = 0;
    _201++;
    if (_201 < _197)
    goto _jump93;
    _201 = 0;
    _202++;
    if (_202 < _197)
    goto _jump93;
    // End body of loop
    _a1_int64_t _203;
    _203.d0 = 3;
    _203.data = jpl_alloc(sizeof(int64_t) * 3);
    _203.data[0] = _197;
    _203.data[1] = _199;
    _203.data[2] = _197;
    if (_198 >= 0)
    goto _jump94;
    fail_assertion("negative array index");
    _jump94:;
    if (_198 < _203.d0)
    goto _jump95;
    fail_assertion("index too large");
    _jump95:;
    int64_t _204 = 0;
    _204 *= _203.d0;
    _204 += _198;
    int64_t _205 = _203.data[_204];
    _164 += _205;
    _197++;
    if (_197 < _196)
    goto _jump89;
    _197 = 0;
    _198++;
    if (_198 < _167)
    goto _jump89;
    // End body of loop
    _162.d1 = _164;
    if (_164 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= _163;
    _206 *= _164;
    _206 *= sizeof(rgba);
    _162.data = jpl_alloc(_206);
    int64_t _207 = 0; // b
    int64_t _208 = 0; // a
    _jump97:; // Begin body of loop
    _a2_rgba _209;
    // Computing bound for c
    _209.d0 = _207;
    if (_207 > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    // Computing bound for d
    int64_t _210 = -_207;
    _209.d1 = _210;
    if (_210 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= _207;
    _211 *= _210;
    _211 *= sizeof(rgba);
    _209.data = jpl_alloc(_211);
    int64_t _212 = 0; // d
    int64_t _213 = 0; // c
    _jump100:; // Begin body of loop
    double _214;
    // Computing bound for e
    int64_t _215 = 10;
    if (_215 > 0) 
    goto _jump101;
    fail_assertion("non-positive loop bound");
    _jump101:;
    // Computing bound for f
    if (_212 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    // Computing bound for g
    if (_208 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    _214 = 0;
    int64_t _216 = 0; // g
    int64_t _217 = 0; // f
    int64_t _218 = 0; // e
    _jump104:; // Begin body of loop
    double _219 = 88.0;
    _214 += _219;
    _216++;
    if (_216 < _208)
    goto _jump104;
    _216 = 0;
    _217++;
    if (_217 < _212)
    goto _jump104;
    _217 = 0;
    _218++;
    if (_218 < _215)
    goto _jump104;
    // End body of loop
    double _220 = 77.0;
    double _221 = 26.0;
    double _222 = 4.0;
    double _223 = fmod(_221, _222);
    double _224 = 78.0;
    rgba _225 = { _214, _220, _223, _224 };
    int64_t _226 = 0;
    _226 *= _209.d0;
    _226 += _213;
    _226 *= _209.d1;
    _226 += _212;
    _209.data[_226] = _225;
    _212++;
    if (_212 < _210)
    goto _jump100;
    _212 = 0;
    _213++;
    if (_213 < _207)
    goto _jump100;
    // End body of loop
    if (_207 >= 0)
    goto _jump105;
    fail_assertion("negative array index");
    _jump105:;
    if (_207 < _209.d0)
    goto _jump106;
    fail_assertion("index too large");
    _jump106:;
    if (_207 >= 0)
    goto _jump107;
    fail_assertion("negative array index");
    _jump107:;
    if (_207 < _209.d1)
    goto _jump108;
    fail_assertion("index too large");
    _jump108:;
    int64_t _227 = 0;
    _227 *= _209.d0;
    _227 += _207;
    _227 *= _209.d1;
    _227 += _207;
    rgba _228 = _209.data[_227];
    int64_t _229 = 0;
    _229 *= _162.d0;
    _229 += _208;
    _229 *= _162.d1;
    _229 += _207;
    _162.data[_229] = _228;
    _207++;
    if (_207 < _164)
    goto _jump97;
    _207 = 0;
    _208++;
    if (_208 < _163)
    goto _jump97;
    // End body of loop
    _161 = _162;
    goto _jump109;
    _jump72:;
    _a2__a2_rgba _230;
    // Computing bound for a
    bool _231 = false;
    bool _232 = !_231;
    bool _233 = !_232;
    int64_t _234;
    if (!_233)
    goto _jump110;
    int64_t _235 = 627;
    int64_t _236 = -_235;
    int64_t _237 = 382;
    int64_t _238 = _236 + _237;
    _234 = _238;
    goto _jump111;
    _jump110:;
    int64_t _239;
    // Computing bound for a
    int64_t _240 = 909;
    if (_240 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing bound for b
    int64_t _241 = 42;
    if (_241 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    _239 = 0;
    int64_t _242 = 0; // b
    int64_t _243 = 0; // a
    _jump114:; // Begin body of loop
    int64_t _244 = -_243;
    _239 += _244;
    _242++;
    if (_242 < _241)
    goto _jump114;
    _242 = 0;
    _243++;
    if (_243 < _240)
    goto _jump114;
    // End body of loop
    _234 = _239;
    _jump111:;
    _230.d0 = _234;
    if (_234 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing bound for b
    int64_t _245 = 49;
    int64_t _246 = -_245;
    int64_t _247 = -_246;
    _230.d1 = _247;
    if (_247 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= _234;
    _248 *= _247;
    _248 *= sizeof(_a2_rgba);
    _230.data = jpl_alloc(_248);
    int64_t _249 = 0; // b
    int64_t _250 = 0; // a
    _jump117:; // Begin body of loop
    _a2_rgba _251;
    // Computing bound for c
    int64_t _252;
    // Computing bound for c
    if (_250 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    // Computing bound for d
    int64_t _253 = 718;
    if (_253 > 0) 
    goto _jump119;
    fail_assertion("non-positive loop bound");
    _jump119:;
    // Computing bound for e
    int64_t _254 = 402;
    if (_254 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    _252 = 0;
    int64_t _255 = 0; // e
    int64_t _256 = 0; // d
    int64_t _257 = 0; // c
    _jump121:; // Begin body of loop
    int64_t _258 = 542;
    _252 += _258;
    _255++;
    if (_255 < _254)
    goto _jump121;
    _255 = 0;
    _256++;
    if (_256 < _253)
    goto _jump121;
    _256 = 0;
    _257++;
    if (_257 < _250)
    goto _jump121;
    // End body of loop
    _251.d0 = _252;
    if (_252 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing bound for d
    double _259 = 85.0;
    double _260 = 27.0;
    bool _261 = _259 >= _260;
    int64_t _262;
    if (!_261)
    goto _jump123;
    _262 = _250;
    goto _jump124;
    _jump123:;
    _262 = _249;
    _jump124:;
    _251.d1 = _262;
    if (_262 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _252;
    _263 *= _262;
    _263 *= sizeof(rgba);
    _251.data = jpl_alloc(_263);
    int64_t _264 = 0; // d
    int64_t _265 = 0; // c
    _jump126:; // Begin body of loop
    double _266 = 76.0;
    double _267;
    // Computing bound for e
    if (_250 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for f
    if (_249 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    _267 = 0;
    int64_t _268 = 0; // f
    int64_t _269 = 0; // e
    _jump129:; // Begin body of loop
    double _270 = 15.0;
    _267 += _270;
    _268++;
    if (_268 < _249)
    goto _jump129;
    _268 = 0;
    _269++;
    if (_269 < _250)
    goto _jump129;
    // End body of loop
    double _271 = 85.0;
    double _272 = 98.0;
    double _273 = _271 * _272;
    double _274 = 90.0;
    rgba _275 = { _266, _267, _273, _274 };
    int64_t _276 = 0;
    _276 *= _251.d0;
    _276 += _265;
    _276 *= _251.d1;
    _276 += _264;
    _251.data[_276] = _275;
    _264++;
    if (_264 < _262)
    goto _jump126;
    _264 = 0;
    _265++;
    if (_265 < _252)
    goto _jump126;
    // End body of loop
    int64_t _277 = 0;
    _277 *= _230.d0;
    _277 += _250;
    _277 *= _230.d1;
    _277 += _249;
    _230.data[_277] = _251;
    _249++;
    if (_249 < _247)
    goto _jump117;
    _249 = 0;
    _250++;
    if (_250 < _234)
    goto _jump117;
    // End body of loop
    int64_t _278;
    // Computing bound for a
    int64_t _279 = 611;
    int64_t _280 = 658;
    int64_t _281 = _279 % _280;
    if (_281 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for b
    int64_t _282 = 886;
    int64_t _283 = 804;
    int64_t _284 = _282 + _283;
    int64_t _285 = -_284;
    if (_285 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    _278 = 0;
    int64_t _286 = 0; // b
    int64_t _287 = 0; // a
    _jump132:; // Begin body of loop
    int64_t _288 = -_286;
    int64_t _289 = _286 + _288;
    _278 += _289;
    _286++;
    if (_286 < _285)
    goto _jump132;
    _286 = 0;
    _287++;
    if (_287 < _281)
    goto _jump132;
    // End body of loop
    int64_t _290 = 713;
    int64_t _291 = -_290;
    int64_t _292 = -_291;
    if (_278 >= 0)
    goto _jump133;
    fail_assertion("negative array index");
    _jump133:;
    if (_278 < _230.d0)
    goto _jump134;
    fail_assertion("index too large");
    _jump134:;
    if (_292 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_292 < _230.d1)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    int64_t _293 = 0;
    _293 *= _230.d0;
    _293 += _278;
    _293 *= _230.d1;
    _293 += _292;
    _a2_rgba _294 = _230.data[_293];
    _161 = _294;
    _jump109:;
    _122 = _161;
    goto _jump137;
    _jump53:;
    _a3__a2_rgba _295;
    // Computing bound for a
    int64_t _296;
    // Computing bound for a
    int64_t _297 = 713;
    if (_297 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    // Computing bound for b
    int64_t _298 = 744;
    if (_298 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    _296 = 0;
    int64_t _299 = 0; // b
    int64_t _300 = 0; // a
    _jump140:; // Begin body of loop
    int64_t _301 = 520;
    _296 += _301;
    _299++;
    if (_299 < _298)
    goto _jump140;
    _299 = 0;
    _300++;
    if (_300 < _297)
    goto _jump140;
    // End body of loop
    _a2_int64_t _302;
    // Computing bound for a
    int64_t _303 = 340;
    _302.d0 = _303;
    if (_303 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    // Computing bound for b
    int64_t _304 = 33;
    _302.d1 = _304;
    if (_304 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    // Computing total size of heap memory to allocate
    int64_t _305 = 1;
    _305 *= _303;
    _305 *= _304;
    _305 *= sizeof(int64_t);
    _302.data = jpl_alloc(_305);
    int64_t _306 = 0; // b
    int64_t _307 = 0; // a
    _jump143:; // Begin body of loop
    int64_t _308 = 0;
    _308 *= _302.d0;
    _308 += _307;
    _308 *= _302.d1;
    _308 += _306;
    _302.data[_308] = _307;
    _306++;
    if (_306 < _304)
    goto _jump143;
    _306 = 0;
    _307++;
    if (_307 < _303)
    goto _jump143;
    // End body of loop
    int64_t _309 = 236;
    int64_t _310 = 765;
    if (_309 >= 0)
    goto _jump144;
    fail_assertion("negative array index");
    _jump144:;
    if (_309 < _302.d0)
    goto _jump145;
    fail_assertion("index too large");
    _jump145:;
    if (_310 >= 0)
    goto _jump146;
    fail_assertion("negative array index");
    _jump146:;
    if (_310 < _302.d1)
    goto _jump147;
    fail_assertion("index too large");
    _jump147:;
    int64_t _311 = 0;
    _311 *= _302.d0;
    _311 += _309;
    _311 *= _302.d1;
    _311 += _310;
    int64_t _312 = _302.data[_311];
    int64_t _313 = _296 + _312;
    _295.d0 = _313;
    if (_313 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    // Computing bound for b
    int64_t _314;
    // Computing bound for a
    int64_t _315;
    // Computing bound for a
    int64_t _316 = 987;
    int64_t _317 = 599;
    int64_t _318 = -_317;
    int64_t _319 = _316 / _318;
    if (_319 > 0) 
    goto _jump149;
    fail_assertion("non-positive loop bound");
    _jump149:;
    // Computing bound for b
    int64_t _320 = 936;
    int64_t _321 = -_320;
    int64_t _322 = -_321;
    if (_322 > 0) 
    goto _jump150;
    fail_assertion("non-positive loop bound");
    _jump150:;
    _315 = 0;
    int64_t _323 = 0; // b
    int64_t _324 = 0; // a
    _jump151:; // Begin body of loop
    int64_t _325 = 946;
    int64_t _326 = 338;
    int64_t _327 = _325 / _326;
    int64_t _328 = 353;
    int64_t _329 = -_328;
    int64_t _330 = _327 % _329;
    _315 += _330;
    _323++;
    if (_323 < _322)
    goto _jump151;
    _323 = 0;
    _324++;
    if (_324 < _319)
    goto _jump151;
    // End body of loop
    if (_315 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    _314 = 0;
    int64_t _331 = 0; // a
    _jump153:; // Begin body of loop
    int64_t _332;
    // Computing bound for b
    int64_t _333 = 696;
    if (_333 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for c
    if (_331 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    _332 = 0;
    int64_t _334 = 0; // c
    int64_t _335 = 0; // b
    _jump156:; // Begin body of loop
    int64_t _336;
    // Computing bound for d
    if (_335 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing bound for e
    if (_334 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    // Computing bound for f
    if (_331 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    _336 = 0;
    int64_t _337 = 0; // f
    int64_t _338 = 0; // e
    int64_t _339 = 0; // d
    _jump160:; // Begin body of loop
    _336 += _337;
    _337++;
    if (_337 < _331)
    goto _jump160;
    _337 = 0;
    _338++;
    if (_338 < _334)
    goto _jump160;
    _338 = 0;
    _339++;
    if (_339 < _335)
    goto _jump160;
    // End body of loop
    _332 += _336;
    _334++;
    if (_334 < _331)
    goto _jump156;
    _334 = 0;
    _335++;
    if (_335 < _333)
    goto _jump156;
    // End body of loop
    int64_t _340 = _332 + _331;
    _314 += _340;
    _331++;
    if (_331 < _315)
    goto _jump153;
    // End body of loop
    _295.d1 = _314;
    if (_314 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for c
    int64_t _341;
    // Computing bound for a
    bool _342 = true;
    bool _343;
    if (!_342)
    goto _jump162;
    bool _344 = true;
    _343 = _344;
    goto _jump163;
    _jump162:;
    bool _345 = true;
    _343 = _345;
    _jump163:;
    int64_t _346;
    if (!_343)
    goto _jump164;
    int64_t _347 = 636;
    _346 = _347;
    goto _jump165;
    _jump164:;
    bool _348 = true;
    int64_t _349;
    if (!_348)
    goto _jump166;
    int64_t _350 = 739;
    int64_t _351 = -_350;
    _349 = _351;
    goto _jump167;
    _jump166:;
    int64_t _352 = 695;
    _349 = _352;
    _jump167:;
    _346 = _349;
    _jump165:;
    if (_346 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    _341 = 0;
    int64_t _353 = 0; // a
    _jump169:; // Begin body of loop
    int64_t _354 = 71;
    int64_t _355 = 936;
    int64_t _356 = 66;
    int64_t _357 = _355 % _356;
    int64_t _358 = _354 % _357;
    _341 += _358;
    _353++;
    if (_353 < _346)
    goto _jump169;
    // End body of loop
    _295.d2 = _341;
    if (_341 > 0) 
    goto _jump170;
    fail_assertion("non-positive loop bound");
    _jump170:;
    // Computing total size of heap memory to allocate
    int64_t _359 = 1;
    _359 *= _313;
    _359 *= _314;
    _359 *= _341;
    _359 *= sizeof(_a2_rgba);
    _295.data = jpl_alloc(_359);
    int64_t _360 = 0; // c
    int64_t _361 = 0; // b
    int64_t _362 = 0; // a
    _jump171:; // Begin body of loop
    _a2_rgba _363;
    // Computing bound for d
    _a2_int64_t _364;
    // Computing bound for d
    bool _365 = true;
    int64_t _366;
    if (!_365)
    goto _jump172;
    _366 = _360;
    goto _jump173;
    _jump172:;
    int64_t _367 = 430;
    _366 = _367;
    _jump173:;
    _364.d0 = _366;
    if (_366 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    // Computing bound for e
    int64_t _368 = 300;
    _364.d1 = _368;
    if (_368 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing total size of heap memory to allocate
    int64_t _369 = 1;
    _369 *= _366;
    _369 *= _368;
    _369 *= sizeof(int64_t);
    _364.data = jpl_alloc(_369);
    int64_t _370 = 0; // e
    int64_t _371 = 0; // d
    _jump176:; // Begin body of loop
    int64_t _372 = 12;
    int64_t _373 = 0;
    _373 *= _364.d0;
    _373 += _371;
    _373 *= _364.d1;
    _373 += _370;
    _364.data[_373] = _372;
    _370++;
    if (_370 < _368)
    goto _jump176;
    _370 = 0;
    _371++;
    if (_371 < _366)
    goto _jump176;
    // End body of loop
    int64_t _374 = 468;
    int64_t _375 = _362 % _374;
    int64_t _376 = 668;
    if (_375 >= 0)
    goto _jump177;
    fail_assertion("negative array index");
    _jump177:;
    if (_375 < _364.d0)
    goto _jump178;
    fail_assertion("index too large");
    _jump178:;
    if (_376 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_376 < _364.d1)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    int64_t _377 = 0;
    _377 *= _364.d0;
    _377 += _375;
    _377 *= _364.d1;
    _377 += _376;
    int64_t _378 = _364.data[_377];
    _363.d0 = _378;
    if (_378 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing bound for e
    bool _379 = _361 == _361;
    int64_t _380;
    if (!_379)
    goto _jump182;
    _380 = _362;
    goto _jump183;
    _jump182:;
    int64_t _381 = 260;
    int64_t _382 = -_381;
    _380 = _382;
    _jump183:;
    int64_t _383 = _380 + _360;
    _363.d1 = _383;
    if (_383 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing total size of heap memory to allocate
    int64_t _384 = 1;
    _384 *= _378;
    _384 *= _383;
    _384 *= sizeof(rgba);
    _363.data = jpl_alloc(_384);
    int64_t _385 = 0; // e
    int64_t _386 = 0; // d
    _jump185:; // Begin body of loop
    _a1_rgba _387;
    // Computing bound for f
    int64_t _388 = _361 + _362;
    _387.d0 = _388;
    if (_388 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _388;
    _389 *= sizeof(rgba);
    _387.data = jpl_alloc(_389);
    int64_t _390 = 0; // f
    _jump187:; // Begin body of loop
    double _391 = 84.0;
    double _392 = 18.0;
    double _393 = 42.0;
    double _394 = 18.0;
    rgba _395 = { _391, _392, _393, _394 };
    int64_t _396 = 0;
    _396 *= _387.d0;
    _396 += _390;
    _387.data[_396] = _395;
    _390++;
    if (_390 < _388)
    goto _jump187;
    // End body of loop
    if (_360 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_360 < _387.d0)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    int64_t _397 = 0;
    _397 *= _387.d0;
    _397 += _360;
    rgba _398 = _387.data[_397];
    int64_t _399 = 0;
    _399 *= _363.d0;
    _399 += _386;
    _399 *= _363.d1;
    _399 += _385;
    _363.data[_399] = _398;
    _385++;
    if (_385 < _383)
    goto _jump185;
    _385 = 0;
    _386++;
    if (_386 < _378)
    goto _jump185;
    // End body of loop
    int64_t _400 = 0;
    _400 *= _295.d0;
    _400 += _362;
    _400 *= _295.d1;
    _400 += _361;
    _400 *= _295.d2;
    _400 += _360;
    _295.data[_400] = _363;
    _360++;
    if (_360 < _341)
    goto _jump171;
    _360 = 0;
    _361++;
    if (_361 < _314)
    goto _jump171;
    _361 = 0;
    _362++;
    if (_362 < _313)
    goto _jump171;
    // End body of loop
    int64_t _401;
    // Computing bound for a
    int64_t _402 = 595;
    int64_t _403 = -_402;
    if (_403 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing bound for b
    bool _405 = true;
    bool _404 = _405;
    if (0 == _405)
    goto _jump191;
    double _406 = 0.0;
    double _407 = 83.0;
    bool _408 = _406 >= _407;
    _404 = _408;
    _jump191:;
    int64_t _409;
    if (!_404)
    goto _jump192;
    int64_t _410 = 614;
    int64_t _411 = 712;
    int64_t _412 = _410 % _411;
    bool _413 = false;
    int64_t _414;
    if (!_413)
    goto _jump193;
    int64_t _415 = 293;
    _414 = _415;
    goto _jump194;
    _jump193:;
    int64_t _416 = 780;
    _414 = _416;
    _jump194:;
    int64_t _417 = _412 + _414;
    _409 = _417;
    goto _jump195;
    _jump192:;
    bool _418 = true;
    int64_t _419;
    if (!_418)
    goto _jump196;
    int64_t _420 = 907;
    _419 = _420;
    goto _jump197;
    _jump196:;
    int64_t _421 = 664;
    _419 = _421;
    _jump197:;
    _409 = _419;
    _jump195:;
    if (_409 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing bound for c
    int64_t _422 = 30;
    int64_t _423 = 252;
    int64_t _424 = _422 + _423;
    if (_424 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    _401 = 0;
    int64_t _425 = 0; // c
    int64_t _426 = 0; // b
    int64_t _427 = 0; // a
    _jump200:; // Begin body of loop
    int64_t _428 = 471;
    _401 += _428;
    _425++;
    if (_425 < _424)
    goto _jump200;
    _425 = 0;
    _426++;
    if (_426 < _409)
    goto _jump200;
    _426 = 0;
    _427++;
    if (_427 < _403)
    goto _jump200;
    // End body of loop
    int64_t _429 = -_401;
    int64_t _430 = 986;
    int64_t _431 = -_430;
    int64_t _432 = 214;
    int64_t _433 = _431 - _432;
    int64_t _434 = -_433;
    int64_t _435;
    // Computing bound for a
    bool _437 = true;
    bool _436 = _437;
    if (0 == _437)
    goto _jump201;
    bool _438 = false;
    _436 = _438;
    _jump201:;
    int64_t _439;
    if (!_436)
    goto _jump202;
    int64_t _440 = 964;
    int64_t _441 = -_440;
    int64_t _442 = 890;
    int64_t _443 = 71;
    int64_t _444 = _442 % _443;
    int64_t _445 = _441 * _444;
    _439 = _445;
    goto _jump203;
    _jump202:;
    int64_t _446 = 361;
    int64_t _447 = -_446;
    _439 = _447;
    _jump203:;
    if (_439 > 0) 
    goto _jump204;
    fail_assertion("non-positive loop bound");
    _jump204:;
    // Computing bound for b
    int64_t _448;
    // Computing bound for a
    int64_t _449 = 373;
    int64_t _450 = 381;
    int64_t _451 = _449 % _450;
    if (_451 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing bound for b
    int64_t _452 = 451;
    if (_452 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    _448 = 0;
    int64_t _453 = 0; // b
    int64_t _454 = 0; // a
    _jump207:; // Begin body of loop
    bool _456 = true;
    bool _455 = _456;
    if (0 == _456)
    goto _jump208;
    bool _457 = false;
    _455 = _457;
    _jump208:;
    int64_t _458;
    if (!_455)
    goto _jump209;
    int64_t _459;
    // Computing bound for c
    int64_t _460 = 246;
    if (_460 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for d
    if (_454 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for e
    int64_t _461 = 39;
    if (_461 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    _459 = 0;
    int64_t _462 = 0; // e
    int64_t _463 = 0; // d
    int64_t _464 = 0; // c
    _jump213:; // Begin body of loop
    _459 += _462;
    _462++;
    if (_462 < _461)
    goto _jump213;
    _462 = 0;
    _463++;
    if (_463 < _454)
    goto _jump213;
    _463 = 0;
    _464++;
    if (_464 < _460)
    goto _jump213;
    // End body of loop
    _458 = _459;
    goto _jump214;
    _jump209:;
    int64_t _465 = 505;
    int64_t _466 = -_465;
    _458 = _466;
    _jump214:;
    _448 += _458;
    _453++;
    if (_453 < _452)
    goto _jump207;
    _453 = 0;
    _454++;
    if (_454 < _451)
    goto _jump207;
    // End body of loop
    if (_448 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing bound for c
    int64_t _467 = 105;
    if (_467 > 0) 
    goto _jump216;
    fail_assertion("non-positive loop bound");
    _jump216:;
    _435 = 0;
    int64_t _468 = 0; // c
    int64_t _469 = 0; // b
    int64_t _470 = 0; // a
    _jump217:; // Begin body of loop
    int64_t _471 = -_468;
    _435 += _471;
    _468++;
    if (_468 < _467)
    goto _jump217;
    _468 = 0;
    _469++;
    if (_469 < _448)
    goto _jump217;
    _469 = 0;
    _470++;
    if (_470 < _439)
    goto _jump217;
    // End body of loop
    int64_t _472 = _434 % _435;
    int64_t _473 = 487;
    if (_429 >= 0)
    goto _jump218;
    fail_assertion("negative array index");
    _jump218:;
    if (_429 < _295.d0)
    goto _jump219;
    fail_assertion("index too large");
    _jump219:;
    if (_472 >= 0)
    goto _jump220;
    fail_assertion("negative array index");
    _jump220:;
    if (_472 < _295.d1)
    goto _jump221;
    fail_assertion("index too large");
    _jump221:;
    if (_473 >= 0)
    goto _jump222;
    fail_assertion("negative array index");
    _jump222:;
    if (_473 < _295.d2)
    goto _jump223;
    fail_assertion("index too large");
    _jump223:;
    int64_t _474 = 0;
    _474 *= _295.d0;
    _474 += _429;
    _474 *= _295.d1;
    _474 += _472;
    _474 *= _295.d2;
    _474 += _473;
    _a2_rgba _475 = _295.data[_474];
    _122 = _475;
    _jump137:;
    write_image(_122, "a.png");
    _a3_bool _476;
    // Computing bound for a
    _a3_int64_t _478;
    // Computing bound for a
    int64_t _479 = 672;
    _478.d0 = _479;
    if (_479 > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    // Computing bound for b
    int64_t _480 = 196;
    int64_t _481 = -_480;
    _478.d1 = _481;
    if (_481 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for c
    int64_t _482 = 313;
    int64_t _483 = -_482;
    _478.d2 = _483;
    if (_483 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing total size of heap memory to allocate
    int64_t _484 = 1;
    _484 *= _479;
    _484 *= _481;
    _484 *= _483;
    _484 *= sizeof(int64_t);
    _478.data = jpl_alloc(_484);
    int64_t _485 = 0; // c
    int64_t _486 = 0; // b
    int64_t _487 = 0; // a
    _jump227:; // Begin body of loop
    int64_t _488 = 0;
    _488 *= _478.d0;
    _488 += _487;
    _488 *= _478.d1;
    _488 += _486;
    _488 *= _478.d2;
    _488 += _485;
    _478.data[_488] = _487;
    _485++;
    if (_485 < _483)
    goto _jump227;
    _485 = 0;
    _486++;
    if (_486 < _481)
    goto _jump227;
    _486 = 0;
    _487++;
    if (_487 < _479)
    goto _jump227;
    // End body of loop
    int64_t _489 = 255;
    int64_t _490 = -_489;
    int64_t _491 = 938;
    int64_t _492 = 878;
    if (_490 >= 0)
    goto _jump228;
    fail_assertion("negative array index");
    _jump228:;
    if (_490 < _478.d0)
    goto _jump229;
    fail_assertion("index too large");
    _jump229:;
    if (_491 >= 0)
    goto _jump230;
    fail_assertion("negative array index");
    _jump230:;
    if (_491 < _478.d1)
    goto _jump231;
    fail_assertion("index too large");
    _jump231:;
    if (_492 >= 0)
    goto _jump232;
    fail_assertion("negative array index");
    _jump232:;
    if (_492 < _478.d2)
    goto _jump233;
    fail_assertion("index too large");
    _jump233:;
    int64_t _493 = 0;
    _493 *= _478.d0;
    _493 += _490;
    _493 *= _478.d1;
    _493 += _491;
    _493 *= _478.d2;
    _493 += _492;
    int64_t _494 = _478.data[_493];
    int64_t _495 = 58;
    int64_t _496 = -_495;
    bool _497 = _494 < _496;
    bool _477 = _497;
    if (0 == _497)
    goto _jump234;
    _a3_bool _498;
    // Computing bound for a
    int64_t _499 = 731;
    _498.d0 = _499;
    if (_499 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing bound for b
    int64_t _500 = 408;
    _498.d1 = _500;
    if (_500 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing bound for c
    int64_t _501 = 764;
    _498.d2 = _501;
    if (_501 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing total size of heap memory to allocate
    int64_t _502 = 1;
    _502 *= _499;
    _502 *= _500;
    _502 *= _501;
    _502 *= sizeof(bool);
    _498.data = jpl_alloc(_502);
    int64_t _503 = 0; // c
    int64_t _504 = 0; // b
    int64_t _505 = 0; // a
    _jump238:; // Begin body of loop
    bool _506 = true;
    int64_t _507 = 0;
    _507 *= _498.d0;
    _507 += _505;
    _507 *= _498.d1;
    _507 += _504;
    _507 *= _498.d2;
    _507 += _503;
    _498.data[_507] = _506;
    _503++;
    if (_503 < _501)
    goto _jump238;
    _503 = 0;
    _504++;
    if (_504 < _500)
    goto _jump238;
    _504 = 0;
    _505++;
    if (_505 < _499)
    goto _jump238;
    // End body of loop
    int64_t _508 = 487;
    int64_t _509 = -_508;
    int64_t _510 = 25;
    int64_t _511 = -_510;
    int64_t _512 = 939;
    if (_509 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (_509 < _498.d0)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    if (_511 >= 0)
    goto _jump241;
    fail_assertion("negative array index");
    _jump241:;
    if (_511 < _498.d1)
    goto _jump242;
    fail_assertion("index too large");
    _jump242:;
    if (_512 >= 0)
    goto _jump243;
    fail_assertion("negative array index");
    _jump243:;
    if (_512 < _498.d2)
    goto _jump244;
    fail_assertion("index too large");
    _jump244:;
    int64_t _513 = 0;
    _513 *= _498.d0;
    _513 += _509;
    _513 *= _498.d1;
    _513 += _511;
    _513 *= _498.d2;
    _513 += _512;
    bool _514 = _498.data[_513];
    bool _515 = !_514;
    bool _516;
    if (!_515)
    goto _jump245;
    int64_t _518 = 860;
    int64_t _519 = 316;
    bool _520 = _518 < _519;
    bool _517 = _520;
    if (0 == _520)
    goto _jump246;
    bool _521 = false;
    _517 = _521;
    _jump246:;
    _516 = _517;
    goto _jump247;
    _jump245:;
    bool _522 = true;
    bool _523 = false;
    _a1_bool _524;
    _524.d0 = 2;
    _524.data = jpl_alloc(sizeof(bool) * 2);
    _524.data[0] = _522;
    _524.data[1] = _523;
    int64_t _525 = 255;
    int64_t _526 = 788;
    int64_t _527 = _525 / _526;
    if (_527 >= 0)
    goto _jump248;
    fail_assertion("negative array index");
    _jump248:;
    if (_527 < _524.d0)
    goto _jump249;
    fail_assertion("index too large");
    _jump249:;
    int64_t _528 = 0;
    _528 *= _524.d0;
    _528 += _527;
    bool _529 = _524.data[_528];
    _516 = _529;
    _jump247:;
    _477 = _516;
    _jump234:;
    int64_t _530;
    if (!_477)
    goto _jump250;
    bool _531 = false;
    bool _532 = true;
    bool _533 = _531 != _532;
    bool _534;
    if (!_533)
    goto _jump251;
    bool _535 = true;
    _534 = _535;
    goto _jump252;
    _jump251:;
    bool _536 = true;
    _534 = _536;
    _jump252:;
    int64_t _537;
    if (!_534)
    goto _jump253;
    int64_t _538 = 977;
    int64_t _539 = -_538;
    int64_t _540 = -_539;
    bool _541 = true;
    bool _542 = !_541;
    int64_t _543;
    if (!_542)
    goto _jump254;
    int64_t _544 = 555;
    _543 = _544;
    goto _jump255;
    _jump254:;
    int64_t _545 = 989;
    int64_t _546 = -_545;
    _543 = _546;
    _jump255:;
    int64_t _547 = _540 / _543;
    int64_t _548 = 639;
    int64_t _549 = _547 - _548;
    _537 = _549;
    goto _jump256;
    _jump253:;
    int64_t _550 = 675;
    int64_t _551 = 377;
    int64_t _552 = _550 - _551;
    _a1_int64_t _553;
    _553.d0 = 1;
    _553.data = jpl_alloc(sizeof(int64_t) * 1);
    _553.data[0] = _552;
    int64_t _554 = 140;
    if (_554 >= 0)
    goto _jump257;
    fail_assertion("negative array index");
    _jump257:;
    if (_554 < _553.d0)
    goto _jump258;
    fail_assertion("index too large");
    _jump258:;
    int64_t _555 = 0;
    _555 *= _553.d0;
    _555 += _554;
    int64_t _556 = _553.data[_555];
    _537 = _556;
    _jump256:;
    _530 = _537;
    goto _jump259;
    _jump250:;
    int64_t _557;
    // Computing bound for a
    int64_t _558 = 903;
    int64_t _559 = 392;
    int64_t _560 = _558 / _559;
    int64_t _561 = 762;
    int64_t _562 = -_561;
    _a1_int64_t _563;
    // Computing bound for a
    int64_t _564 = 269;
    _563.d0 = _564;
    if (_564 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    // Computing total size of heap memory to allocate
    int64_t _565 = 1;
    _565 *= _564;
    _565 *= sizeof(int64_t);
    _563.data = jpl_alloc(_565);
    int64_t _566 = 0; // a
    _jump261:; // Begin body of loop
    int64_t _567 = 186;
    int64_t _568 = 0;
    _568 *= _563.d0;
    _568 += _566;
    _563.data[_568] = _567;
    _566++;
    if (_566 < _564)
    goto _jump261;
    // End body of loop
    int64_t _569 = 620;
    int64_t _570 = 880;
    int64_t _571 = _569 + _570;
    if (_571 >= 0)
    goto _jump262;
    fail_assertion("negative array index");
    _jump262:;
    if (_571 < _563.d0)
    goto _jump263;
    fail_assertion("index too large");
    _jump263:;
    int64_t _572 = 0;
    _572 *= _563.d0;
    _572 += _571;
    int64_t _573 = _563.data[_572];
    int64_t _574 = _562 * _573;
    int64_t _575 = _560 / _574;
    if (_575 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    _557 = 0;
    int64_t _576 = 0; // a
    _jump265:; // Begin body of loop
    int64_t _577 = 381;
    int64_t _578 = -_577;
    int64_t _579 = -_578;
    _557 += _579;
    _576++;
    if (_576 < _575)
    goto _jump265;
    // End body of loop
    _530 = _557;
    _jump259:;
    _476.d0 = _530;
    if (_530 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing bound for b
    int64_t _580;
    // Computing bound for a
    _a3_int64_t _581;
    // Computing bound for a
    int64_t _582 = 769;
    int64_t _583 = -_582;
    int64_t _584 = -_583;
    _581.d0 = _584;
    if (_584 > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    // Computing bound for b
    _a1_int64_t _585;
    // Computing bound for a
    int64_t _586 = 863;
    _585.d0 = _586;
    if (_586 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing total size of heap memory to allocate
    int64_t _587 = 1;
    _587 *= _586;
    _587 *= sizeof(int64_t);
    _585.data = jpl_alloc(_587);
    int64_t _588 = 0; // a
    _jump269:; // Begin body of loop
    int64_t _589 = 0;
    _589 *= _585.d0;
    _589 += _588;
    _585.data[_589] = _588;
    _588++;
    if (_588 < _586)
    goto _jump269;
    // End body of loop
    int64_t _590 = 417;
    int64_t _591 = 539;
    int64_t _592 = _590 - _591;
    if (_592 >= 0)
    goto _jump270;
    fail_assertion("negative array index");
    _jump270:;
    if (_592 < _585.d0)
    goto _jump271;
    fail_assertion("index too large");
    _jump271:;
    int64_t _593 = 0;
    _593 *= _585.d0;
    _593 += _592;
    int64_t _594 = _585.data[_593];
    _581.d1 = _594;
    if (_594 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing bound for c
    int64_t _595 = 263;
    int64_t _596 = -_595;
    _581.d2 = _596;
    if (_596 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    // Computing total size of heap memory to allocate
    int64_t _597 = 1;
    _597 *= _584;
    _597 *= _594;
    _597 *= _596;
    _597 *= sizeof(int64_t);
    _581.data = jpl_alloc(_597);
    int64_t _598 = 0; // c
    int64_t _599 = 0; // b
    int64_t _600 = 0; // a
    _jump274:; // Begin body of loop
    int64_t _601 = 508;
    int64_t _602 = 0;
    _602 *= _581.d0;
    _602 += _600;
    _602 *= _581.d1;
    _602 += _599;
    _602 *= _581.d2;
    _602 += _598;
    _581.data[_602] = _601;
    _598++;
    if (_598 < _596)
    goto _jump274;
    _598 = 0;
    _599++;
    if (_599 < _594)
    goto _jump274;
    _599 = 0;
    _600++;
    if (_600 < _584)
    goto _jump274;
    // End body of loop
    int64_t _603;
    // Computing bound for a
    int64_t _604 = 638;
    if (_604 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    _603 = 0;
    int64_t _605 = 0; // a
    _jump276:; // Begin body of loop
    _603 += _605;
    _605++;
    if (_605 < _604)
    goto _jump276;
    // End body of loop
    int64_t _606;
    // Computing bound for a
    int64_t _607;
    // Computing bound for a
    int64_t _608 = 551;
    if (_608 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for b
    int64_t _609 = 296;
    if (_609 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    _607 = 0;
    int64_t _610 = 0; // b
    int64_t _611 = 0; // a
    _jump279:; // Begin body of loop
    _607 += _610;
    _610++;
    if (_610 < _609)
    goto _jump279;
    _610 = 0;
    _611++;
    if (_611 < _608)
    goto _jump279;
    // End body of loop
    if (_607 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    _606 = 0;
    int64_t _612 = 0; // a
    _jump281:; // Begin body of loop
    _606 += _612;
    _612++;
    if (_612 < _607)
    goto _jump281;
    // End body of loop
    int64_t _613 = _603 / _606;
    int64_t _614 = 799;
    int64_t _615 = -_614;
    int64_t _616 = 679;
    int64_t _617;
    // Computing bound for a
    int64_t _618 = 644;
    if (_618 > 0) 
    goto _jump282;
    fail_assertion("non-positive loop bound");
    _jump282:;
    // Computing bound for b
    int64_t _619 = 336;
    if (_619 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    _617 = 0;
    int64_t _620 = 0; // b
    int64_t _621 = 0; // a
    _jump284:; // Begin body of loop
    _617 += _621;
    _620++;
    if (_620 < _619)
    goto _jump284;
    _620 = 0;
    _621++;
    if (_621 < _618)
    goto _jump284;
    // End body of loop
    int64_t _622 = 782;
    int64_t _623 = 370;
    int64_t _624 = _622 + _623;
    int64_t _625 = _617 / _624;
    int64_t _626 = _616 % _625;
    if (_613 >= 0)
    goto _jump285;
    fail_assertion("negative array index");
    _jump285:;
    if (_613 < _581.d0)
    goto _jump286;
    fail_assertion("index too large");
    _jump286:;
    if (_615 >= 0)
    goto _jump287;
    fail_assertion("negative array index");
    _jump287:;
    if (_615 < _581.d1)
    goto _jump288;
    fail_assertion("index too large");
    _jump288:;
    if (_626 >= 0)
    goto _jump289;
    fail_assertion("negative array index");
    _jump289:;
    if (_626 < _581.d2)
    goto _jump290;
    fail_assertion("index too large");
    _jump290:;
    int64_t _627 = 0;
    _627 *= _581.d0;
    _627 += _613;
    _627 *= _581.d1;
    _627 += _615;
    _627 *= _581.d2;
    _627 += _626;
    int64_t _628 = _581.data[_627];
    int64_t _629 = 292;
    int64_t _630 = 920;
    int64_t _631 = -_630;
    bool _632 = _629 == _631;
    int64_t _633;
    if (!_632)
    goto _jump291;
    bool _634 = true;
    int64_t _635;
    if (!_634)
    goto _jump292;
    bool _636 = false;
    int64_t _637;
    if (!_636)
    goto _jump293;
    int64_t _638 = 470;
    _637 = _638;
    goto _jump294;
    _jump293:;
    int64_t _639 = 141;
    _637 = _639;
    _jump294:;
    _635 = _637;
    goto _jump295;
    _jump292:;
    int64_t _640 = 454;
    _635 = _640;
    _jump295:;
    _633 = _635;
    goto _jump296;
    _jump291:;
    int64_t _641 = 68;
    _633 = _641;
    _jump296:;
    int64_t _642;
    // Computing bound for a
    bool _643 = true;
    int64_t _644;
    if (!_643)
    goto _jump297;
    int64_t _645 = 688;
    int64_t _646 = -_645;
    _644 = _646;
    goto _jump298;
    _jump297:;
    int64_t _647 = 313;
    _644 = _647;
    _jump298:;
    if (_644 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for b
    int64_t _648 = 914;
    int64_t _649 = -_648;
    int64_t _650 = 604;
    int64_t _651 = _649 / _650;
    if (_651 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    _642 = 0;
    int64_t _652 = 0; // b
    int64_t _653 = 0; // a
    _jump301:; // Begin body of loop
    int64_t _654 = -_653;
    int64_t _655 = -_654;
    _642 += _655;
    _652++;
    if (_652 < _651)
    goto _jump301;
    _652 = 0;
    _653++;
    if (_653 < _644)
    goto _jump301;
    // End body of loop
    int64_t _656 = _633 - _642;
    int64_t _657 = _628 / _656;
    if (_657 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    _580 = 0;
    int64_t _658 = 0; // a
    _jump303:; // Begin body of loop
    _a2_bool _659;
    // Computing bound for b
    int64_t _660 = -_658;
    int64_t _661 = _658 - _660;
    _659.d0 = _661;
    if (_661 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for c
    _659.d1 = _658;
    if (_658 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    // Computing total size of heap memory to allocate
    int64_t _662 = 1;
    _662 *= _661;
    _662 *= _658;
    _662 *= sizeof(bool);
    _659.data = jpl_alloc(_662);
    int64_t _663 = 0; // c
    int64_t _664 = 0; // b
    _jump306:; // Begin body of loop
    bool _665 = true;
    bool _666 = !_665;
    bool _667 = !_666;
    int64_t _668 = 0;
    _668 *= _659.d0;
    _668 += _664;
    _668 *= _659.d1;
    _668 += _663;
    _659.data[_668] = _667;
    _663++;
    if (_663 < _658)
    goto _jump306;
    _663 = 0;
    _664++;
    if (_664 < _661)
    goto _jump306;
    // End body of loop
    bool _669 = true;
    bool _670 = !_669;
    int64_t _671;
    if (!_670)
    goto _jump307;
    int64_t _672;
    // Computing bound for b
    if (_658 > 0) 
    goto _jump308;
    fail_assertion("non-positive loop bound");
    _jump308:;
    // Computing bound for c
    if (_658 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for d
    if (_658 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    _672 = 0;
    int64_t _673 = 0; // d
    int64_t _674 = 0; // c
    int64_t _675 = 0; // b
    _jump311:; // Begin body of loop
    int64_t _676 = 161;
    _672 += _676;
    _673++;
    if (_673 < _658)
    goto _jump311;
    _673 = 0;
    _674++;
    if (_674 < _658)
    goto _jump311;
    _674 = 0;
    _675++;
    if (_675 < _658)
    goto _jump311;
    // End body of loop
    _671 = _672;
    goto _jump312;
    _jump307:;
    int64_t _677 = 648;
    _671 = _677;
    _jump312:;
    if (_671 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (_671 < _659.d0)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    if (_658 >= 0)
    goto _jump315;
    fail_assertion("negative array index");
    _jump315:;
    if (_658 < _659.d1)
    goto _jump316;
    fail_assertion("index too large");
    _jump316:;
    int64_t _678 = 0;
    _678 *= _659.d0;
    _678 += _671;
    _678 *= _659.d1;
    _678 += _658;
    bool _679 = _659.data[_678];
    int64_t _680;
    if (!_679)
    goto _jump317;
    int64_t _681 = _658 * _658;
    bool _682 = _658 <= _681;
    bool _683 = !_682;
    int64_t _684;
    if (!_683)
    goto _jump318;
    _684 = _658;
    goto _jump319;
    _jump318:;
    int64_t _685 = 993;
    bool _686 = _658 == _685;
    bool _687 = !_686;
    int64_t _688;
    if (!_687)
    goto _jump320;
    int64_t _689 = 441;
    _a1_int64_t _690;
    _690.d0 = 1;
    _690.data = jpl_alloc(sizeof(int64_t) * 1);
    _690.data[0] = _689;
    int64_t _691 = -_658;
    if (_691 >= 0)
    goto _jump321;
    fail_assertion("negative array index");
    _jump321:;
    if (_691 < _690.d0)
    goto _jump322;
    fail_assertion("index too large");
    _jump322:;
    int64_t _692 = 0;
    _692 *= _690.d0;
    _692 += _691;
    int64_t _693 = _690.data[_692];
    _688 = _693;
    goto _jump323;
    _jump320:;
    int64_t _694 = -_658;
    _688 = _694;
    _jump323:;
    _684 = _688;
    _jump319:;
    _680 = _684;
    goto _jump324;
    _jump317:;
    int64_t _695;
    // Computing bound for b
    bool _696 = true;
    bool _697 = !_696;
    int64_t _698;
    if (!_697)
    goto _jump325;
    _698 = _658;
    goto _jump326;
    _jump325:;
    _698 = _658;
    _jump326:;
    if (_698 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing bound for c
    if (_658 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    // Computing bound for d
    int64_t _699;
    // Computing bound for b
    if (_658 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for c
    int64_t _700;
    // Computing bound for b
    int64_t _701 = 123;
    if (_701 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for c
    if (_658 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing bound for d
    int64_t _702 = 923;
    if (_702 > 0) 
    goto _jump332;
    fail_assertion("non-positive loop bound");
    _jump332:;
    _700 = 0;
    int64_t _703 = 0; // d
    int64_t _704 = 0; // c
    int64_t _705 = 0; // b
    _jump333:; // Begin body of loop
    _700 += _704;
    _703++;
    if (_703 < _702)
    goto _jump333;
    _703 = 0;
    _704++;
    if (_704 < _658)
    goto _jump333;
    _704 = 0;
    _705++;
    if (_705 < _701)
    goto _jump333;
    // End body of loop
    if (_700 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    _699 = 0;
    int64_t _706 = 0; // c
    int64_t _707 = 0; // b
    _jump335:; // Begin body of loop
    _699 += _707;
    _706++;
    if (_706 < _700)
    goto _jump335;
    _706 = 0;
    _707++;
    if (_707 < _658)
    goto _jump335;
    // End body of loop
    if (_699 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    _695 = 0;
    int64_t _708 = 0; // d
    int64_t _709 = 0; // c
    int64_t _710 = 0; // b
    _jump337:; // Begin body of loop
    int64_t _711 = _709 + _708;
    _695 += _711;
    _708++;
    if (_708 < _699)
    goto _jump337;
    _708 = 0;
    _709++;
    if (_709 < _658)
    goto _jump337;
    _709 = 0;
    _710++;
    if (_710 < _698)
    goto _jump337;
    // End body of loop
    int64_t _712 = -_658;
    int64_t _713 = _695 * _712;
    _680 = _713;
    _jump324:;
    _580 += _680;
    _658++;
    if (_658 < _657)
    goto _jump303;
    // End body of loop
    _476.d1 = _580;
    if (_580 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for c
    int64_t _714 = 740;
    _476.d2 = _714;
    if (_714 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    // Computing total size of heap memory to allocate
    int64_t _715 = 1;
    _715 *= _530;
    _715 *= _580;
    _715 *= _714;
    _715 *= sizeof(bool);
    _476.data = jpl_alloc(_715);
    int64_t _716 = 0; // c
    int64_t _717 = 0; // b
    int64_t _718 = 0; // a
    _jump340:; // Begin body of loop
    bool _719 = true;
    int64_t _720 = 0;
    _720 *= _476.d0;
    _720 += _718;
    _720 *= _476.d1;
    _720 += _717;
    _720 *= _476.d2;
    _720 += _716;
    _476.data[_720] = _719;
    _716++;
    if (_716 < _714)
    goto _jump340;
    _716 = 0;
    _717++;
    if (_717 < _580)
    goto _jump340;
    _717 = 0;
    _718++;
    if (_718 < _530)
    goto _jump340;
    // End body of loop
    bool _721 = true;
    _a2__a3_bool _722;
    if (!_721)
    goto _jump827;
    _a2__a3_bool _723;
    // Computing bound for g
    _723.d0 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing bound for h
    _723.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    // Computing total size of heap memory to allocate
    int64_t _724 = 1;
    _724 *= _476.d2;
    _724 *= _476.d2;
    _724 *= sizeof(_a3_bool);
    _723.data = jpl_alloc(_724);
    int64_t _725 = 0; // h
    int64_t _726 = 0; // g
    _jump830:; // Begin body of loop
    int64_t _727 = 0;
    _727 *= _723.d0;
    _727 += _726;
    _727 *= _723.d1;
    _727 += _725;
    _723.data[_727] = _476;
    _725++;
    if (_725 < _476.d2)
    goto _jump830;
    _725 = 0;
    _726++;
    if (_726 < _476.d2)
    goto _jump830;
    // End body of loop
    _722 = _723;
    goto _jump831;
    _jump827:;
    _a2__a3_bool _728;
    // Computing bound for g
    _728.d0 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    // Computing bound for h
    _728.d1 = _476.d1;
    if (_476.d1 > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing total size of heap memory to allocate
    int64_t _729 = 1;
    _729 *= _476.d0;
    _729 *= _476.d1;
    _729 *= sizeof(_a3_bool);
    _728.data = jpl_alloc(_729);
    int64_t _730 = 0; // h
    int64_t _731 = 0; // g
    _jump834:; // Begin body of loop
    int64_t _732 = 0;
    _732 *= _728.d0;
    _732 += _731;
    _732 *= _728.d1;
    _732 += _730;
    _728.data[_732] = _476;
    _730++;
    if (_730 < _476.d1)
    goto _jump834;
    _730 = 0;
    _731++;
    if (_731 < _476.d0)
    goto _jump834;
    // End body of loop
    _722 = _728;
    _jump831:;
    int64_t _733 = -_476.d1;
    int64_t _734 = -_733;
    if (_734 >= 0)
    goto _jump835;
    fail_assertion("negative array index");
    _jump835:;
    if (_734 < _722.d0)
    goto _jump836;
    fail_assertion("index too large");
    _jump836:;
    if (_476.d2 >= 0)
    goto _jump837;
    fail_assertion("negative array index");
    _jump837:;
    if (_476.d2 < _722.d1)
    goto _jump838;
    fail_assertion("index too large");
    _jump838:;
    int64_t _735 = 0;
    _735 *= _722.d0;
    _735 += _734;
    _735 *= _722.d1;
    _735 += _476.d2;
    _a3_bool _736 = _722.data[_735];
    _a3_bool _737;
    // Computing bound for g
    int64_t _738 = 384;
    _737.d0 = _738;
    if (_738 > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    // Computing bound for h
    int64_t _739;
    // Computing bound for g
    if (_476.d0 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    _739 = 0;
    int64_t _740 = 0; // g
    _jump841:; // Begin body of loop
    int64_t _741 = 265;
    _739 += _741;
    _740++;
    if (_740 < _476.d0)
    goto _jump841;
    // End body of loop
    _737.d1 = _739;
    if (_739 > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing bound for i
    int64_t _742;
    // Computing bound for g
    if (_476.d2 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    // Computing bound for h
    if (_476.d1 > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    _742 = 0;
    int64_t _743 = 0; // h
    int64_t _744 = 0; // g
    _jump845:; // Begin body of loop
    int64_t _745 = 327;
    _742 += _745;
    _743++;
    if (_743 < _476.d1)
    goto _jump845;
    _743 = 0;
    _744++;
    if (_744 < _476.d2)
    goto _jump845;
    // End body of loop
    _737.d2 = _742;
    if (_742 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    // Computing total size of heap memory to allocate
    int64_t _746 = 1;
    _746 *= _738;
    _746 *= _739;
    _746 *= _742;
    _746 *= sizeof(bool);
    _737.data = jpl_alloc(_746);
    int64_t _747 = 0; // i
    int64_t _748 = 0; // h
    int64_t _749 = 0; // g
    _jump847:; // Begin body of loop
    bool _750 = _748 == _476.d1;
    int64_t _751 = 0;
    _751 *= _737.d0;
    _751 += _749;
    _751 *= _737.d1;
    _751 += _748;
    _751 *= _737.d2;
    _751 += _747;
    _737.data[_751] = _750;
    _747++;
    if (_747 < _742)
    goto _jump847;
    _747 = 0;
    _748++;
    if (_748 < _739)
    goto _jump847;
    _748 = 0;
    _749++;
    if (_749 < _738)
    goto _jump847;
    // End body of loop
    bool _752 = true;
    _a3_bool _753;
    if (!_752)
    goto _jump848;
    _753 = _476;
    goto _jump849;
    _jump848:;
    _753 = _476;
    _jump849:;
    _a1__a3_bool _754;
    _754.d0 = 3;
    _754.data = jpl_alloc(sizeof(_a3_bool) * 3);
    _754.data[0] = _736;
    _754.data[1] = _737;
    _754.data[2] = _753;
    if (_476.d1 >= 0)
    goto _jump850;
    fail_assertion("negative array index");
    _jump850:;
    if (_476.d1 < _754.d0)
    goto _jump851;
    fail_assertion("index too large");
    _jump851:;
    int64_t _755 = 0;
    _755 *= _754.d0;
    _755 += _476.d1;
    _a3_bool _756 = _754.data[_755];
    int64_t _757;
    // Computing bound for g
    if (_476.d1 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for h
    bool _759 = false;
    bool _760 = !_759;
    bool _758 = _760;
    if (0 == _760)
    goto _jump853;
    bool _761 = true;
    _758 = _761;
    _jump853:;
    _a2_int64_t _762;
    if (!_758)
    goto _jump854;
    _a2_int64_t _763;
    // Computing bound for g
    _763.d0 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    // Computing bound for h
    int64_t _764;
    // Computing bound for g
    if (_476.d1 > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing bound for h
    if (_476.d1 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    _764 = 0;
    int64_t _765 = 0; // h
    int64_t _766 = 0; // g
    _jump858:; // Begin body of loop
    _764 += _476.d0;
    _765++;
    if (_765 < _476.d1)
    goto _jump858;
    _765 = 0;
    _766++;
    if (_766 < _476.d1)
    goto _jump858;
    // End body of loop
    _763.d1 = _764;
    if (_764 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    // Computing total size of heap memory to allocate
    int64_t _767 = 1;
    _767 *= _476.d0;
    _767 *= _764;
    _767 *= sizeof(int64_t);
    _763.data = jpl_alloc(_767);
    int64_t _768 = 0; // h
    int64_t _769 = 0; // g
    _jump860:; // Begin body of loop
    int64_t _770 = 0;
    _770 *= _763.d0;
    _770 += _769;
    _770 *= _763.d1;
    _770 += _768;
    _763.data[_770] = _476.d1;
    _768++;
    if (_768 < _764)
    goto _jump860;
    _768 = 0;
    _769++;
    if (_769 < _476.d0)
    goto _jump860;
    // End body of loop
    _762 = _763;
    goto _jump861;
    _jump854:;
    _a2_int64_t _771;
    // Computing bound for g
    _771.d0 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump862;
    fail_assertion("non-positive loop bound");
    _jump862:;
    // Computing bound for h
    int64_t _772 = -_476.d0;
    _771.d1 = _772;
    if (_772 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing total size of heap memory to allocate
    int64_t _773 = 1;
    _773 *= _476.d0;
    _773 *= _772;
    _773 *= sizeof(int64_t);
    _771.data = jpl_alloc(_773);
    int64_t _774 = 0; // h
    int64_t _775 = 0; // g
    _jump864:; // Begin body of loop
    int64_t _776;
    // Computing bound for i
    if (_476.d1 > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    _776 = 0;
    int64_t _777 = 0; // i
    _jump866:; // Begin body of loop
    _776 += _777;
    _777++;
    if (_777 < _476.d1)
    goto _jump866;
    // End body of loop
    int64_t _778 = 0;
    _778 *= _771.d0;
    _778 += _775;
    _778 *= _771.d1;
    _778 += _774;
    _771.data[_778] = _776;
    _774++;
    if (_774 < _772)
    goto _jump864;
    _774 = 0;
    _775++;
    if (_775 < _476.d0)
    goto _jump864;
    // End body of loop
    _762 = _771;
    _jump861:;
    int64_t _779 = 987;
    int64_t _780 = 480;
    if (_779 >= 0)
    goto _jump867;
    fail_assertion("negative array index");
    _jump867:;
    if (_779 < _762.d0)
    goto _jump868;
    fail_assertion("index too large");
    _jump868:;
    if (_780 >= 0)
    goto _jump869;
    fail_assertion("negative array index");
    _jump869:;
    if (_780 < _762.d1)
    goto _jump870;
    fail_assertion("index too large");
    _jump870:;
    int64_t _781 = 0;
    _781 *= _762.d0;
    _781 += _779;
    _781 *= _762.d1;
    _781 += _780;
    int64_t _782 = _762.data[_781];
    if (_782 > 0) 
    goto _jump871;
    fail_assertion("non-positive loop bound");
    _jump871:;
    // Computing bound for i
    _a3__a1_int64_t _783;
    // Computing bound for g
    int64_t _784 = -_476.d2;
    _783.d0 = _784;
    if (_784 > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    // Computing bound for h
    _783.d1 = _476.d1;
    if (_476.d1 > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    // Computing bound for i
    _783.d2 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing total size of heap memory to allocate
    int64_t _785 = 1;
    _785 *= _784;
    _785 *= _476.d1;
    _785 *= _476.d0;
    _785 *= sizeof(_a1_int64_t);
    _783.data = jpl_alloc(_785);
    int64_t _786 = 0; // i
    int64_t _787 = 0; // h
    int64_t _788 = 0; // g
    _jump875:; // Begin body of loop
    _a1_int64_t _789;
    _789.d0 = 1;
    _789.data = jpl_alloc(sizeof(int64_t) * 1);
    _789.data[0] = _476.d1;
    int64_t _790 = 0;
    _790 *= _783.d0;
    _790 += _788;
    _790 *= _783.d1;
    _790 += _787;
    _790 *= _783.d2;
    _790 += _786;
    _783.data[_790] = _789;
    _786++;
    if (_786 < _476.d0)
    goto _jump875;
    _786 = 0;
    _787++;
    if (_787 < _476.d1)
    goto _jump875;
    _787 = 0;
    _788++;
    if (_788 < _784)
    goto _jump875;
    // End body of loop
    int64_t _791 = 230;
    int64_t _792 = -_791;
    int64_t _793 = -_792;
    int64_t _794 = 698;
    int64_t _795;
    // Computing bound for g
    if (_476.d0 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    _795 = 0;
    int64_t _796 = 0; // g
    _jump877:; // Begin body of loop
    _795 += _476.d2;
    _796++;
    if (_796 < _476.d0)
    goto _jump877;
    // End body of loop
    int64_t _797 = _794 - _795;
    if (_476.d0 >= 0)
    goto _jump878;
    fail_assertion("negative array index");
    _jump878:;
    if (_476.d0 < _783.d0)
    goto _jump879;
    fail_assertion("index too large");
    _jump879:;
    if (_793 >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (_793 < _783.d1)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    if (_797 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_797 < _783.d2)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    int64_t _798 = 0;
    _798 *= _783.d0;
    _798 += _476.d0;
    _798 *= _783.d1;
    _798 += _793;
    _798 *= _783.d2;
    _798 += _797;
    _a1_int64_t _799 = _783.data[_798];
    int64_t _800 = 31;
    int64_t _801 = _800 * _476.d0;
    int64_t _802 = 907;
    if (_801 >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (_801 < _476.d0)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    if (_802 >= 0)
    goto _jump886;
    fail_assertion("negative array index");
    _jump886:;
    if (_802 < _476.d1)
    goto _jump887;
    fail_assertion("index too large");
    _jump887:;
    if (_476.d0 >= 0)
    goto _jump888;
    fail_assertion("negative array index");
    _jump888:;
    if (_476.d0 < _476.d2)
    goto _jump889;
    fail_assertion("index too large");
    _jump889:;
    int64_t _803 = 0;
    _803 *= _476.d0;
    _803 += _801;
    _803 *= _476.d1;
    _803 += _802;
    _803 *= _476.d2;
    _803 += _476.d0;
    bool _804 = _476.data[_803];
    int64_t _805;
    if (!_804)
    goto _jump890;
    _805 = _476.d0;
    goto _jump891;
    _jump890:;
    bool _806 = false;
    int64_t _807;
    if (!_806)
    goto _jump892;
    _807 = _476.d0;
    goto _jump893;
    _jump892:;
    _807 = _476.d0;
    _jump893:;
    int64_t _808 = _476.d2 - _807;
    _805 = _808;
    _jump891:;
    if (_805 >= 0)
    goto _jump894;
    fail_assertion("negative array index");
    _jump894:;
    if (_805 < _799.d0)
    goto _jump895;
    fail_assertion("index too large");
    _jump895:;
    int64_t _809 = 0;
    _809 *= _799.d0;
    _809 += _805;
    int64_t _810 = _799.data[_809];
    if (_810 > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    _757 = 0;
    int64_t _811 = 0; // i
    int64_t _812 = 0; // h
    int64_t _813 = 0; // g
    _jump897:; // Begin body of loop
    _757 += _476.d1;
    _811++;
    if (_811 < _810)
    goto _jump897;
    _811 = 0;
    _812++;
    if (_812 < _782)
    goto _jump897;
    _812 = 0;
    _813++;
    if (_813 < _476.d1)
    goto _jump897;
    // End body of loop
    int64_t _814 = _476.d1 + _476.d1;
    if (_757 >= 0)
    goto _jump898;
    fail_assertion("negative array index");
    _jump898:;
    if (_757 < _756.d0)
    goto _jump899;
    fail_assertion("index too large");
    _jump899:;
    if (_476.d0 >= 0)
    goto _jump900;
    fail_assertion("negative array index");
    _jump900:;
    if (_476.d0 < _756.d1)
    goto _jump901;
    fail_assertion("index too large");
    _jump901:;
    if (_814 >= 0)
    goto _jump902;
    fail_assertion("negative array index");
    _jump902:;
    if (_814 < _756.d2)
    goto _jump903;
    fail_assertion("index too large");
    _jump903:;
    int64_t _815 = 0;
    _815 *= _756.d0;
    _815 += _757;
    _815 *= _756.d1;
    _815 += _476.d0;
    _815 *= _756.d2;
    _815 += _814;
    bool _816 = _756.data[_815];
    _a3_int64_t _817;
    if (!_816)
    goto _jump904;
    int64_t _818;
    // Computing bound for g
    if (_476.d2 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for h
    if (_476.d2 > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    _818 = 0;
    int64_t _819 = 0; // h
    int64_t _820 = 0; // g
    _jump907:; // Begin body of loop
    _818 += _476.d2;
    _819++;
    if (_819 < _476.d2)
    goto _jump907;
    _819 = 0;
    _820++;
    if (_820 < _476.d2)
    goto _jump907;
    // End body of loop
    int64_t _821;
    // Computing bound for g
    if (_476.d2 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing bound for h
    bool _822 = false;
    _a1_int64_t _823;
    if (!_822)
    goto _jump909;
    _a1_int64_t _824;
    _824.d0 = 3;
    _824.data = jpl_alloc(sizeof(int64_t) * 3);
    _824.data[0] = _476.d2;
    _824.data[1] = _476.d0;
    _824.data[2] = _476.d2;
    _823 = _824;
    goto _jump910;
    _jump909:;
    _a1_int64_t _825;
    // Computing bound for g
    _825.d0 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing total size of heap memory to allocate
    int64_t _826 = 1;
    _826 *= _476.d2;
    _826 *= sizeof(int64_t);
    _825.data = jpl_alloc(_826);
    int64_t _827 = 0; // g
    _jump912:; // Begin body of loop
    int64_t _828 = 0;
    _828 *= _825.d0;
    _828 += _827;
    _825.data[_828] = _476.d1;
    _827++;
    if (_827 < _476.d2)
    goto _jump912;
    // End body of loop
    _823 = _825;
    _jump910:;
    if (_476.d2 >= 0)
    goto _jump913;
    fail_assertion("negative array index");
    _jump913:;
    if (_476.d2 < _823.d0)
    goto _jump914;
    fail_assertion("index too large");
    _jump914:;
    int64_t _829 = 0;
    _829 *= _823.d0;
    _829 += _476.d2;
    int64_t _830 = _823.data[_829];
    if (_830 > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing bound for i
    bool _831 = false;
    bool _832 = !_831;
    int64_t _833;
    if (!_832)
    goto _jump916;
    int64_t _834 = -_476.d1;
    _833 = _834;
    goto _jump917;
    _jump916:;
    int64_t _835 = _476.d1 + _476.d1;
    _833 = _835;
    _jump917:;
    int64_t _836 = _833 % _476.d0;
    if (_836 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    _821 = 0;
    int64_t _837 = 0; // i
    int64_t _838 = 0; // h
    int64_t _839 = 0; // g
    _jump919:; // Begin body of loop
    int64_t _840 = -_476.d1;
    _821 += _840;
    _837++;
    if (_837 < _836)
    goto _jump919;
    _837 = 0;
    _838++;
    if (_838 < _830)
    goto _jump919;
    _838 = 0;
    _839++;
    if (_839 < _476.d2)
    goto _jump919;
    // End body of loop
    bool _841 = _818 < _821;
    _a3_int64_t _842;
    if (!_841)
    goto _jump920;
    _a3_int64_t _843;
    // Computing bound for g
    int64_t _844 = -_476.d2;
    _843.d0 = _844;
    if (_844 > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing bound for h
    _843.d1 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump922;
    fail_assertion("non-positive loop bound");
    _jump922:;
    // Computing bound for i
    int64_t _845 = 192;
    _843.d2 = _845;
    if (_845 > 0) 
    goto _jump923;
    fail_assertion("non-positive loop bound");
    _jump923:;
    // Computing total size of heap memory to allocate
    int64_t _846 = 1;
    _846 *= _844;
    _846 *= _476.d0;
    _846 *= _845;
    _846 *= sizeof(int64_t);
    _843.data = jpl_alloc(_846);
    int64_t _847 = 0; // i
    int64_t _848 = 0; // h
    int64_t _849 = 0; // g
    _jump924:; // Begin body of loop
    int64_t _850 = 0;
    _850 *= _843.d0;
    _850 += _849;
    _850 *= _843.d1;
    _850 += _848;
    _850 *= _843.d2;
    _850 += _847;
    _843.data[_850] = _476.d1;
    _847++;
    if (_847 < _845)
    goto _jump924;
    _847 = 0;
    _848++;
    if (_848 < _476.d0)
    goto _jump924;
    _848 = 0;
    _849++;
    if (_849 < _844)
    goto _jump924;
    // End body of loop
    _842 = _843;
    goto _jump925;
    _jump920:;
    _a3__a2__a3_int64_t _851;
    // Computing bound for g
    int64_t _852 = 853;
    int64_t _853 = _852 % _476.d0;
    _851.d0 = _853;
    if (_853 > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing bound for h
    int64_t _854 = 737;
    _851.d1 = _854;
    if (_854 > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    // Computing bound for i
    _851.d2 = _476.d1;
    if (_476.d1 > 0) 
    goto _jump928;
    fail_assertion("non-positive loop bound");
    _jump928:;
    // Computing total size of heap memory to allocate
    int64_t _855 = 1;
    _855 *= _853;
    _855 *= _854;
    _855 *= _476.d1;
    _855 *= sizeof(_a2__a3_int64_t);
    _851.data = jpl_alloc(_855);
    int64_t _856 = 0; // i
    int64_t _857 = 0; // h
    int64_t _858 = 0; // g
    _jump929:; // Begin body of loop
    _a2__a3_int64_t _859;
    // Computing bound for j
    _859.d0 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump930;
    fail_assertion("non-positive loop bound");
    _jump930:;
    // Computing bound for k
    _859.d1 = _858;
    if (_858 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing total size of heap memory to allocate
    int64_t _860 = 1;
    _860 *= _476.d2;
    _860 *= _858;
    _860 *= sizeof(_a3_int64_t);
    _859.data = jpl_alloc(_860);
    int64_t _861 = 0; // k
    int64_t _862 = 0; // j
    _jump932:; // Begin body of loop
    _a3_int64_t _863;
    // Computing bound for l
    _863.d0 = _862;
    if (_862 > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    // Computing bound for m
    _863.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for n
    _863.d2 = _856;
    if (_856 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _864 = 1;
    _864 *= _862;
    _864 *= _476.d2;
    _864 *= _856;
    _864 *= sizeof(int64_t);
    _863.data = jpl_alloc(_864);
    int64_t _865 = 0; // n
    int64_t _866 = 0; // m
    int64_t _867 = 0; // l
    _jump936:; // Begin body of loop
    int64_t _868 = 0;
    _868 *= _863.d0;
    _868 += _867;
    _868 *= _863.d1;
    _868 += _866;
    _868 *= _863.d2;
    _868 += _865;
    _863.data[_868] = _862;
    _865++;
    if (_865 < _856)
    goto _jump936;
    _865 = 0;
    _866++;
    if (_866 < _476.d2)
    goto _jump936;
    _866 = 0;
    _867++;
    if (_867 < _862)
    goto _jump936;
    // End body of loop
    int64_t _869 = 0;
    _869 *= _859.d0;
    _869 += _862;
    _869 *= _859.d1;
    _869 += _861;
    _859.data[_869] = _863;
    _861++;
    if (_861 < _858)
    goto _jump932;
    _861 = 0;
    _862++;
    if (_862 < _476.d2)
    goto _jump932;
    // End body of loop
    int64_t _870 = 0;
    _870 *= _851.d0;
    _870 += _858;
    _870 *= _851.d1;
    _870 += _857;
    _870 *= _851.d2;
    _870 += _856;
    _851.data[_870] = _859;
    _856++;
    if (_856 < _476.d1)
    goto _jump929;
    _856 = 0;
    _857++;
    if (_857 < _854)
    goto _jump929;
    _857 = 0;
    _858++;
    if (_858 < _853)
    goto _jump929;
    // End body of loop
    int64_t _871;
    // Computing bound for g
    _a1_int64_t _872;
    // Computing bound for g
    _872.d0 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing total size of heap memory to allocate
    int64_t _873 = 1;
    _873 *= _476.d2;
    _873 *= sizeof(int64_t);
    _872.data = jpl_alloc(_873);
    int64_t _874 = 0; // g
    _jump938:; // Begin body of loop
    int64_t _875 = 0;
    _875 *= _872.d0;
    _875 += _874;
    _872.data[_875] = _476.d1;
    _874++;
    if (_874 < _476.d2)
    goto _jump938;
    // End body of loop
    int64_t _876 = _476.d1 + _476.d0;
    if (_876 >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (_876 < _872.d0)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    int64_t _877 = 0;
    _877 *= _872.d0;
    _877 += _876;
    int64_t _878 = _872.data[_877];
    if (_878 > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    // Computing bound for h
    int64_t _879;
    // Computing bound for g
    int64_t _880 = 256;
    int64_t _881 = _880 - _476.d0;
    if (_881 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    _879 = 0;
    int64_t _882 = 0; // g
    _jump943:; // Begin body of loop
    _879 += _476.d1;
    _882++;
    if (_882 < _881)
    goto _jump943;
    // End body of loop
    if (_879 > 0) 
    goto _jump944;
    fail_assertion("non-positive loop bound");
    _jump944:;
    _871 = 0;
    int64_t _883 = 0; // h
    int64_t _884 = 0; // g
    _jump945:; // Begin body of loop
    _871 += _476.d2;
    _883++;
    if (_883 < _879)
    goto _jump945;
    _883 = 0;
    _884++;
    if (_884 < _878)
    goto _jump945;
    // End body of loop
    int64_t _885;
    // Computing bound for g
    int64_t _886;
    // Computing bound for g
    if (_476.d1 > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    // Computing bound for h
    int64_t _887 = -_476.d2;
    if (_887 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for i
    int64_t _888 = 886;
    int64_t _889 = _476.d2 + _888;
    if (_889 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    _886 = 0;
    int64_t _890 = 0; // i
    int64_t _891 = 0; // h
    int64_t _892 = 0; // g
    _jump949:; // Begin body of loop
    int64_t _893 = 506;
    int64_t _894 = -_893;
    _886 += _894;
    _890++;
    if (_890 < _889)
    goto _jump949;
    _890 = 0;
    _891++;
    if (_891 < _887)
    goto _jump949;
    _891 = 0;
    _892++;
    if (_892 < _476.d1)
    goto _jump949;
    // End body of loop
    if (_886 > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing bound for h
    bool _895 = false;
    int64_t _896;
    if (!_895)
    goto _jump951;
    int64_t _897;
    // Computing bound for g
    int64_t _898 = 207;
    if (_898 > 0) 
    goto _jump952;
    fail_assertion("non-positive loop bound");
    _jump952:;
    // Computing bound for h
    if (_476.d0 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    _897 = 0;
    int64_t _899 = 0; // h
    int64_t _900 = 0; // g
    _jump954:; // Begin body of loop
    _897 += _899;
    _899++;
    if (_899 < _476.d0)
    goto _jump954;
    _899 = 0;
    _900++;
    if (_900 < _898)
    goto _jump954;
    // End body of loop
    _896 = _897;
    goto _jump955;
    _jump951:;
    _896 = _476.d1;
    _jump955:;
    if (_896 > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    _885 = 0;
    int64_t _901 = 0; // h
    int64_t _902 = 0; // g
    _jump957:; // Begin body of loop
    int64_t _903 = 511;
    _885 += _903;
    _901++;
    if (_901 < _896)
    goto _jump957;
    _901 = 0;
    _902++;
    if (_902 < _886)
    goto _jump957;
    // End body of loop
    _a2_int64_t _904;
    // Computing bound for g
    _904.d0 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing bound for h
    _904.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing total size of heap memory to allocate
    int64_t _905 = 1;
    _905 *= _476.d0;
    _905 *= _476.d2;
    _905 *= sizeof(int64_t);
    _904.data = jpl_alloc(_905);
    int64_t _906 = 0; // h
    int64_t _907 = 0; // g
    _jump960:; // Begin body of loop
    int64_t _908 = 0;
    _908 *= _904.d0;
    _908 += _907;
    _908 *= _904.d1;
    _908 += _906;
    _904.data[_908] = _476.d2;
    _906++;
    if (_906 < _476.d2)
    goto _jump960;
    _906 = 0;
    _907++;
    if (_907 < _476.d0)
    goto _jump960;
    // End body of loop
    int64_t _909 = 398;
    int64_t _910 = 916;
    if (_909 >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (_909 < _904.d0)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    if (_910 >= 0)
    goto _jump963;
    fail_assertion("negative array index");
    _jump963:;
    if (_910 < _904.d1)
    goto _jump964;
    fail_assertion("index too large");
    _jump964:;
    int64_t _911 = 0;
    _911 *= _904.d0;
    _911 += _909;
    _911 *= _904.d1;
    _911 += _910;
    int64_t _912 = _904.data[_911];
    int64_t _913 = -_912;
    if (_871 >= 0)
    goto _jump965;
    fail_assertion("negative array index");
    _jump965:;
    if (_871 < _851.d0)
    goto _jump966;
    fail_assertion("index too large");
    _jump966:;
    if (_885 >= 0)
    goto _jump967;
    fail_assertion("negative array index");
    _jump967:;
    if (_885 < _851.d1)
    goto _jump968;
    fail_assertion("index too large");
    _jump968:;
    if (_913 >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (_913 < _851.d2)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    int64_t _914 = 0;
    _914 *= _851.d0;
    _914 += _871;
    _914 *= _851.d1;
    _914 += _885;
    _914 *= _851.d2;
    _914 += _913;
    _a2__a3_int64_t _915 = _851.data[_914];
    int64_t _916 = _476.d2 - _476.d1;
    int64_t _917 = -_916;
    int64_t _918 = 131;
    int64_t _919 = _918 % _476.d1;
    int64_t _920 = -_919;
    bool _921 = false;
    bool _922 = false;
    bool _923 = _921 != _922;
    int64_t _924;
    if (!_923)
    goto _jump971;
    int64_t _925 = 186;
    _924 = _925;
    goto _jump972;
    _jump971:;
    int64_t _926;
    // Computing bound for g
    int64_t _927 = -_476.d2;
    if (_927 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    _926 = 0;
    int64_t _928 = 0; // g
    _jump974:; // Begin body of loop
    _926 += _476.d2;
    _928++;
    if (_928 < _927)
    goto _jump974;
    // End body of loop
    _924 = _926;
    _jump972:;
    int64_t _929 = _920 / _924;
    if (_917 >= 0)
    goto _jump975;
    fail_assertion("negative array index");
    _jump975:;
    if (_917 < _915.d0)
    goto _jump976;
    fail_assertion("index too large");
    _jump976:;
    if (_929 >= 0)
    goto _jump977;
    fail_assertion("negative array index");
    _jump977:;
    if (_929 < _915.d1)
    goto _jump978;
    fail_assertion("index too large");
    _jump978:;
    int64_t _930 = 0;
    _930 *= _915.d0;
    _930 += _917;
    _930 *= _915.d1;
    _930 += _929;
    _a3_int64_t _931 = _915.data[_930];
    _842 = _931;
    _jump925:;
    _817 = _842;
    goto _jump979;
    _jump904:;
    _a3_int64_t _932;
    // Computing bound for g
    double _933;
    // Computing bound for g
    if (_476.d1 > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing bound for h
    if (_476.d2 > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    _933 = 0;
    int64_t _934 = 0; // h
    int64_t _935 = 0; // g
    _jump982:; // Begin body of loop
    double _936;
    // Computing bound for i
    if (_934 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for j
    if (_476.d1 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing bound for k
    int64_t _937 = 368;
    if (_937 > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    _936 = 0;
    int64_t _938 = 0; // k
    int64_t _939 = 0; // j
    int64_t _940 = 0; // i
    _jump986:; // Begin body of loop
    double _941 = 50.0;
    _936 += _941;
    _938++;
    if (_938 < _937)
    goto _jump986;
    _938 = 0;
    _939++;
    if (_939 < _476.d1)
    goto _jump986;
    _939 = 0;
    _940++;
    if (_940 < _934)
    goto _jump986;
    // End body of loop
    _933 += _936;
    _934++;
    if (_934 < _476.d2)
    goto _jump982;
    _934 = 0;
    _935++;
    if (_935 < _476.d1)
    goto _jump982;
    // End body of loop
    double _942;
    // Computing bound for g
    if (_476.d0 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing bound for h
    if (_476.d1 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing bound for i
    if (_476.d0 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    _942 = 0;
    int64_t _943 = 0; // i
    int64_t _944 = 0; // h
    int64_t _945 = 0; // g
    _jump990:; // Begin body of loop
    double _946 = 4.0;
    _942 += _946;
    _943++;
    if (_943 < _476.d0)
    goto _jump990;
    _943 = 0;
    _944++;
    if (_944 < _476.d1)
    goto _jump990;
    _944 = 0;
    _945++;
    if (_945 < _476.d0)
    goto _jump990;
    // End body of loop
    double _947 = -_942;
    bool _948 = _933 != _947;
    int64_t _949;
    if (!_948)
    goto _jump991;
    int64_t _950;
    // Computing bound for g
    int64_t _951;
    // Computing bound for g
    if (_476.d0 > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    // Computing bound for h
    if (_476.d2 > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing bound for i
    if (_476.d0 > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    _951 = 0;
    int64_t _952 = 0; // i
    int64_t _953 = 0; // h
    int64_t _954 = 0; // g
    _jump995:; // Begin body of loop
    _951 += _476.d1;
    _952++;
    if (_952 < _476.d0)
    goto _jump995;
    _952 = 0;
    _953++;
    if (_953 < _476.d2)
    goto _jump995;
    _953 = 0;
    _954++;
    if (_954 < _476.d0)
    goto _jump995;
    // End body of loop
    if (_951 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing bound for h
    _a2_int64_t _955;
    // Computing bound for g
    _955.d0 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump997;
    fail_assertion("non-positive loop bound");
    _jump997:;
    // Computing bound for h
    int64_t _956 = 855;
    _955.d1 = _956;
    if (_956 > 0) 
    goto _jump998;
    fail_assertion("non-positive loop bound");
    _jump998:;
    // Computing total size of heap memory to allocate
    int64_t _957 = 1;
    _957 *= _476.d2;
    _957 *= _956;
    _957 *= sizeof(int64_t);
    _955.data = jpl_alloc(_957);
    int64_t _958 = 0; // h
    int64_t _959 = 0; // g
    _jump999:; // Begin body of loop
    int64_t _960 = 43;
    int64_t _961 = 0;
    _961 *= _955.d0;
    _961 += _959;
    _961 *= _955.d1;
    _961 += _958;
    _955.data[_961] = _960;
    _958++;
    if (_958 < _956)
    goto _jump999;
    _958 = 0;
    _959++;
    if (_959 < _476.d2)
    goto _jump999;
    // End body of loop
    int64_t _962 = -_476.d2;
    if (_962 >= 0)
    goto _jump1000;
    fail_assertion("negative array index");
    _jump1000:;
    if (_962 < _955.d0)
    goto _jump1001;
    fail_assertion("index too large");
    _jump1001:;
    if (_476.d1 >= 0)
    goto _jump1002;
    fail_assertion("negative array index");
    _jump1002:;
    if (_476.d1 < _955.d1)
    goto _jump1003;
    fail_assertion("index too large");
    _jump1003:;
    int64_t _963 = 0;
    _963 *= _955.d0;
    _963 += _962;
    _963 *= _955.d1;
    _963 += _476.d1;
    int64_t _964 = _955.data[_963];
    if (_964 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    _950 = 0;
    int64_t _965 = 0; // h
    int64_t _966 = 0; // g
    _jump1005:; // Begin body of loop
    _950 += _966;
    _965++;
    if (_965 < _964)
    goto _jump1005;
    _965 = 0;
    _966++;
    if (_966 < _951)
    goto _jump1005;
    // End body of loop
    _949 = _950;
    goto _jump1006;
    _jump991:;
    int64_t _967 = -_476.d2;
    _949 = _967;
    _jump1006:;
    int64_t _968 = -_949;
    _932.d0 = _968;
    if (_968 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for h
    int64_t _969 = 570;
    _a2_int64_t _970;
    // Computing bound for g
    int64_t _971 = -_476.d2;
    _970.d0 = _971;
    if (_971 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for h
    int64_t _972 = -_476.d0;
    _970.d1 = _972;
    if (_972 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing total size of heap memory to allocate
    int64_t _973 = 1;
    _973 *= _971;
    _973 *= _972;
    _973 *= sizeof(int64_t);
    _970.data = jpl_alloc(_973);
    int64_t _974 = 0; // h
    int64_t _975 = 0; // g
    _jump1010:; // Begin body of loop
    int64_t _976 = 0;
    _976 *= _970.d0;
    _976 += _975;
    _976 *= _970.d1;
    _976 += _974;
    _970.data[_976] = _476.d1;
    _974++;
    if (_974 < _972)
    goto _jump1010;
    _974 = 0;
    _975++;
    if (_975 < _971)
    goto _jump1010;
    // End body of loop
    int64_t _977 = 599;
    int64_t _978 = -_977;
    if (_978 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (_978 < _970.d0)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    if (_476.d1 >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (_476.d1 < _970.d1)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    int64_t _979 = 0;
    _979 *= _970.d0;
    _979 += _978;
    _979 *= _970.d1;
    _979 += _476.d1;
    int64_t _980 = _970.data[_979];
    int64_t _981 = _969 % _980;
    int64_t _982 = -_981;
    _932.d1 = _982;
    if (_982 > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing bound for i
    int64_t _983 = 142;
    _932.d2 = _983;
    if (_983 > 0) 
    goto _jump1016;
    fail_assertion("non-positive loop bound");
    _jump1016:;
    // Computing total size of heap memory to allocate
    int64_t _984 = 1;
    _984 *= _968;
    _984 *= _982;
    _984 *= _983;
    _984 *= sizeof(int64_t);
    _932.data = jpl_alloc(_984);
    int64_t _985 = 0; // i
    int64_t _986 = 0; // h
    int64_t _987 = 0; // g
    _jump1017:; // Begin body of loop
    int64_t _988 = 0;
    _988 *= _932.d0;
    _988 += _987;
    _988 *= _932.d1;
    _988 += _986;
    _988 *= _932.d2;
    _988 += _985;
    _932.data[_988] = _987;
    _985++;
    if (_985 < _983)
    goto _jump1017;
    _985 = 0;
    _986++;
    if (_986 < _982)
    goto _jump1017;
    _986 = 0;
    _987++;
    if (_987 < _968)
    goto _jump1017;
    // End body of loop
    _817 = _932;
    _jump979:;
    bool _989 = false;
    _a2_bool _990;
    if (!_989)
    goto _jump1659;
    _a2_bool _991;
    // Computing bound for m
    _991.d0 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing bound for n
    _991.d1 = _476.d1;
    if (_476.d1 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing total size of heap memory to allocate
    int64_t _992 = 1;
    _992 *= _476.d0;
    _992 *= _476.d1;
    _992 *= sizeof(bool);
    _991.data = jpl_alloc(_992);
    int64_t _993 = 0; // n
    int64_t _994 = 0; // m
    _jump1662:; // Begin body of loop
    bool _997 = false;
    bool _998;
    if (!_997)
    goto _jump1663;
    int64_t _999 = 649;
    bool _1000 = _817.d0 != _999;
    _998 = _1000;
    goto _jump1664;
    _jump1663:;
    bool _1001 = false;
    _998 = _1001;
    _jump1664:;
    bool _996 = _998;
    if (0 == _998)
    goto _jump1665;
    int64_t _1002;
    // Computing bound for o
    if (_476.d2 > 0) 
    goto _jump1666;
    fail_assertion("non-positive loop bound");
    _jump1666:;
    // Computing bound for p
    if (_817.d0 > 0) 
    goto _jump1667;
    fail_assertion("non-positive loop bound");
    _jump1667:;
    // Computing bound for q
    int64_t _1003 = 19;
    if (_1003 > 0) 
    goto _jump1668;
    fail_assertion("non-positive loop bound");
    _jump1668:;
    _1002 = 0;
    int64_t _1004 = 0; // q
    int64_t _1005 = 0; // p
    int64_t _1006 = 0; // o
    _jump1669:; // Begin body of loop
    _1002 += _1005;
    _1004++;
    if (_1004 < _1003)
    goto _jump1669;
    _1004 = 0;
    _1005++;
    if (_1005 < _817.d0)
    goto _jump1669;
    _1005 = 0;
    _1006++;
    if (_1006 < _476.d2)
    goto _jump1669;
    // End body of loop
    int64_t _1007 = -_817.d1;
    if (_1002 >= 0)
    goto _jump1670;
    fail_assertion("negative array index");
    _jump1670:;
    if (_1002 < _476.d0)
    goto _jump1671;
    fail_assertion("index too large");
    _jump1671:;
    if (_994 >= 0)
    goto _jump1672;
    fail_assertion("negative array index");
    _jump1672:;
    if (_994 < _476.d1)
    goto _jump1673;
    fail_assertion("index too large");
    _jump1673:;
    if (_1007 >= 0)
    goto _jump1674;
    fail_assertion("negative array index");
    _jump1674:;
    if (_1007 < _476.d2)
    goto _jump1675;
    fail_assertion("index too large");
    _jump1675:;
    int64_t _1008 = 0;
    _1008 *= _476.d0;
    _1008 += _1002;
    _1008 *= _476.d1;
    _1008 += _994;
    _1008 *= _476.d2;
    _1008 += _1007;
    bool _1009 = _476.data[_1008];
    _996 = _1009;
    _jump1665:;
    bool _1010 = !_996;
    bool _995 = _1010;
    if (0 == _1010)
    goto _jump1676;
    bool _1011 = true;
    bool _1012 = !_1011;
    _995 = _1012;
    _jump1676:;
    int64_t _1013 = 0;
    _1013 *= _991.d0;
    _1013 += _994;
    _1013 *= _991.d1;
    _1013 += _993;
    _991.data[_1013] = _995;
    _993++;
    if (_993 < _476.d1)
    goto _jump1662;
    _993 = 0;
    _994++;
    if (_994 < _476.d0)
    goto _jump1662;
    // End body of loop
    _990 = _991;
    goto _jump1677;
    _jump1659:;
    _a1__a2_bool _1014;
    // Computing bound for m
    _1014.d0 = _817.d2;
    if (_817.d2 > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    // Computing total size of heap memory to allocate
    int64_t _1015 = 1;
    _1015 *= _817.d2;
    _1015 *= sizeof(_a2_bool);
    _1014.data = jpl_alloc(_1015);
    int64_t _1016 = 0; // m
    _jump1679:; // Begin body of loop
    bool _1017 = _476.d0 > _476.d0;
    bool _1018;
    if (!_1017)
    goto _jump1680;
    bool _1019 = true;
    _1018 = _1019;
    goto _jump1681;
    _jump1680:;
    bool _1020 = true;
    bool _1021 = !_1020;
    _1018 = _1021;
    _jump1681:;
    double _1022 = 29.0;
    double _1023 = 79.0;
    bool _1024 = _1022 != _1023;
    bool _1025 = !_1024;
    bool _1026 = _1018 != _1025;
    _a2_bool _1027;
    if (!_1026)
    goto _jump1682;
    _a2_bool _1028;
    // Computing bound for n
    _1028.d0 = _817.d1;
    if (_817.d1 > 0) 
    goto _jump1683;
    fail_assertion("non-positive loop bound");
    _jump1683:;
    // Computing bound for o
    _1028.d1 = _817.d0;
    if (_817.d0 > 0) 
    goto _jump1684;
    fail_assertion("non-positive loop bound");
    _jump1684:;
    // Computing total size of heap memory to allocate
    int64_t _1029 = 1;
    _1029 *= _817.d1;
    _1029 *= _817.d0;
    _1029 *= sizeof(bool);
    _1028.data = jpl_alloc(_1029);
    int64_t _1030 = 0; // o
    int64_t _1031 = 0; // n
    _jump1685:; // Begin body of loop
    int64_t _1032 = -_1030;
    int64_t _1033 = _1031 / _476.d1;
    bool _1034 = _1032 == _1033;
    int64_t _1035 = 0;
    _1035 *= _1028.d0;
    _1035 += _1031;
    _1035 *= _1028.d1;
    _1035 += _1030;
    _1028.data[_1035] = _1034;
    _1030++;
    if (_1030 < _817.d0)
    goto _jump1685;
    _1030 = 0;
    _1031++;
    if (_1031 < _817.d1)
    goto _jump1685;
    // End body of loop
    _1027 = _1028;
    goto _jump1686;
    _jump1682:;
    bool _1036 = false;
    _a2_bool _1037;
    if (!_1036)
    goto _jump1687;
    _a2_bool _1038;
    // Computing bound for n
    _1038.d0 = _476.d1;
    if (_476.d1 > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing bound for o
    _1038.d1 = _817.d2;
    if (_817.d2 > 0) 
    goto _jump1689;
    fail_assertion("non-positive loop bound");
    _jump1689:;
    // Computing total size of heap memory to allocate
    int64_t _1039 = 1;
    _1039 *= _476.d1;
    _1039 *= _817.d2;
    _1039 *= sizeof(bool);
    _1038.data = jpl_alloc(_1039);
    int64_t _1040 = 0; // o
    int64_t _1041 = 0; // n
    _jump1690:; // Begin body of loop
    int64_t _1042 = 845;
    bool _1043 = _817.d0 != _1042;
    int64_t _1044 = 0;
    _1044 *= _1038.d0;
    _1044 += _1041;
    _1044 *= _1038.d1;
    _1044 += _1040;
    _1038.data[_1044] = _1043;
    _1040++;
    if (_1040 < _817.d2)
    goto _jump1690;
    _1040 = 0;
    _1041++;
    if (_1041 < _476.d1)
    goto _jump1690;
    // End body of loop
    _1037 = _1038;
    goto _jump1691;
    _jump1687:;
    _a2_bool _1045;
    // Computing bound for n
    int64_t _1046 = 753;
    _1045.d0 = _1046;
    if (_1046 > 0) 
    goto _jump1692;
    fail_assertion("non-positive loop bound");
    _jump1692:;
    // Computing bound for o
    _1045.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump1693;
    fail_assertion("non-positive loop bound");
    _jump1693:;
    // Computing total size of heap memory to allocate
    int64_t _1047 = 1;
    _1047 *= _1046;
    _1047 *= _476.d2;
    _1047 *= sizeof(bool);
    _1045.data = jpl_alloc(_1047);
    int64_t _1048 = 0; // o
    int64_t _1049 = 0; // n
    _jump1694:; // Begin body of loop
    bool _1051 = false;
    bool _1050 = _1051;
    if (0 != _1051)
    goto _jump1695;
    bool _1052 = true;
    _1050 = _1052;
    _jump1695:;
    int64_t _1053 = 0;
    _1053 *= _1045.d0;
    _1053 += _1049;
    _1053 *= _1045.d1;
    _1053 += _1048;
    _1045.data[_1053] = _1050;
    _1048++;
    if (_1048 < _476.d2)
    goto _jump1694;
    _1048 = 0;
    _1049++;
    if (_1049 < _1046)
    goto _jump1694;
    // End body of loop
    _1037 = _1045;
    _jump1691:;
    _1027 = _1037;
    _jump1686:;
    int64_t _1054 = 0;
    _1054 *= _1014.d0;
    _1054 += _1016;
    _1014.data[_1054] = _1027;
    _1016++;
    if (_1016 < _817.d2)
    goto _jump1679;
    // End body of loop
    _a3_bool _1056;
    // Computing bound for m
    _1056.d0 = _817.d0;
    if (_817.d0 > 0) 
    goto _jump1696;
    fail_assertion("non-positive loop bound");
    _jump1696:;
    // Computing bound for n
    _1056.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump1697;
    fail_assertion("non-positive loop bound");
    _jump1697:;
    // Computing bound for o
    _1056.d2 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump1698;
    fail_assertion("non-positive loop bound");
    _jump1698:;
    // Computing total size of heap memory to allocate
    int64_t _1057 = 1;
    _1057 *= _817.d0;
    _1057 *= _476.d2;
    _1057 *= _476.d2;
    _1057 *= sizeof(bool);
    _1056.data = jpl_alloc(_1057);
    int64_t _1058 = 0; // o
    int64_t _1059 = 0; // n
    int64_t _1060 = 0; // m
    _jump1699:; // Begin body of loop
    bool _1061 = true;
    int64_t _1062 = 0;
    _1062 *= _1056.d0;
    _1062 += _1060;
    _1062 *= _1056.d1;
    _1062 += _1059;
    _1062 *= _1056.d2;
    _1062 += _1058;
    _1056.data[_1062] = _1061;
    _1058++;
    if (_1058 < _476.d2)
    goto _jump1699;
    _1058 = 0;
    _1059++;
    if (_1059 < _476.d2)
    goto _jump1699;
    _1059 = 0;
    _1060++;
    if (_1060 < _817.d0)
    goto _jump1699;
    // End body of loop
    int64_t _1063 = -_817.d0;
    if (_817.d1 >= 0)
    goto _jump1700;
    fail_assertion("negative array index");
    _jump1700:;
    if (_817.d1 < _1056.d0)
    goto _jump1701;
    fail_assertion("index too large");
    _jump1701:;
    if (_817.d2 >= 0)
    goto _jump1702;
    fail_assertion("negative array index");
    _jump1702:;
    if (_817.d2 < _1056.d1)
    goto _jump1703;
    fail_assertion("index too large");
    _jump1703:;
    if (_1063 >= 0)
    goto _jump1704;
    fail_assertion("negative array index");
    _jump1704:;
    if (_1063 < _1056.d2)
    goto _jump1705;
    fail_assertion("index too large");
    _jump1705:;
    int64_t _1064 = 0;
    _1064 *= _1056.d0;
    _1064 += _817.d1;
    _1064 *= _1056.d1;
    _1064 += _817.d2;
    _1064 *= _1056.d2;
    _1064 += _1063;
    bool _1065 = _1056.data[_1064];
    bool _1066;
    if (!_1065)
    goto _jump1706;
    bool _1067 = false;
    bool _1068 = !_1067;
    _1066 = _1068;
    goto _jump1707;
    _jump1706:;
    bool _1069 = true;
    _1066 = _1069;
    _jump1707:;
    bool _1055 = _1066;
    if (0 != _1066)
    goto _jump1708;
    int64_t _1070 = _817.d2 % _476.d1;
    bool _1071 = _1070 != _476.d0;
    double _1072 = 94.0;
    double _1073 = 21.0;
    bool _1074 = _1072 == _1073;
    bool _1075 = _1071 == _1074;
    _1055 = _1075;
    _jump1708:;
    int64_t _1076;
    if (!_1055)
    goto _jump1709;
    int64_t _1077;
    // Computing bound for m
    if (_476.d2 > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    _1077 = 0;
    int64_t _1078 = 0; // m
    _jump1711:; // Begin body of loop
    bool _1079 = true;
    int64_t _1080;
    if (!_1079)
    goto _jump1712;
    int64_t _1081 = -_476.d1;
    _1080 = _1081;
    goto _jump1713;
    _jump1712:;
    _1080 = _817.d0;
    _jump1713:;
    _1077 += _1080;
    _1078++;
    if (_1078 < _476.d2)
    goto _jump1711;
    // End body of loop
    _1076 = _1077;
    goto _jump1714;
    _jump1709:;
    _1076 = _817.d0;
    _jump1714:;
    if (_1076 >= 0)
    goto _jump1715;
    fail_assertion("negative array index");
    _jump1715:;
    if (_1076 < _1014.d0)
    goto _jump1716;
    fail_assertion("index too large");
    _jump1716:;
    int64_t _1082 = 0;
    _1082 *= _1014.d0;
    _1082 += _1076;
    _a2_bool _1083 = _1014.data[_1082];
    _990 = _1083;
    _jump1677:;
    bool _1084 = false;
    bool _1085 = true;
    _a1_bool _1086;
    // Computing bound for q
    _1086.d0 = _817.d0;
    if (_817.d0 > 0) 
    goto _jump1717;
    fail_assertion("non-positive loop bound");
    _jump1717:;
    // Computing total size of heap memory to allocate
    int64_t _1087 = 1;
    _1087 *= _817.d0;
    _1087 *= sizeof(bool);
    _1086.data = jpl_alloc(_1087);
    int64_t _1088 = 0; // q
    _jump1718:; // Begin body of loop
    int64_t _1090 = -_990.d1;
    int64_t _1091 = 646;
    if (_1090 >= 0)
    goto _jump1719;
    fail_assertion("negative array index");
    _jump1719:;
    if (_1090 < _476.d0)
    goto _jump1720;
    fail_assertion("index too large");
    _jump1720:;
    if (_817.d2 >= 0)
    goto _jump1721;
    fail_assertion("negative array index");
    _jump1721:;
    if (_817.d2 < _476.d1)
    goto _jump1722;
    fail_assertion("index too large");
    _jump1722:;
    if (_1091 >= 0)
    goto _jump1723;
    fail_assertion("negative array index");
    _jump1723:;
    if (_1091 < _476.d2)
    goto _jump1724;
    fail_assertion("index too large");
    _jump1724:;
    int64_t _1092 = 0;
    _1092 *= _476.d0;
    _1092 += _1090;
    _1092 *= _476.d1;
    _1092 += _817.d2;
    _1092 *= _476.d2;
    _1092 += _1091;
    bool _1093 = _476.data[_1092];
    bool _1089 = _1093;
    if (0 != _1093)
    goto _jump1725;
    bool _1094 = false;
    _1089 = _1094;
    _jump1725:;
    int64_t _1095 = 0;
    _1095 *= _1086.d0;
    _1095 += _1088;
    _1086.data[_1095] = _1089;
    _1088++;
    if (_1088 < _817.d0)
    goto _jump1718;
    // End body of loop
    if (_990.d0 >= 0)
    goto _jump1726;
    fail_assertion("negative array index");
    _jump1726:;
    if (_990.d0 < _1086.d0)
    goto _jump1727;
    fail_assertion("index too large");
    _jump1727:;
    int64_t _1096 = 0;
    _1096 *= _1086.d0;
    _1096 += _990.d0;
    bool _1097 = _1086.data[_1096];
    bool _1098 = _1085 == _1097;
    _a1_bool _1099;
    _1099.d0 = 2;
    _1099.data = jpl_alloc(sizeof(bool) * 2);
    _1099.data[0] = _1084;
    _1099.data[1] = _1098;
    double _1100 = 49.0;
    bool _1101 = _1099.d0 != _817.d2;
    _a2__a1__a1__a2_bool _1102;
    // Computing bound for z
    _1102.d0 = _817.d2;
    if (_817.d2 > 0) 
    goto _jump2154;
    fail_assertion("non-positive loop bound");
    _jump2154:;
    // Computing bound for A
    if (_1099.d0 >= 0)
    goto _jump2155;
    fail_assertion("negative array index");
    _jump2155:;
    if (_1099.d0 < _817.d0)
    goto _jump2156;
    fail_assertion("index too large");
    _jump2156:;
    if (_476.d2 >= 0)
    goto _jump2157;
    fail_assertion("negative array index");
    _jump2157:;
    if (_476.d2 < _817.d1)
    goto _jump2158;
    fail_assertion("index too large");
    _jump2158:;
    if (_476.d0 >= 0)
    goto _jump2159;
    fail_assertion("negative array index");
    _jump2159:;
    if (_476.d0 < _817.d2)
    goto _jump2160;
    fail_assertion("index too large");
    _jump2160:;
    int64_t _1103 = 0;
    _1103 *= _817.d0;
    _1103 += _1099.d0;
    _1103 *= _817.d1;
    _1103 += _476.d2;
    _1103 *= _817.d2;
    _1103 += _476.d0;
    int64_t _1104 = _817.data[_1103];
    _1102.d1 = _1104;
    if (_1104 > 0) 
    goto _jump2161;
    fail_assertion("non-positive loop bound");
    _jump2161:;
    // Computing total size of heap memory to allocate
    int64_t _1105 = 1;
    _1105 *= _817.d2;
    _1105 *= _1104;
    _1105 *= sizeof(_a1__a1__a2_bool);
    _1102.data = jpl_alloc(_1105);
    int64_t _1106 = 0; // A
    int64_t _1107 = 0; // z
    _jump2162:; // Begin body of loop
    _a1__a1__a2_bool _1108;
    // Computing bound for B
    _1108.d0 = _1099.d0;
    if (_1099.d0 > 0) 
    goto _jump2163;
    fail_assertion("non-positive loop bound");
    _jump2163:;
    // Computing total size of heap memory to allocate
    int64_t _1109 = 1;
    _1109 *= _1099.d0;
    _1109 *= sizeof(_a1__a2_bool);
    _1108.data = jpl_alloc(_1109);
    int64_t _1110 = 0; // B
    _jump2164:; // Begin body of loop
    bool _1111 = _1101;
    if (0 != _1101)
    goto _jump2165;
    bool _1112 = _817.d1 == _476.d2;
    _1111 = _1112;
    _jump2165:;
    _a1__a2_bool _1113;
    if (!_1111)
    goto _jump2166;
    _a1__a2_bool _1114;
    _1114.d0 = 1;
    _1114.data = jpl_alloc(sizeof(_a2_bool) * 1);
    _1114.data[0] = _990;
    _1113 = _1114;
    goto _jump2167;
    _jump2166:;
    _a1__a2_bool _1115;
    // Computing bound for C
    _1115.d0 = _817.d2;
    if (_817.d2 > 0) 
    goto _jump2168;
    fail_assertion("non-positive loop bound");
    _jump2168:;
    // Computing total size of heap memory to allocate
    int64_t _1116 = 1;
    _1116 *= _817.d2;
    _1116 *= sizeof(_a2_bool);
    _1115.data = jpl_alloc(_1116);
    int64_t _1117 = 0; // C
    _jump2169:; // Begin body of loop
    _a2_bool _1118;
    // Computing bound for D
    _1118.d0 = _817.d2;
    if (_817.d2 > 0) 
    goto _jump2170;
    fail_assertion("non-positive loop bound");
    _jump2170:;
    // Computing bound for E
    _1118.d1 = _817.d1;
    if (_817.d1 > 0) 
    goto _jump2171;
    fail_assertion("non-positive loop bound");
    _jump2171:;
    // Computing total size of heap memory to allocate
    int64_t _1119 = 1;
    _1119 *= _817.d2;
    _1119 *= _817.d1;
    _1119 *= sizeof(bool);
    _1118.data = jpl_alloc(_1119);
    int64_t _1120 = 0; // E
    int64_t _1121 = 0; // D
    _jump2172:; // Begin body of loop
    bool _1122 = false;
    int64_t _1123 = 0;
    _1123 *= _1118.d0;
    _1123 += _1121;
    _1123 *= _1118.d1;
    _1123 += _1120;
    _1118.data[_1123] = _1122;
    _1120++;
    if (_1120 < _817.d1)
    goto _jump2172;
    _1120 = 0;
    _1121++;
    if (_1121 < _817.d2)
    goto _jump2172;
    // End body of loop
    int64_t _1124 = 0;
    _1124 *= _1115.d0;
    _1124 += _1117;
    _1115.data[_1124] = _1118;
    _1117++;
    if (_1117 < _817.d2)
    goto _jump2169;
    // End body of loop
    _1113 = _1115;
    _jump2167:;
    int64_t _1125 = 0;
    _1125 *= _1108.d0;
    _1125 += _1110;
    _1108.data[_1125] = _1113;
    _1110++;
    if (_1110 < _1099.d0)
    goto _jump2164;
    // End body of loop
    int64_t _1126 = 0;
    _1126 *= _1102.d0;
    _1126 += _1107;
    _1126 *= _1102.d1;
    _1126 += _1106;
    _1102.data[_1126] = _1108;
    _1106++;
    if (_1106 < _1104)
    goto _jump2162;
    _1106 = 0;
    _1107++;
    if (_1107 < _817.d2)
    goto _jump2162;
    // End body of loop
    int64_t _1127 = 671;
    if (_476.d2 >= 0)
    goto _jump2173;
    fail_assertion("negative array index");
    _jump2173:;
    if (_476.d2 < _990.d0)
    goto _jump2174;
    fail_assertion("index too large");
    _jump2174:;
    if (_1127 >= 0)
    goto _jump2175;
    fail_assertion("negative array index");
    _jump2175:;
    if (_1127 < _990.d1)
    goto _jump2176;
    fail_assertion("index too large");
    _jump2176:;
    int64_t _1128 = 0;
    _1128 *= _990.d0;
    _1128 += _476.d2;
    _1128 *= _990.d1;
    _1128 += _1127;
    bool _1129 = _990.data[_1128];
    bool _1130 = !_1129;
    _a3_int64_t _1131;
    if (!_1130)
    goto _jump2177;
    _1131 = _817;
    goto _jump2178;
    _jump2177:;
    _a1__a3_int64_t _1132;
    // Computing bound for z
    int64_t _1133 = -_476.d0;
    _1132.d0 = _1133;
    if (_1133 > 0) 
    goto _jump2179;
    fail_assertion("non-positive loop bound");
    _jump2179:;
    // Computing total size of heap memory to allocate
    int64_t _1134 = 1;
    _1134 *= _1133;
    _1134 *= sizeof(_a3_int64_t);
    _1132.data = jpl_alloc(_1134);
    int64_t _1135 = 0; // z
    _jump2180:; // Begin body of loop
    int64_t _1136 = 0;
    _1136 *= _1132.d0;
    _1136 += _1135;
    _1132.data[_1136] = _817;
    _1135++;
    if (_1135 < _1133)
    goto _jump2180;
    // End body of loop
    if (_817.d0 >= 0)
    goto _jump2181;
    fail_assertion("negative array index");
    _jump2181:;
    if (_817.d0 < _1132.d0)
    goto _jump2182;
    fail_assertion("index too large");
    _jump2182:;
    int64_t _1137 = 0;
    _1137 *= _1132.d0;
    _1137 += _817.d0;
    _a3_int64_t _1138 = _1132.data[_1137];
    _1131 = _1138;
    _jump2178:;
    bool _1140 = true;
    bool _1139 = _1140;
    if (0 != _1140)
    goto _jump2183;
    bool _1141 = true;
    _1139 = _1141;
    _jump2183:;
    bool _1142 = !_1139;
    int64_t _1143;
    if (!_1142)
    goto _jump2184;
    int64_t _1144;
    // Computing bound for z
    if (_476.d0 > 0) 
    goto _jump2185;
    fail_assertion("non-positive loop bound");
    _jump2185:;
    // Computing bound for A
    bool _1145 = false;
    int64_t _1146;
    if (!_1145)
    goto _jump2186;
    _1146 = _476.d1;
    goto _jump2187;
    _jump2186:;
    _1146 = _476.d2;
    _jump2187:;
    if (_1146 > 0) 
    goto _jump2188;
    fail_assertion("non-positive loop bound");
    _jump2188:;
    _1144 = 0;
    int64_t _1147 = 0; // A
    int64_t _1148 = 0; // z
    _jump2189:; // Begin body of loop
    _1144 += _1099.d0;
    _1147++;
    if (_1147 < _1146)
    goto _jump2189;
    _1147 = 0;
    _1148++;
    if (_1148 < _476.d0)
    goto _jump2189;
    // End body of loop
    _1143 = _1144;
    goto _jump2190;
    _jump2184:;
    _1143 = _476.d0;
    _jump2190:;
    int64_t _1149 = _476.d2 * _1143;
    if (_817.d2 >= 0)
    goto _jump2191;
    fail_assertion("negative array index");
    _jump2191:;
    if (_817.d2 < _1131.d0)
    goto _jump2192;
    fail_assertion("index too large");
    _jump2192:;
    if (_476.d1 >= 0)
    goto _jump2193;
    fail_assertion("negative array index");
    _jump2193:;
    if (_476.d1 < _1131.d1)
    goto _jump2194;
    fail_assertion("index too large");
    _jump2194:;
    if (_1149 >= 0)
    goto _jump2195;
    fail_assertion("negative array index");
    _jump2195:;
    if (_1149 < _1131.d2)
    goto _jump2196;
    fail_assertion("index too large");
    _jump2196:;
    int64_t _1150 = 0;
    _1150 *= _1131.d0;
    _1150 += _817.d2;
    _1150 *= _1131.d1;
    _1150 += _476.d1;
    _1150 *= _1131.d2;
    _1150 += _1149;
    int64_t _1151 = _1131.data[_1150];
    if (_1151 >= 0)
    goto _jump2197;
    fail_assertion("negative array index");
    _jump2197:;
    if (_1151 < _1102.d0)
    goto _jump2198;
    fail_assertion("index too large");
    _jump2198:;
    if (_476.d0 >= 0)
    goto _jump2199;
    fail_assertion("negative array index");
    _jump2199:;
    if (_476.d0 < _1102.d1)
    goto _jump2200;
    fail_assertion("index too large");
    _jump2200:;
    int64_t _1152 = 0;
    _1152 *= _1102.d0;
    _1152 += _1151;
    _1152 *= _1102.d1;
    _1152 += _476.d0;
    _a1__a1__a2_bool _1153 = _1102.data[_1152];
    _a3_rgba _1154;
    // Computing bound for z
    int64_t _1155;
    // Computing bound for z
    int64_t _1156 = -_476.d2;
    if (_1156 > 0) 
    goto _jump2201;
    fail_assertion("non-positive loop bound");
    _jump2201:;
    _1155 = 0;
    int64_t _1157 = 0; // z
    _jump2202:; // Begin body of loop
    bool _1158;
    if (!_1101)
    goto _jump2203;
    bool _1159 = true;
    bool _1160 = !_1159;
    _1158 = _1160;
    goto _jump2204;
    _jump2203:;
    bool _1161 = false;
    bool _1162 = !_1161;
    _1158 = _1162;
    _jump2204:;
    int64_t _1163;
    if (!_1158)
    goto _jump2205;
    int64_t _1164 = 28;
    _1163 = _1164;
    goto _jump2206;
    _jump2205:;
    int64_t _1165 = 325;
    _1163 = _1165;
    _jump2206:;
    _1155 += _1163;
    _1157++;
    if (_1157 < _1156)
    goto _jump2202;
    // End body of loop
    int64_t _1166 = _1155 + _476.d0;
    _1154.d0 = _1166;
    if (_1166 > 0) 
    goto _jump2207;
    fail_assertion("non-positive loop bound");
    _jump2207:;
    // Computing bound for A
    _a1_bool _1167;
    _1167.d0 = 2;
    _1167.data = jpl_alloc(sizeof(bool) * 2);
    _1167.data[0] = _1101;
    _1167.data[1] = _1101;
    if (_817.d2 >= 0)
    goto _jump2208;
    fail_assertion("negative array index");
    _jump2208:;
    if (_817.d2 < _1167.d0)
    goto _jump2209;
    fail_assertion("index too large");
    _jump2209:;
    int64_t _1168 = 0;
    _1168 *= _1167.d0;
    _1168 += _817.d2;
    bool _1169 = _1167.data[_1168];
    bool _1170 = !_1169;
    int64_t _1171;
    if (!_1170)
    goto _jump2210;
    int64_t _1172;
    // Computing bound for z
    if (_817.d2 > 0) 
    goto _jump2211;
    fail_assertion("non-positive loop bound");
    _jump2211:;
    // Computing bound for A
    int64_t _1173 = -_476.d0;
    if (_1173 > 0) 
    goto _jump2212;
    fail_assertion("non-positive loop bound");
    _jump2212:;
    // Computing bound for B
    int64_t _1174 = -_476.d2;
    if (_1174 > 0) 
    goto _jump2213;
    fail_assertion("non-positive loop bound");
    _jump2213:;
    _1172 = 0;
    int64_t _1175 = 0; // B
    int64_t _1176 = 0; // A
    int64_t _1177 = 0; // z
    _jump2214:; // Begin body of loop
    int64_t _1178;
    // Computing bound for C
    if (_476.d0 > 0) 
    goto _jump2215;
    fail_assertion("non-positive loop bound");
    _jump2215:;
    // Computing bound for D
    if (_1099.d0 > 0) 
    goto _jump2216;
    fail_assertion("non-positive loop bound");
    _jump2216:;
    _1178 = 0;
    int64_t _1179 = 0; // D
    int64_t _1180 = 0; // C
    _jump2217:; // Begin body of loop
    _a2_int64_t _1181;
    // Computing bound for E
    _1181.d0 = _1175;
    if (_1175 > 0) 
    goto _jump2218;
    fail_assertion("non-positive loop bound");
    _jump2218:;
    // Computing bound for F
    int64_t _1182 = 554;
    _1181.d1 = _1182;
    if (_1182 > 0) 
    goto _jump2219;
    fail_assertion("non-positive loop bound");
    _jump2219:;
    // Computing total size of heap memory to allocate
    int64_t _1183 = 1;
    _1183 *= _1175;
    _1183 *= _1182;
    _1183 *= sizeof(int64_t);
    _1181.data = jpl_alloc(_1183);
    int64_t _1184 = 0; // F
    int64_t _1185 = 0; // E
    _jump2220:; // Begin body of loop
    int64_t _1186 = 0;
    _1186 *= _1181.d0;
    _1186 += _1185;
    _1186 *= _1181.d1;
    _1186 += _1184;
    _1181.data[_1186] = _1177;
    _1184++;
    if (_1184 < _1182)
    goto _jump2220;
    _1184 = 0;
    _1185++;
    if (_1185 < _1175)
    goto _jump2220;
    // End body of loop
    int64_t _1187 = -_1177;
    if (_1187 >= 0)
    goto _jump2221;
    fail_assertion("negative array index");
    _jump2221:;
    if (_1187 < _1181.d0)
    goto _jump2222;
    fail_assertion("index too large");
    _jump2222:;
    if (_817.d2 >= 0)
    goto _jump2223;
    fail_assertion("negative array index");
    _jump2223:;
    if (_817.d2 < _1181.d1)
    goto _jump2224;
    fail_assertion("index too large");
    _jump2224:;
    int64_t _1188 = 0;
    _1188 *= _1181.d0;
    _1188 += _1187;
    _1188 *= _1181.d1;
    _1188 += _817.d2;
    int64_t _1189 = _1181.data[_1188];
    _1178 += _1189;
    _1179++;
    if (_1179 < _1099.d0)
    goto _jump2217;
    _1179 = 0;
    _1180++;
    if (_1180 < _476.d0)
    goto _jump2217;
    // End body of loop
    _1172 += _1178;
    _1175++;
    if (_1175 < _1174)
    goto _jump2214;
    _1175 = 0;
    _1176++;
    if (_1176 < _1173)
    goto _jump2214;
    _1176 = 0;
    _1177++;
    if (_1177 < _817.d2)
    goto _jump2214;
    // End body of loop
    _1171 = _1172;
    goto _jump2225;
    _jump2210:;
    int64_t _1190 = -_817.d0;
    _1171 = _1190;
    _jump2225:;
    _1154.d1 = _1171;
    if (_1171 > 0) 
    goto _jump2226;
    fail_assertion("non-positive loop bound");
    _jump2226:;
    // Computing bound for B
    _1154.d2 = _817.d0;
    if (_817.d0 > 0) 
    goto _jump2227;
    fail_assertion("non-positive loop bound");
    _jump2227:;
    // Computing total size of heap memory to allocate
    int64_t _1191 = 1;
    _1191 *= _1166;
    _1191 *= _1171;
    _1191 *= _817.d0;
    _1191 *= sizeof(rgba);
    _1154.data = jpl_alloc(_1191);
    int64_t _1192 = 0; // B
    int64_t _1193 = 0; // A
    int64_t _1194 = 0; // z
    _jump2228:; // Begin body of loop
    double _1195;
    // Computing bound for C
    if (_1194 > 0) 
    goto _jump2229;
    fail_assertion("non-positive loop bound");
    _jump2229:;
    // Computing bound for D
    if (_817.d2 > 0) 
    goto _jump2230;
    fail_assertion("non-positive loop bound");
    _jump2230:;
    _1195 = 0;
    int64_t _1196 = 0; // D
    int64_t _1197 = 0; // C
    _jump2231:; // Begin body of loop
    double _1198;
    // Computing bound for E
    if (_476.d1 > 0) 
    goto _jump2232;
    fail_assertion("non-positive loop bound");
    _jump2232:;
    // Computing bound for F
    if (_476.d1 > 0) 
    goto _jump2233;
    fail_assertion("non-positive loop bound");
    _jump2233:;
    // Computing bound for G
    int64_t _1199;
    // Computing bound for E
    if (_1192 > 0) 
    goto _jump2234;
    fail_assertion("non-positive loop bound");
    _jump2234:;
    // Computing bound for F
    if (_1193 > 0) 
    goto _jump2235;
    fail_assertion("non-positive loop bound");
    _jump2235:;
    _1199 = 0;
    int64_t _1200 = 0; // F
    int64_t _1201 = 0; // E
    _jump2236:; // Begin body of loop
    _1199 += _990.d0;
    _1200++;
    if (_1200 < _1193)
    goto _jump2236;
    _1200 = 0;
    _1201++;
    if (_1201 < _1192)
    goto _jump2236;
    // End body of loop
    if (_1199 > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    _1198 = 0;
    int64_t _1202 = 0; // G
    int64_t _1203 = 0; // F
    int64_t _1204 = 0; // E
    _jump2238:; // Begin body of loop
    _a1_double _1205;
    // Computing bound for H
    _1205.d0 = _1202;
    if (_1202 > 0) 
    goto _jump2239;
    fail_assertion("non-positive loop bound");
    _jump2239:;
    // Computing total size of heap memory to allocate
    int64_t _1206 = 1;
    _1206 *= _1202;
    _1206 *= sizeof(double);
    _1205.data = jpl_alloc(_1206);
    int64_t _1207 = 0; // H
    _jump2240:; // Begin body of loop
    double _1208 = 12.0;
    int64_t _1209 = 0;
    _1209 *= _1205.d0;
    _1209 += _1207;
    _1205.data[_1209] = _1208;
    _1207++;
    if (_1207 < _1202)
    goto _jump2240;
    // End body of loop
    if (_1099.d0 >= 0)
    goto _jump2241;
    fail_assertion("negative array index");
    _jump2241:;
    if (_1099.d0 < _1205.d0)
    goto _jump2242;
    fail_assertion("index too large");
    _jump2242:;
    int64_t _1210 = 0;
    _1210 *= _1205.d0;
    _1210 += _1099.d0;
    double _1211 = _1205.data[_1210];
    _1198 += _1211;
    _1202++;
    if (_1202 < _1199)
    goto _jump2238;
    _1202 = 0;
    _1203++;
    if (_1203 < _476.d1)
    goto _jump2238;
    _1203 = 0;
    _1204++;
    if (_1204 < _476.d1)
    goto _jump2238;
    // End body of loop
    _1195 += _1198;
    _1196++;
    if (_1196 < _817.d2)
    goto _jump2231;
    _1196 = 0;
    _1197++;
    if (_1197 < _1194)
    goto _jump2231;
    // End body of loop
    bool _1212 = false;
    rgba _1213;
    if (!_1212)
    goto _jump2243;
    double _1214 = 20.0;
    double _1215 = 43.0;
    rgba _1216 = { _1214, _1100, _1100, _1215 };
    _1213 = _1216;
    goto _jump2244;
    _jump2243:;
    double _1217 = 55.0;
    double _1218 = 72.0;
    double _1219 = _1100 * _1218;
    double _1220 = 77.0;
    double _1221 = -_1220;
    double _1222 = 91.0;
    rgba _1223 = { _1217, _1219, _1221, _1222 };
    _1213 = _1223;
    _jump2244:;
    double _1224 = _1213.r;
    bool _1226 = false;
    bool _1225 = _1226;
    if (0 == _1226)
    goto _jump2245;
    _1225 = _1101;
    _jump2245:;
    bool _1227;
    if (!_1225)
    goto _jump2246;
    _1227 = _1101;
    goto _jump2247;
    _jump2246:;
    bool _1228 = _1194 != _990.d0;
    _1227 = _1228;
    _jump2247:;
    bool _1229 = !_1227;
    double _1230;
    if (!_1229)
    goto _jump2248;
    p _1231 = w(_476);
    double _1232 = _1231.a;
    _1230 = _1232;
    goto _jump2249;
    _jump2248:;
    double _1233;
    // Computing bound for C
    if (_817.d2 > 0) 
    goto _jump2250;
    fail_assertion("non-positive loop bound");
    _jump2250:;
    // Computing bound for D
    int64_t _1234 = _1192 / _1099.d0;
    if (_1234 > 0) 
    goto _jump2251;
    fail_assertion("non-positive loop bound");
    _jump2251:;
    _1233 = 0;
    int64_t _1235 = 0; // D
    int64_t _1236 = 0; // C
    _jump2252:; // Begin body of loop
    double _1237 = 75.0;
    double _1238 = -_1237;
    _1233 += _1238;
    _1235++;
    if (_1235 < _1234)
    goto _jump2252;
    _1235 = 0;
    _1236++;
    if (_1236 < _817.d2)
    goto _jump2252;
    // End body of loop
    double _1239 = -_1100;
    double _1240 = -_1239;
    double _1241 = _1233 * _1240;
    _1230 = _1241;
    _jump2249:;
    _a2_p _1242;
    // Computing bound for C
    int64_t _1243 = -_817.d1;
    _1242.d0 = _1243;
    if (_1243 > 0) 
    goto _jump2253;
    fail_assertion("non-positive loop bound");
    _jump2253:;
    // Computing bound for D
    _1242.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump2254;
    fail_assertion("non-positive loop bound");
    _jump2254:;
    // Computing total size of heap memory to allocate
    int64_t _1244 = 1;
    _1244 *= _1243;
    _1244 *= _476.d2;
    _1244 *= sizeof(p);
    _1242.data = jpl_alloc(_1244);
    int64_t _1245 = 0; // D
    int64_t _1246 = 0; // C
    _jump2255:; // Begin body of loop
    p _1247 = w(_476);
    int64_t _1248 = 0;
    _1248 *= _1242.d0;
    _1248 += _1246;
    _1248 *= _1242.d1;
    _1248 += _1245;
    _1242.data[_1248] = _1247;
    _1245++;
    if (_1245 < _476.d2)
    goto _jump2255;
    _1245 = 0;
    _1246++;
    if (_1246 < _1243)
    goto _jump2255;
    // End body of loop
    if (_1192 >= 0)
    goto _jump2256;
    fail_assertion("negative array index");
    _jump2256:;
    if (_1192 < _1242.d0)
    goto _jump2257;
    fail_assertion("index too large");
    _jump2257:;
    if (_990.d1 >= 0)
    goto _jump2258;
    fail_assertion("negative array index");
    _jump2258:;
    if (_990.d1 < _1242.d1)
    goto _jump2259;
    fail_assertion("index too large");
    _jump2259:;
    int64_t _1249 = 0;
    _1249 *= _1242.d0;
    _1249 += _1192;
    _1249 *= _1242.d1;
    _1249 += _990.d1;
    p _1250 = _1242.data[_1249];
    double _1251 = _1250.a;
    rgba _1252 = { _1195, _1224, _1230, _1251 };
    int64_t _1253 = 0;
    _1253 *= _1154.d0;
    _1253 += _1194;
    _1253 *= _1154.d1;
    _1253 += _1193;
    _1253 *= _1154.d2;
    _1253 += _1192;
    _1154.data[_1253] = _1252;
    _1192++;
    if (_1192 < _817.d0)
    goto _jump2228;
    _1192 = 0;
    _1193++;
    if (_1193 < _1171)
    goto _jump2228;
    _1193 = 0;
    _1194++;
    if (_1194 < _1166)
    goto _jump2228;
    // End body of loop
    _a3__a3_int64_t _1254 = f(_1153, _1154);
    _a3_bool _1255;
    // Computing bound for A
    int64_t _1256 = 563;
    int64_t _1257 = -_1256;
    int64_t _1258 = _817.d1 / _1257;
    _1255.d0 = _1258;
    if (_1258 > 0) 
    goto _jump2260;
    fail_assertion("non-positive loop bound");
    _jump2260:;
    // Computing bound for B
    _1255.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump2261;
    fail_assertion("non-positive loop bound");
    _jump2261:;
    // Computing bound for C
    int64_t _1259;
    // Computing bound for A
    if (_817.d2 > 0) 
    goto _jump2262;
    fail_assertion("non-positive loop bound");
    _jump2262:;
    // Computing bound for B
    if (_990.d0 > 0) 
    goto _jump2263;
    fail_assertion("non-positive loop bound");
    _jump2263:;
    _1259 = 0;
    int64_t _1260 = 0; // B
    int64_t _1261 = 0; // A
    _jump2264:; // Begin body of loop
    int64_t _1262 = -_476.d1;
    _1259 += _1262;
    _1260++;
    if (_1260 < _990.d0)
    goto _jump2264;
    _1260 = 0;
    _1261++;
    if (_1261 < _817.d2)
    goto _jump2264;
    // End body of loop
    _1255.d2 = _1259;
    if (_1259 > 0) 
    goto _jump2265;
    fail_assertion("non-positive loop bound");
    _jump2265:;
    // Computing total size of heap memory to allocate
    int64_t _1263 = 1;
    _1263 *= _1258;
    _1263 *= _476.d2;
    _1263 *= _1259;
    _1263 *= sizeof(bool);
    _1255.data = jpl_alloc(_1263);
    int64_t _1264 = 0; // C
    int64_t _1265 = 0; // B
    int64_t _1266 = 0; // A
    _jump2266:; // Begin body of loop
    bool _1267 = _1101;
    if (0 == _1101)
    goto _jump2267;
    _1267 = _1101;
    _jump2267:;
    bool _1268 = !_1267;
    double _1269;
    if (!_1268)
    goto _jump2268;
    double _1270 = -_1100;
    double _1271 = -_1270;
    _1269 = _1271;
    goto _jump2269;
    _jump2268:;
    double _1272 = 46.0;
    _1269 = _1272;
    _jump2269:;
    double _1273 = 17.0;
    bool _1274 = _1269 == _1273;
    bool _1275;
    if (!_1274)
    goto _jump2270;
    _1275 = _1101;
    goto _jump2271;
    _jump2270:;
    bool _1277 = true;
    bool _1276 = _1277;
    if (0 != _1277)
    goto _jump2272;
    double _1278 = 35.0;
    bool _1279 = _1278 < _1100;
    _1276 = _1279;
    _jump2272:;
    double _1280 = -_1100;
    double _1281 = 90.0;
    bool _1282 = _1280 == _1281;
    bool _1283 = _1276 == _1282;
    _1275 = _1283;
    _jump2271:;
    int64_t _1284 = 0;
    _1284 *= _1255.d0;
    _1284 += _1266;
    _1284 *= _1255.d1;
    _1284 += _1265;
    _1284 *= _1255.d2;
    _1284 += _1264;
    _1255.data[_1284] = _1275;
    _1264++;
    if (_1264 < _1259)
    goto _jump2266;
    _1264 = 0;
    _1265++;
    if (_1265 < _476.d2)
    goto _jump2266;
    _1265 = 0;
    _1266++;
    if (_1266 < _1258)
    goto _jump2266;
    // End body of loop
    p _1285 = w(_1255);
    if (_817.d0 >= 0)
    goto _jump2273;
    fail_assertion("negative array index");
    _jump2273:;
    if (_817.d0 < _1099.d0)
    goto _jump2274;
    fail_assertion("index too large");
    _jump2274:;
    int64_t _1286 = 0;
    _1286 *= _1099.d0;
    _1286 += _817.d0;
    bool _1287 = _1099.data[_1286];
    bool _1288;
    if (!_1287)
    goto _jump2275;
    double _1289 = 42.0;
    double _1290 = 67.0;
    bool _1291 = _1289 < _1290;
    _1288 = _1291;
    goto _jump2276;
    _jump2275:;
    int64_t _1292 = 84;
    bool _1293 = _476.d2 == _1292;
    _1288 = _1293;
    _jump2276:;
    bool _1294;
    if (!_1288)
    goto _jump2277;
    bool _1295 = true;
    _1294 = _1295;
    goto _jump2278;
    _jump2277:;
    bool _1297 = _476.d0 == _476.d0;
    bool _1296 = _1297;
    if (0 != _1297)
    goto _jump2279;
    bool _1298 = _990.d1 > _476.d2;
    _1296 = _1298;
    _jump2279:;
    _1294 = _1296;
    _jump2278:;
    _a3__a2_rgba _1299;
    if (!_1294)
    goto _jump2280;
    _a3__a2_rgba _1300;
    // Computing bound for B
    _1300.d0 = _817.d1;
    if (_817.d1 > 0) 
    goto _jump2281;
    fail_assertion("non-positive loop bound");
    _jump2281:;
    // Computing bound for C
    _1300.d1 = _817.d1;
    if (_817.d1 > 0) 
    goto _jump2282;
    fail_assertion("non-positive loop bound");
    _jump2282:;
    // Computing bound for D
    _1300.d2 = _1099.d0;
    if (_1099.d0 > 0) 
    goto _jump2283;
    fail_assertion("non-positive loop bound");
    _jump2283:;
    // Computing total size of heap memory to allocate
    int64_t _1301 = 1;
    _1301 *= _817.d1;
    _1301 *= _817.d1;
    _1301 *= _1099.d0;
    _1301 *= sizeof(_a2_rgba);
    _1300.data = jpl_alloc(_1301);
    int64_t _1302 = 0; // D
    int64_t _1303 = 0; // C
    int64_t _1304 = 0; // B
    _jump2284:; // Begin body of loop
    _a2_rgba _1305;
    // Computing bound for E
    _1305.d0 = _476.d0;
    if (_476.d0 > 0) 
    goto _jump2285;
    fail_assertion("non-positive loop bound");
    _jump2285:;
    // Computing bound for F
    _1305.d1 = _817.d0;
    if (_817.d0 > 0) 
    goto _jump2286;
    fail_assertion("non-positive loop bound");
    _jump2286:;
    // Computing total size of heap memory to allocate
    int64_t _1306 = 1;
    _1306 *= _476.d0;
    _1306 *= _817.d0;
    _1306 *= sizeof(rgba);
    _1305.data = jpl_alloc(_1306);
    int64_t _1307 = 0; // F
    int64_t _1308 = 0; // E
    _jump2287:; // Begin body of loop
    double _1309 = 98.0;
    rgba _1310 = { _1100, _1100, _1309, _1100 };
    int64_t _1311 = 0;
    _1311 *= _1305.d0;
    _1311 += _1308;
    _1311 *= _1305.d1;
    _1311 += _1307;
    _1305.data[_1311] = _1310;
    _1307++;
    if (_1307 < _817.d0)
    goto _jump2287;
    _1307 = 0;
    _1308++;
    if (_1308 < _476.d0)
    goto _jump2287;
    // End body of loop
    int64_t _1312 = 0;
    _1312 *= _1300.d0;
    _1312 += _1304;
    _1312 *= _1300.d1;
    _1312 += _1303;
    _1312 *= _1300.d2;
    _1312 += _1302;
    _1300.data[_1312] = _1305;
    _1302++;
    if (_1302 < _1099.d0)
    goto _jump2284;
    _1302 = 0;
    _1303++;
    if (_1303 < _817.d1)
    goto _jump2284;
    _1303 = 0;
    _1304++;
    if (_1304 < _817.d1)
    goto _jump2284;
    // End body of loop
    _1299 = _1300;
    goto _jump2288;
    _jump2280:;
    _a3__a2_rgba _1313;
    // Computing bound for B
    int64_t _1314 = _476.d2 / _476.d0;
    _1313.d0 = _1314;
    if (_1314 > 0) 
    goto _jump2289;
    fail_assertion("non-positive loop bound");
    _jump2289:;
    // Computing bound for C
    int64_t _1315 = -_817.d1;
    _1313.d1 = _1315;
    if (_1315 > 0) 
    goto _jump2290;
    fail_assertion("non-positive loop bound");
    _jump2290:;
    // Computing bound for D
    _a3_int64_t _1316;
    // Computing bound for B
    int64_t _1317 = 479;
    _1316.d0 = _1317;
    if (_1317 > 0) 
    goto _jump2291;
    fail_assertion("non-positive loop bound");
    _jump2291:;
    // Computing bound for C
    _1316.d1 = _1099.d0;
    if (_1099.d0 > 0) 
    goto _jump2292;
    fail_assertion("non-positive loop bound");
    _jump2292:;
    // Computing bound for D
    _1316.d2 = _476.d1;
    if (_476.d1 > 0) 
    goto _jump2293;
    fail_assertion("non-positive loop bound");
    _jump2293:;
    // Computing total size of heap memory to allocate
    int64_t _1318 = 1;
    _1318 *= _1317;
    _1318 *= _1099.d0;
    _1318 *= _476.d1;
    _1318 *= sizeof(int64_t);
    _1316.data = jpl_alloc(_1318);
    int64_t _1319 = 0; // D
    int64_t _1320 = 0; // C
    int64_t _1321 = 0; // B
    _jump2294:; // Begin body of loop
    int64_t _1322 = 0;
    _1322 *= _1316.d0;
    _1322 += _1321;
    _1322 *= _1316.d1;
    _1322 += _1320;
    _1322 *= _1316.d2;
    _1322 += _1319;
    _1316.data[_1322] = _1319;
    _1319++;
    if (_1319 < _476.d1)
    goto _jump2294;
    _1319 = 0;
    _1320++;
    if (_1320 < _1099.d0)
    goto _jump2294;
    _1320 = 0;
    _1321++;
    if (_1321 < _1317)
    goto _jump2294;
    // End body of loop
    int64_t _1323 = 649;
    int64_t _1324;
    // Computing bound for B
    if (_990.d0 > 0) 
    goto _jump2295;
    fail_assertion("non-positive loop bound");
    _jump2295:;
    // Computing bound for C
    if (_476.d0 > 0) 
    goto _jump2296;
    fail_assertion("non-positive loop bound");
    _jump2296:;
    // Computing bound for D
    if (_817.d2 > 0) 
    goto _jump2297;
    fail_assertion("non-positive loop bound");
    _jump2297:;
    _1324 = 0;
    int64_t _1325 = 0; // D
    int64_t _1326 = 0; // C
    int64_t _1327 = 0; // B
    _jump2298:; // Begin body of loop
    _1324 += _1326;
    _1325++;
    if (_1325 < _817.d2)
    goto _jump2298;
    _1325 = 0;
    _1326++;
    if (_1326 < _476.d0)
    goto _jump2298;
    _1326 = 0;
    _1327++;
    if (_1327 < _990.d0)
    goto _jump2298;
    // End body of loop
    if (_1323 >= 0)
    goto _jump2299;
    fail_assertion("negative array index");
    _jump2299:;
    if (_1323 < _1316.d0)
    goto _jump2300;
    fail_assertion("index too large");
    _jump2300:;
    if (_1324 >= 0)
    goto _jump2301;
    fail_assertion("negative array index");
    _jump2301:;
    if (_1324 < _1316.d1)
    goto _jump2302;
    fail_assertion("index too large");
    _jump2302:;
    if (_1099.d0 >= 0)
    goto _jump2303;
    fail_assertion("negative array index");
    _jump2303:;
    if (_1099.d0 < _1316.d2)
    goto _jump2304;
    fail_assertion("index too large");
    _jump2304:;
    int64_t _1328 = 0;
    _1328 *= _1316.d0;
    _1328 += _1323;
    _1328 *= _1316.d1;
    _1328 += _1324;
    _1328 *= _1316.d2;
    _1328 += _1099.d0;
    int64_t _1329 = _1316.data[_1328];
    _1313.d2 = _1329;
    if (_1329 > 0) 
    goto _jump2305;
    fail_assertion("non-positive loop bound");
    _jump2305:;
    // Computing total size of heap memory to allocate
    int64_t _1330 = 1;
    _1330 *= _1314;
    _1330 *= _1315;
    _1330 *= _1329;
    _1330 *= sizeof(_a2_rgba);
    _1313.data = jpl_alloc(_1330);
    int64_t _1331 = 0; // D
    int64_t _1332 = 0; // C
    int64_t _1333 = 0; // B
    _jump2306:; // Begin body of loop
    _a2_rgba _1334;
    // Computing bound for E
    int64_t _1335 = -_817.d2;
    _1334.d0 = _1335;
    if (_1335 > 0) 
    goto _jump2307;
    fail_assertion("non-positive loop bound");
    _jump2307:;
    // Computing bound for F
    _1334.d1 = _476.d2;
    if (_476.d2 > 0) 
    goto _jump2308;
    fail_assertion("non-positive loop bound");
    _jump2308:;
    // Computing total size of heap memory to allocate
    int64_t _1336 = 1;
    _1336 *= _1335;
    _1336 *= _476.d2;
    _1336 *= sizeof(rgba);
    _1334.data = jpl_alloc(_1336);
    int64_t _1337 = 0; // F
    int64_t _1338 = 0; // E
    _jump2309:; // Begin body of loop
    double _1339 = 15.0;
    double _1340 = 34.0;
    double _1341 = 95.0;
    rgba _1342 = { _1339, _1340, _1341, _1100 };
    int64_t _1343 = 0;
    _1343 *= _1334.d0;
    _1343 += _1338;
    _1343 *= _1334.d1;
    _1343 += _1337;
    _1334.data[_1343] = _1342;
    _1337++;
    if (_1337 < _476.d2)
    goto _jump2309;
    _1337 = 0;
    _1338++;
    if (_1338 < _1335)
    goto _jump2309;
    // End body of loop
    int64_t _1344 = 0;
    _1344 *= _1313.d0;
    _1344 += _1333;
    _1344 *= _1313.d1;
    _1344 += _1332;
    _1344 *= _1313.d2;
    _1344 += _1331;
    _1313.data[_1344] = _1334;
    _1331++;
    if (_1331 < _1329)
    goto _jump2306;
    _1331 = 0;
    _1332++;
    if (_1332 < _1315)
    goto _jump2306;
    _1332 = 0;
    _1333++;
    if (_1333 < _1314)
    goto _jump2306;
    // End body of loop
    _1299 = _1313;
    _jump2288:;
    _a1__a3__a2_rgba _1345;
    _1345.d0 = 1;
    _1345.data = jpl_alloc(sizeof(_a3__a2_rgba) * 1);
    _1345.data[0] = _1299;
    int64_t _1346 = -_1099.d0;
    if (_1346 >= 0)
    goto _jump2310;
    fail_assertion("negative array index");
    _jump2310:;
    if (_1346 < _1345.d0)
    goto _jump2311;
    fail_assertion("index too large");
    _jump2311:;
    int64_t _1347 = 0;
    _1347 *= _1345.d0;
    _1347 += _1346;
    _a3__a2_rgba _1348 = _1345.data[_1347];
    if (_817.d0 >= 0)
    goto _jump2312;
    fail_assertion("negative array index");
    _jump2312:;
    if (_817.d0 < _1348.d0)
    goto _jump2313;
    fail_assertion("index too large");
    _jump2313:;
    if (_817.d1 >= 0)
    goto _jump2314;
    fail_assertion("negative array index");
    _jump2314:;
    if (_817.d1 < _1348.d1)
    goto _jump2315;
    fail_assertion("index too large");
    _jump2315:;
    if (_817.d2 >= 0)
    goto _jump2316;
    fail_assertion("negative array index");
    _jump2316:;
    if (_817.d2 < _1348.d2)
    goto _jump2317;
    fail_assertion("index too large");
    _jump2317:;
    int64_t _1349 = 0;
    _1349 *= _1348.d0;
    _1349 += _817.d0;
    _1349 *= _1348.d1;
    _1349 += _817.d1;
    _1349 *= _1348.d2;
    _1349 += _817.d2;
    _a2_rgba _1350 = _1348.data[_1349];
    write_image(_1350, "B.png");
    double _1351 = get_time();
    double _1352 = get_time();
    print_time(_1352 - _1351);
}

