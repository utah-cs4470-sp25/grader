
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_rgba *data;
} _a3__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_rgba *data;
} _a3__a3__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2_rgba *data;
} _a3__a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  _a3_rgba *data;
} _a1__a3_rgba;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_rgba *data;
} _a2__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
    _a3_bool a;
} e;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  _a2__a3_rgba *data;
} _a1__a2__a3_rgba;

typedef struct {
  int64_t d0;
  _a2_void_t *data;
} _a1__a2_void_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  e *data;
} _a2_e;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
    rgba a;
} i;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  _a1__a3_bool *data;
} _a1__a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  i *data;
} _a1_i;

typedef struct {
  int64_t d0;
  _a2_e *data;
} _a1__a2_e;

int64_t b(_a3_rgba c, _a1_bool g, _a2_rgba i) {
    return g.d0;
    bool _0 = false;
    _a3_int64_t _1;
    // Computing bound for m
    _1.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    // Computing bound for n
    _1.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing bound for o
    _1.d2 = c.d1;
    if (c.d1 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= c.d1;
    _2 *= c.d1;
    _2 *= c.d1;
    _2 *= sizeof(int64_t);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // o
    int64_t _4 = 0; // n
    int64_t _5 = 0; // m
    _jump236:; // Begin body of loop
    int64_t _6 = 0;
    _6 *= _1.d0;
    _6 += _5;
    _6 *= _1.d1;
    _6 += _4;
    _6 *= _1.d2;
    _6 += _3;
    _1.data[_6] = c.d0;
    _3++;
    if (_3 < c.d1)
    goto _jump236;
    _3 = 0;
    _4++;
    if (_4 < c.d1)
    goto _jump236;
    _4 = 0;
    _5++;
    if (_5 < c.d1)
    goto _jump236;
    // End body of loop
    _a3__a1_bool _7;
    // Computing bound for q
    int64_t _8;
    // Computing bound for q
    if (g.d0 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing bound for r
    int64_t _9 = 832;
    if (_9 > 0) 
    goto _jump238;
    fail_assertion("non-positive loop bound");
    _jump238:;
    _8 = 0;
    int64_t _10 = 0; // r
    int64_t _11 = 0; // q
    _jump239:; // Begin body of loop
    int64_t _12 = i.d0 / _11;
    _8 += _12;
    _10++;
    if (_10 < _9)
    goto _jump239;
    _10 = 0;
    _11++;
    if (_11 < g.d0)
    goto _jump239;
    // End body of loop
    _7.d0 = _8;
    if (_8 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    // Computing bound for r
    _7.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing bound for s
    _7.d2 = c.d2;
    if (c.d2 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _8;
    _13 *= i.d0;
    _13 *= c.d2;
    _13 *= sizeof(_a1_bool);
    _7.data = jpl_alloc(_13);
    int64_t _14 = 0; // s
    int64_t _15 = 0; // r
    int64_t _16 = 0; // q
    _jump243:; // Begin body of loop
    bool _17 = false;
    double _18;
    if (!_17)
    goto _jump244;
    double _19;
    // Computing bound for t
    if (i.d0 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing bound for u
    int64_t _20 = 982;
    if (_20 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing bound for v
    if (c.d2 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    _19 = 0;
    int64_t _21 = 0; // v
    int64_t _22 = 0; // u
    int64_t _23 = 0; // t
    _jump248:; // Begin body of loop
    double _24 = 93.0;
    double _25 = -_24;
    _19 += _25;
    _21++;
    if (_21 < c.d2)
    goto _jump248;
    _21 = 0;
    _22++;
    if (_22 < _20)
    goto _jump248;
    _22 = 0;
    _23++;
    if (_23 < i.d0)
    goto _jump248;
    // End body of loop
    _18 = _19;
    goto _jump249;
    _jump244:;
    double _26 = 22.0;
    _a1_double _27;
    _27.d0 = 1;
    _27.data = jpl_alloc(sizeof(double) * 1);
    _27.data[0] = _26;
    if (i.d1 >= 0)
    goto _jump250;
    fail_assertion("negative array index");
    _jump250:;
    if (i.d1 < _27.d0)
    goto _jump251;
    fail_assertion("index too large");
    _jump251:;
    int64_t _28 = 0;
    _28 *= _27.d0;
    _28 += i.d1;
    double _29 = _27.data[_28];
    _18 = _29;
    _jump249:;
    bool _30 = true;
    _a3_rgba _31;
    if (!_30)
    goto _jump252;
    _31 = c;
    goto _jump253;
    _jump252:;
    _31 = c;
    _jump253:;
    if (_16 >= 0)
    goto _jump254;
    fail_assertion("negative array index");
    _jump254:;
    if (_16 < _31.d0)
    goto _jump255;
    fail_assertion("index too large");
    _jump255:;
    if (_14 >= 0)
    goto _jump256;
    fail_assertion("negative array index");
    _jump256:;
    if (_14 < _31.d1)
    goto _jump257;
    fail_assertion("index too large");
    _jump257:;
    if (i.d0 >= 0)
    goto _jump258;
    fail_assertion("negative array index");
    _jump258:;
    if (i.d0 < _31.d2)
    goto _jump259;
    fail_assertion("index too large");
    _jump259:;
    int64_t _32 = 0;
    _32 *= _31.d0;
    _32 += _16;
    _32 *= _31.d1;
    _32 += _14;
    _32 *= _31.d2;
    _32 += i.d0;
    rgba _33 = _31.data[_32];
    double _34 = _33.b;
    bool _35 = _18 == _34;
    _a1_bool _36;
    if (!_35)
    goto _jump260;
    _36 = a;
    goto _jump261;
    _jump260:;
    _a2__a1_bool _37;
    // Computing bound for t
    _37.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing bound for u
    _37.d1 = _14;
    if (_14 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= g.d0;
    _38 *= _14;
    _38 *= sizeof(_a1_bool);
    _37.data = jpl_alloc(_38);
    int64_t _39 = 0; // u
    int64_t _40 = 0; // t
    _jump264:; // Begin body of loop
    int64_t _41 = 0;
    _41 *= _37.d0;
    _41 += _40;
    _41 *= _37.d1;
    _41 += _39;
    _37.data[_41] = g;
    _39++;
    if (_39 < _14)
    goto _jump264;
    _39 = 0;
    _40++;
    if (_40 < g.d0)
    goto _jump264;
    // End body of loop
    _a1_int64_t _42;
    if (!_0)
    goto _jump265;
    int64_t _43 = 755;
    _a1_int64_t _44;
    _44.d0 = 1;
    _44.data = jpl_alloc(sizeof(int64_t) * 1);
    _44.data[0] = _43;
    _42 = _44;
    goto _jump266;
    _jump265:;
    _a1_int64_t _45;
    _45.d0 = 2;
    _45.data = jpl_alloc(sizeof(int64_t) * 2);
    _45.data[0] = g.d0;
    _45.data[1] = _16;
    _42 = _45;
    _jump266:;
    if (_1.d1 >= 0)
    goto _jump267;
    fail_assertion("negative array index");
    _jump267:;
    if (_1.d1 < _42.d0)
    goto _jump268;
    fail_assertion("index too large");
    _jump268:;
    int64_t _46 = 0;
    _46 *= _42.d0;
    _46 += _1.d1;
    int64_t _47 = _42.data[_46];
    if (_16 >= 0)
    goto _jump269;
    fail_assertion("negative array index");
    _jump269:;
    if (_16 < _37.d0)
    goto _jump270;
    fail_assertion("index too large");
    _jump270:;
    if (_47 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_47 < _37.d1)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    int64_t _48 = 0;
    _48 *= _37.d0;
    _48 += _16;
    _48 *= _37.d1;
    _48 += _47;
    _a1_bool _49 = _37.data[_48];
    _36 = _49;
    _jump261:;
    int64_t _50 = 0;
    _50 *= _7.d0;
    _50 += _16;
    _50 *= _7.d1;
    _50 += _15;
    _50 *= _7.d2;
    _50 += _14;
    _7.data[_50] = _36;
    _14++;
    if (_14 < c.d2)
    goto _jump243;
    _14 = 0;
    _15++;
    if (_15 < i.d0)
    goto _jump243;
    _15 = 0;
    _16++;
    if (_16 < _8)
    goto _jump243;
    // End body of loop
    _a3_bool _51;
    // Computing bound for q
    _51.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    // Computing bound for r
    _51.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing bound for s
    _51.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= g.d0;
    _52 *= i.d1;
    _52 *= i.d0;
    _52 *= sizeof(bool);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // s
    int64_t _54 = 0; // r
    int64_t _55 = 0; // q
    _jump276:; // Begin body of loop
    if (_1.d0 >= 0)
    goto _jump277;
    fail_assertion("negative array index");
    _jump277:;
    if (_1.d0 < g.d0)
    goto _jump278;
    fail_assertion("index too large");
    _jump278:;
    int64_t _56 = 0;
    _56 *= g.d0;
    _56 += _1.d0;
    bool _57 = g.data[_56];
    int64_t _58 = 0;
    _58 *= _51.d0;
    _58 += _55;
    _58 *= _51.d1;
    _58 += _54;
    _58 *= _51.d2;
    _58 += _53;
    _51.data[_58] = _57;
    _53++;
    if (_53 < i.d0)
    goto _jump276;
    _53 = 0;
    _54++;
    if (_54 < i.d1)
    goto _jump276;
    _54 = 0;
    _55++;
    if (_55 < g.d0)
    goto _jump276;
    // End body of loop
    int64_t _59;
    // Computing bound for q
    if (i.d0 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing bound for r
    if (c.d2 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    // Computing bound for s
    if (i.d1 > 0) 
    goto _jump281;
    fail_assertion("non-positive loop bound");
    _jump281:;
    _59 = 0;
    int64_t _60 = 0; // s
    int64_t _61 = 0; // r
    int64_t _62 = 0; // q
    _jump282:; // Begin body of loop
    int64_t _63 = 964;
    int64_t _64 = _63 / _1.d2;
    _59 += _64;
    _60++;
    if (_60 < i.d1)
    goto _jump282;
    _60 = 0;
    _61++;
    if (_61 < c.d2)
    goto _jump282;
    _61 = 0;
    _62++;
    if (_62 < i.d0)
    goto _jump282;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump283;
    fail_assertion("negative array index");
    _jump283:;
    if (i.d0 < _51.d0)
    goto _jump284;
    fail_assertion("index too large");
    _jump284:;
    if (c.d2 >= 0)
    goto _jump285;
    fail_assertion("negative array index");
    _jump285:;
    if (c.d2 < _51.d1)
    goto _jump286;
    fail_assertion("index too large");
    _jump286:;
    if (_59 >= 0)
    goto _jump287;
    fail_assertion("negative array index");
    _jump287:;
    if (_59 < _51.d2)
    goto _jump288;
    fail_assertion("index too large");
    _jump288:;
    int64_t _65 = 0;
    _65 *= _51.d0;
    _65 += i.d0;
    _65 *= _51.d1;
    _65 += c.d2;
    _65 *= _51.d2;
    _65 += _59;
    bool _66 = _51.data[_65];
    _a3__a3_rgba _67;
    if (!_66)
    goto _jump289;
    _a3__a3__a3_rgba _68;
    // Computing bound for q
    _68.d0 = _1.d2;
    if (_1.d2 > 0) 
    goto _jump290;
    fail_assertion("non-positive loop bound");
    _jump290:;
    // Computing bound for r
    _68.d1 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump291;
    fail_assertion("non-positive loop bound");
    _jump291:;
    // Computing bound for s
    int64_t _69 = 35;
    _68.d2 = _69;
    if (_69 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= _1.d2;
    _70 *= _1.d1;
    _70 *= _69;
    _70 *= sizeof(_a3__a3_rgba);
    _68.data = jpl_alloc(_70);
    int64_t _71 = 0; // s
    int64_t _72 = 0; // r
    int64_t _73 = 0; // q
    _jump293:; // Begin body of loop
    _a3__a3_rgba _74;
    // Computing bound for t
    _74.d0 = _72;
    if (_72 > 0) 
    goto _jump294;
    fail_assertion("non-positive loop bound");
    _jump294:;
    // Computing bound for u
    int64_t _75 = 881;
    _74.d1 = _75;
    if (_75 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing bound for v
    _74.d2 = _72;
    if (_72 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _72;
    _76 *= _75;
    _76 *= _72;
    _76 *= sizeof(_a3_rgba);
    _74.data = jpl_alloc(_76);
    int64_t _77 = 0; // v
    int64_t _78 = 0; // u
    int64_t _79 = 0; // t
    _jump297:; // Begin body of loop
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += _79;
    _80 *= _74.d1;
    _80 += _78;
    _80 *= _74.d2;
    _80 += _77;
    _74.data[_80] = c;
    _77++;
    if (_77 < _72)
    goto _jump297;
    _77 = 0;
    _78++;
    if (_78 < _75)
    goto _jump297;
    _78 = 0;
    _79++;
    if (_79 < _72)
    goto _jump297;
    // End body of loop
    int64_t _81 = 0;
    _81 *= _68.d0;
    _81 += _73;
    _81 *= _68.d1;
    _81 += _72;
    _81 *= _68.d2;
    _81 += _71;
    _68.data[_81] = _74;
    _71++;
    if (_71 < _69)
    goto _jump293;
    _71 = 0;
    _72++;
    if (_72 < _1.d1)
    goto _jump293;
    _72 = 0;
    _73++;
    if (_73 < _1.d2)
    goto _jump293;
    // End body of loop
    _a3_int64_t _82;
    // Computing bound for q
    _82.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing bound for r
    _82.d1 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing bound for s
    _82.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing total size of heap memory to allocate
    int64_t _83 = 1;
    _83 *= c.d0;
    _83 *= _1.d0;
    _83 *= i.d1;
    _83 *= sizeof(int64_t);
    _82.data = jpl_alloc(_83);
    int64_t _84 = 0; // s
    int64_t _85 = 0; // r
    int64_t _86 = 0; // q
    _jump301:; // Begin body of loop
    int64_t _87 = 204;
    int64_t _88 = 0;
    _88 *= _82.d0;
    _88 += _86;
    _88 *= _82.d1;
    _88 += _85;
    _88 *= _82.d2;
    _88 += _84;
    _82.data[_88] = _87;
    _84++;
    if (_84 < i.d1)
    goto _jump301;
    _84 = 0;
    _85++;
    if (_85 < _1.d0)
    goto _jump301;
    _85 = 0;
    _86++;
    if (_86 < c.d0)
    goto _jump301;
    // End body of loop
    int64_t _89 = b(c, g, i);
    if (g.d0 >= 0)
    goto _jump302;
    fail_assertion("negative array index");
    _jump302:;
    if (g.d0 < _82.d0)
    goto _jump303;
    fail_assertion("index too large");
    _jump303:;
    if (_89 >= 0)
    goto _jump304;
    fail_assertion("negative array index");
    _jump304:;
    if (_89 < _82.d1)
    goto _jump305;
    fail_assertion("index too large");
    _jump305:;
    if (c.d0 >= 0)
    goto _jump306;
    fail_assertion("negative array index");
    _jump306:;
    if (c.d0 < _82.d2)
    goto _jump307;
    fail_assertion("index too large");
    _jump307:;
    int64_t _90 = 0;
    _90 *= _82.d0;
    _90 += g.d0;
    _90 *= _82.d1;
    _90 += _89;
    _90 *= _82.d2;
    _90 += c.d0;
    int64_t _91 = _82.data[_90];
    if (g.d0 >= 0)
    goto _jump308;
    fail_assertion("negative array index");
    _jump308:;
    if (g.d0 < _1.d0)
    goto _jump309;
    fail_assertion("index too large");
    _jump309:;
    if (_1.d0 >= 0)
    goto _jump310;
    fail_assertion("negative array index");
    _jump310:;
    if (_1.d0 < _1.d1)
    goto _jump311;
    fail_assertion("index too large");
    _jump311:;
    if (g.d0 >= 0)
    goto _jump312;
    fail_assertion("negative array index");
    _jump312:;
    if (g.d0 < _1.d2)
    goto _jump313;
    fail_assertion("index too large");
    _jump313:;
    int64_t _92 = 0;
    _92 *= _1.d0;
    _92 += g.d0;
    _92 *= _1.d1;
    _92 += _1.d0;
    _92 *= _1.d2;
    _92 += g.d0;
    int64_t _93 = _1.data[_92];
    int64_t _94 = c.d0 + _93;
    if (_1.d1 >= 0)
    goto _jump314;
    fail_assertion("negative array index");
    _jump314:;
    if (_1.d1 < _68.d0)
    goto _jump315;
    fail_assertion("index too large");
    _jump315:;
    if (_91 >= 0)
    goto _jump316;
    fail_assertion("negative array index");
    _jump316:;
    if (_91 < _68.d1)
    goto _jump317;
    fail_assertion("index too large");
    _jump317:;
    if (_94 >= 0)
    goto _jump318;
    fail_assertion("negative array index");
    _jump318:;
    if (_94 < _68.d2)
    goto _jump319;
    fail_assertion("index too large");
    _jump319:;
    int64_t _95 = 0;
    _95 *= _68.d0;
    _95 += _1.d1;
    _95 *= _68.d1;
    _95 += _91;
    _95 *= _68.d2;
    _95 += _94;
    _a3__a3_rgba _96 = _68.data[_95];
    _67 = _96;
    goto _jump320;
    _jump289:;
    _a3__a3_rgba _97;
    // Computing bound for q
    int64_t _98;
    // Computing bound for q
    int64_t _99;
    // Computing bound for q
    if (_1.d0 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing bound for r
    if (i.d1 > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    _99 = 0;
    int64_t _100 = 0; // r
    int64_t _101 = 0; // q
    _jump323:; // Begin body of loop
    _99 += _1.d2;
    _100++;
    if (_100 < i.d1)
    goto _jump323;
    _100 = 0;
    _101++;
    if (_101 < _1.d0)
    goto _jump323;
    // End body of loop
    if (_99 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing bound for r
    if (_1.d0 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    _98 = 0;
    int64_t _102 = 0; // r
    int64_t _103 = 0; // q
    _jump326:; // Begin body of loop
    _98 += i.d0;
    _102++;
    if (_102 < _1.d0)
    goto _jump326;
    _102 = 0;
    _103++;
    if (_103 < _99)
    goto _jump326;
    // End body of loop
    _97.d0 = _98;
    if (_98 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing bound for r
    _97.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    // Computing bound for s
    int64_t _104 = 949;
    _97.d2 = _104;
    if (_104 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _98;
    _105 *= g.d0;
    _105 *= _104;
    _105 *= sizeof(_a3_rgba);
    _97.data = jpl_alloc(_105);
    int64_t _106 = 0; // s
    int64_t _107 = 0; // r
    int64_t _108 = 0; // q
    _jump330:; // Begin body of loop
    bool _109 = !_0;
    _a3_rgba _110;
    if (!_109)
    goto _jump331;
    _110 = c;
    goto _jump332;
    _jump331:;
    _110 = c;
    _jump332:;
    int64_t _111 = 0;
    _111 *= _97.d0;
    _111 += _108;
    _111 *= _97.d1;
    _111 += _107;
    _111 *= _97.d2;
    _111 += _106;
    _97.data[_111] = _110;
    _106++;
    if (_106 < _104)
    goto _jump330;
    _106 = 0;
    _107++;
    if (_107 < g.d0)
    goto _jump330;
    _107 = 0;
    _108++;
    if (_108 < _98)
    goto _jump330;
    // End body of loop
    _67 = _97;
    _jump320:;
    int64_t _112 = -c.d1;
    int64_t _113 = 629;
    int64_t _114 = _112 % _113;
    if (i.d0 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (i.d0 < _67.d0)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    if (_1.d0 >= 0)
    goto _jump335;
    fail_assertion("negative array index");
    _jump335:;
    if (_1.d0 < _67.d1)
    goto _jump336;
    fail_assertion("index too large");
    _jump336:;
    if (_114 >= 0)
    goto _jump337;
    fail_assertion("negative array index");
    _jump337:;
    if (_114 < _67.d2)
    goto _jump338;
    fail_assertion("index too large");
    _jump338:;
    int64_t _115 = 0;
    _115 *= _67.d0;
    _115 += i.d0;
    _115 *= _67.d1;
    _115 += _1.d0;
    _115 *= _67.d2;
    _115 += _114;
    _a3_rgba _116 = _67.data[_115];
    bool _117 = _1.d0 == g.d0;
    bool _118;
    if (!_117)
    goto _jump339;
    bool _119 = _0;
    if (0 != _0)
    goto _jump340;
    bool _120 = false;
    _119 = _120;
    _jump340:;
    _118 = _119;
    goto _jump341;
    _jump339:;
    bool _121 = true;
    bool _122;
    if (!_121)
    goto _jump342;
    bool _123 = false;
    _122 = _123;
    goto _jump343;
    _jump342:;
    _122 = _0;
    _jump343:;
    _118 = _122;
    _jump341:;
    double _124 = 9.0;
    double _125 = -_124;
    double _126 = 8.0;
    double _127 = -_126;
    bool _128 = _125 >= _127;
    bool _129 = _118 != _128;
    _a2__a1_bool _130;
    if (!_129)
    goto _jump344;
    _a2__a1_bool _131;
    // Computing bound for q
    _131.d0 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    // Computing bound for r
    int64_t _132;
    if (!_0)
    goto _jump346;
    _132 = c.d2;
    goto _jump347;
    _jump346:;
    _132 = c.d0;
    _jump347:;
    int64_t _133 = _1.d2 / _132;
    _131.d1 = _133;
    if (_133 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= _1.d1;
    _134 *= _133;
    _134 *= sizeof(_a1_bool);
    _131.data = jpl_alloc(_134);
    int64_t _135 = 0; // r
    int64_t _136 = 0; // q
    _jump349:; // Begin body of loop
    _a1_bool _137;
    // Computing bound for s
    _137.d0 = c.d0;
    if (c.d0 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= c.d0;
    _138 *= sizeof(bool);
    _137.data = jpl_alloc(_138);
    int64_t _139 = 0; // s
    _jump351:; // Begin body of loop
    bool _140 = g.d0 > g.d0;
    int64_t _141 = 0;
    _141 *= _137.d0;
    _141 += _139;
    _137.data[_141] = _140;
    _139++;
    if (_139 < c.d0)
    goto _jump351;
    // End body of loop
    int64_t _142 = 0;
    _142 *= _131.d0;
    _142 += _136;
    _142 *= _131.d1;
    _142 += _135;
    _131.data[_142] = _137;
    _135++;
    if (_135 < _133)
    goto _jump349;
    _135 = 0;
    _136++;
    if (_136 < _1.d1)
    goto _jump349;
    // End body of loop
    _130 = _131;
    goto _jump352;
    _jump344:;
    bool _143 = c.d0 > _1.d0;
    bool _144;
    if (!_143)
    goto _jump353;
    _144 = _0;
    goto _jump354;
    _jump353:;
    bool _145 = _0;
    if (0 != _0)
    goto _jump355;
    bool _146 = true;
    _145 = _146;
    _jump355:;
    _144 = _145;
    _jump354:;
    _a2__a1_bool _147;
    if (!_144)
    goto _jump356;
    _a2__a1_bool _148;
    // Computing bound for q
    int64_t _149 = -_1.d2;
    _148.d0 = _149;
    if (_149 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    // Computing bound for r
    _148.d1 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= _149;
    _150 *= _1.d1;
    _150 *= sizeof(_a1_bool);
    _148.data = jpl_alloc(_150);
    int64_t _151 = 0; // r
    int64_t _152 = 0; // q
    _jump359:; // Begin body of loop
    int64_t _153 = 0;
    _153 *= _148.d0;
    _153 += _152;
    _153 *= _148.d1;
    _153 += _151;
    _148.data[_153] = g;
    _151++;
    if (_151 < _1.d1)
    goto _jump359;
    _151 = 0;
    _152++;
    if (_152 < _149)
    goto _jump359;
    // End body of loop
    _147 = _148;
    goto _jump360;
    _jump356:;
    _a2__a1_bool _154;
    // Computing bound for q
    _154.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    // Computing bound for r
    _154.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= g.d0;
    _155 *= i.d1;
    _155 *= sizeof(_a1_bool);
    _154.data = jpl_alloc(_155);
    int64_t _156 = 0; // r
    int64_t _157 = 0; // q
    _jump363:; // Begin body of loop
    int64_t _158 = 0;
    _158 *= _154.d0;
    _158 += _157;
    _158 *= _154.d1;
    _158 += _156;
    _154.data[_158] = g;
    _156++;
    if (_156 < i.d1)
    goto _jump363;
    _156 = 0;
    _157++;
    if (_157 < g.d0)
    goto _jump363;
    // End body of loop
    _147 = _154;
    _jump360:;
    _130 = _147;
    _jump352:;
    if (_1.d0 >= 0)
    goto _jump364;
    fail_assertion("negative array index");
    _jump364:;
    if (_1.d0 < a.d0)
    goto _jump365;
    fail_assertion("index too large");
    _jump365:;
    int64_t _159 = 0;
    _159 *= a.d0;
    _159 += _1.d0;
    bool _160 = a.data[_159];
    bool _161 = !_160;
    bool _162 = !_161;
    int64_t _163;
    if (!_162)
    goto _jump366;
    _163 = g.d0;
    goto _jump367;
    _jump366:;
    int64_t _164 = 898;
    int64_t _165 = g.d0 % _164;
    _163 = _165;
    _jump367:;
    int64_t _166 = i.d0 % _1.d0;
    int64_t _167 = -_166;
    if (_163 >= 0)
    goto _jump368;
    fail_assertion("negative array index");
    _jump368:;
    if (_163 < _130.d0)
    goto _jump369;
    fail_assertion("index too large");
    _jump369:;
    if (_167 >= 0)
    goto _jump370;
    fail_assertion("negative array index");
    _jump370:;
    if (_167 < _130.d1)
    goto _jump371;
    fail_assertion("index too large");
    _jump371:;
    int64_t _168 = 0;
    _168 *= _130.d0;
    _168 += _163;
    _168 *= _130.d1;
    _168 += _167;
    _a1_bool _169 = _130.data[_168];
    bool _170 = !_0;
    _a2__a2_rgba _171;
    if (!_170)
    goto _jump372;
    bool _172 = _0;
    if (0 != _0)
    goto _jump373;
    bool _173 = false;
    _172 = _173;
    _jump373:;
    bool _174;
    if (!_172)
    goto _jump374;
    _174 = _0;
    goto _jump375;
    _jump374:;
    _174 = _0;
    _jump375:;
    _a2__a2_rgba _175;
    if (!_174)
    goto _jump376;
    _a2__a2_rgba _176;
    // Computing bound for q
    int64_t _177 = c.d2 + g.d0;
    _176.d0 = _177;
    if (_177 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    // Computing bound for r
    int64_t _178 = 420;
    _176.d1 = _178;
    if (_178 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= _177;
    _179 *= _178;
    _179 *= sizeof(_a2_rgba);
    _176.data = jpl_alloc(_179);
    int64_t _180 = 0; // r
    int64_t _181 = 0; // q
    _jump379:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _176.d0;
    _182 += _181;
    _182 *= _176.d1;
    _182 += _180;
    _176.data[_182] = i;
    _180++;
    if (_180 < _178)
    goto _jump379;
    _180 = 0;
    _181++;
    if (_181 < _177)
    goto _jump379;
    // End body of loop
    _175 = _176;
    goto _jump380;
    _jump376:;
    _a2__a2_rgba _183;
    // Computing bound for q
    _183.d0 = c.d2;
    if (c.d2 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing bound for r
    int64_t _184;
    // Computing bound for q
    if (c.d1 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for r
    if (i.d1 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing bound for s
    if (_1.d0 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    _184 = 0;
    int64_t _185 = 0; // s
    int64_t _186 = 0; // r
    int64_t _187 = 0; // q
    _jump385:; // Begin body of loop
    _184 += i.d0;
    _185++;
    if (_185 < _1.d0)
    goto _jump385;
    _185 = 0;
    _186++;
    if (_186 < i.d1)
    goto _jump385;
    _186 = 0;
    _187++;
    if (_187 < c.d1)
    goto _jump385;
    // End body of loop
    _183.d1 = _184;
    if (_184 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= c.d2;
    _188 *= _184;
    _188 *= sizeof(_a2_rgba);
    _183.data = jpl_alloc(_188);
    int64_t _189 = 0; // r
    int64_t _190 = 0; // q
    _jump387:; // Begin body of loop
    int64_t _191 = 0;
    _191 *= _183.d0;
    _191 += _190;
    _191 *= _183.d1;
    _191 += _189;
    _183.data[_191] = i;
    _189++;
    if (_189 < _184)
    goto _jump387;
    _189 = 0;
    _190++;
    if (_190 < c.d2)
    goto _jump387;
    // End body of loop
    _175 = _183;
    _jump380:;
    _171 = _175;
    goto _jump388;
    _jump372:;
    _a3__a2__a2_rgba _192;
    // Computing bound for q
    int64_t _193 = -i.d1;
    _192.d0 = _193;
    if (_193 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing bound for r
    int64_t _194 = 204;
    int64_t _195 = _194 / _1.d0;
    _192.d1 = _195;
    if (_195 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for s
    int64_t _196 = i.d0 - c.d2;
    _192.d2 = _196;
    if (_196 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= _193;
    _197 *= _195;
    _197 *= _196;
    _197 *= sizeof(_a2__a2_rgba);
    _192.data = jpl_alloc(_197);
    int64_t _198 = 0; // s
    int64_t _199 = 0; // r
    int64_t _200 = 0; // q
    _jump392:; // Begin body of loop
    _a2__a2_rgba _201;
    // Computing bound for t
    _201.d0 = _200;
    if (_200 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing bound for u
    _201.d1 = _198;
    if (_198 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _200;
    _202 *= _198;
    _202 *= sizeof(_a2_rgba);
    _201.data = jpl_alloc(_202);
    int64_t _203 = 0; // u
    int64_t _204 = 0; // t
    _jump395:; // Begin body of loop
    int64_t _205 = 0;
    _205 *= _201.d0;
    _205 += _204;
    _205 *= _201.d1;
    _205 += _203;
    _201.data[_205] = i;
    _203++;
    if (_203 < _198)
    goto _jump395;
    _203 = 0;
    _204++;
    if (_204 < _200)
    goto _jump395;
    // End body of loop
    int64_t _206 = 0;
    _206 *= _192.d0;
    _206 += _200;
    _206 *= _192.d1;
    _206 += _199;
    _206 *= _192.d2;
    _206 += _198;
    _192.data[_206] = _201;
    _198++;
    if (_198 < _196)
    goto _jump392;
    _198 = 0;
    _199++;
    if (_199 < _195)
    goto _jump392;
    _199 = 0;
    _200++;
    if (_200 < _193)
    goto _jump392;
    // End body of loop
    int64_t _207 = -i.d0;
    if (g.d0 >= 0)
    goto _jump396;
    fail_assertion("negative array index");
    _jump396:;
    if (g.d0 < _192.d0)
    goto _jump397;
    fail_assertion("index too large");
    _jump397:;
    if (i.d1 >= 0)
    goto _jump398;
    fail_assertion("negative array index");
    _jump398:;
    if (i.d1 < _192.d1)
    goto _jump399;
    fail_assertion("index too large");
    _jump399:;
    if (_207 >= 0)
    goto _jump400;
    fail_assertion("negative array index");
    _jump400:;
    if (_207 < _192.d2)
    goto _jump401;
    fail_assertion("index too large");
    _jump401:;
    int64_t _208 = 0;
    _208 *= _192.d0;
    _208 += g.d0;
    _208 *= _192.d1;
    _208 += i.d1;
    _208 *= _192.d2;
    _208 += _207;
    _a2__a2_rgba _209 = _192.data[_208];
    _171 = _209;
    _jump388:;
    bool _210 = true;
    _a3_rgba _211;
    if (!_210)
    goto _jump402;
    _211 = c;
    goto _jump403;
    _jump402:;
    _211 = c;
    _jump403:;
    bool _212 = false;
    _a1_bool _213;
    _213.d0 = 1;
    _213.data = jpl_alloc(sizeof(bool) * 1);
    _213.data[0] = _212;
    bool _215 = _1.d2 <= g.d0;
    bool _214 = _215;
    if (0 == _215)
    goto _jump404;
    _214 = _0;
    _jump404:;
    _a2_rgba _216;
    if (!_214)
    goto _jump405;
    _a2_rgba _217;
    // Computing bound for q
    _217.d0 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump406;
    fail_assertion("non-positive loop bound");
    _jump406:;
    // Computing bound for r
    _217.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    // Computing total size of heap memory to allocate
    int64_t _218 = 1;
    _218 *= _1.d0;
    _218 *= g.d0;
    _218 *= sizeof(rgba);
    _217.data = jpl_alloc(_218);
    int64_t _219 = 0; // r
    int64_t _220 = 0; // q
    _jump408:; // Begin body of loop
    if (i.d1 >= 0)
    goto _jump409;
    fail_assertion("negative array index");
    _jump409:;
    if (i.d1 < i.d0)
    goto _jump410;
    fail_assertion("index too large");
    _jump410:;
    if (_1.d2 >= 0)
    goto _jump411;
    fail_assertion("negative array index");
    _jump411:;
    if (_1.d2 < i.d1)
    goto _jump412;
    fail_assertion("index too large");
    _jump412:;
    int64_t _221 = 0;
    _221 *= i.d0;
    _221 += i.d1;
    _221 *= i.d1;
    _221 += _1.d2;
    rgba _222 = i.data[_221];
    int64_t _223 = 0;
    _223 *= _217.d0;
    _223 += _220;
    _223 *= _217.d1;
    _223 += _219;
    _217.data[_223] = _222;
    _219++;
    if (_219 < g.d0)
    goto _jump408;
    _219 = 0;
    _220++;
    if (_220 < _1.d0)
    goto _jump408;
    // End body of loop
    _216 = _217;
    goto _jump413;
    _jump405:;
    _a3__a2_rgba _224;
    // Computing bound for q
    _224.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    // Computing bound for r
    _224.d1 = c.d0;
    if (c.d0 > 0) 
    goto _jump415;
    fail_assertion("non-positive loop bound");
    _jump415:;
    // Computing bound for s
    _224.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing total size of heap memory to allocate
    int64_t _225 = 1;
    _225 *= c.d1;
    _225 *= c.d0;
    _225 *= i.d1;
    _225 *= sizeof(_a2_rgba);
    _224.data = jpl_alloc(_225);
    int64_t _226 = 0; // s
    int64_t _227 = 0; // r
    int64_t _228 = 0; // q
    _jump417:; // Begin body of loop
    int64_t _229 = 0;
    _229 *= _224.d0;
    _229 += _228;
    _229 *= _224.d1;
    _229 += _227;
    _229 *= _224.d2;
    _229 += _226;
    _224.data[_229] = i;
    _226++;
    if (_226 < i.d1)
    goto _jump417;
    _226 = 0;
    _227++;
    if (_227 < c.d0)
    goto _jump417;
    _227 = 0;
    _228++;
    if (_228 < c.d1)
    goto _jump417;
    // End body of loop
    if (c.d2 >= 0)
    goto _jump418;
    fail_assertion("negative array index");
    _jump418:;
    if (c.d2 < _224.d0)
    goto _jump419;
    fail_assertion("index too large");
    _jump419:;
    if (c.d1 >= 0)
    goto _jump420;
    fail_assertion("negative array index");
    _jump420:;
    if (c.d1 < _224.d1)
    goto _jump421;
    fail_assertion("index too large");
    _jump421:;
    if (_1.d1 >= 0)
    goto _jump422;
    fail_assertion("negative array index");
    _jump422:;
    if (_1.d1 < _224.d2)
    goto _jump423;
    fail_assertion("index too large");
    _jump423:;
    int64_t _230 = 0;
    _230 *= _224.d0;
    _230 += c.d2;
    _230 *= _224.d1;
    _230 += c.d1;
    _230 *= _224.d2;
    _230 += _1.d1;
    _a2_rgba _231 = _224.data[_230];
    _216 = _231;
    _jump413:;
    int64_t _232 = b(_211, _213, _216);
    if (c.d2 >= 0)
    goto _jump424;
    fail_assertion("negative array index");
    _jump424:;
    if (c.d2 < _171.d0)
    goto _jump425;
    fail_assertion("index too large");
    _jump425:;
    if (_232 >= 0)
    goto _jump426;
    fail_assertion("negative array index");
    _jump426:;
    if (_232 < _171.d1)
    goto _jump427;
    fail_assertion("index too large");
    _jump427:;
    int64_t _233 = 0;
    _233 *= _171.d0;
    _233 += c.d2;
    _233 *= _171.d1;
    _233 += _232;
    _a2_rgba _234 = _171.data[_233];
    int64_t _235 = b(_116, _169, _234);
    int64_t _236;
    // Computing bound for q
    if (i.d1 > 0) 
    goto _jump428;
    fail_assertion("non-positive loop bound");
    _jump428:;
    _236 = 0;
    int64_t _237 = 0; // q
    _jump429:; // Begin body of loop
    _236 += c.d1;
    _237++;
    if (_237 < i.d1)
    goto _jump429;
    // End body of loop
    if (_235 >= 0)
    goto _jump430;
    fail_assertion("negative array index");
    _jump430:;
    if (_235 < _7.d0)
    goto _jump431;
    fail_assertion("index too large");
    _jump431:;
    if (_236 >= 0)
    goto _jump432;
    fail_assertion("negative array index");
    _jump432:;
    if (_236 < _7.d1)
    goto _jump433;
    fail_assertion("index too large");
    _jump433:;
    if (g.d0 >= 0)
    goto _jump434;
    fail_assertion("negative array index");
    _jump434:;
    if (g.d0 < _7.d2)
    goto _jump435;
    fail_assertion("index too large");
    _jump435:;
    int64_t _238 = 0;
    _238 *= _7.d0;
    _238 += _235;
    _238 *= _7.d1;
    _238 += _236;
    _238 *= _7.d2;
    _238 += g.d0;
    _a1_bool _239 = _7.data[_238];
    int64_t _240;
    if (!_0)
    goto _jump436;
    int64_t _241 = 872;
    _240 = _241;
    goto _jump437;
    _jump436:;
    int64_t _242;
    // Computing bound for s
    if (g.d0 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    _242 = 0;
    int64_t _243 = 0; // s
    _jump439:; // Begin body of loop
    _242 += g.d0;
    _243++;
    if (_243 < g.d0)
    goto _jump439;
    // End body of loop
    _240 = _242;
    _jump437:;
    bool _244 = _240 == _239.d0;
    bool _245 = _244 == _0;
    return g.d0;
    _a1__a3_rgba _246;
    // Computing bound for t
    _246.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump440;
    fail_assertion("non-positive loop bound");
    _jump440:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= i.d0;
    _247 *= sizeof(_a3_rgba);
    _246.data = jpl_alloc(_247);
    int64_t _248 = 0; // t
    _jump441:; // Begin body of loop
    _a3_rgba _249;
    if (!_245)
    goto _jump442;
    _a3_rgba _250;
    // Computing bound for u
    int64_t _251;
    // Computing bound for u
    int64_t _252;
    // Computing bound for u
    if (c.d2 > 0) 
    goto _jump443;
    fail_assertion("non-positive loop bound");
    _jump443:;
    // Computing bound for v
    if (g.d0 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    _252 = 0;
    int64_t _253 = 0; // v
    int64_t _254 = 0; // u
    _jump445:; // Begin body of loop
    _252 += _248;
    _253++;
    if (_253 < g.d0)
    goto _jump445;
    _253 = 0;
    _254++;
    if (_254 < c.d2)
    goto _jump445;
    // End body of loop
    if (_252 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    _251 = 0;
    int64_t _255 = 0; // u
    _jump447:; // Begin body of loop
    _251 += _239.d0;
    _255++;
    if (_255 < _252)
    goto _jump447;
    // End body of loop
    _250.d0 = _251;
    if (_251 > 0) 
    goto _jump448;
    fail_assertion("non-positive loop bound");
    _jump448:;
    // Computing bound for v
    int64_t _256;
    // Computing bound for u
    if (c.d2 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for v
    if (_1.d2 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    // Computing bound for w
    if (g.d0 > 0) 
    goto _jump451;
    fail_assertion("non-positive loop bound");
    _jump451:;
    _256 = 0;
    int64_t _257 = 0; // w
    int64_t _258 = 0; // v
    int64_t _259 = 0; // u
    _jump452:; // Begin body of loop
    _256 += _1.d1;
    _257++;
    if (_257 < g.d0)
    goto _jump452;
    _257 = 0;
    _258++;
    if (_258 < _1.d2)
    goto _jump452;
    _258 = 0;
    _259++;
    if (_259 < c.d2)
    goto _jump452;
    // End body of loop
    _250.d1 = _256;
    if (_256 > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    // Computing bound for w
    _250.d2 = _1.d1;
    if (_1.d1 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing total size of heap memory to allocate
    int64_t _260 = 1;
    _260 *= _251;
    _260 *= _256;
    _260 *= _1.d1;
    _260 *= sizeof(rgba);
    _250.data = jpl_alloc(_260);
    int64_t _261 = 0; // w
    int64_t _262 = 0; // v
    int64_t _263 = 0; // u
    _jump455:; // Begin body of loop
    if (c.d1 >= 0)
    goto _jump456;
    fail_assertion("negative array index");
    _jump456:;
    if (c.d1 < i.d0)
    goto _jump457;
    fail_assertion("index too large");
    _jump457:;
    if (_248 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_248 < i.d1)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    int64_t _264 = 0;
    _264 *= i.d0;
    _264 += c.d1;
    _264 *= i.d1;
    _264 += _248;
    rgba _265 = i.data[_264];
    int64_t _266 = 0;
    _266 *= _250.d0;
    _266 += _263;
    _266 *= _250.d1;
    _266 += _262;
    _266 *= _250.d2;
    _266 += _261;
    _250.data[_266] = _265;
    _261++;
    if (_261 < _1.d1)
    goto _jump455;
    _261 = 0;
    _262++;
    if (_262 < _256)
    goto _jump455;
    _262 = 0;
    _263++;
    if (_263 < _251)
    goto _jump455;
    // End body of loop
    _249 = _250;
    goto _jump460;
    _jump442:;
    _249 = c;
    _jump460:;
    int64_t _267 = 0;
    _267 *= _246.d0;
    _267 += _248;
    _246.data[_267] = _249;
    _248++;
    if (_248 < i.d0)
    goto _jump441;
    // End body of loop
    bool _268 = true;
    int64_t _269;
    if (!_268)
    goto _jump461;
    _269 = _1.d0;
    goto _jump462;
    _jump461:;
    double _270 = 12.0;
    double _271 = 57.0;
    double _272 = 35.0;
    double _273 = fmod(_271, _272);
    bool _274 = _270 == _273;
    bool _275 = !_274;
    int64_t _276;
    if (!_275)
    goto _jump463;
    if (i.d0 >= 0)
    goto _jump464;
    fail_assertion("negative array index");
    _jump464:;
    if (i.d0 < _1.d0)
    goto _jump465;
    fail_assertion("index too large");
    _jump465:;
    if (c.d0 >= 0)
    goto _jump466;
    fail_assertion("negative array index");
    _jump466:;
    if (c.d0 < _1.d1)
    goto _jump467;
    fail_assertion("index too large");
    _jump467:;
    if (c.d2 >= 0)
    goto _jump468;
    fail_assertion("negative array index");
    _jump468:;
    if (c.d2 < _1.d2)
    goto _jump469;
    fail_assertion("index too large");
    _jump469:;
    int64_t _277 = 0;
    _277 *= _1.d0;
    _277 += i.d0;
    _277 *= _1.d1;
    _277 += c.d0;
    _277 *= _1.d2;
    _277 += c.d2;
    int64_t _278 = _1.data[_277];
    int64_t _279 = _278 + i.d0;
    _276 = _279;
    goto _jump470;
    _jump463:;
    _276 = i.d0;
    _jump470:;
    _269 = _276;
    _jump462:;
    if (_269 >= 0)
    goto _jump471;
    fail_assertion("negative array index");
    _jump471:;
    if (_269 < _246.d0)
    goto _jump472;
    fail_assertion("index too large");
    _jump472:;
    int64_t _280 = 0;
    _280 *= _246.d0;
    _280 += _269;
    _a3_rgba _281 = _246.data[_280];
    _a2_rgba _282;
    if (!_245)
    goto _jump473;
    int64_t _283 = 298;
    bool _284 = _1.d2 >= _283;
    _a2__a2_rgba _285;
    if (!_284)
    goto _jump474;
    _a2__a2_rgba _286;
    // Computing bound for t
    int64_t _287 = -i.d1;
    _286.d0 = _287;
    if (_287 > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing bound for u
    _286.d1 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing total size of heap memory to allocate
    int64_t _288 = 1;
    _288 *= _287;
    _288 *= _1.d0;
    _288 *= sizeof(_a2_rgba);
    _286.data = jpl_alloc(_288);
    int64_t _289 = 0; // u
    int64_t _290 = 0; // t
    _jump477:; // Begin body of loop
    _a1__a2_rgba _291;
    _291.d0 = 2;
    _291.data = jpl_alloc(sizeof(_a2_rgba) * 2);
    _291.data[0] = i;
    _291.data[1] = i;
    if (_290 >= 0)
    goto _jump478;
    fail_assertion("negative array index");
    _jump478:;
    if (_290 < _291.d0)
    goto _jump479;
    fail_assertion("index too large");
    _jump479:;
    int64_t _292 = 0;
    _292 *= _291.d0;
    _292 += _290;
    _a2_rgba _293 = _291.data[_292];
    int64_t _294 = 0;
    _294 *= _286.d0;
    _294 += _290;
    _294 *= _286.d1;
    _294 += _289;
    _286.data[_294] = _293;
    _289++;
    if (_289 < _1.d0)
    goto _jump477;
    _289 = 0;
    _290++;
    if (_290 < _287)
    goto _jump477;
    // End body of loop
    _285 = _286;
    goto _jump480;
    _jump474:;
    _a2__a2_rgba _295;
    // Computing bound for t
    _295.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    // Computing bound for u
    _295.d1 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= c.d1;
    _296 *= _1.d0;
    _296 *= sizeof(_a2_rgba);
    _295.data = jpl_alloc(_296);
    int64_t _297 = 0; // u
    int64_t _298 = 0; // t
    _jump483:; // Begin body of loop
    int64_t _299 = 0;
    _299 *= _295.d0;
    _299 += _298;
    _299 *= _295.d1;
    _299 += _297;
    _295.data[_299] = i;
    _297++;
    if (_297 < _1.d0)
    goto _jump483;
    _297 = 0;
    _298++;
    if (_298 < c.d1)
    goto _jump483;
    // End body of loop
    _285 = _295;
    _jump480:;
    _a2__a3_rgba _300;
    // Computing bound for t
    _300.d0 = _239.d0;
    if (_239.d0 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing bound for u
    _300.d1 = c.d2;
    if (c.d2 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing total size of heap memory to allocate
    int64_t _301 = 1;
    _301 *= _239.d0;
    _301 *= c.d2;
    _301 *= sizeof(_a3_rgba);
    _300.data = jpl_alloc(_301);
    int64_t _302 = 0; // u
    int64_t _303 = 0; // t
    _jump486:; // Begin body of loop
    int64_t _304 = 0;
    _304 *= _300.d0;
    _304 += _303;
    _304 *= _300.d1;
    _304 += _302;
    _300.data[_304] = c;
    _302++;
    if (_302 < c.d2)
    goto _jump486;
    _302 = 0;
    _303++;
    if (_303 < _239.d0)
    goto _jump486;
    // End body of loop
    if (_239.d0 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_239.d0 < _300.d0)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (c.d2 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (c.d2 < _300.d1)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _305 = 0;
    _305 *= _300.d0;
    _305 += _239.d0;
    _305 *= _300.d1;
    _305 += c.d2;
    _a3_rgba _306 = _300.data[_305];
    _a2__a1_bool _307;
    // Computing bound for t
    _307.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for u
    _307.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= g.d0;
    _308 *= c.d1;
    _308 *= sizeof(_a1_bool);
    _307.data = jpl_alloc(_308);
    int64_t _309 = 0; // u
    int64_t _310 = 0; // t
    _jump493:; // Begin body of loop
    int64_t _311 = 0;
    _311 *= _307.d0;
    _311 += _310;
    _311 *= _307.d1;
    _311 += _309;
    _307.data[_311] = g;
    _309++;
    if (_309 < c.d1)
    goto _jump493;
    _309 = 0;
    _310++;
    if (_310 < g.d0)
    goto _jump493;
    // End body of loop
    int64_t _312 = b(c, _239, i);
    if (_312 >= 0)
    goto _jump494;
    fail_assertion("negative array index");
    _jump494:;
    if (_312 < _307.d0)
    goto _jump495;
    fail_assertion("index too large");
    _jump495:;
    if (c.d2 >= 0)
    goto _jump496;
    fail_assertion("negative array index");
    _jump496:;
    if (c.d2 < _307.d1)
    goto _jump497;
    fail_assertion("index too large");
    _jump497:;
    int64_t _313 = 0;
    _313 *= _307.d0;
    _313 += _312;
    _313 *= _307.d1;
    _313 += c.d2;
    _a1_bool _314 = _307.data[_313];
    int64_t _315 = b(_306, _314, i);
    int64_t _316 = _315 * c.d0;
    if (c.d0 >= 0)
    goto _jump498;
    fail_assertion("negative array index");
    _jump498:;
    if (c.d0 < _285.d0)
    goto _jump499;
    fail_assertion("index too large");
    _jump499:;
    if (_316 >= 0)
    goto _jump500;
    fail_assertion("negative array index");
    _jump500:;
    if (_316 < _285.d1)
    goto _jump501;
    fail_assertion("index too large");
    _jump501:;
    int64_t _317 = 0;
    _317 *= _285.d0;
    _317 += c.d0;
    _317 *= _285.d1;
    _317 += _316;
    _a2_rgba _318 = _285.data[_317];
    _282 = _318;
    goto _jump502;
    _jump473:;
    bool _319 = false;
    bool _320;
    if (!_319)
    goto _jump503;
    _320 = _0;
    goto _jump504;
    _jump503:;
    bool _321 = true;
    bool _322 = _321 == _0;
    _a1_bool _323;
    if (!_322)
    goto _jump505;
    _a1_bool _324;
    if (!_245)
    goto _jump506;
    _324 = a;
    goto _jump507;
    _jump506:;
    _324 = _239;
    _jump507:;
    _323 = _324;
    goto _jump508;
    _jump505:;
    _323 = _239;
    _jump508:;
    if (c.d2 >= 0)
    goto _jump509;
    fail_assertion("negative array index");
    _jump509:;
    if (c.d2 < _323.d0)
    goto _jump510;
    fail_assertion("index too large");
    _jump510:;
    int64_t _325 = 0;
    _325 *= _323.d0;
    _325 += c.d2;
    bool _326 = _323.data[_325];
    _320 = _326;
    _jump504:;
    _a2_rgba _327;
    if (!_320)
    goto _jump511;
    _a2_rgba _328;
    // Computing bound for t
    _a2_int64_t _329;
    if (!_245)
    goto _jump512;
    _a2_int64_t _330;
    // Computing bound for t
    _330.d0 = c.d1;
    if (c.d1 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing bound for u
    _330.d1 = _1.d0;
    if (_1.d0 > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= c.d1;
    _331 *= _1.d0;
    _331 *= sizeof(int64_t);
    _330.data = jpl_alloc(_331);
    int64_t _332 = 0; // u
    int64_t _333 = 0; // t
    _jump515:; // Begin body of loop
    int64_t _334 = 0;
    _334 *= _330.d0;
    _334 += _333;
    _334 *= _330.d1;
    _334 += _332;
    _330.data[_334] = _1.d1;
    _332++;
    if (_332 < _1.d0)
    goto _jump515;
    _332 = 0;
    _333++;
    if (_333 < c.d1)
    goto _jump515;
    // End body of loop
    _329 = _330;
    goto _jump516;
    _jump512:;
    _a2_int64_t _335;
    // Computing bound for t
    _335.d0 = _1.d2;
    if (_1.d2 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for u
    _335.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _1.d2;
    _336 *= i.d1;
    _336 *= sizeof(int64_t);
    _335.data = jpl_alloc(_336);
    int64_t _337 = 0; // u
    int64_t _338 = 0; // t
    _jump519:; // Begin body of loop
    int64_t _339 = 0;
    _339 *= _335.d0;
    _339 += _338;
    _339 *= _335.d1;
    _339 += _337;
    _335.data[_339] = i.d1;
    _337++;
    if (_337 < i.d1)
    goto _jump519;
    _337 = 0;
    _338++;
    if (_338 < _1.d2)
    goto _jump519;
    // End body of loop
    _329 = _335;
    _jump516:;
    int64_t _340 = 199;
    if (_239.d0 >= 0)
    goto _jump520;
    fail_assertion("negative array index");
    _jump520:;
    if (_239.d0 < _329.d0)
    goto _jump521;
    fail_assertion("index too large");
    _jump521:;
    if (_340 >= 0)
    goto _jump522;
    fail_assertion("negative array index");
    _jump522:;
    if (_340 < _329.d1)
    goto _jump523;
    fail_assertion("index too large");
    _jump523:;
    int64_t _341 = 0;
    _341 *= _329.d0;
    _341 += _239.d0;
    _341 *= _329.d1;
    _341 += _340;
    int64_t _342 = _329.data[_341];
    _328.d0 = _342;
    if (_342 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing bound for u
    _328.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    // Computing total size of heap memory to allocate
    int64_t _343 = 1;
    _343 *= _342;
    _343 *= i.d1;
    _343 *= sizeof(rgba);
    _328.data = jpl_alloc(_343);
    int64_t _344 = 0; // u
    int64_t _345 = 0; // t
    _jump526:; // Begin body of loop
    bool _346;
    if (!_245)
    goto _jump527;
    _346 = _0;
    goto _jump528;
    _jump527:;
    _346 = _245;
    _jump528:;
    _a2_rgba _347;
    if (!_346)
    goto _jump529;
    _347 = i;
    goto _jump530;
    _jump529:;
    _347 = i;
    _jump530:;
    _a2_int64_t _348;
    // Computing bound for v
    _348.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump531;
    fail_assertion("non-positive loop bound");
    _jump531:;
    // Computing bound for w
    _348.d1 = c.d1;
    if (c.d1 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= i.d1;
    _349 *= c.d1;
    _349 *= sizeof(int64_t);
    _348.data = jpl_alloc(_349);
    int64_t _350 = 0; // w
    int64_t _351 = 0; // v
    _jump533:; // Begin body of loop
    int64_t _352 = 0;
    _352 *= _348.d0;
    _352 += _351;
    _352 *= _348.d1;
    _352 += _350;
    _348.data[_352] = _344;
    _350++;
    if (_350 < c.d1)
    goto _jump533;
    _350 = 0;
    _351++;
    if (_351 < i.d1)
    goto _jump533;
    // End body of loop
    if (c.d2 >= 0)
    goto _jump534;
    fail_assertion("negative array index");
    _jump534:;
    if (c.d2 < _348.d0)
    goto _jump535;
    fail_assertion("index too large");
    _jump535:;
    if (_344 >= 0)
    goto _jump536;
    fail_assertion("negative array index");
    _jump536:;
    if (_344 < _348.d1)
    goto _jump537;
    fail_assertion("index too large");
    _jump537:;
    int64_t _353 = 0;
    _353 *= _348.d0;
    _353 += c.d2;
    _353 *= _348.d1;
    _353 += _344;
    int64_t _354 = _348.data[_353];
    if (_354 >= 0)
    goto _jump538;
    fail_assertion("negative array index");
    _jump538:;
    if (_354 < _347.d0)
    goto _jump539;
    fail_assertion("index too large");
    _jump539:;
    if (g.d0 >= 0)
    goto _jump540;
    fail_assertion("negative array index");
    _jump540:;
    if (g.d0 < _347.d1)
    goto _jump541;
    fail_assertion("index too large");
    _jump541:;
    int64_t _355 = 0;
    _355 *= _347.d0;
    _355 += _354;
    _355 *= _347.d1;
    _355 += g.d0;
    rgba _356 = _347.data[_355];
    int64_t _357 = 0;
    _357 *= _328.d0;
    _357 += _345;
    _357 *= _328.d1;
    _357 += _344;
    _328.data[_357] = _356;
    _344++;
    if (_344 < i.d1)
    goto _jump526;
    _344 = 0;
    _345++;
    if (_345 < _342)
    goto _jump526;
    // End body of loop
    _327 = _328;
    goto _jump542;
    _jump511:;
    _327 = i;
    _jump542:;
    _282 = _327;
    _jump502:;
    int64_t _358 = b(_281, a, _282);
    return _358;
}

bool c(void_t d) {
    bool _0 = false;
    if (0 != _0)
    goto _jump543;
    fail_assertion("e");
    _jump543:;
    _a3__a2_int64_t _1;
    // Computing bound for e
    int64_t _2 = 921;
    int64_t _3 = -_2;
    int64_t _4 = 856;
    int64_t _5 = -_4;
    int64_t _6 = -_5;
    int64_t _7 = 687;
    int64_t _8 = -_7;
    int64_t _9 = _6 + _8;
    int64_t _10 = _3 * _9;
    _1.d0 = _10;
    if (_10 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for f
    int64_t _11;
    // Computing bound for e
    int64_t _12 = 776;
    if (_12 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing bound for f
    _a2_int64_t _13;
    // Computing bound for e
    int64_t _14 = 915;
    _13.d0 = _14;
    if (_14 > 0) 
    goto _jump546;
    fail_assertion("non-positive loop bound");
    _jump546:;
    // Computing bound for f
    int64_t _15 = 154;
    _13.d1 = _15;
    if (_15 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _14;
    _16 *= _15;
    _16 *= sizeof(int64_t);
    _13.data = jpl_alloc(_16);
    int64_t _17 = 0; // f
    int64_t _18 = 0; // e
    _jump548:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _13.d0;
    _19 += _18;
    _19 *= _13.d1;
    _19 += _17;
    _13.data[_19] = _18;
    _17++;
    if (_17 < _15)
    goto _jump548;
    _17 = 0;
    _18++;
    if (_18 < _14)
    goto _jump548;
    // End body of loop
    int64_t _20 = 111;
    int64_t _21 = -_20;
    int64_t _22 = 494;
    int64_t _23 = _21 % _22;
    int64_t _24 = 134;
    int64_t _25 = -_24;
    if (_23 >= 0)
    goto _jump549;
    fail_assertion("negative array index");
    _jump549:;
    if (_23 < _13.d0)
    goto _jump550;
    fail_assertion("index too large");
    _jump550:;
    if (_25 >= 0)
    goto _jump551;
    fail_assertion("negative array index");
    _jump551:;
    if (_25 < _13.d1)
    goto _jump552;
    fail_assertion("index too large");
    _jump552:;
    int64_t _26 = 0;
    _26 *= _13.d0;
    _26 += _23;
    _26 *= _13.d1;
    _26 += _25;
    int64_t _27 = _13.data[_26];
    if (_27 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    _11 = 0;
    int64_t _28 = 0; // f
    int64_t _29 = 0; // e
    _jump554:; // Begin body of loop
    int64_t _30 = _28 * _28;
    _11 += _30;
    _28++;
    if (_28 < _27)
    goto _jump554;
    _28 = 0;
    _29++;
    if (_29 < _12)
    goto _jump554;
    // End body of loop
    int64_t _31 = -_11;
    _1.d1 = _31;
    if (_31 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing bound for g
    int64_t _32;
    // Computing bound for e
    int64_t _33;
    // Computing bound for e
    int64_t _34 = 810;
    int64_t _35 = -_34;
    int64_t _36 = 411;
    int64_t _37 = -_36;
    int64_t _38 = _35 - _37;
    if (_38 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing bound for f
    int64_t _39 = 388;
    _a1_int64_t _40;
    _40.d0 = 1;
    _40.data = jpl_alloc(sizeof(int64_t) * 1);
    _40.data[0] = _39;
    int64_t _41 = 725;
    int64_t _42 = -_41;
    int64_t _43 = 458;
    int64_t _44 = _42 % _43;
    if (_44 >= 0)
    goto _jump557;
    fail_assertion("negative array index");
    _jump557:;
    if (_44 < _40.d0)
    goto _jump558;
    fail_assertion("index too large");
    _jump558:;
    int64_t _45 = 0;
    _45 *= _40.d0;
    _45 += _44;
    int64_t _46 = _40.data[_45];
    if (_46 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    _33 = 0;
    int64_t _47 = 0; // f
    int64_t _48 = 0; // e
    _jump560:; // Begin body of loop
    _a2_int64_t _49;
    // Computing bound for g
    int64_t _50 = -_48;
    _49.d0 = _50;
    if (_50 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for h
    int64_t _51 = 984;
    _49.d1 = _51;
    if (_51 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= _50;
    _52 *= _51;
    _52 *= sizeof(int64_t);
    _49.data = jpl_alloc(_52);
    int64_t _53 = 0; // h
    int64_t _54 = 0; // g
    _jump563:; // Begin body of loop
    int64_t _55 = _53 * _47;
    int64_t _56 = 0;
    _56 *= _49.d0;
    _56 += _54;
    _56 *= _49.d1;
    _56 += _53;
    _49.data[_56] = _55;
    _53++;
    if (_53 < _51)
    goto _jump563;
    _53 = 0;
    _54++;
    if (_54 < _50)
    goto _jump563;
    // End body of loop
    int64_t _57;
    // Computing bound for g
    if (_47 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing bound for h
    int64_t _58 = -_48;
    if (_58 > 0) 
    goto _jump565;
    fail_assertion("non-positive loop bound");
    _jump565:;
    _57 = 0;
    int64_t _59 = 0; // h
    int64_t _60 = 0; // g
    _jump566:; // Begin body of loop
    _57 += _60;
    _59++;
    if (_59 < _58)
    goto _jump566;
    _59 = 0;
    _60++;
    if (_60 < _47)
    goto _jump566;
    // End body of loop
    int64_t _61 = 720;
    if (_57 >= 0)
    goto _jump567;
    fail_assertion("negative array index");
    _jump567:;
    if (_57 < _49.d0)
    goto _jump568;
    fail_assertion("index too large");
    _jump568:;
    if (_61 >= 0)
    goto _jump569;
    fail_assertion("negative array index");
    _jump569:;
    if (_61 < _49.d1)
    goto _jump570;
    fail_assertion("index too large");
    _jump570:;
    int64_t _62 = 0;
    _62 *= _49.d0;
    _62 += _57;
    _62 *= _49.d1;
    _62 += _61;
    int64_t _63 = _49.data[_62];
    _33 += _63;
    _47++;
    if (_47 < _46)
    goto _jump560;
    _47 = 0;
    _48++;
    if (_48 < _38)
    goto _jump560;
    // End body of loop
    if (_33 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing bound for f
    bool _64 = c(d);
    int64_t _65;
    if (!_64)
    goto _jump572;
    int64_t _66 = 324;
    int64_t _67 = 719;
    _a1_int64_t _68;
    _68.d0 = 2;
    _68.data = jpl_alloc(sizeof(int64_t) * 2);
    _68.data[0] = _66;
    _68.data[1] = _67;
    int64_t _69 = 944;
    if (_69 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (_69 < _68.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    int64_t _70 = 0;
    _70 *= _68.d0;
    _70 += _69;
    int64_t _71 = _68.data[_70];
    _65 = _71;
    goto _jump575;
    _jump572:;
    int64_t _72 = 161;
    _65 = _72;
    _jump575:;
    if (_65 > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    _32 = 0;
    int64_t _73 = 0; // f
    int64_t _74 = 0; // e
    _jump577:; // Begin body of loop
    int64_t _75;
    // Computing bound for g
    if (_74 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing bound for h
    int64_t _76 = 752;
    if (_76 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    _75 = 0;
    int64_t _77 = 0; // h
    int64_t _78 = 0; // g
    _jump580:; // Begin body of loop
    int64_t _79 = 740;
    _75 += _79;
    _77++;
    if (_77 < _76)
    goto _jump580;
    _77 = 0;
    _78++;
    if (_78 < _74)
    goto _jump580;
    // End body of loop
    _32 += _75;
    _73++;
    if (_73 < _65)
    goto _jump577;
    _73 = 0;
    _74++;
    if (_74 < _33)
    goto _jump577;
    // End body of loop
    _1.d2 = _32;
    if (_32 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= _10;
    _80 *= _31;
    _80 *= _32;
    _80 *= sizeof(_a2_int64_t);
    _1.data = jpl_alloc(_80);
    int64_t _81 = 0; // g
    int64_t _82 = 0; // f
    int64_t _83 = 0; // e
    _jump582:; // Begin body of loop
    bool _86 = true;
    bool _88 = true;
    bool _87 = _88;
    if (0 != _88)
    goto _jump583;
    bool _89 = true;
    _87 = _89;
    _jump583:;
    bool _90 = _86 != _87;
    bool _85 = _90;
    if (0 == _90)
    goto _jump584;
    bool _92 = true;
    bool _91 = _92;
    if (0 == _92)
    goto _jump585;
    int64_t _93 = 377;
    bool _94 = _82 == _93;
    _91 = _94;
    _jump585:;
    _85 = _91;
    _jump584:;
    bool _84 = _85;
    if (0 == _85)
    goto _jump586;
    bool _95 = false;
    _84 = _95;
    _jump586:;
    _a2_int64_t _96;
    if (!_84)
    goto _jump587;
    bool _97 = false;
    bool _98 = !_97;
    _a2__a2_int64_t _99;
    if (!_98)
    goto _jump588;
    _a2__a2_int64_t _100;
    // Computing bound for h
    _100.d0 = _83;
    if (_83 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing bound for i
    int64_t _101 = 326;
    int64_t _102 = _101 * _83;
    _100.d1 = _102;
    if (_102 > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= _83;
    _103 *= _102;
    _103 *= sizeof(_a2_int64_t);
    _100.data = jpl_alloc(_103);
    int64_t _104 = 0; // i
    int64_t _105 = 0; // h
    _jump591:; // Begin body of loop
    _a2_int64_t _106;
    // Computing bound for j
    _106.d0 = _105;
    if (_105 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    // Computing bound for k
    _106.d1 = _105;
    if (_105 > 0) 
    goto _jump593;
    fail_assertion("non-positive loop bound");
    _jump593:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= _105;
    _107 *= _105;
    _107 *= sizeof(int64_t);
    _106.data = jpl_alloc(_107);
    int64_t _108 = 0; // k
    int64_t _109 = 0; // j
    _jump594:; // Begin body of loop
    int64_t _110 = 0;
    _110 *= _106.d0;
    _110 += _109;
    _110 *= _106.d1;
    _110 += _108;
    _106.data[_110] = _82;
    _108++;
    if (_108 < _105)
    goto _jump594;
    _108 = 0;
    _109++;
    if (_109 < _105)
    goto _jump594;
    // End body of loop
    int64_t _111 = 0;
    _111 *= _100.d0;
    _111 += _105;
    _111 *= _100.d1;
    _111 += _104;
    _100.data[_111] = _106;
    _104++;
    if (_104 < _102)
    goto _jump591;
    _104 = 0;
    _105++;
    if (_105 < _83)
    goto _jump591;
    // End body of loop
    _99 = _100;
    goto _jump595;
    _jump588:;
    _a2__a2_int64_t _112;
    // Computing bound for h
    int64_t _113 = 36;
    int64_t _114 = -_113;
    _112.d0 = _114;
    if (_114 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    // Computing bound for i
    _112.d1 = _81;
    if (_81 > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _114;
    _115 *= _81;
    _115 *= sizeof(_a2_int64_t);
    _112.data = jpl_alloc(_115);
    int64_t _116 = 0; // i
    int64_t _117 = 0; // h
    _jump598:; // Begin body of loop
    _a2_int64_t _118;
    // Computing bound for j
    _118.d0 = _117;
    if (_117 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    // Computing bound for k
    int64_t _119 = 257;
    _118.d1 = _119;
    if (_119 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing total size of heap memory to allocate
    int64_t _120 = 1;
    _120 *= _117;
    _120 *= _119;
    _120 *= sizeof(int64_t);
    _118.data = jpl_alloc(_120);
    int64_t _121 = 0; // k
    int64_t _122 = 0; // j
    _jump601:; // Begin body of loop
    int64_t _123 = 0;
    _123 *= _118.d0;
    _123 += _122;
    _123 *= _118.d1;
    _123 += _121;
    _118.data[_123] = _81;
    _121++;
    if (_121 < _119)
    goto _jump601;
    _121 = 0;
    _122++;
    if (_122 < _117)
    goto _jump601;
    // End body of loop
    int64_t _124 = 0;
    _124 *= _112.d0;
    _124 += _117;
    _124 *= _112.d1;
    _124 += _116;
    _112.data[_124] = _118;
    _116++;
    if (_116 < _81)
    goto _jump598;
    _116 = 0;
    _117++;
    if (_117 < _114)
    goto _jump598;
    // End body of loop
    _99 = _112;
    _jump595:;
    if (_83 >= 0)
    goto _jump602;
    fail_assertion("negative array index");
    _jump602:;
    if (_83 < _99.d0)
    goto _jump603;
    fail_assertion("index too large");
    _jump603:;
    if (_81 >= 0)
    goto _jump604;
    fail_assertion("negative array index");
    _jump604:;
    if (_81 < _99.d1)
    goto _jump605;
    fail_assertion("index too large");
    _jump605:;
    int64_t _125 = 0;
    _125 *= _99.d0;
    _125 += _83;
    _125 *= _99.d1;
    _125 += _81;
    _a2_int64_t _126 = _99.data[_125];
    _96 = _126;
    goto _jump606;
    _jump587:;
    if (_83 >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (_83 < a.d0)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    int64_t _128 = 0;
    _128 *= a.d0;
    _128 += _83;
    bool _129 = a.data[_128];
    bool _127 = _129;
    if (0 == _129)
    goto _jump609;
    bool _130 = c(d);
    _127 = _130;
    _jump609:;
    _a1__a2_int64_t _131;
    if (!_127)
    goto _jump610;
    _a2_int64_t _132;
    // Computing bound for h
    _132.d0 = _81;
    if (_81 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for i
    _132.d1 = _81;
    if (_81 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _81;
    _133 *= _81;
    _133 *= sizeof(int64_t);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // i
    int64_t _135 = 0; // h
    _jump613:; // Begin body of loop
    int64_t _136 = 0;
    _136 *= _132.d0;
    _136 += _135;
    _136 *= _132.d1;
    _136 += _134;
    _132.data[_136] = _135;
    _134++;
    if (_134 < _81)
    goto _jump613;
    _134 = 0;
    _135++;
    if (_135 < _81)
    goto _jump613;
    // End body of loop
    _a1__a2_int64_t _137;
    _137.d0 = 1;
    _137.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _137.data[0] = _132;
    _131 = _137;
    goto _jump614;
    _jump610:;
    _a2_int64_t _138;
    // Computing bound for h
    _138.d0 = _81;
    if (_81 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing bound for i
    _138.d1 = _83;
    if (_83 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= _81;
    _139 *= _83;
    _139 *= sizeof(int64_t);
    _138.data = jpl_alloc(_139);
    int64_t _140 = 0; // i
    int64_t _141 = 0; // h
    _jump617:; // Begin body of loop
    int64_t _142 = 921;
    int64_t _143 = 0;
    _143 *= _138.d0;
    _143 += _141;
    _143 *= _138.d1;
    _143 += _140;
    _138.data[_143] = _142;
    _140++;
    if (_140 < _83)
    goto _jump617;
    _140 = 0;
    _141++;
    if (_141 < _81)
    goto _jump617;
    // End body of loop
    _a1__a2_int64_t _144;
    _144.d0 = 1;
    _144.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _144.data[0] = _138;
    _131 = _144;
    _jump614:;
    if (_82 >= 0)
    goto _jump618;
    fail_assertion("negative array index");
    _jump618:;
    if (_82 < _131.d0)
    goto _jump619;
    fail_assertion("index too large");
    _jump619:;
    int64_t _145 = 0;
    _145 *= _131.d0;
    _145 += _82;
    _a2_int64_t _146 = _131.data[_145];
    _96 = _146;
    _jump606:;
    int64_t _147 = 0;
    _147 *= _1.d0;
    _147 += _83;
    _147 *= _1.d1;
    _147 += _82;
    _147 *= _1.d2;
    _147 += _81;
    _1.data[_147] = _96;
    _81++;
    if (_81 < _32)
    goto _jump582;
    _81 = 0;
    _82++;
    if (_82 < _31)
    goto _jump582;
    _82 = 0;
    _83++;
    if (_83 < _10)
    goto _jump582;
    // End body of loop
    double _148 = 70.0;
    double _149 = -_148;
    double _150 = 25.0;
    bool _151 = false;
    double _152;
    if (!_151)
    goto _jump620;
    double _153 = 71.0;
    _152 = _153;
    goto _jump621;
    _jump620:;
    double _154 = 86.0;
    _152 = _154;
    _jump621:;
    double _155 = -_152;
    double _156 = _150 / _155;
    bool _157 = _149 <= _156;
    bool _158 = !_157;
    int64_t _159;
    if (!_158)
    goto _jump622;
    int64_t _160;
    // Computing bound for e
    int64_t _161 = 684;
    int64_t _162 = -_161;
    if (_162 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    // Computing bound for f
    int64_t _163 = 498;
    int64_t _164 = -_163;
    int64_t _165 = 95;
    int64_t _166 = _164 / _165;
    int64_t _167 = -_166;
    if (_167 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    _160 = 0;
    int64_t _168 = 0; // f
    int64_t _169 = 0; // e
    _jump625:; // Begin body of loop
    int64_t _170 = 792;
    int64_t _171 = _169 + _170;
    _160 += _171;
    _168++;
    if (_168 < _167)
    goto _jump625;
    _168 = 0;
    _169++;
    if (_169 < _162)
    goto _jump625;
    // End body of loop
    _159 = _160;
    goto _jump626;
    _jump622:;
    int64_t _172 = 629;
    _159 = _172;
    _jump626:;
    int64_t _173;
    // Computing bound for e
    int64_t _174 = 180;
    int64_t _175 = 111;
    int64_t _176 = _174 / _175;
    int64_t _177 = -_176;
    if (_177 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    // Computing bound for f
    bool _178 = true;
    bool _179 = !_178;
    _a2_int64_t _180;
    if (!_179)
    goto _jump628;
    _a2_int64_t _181;
    // Computing bound for e
    int64_t _182 = 631;
    _181.d0 = _182;
    if (_182 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    // Computing bound for f
    int64_t _183 = 251;
    int64_t _184 = 761;
    int64_t _185 = _183 + _184;
    _181.d1 = _185;
    if (_185 > 0) 
    goto _jump630;
    fail_assertion("non-positive loop bound");
    _jump630:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= _182;
    _186 *= _185;
    _186 *= sizeof(int64_t);
    _181.data = jpl_alloc(_186);
    int64_t _187 = 0; // f
    int64_t _188 = 0; // e
    _jump631:; // Begin body of loop
    int64_t _189 = 0;
    _189 *= _181.d0;
    _189 += _188;
    _189 *= _181.d1;
    _189 += _187;
    _181.data[_189] = _187;
    _187++;
    if (_187 < _185)
    goto _jump631;
    _187 = 0;
    _188++;
    if (_188 < _182)
    goto _jump631;
    // End body of loop
    _180 = _181;
    goto _jump632;
    _jump628:;
    _a2_int64_t _190;
    // Computing bound for e
    int64_t _191 = 705;
    _190.d0 = _191;
    if (_191 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing bound for f
    int64_t _192 = 281;
    int64_t _193 = -_192;
    _190.d1 = _193;
    if (_193 > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= _191;
    _194 *= _193;
    _194 *= sizeof(int64_t);
    _190.data = jpl_alloc(_194);
    int64_t _195 = 0; // f
    int64_t _196 = 0; // e
    _jump635:; // Begin body of loop
    int64_t _197 = 0;
    _197 *= _190.d0;
    _197 += _196;
    _197 *= _190.d1;
    _197 += _195;
    _190.data[_197] = _196;
    _195++;
    if (_195 < _193)
    goto _jump635;
    _195 = 0;
    _196++;
    if (_196 < _191)
    goto _jump635;
    // End body of loop
    _180 = _190;
    _jump632:;
    int64_t _198;
    // Computing bound for e
    int64_t _199 = 243;
    int64_t _200 = -_199;
    if (_200 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for f
    int64_t _201 = 510;
    int64_t _202 = 67;
    int64_t _203 = _201 + _202;
    if (_203 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for g
    int64_t _204 = 433;
    int64_t _205 = 215;
    int64_t _206 = _204 * _205;
    if (_206 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    _198 = 0;
    int64_t _207 = 0; // g
    int64_t _208 = 0; // f
    int64_t _209 = 0; // e
    _jump639:; // Begin body of loop
    _198 += _209;
    _207++;
    if (_207 < _206)
    goto _jump639;
    _207 = 0;
    _208++;
    if (_208 < _203)
    goto _jump639;
    _208 = 0;
    _209++;
    if (_209 < _200)
    goto _jump639;
    // End body of loop
    int64_t _210 = -_198;
    int64_t _211 = 78;
    int64_t _212 = -_211;
    int64_t _213 = -_212;
    int64_t _214 = -_213;
    if (_210 >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (_210 < _180.d0)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    if (_214 >= 0)
    goto _jump642;
    fail_assertion("negative array index");
    _jump642:;
    if (_214 < _180.d1)
    goto _jump643;
    fail_assertion("index too large");
    _jump643:;
    int64_t _215 = 0;
    _215 *= _180.d0;
    _215 += _210;
    _215 *= _180.d1;
    _215 += _214;
    int64_t _216 = _180.data[_215];
    if (_216 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    _173 = 0;
    int64_t _217 = 0; // f
    int64_t _218 = 0; // e
    _jump645:; // Begin body of loop
    _173 += _218;
    _217++;
    if (_217 < _216)
    goto _jump645;
    _217 = 0;
    _218++;
    if (_218 < _177)
    goto _jump645;
    // End body of loop
    int64_t _219 = -_173;
    _a3_rgba _220;
    // Computing bound for e
    bool _221 = c(d);
    int64_t _222;
    if (!_221)
    goto _jump646;
    int64_t _223 = 270;
    _222 = _223;
    goto _jump647;
    _jump646:;
    int64_t _224 = 205;
    _222 = _224;
    _jump647:;
    _220.d0 = _222;
    if (_222 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing bound for f
    int64_t _225;
    // Computing bound for e
    int64_t _226 = 461;
    if (_226 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    _225 = 0;
    int64_t _227 = 0; // e
    _jump650:; // Begin body of loop
    int64_t _228 = 669;
    _a1_int64_t _229;
    _229.d0 = 2;
    _229.data = jpl_alloc(sizeof(int64_t) * 2);
    _229.data[0] = _228;
    _229.data[1] = _227;
    _a2_int64_t _230;
    // Computing bound for f
    int64_t _231 = 266;
    _230.d0 = _231;
    if (_231 > 0) 
    goto _jump651;
    fail_assertion("non-positive loop bound");
    _jump651:;
    // Computing bound for g
    int64_t _232 = 59;
    _230.d1 = _232;
    if (_232 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= _231;
    _233 *= _232;
    _233 *= sizeof(int64_t);
    _230.data = jpl_alloc(_233);
    int64_t _234 = 0; // g
    int64_t _235 = 0; // f
    _jump653:; // Begin body of loop
    int64_t _236 = 0;
    _236 *= _230.d0;
    _236 += _235;
    _236 *= _230.d1;
    _236 += _234;
    _230.data[_236] = _227;
    _234++;
    if (_234 < _232)
    goto _jump653;
    _234 = 0;
    _235++;
    if (_235 < _231)
    goto _jump653;
    // End body of loop
    int64_t _237 = 552;
    if (_237 >= 0)
    goto _jump654;
    fail_assertion("negative array index");
    _jump654:;
    if (_237 < _230.d0)
    goto _jump655;
    fail_assertion("index too large");
    _jump655:;
    if (_227 >= 0)
    goto _jump656;
    fail_assertion("negative array index");
    _jump656:;
    if (_227 < _230.d1)
    goto _jump657;
    fail_assertion("index too large");
    _jump657:;
    int64_t _238 = 0;
    _238 *= _230.d0;
    _238 += _237;
    _238 *= _230.d1;
    _238 += _227;
    int64_t _239 = _230.data[_238];
    if (_239 >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (_239 < _229.d0)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    int64_t _240 = 0;
    _240 *= _229.d0;
    _240 += _239;
    int64_t _241 = _229.data[_240];
    _225 += _241;
    _227++;
    if (_227 < _226)
    goto _jump650;
    // End body of loop
    _220.d1 = _225;
    if (_225 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for g
    int64_t _242 = 133;
    _220.d2 = _242;
    if (_242 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= _222;
    _243 *= _225;
    _243 *= _242;
    _243 *= sizeof(rgba);
    _220.data = jpl_alloc(_243);
    int64_t _244 = 0; // g
    int64_t _245 = 0; // f
    int64_t _246 = 0; // e
    _jump662:; // Begin body of loop
    double _247;
    // Computing bound for h
    int64_t _248;
    // Computing bound for h
    int64_t _249 = 844;
    int64_t _250 = _249 * _244;
    if (_250 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing bound for i
    int64_t _251 = 594;
    if (_251 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for j
    int64_t _252;
    // Computing bound for h
    if (_244 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for i
    if (_246 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing bound for j
    if (_244 > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    _252 = 0;
    int64_t _253 = 0; // j
    int64_t _254 = 0; // i
    int64_t _255 = 0; // h
    _jump668:; // Begin body of loop
    _252 += _254;
    _253++;
    if (_253 < _244)
    goto _jump668;
    _253 = 0;
    _254++;
    if (_254 < _246)
    goto _jump668;
    _254 = 0;
    _255++;
    if (_255 < _244)
    goto _jump668;
    // End body of loop
    if (_252 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    _248 = 0;
    int64_t _256 = 0; // j
    int64_t _257 = 0; // i
    int64_t _258 = 0; // h
    _jump670:; // Begin body of loop
    _248 += _256;
    _256++;
    if (_256 < _252)
    goto _jump670;
    _256 = 0;
    _257++;
    if (_257 < _251)
    goto _jump670;
    _257 = 0;
    _258++;
    if (_258 < _250)
    goto _jump670;
    // End body of loop
    if (_248 > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    // Computing bound for i
    int64_t _259 = -_244;
    if (_259 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    _247 = 0;
    int64_t _260 = 0; // i
    int64_t _261 = 0; // h
    _jump673:; // Begin body of loop
    double _262;
    // Computing bound for j
    if (_245 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing bound for k
    if (_246 > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    _262 = 0;
    int64_t _263 = 0; // k
    int64_t _264 = 0; // j
    _jump676:; // Begin body of loop
    double _265;
    // Computing bound for l
    if (_245 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    // Computing bound for m
    if (_264 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing bound for n
    int64_t _266 = 532;
    if (_266 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    _265 = 0;
    int64_t _267 = 0; // n
    int64_t _268 = 0; // m
    int64_t _269 = 0; // l
    _jump680:; // Begin body of loop
    double _270 = 92.0;
    _265 += _270;
    _267++;
    if (_267 < _266)
    goto _jump680;
    _267 = 0;
    _268++;
    if (_268 < _264)
    goto _jump680;
    _268 = 0;
    _269++;
    if (_269 < _245)
    goto _jump680;
    // End body of loop
    _262 += _265;
    _263++;
    if (_263 < _246)
    goto _jump676;
    _263 = 0;
    _264++;
    if (_264 < _245)
    goto _jump676;
    // End body of loop
    _247 += _262;
    _260++;
    if (_260 < _259)
    goto _jump673;
    _260 = 0;
    _261++;
    if (_261 < _248)
    goto _jump673;
    // End body of loop
    bool _271 = _244 >= _244;
    if (_244 >= 0)
    goto _jump681;
    fail_assertion("negative array index");
    _jump681:;
    if (_244 < a.d0)
    goto _jump682;
    fail_assertion("index too large");
    _jump682:;
    int64_t _272 = 0;
    _272 *= a.d0;
    _272 += _244;
    bool _273 = a.data[_272];
    bool _274 = _271 != _273;
    double _275;
    if (!_274)
    goto _jump683;
    double _276 = 80.0;
    double _277 = -_276;
    _275 = _277;
    goto _jump684;
    _jump683:;
    bool _278 = false;
    double _279;
    if (!_278)
    goto _jump685;
    double _280 = 75.0;
    _279 = _280;
    goto _jump686;
    _jump685:;
    double _281 = 87.0;
    double _282 = -_281;
    _279 = _282;
    _jump686:;
    _275 = _279;
    _jump684:;
    if (_244 >= 0)
    goto _jump687;
    fail_assertion("negative array index");
    _jump687:;
    if (_244 < a.d0)
    goto _jump688;
    fail_assertion("index too large");
    _jump688:;
    int64_t _283 = 0;
    _283 *= a.d0;
    _283 += _244;
    bool _284 = a.data[_283];
    double _285;
    if (!_284)
    goto _jump689;
    double _286 = 40.0;
    _285 = _286;
    goto _jump690;
    _jump689:;
    double _287 = 63.0;
    _285 = _287;
    _jump690:;
    double _288 = -_285;
    double _289 = 80.0;
    rgba _290 = { _247, _275, _288, _289 };
    int64_t _291 = 0;
    _291 *= _220.d0;
    _291 += _246;
    _291 *= _220.d1;
    _291 += _245;
    _291 *= _220.d2;
    _291 += _244;
    _220.data[_291] = _290;
    _244++;
    if (_244 < _242)
    goto _jump662;
    _244 = 0;
    _245++;
    if (_245 < _225)
    goto _jump662;
    _245 = 0;
    _246++;
    if (_246 < _222)
    goto _jump662;
    // End body of loop
    _a2_rgba _292;
    // Computing bound for e
    int64_t _293 = 673;
    _292.d0 = _293;
    if (_293 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for f
    int64_t _294 = 862;
    int64_t _295 = -_294;
    _292.d1 = _295;
    if (_295 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _293;
    _296 *= _295;
    _296 *= sizeof(rgba);
    _292.data = jpl_alloc(_296);
    int64_t _297 = 0; // f
    int64_t _298 = 0; // e
    _jump693:; // Begin body of loop
    double _299;
    // Computing bound for g
    if (_297 > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    _299 = 0;
    int64_t _300 = 0; // g
    _jump695:; // Begin body of loop
    double _301 = 80.0;
    _299 += _301;
    _300++;
    if (_300 < _297)
    goto _jump695;
    // End body of loop
    double _302 = 18.0;
    double _303 = -_302;
    double _304 = _299 * _303;
    double _305 = -_304;
    _a3_double _306;
    // Computing bound for g
    _306.d0 = _298;
    if (_298 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for h
    int64_t _307 = 579;
    _306.d1 = _307;
    if (_307 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    // Computing bound for i
    _306.d2 = _298;
    if (_298 > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= _298;
    _308 *= _307;
    _308 *= _298;
    _308 *= sizeof(double);
    _306.data = jpl_alloc(_308);
    int64_t _309 = 0; // i
    int64_t _310 = 0; // h
    int64_t _311 = 0; // g
    _jump699:; // Begin body of loop
    double _312 = 51.0;
    double _313 = -_312;
    int64_t _314 = 0;
    _314 *= _306.d0;
    _314 += _311;
    _314 *= _306.d1;
    _314 += _310;
    _314 *= _306.d2;
    _314 += _309;
    _306.data[_314] = _313;
    _309++;
    if (_309 < _298)
    goto _jump699;
    _309 = 0;
    _310++;
    if (_310 < _307)
    goto _jump699;
    _310 = 0;
    _311++;
    if (_311 < _298)
    goto _jump699;
    // End body of loop
    int64_t _315;
    // Computing bound for g
    if (_297 > 0) 
    goto _jump700;
    fail_assertion("non-positive loop bound");
    _jump700:;
    // Computing bound for h
    if (_298 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    _315 = 0;
    int64_t _316 = 0; // h
    int64_t _317 = 0; // g
    _jump702:; // Begin body of loop
    _315 += _297;
    _316++;
    if (_316 < _298)
    goto _jump702;
    _316 = 0;
    _317++;
    if (_317 < _297)
    goto _jump702;
    // End body of loop
    int64_t _318 = _298 / _315;
    _a1_int64_t _319;
    // Computing bound for g
    int64_t _320 = 615;
    _319.d0 = _320;
    if (_320 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= _320;
    _321 *= sizeof(int64_t);
    _319.data = jpl_alloc(_321);
    int64_t _322 = 0; // g
    _jump704:; // Begin body of loop
    int64_t _323 = 0;
    _323 *= _319.d0;
    _323 += _322;
    _319.data[_323] = _322;
    _322++;
    if (_322 < _320)
    goto _jump704;
    // End body of loop
    int64_t _324 = 904;
    int64_t _325 = _324 * _297;
    if (_325 >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (_325 < _319.d0)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    int64_t _326 = 0;
    _326 *= _319.d0;
    _326 += _325;
    int64_t _327 = _319.data[_326];
    if (_318 >= 0)
    goto _jump707;
    fail_assertion("negative array index");
    _jump707:;
    if (_318 < _306.d0)
    goto _jump708;
    fail_assertion("index too large");
    _jump708:;
    if (_298 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (_298 < _306.d1)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    if (_327 >= 0)
    goto _jump711;
    fail_assertion("negative array index");
    _jump711:;
    if (_327 < _306.d2)
    goto _jump712;
    fail_assertion("index too large");
    _jump712:;
    int64_t _328 = 0;
    _328 *= _306.d0;
    _328 += _318;
    _328 *= _306.d1;
    _328 += _298;
    _328 *= _306.d2;
    _328 += _327;
    double _329 = _306.data[_328];
    bool _330 = false;
    double _331;
    if (!_330)
    goto _jump713;
    double _332 = 1.0;
    double _333 = 13.0;
    double _334 = _332 * _333;
    _331 = _334;
    goto _jump714;
    _jump713:;
    double _335 = 66.0;
    _331 = _335;
    _jump714:;
    double _336 = 95.0;
    rgba _337 = { _305, _329, _331, _336 };
    int64_t _338 = 0;
    _338 *= _292.d0;
    _338 += _298;
    _338 *= _292.d1;
    _338 += _297;
    _292.data[_338] = _337;
    _297++;
    if (_297 < _295)
    goto _jump693;
    _297 = 0;
    _298++;
    if (_298 < _293)
    goto _jump693;
    // End body of loop
    int64_t _339 = b(_220, a, _292);
    if (_159 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_159 < _1.d0)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    if (_219 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (_219 < _1.d1)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    if (_339 >= 0)
    goto _jump719;
    fail_assertion("negative array index");
    _jump719:;
    if (_339 < _1.d2)
    goto _jump720;
    fail_assertion("index too large");
    _jump720:;
    int64_t _340 = 0;
    _340 *= _1.d0;
    _340 += _159;
    _340 *= _1.d1;
    _340 += _219;
    _340 *= _1.d2;
    _340 += _339;
    _a2_int64_t _341 = _1.data[_340];
    _a3_bool _343;
    // Computing bound for h
    _343.d0 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for i
    int64_t _344 = _341.d1 / _341.d0;
    _343.d1 = _344;
    if (_344 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing bound for j
    int64_t _345 = 828;
    int64_t _346 = -_345;
    _343.d2 = _346;
    if (_346 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    // Computing total size of heap memory to allocate
    int64_t _347 = 1;
    _347 *= _341.d0;
    _347 *= _344;
    _347 *= _346;
    _347 *= sizeof(bool);
    _343.data = jpl_alloc(_347);
    int64_t _348 = 0; // j
    int64_t _349 = 0; // i
    int64_t _350 = 0; // h
    _jump724:; // Begin body of loop
    bool _351 = true;
    bool _352 = !_351;
    int64_t _353 = 0;
    _353 *= _343.d0;
    _353 += _350;
    _353 *= _343.d1;
    _353 += _349;
    _353 *= _343.d2;
    _353 += _348;
    _343.data[_353] = _352;
    _348++;
    if (_348 < _346)
    goto _jump724;
    _348 = 0;
    _349++;
    if (_349 < _344)
    goto _jump724;
    _349 = 0;
    _350++;
    if (_350 < _341.d0)
    goto _jump724;
    // End body of loop
    int64_t _354 = -_341.d1;
    int64_t _355;
    // Computing bound for h
    int64_t _356 = 822;
    if (_356 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing bound for i
    if (_341.d0 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    _355 = 0;
    int64_t _357 = 0; // i
    int64_t _358 = 0; // h
    _jump727:; // Begin body of loop
    _355 += _341.d0;
    _357++;
    if (_357 < _341.d0)
    goto _jump727;
    _357 = 0;
    _358++;
    if (_358 < _356)
    goto _jump727;
    // End body of loop
    if (_341.d1 >= 0)
    goto _jump728;
    fail_assertion("negative array index");
    _jump728:;
    if (_341.d1 < _343.d0)
    goto _jump729;
    fail_assertion("index too large");
    _jump729:;
    if (_354 >= 0)
    goto _jump730;
    fail_assertion("negative array index");
    _jump730:;
    if (_354 < _343.d1)
    goto _jump731;
    fail_assertion("index too large");
    _jump731:;
    if (_355 >= 0)
    goto _jump732;
    fail_assertion("negative array index");
    _jump732:;
    if (_355 < _343.d2)
    goto _jump733;
    fail_assertion("index too large");
    _jump733:;
    int64_t _359 = 0;
    _359 *= _343.d0;
    _359 += _341.d1;
    _359 *= _343.d1;
    _359 += _354;
    _359 *= _343.d2;
    _359 += _355;
    bool _360 = _343.data[_359];
    _a2_bool _361;
    if (!_360)
    goto _jump734;
    bool _363 = true;
    bool _364 = !_363;
    bool _362 = _364;
    if (0 != _364)
    goto _jump735;
    bool _365 = c(d);
    _362 = _365;
    _jump735:;
    _a2_bool _366;
    if (!_362)
    goto _jump736;
    _a2_bool _367;
    // Computing bound for h
    int64_t _368;
    // Computing bound for h
    int64_t _369 = 859;
    if (_369 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    _368 = 0;
    int64_t _370 = 0; // h
    _jump738:; // Begin body of loop
    _368 += _341.d0;
    _370++;
    if (_370 < _369)
    goto _jump738;
    // End body of loop
    _367.d0 = _368;
    if (_368 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing bound for i
    _367.d1 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    // Computing total size of heap memory to allocate
    int64_t _371 = 1;
    _371 *= _368;
    _371 *= _341.d1;
    _371 *= sizeof(bool);
    _367.data = jpl_alloc(_371);
    int64_t _372 = 0; // i
    int64_t _373 = 0; // h
    _jump741:; // Begin body of loop
    bool _374 = c(d);
    int64_t _375 = 0;
    _375 *= _367.d0;
    _375 += _373;
    _375 *= _367.d1;
    _375 += _372;
    _367.data[_375] = _374;
    _372++;
    if (_372 < _341.d1)
    goto _jump741;
    _372 = 0;
    _373++;
    if (_373 < _368)
    goto _jump741;
    // End body of loop
    _366 = _367;
    goto _jump742;
    _jump736:;
    _a2_bool _376;
    // Computing bound for h
    int64_t _377 = 384;
    int64_t _378 = _341.d0 - _377;
    _376.d0 = _378;
    if (_378 > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing bound for i
    int64_t _379 = 121;
    int64_t _380 = -_379;
    _376.d1 = _380;
    if (_380 > 0) 
    goto _jump744;
    fail_assertion("non-positive loop bound");
    _jump744:;
    // Computing total size of heap memory to allocate
    int64_t _381 = 1;
    _381 *= _378;
    _381 *= _380;
    _381 *= sizeof(bool);
    _376.data = jpl_alloc(_381);
    int64_t _382 = 0; // i
    int64_t _383 = 0; // h
    _jump745:; // Begin body of loop
    double _384 = 25.0;
    double _385 = 39.0;
    bool _386 = _384 < _385;
    int64_t _387 = 0;
    _387 *= _376.d0;
    _387 += _383;
    _387 *= _376.d1;
    _387 += _382;
    _376.data[_387] = _386;
    _382++;
    if (_382 < _380)
    goto _jump745;
    _382 = 0;
    _383++;
    if (_383 < _378)
    goto _jump745;
    // End body of loop
    _366 = _376;
    _jump742:;
    _361 = _366;
    goto _jump746;
    _jump734:;
    _a2_bool _388;
    // Computing bound for h
    int64_t _389;
    // Computing bound for h
    if (_341.d1 > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    _389 = 0;
    int64_t _390 = 0; // h
    _jump748:; // Begin body of loop
    int64_t _391 = _341.d1 - _390;
    _389 += _391;
    _390++;
    if (_390 < _341.d1)
    goto _jump748;
    // End body of loop
    _388.d0 = _389;
    if (_389 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing bound for i
    int64_t _392 = _341.d0 * _341.d0;
    int64_t _393 = _341.d1 - _392;
    _388.d1 = _393;
    if (_393 > 0) 
    goto _jump750;
    fail_assertion("non-positive loop bound");
    _jump750:;
    // Computing total size of heap memory to allocate
    int64_t _394 = 1;
    _394 *= _389;
    _394 *= _393;
    _394 *= sizeof(bool);
    _388.data = jpl_alloc(_394);
    int64_t _395 = 0; // i
    int64_t _396 = 0; // h
    _jump751:; // Begin body of loop
    bool _398 = c(d);
    bool _397 = _398;
    if (0 != _398)
    goto _jump752;
    bool _399 = false;
    _397 = _399;
    _jump752:;
    int64_t _400 = 0;
    _400 *= _388.d0;
    _400 += _396;
    _400 *= _388.d1;
    _400 += _395;
    _388.data[_400] = _397;
    _395++;
    if (_395 < _393)
    goto _jump751;
    _395 = 0;
    _396++;
    if (_396 < _389)
    goto _jump751;
    // End body of loop
    _361 = _388;
    _jump746:;
    int64_t _401 = 62;
    int64_t _402 = 700;
    int64_t _403 = _401 * _402;
    int64_t _404 = _403 * _341.d1;
    bool _405 = true;
    int64_t _406;
    if (!_405)
    goto _jump753;
    _406 = _341.d0;
    goto _jump754;
    _jump753:;
    _406 = _341.d1;
    _jump754:;
    int64_t _407 = _404 - _406;
    int64_t _408 = 630;
    if (_407 >= 0)
    goto _jump755;
    fail_assertion("negative array index");
    _jump755:;
    if (_407 < _361.d0)
    goto _jump756;
    fail_assertion("index too large");
    _jump756:;
    if (_408 >= 0)
    goto _jump757;
    fail_assertion("negative array index");
    _jump757:;
    if (_408 < _361.d1)
    goto _jump758;
    fail_assertion("index too large");
    _jump758:;
    int64_t _409 = 0;
    _409 *= _361.d0;
    _409 += _407;
    _409 *= _361.d1;
    _409 += _408;
    bool _410 = _361.data[_409];
    bool _342 = _410;
    if (0 != _410)
    goto _jump759;
    int64_t _411;
    // Computing bound for h
    bool _412 = false;
    bool _413 = !_412;
    bool _414 = !_413;
    int64_t _415;
    if (!_414)
    goto _jump760;
    _415 = _341.d0;
    goto _jump761;
    _jump760:;
    int64_t _416 = 68;
    _415 = _416;
    _jump761:;
    if (_415 > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing bound for i
    if (_341.d1 > 0) 
    goto _jump763;
    fail_assertion("non-positive loop bound");
    _jump763:;
    // Computing bound for j
    _a1__a2_int64_t _417;
    // Computing bound for h
    int64_t _418 = 510;
    _417.d0 = _418;
    if (_418 > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    // Computing total size of heap memory to allocate
    int64_t _419 = 1;
    _419 *= _418;
    _419 *= sizeof(_a2_int64_t);
    _417.data = jpl_alloc(_419);
    int64_t _420 = 0; // h
    _jump765:; // Begin body of loop
    int64_t _421 = 0;
    _421 *= _417.d0;
    _421 += _420;
    _417.data[_421] = _341;
    _420++;
    if (_420 < _418)
    goto _jump765;
    // End body of loop
    if (_341.d1 >= 0)
    goto _jump766;
    fail_assertion("negative array index");
    _jump766:;
    if (_341.d1 < _417.d0)
    goto _jump767;
    fail_assertion("index too large");
    _jump767:;
    int64_t _422 = 0;
    _422 *= _417.d0;
    _422 += _341.d1;
    _a2_int64_t _423 = _417.data[_422];
    int64_t _424 = 176;
    if (_424 >= 0)
    goto _jump768;
    fail_assertion("negative array index");
    _jump768:;
    if (_424 < _423.d0)
    goto _jump769;
    fail_assertion("index too large");
    _jump769:;
    if (_341.d0 >= 0)
    goto _jump770;
    fail_assertion("negative array index");
    _jump770:;
    if (_341.d0 < _423.d1)
    goto _jump771;
    fail_assertion("index too large");
    _jump771:;
    int64_t _425 = 0;
    _425 *= _423.d0;
    _425 += _424;
    _425 *= _423.d1;
    _425 += _341.d0;
    int64_t _426 = _423.data[_425];
    if (_426 > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    _411 = 0;
    int64_t _427 = 0; // j
    int64_t _428 = 0; // i
    int64_t _429 = 0; // h
    _jump773:; // Begin body of loop
    int64_t _430;
    // Computing bound for k
    if (_429 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    _430 = 0;
    int64_t _431 = 0; // k
    _jump775:; // Begin body of loop
    int64_t _432 = _341.d0 - _341.d1;
    int64_t _433 = -_432;
    _430 += _433;
    _431++;
    if (_431 < _429)
    goto _jump775;
    // End body of loop
    _411 += _430;
    _427++;
    if (_427 < _426)
    goto _jump773;
    _427 = 0;
    _428++;
    if (_428 < _341.d1)
    goto _jump773;
    _428 = 0;
    _429++;
    if (_429 < _415)
    goto _jump773;
    // End body of loop
    bool _434 = _411 <= _341.d1;
    _342 = _434;
    _jump759:;
    bool _435 = !_342;
    if (0 != _435)
    goto _jump776;
    fail_assertion("h");
    _jump776:;
    _a2__a3_bool _437;
    // Computing bound for h
    int64_t _438;
    // Computing bound for h
    int64_t _439 = 67;
    if (_439 > 0) 
    goto _jump777;
    fail_assertion("non-positive loop bound");
    _jump777:;
    _438 = 0;
    int64_t _440 = 0; // h
    _jump778:; // Begin body of loop
    _438 += _341.d1;
    _440++;
    if (_440 < _439)
    goto _jump778;
    // End body of loop
    _437.d0 = _438;
    if (_438 > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing bound for i
    int64_t _441 = _341.d0 * _341.d0;
    int64_t _442 = -_441;
    _437.d1 = _442;
    if (_442 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= _438;
    _443 *= _442;
    _443 *= sizeof(_a3_bool);
    _437.data = jpl_alloc(_443);
    int64_t _444 = 0; // i
    int64_t _445 = 0; // h
    _jump781:; // Begin body of loop
    _a3_bool _446;
    // Computing bound for j
    _446.d0 = _445;
    if (_445 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing bound for k
    _446.d1 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing bound for l
    int64_t _447 = 533;
    _446.d2 = _447;
    if (_447 > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    // Computing total size of heap memory to allocate
    int64_t _448 = 1;
    _448 *= _445;
    _448 *= _341.d1;
    _448 *= _447;
    _448 *= sizeof(bool);
    _446.data = jpl_alloc(_448);
    int64_t _449 = 0; // l
    int64_t _450 = 0; // k
    int64_t _451 = 0; // j
    _jump785:; // Begin body of loop
    bool _452 = true;
    bool _453 = !_452;
    int64_t _454 = 0;
    _454 *= _446.d0;
    _454 += _451;
    _454 *= _446.d1;
    _454 += _450;
    _454 *= _446.d2;
    _454 += _449;
    _446.data[_454] = _453;
    _449++;
    if (_449 < _447)
    goto _jump785;
    _449 = 0;
    _450++;
    if (_450 < _341.d1)
    goto _jump785;
    _450 = 0;
    _451++;
    if (_451 < _445)
    goto _jump785;
    // End body of loop
    int64_t _455 = 0;
    _455 *= _437.d0;
    _455 += _445;
    _455 *= _437.d1;
    _455 += _444;
    _437.data[_455] = _446;
    _444++;
    if (_444 < _442)
    goto _jump781;
    _444 = 0;
    _445++;
    if (_445 < _438)
    goto _jump781;
    // End body of loop
    int64_t _456 = 171;
    int64_t _457 = -_456;
    bool _458 = true;
    int64_t _459;
    if (!_458)
    goto _jump786;
    _459 = _341.d1;
    goto _jump787;
    _jump786:;
    _459 = _341.d1;
    _jump787:;
    int64_t _460 = _457 / _459;
    int64_t _461;
    // Computing bound for h
    int64_t _462 = 993;
    if (_462 > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    _461 = 0;
    int64_t _463 = 0; // h
    _jump789:; // Begin body of loop
    _461 += _341.d0;
    _463++;
    if (_463 < _462)
    goto _jump789;
    // End body of loop
    int64_t _464 = -_461;
    if (_460 >= 0)
    goto _jump790;
    fail_assertion("negative array index");
    _jump790:;
    if (_460 < _437.d0)
    goto _jump791;
    fail_assertion("index too large");
    _jump791:;
    if (_464 >= 0)
    goto _jump792;
    fail_assertion("negative array index");
    _jump792:;
    if (_464 < _437.d1)
    goto _jump793;
    fail_assertion("index too large");
    _jump793:;
    int64_t _465 = 0;
    _465 *= _437.d0;
    _465 += _460;
    _465 *= _437.d1;
    _465 += _464;
    _a3_bool _466 = _437.data[_465];
    int64_t _467;
    // Computing bound for h
    int64_t _468 = 784;
    if (_468 > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    _467 = 0;
    int64_t _469 = 0; // h
    _jump795:; // Begin body of loop
    int64_t _470;
    // Computing bound for i
    if (_469 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing bound for j
    int64_t _471 = 350;
    if (_471 > 0) 
    goto _jump797;
    fail_assertion("non-positive loop bound");
    _jump797:;
    _470 = 0;
    int64_t _472 = 0; // j
    int64_t _473 = 0; // i
    _jump798:; // Begin body of loop
    _470 += _341.d0;
    _472++;
    if (_472 < _471)
    goto _jump798;
    _472 = 0;
    _473++;
    if (_473 < _469)
    goto _jump798;
    // End body of loop
    _467 += _470;
    _469++;
    if (_469 < _468)
    goto _jump795;
    // End body of loop
    int64_t _474 = -_467;
    double _475;
    // Computing bound for h
    if (_341.d1 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    _475 = 0;
    int64_t _476 = 0; // h
    _jump800:; // Begin body of loop
    double _477;
    // Computing bound for i
    if (_341.d1 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    _477 = 0;
    int64_t _478 = 0; // i
    _jump802:; // Begin body of loop
    double _479 = 56.0;
    _477 += _479;
    _478++;
    if (_478 < _341.d1)
    goto _jump802;
    // End body of loop
    _475 += _477;
    _476++;
    if (_476 < _341.d1)
    goto _jump800;
    // End body of loop
    double _480;
    // Computing bound for h
    int64_t _481 = 265;
    if (_481 > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    // Computing bound for i
    int64_t _482 = 116;
    if (_482 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    _480 = 0;
    int64_t _483 = 0; // i
    int64_t _484 = 0; // h
    _jump805:; // Begin body of loop
    double _485 = 24.0;
    _480 += _485;
    _483++;
    if (_483 < _482)
    goto _jump805;
    _483 = 0;
    _484++;
    if (_484 < _481)
    goto _jump805;
    // End body of loop
    double _486 = -_480;
    bool _487 = _475 >= _486;
    int64_t _488;
    if (!_487)
    goto _jump806;
    _a3_int64_t _489;
    // Computing bound for h
    int64_t _490 = -_341.d1;
    _489.d0 = _490;
    if (_490 > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing bound for i
    int64_t _491 = 510;
    _489.d1 = _491;
    if (_491 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing bound for j
    int64_t _492 = 944;
    int64_t _493 = 877;
    int64_t _494 = _492 + _493;
    _489.d2 = _494;
    if (_494 > 0) 
    goto _jump809;
    fail_assertion("non-positive loop bound");
    _jump809:;
    // Computing total size of heap memory to allocate
    int64_t _495 = 1;
    _495 *= _490;
    _495 *= _491;
    _495 *= _494;
    _495 *= sizeof(int64_t);
    _489.data = jpl_alloc(_495);
    int64_t _496 = 0; // j
    int64_t _497 = 0; // i
    int64_t _498 = 0; // h
    _jump810:; // Begin body of loop
    int64_t _499 = 0;
    _499 *= _489.d0;
    _499 += _498;
    _499 *= _489.d1;
    _499 += _497;
    _499 *= _489.d2;
    _499 += _496;
    _489.data[_499] = _498;
    _496++;
    if (_496 < _494)
    goto _jump810;
    _496 = 0;
    _497++;
    if (_497 < _491)
    goto _jump810;
    _497 = 0;
    _498++;
    if (_498 < _490)
    goto _jump810;
    // End body of loop
    int64_t _500 = -_341.d0;
    int64_t _501 = _341.d1 * _500;
    int64_t _502 = 681;
    if (_501 >= 0)
    goto _jump811;
    fail_assertion("negative array index");
    _jump811:;
    if (_501 < _489.d0)
    goto _jump812;
    fail_assertion("index too large");
    _jump812:;
    if (_502 >= 0)
    goto _jump813;
    fail_assertion("negative array index");
    _jump813:;
    if (_502 < _489.d1)
    goto _jump814;
    fail_assertion("index too large");
    _jump814:;
    if (_341.d0 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (_341.d0 < _489.d2)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    int64_t _503 = 0;
    _503 *= _489.d0;
    _503 += _501;
    _503 *= _489.d1;
    _503 += _502;
    _503 *= _489.d2;
    _503 += _341.d0;
    int64_t _504 = _489.data[_503];
    _488 = _504;
    goto _jump817;
    _jump806:;
    _488 = _341.d0;
    _jump817:;
    int64_t _505;
    // Computing bound for h
    int64_t _506 = 464;
    if (_506 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for i
    int64_t _507 = 62;
    if (_507 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    _505 = 0;
    int64_t _508 = 0; // i
    int64_t _509 = 0; // h
    _jump820:; // Begin body of loop
    int64_t _510 = 243;
    _505 += _510;
    _508++;
    if (_508 < _507)
    goto _jump820;
    _508 = 0;
    _509++;
    if (_509 < _506)
    goto _jump820;
    // End body of loop
    if (_474 >= 0)
    goto _jump821;
    fail_assertion("negative array index");
    _jump821:;
    if (_474 < _466.d0)
    goto _jump822;
    fail_assertion("index too large");
    _jump822:;
    if (_488 >= 0)
    goto _jump823;
    fail_assertion("negative array index");
    _jump823:;
    if (_488 < _466.d1)
    goto _jump824;
    fail_assertion("index too large");
    _jump824:;
    if (_505 >= 0)
    goto _jump825;
    fail_assertion("negative array index");
    _jump825:;
    if (_505 < _466.d2)
    goto _jump826;
    fail_assertion("index too large");
    _jump826:;
    int64_t _511 = 0;
    _511 *= _466.d0;
    _511 += _474;
    _511 *= _466.d1;
    _511 += _488;
    _511 *= _466.d2;
    _511 += _505;
    bool _512 = _466.data[_511];
    bool _436 = _512;
    if (0 != _512)
    goto _jump827;
    _a1_double _513;
    // Computing bound for h
    _513.d0 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing total size of heap memory to allocate
    int64_t _514 = 1;
    _514 *= _341.d1;
    _514 *= sizeof(double);
    _513.data = jpl_alloc(_514);
    int64_t _515 = 0; // h
    _jump829:; // Begin body of loop
    double _516 = 31.0;
    double _517 = -_516;
    int64_t _518 = 0;
    _518 *= _513.d0;
    _518 += _515;
    _513.data[_518] = _517;
    _515++;
    if (_515 < _341.d1)
    goto _jump829;
    // End body of loop
    if (_341.d1 >= 0)
    goto _jump830;
    fail_assertion("negative array index");
    _jump830:;
    if (_341.d1 < _513.d0)
    goto _jump831;
    fail_assertion("index too large");
    _jump831:;
    int64_t _519 = 0;
    _519 *= _513.d0;
    _519 += _341.d1;
    double _520 = _513.data[_519];
    double _521 = 67.0;
    bool _522 = _520 >= _521;
    _436 = _522;
    _jump827:;
    bool _523;
    if (!_436)
    goto _jump832;
    _a3_bool _524;
    // Computing bound for h
    int64_t _525;
    // Computing bound for h
    int64_t _526 = 442;
    int64_t _527 = -_526;
    if (_527 > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    _525 = 0;
    int64_t _528 = 0; // h
    _jump834:; // Begin body of loop
    _525 += _341.d0;
    _528++;
    if (_528 < _527)
    goto _jump834;
    // End body of loop
    int64_t _529 = _341.d1 - _525;
    _524.d0 = _529;
    if (_529 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing bound for i
    int64_t _530;
    // Computing bound for h
    bool _531 = false;
    bool _532 = !_531;
    int64_t _533;
    if (!_532)
    goto _jump836;
    _533 = _341.d0;
    goto _jump837;
    _jump836:;
    _533 = _341.d0;
    _jump837:;
    if (_533 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    _530 = 0;
    int64_t _534 = 0; // h
    _jump839:; // Begin body of loop
    int64_t _535 = 57;
    int64_t _536 = 216;
    int64_t _537 = _341.d1 / _536;
    int64_t _538;
    // Computing bound for i
    if (_534 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for j
    if (_534 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing bound for k
    if (_341.d0 > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    _538 = 0;
    int64_t _539 = 0; // k
    int64_t _540 = 0; // j
    int64_t _541 = 0; // i
    _jump843:; // Begin body of loop
    _538 += _539;
    _539++;
    if (_539 < _341.d0)
    goto _jump843;
    _539 = 0;
    _540++;
    if (_540 < _534)
    goto _jump843;
    _540 = 0;
    _541++;
    if (_541 < _534)
    goto _jump843;
    // End body of loop
    int64_t _542 = _537 * _538;
    int64_t _543 = _535 - _542;
    _530 += _543;
    _534++;
    if (_534 < _533)
    goto _jump839;
    // End body of loop
    _524.d1 = _530;
    if (_530 > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    // Computing bound for j
    int64_t _544 = -_341.d1;
    _524.d2 = _544;
    if (_544 > 0) 
    goto _jump845;
    fail_assertion("non-positive loop bound");
    _jump845:;
    // Computing total size of heap memory to allocate
    int64_t _545 = 1;
    _545 *= _529;
    _545 *= _530;
    _545 *= _544;
    _545 *= sizeof(bool);
    _524.data = jpl_alloc(_545);
    int64_t _546 = 0; // j
    int64_t _547 = 0; // i
    int64_t _548 = 0; // h
    _jump846:; // Begin body of loop
    bool _549 = c(d);
    bool _550;
    if (!_549)
    goto _jump847;
    _a1__a1_bool _551;
    _551.d0 = 1;
    _551.data = jpl_alloc(sizeof(_a1_bool) * 1);
    _551.data[0] = a;
    bool _552 = false;
    int64_t _553;
    if (!_552)
    goto _jump848;
    _553 = _548;
    goto _jump849;
    _jump848:;
    _553 = _548;
    _jump849:;
    if (_553 >= 0)
    goto _jump850;
    fail_assertion("negative array index");
    _jump850:;
    if (_553 < _551.d0)
    goto _jump851;
    fail_assertion("index too large");
    _jump851:;
    int64_t _554 = 0;
    _554 *= _551.d0;
    _554 += _553;
    _a1_bool _555 = _551.data[_554];
    int64_t _556;
    // Computing bound for k
    if (_548 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for l
    if (_548 > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing bound for m
    int64_t _557 = 185;
    if (_557 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    _556 = 0;
    int64_t _558 = 0; // m
    int64_t _559 = 0; // l
    int64_t _560 = 0; // k
    _jump855:; // Begin body of loop
    int64_t _561 = 101;
    _556 += _561;
    _558++;
    if (_558 < _557)
    goto _jump855;
    _558 = 0;
    _559++;
    if (_559 < _548)
    goto _jump855;
    _559 = 0;
    _560++;
    if (_560 < _548)
    goto _jump855;
    // End body of loop
    if (_556 >= 0)
    goto _jump856;
    fail_assertion("negative array index");
    _jump856:;
    if (_556 < _555.d0)
    goto _jump857;
    fail_assertion("index too large");
    _jump857:;
    int64_t _562 = 0;
    _562 *= _555.d0;
    _562 += _556;
    bool _563 = _555.data[_562];
    _550 = _563;
    goto _jump858;
    _jump847:;
    bool _564 = c(d);
    bool _565;
    if (!_564)
    goto _jump859;
    bool _566 = true;
    _a1_bool _567;
    if (!_566)
    goto _jump860;
    _567 = a;
    goto _jump861;
    _jump860:;
    _567 = a;
    _jump861:;
    if (_548 >= 0)
    goto _jump862;
    fail_assertion("negative array index");
    _jump862:;
    if (_548 < _567.d0)
    goto _jump863;
    fail_assertion("index too large");
    _jump863:;
    int64_t _568 = 0;
    _568 *= _567.d0;
    _568 += _548;
    bool _569 = _567.data[_568];
    _565 = _569;
    goto _jump864;
    _jump859:;
    int64_t _570 = 842;
    bool _571 = _570 != _547;
    bool _572 = c(d);
    bool _573 = _571 == _572;
    _565 = _573;
    _jump864:;
    _550 = _565;
    _jump858:;
    int64_t _574 = 0;
    _574 *= _524.d0;
    _574 += _548;
    _574 *= _524.d1;
    _574 += _547;
    _574 *= _524.d2;
    _574 += _546;
    _524.data[_574] = _550;
    _546++;
    if (_546 < _544)
    goto _jump846;
    _546 = 0;
    _547++;
    if (_547 < _530)
    goto _jump846;
    _547 = 0;
    _548++;
    if (_548 < _529)
    goto _jump846;
    // End body of loop
    bool _575 = false;
    bool _576 = !_575;
    bool _577;
    if (!_576)
    goto _jump865;
    bool _578 = false;
    _577 = _578;
    goto _jump866;
    _jump865:;
    bool _580 = false;
    bool _579 = _580;
    if (0 == _580)
    goto _jump867;
    bool _581 = true;
    _579 = _581;
    _jump867:;
    _577 = _579;
    _jump866:;
    bool _582 = !_577;
    int64_t _583;
    if (!_582)
    goto _jump868;
    int64_t _584 = 490;
    int64_t _585 = 363;
    int64_t _586 = -_585;
    _a1_int64_t _587;
    _587.d0 = 3;
    _587.data = jpl_alloc(sizeof(int64_t) * 3);
    _587.data[0] = _584;
    _587.data[1] = _586;
    _587.data[2] = _341.d0;
    int64_t _588 = 234;
    int64_t _589 = -_588;
    if (_589 >= 0)
    goto _jump869;
    fail_assertion("negative array index");
    _jump869:;
    if (_589 < _587.d0)
    goto _jump870;
    fail_assertion("index too large");
    _jump870:;
    int64_t _590 = 0;
    _590 *= _587.d0;
    _590 += _589;
    int64_t _591 = _587.data[_590];
    _583 = _591;
    goto _jump871;
    _jump868:;
    int64_t _592;
    // Computing bound for h
    int64_t _593 = 133;
    if (_593 > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    _592 = 0;
    int64_t _594 = 0; // h
    _jump873:; // Begin body of loop
    _592 += _341.d0;
    _594++;
    if (_594 < _593)
    goto _jump873;
    // End body of loop
    _583 = _592;
    _jump871:;
    int64_t _595 = _341.d1 + _341.d0;
    int64_t _596 = _583 % _595;
    bool _597 = false;
    _a2_int64_t _598;
    if (!_597)
    goto _jump874;
    _598 = _341;
    goto _jump875;
    _jump874:;
    _598 = _341;
    _jump875:;
    bool _599 = false;
    int64_t _600;
    if (!_599)
    goto _jump876;
    _600 = _341.d0;
    goto _jump877;
    _jump876:;
    int64_t _601 = 675;
    _600 = _601;
    _jump877:;
    if (_600 >= 0)
    goto _jump878;
    fail_assertion("negative array index");
    _jump878:;
    if (_600 < _598.d0)
    goto _jump879;
    fail_assertion("index too large");
    _jump879:;
    if (_341.d1 >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (_341.d1 < _598.d1)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    int64_t _602 = 0;
    _602 *= _598.d0;
    _602 += _600;
    _602 *= _598.d1;
    _602 += _341.d1;
    int64_t _603 = _598.data[_602];
    int64_t _604;
    // Computing bound for h
    if (_341.d1 > 0) 
    goto _jump882;
    fail_assertion("non-positive loop bound");
    _jump882:;
    // Computing bound for i
    int64_t _605;
    // Computing bound for h
    int64_t _606 = 824;
    if (_606 > 0) 
    goto _jump883;
    fail_assertion("non-positive loop bound");
    _jump883:;
    _605 = 0;
    int64_t _607 = 0; // h
    _jump884:; // Begin body of loop
    _605 += _341.d0;
    _607++;
    if (_607 < _606)
    goto _jump884;
    // End body of loop
    if (_605 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing bound for j
    int64_t _608;
    // Computing bound for h
    if (_341.d0 > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing bound for i
    if (_341.d0 > 0) 
    goto _jump887;
    fail_assertion("non-positive loop bound");
    _jump887:;
    _608 = 0;
    int64_t _609 = 0; // i
    int64_t _610 = 0; // h
    _jump888:; // Begin body of loop
    _608 += _609;
    _609++;
    if (_609 < _341.d0)
    goto _jump888;
    _609 = 0;
    _610++;
    if (_610 < _341.d0)
    goto _jump888;
    // End body of loop
    if (_608 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    _604 = 0;
    int64_t _611 = 0; // j
    int64_t _612 = 0; // i
    int64_t _613 = 0; // h
    _jump890:; // Begin body of loop
    int64_t _614 = 220;
    int64_t _615 = _614 + _611;
    _604 += _615;
    _611++;
    if (_611 < _608)
    goto _jump890;
    _611 = 0;
    _612++;
    if (_612 < _605)
    goto _jump890;
    _612 = 0;
    _613++;
    if (_613 < _341.d1)
    goto _jump890;
    // End body of loop
    int64_t _616 = 620;
    if (_616 >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (_616 < _341.d0)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    if (_341.d1 >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (_341.d1 < _341.d1)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    int64_t _617 = 0;
    _617 *= _341.d0;
    _617 += _616;
    _617 *= _341.d1;
    _617 += _341.d1;
    int64_t _618 = _341.data[_617];
    _a1_int64_t _619;
    _619.d0 = 3;
    _619.data = jpl_alloc(sizeof(int64_t) * 3);
    _619.data[0] = _603;
    _619.data[1] = _604;
    _619.data[2] = _618;
    int64_t _620;
    // Computing bound for h
    int64_t _621;
    // Computing bound for h
    int64_t _622 = 137;
    if (_622 > 0) 
    goto _jump895;
    fail_assertion("non-positive loop bound");
    _jump895:;
    // Computing bound for i
    if (_341.d0 > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    // Computing bound for j
    if (_341.d1 > 0) 
    goto _jump897;
    fail_assertion("non-positive loop bound");
    _jump897:;
    _621 = 0;
    int64_t _623 = 0; // j
    int64_t _624 = 0; // i
    int64_t _625 = 0; // h
    _jump898:; // Begin body of loop
    _621 += _624;
    _623++;
    if (_623 < _341.d1)
    goto _jump898;
    _623 = 0;
    _624++;
    if (_624 < _341.d0)
    goto _jump898;
    _624 = 0;
    _625++;
    if (_625 < _622)
    goto _jump898;
    // End body of loop
    if (_621 > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    _620 = 0;
    int64_t _626 = 0; // h
    _jump900:; // Begin body of loop
    int64_t _627;
    // Computing bound for i
    int64_t _628 = -_341.d0;
    if (_628 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing bound for j
    if (_341.d1 > 0) 
    goto _jump902;
    fail_assertion("non-positive loop bound");
    _jump902:;
    // Computing bound for k
    int64_t _629 = _341.d1 / _341.d1;
    if (_629 > 0) 
    goto _jump903;
    fail_assertion("non-positive loop bound");
    _jump903:;
    _627 = 0;
    int64_t _630 = 0; // k
    int64_t _631 = 0; // j
    int64_t _632 = 0; // i
    _jump904:; // Begin body of loop
    int64_t _633;
    // Computing bound for l
    int64_t _634 = 820;
    if (_634 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for m
    if (_630 > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    _633 = 0;
    int64_t _635 = 0; // m
    int64_t _636 = 0; // l
    _jump907:; // Begin body of loop
    _633 += _632;
    _635++;
    if (_635 < _630)
    goto _jump907;
    _635 = 0;
    _636++;
    if (_636 < _634)
    goto _jump907;
    // End body of loop
    _627 += _633;
    _630++;
    if (_630 < _629)
    goto _jump904;
    _630 = 0;
    _631++;
    if (_631 < _341.d1)
    goto _jump904;
    _631 = 0;
    _632++;
    if (_632 < _628)
    goto _jump904;
    // End body of loop
    _620 += _627;
    _626++;
    if (_626 < _621)
    goto _jump900;
    // End body of loop
    if (_620 >= 0)
    goto _jump908;
    fail_assertion("negative array index");
    _jump908:;
    if (_620 < _619.d0)
    goto _jump909;
    fail_assertion("index too large");
    _jump909:;
    int64_t _637 = 0;
    _637 *= _619.d0;
    _637 += _620;
    int64_t _638 = _619.data[_637];
    int64_t _639 = -_638;
    if (_596 >= 0)
    goto _jump910;
    fail_assertion("negative array index");
    _jump910:;
    if (_596 < _524.d0)
    goto _jump911;
    fail_assertion("index too large");
    _jump911:;
    if (_639 >= 0)
    goto _jump912;
    fail_assertion("negative array index");
    _jump912:;
    if (_639 < _524.d1)
    goto _jump913;
    fail_assertion("index too large");
    _jump913:;
    if (_341.d1 >= 0)
    goto _jump914;
    fail_assertion("negative array index");
    _jump914:;
    if (_341.d1 < _524.d2)
    goto _jump915;
    fail_assertion("index too large");
    _jump915:;
    int64_t _640 = 0;
    _640 *= _524.d0;
    _640 += _596;
    _640 *= _524.d1;
    _640 += _639;
    _640 *= _524.d2;
    _640 += _341.d1;
    bool _641 = _524.data[_640];
    _523 = _641;
    goto _jump916;
    _jump832:;
    double _642;
    // Computing bound for h
    if (_341.d0 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for i
    if (_341.d0 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing bound for j
    int64_t _643 = 598;
    if (_643 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    _642 = 0;
    int64_t _644 = 0; // j
    int64_t _645 = 0; // i
    int64_t _646 = 0; // h
    _jump920:; // Begin body of loop
    double _647 = 8.0;
    _642 += _647;
    _644++;
    if (_644 < _643)
    goto _jump920;
    _644 = 0;
    _645++;
    if (_645 < _341.d0)
    goto _jump920;
    _645 = 0;
    _646++;
    if (_646 < _341.d0)
    goto _jump920;
    // End body of loop
    double _648 = -_642;
    bool _650 = false;
    bool _651 = !_650;
    bool _649 = _651;
    if (0 == _651)
    goto _jump921;
    bool _652 = c(d);
    bool _653 = !_652;
    _649 = _653;
    _jump921:;
    double _654;
    if (!_649)
    goto _jump922;
    bool _655 = true;
    bool _656 = !_655;
    double _657;
    if (!_656)
    goto _jump923;
    double _658;
    // Computing bound for h
    int64_t _659;
    // Computing bound for h
    if (_341.d1 > 0) 
    goto _jump924;
    fail_assertion("non-positive loop bound");
    _jump924:;
    _659 = 0;
    int64_t _660 = 0; // h
    _jump925:; // Begin body of loop
    _659 += _341.d0;
    _660++;
    if (_660 < _341.d1)
    goto _jump925;
    // End body of loop
    if (_659 > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing bound for i
    if (_341.d0 > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    _658 = 0;
    int64_t _661 = 0; // i
    int64_t _662 = 0; // h
    _jump928:; // Begin body of loop
    double _663 = 24.0;
    _658 += _663;
    _661++;
    if (_661 < _341.d0)
    goto _jump928;
    _661 = 0;
    _662++;
    if (_662 < _659)
    goto _jump928;
    // End body of loop
    _657 = _658;
    goto _jump929;
    _jump923:;
    double _664 = 50.0;
    _657 = _664;
    _jump929:;
    _654 = _657;
    goto _jump930;
    _jump922:;
    double _665 = 56.0;
    double _666;
    // Computing bound for h
    if (_341.d0 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    _666 = 0;
    int64_t _667 = 0; // h
    _jump932:; // Begin body of loop
    double _668 = 4.0;
    _666 += _668;
    _667++;
    if (_667 < _341.d0)
    goto _jump932;
    // End body of loop
    double _669 = _665 - _666;
    double _670 = -_669;
    _654 = _670;
    _jump930:;
    double _671 = -_654;
    bool _672 = _648 <= _671;
    _523 = _672;
    _jump916:;
    if (0 != _523)
    goto _jump933;
    fail_assertion("h");
    _jump933:;
    bool _673 = false;
    return _673;
    bool _675 = c(d);
    double _676;
    if (!_675)
    goto _jump934;
    double _677;
    // Computing bound for h
    bool _678 = false;
    int64_t _679;
    if (!_678)
    goto _jump935;
    int64_t _680 = 85;
    _679 = _680;
    goto _jump936;
    _jump935:;
    _679 = _341.d1;
    _jump936:;
    if (_679 > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing bound for i
    if (_341.d1 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing bound for j
    if (_341.d1 > 0) 
    goto _jump939;
    fail_assertion("non-positive loop bound");
    _jump939:;
    _677 = 0;
    int64_t _681 = 0; // j
    int64_t _682 = 0; // i
    int64_t _683 = 0; // h
    _jump940:; // Begin body of loop
    double _684;
    // Computing bound for k
    if (_681 > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    // Computing bound for l
    int64_t _685 = 259;
    if (_685 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing bound for m
    if (_683 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    _684 = 0;
    int64_t _686 = 0; // m
    int64_t _687 = 0; // l
    int64_t _688 = 0; // k
    _jump944:; // Begin body of loop
    double _689 = 87.0;
    _684 += _689;
    _686++;
    if (_686 < _683)
    goto _jump944;
    _686 = 0;
    _687++;
    if (_687 < _685)
    goto _jump944;
    _687 = 0;
    _688++;
    if (_688 < _681)
    goto _jump944;
    // End body of loop
    _677 += _684;
    _681++;
    if (_681 < _341.d1)
    goto _jump940;
    _681 = 0;
    _682++;
    if (_682 < _341.d1)
    goto _jump940;
    _682 = 0;
    _683++;
    if (_683 < _679)
    goto _jump940;
    // End body of loop
    _676 = _677;
    goto _jump945;
    _jump934:;
    double _690;
    // Computing bound for h
    int64_t _691 = 462;
    int64_t _692 = -_691;
    if (_692 > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    _690 = 0;
    int64_t _693 = 0; // h
    _jump947:; // Begin body of loop
    double _694 = 72.0;
    _690 += _694;
    _693++;
    if (_693 < _692)
    goto _jump947;
    // End body of loop
    _676 = _690;
    _jump945:;
    double _695 = 10.0;
    bool _696 = _676 > _695;
    bool _674 = _696;
    if (0 == _696)
    goto _jump948;
    bool _697 = true;
    _674 = _697;
    _jump948:;
    bool _698;
    if (!_674)
    goto _jump949;
    int64_t _700 = 485;
    int64_t _701 = -_341.d0;
    bool _702 = _700 >= _701;
    bool _703;
    if (!_702)
    goto _jump950;
    int64_t _704 = 333;
    int64_t _705 = 946;
    bool _706 = _704 == _705;
    _703 = _706;
    goto _jump951;
    _jump950:;
    bool _707 = true;
    _703 = _707;
    _jump951:;
    bool _699 = _703;
    if (0 == _703)
    goto _jump952;
    _a3_double _708;
    // Computing bound for h
    _708.d0 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    // Computing bound for i
    _708.d1 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing bound for j
    _708.d2 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing total size of heap memory to allocate
    int64_t _709 = 1;
    _709 *= _341.d0;
    _709 *= _341.d1;
    _709 *= _341.d0;
    _709 *= sizeof(double);
    _708.data = jpl_alloc(_709);
    int64_t _710 = 0; // j
    int64_t _711 = 0; // i
    int64_t _712 = 0; // h
    _jump956:; // Begin body of loop
    double _713 = 79.0;
    int64_t _714 = 0;
    _714 *= _708.d0;
    _714 += _712;
    _714 *= _708.d1;
    _714 += _711;
    _714 *= _708.d2;
    _714 += _710;
    _708.data[_714] = _713;
    _710++;
    if (_710 < _341.d0)
    goto _jump956;
    _710 = 0;
    _711++;
    if (_711 < _341.d1)
    goto _jump956;
    _711 = 0;
    _712++;
    if (_712 < _341.d0)
    goto _jump956;
    // End body of loop
    if (_341.d0 >= 0)
    goto _jump957;
    fail_assertion("negative array index");
    _jump957:;
    if (_341.d0 < _708.d0)
    goto _jump958;
    fail_assertion("index too large");
    _jump958:;
    if (_341.d1 >= 0)
    goto _jump959;
    fail_assertion("negative array index");
    _jump959:;
    if (_341.d1 < _708.d1)
    goto _jump960;
    fail_assertion("index too large");
    _jump960:;
    if (_341.d0 >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (_341.d0 < _708.d2)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    int64_t _715 = 0;
    _715 *= _708.d0;
    _715 += _341.d0;
    _715 *= _708.d1;
    _715 += _341.d1;
    _715 *= _708.d2;
    _715 += _341.d0;
    double _716 = _708.data[_715];
    double _717 = 80.0;
    bool _718 = _716 == _717;
    _699 = _718;
    _jump952:;
    _a3_bool _719;
    // Computing bound for h
    int64_t _720;
    // Computing bound for h
    int64_t _721 = 571;
    if (_721 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    _720 = 0;
    int64_t _722 = 0; // h
    _jump964:; // Begin body of loop
    _720 += _722;
    _722++;
    if (_722 < _721)
    goto _jump964;
    // End body of loop
    _719.d0 = _720;
    if (_720 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing bound for i
    int64_t _723;
    // Computing bound for h
    int64_t _724 = 951;
    if (_724 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    _723 = 0;
    int64_t _725 = 0; // h
    _jump967:; // Begin body of loop
    _723 += _725;
    _725++;
    if (_725 < _724)
    goto _jump967;
    // End body of loop
    int64_t _726 = -_723;
    _719.d1 = _726;
    if (_726 > 0) 
    goto _jump968;
    fail_assertion("non-positive loop bound");
    _jump968:;
    // Computing bound for j
    _719.d2 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump969;
    fail_assertion("non-positive loop bound");
    _jump969:;
    // Computing total size of heap memory to allocate
    int64_t _727 = 1;
    _727 *= _720;
    _727 *= _726;
    _727 *= _341.d1;
    _727 *= sizeof(bool);
    _719.data = jpl_alloc(_727);
    int64_t _728 = 0; // j
    int64_t _729 = 0; // i
    int64_t _730 = 0; // h
    _jump970:; // Begin body of loop
    bool _731 = true;
    bool _732 = !_731;
    int64_t _733 = 0;
    _733 *= _719.d0;
    _733 += _730;
    _733 *= _719.d1;
    _733 += _729;
    _733 *= _719.d2;
    _733 += _728;
    _719.data[_733] = _732;
    _728++;
    if (_728 < _341.d1)
    goto _jump970;
    _728 = 0;
    _729++;
    if (_729 < _726)
    goto _jump970;
    _729 = 0;
    _730++;
    if (_730 < _720)
    goto _jump970;
    // End body of loop
    int64_t _734;
    // Computing bound for h
    if (_341.d0 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    // Computing bound for i
    if (_341.d0 > 0) 
    goto _jump972;
    fail_assertion("non-positive loop bound");
    _jump972:;
    // Computing bound for j
    if (_341.d0 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    _734 = 0;
    int64_t _735 = 0; // j
    int64_t _736 = 0; // i
    int64_t _737 = 0; // h
    _jump974:; // Begin body of loop
    _734 += _341.d1;
    _735++;
    if (_735 < _341.d0)
    goto _jump974;
    _735 = 0;
    _736++;
    if (_736 < _341.d0)
    goto _jump974;
    _736 = 0;
    _737++;
    if (_737 < _341.d0)
    goto _jump974;
    // End body of loop
    int64_t _738 = _341.d1 - _341.d1;
    _a1__a2_int64_t _739;
    // Computing bound for h
    int64_t _740 = 858;
    _739.d0 = _740;
    if (_740 > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing total size of heap memory to allocate
    int64_t _741 = 1;
    _741 *= _740;
    _741 *= sizeof(_a2_int64_t);
    _739.data = jpl_alloc(_741);
    int64_t _742 = 0; // h
    _jump976:; // Begin body of loop
    int64_t _743 = 0;
    _743 *= _739.d0;
    _743 += _742;
    _739.data[_743] = _341;
    _742++;
    if (_742 < _740)
    goto _jump976;
    // End body of loop
    int64_t _744;
    // Computing bound for h
    int64_t _745 = 172;
    if (_745 > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing bound for i
    if (_341.d1 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for j
    int64_t _746 = 433;
    if (_746 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    _744 = 0;
    int64_t _747 = 0; // j
    int64_t _748 = 0; // i
    int64_t _749 = 0; // h
    _jump980:; // Begin body of loop
    _744 += _749;
    _747++;
    if (_747 < _746)
    goto _jump980;
    _747 = 0;
    _748++;
    if (_748 < _341.d1)
    goto _jump980;
    _748 = 0;
    _749++;
    if (_749 < _745)
    goto _jump980;
    // End body of loop
    if (_744 >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (_744 < _739.d0)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    int64_t _750 = 0;
    _750 *= _739.d0;
    _750 += _744;
    _a2_int64_t _751 = _739.data[_750];
    if (_341.d0 >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (_341.d0 < _751.d0)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    if (_341.d1 >= 0)
    goto _jump985;
    fail_assertion("negative array index");
    _jump985:;
    if (_341.d1 < _751.d1)
    goto _jump986;
    fail_assertion("index too large");
    _jump986:;
    int64_t _752 = 0;
    _752 *= _751.d0;
    _752 += _341.d0;
    _752 *= _751.d1;
    _752 += _341.d1;
    int64_t _753 = _751.data[_752];
    if (_734 >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (_734 < _719.d0)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    if (_738 >= 0)
    goto _jump989;
    fail_assertion("negative array index");
    _jump989:;
    if (_738 < _719.d1)
    goto _jump990;
    fail_assertion("index too large");
    _jump990:;
    if (_753 >= 0)
    goto _jump991;
    fail_assertion("negative array index");
    _jump991:;
    if (_753 < _719.d2)
    goto _jump992;
    fail_assertion("index too large");
    _jump992:;
    int64_t _754 = 0;
    _754 *= _719.d0;
    _754 += _734;
    _754 *= _719.d1;
    _754 += _738;
    _754 *= _719.d2;
    _754 += _753;
    bool _755 = _719.data[_754];
    bool _756 = _699 != _755;
    _698 = _756;
    goto _jump993;
    _jump949:;
    double _757 = 37.0;
    double _758 = -_757;
    double _759 = 11.0;
    bool _760 = _758 < _759;
    void_t _761;
    if (!_760)
    goto _jump994;
    _761 = d;
    goto _jump995;
    _jump994:;
    _761 = d;
    _jump995:;
    bool _762 = c(_761);
    _698 = _762;
    _jump993:;
    int64_t _763;
    if (!_698)
    goto _jump996;
    _763 = _341.d1;
    goto _jump997;
    _jump996:;
    _a3_rgba _764;
    // Computing bound for h
    int64_t _765;
    // Computing bound for h
    int64_t _766 = 315;
    int64_t _767 = _766 * _341.d0;
    if (_767 > 0) 
    goto _jump998;
    fail_assertion("non-positive loop bound");
    _jump998:;
    // Computing bound for i
    int64_t _768 = 823;
    if (_768 > 0) 
    goto _jump999;
    fail_assertion("non-positive loop bound");
    _jump999:;
    _765 = 0;
    int64_t _769 = 0; // i
    int64_t _770 = 0; // h
    _jump1000:; // Begin body of loop
    _765 += _770;
    _769++;
    if (_769 < _768)
    goto _jump1000;
    _769 = 0;
    _770++;
    if (_770 < _767)
    goto _jump1000;
    // End body of loop
    int64_t _771 = -_765;
    _764.d0 = _771;
    if (_771 > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    // Computing bound for i
    _764.d1 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump1002;
    fail_assertion("non-positive loop bound");
    _jump1002:;
    // Computing bound for j
    int64_t _772;
    // Computing bound for h
    int64_t _773 = 549;
    if (_773 > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    _772 = 0;
    int64_t _774 = 0; // h
    _jump1004:; // Begin body of loop
    _772 += _774;
    _774++;
    if (_774 < _773)
    goto _jump1004;
    // End body of loop
    int64_t _775 = -_772;
    int64_t _776 = _775 - _341.d0;
    _764.d2 = _776;
    if (_776 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing total size of heap memory to allocate
    int64_t _777 = 1;
    _777 *= _771;
    _777 *= _341.d0;
    _777 *= _776;
    _777 *= sizeof(rgba);
    _764.data = jpl_alloc(_777);
    int64_t _778 = 0; // j
    int64_t _779 = 0; // i
    int64_t _780 = 0; // h
    _jump1006:; // Begin body of loop
    _a3_void_t _781;
    // Computing bound for k
    _781.d0 = _780;
    if (_780 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for l
    _781.d1 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for m
    _781.d2 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing total size of heap memory to allocate
    int64_t _782 = 1;
    _782 *= _780;
    _782 *= _341.d1;
    _782 *= _341.d0;
    _782 *= sizeof(void_t);
    _781.data = jpl_alloc(_782);
    int64_t _783 = 0; // m
    int64_t _784 = 0; // l
    int64_t _785 = 0; // k
    _jump1010:; // Begin body of loop
    int64_t _786 = 0;
    _786 *= _781.d0;
    _786 += _785;
    _786 *= _781.d1;
    _786 += _784;
    _786 *= _781.d2;
    _786 += _783;
    _781.data[_786] = d;
    _783++;
    if (_783 < _341.d0)
    goto _jump1010;
    _783 = 0;
    _784++;
    if (_784 < _341.d1)
    goto _jump1010;
    _784 = 0;
    _785++;
    if (_785 < _780)
    goto _jump1010;
    // End body of loop
    int64_t _787 = 981;
    int64_t _788 = _779 % _778;
    if (_787 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (_787 < _781.d0)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    if (_788 >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (_788 < _781.d1)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    if (_780 >= 0)
    goto _jump1015;
    fail_assertion("negative array index");
    _jump1015:;
    if (_780 < _781.d2)
    goto _jump1016;
    fail_assertion("index too large");
    _jump1016:;
    int64_t _789 = 0;
    _789 *= _781.d0;
    _789 += _787;
    _789 *= _781.d1;
    _789 += _788;
    _789 *= _781.d2;
    _789 += _780;
    void_t _790 = _781.data[_789];
    bool _791 = c(_790);
    rgba _792;
    if (!_791)
    goto _jump1017;
    double _793 = 48.0;
    double _794 = 53.0;
    double _795;
    // Computing bound for k
    if (_780 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    // Computing bound for l
    int64_t _796 = 361;
    if (_796 > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    _795 = 0;
    int64_t _797 = 0; // l
    int64_t _798 = 0; // k
    _jump1020:; // Begin body of loop
    double _799 = 63.0;
    _795 += _799;
    _797++;
    if (_797 < _796)
    goto _jump1020;
    _797 = 0;
    _798++;
    if (_798 < _780)
    goto _jump1020;
    // End body of loop
    double _800 = 24.0;
    double _801 = -_800;
    rgba _802 = { _793, _794, _795, _801 };
    _792 = _802;
    goto _jump1021;
    _jump1017:;
    _a3_rgba _803;
    // Computing bound for k
    _803.d0 = _778;
    if (_778 > 0) 
    goto _jump1022;
    fail_assertion("non-positive loop bound");
    _jump1022:;
    // Computing bound for l
    _803.d1 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing bound for m
    _803.d2 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing total size of heap memory to allocate
    int64_t _804 = 1;
    _804 *= _778;
    _804 *= _341.d1;
    _804 *= _341.d1;
    _804 *= sizeof(rgba);
    _803.data = jpl_alloc(_804);
    int64_t _805 = 0; // m
    int64_t _806 = 0; // l
    int64_t _807 = 0; // k
    _jump1025:; // Begin body of loop
    double _808 = 36.0;
    double _809 = 60.0;
    double _810 = 38.0;
    double _811 = 37.0;
    rgba _812 = { _808, _809, _810, _811 };
    int64_t _813 = 0;
    _813 *= _803.d0;
    _813 += _807;
    _813 *= _803.d1;
    _813 += _806;
    _813 *= _803.d2;
    _813 += _805;
    _803.data[_813] = _812;
    _805++;
    if (_805 < _341.d1)
    goto _jump1025;
    _805 = 0;
    _806++;
    if (_806 < _341.d1)
    goto _jump1025;
    _806 = 0;
    _807++;
    if (_807 < _778)
    goto _jump1025;
    // End body of loop
    int64_t _814 = 516;
    bool _815 = true;
    _a2_int64_t _816;
    if (!_815)
    goto _jump1026;
    _816 = _341;
    goto _jump1027;
    _jump1026:;
    _816 = _341;
    _jump1027:;
    int64_t _817 = 846;
    if (_341.d1 >= 0)
    goto _jump1028;
    fail_assertion("negative array index");
    _jump1028:;
    if (_341.d1 < _816.d0)
    goto _jump1029;
    fail_assertion("index too large");
    _jump1029:;
    if (_817 >= 0)
    goto _jump1030;
    fail_assertion("negative array index");
    _jump1030:;
    if (_817 < _816.d1)
    goto _jump1031;
    fail_assertion("index too large");
    _jump1031:;
    int64_t _818 = 0;
    _818 *= _816.d0;
    _818 += _341.d1;
    _818 *= _816.d1;
    _818 += _817;
    int64_t _819 = _816.data[_818];
    if (_780 >= 0)
    goto _jump1032;
    fail_assertion("negative array index");
    _jump1032:;
    if (_780 < _803.d0)
    goto _jump1033;
    fail_assertion("index too large");
    _jump1033:;
    if (_814 >= 0)
    goto _jump1034;
    fail_assertion("negative array index");
    _jump1034:;
    if (_814 < _803.d1)
    goto _jump1035;
    fail_assertion("index too large");
    _jump1035:;
    if (_819 >= 0)
    goto _jump1036;
    fail_assertion("negative array index");
    _jump1036:;
    if (_819 < _803.d2)
    goto _jump1037;
    fail_assertion("index too large");
    _jump1037:;
    int64_t _820 = 0;
    _820 *= _803.d0;
    _820 += _780;
    _820 *= _803.d1;
    _820 += _814;
    _820 *= _803.d2;
    _820 += _819;
    rgba _821 = _803.data[_820];
    _792 = _821;
    _jump1021:;
    int64_t _822 = 0;
    _822 *= _764.d0;
    _822 += _780;
    _822 *= _764.d1;
    _822 += _779;
    _822 *= _764.d2;
    _822 += _778;
    _764.data[_822] = _792;
    _778++;
    if (_778 < _776)
    goto _jump1006;
    _778 = 0;
    _779++;
    if (_779 < _341.d0)
    goto _jump1006;
    _779 = 0;
    _780++;
    if (_780 < _771)
    goto _jump1006;
    // End body of loop
    bool _823 = true;
    _a1_bool _824;
    if (!_823)
    goto _jump1038;
    bool _825 = true;
    _a2_bool _826;
    // Computing bound for h
    int64_t _827 = 26;
    _826.d0 = _827;
    if (_827 > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    // Computing bound for i
    int64_t _828 = 550;
    _826.d1 = _828;
    if (_828 > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    // Computing total size of heap memory to allocate
    int64_t _829 = 1;
    _829 *= _827;
    _829 *= _828;
    _829 *= sizeof(bool);
    _826.data = jpl_alloc(_829);
    int64_t _830 = 0; // i
    int64_t _831 = 0; // h
    _jump1041:; // Begin body of loop
    bool _832 = false;
    int64_t _833 = 0;
    _833 *= _826.d0;
    _833 += _831;
    _833 *= _826.d1;
    _833 += _830;
    _826.data[_833] = _832;
    _830++;
    if (_830 < _828)
    goto _jump1041;
    _830 = 0;
    _831++;
    if (_831 < _827)
    goto _jump1041;
    // End body of loop
    int64_t _834 = _341.d0 + _341.d0;
    if (_341.d1 >= 0)
    goto _jump1042;
    fail_assertion("negative array index");
    _jump1042:;
    if (_341.d1 < _826.d0)
    goto _jump1043;
    fail_assertion("index too large");
    _jump1043:;
    if (_834 >= 0)
    goto _jump1044;
    fail_assertion("negative array index");
    _jump1044:;
    if (_834 < _826.d1)
    goto _jump1045;
    fail_assertion("index too large");
    _jump1045:;
    int64_t _835 = 0;
    _835 *= _826.d0;
    _835 += _341.d1;
    _835 *= _826.d1;
    _835 += _834;
    bool _836 = _826.data[_835];
    bool _837 = _825 == _836;
    _a1_bool _838;
    if (!_837)
    goto _jump1046;
    bool _839 = true;
    bool _840 = !_839;
    int64_t _841 = 674;
    bool _842 = _341.d1 >= _841;
    bool _843 = c(d);
    bool _844 = _842 == _843;
    _a1_bool _845;
    _845.d0 = 2;
    _845.data = jpl_alloc(sizeof(bool) * 2);
    _845.data[0] = _840;
    _845.data[1] = _844;
    _838 = _845;
    goto _jump1047;
    _jump1046:;
    bool _847 = c(d);
    bool _846 = _847;
    if (0 == _847)
    goto _jump1048;
    int64_t _848 = 258;
    if (_848 >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (_848 < a.d0)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    int64_t _849 = 0;
    _849 *= a.d0;
    _849 += _848;
    bool _850 = a.data[_849];
    _846 = _850;
    _jump1048:;
    int64_t _851 = 799;
    int64_t _852 = _851 * _341.d0;
    int64_t _853 = 856;
    bool _854 = _852 <= _853;
    _a1_bool _855;
    _855.d0 = 2;
    _855.data = jpl_alloc(sizeof(bool) * 2);
    _855.data[0] = _846;
    _855.data[1] = _854;
    _838 = _855;
    _jump1047:;
    _824 = _838;
    goto _jump1051;
    _jump1038:;
    bool _856 = c(d);
    _a1_bool _857;
    _857.d0 = 1;
    _857.data = jpl_alloc(sizeof(bool) * 1);
    _857.data[0] = _856;
    _824 = _857;
    _jump1051:;
    _a2_rgba _858;
    // Computing bound for h
    _858.d0 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing bound for i
    bool _859 = false;
    int64_t _860;
    if (!_859)
    goto _jump1053;
    _860 = _341.d1;
    goto _jump1054;
    _jump1053:;
    int64_t _861 = -_341.d1;
    bool _862 = _861 != _341.d0;
    int64_t _863;
    if (!_862)
    goto _jump1055;
    _863 = _341.d1;
    goto _jump1056;
    _jump1055:;
    bool _864 = true;
    bool _865 = !_864;
    int64_t _866;
    if (!_865)
    goto _jump1057;
    _866 = _341.d1;
    goto _jump1058;
    _jump1057:;
    _866 = _341.d0;
    _jump1058:;
    _863 = _866;
    _jump1056:;
    _860 = _863;
    _jump1054:;
    _858.d1 = _860;
    if (_860 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing total size of heap memory to allocate
    int64_t _867 = 1;
    _867 *= _341.d1;
    _867 *= _860;
    _867 *= sizeof(rgba);
    _858.data = jpl_alloc(_867);
    int64_t _868 = 0; // i
    int64_t _869 = 0; // h
    _jump1060:; // Begin body of loop
    bool _870 = _868 != _341.d0;
    double _871;
    if (!_870)
    goto _jump1061;
    double _872;
    // Computing bound for j
    if (_341.d0 > 0) 
    goto _jump1062;
    fail_assertion("non-positive loop bound");
    _jump1062:;
    // Computing bound for k
    if (_869 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    _872 = 0;
    int64_t _873 = 0; // k
    int64_t _874 = 0; // j
    _jump1064:; // Begin body of loop
    double _875 = 44.0;
    _872 += _875;
    _873++;
    if (_873 < _869)
    goto _jump1064;
    _873 = 0;
    _874++;
    if (_874 < _341.d0)
    goto _jump1064;
    // End body of loop
    _871 = _872;
    goto _jump1065;
    _jump1061:;
    double _876 = 98.0;
    _871 = _876;
    _jump1065:;
    double _877 = 26.0;
    double _878 = 11.0;
    double _879 = fmod(_877, _878);
    double _880 = fmod(_871, _879);
    _a3_double _881;
    // Computing bound for j
    _881.d0 = _341.d1;
    if (_341.d1 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing bound for k
    int64_t _882 = 13;
    int64_t _883 = 323;
    int64_t _884 = _882 / _883;
    _881.d1 = _884;
    if (_884 > 0) 
    goto _jump1067;
    fail_assertion("non-positive loop bound");
    _jump1067:;
    // Computing bound for l
    _881.d2 = _869;
    if (_869 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing total size of heap memory to allocate
    int64_t _885 = 1;
    _885 *= _341.d1;
    _885 *= _884;
    _885 *= _869;
    _885 *= sizeof(double);
    _881.data = jpl_alloc(_885);
    int64_t _886 = 0; // l
    int64_t _887 = 0; // k
    int64_t _888 = 0; // j
    _jump1069:; // Begin body of loop
    double _889 = 43.0;
    int64_t _890 = 0;
    _890 *= _881.d0;
    _890 += _888;
    _890 *= _881.d1;
    _890 += _887;
    _890 *= _881.d2;
    _890 += _886;
    _881.data[_890] = _889;
    _886++;
    if (_886 < _869)
    goto _jump1069;
    _886 = 0;
    _887++;
    if (_887 < _884)
    goto _jump1069;
    _887 = 0;
    _888++;
    if (_888 < _341.d1)
    goto _jump1069;
    // End body of loop
    int64_t _891 = 252;
    bool _892 = _341.d0 < _341.d0;
    int64_t _893;
    if (!_892)
    goto _jump1070;
    _893 = _341.d0;
    goto _jump1071;
    _jump1070:;
    _893 = _341.d0;
    _jump1071:;
    if (_869 >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (_869 < _881.d0)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    if (_891 >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (_891 < _881.d1)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    if (_893 >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (_893 < _881.d2)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    int64_t _894 = 0;
    _894 *= _881.d0;
    _894 += _869;
    _894 *= _881.d1;
    _894 += _891;
    _894 *= _881.d2;
    _894 += _893;
    double _895 = _881.data[_894];
    _a2_double _896;
    // Computing bound for j
    int64_t _897;
    // Computing bound for j
    if (_341.d0 > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    _897 = 0;
    int64_t _898 = 0; // j
    _jump1079:; // Begin body of loop
    _897 += _868;
    _898++;
    if (_898 < _341.d0)
    goto _jump1079;
    // End body of loop
    _896.d0 = _897;
    if (_897 > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    // Computing bound for k
    _896.d1 = _868;
    if (_868 > 0) 
    goto _jump1081;
    fail_assertion("non-positive loop bound");
    _jump1081:;
    // Computing total size of heap memory to allocate
    int64_t _899 = 1;
    _899 *= _897;
    _899 *= _868;
    _899 *= sizeof(double);
    _896.data = jpl_alloc(_899);
    int64_t _900 = 0; // k
    int64_t _901 = 0; // j
    _jump1082:; // Begin body of loop
    double _902;
    // Computing bound for l
    if (_868 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    _902 = 0;
    int64_t _903 = 0; // l
    _jump1084:; // Begin body of loop
    double _904 = 99.0;
    _902 += _904;
    _903++;
    if (_903 < _868)
    goto _jump1084;
    // End body of loop
    int64_t _905 = 0;
    _905 *= _896.d0;
    _905 += _901;
    _905 *= _896.d1;
    _905 += _900;
    _896.data[_905] = _902;
    _900++;
    if (_900 < _868)
    goto _jump1082;
    _900 = 0;
    _901++;
    if (_901 < _897)
    goto _jump1082;
    // End body of loop
    int64_t _906 = 237;
    if (_906 >= 0)
    goto _jump1085;
    fail_assertion("negative array index");
    _jump1085:;
    if (_906 < _896.d0)
    goto _jump1086;
    fail_assertion("index too large");
    _jump1086:;
    if (_341.d1 >= 0)
    goto _jump1087;
    fail_assertion("negative array index");
    _jump1087:;
    if (_341.d1 < _896.d1)
    goto _jump1088;
    fail_assertion("index too large");
    _jump1088:;
    int64_t _907 = 0;
    _907 *= _896.d0;
    _907 += _906;
    _907 *= _896.d1;
    _907 += _341.d1;
    double _908 = _896.data[_907];
    double _909 = 17.0;
    double _910 = -_909;
    double _911 = 5.0;
    double _912 = _910 - _911;
    double _913 = -_912;
    rgba _914 = { _880, _895, _908, _913 };
    int64_t _915 = 0;
    _915 *= _858.d0;
    _915 += _869;
    _915 *= _858.d1;
    _915 += _868;
    _858.data[_915] = _914;
    _868++;
    if (_868 < _860)
    goto _jump1060;
    _868 = 0;
    _869++;
    if (_869 < _341.d1)
    goto _jump1060;
    // End body of loop
    int64_t _916 = b(_764, _824, _858);
    _763 = _916;
    _jump997:;
    bool _917 = false;
    return _917;
}

bool f(e g, _a3_int64_t h, _a2_void_t l) {
    int64_t _0 = 656;
    int64_t _2 = 926;
    int64_t _3 = -_2;
    bool _4 = l.d1 <= _3;
    bool _1 = _4;
    if (0 == _4)
    goto _jump1198;
    bool _5 = true;
    bool _6 = !_5;
    bool _7;
    if (!_6)
    goto _jump1199;
    bool _8 = true;
    _7 = _8;
    goto _jump1200;
    _jump1199:;
    bool _9 = true;
    _7 = _9;
    _jump1200:;
    _1 = _7;
    _jump1198:;
    int64_t _10;
    if (!_1)
    goto _jump1201;
    bool _11 = f(g, h, l);
    int64_t _12;
    if (!_11)
    goto _jump1202;
    _12 = _0;
    goto _jump1203;
    _jump1202:;
    int64_t _13 = 5;
    int64_t _14 = l.d1 - _13;
    _12 = _14;
    _jump1203:;
    if (_12 >= 0)
    goto _jump1204;
    fail_assertion("negative array index");
    _jump1204:;
    if (_12 < h.d0)
    goto _jump1205;
    fail_assertion("index too large");
    _jump1205:;
    if (h.d0 >= 0)
    goto _jump1206;
    fail_assertion("negative array index");
    _jump1206:;
    if (h.d0 < h.d1)
    goto _jump1207;
    fail_assertion("index too large");
    _jump1207:;
    if (l.d1 >= 0)
    goto _jump1208;
    fail_assertion("negative array index");
    _jump1208:;
    if (l.d1 < h.d2)
    goto _jump1209;
    fail_assertion("index too large");
    _jump1209:;
    int64_t _15 = 0;
    _15 *= h.d0;
    _15 += _12;
    _15 *= h.d1;
    _15 += h.d0;
    _15 *= h.d2;
    _15 += l.d1;
    int64_t _16 = h.data[_15];
    _10 = _16;
    goto _jump1210;
    _jump1201:;
    _10 = l.d1;
    _jump1210:;
    bool _17 = _10 >= l.d1;
    _a2__a2_int64_t _18;
    if (!_17)
    goto _jump1211;
    _a2__a2_int64_t _19;
    // Computing bound for p
    _19.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    // Computing bound for q
    int64_t _20;
    // Computing bound for p
    if (h.d2 > 0) 
    goto _jump1213;
    fail_assertion("non-positive loop bound");
    _jump1213:;
    // Computing bound for q
    if (h.d0 > 0) 
    goto _jump1214;
    fail_assertion("non-positive loop bound");
    _jump1214:;
    // Computing bound for r
    if (_0 > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    _20 = 0;
    int64_t _21 = 0; // r
    int64_t _22 = 0; // q
    int64_t _23 = 0; // p
    _jump1216:; // Begin body of loop
    _20 += _21;
    _21++;
    if (_21 < _0)
    goto _jump1216;
    _21 = 0;
    _22++;
    if (_22 < h.d0)
    goto _jump1216;
    _22 = 0;
    _23++;
    if (_23 < h.d2)
    goto _jump1216;
    // End body of loop
    _19.d1 = _20;
    if (_20 > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= h.d0;
    _24 *= _20;
    _24 *= sizeof(_a2_int64_t);
    _19.data = jpl_alloc(_24);
    int64_t _25 = 0; // q
    int64_t _26 = 0; // p
    _jump1218:; // Begin body of loop
    _a2_int64_t _27;
    // Computing bound for r
    int64_t _28 = 560;
    int64_t _29 = -_28;
    int64_t _30 = -_29;
    _27.d0 = _30;
    if (_30 > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing bound for s
    int64_t _31 = l.d1 - _26;
    _27.d1 = _31;
    if (_31 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _30;
    _32 *= _31;
    _32 *= sizeof(int64_t);
    _27.data = jpl_alloc(_32);
    int64_t _33 = 0; // s
    int64_t _34 = 0; // r
    _jump1221:; // Begin body of loop
    int64_t _35 = 0;
    _35 *= _27.d0;
    _35 += _34;
    _35 *= _27.d1;
    _35 += _33;
    _27.data[_35] = h.d0;
    _33++;
    if (_33 < _31)
    goto _jump1221;
    _33 = 0;
    _34++;
    if (_34 < _30)
    goto _jump1221;
    // End body of loop
    int64_t _36 = 0;
    _36 *= _19.d0;
    _36 += _26;
    _36 *= _19.d1;
    _36 += _25;
    _19.data[_36] = _27;
    _25++;
    if (_25 < _20)
    goto _jump1218;
    _25 = 0;
    _26++;
    if (_26 < h.d0)
    goto _jump1218;
    // End body of loop
    _18 = _19;
    goto _jump1222;
    _jump1211:;
    _a2__a2_int64_t _37;
    // Computing bound for p
    _37.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing bound for q
    _37.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1224;
    fail_assertion("non-positive loop bound");
    _jump1224:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= h.d2;
    _38 *= l.d0;
    _38 *= sizeof(_a2_int64_t);
    _37.data = jpl_alloc(_38);
    int64_t _39 = 0; // q
    int64_t _40 = 0; // p
    _jump1225:; // Begin body of loop
    _a2_int64_t _41;
    // Computing bound for r
    _41.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for s
    int64_t _42 = l.d1 / h.d2;
    int64_t _43 = -_42;
    _41.d1 = _43;
    if (_43 > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing total size of heap memory to allocate
    int64_t _44 = 1;
    _44 *= h.d1;
    _44 *= _43;
    _44 *= sizeof(int64_t);
    _41.data = jpl_alloc(_44);
    int64_t _45 = 0; // s
    int64_t _46 = 0; // r
    _jump1228:; // Begin body of loop
    int64_t _47 = 0;
    _47 *= _41.d0;
    _47 += _46;
    _47 *= _41.d1;
    _47 += _45;
    _41.data[_47] = _46;
    _45++;
    if (_45 < _43)
    goto _jump1228;
    _45 = 0;
    _46++;
    if (_46 < h.d1)
    goto _jump1228;
    // End body of loop
    int64_t _48 = 0;
    _48 *= _37.d0;
    _48 += _40;
    _48 *= _37.d1;
    _48 += _39;
    _37.data[_48] = _41;
    _39++;
    if (_39 < l.d0)
    goto _jump1225;
    _39 = 0;
    _40++;
    if (_40 < h.d2)
    goto _jump1225;
    // End body of loop
    _18 = _37;
    _jump1222:;
    _a3_rgba _49;
    // Computing bound for p
    _49.d0 = _0;
    if (_0 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    // Computing bound for q
    _a3_int64_t _50;
    // Computing bound for p
    bool _51 = false;
    int64_t _52;
    if (!_51)
    goto _jump1230;
    _52 = h.d2;
    goto _jump1231;
    _jump1230:;
    _52 = _0;
    _jump1231:;
    _50.d0 = _52;
    if (_52 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    // Computing bound for q
    _50.d1 = _0;
    if (_0 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing bound for r
    int64_t _53 = 903;
    _50.d2 = _53;
    if (_53 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= _52;
    _54 *= _0;
    _54 *= _53;
    _54 *= sizeof(int64_t);
    _50.data = jpl_alloc(_54);
    int64_t _55 = 0; // r
    int64_t _56 = 0; // q
    int64_t _57 = 0; // p
    _jump1235:; // Begin body of loop
    bool _58 = f(g, h, l);
    int64_t _59;
    if (!_58)
    goto _jump1236;
    _59 = _56;
    goto _jump1237;
    _jump1236:;
    _59 = _57;
    _jump1237:;
    int64_t _60 = 0;
    _60 *= _50.d0;
    _60 += _57;
    _60 *= _50.d1;
    _60 += _56;
    _60 *= _50.d2;
    _60 += _55;
    _50.data[_60] = _59;
    _55++;
    if (_55 < _53)
    goto _jump1235;
    _55 = 0;
    _56++;
    if (_56 < _0)
    goto _jump1235;
    _56 = 0;
    _57++;
    if (_57 < _52)
    goto _jump1235;
    // End body of loop
    if (h.d2 >= 0)
    goto _jump1238;
    fail_assertion("negative array index");
    _jump1238:;
    if (h.d2 < _50.d0)
    goto _jump1239;
    fail_assertion("index too large");
    _jump1239:;
    if (l.d1 >= 0)
    goto _jump1240;
    fail_assertion("negative array index");
    _jump1240:;
    if (l.d1 < _50.d1)
    goto _jump1241;
    fail_assertion("index too large");
    _jump1241:;
    if (l.d1 >= 0)
    goto _jump1242;
    fail_assertion("negative array index");
    _jump1242:;
    if (l.d1 < _50.d2)
    goto _jump1243;
    fail_assertion("index too large");
    _jump1243:;
    int64_t _61 = 0;
    _61 *= _50.d0;
    _61 += h.d2;
    _61 *= _50.d1;
    _61 += l.d1;
    _61 *= _50.d2;
    _61 += l.d1;
    int64_t _62 = _50.data[_61];
    _49.d1 = _62;
    if (_62 > 0) 
    goto _jump1244;
    fail_assertion("non-positive loop bound");
    _jump1244:;
    // Computing bound for r
    _a3_rgba _63;
    // Computing bound for p
    int64_t _64 = 875;
    _63.d0 = _64;
    if (_64 > 0) 
    goto _jump1245;
    fail_assertion("non-positive loop bound");
    _jump1245:;
    // Computing bound for q
    int64_t _65 = -_0;
    _63.d1 = _65;
    if (_65 > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing bound for r
    _63.d2 = h.d2;
    if (h.d2 > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= _64;
    _66 *= _65;
    _66 *= h.d2;
    _66 *= sizeof(rgba);
    _63.data = jpl_alloc(_66);
    int64_t _67 = 0; // r
    int64_t _68 = 0; // q
    int64_t _69 = 0; // p
    _jump1248:; // Begin body of loop
    int64_t _70 = 0;
    _70 *= _63.d0;
    _70 += _69;
    _70 *= _63.d1;
    _70 += _68;
    _70 *= _63.d2;
    _70 += _67;
    _63.data[_70] = d;
    _67++;
    if (_67 < h.d2)
    goto _jump1248;
    _67 = 0;
    _68++;
    if (_68 < _65)
    goto _jump1248;
    _68 = 0;
    _69++;
    if (_69 < _64)
    goto _jump1248;
    // End body of loop
    int64_t _71 = 590;
    if (_71 >= 0)
    goto _jump1249;
    fail_assertion("negative array index");
    _jump1249:;
    if (_71 < l.d0)
    goto _jump1250;
    fail_assertion("index too large");
    _jump1250:;
    if (l.d1 >= 0)
    goto _jump1251;
    fail_assertion("negative array index");
    _jump1251:;
    if (l.d1 < l.d1)
    goto _jump1252;
    fail_assertion("index too large");
    _jump1252:;
    int64_t _72 = 0;
    _72 *= l.d0;
    _72 += _71;
    _72 *= l.d1;
    _72 += l.d1;
    void_t _73 = l.data[_72];
    bool _74 = c(_73);
    _a1_bool _75;
    if (!_74)
    goto _jump1253;
    bool _76 = false;
    bool _77 = !_76;
    _a1_bool _78;
    _78.d0 = 1;
    _78.data = jpl_alloc(sizeof(bool) * 1);
    _78.data[0] = _77;
    _75 = _78;
    goto _jump1254;
    _jump1253:;
    _a2__a1_bool _79;
    // Computing bound for p
    _79.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1255;
    fail_assertion("non-positive loop bound");
    _jump1255:;
    // Computing bound for q
    _79.d1 = h.d1;
    if (h.d1 > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= h.d1;
    _80 *= h.d1;
    _80 *= sizeof(_a1_bool);
    _79.data = jpl_alloc(_80);
    int64_t _81 = 0; // q
    int64_t _82 = 0; // p
    _jump1257:; // Begin body of loop
    int64_t _83 = 0;
    _83 *= _79.d0;
    _83 += _82;
    _83 *= _79.d1;
    _83 += _81;
    _79.data[_83] = a;
    _81++;
    if (_81 < h.d1)
    goto _jump1257;
    _81 = 0;
    _82++;
    if (_82 < h.d1)
    goto _jump1257;
    // End body of loop
    int64_t _84;
    // Computing bound for p
    if (l.d0 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    _84 = 0;
    int64_t _85 = 0; // p
    _jump1259:; // Begin body of loop
    _84 += _0;
    _85++;
    if (_85 < l.d0)
    goto _jump1259;
    // End body of loop
    if (_84 >= 0)
    goto _jump1260;
    fail_assertion("negative array index");
    _jump1260:;
    if (_84 < _79.d0)
    goto _jump1261;
    fail_assertion("index too large");
    _jump1261:;
    if (l.d0 >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (l.d0 < _79.d1)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    int64_t _86 = 0;
    _86 *= _79.d0;
    _86 += _84;
    _86 *= _79.d1;
    _86 += l.d0;
    _a1_bool _87 = _79.data[_86];
    _75 = _87;
    _jump1254:;
    _a3__a2_rgba _88;
    // Computing bound for p
    _88.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing bound for q
    _88.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    // Computing bound for r
    _88.d2 = h.d2;
    if (h.d2 > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= h.d2;
    _89 *= h.d0;
    _89 *= h.d2;
    _89 *= sizeof(_a2_rgba);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // r
    int64_t _91 = 0; // q
    int64_t _92 = 0; // p
    _jump1267:; // Begin body of loop
    _a2_rgba _93;
    // Computing bound for s
    _93.d0 = _92;
    if (_92 > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    // Computing bound for t
    _93.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    // Computing total size of heap memory to allocate
    int64_t _94 = 1;
    _94 *= _92;
    _94 *= h.d2;
    _94 *= sizeof(rgba);
    _93.data = jpl_alloc(_94);
    int64_t _95 = 0; // t
    int64_t _96 = 0; // s
    _jump1270:; // Begin body of loop
    int64_t _97 = 0;
    _97 *= _93.d0;
    _97 += _96;
    _97 *= _93.d1;
    _97 += _95;
    _93.data[_97] = d;
    _95++;
    if (_95 < h.d2)
    goto _jump1270;
    _95 = 0;
    _96++;
    if (_96 < _92)
    goto _jump1270;
    // End body of loop
    int64_t _98 = 0;
    _98 *= _88.d0;
    _98 += _92;
    _98 *= _88.d1;
    _98 += _91;
    _98 *= _88.d2;
    _98 += _90;
    _88.data[_98] = _93;
    _90++;
    if (_90 < h.d2)
    goto _jump1267;
    _90 = 0;
    _91++;
    if (_91 < h.d0)
    goto _jump1267;
    _91 = 0;
    _92++;
    if (_92 < h.d2)
    goto _jump1267;
    // End body of loop
    _a3_rgba _99;
    // Computing bound for p
    int64_t _100 = 715;
    _99.d0 = _100;
    if (_100 > 0) 
    goto _jump1271;
    fail_assertion("non-positive loop bound");
    _jump1271:;
    // Computing bound for q
    _99.d1 = _0;
    if (_0 > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for r
    int64_t _101 = 832;
    _99.d2 = _101;
    if (_101 > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= _100;
    _102 *= _0;
    _102 *= _101;
    _102 *= sizeof(rgba);
    _99.data = jpl_alloc(_102);
    int64_t _103 = 0; // r
    int64_t _104 = 0; // q
    int64_t _105 = 0; // p
    _jump1274:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _99.d0;
    _106 += _105;
    _106 *= _99.d1;
    _106 += _104;
    _106 *= _99.d2;
    _106 += _103;
    _99.data[_106] = d;
    _103++;
    if (_103 < _101)
    goto _jump1274;
    _103 = 0;
    _104++;
    if (_104 < _0)
    goto _jump1274;
    _104 = 0;
    _105++;
    if (_105 < _100)
    goto _jump1274;
    // End body of loop
    _a2_rgba _107;
    // Computing bound for p
    int64_t _108 = 942;
    _107.d0 = _108;
    if (_108 > 0) 
    goto _jump1275;
    fail_assertion("non-positive loop bound");
    _jump1275:;
    // Computing bound for q
    _107.d1 = _0;
    if (_0 > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= _108;
    _109 *= _0;
    _109 *= sizeof(rgba);
    _107.data = jpl_alloc(_109);
    int64_t _110 = 0; // q
    int64_t _111 = 0; // p
    _jump1277:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _107.d0;
    _112 += _111;
    _112 *= _107.d1;
    _112 += _110;
    _107.data[_112] = d;
    _110++;
    if (_110 < _0)
    goto _jump1277;
    _110 = 0;
    _111++;
    if (_111 < _108)
    goto _jump1277;
    // End body of loop
    int64_t _113 = b(_99, a, _107);
    int64_t _114;
    // Computing bound for p
    if (_0 > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing bound for q
    if (h.d1 > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing bound for r
    if (l.d1 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    _114 = 0;
    int64_t _115 = 0; // r
    int64_t _116 = 0; // q
    int64_t _117 = 0; // p
    _jump1281:; // Begin body of loop
    _114 += _0;
    _115++;
    if (_115 < l.d1)
    goto _jump1281;
    _115 = 0;
    _116++;
    if (_116 < h.d1)
    goto _jump1281;
    _116 = 0;
    _117++;
    if (_117 < _0)
    goto _jump1281;
    // End body of loop
    _a3_int64_t _118;
    // Computing bound for p
    _118.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing bound for q
    _118.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for r
    _118.d2 = l.d0;
    if (l.d0 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= h.d0;
    _119 *= h.d2;
    _119 *= l.d0;
    _119 *= sizeof(int64_t);
    _118.data = jpl_alloc(_119);
    int64_t _120 = 0; // r
    int64_t _121 = 0; // q
    int64_t _122 = 0; // p
    _jump1285:; // Begin body of loop
    int64_t _123 = 0;
    _123 *= _118.d0;
    _123 += _122;
    _123 *= _118.d1;
    _123 += _121;
    _123 *= _118.d2;
    _123 += _120;
    _118.data[_123] = h.d2;
    _120++;
    if (_120 < l.d0)
    goto _jump1285;
    _120 = 0;
    _121++;
    if (_121 < h.d2)
    goto _jump1285;
    _121 = 0;
    _122++;
    if (_122 < h.d0)
    goto _jump1285;
    // End body of loop
    bool _124 = true;
    int64_t _125;
    if (!_124)
    goto _jump1286;
    _125 = h.d1;
    goto _jump1287;
    _jump1286:;
    _125 = l.d0;
    _jump1287:;
    bool _126 = false;
    int64_t _127;
    if (!_126)
    goto _jump1288;
    _127 = h.d2;
    goto _jump1289;
    _jump1288:;
    _127 = _0;
    _jump1289:;
    if (h.d0 >= 0)
    goto _jump1290;
    fail_assertion("negative array index");
    _jump1290:;
    if (h.d0 < _118.d0)
    goto _jump1291;
    fail_assertion("index too large");
    _jump1291:;
    if (_125 >= 0)
    goto _jump1292;
    fail_assertion("negative array index");
    _jump1292:;
    if (_125 < _118.d1)
    goto _jump1293;
    fail_assertion("index too large");
    _jump1293:;
    if (_127 >= 0)
    goto _jump1294;
    fail_assertion("negative array index");
    _jump1294:;
    if (_127 < _118.d2)
    goto _jump1295;
    fail_assertion("index too large");
    _jump1295:;
    int64_t _128 = 0;
    _128 *= _118.d0;
    _128 += h.d0;
    _128 *= _118.d1;
    _128 += _125;
    _128 *= _118.d2;
    _128 += _127;
    int64_t _129 = _118.data[_128];
    if (_113 >= 0)
    goto _jump1296;
    fail_assertion("negative array index");
    _jump1296:;
    if (_113 < _88.d0)
    goto _jump1297;
    fail_assertion("index too large");
    _jump1297:;
    if (_114 >= 0)
    goto _jump1298;
    fail_assertion("negative array index");
    _jump1298:;
    if (_114 < _88.d1)
    goto _jump1299;
    fail_assertion("index too large");
    _jump1299:;
    if (_129 >= 0)
    goto _jump1300;
    fail_assertion("negative array index");
    _jump1300:;
    if (_129 < _88.d2)
    goto _jump1301;
    fail_assertion("index too large");
    _jump1301:;
    int64_t _130 = 0;
    _130 *= _88.d0;
    _130 += _113;
    _130 *= _88.d1;
    _130 += _114;
    _130 *= _88.d2;
    _130 += _129;
    _a2_rgba _131 = _88.data[_130];
    int64_t _132 = b(_63, _75, _131);
    _49.d2 = _132;
    if (_132 > 0) 
    goto _jump1302;
    fail_assertion("non-positive loop bound");
    _jump1302:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _0;
    _133 *= _62;
    _133 *= _132;
    _133 *= sizeof(rgba);
    _49.data = jpl_alloc(_133);
    int64_t _134 = 0; // r
    int64_t _135 = 0; // q
    int64_t _136 = 0; // p
    _jump1303:; // Begin body of loop
    bool _137 = true;
    rgba _138;
    if (!_137)
    goto _jump1304;
    _a1_rgba _139;
    // Computing bound for s
    _139.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= h.d2;
    _140 *= sizeof(rgba);
    _139.data = jpl_alloc(_140);
    int64_t _141 = 0; // s
    _jump1306:; // Begin body of loop
    int64_t _142 = 0;
    _142 *= _139.d0;
    _142 += _141;
    _139.data[_142] = d;
    _141++;
    if (_141 < h.d2)
    goto _jump1306;
    // End body of loop
    if (h.d2 >= 0)
    goto _jump1307;
    fail_assertion("negative array index");
    _jump1307:;
    if (h.d2 < _139.d0)
    goto _jump1308;
    fail_assertion("index too large");
    _jump1308:;
    int64_t _143 = 0;
    _143 *= _139.d0;
    _143 += h.d2;
    rgba _144 = _139.data[_143];
    _138 = _144;
    goto _jump1309;
    _jump1304:;
    _a1_rgba _145;
    // Computing bound for s
    _145.d0 = _135;
    if (_135 > 0) 
    goto _jump1310;
    fail_assertion("non-positive loop bound");
    _jump1310:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _135;
    _146 *= sizeof(rgba);
    _145.data = jpl_alloc(_146);
    int64_t _147 = 0; // s
    _jump1311:; // Begin body of loop
    int64_t _148 = 0;
    _148 *= _145.d0;
    _148 += _147;
    _145.data[_148] = d;
    _147++;
    if (_147 < _135)
    goto _jump1311;
    // End body of loop
    bool _149 = true;
    int64_t _150;
    if (!_149)
    goto _jump1312;
    int64_t _151 = 127;
    _150 = _151;
    goto _jump1313;
    _jump1312:;
    _150 = l.d1;
    _jump1313:;
    if (_150 >= 0)
    goto _jump1314;
    fail_assertion("negative array index");
    _jump1314:;
    if (_150 < _145.d0)
    goto _jump1315;
    fail_assertion("index too large");
    _jump1315:;
    int64_t _152 = 0;
    _152 *= _145.d0;
    _152 += _150;
    rgba _153 = _145.data[_152];
    _138 = _153;
    _jump1309:;
    int64_t _154 = 0;
    _154 *= _49.d0;
    _154 += _136;
    _154 *= _49.d1;
    _154 += _135;
    _154 *= _49.d2;
    _154 += _134;
    _49.data[_154] = _138;
    _134++;
    if (_134 < _132)
    goto _jump1303;
    _134 = 0;
    _135++;
    if (_135 < _62)
    goto _jump1303;
    _135 = 0;
    _136++;
    if (_136 < _0)
    goto _jump1303;
    // End body of loop
    _a1_bool _155;
    // Computing bound for p
    _155.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= l.d0;
    _156 *= sizeof(bool);
    _155.data = jpl_alloc(_156);
    int64_t _157 = 0; // p
    _jump1317:; // Begin body of loop
    _a2_int64_t _158;
    // Computing bound for q
    _158.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for r
    _158.d1 = _157;
    if (_157 > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= h.d0;
    _159 *= _157;
    _159 *= sizeof(int64_t);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // r
    int64_t _161 = 0; // q
    _jump1320:; // Begin body of loop
    int64_t _162 = 0;
    _162 *= _158.d0;
    _162 += _161;
    _162 *= _158.d1;
    _162 += _160;
    _158.data[_162] = _0;
    _160++;
    if (_160 < _157)
    goto _jump1320;
    _160 = 0;
    _161++;
    if (_161 < h.d0)
    goto _jump1320;
    // End body of loop
    bool _163 = true;
    int64_t _164;
    if (!_163)
    goto _jump1321;
    _164 = _0;
    goto _jump1322;
    _jump1321:;
    _164 = _0;
    _jump1322:;
    if (_164 >= 0)
    goto _jump1323;
    fail_assertion("negative array index");
    _jump1323:;
    if (_164 < _158.d0)
    goto _jump1324;
    fail_assertion("index too large");
    _jump1324:;
    if (h.d2 >= 0)
    goto _jump1325;
    fail_assertion("negative array index");
    _jump1325:;
    if (h.d2 < _158.d1)
    goto _jump1326;
    fail_assertion("index too large");
    _jump1326:;
    int64_t _165 = 0;
    _165 *= _158.d0;
    _165 += _164;
    _165 *= _158.d1;
    _165 += h.d2;
    int64_t _166 = _158.data[_165];
    int64_t _167 = -_166;
    bool _168 = _167 >= h.d2;
    int64_t _169 = 0;
    _169 *= _155.d0;
    _169 += _157;
    _155.data[_169] = _168;
    _157++;
    if (_157 < l.d0)
    goto _jump1317;
    // End body of loop
    _a2__a3_bool _170;
    // Computing bound for p
    int64_t _171;
    // Computing bound for p
    if (_0 > 0) 
    goto _jump1327;
    fail_assertion("non-positive loop bound");
    _jump1327:;
    // Computing bound for q
    if (h.d1 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    // Computing bound for r
    if (l.d0 > 0) 
    goto _jump1329;
    fail_assertion("non-positive loop bound");
    _jump1329:;
    _171 = 0;
    int64_t _172 = 0; // r
    int64_t _173 = 0; // q
    int64_t _174 = 0; // p
    _jump1330:; // Begin body of loop
    _171 += h.d1;
    _172++;
    if (_172 < l.d0)
    goto _jump1330;
    _172 = 0;
    _173++;
    if (_173 < h.d1)
    goto _jump1330;
    _173 = 0;
    _174++;
    if (_174 < _0)
    goto _jump1330;
    // End body of loop
    _170.d0 = _171;
    if (_171 > 0) 
    goto _jump1331;
    fail_assertion("non-positive loop bound");
    _jump1331:;
    // Computing bound for q
    _170.d1 = _0;
    if (_0 > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    // Computing total size of heap memory to allocate
    int64_t _175 = 1;
    _175 *= _171;
    _175 *= _0;
    _175 *= sizeof(_a3_bool);
    _170.data = jpl_alloc(_175);
    int64_t _176 = 0; // q
    int64_t _177 = 0; // p
    _jump1333:; // Begin body of loop
    _a3_bool _178 = g.a;
    int64_t _179 = 0;
    _179 *= _170.d0;
    _179 += _177;
    _179 *= _170.d1;
    _179 += _176;
    _170.data[_179] = _178;
    _176++;
    if (_176 < _0)
    goto _jump1333;
    _176 = 0;
    _177++;
    if (_177 < _171)
    goto _jump1333;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump1334;
    fail_assertion("negative array index");
    _jump1334:;
    if (h.d1 < _170.d0)
    goto _jump1335;
    fail_assertion("index too large");
    _jump1335:;
    if (h.d2 >= 0)
    goto _jump1336;
    fail_assertion("negative array index");
    _jump1336:;
    if (h.d2 < _170.d1)
    goto _jump1337;
    fail_assertion("index too large");
    _jump1337:;
    int64_t _180 = 0;
    _180 *= _170.d0;
    _180 += h.d1;
    _180 *= _170.d1;
    _180 += h.d2;
    _a3_bool _181 = _170.data[_180];
    if (h.d2 >= 0)
    goto _jump1338;
    fail_assertion("negative array index");
    _jump1338:;
    if (h.d2 < l.d0)
    goto _jump1339;
    fail_assertion("index too large");
    _jump1339:;
    if (h.d1 >= 0)
    goto _jump1340;
    fail_assertion("negative array index");
    _jump1340:;
    if (h.d1 < l.d1)
    goto _jump1341;
    fail_assertion("index too large");
    _jump1341:;
    int64_t _182 = 0;
    _182 *= l.d0;
    _182 += h.d2;
    _182 *= l.d1;
    _182 += h.d1;
    void_t _183 = l.data[_182];
    bool _184 = c(_183);
    int64_t _185;
    if (!_184)
    goto _jump1342;
    _185 = h.d0;
    goto _jump1343;
    _jump1342:;
    int64_t _186 = 87;
    if (h.d1 >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (h.d1 < h.d0)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    if (_186 >= 0)
    goto _jump1346;
    fail_assertion("negative array index");
    _jump1346:;
    if (_186 < h.d1)
    goto _jump1347;
    fail_assertion("index too large");
    _jump1347:;
    if (h.d1 >= 0)
    goto _jump1348;
    fail_assertion("negative array index");
    _jump1348:;
    if (h.d1 < h.d2)
    goto _jump1349;
    fail_assertion("index too large");
    _jump1349:;
    int64_t _187 = 0;
    _187 *= h.d0;
    _187 += h.d1;
    _187 *= h.d1;
    _187 += _186;
    _187 *= h.d2;
    _187 += h.d1;
    int64_t _188 = h.data[_187];
    _185 = _188;
    _jump1343:;
    bool _189 = true;
    _a1_int64_t _190;
    if (!_189)
    goto _jump1350;
    _a1_int64_t _191;
    // Computing bound for p
    _191.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1351;
    fail_assertion("non-positive loop bound");
    _jump1351:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= h.d1;
    _192 *= sizeof(int64_t);
    _191.data = jpl_alloc(_192);
    int64_t _193 = 0; // p
    _jump1352:; // Begin body of loop
    int64_t _194 = 0;
    _194 *= _191.d0;
    _194 += _193;
    _191.data[_194] = h.d0;
    _193++;
    if (_193 < h.d1)
    goto _jump1352;
    // End body of loop
    _190 = _191;
    goto _jump1353;
    _jump1350:;
    _a1_int64_t _195;
    // Computing bound for p
    _195.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1354;
    fail_assertion("non-positive loop bound");
    _jump1354:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= h.d0;
    _196 *= sizeof(int64_t);
    _195.data = jpl_alloc(_196);
    int64_t _197 = 0; // p
    _jump1355:; // Begin body of loop
    int64_t _198 = 0;
    _198 *= _195.d0;
    _198 += _197;
    _195.data[_198] = _0;
    _197++;
    if (_197 < h.d0)
    goto _jump1355;
    // End body of loop
    _190 = _195;
    _jump1353:;
    int64_t _199 = -_0;
    if (_199 >= 0)
    goto _jump1356;
    fail_assertion("negative array index");
    _jump1356:;
    if (_199 < _190.d0)
    goto _jump1357;
    fail_assertion("index too large");
    _jump1357:;
    int64_t _200 = 0;
    _200 *= _190.d0;
    _200 += _199;
    int64_t _201 = _190.data[_200];
    _a3_int64_t _202;
    // Computing bound for p
    int64_t _203 = l.d0 / l.d1;
    _202.d0 = _203;
    if (_203 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    // Computing bound for q
    _202.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1359;
    fail_assertion("non-positive loop bound");
    _jump1359:;
    // Computing bound for r
    int64_t _204 = 517;
    _202.d2 = _204;
    if (_204 > 0) 
    goto _jump1360;
    fail_assertion("non-positive loop bound");
    _jump1360:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _203;
    _205 *= h.d2;
    _205 *= _204;
    _205 *= sizeof(int64_t);
    _202.data = jpl_alloc(_205);
    int64_t _206 = 0; // r
    int64_t _207 = 0; // q
    int64_t _208 = 0; // p
    _jump1361:; // Begin body of loop
    int64_t _209 = 0;
    _209 *= _202.d0;
    _209 += _208;
    _209 *= _202.d1;
    _209 += _207;
    _209 *= _202.d2;
    _209 += _206;
    _202.data[_209] = l.d1;
    _206++;
    if (_206 < _204)
    goto _jump1361;
    _206 = 0;
    _207++;
    if (_207 < h.d2)
    goto _jump1361;
    _207 = 0;
    _208++;
    if (_208 < _203)
    goto _jump1361;
    // End body of loop
    int64_t _210 = h.d2 + h.d1;
    int64_t _211 = 328;
    int64_t _212;
    // Computing bound for p
    if (l.d1 > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    _212 = 0;
    int64_t _213 = 0; // p
    _jump1363:; // Begin body of loop
    _212 += h.d0;
    _213++;
    if (_213 < l.d1)
    goto _jump1363;
    // End body of loop
    if (_210 >= 0)
    goto _jump1364;
    fail_assertion("negative array index");
    _jump1364:;
    if (_210 < _202.d0)
    goto _jump1365;
    fail_assertion("index too large");
    _jump1365:;
    if (_211 >= 0)
    goto _jump1366;
    fail_assertion("negative array index");
    _jump1366:;
    if (_211 < _202.d1)
    goto _jump1367;
    fail_assertion("index too large");
    _jump1367:;
    if (_212 >= 0)
    goto _jump1368;
    fail_assertion("negative array index");
    _jump1368:;
    if (_212 < _202.d2)
    goto _jump1369;
    fail_assertion("index too large");
    _jump1369:;
    int64_t _214 = 0;
    _214 *= _202.d0;
    _214 += _210;
    _214 *= _202.d1;
    _214 += _211;
    _214 *= _202.d2;
    _214 += _212;
    int64_t _215 = _202.data[_214];
    if (_185 >= 0)
    goto _jump1370;
    fail_assertion("negative array index");
    _jump1370:;
    if (_185 < _181.d0)
    goto _jump1371;
    fail_assertion("index too large");
    _jump1371:;
    if (_201 >= 0)
    goto _jump1372;
    fail_assertion("negative array index");
    _jump1372:;
    if (_201 < _181.d1)
    goto _jump1373;
    fail_assertion("index too large");
    _jump1373:;
    if (_215 >= 0)
    goto _jump1374;
    fail_assertion("negative array index");
    _jump1374:;
    if (_215 < _181.d2)
    goto _jump1375;
    fail_assertion("index too large");
    _jump1375:;
    int64_t _216 = 0;
    _216 *= _181.d0;
    _216 += _185;
    _216 *= _181.d1;
    _216 += _201;
    _216 *= _181.d2;
    _216 += _215;
    bool _217 = _181.data[_216];
    _a2_rgba _218;
    if (!_217)
    goto _jump1376;
    _a2_rgba _219;
    // Computing bound for p
    int64_t _220 = 490;
    _219.d0 = _220;
    if (_220 > 0) 
    goto _jump1377;
    fail_assertion("non-positive loop bound");
    _jump1377:;
    // Computing bound for q
    _219.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1378;
    fail_assertion("non-positive loop bound");
    _jump1378:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _220;
    _221 *= h.d2;
    _221 *= sizeof(rgba);
    _219.data = jpl_alloc(_221);
    int64_t _222 = 0; // q
    int64_t _223 = 0; // p
    _jump1379:; // Begin body of loop
    double _224 = 49.0;
    double _225 = 11.0;
    double _226 = 31.0;
    _a1_double _227;
    _227.d0 = 3;
    _227.data = jpl_alloc(sizeof(double) * 3);
    _227.data[0] = _224;
    _227.data[1] = _225;
    _227.data[2] = _226;
    if (_222 >= 0)
    goto _jump1380;
    fail_assertion("negative array index");
    _jump1380:;
    if (_222 < _227.d0)
    goto _jump1381;
    fail_assertion("index too large");
    _jump1381:;
    int64_t _228 = 0;
    _228 *= _227.d0;
    _228 += _222;
    double _229 = _227.data[_228];
    double _230 = 76.0;
    _a1_double _231;
    // Computing bound for r
    _231.d0 = _222;
    if (_222 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= _222;
    _232 *= sizeof(double);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // r
    _jump1383:; // Begin body of loop
    double _234 = 81.0;
    int64_t _235 = 0;
    _235 *= _231.d0;
    _235 += _233;
    _231.data[_235] = _234;
    _233++;
    if (_233 < _222)
    goto _jump1383;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump1384;
    fail_assertion("negative array index");
    _jump1384:;
    if (h.d1 < _231.d0)
    goto _jump1385;
    fail_assertion("index too large");
    _jump1385:;
    int64_t _236 = 0;
    _236 *= _231.d0;
    _236 += h.d1;
    double _237 = _231.data[_236];
    double _238;
    // Computing bound for r
    int64_t _239;
    // Computing bound for r
    if (_223 > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing bound for s
    if (h.d0 > 0) 
    goto _jump1387;
    fail_assertion("non-positive loop bound");
    _jump1387:;
    _239 = 0;
    int64_t _240 = 0; // s
    int64_t _241 = 0; // r
    _jump1388:; // Begin body of loop
    _239 += _222;
    _240++;
    if (_240 < h.d0)
    goto _jump1388;
    _240 = 0;
    _241++;
    if (_241 < _223)
    goto _jump1388;
    // End body of loop
    if (_239 > 0) 
    goto _jump1389;
    fail_assertion("non-positive loop bound");
    _jump1389:;
    // Computing bound for s
    if (h.d1 > 0) 
    goto _jump1390;
    fail_assertion("non-positive loop bound");
    _jump1390:;
    // Computing bound for t
    if (l.d1 > 0) 
    goto _jump1391;
    fail_assertion("non-positive loop bound");
    _jump1391:;
    _238 = 0;
    int64_t _242 = 0; // t
    int64_t _243 = 0; // s
    int64_t _244 = 0; // r
    _jump1392:; // Begin body of loop
    double _245;
    // Computing bound for u
    if (_244 > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    // Computing bound for v
    if (l.d1 > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing bound for w
    if (_222 > 0) 
    goto _jump1395;
    fail_assertion("non-positive loop bound");
    _jump1395:;
    _245 = 0;
    int64_t _246 = 0; // w
    int64_t _247 = 0; // v
    int64_t _248 = 0; // u
    _jump1396:; // Begin body of loop
    double _249 = 81.0;
    _245 += _249;
    _246++;
    if (_246 < _222)
    goto _jump1396;
    _246 = 0;
    _247++;
    if (_247 < l.d1)
    goto _jump1396;
    _247 = 0;
    _248++;
    if (_248 < _244)
    goto _jump1396;
    // End body of loop
    _238 += _245;
    _242++;
    if (_242 < l.d1)
    goto _jump1392;
    _242 = 0;
    _243++;
    if (_243 < h.d1)
    goto _jump1392;
    _243 = 0;
    _244++;
    if (_244 < _239)
    goto _jump1392;
    // End body of loop
    rgba _250 = { _229, _230, _237, _238 };
    int64_t _251 = 0;
    _251 *= _219.d0;
    _251 += _223;
    _251 *= _219.d1;
    _251 += _222;
    _219.data[_251] = _250;
    _222++;
    if (_222 < h.d2)
    goto _jump1379;
    _222 = 0;
    _223++;
    if (_223 < _220)
    goto _jump1379;
    // End body of loop
    _218 = _219;
    goto _jump1397;
    _jump1376:;
    bool _253 = false;
    bool _252 = _253;
    if (0 == _253)
    goto _jump1398;
    bool _254 = false;
    bool _255;
    if (!_254)
    goto _jump1399;
    bool _256 = false;
    _255 = _256;
    goto _jump1400;
    _jump1399:;
    bool _258 = true;
    bool _257 = _258;
    if (0 != _258)
    goto _jump1401;
    bool _259 = false;
    _257 = _259;
    _jump1401:;
    _255 = _257;
    _jump1400:;
    _252 = _255;
    _jump1398:;
    _a2_rgba _260;
    if (!_252)
    goto _jump1402;
    _a3__a2_rgba _261;
    // Computing bound for p
    int64_t _262;
    // Computing bound for p
    if (_0 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    // Computing bound for q
    if (_0 > 0) 
    goto _jump1404;
    fail_assertion("non-positive loop bound");
    _jump1404:;
    _262 = 0;
    int64_t _263 = 0; // q
    int64_t _264 = 0; // p
    _jump1405:; // Begin body of loop
    _262 += _263;
    _263++;
    if (_263 < _0)
    goto _jump1405;
    _263 = 0;
    _264++;
    if (_264 < _0)
    goto _jump1405;
    // End body of loop
    _261.d0 = _262;
    if (_262 > 0) 
    goto _jump1406;
    fail_assertion("non-positive loop bound");
    _jump1406:;
    // Computing bound for q
    _261.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump1407;
    fail_assertion("non-positive loop bound");
    _jump1407:;
    // Computing bound for r
    _261.d2 = l.d0;
    if (l.d0 > 0) 
    goto _jump1408;
    fail_assertion("non-positive loop bound");
    _jump1408:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= _262;
    _265 *= h.d0;
    _265 *= l.d0;
    _265 *= sizeof(_a2_rgba);
    _261.data = jpl_alloc(_265);
    int64_t _266 = 0; // r
    int64_t _267 = 0; // q
    int64_t _268 = 0; // p
    _jump1409:; // Begin body of loop
    _a2_rgba _269;
    // Computing bound for s
    _269.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1410;
    fail_assertion("non-positive loop bound");
    _jump1410:;
    // Computing bound for t
    _269.d1 = _267;
    if (_267 > 0) 
    goto _jump1411;
    fail_assertion("non-positive loop bound");
    _jump1411:;
    // Computing total size of heap memory to allocate
    int64_t _270 = 1;
    _270 *= h.d0;
    _270 *= _267;
    _270 *= sizeof(rgba);
    _269.data = jpl_alloc(_270);
    int64_t _271 = 0; // t
    int64_t _272 = 0; // s
    _jump1412:; // Begin body of loop
    int64_t _273 = 0;
    _273 *= _269.d0;
    _273 += _272;
    _273 *= _269.d1;
    _273 += _271;
    _269.data[_273] = d;
    _271++;
    if (_271 < _267)
    goto _jump1412;
    _271 = 0;
    _272++;
    if (_272 < h.d0)
    goto _jump1412;
    // End body of loop
    int64_t _274 = 0;
    _274 *= _261.d0;
    _274 += _268;
    _274 *= _261.d1;
    _274 += _267;
    _274 *= _261.d2;
    _274 += _266;
    _261.data[_274] = _269;
    _266++;
    if (_266 < l.d0)
    goto _jump1409;
    _266 = 0;
    _267++;
    if (_267 < h.d0)
    goto _jump1409;
    _267 = 0;
    _268++;
    if (_268 < _262)
    goto _jump1409;
    // End body of loop
    _a1_int64_t _275;
    _275.d0 = 1;
    _275.data = jpl_alloc(sizeof(int64_t) * 1);
    _275.data[0] = h.d0;
    if (h.d1 >= 0)
    goto _jump1413;
    fail_assertion("negative array index");
    _jump1413:;
    if (h.d1 < _275.d0)
    goto _jump1414;
    fail_assertion("index too large");
    _jump1414:;
    int64_t _276 = 0;
    _276 *= _275.d0;
    _276 += h.d1;
    int64_t _277 = _275.data[_276];
    if (_277 >= 0)
    goto _jump1415;
    fail_assertion("negative array index");
    _jump1415:;
    if (_277 < _261.d0)
    goto _jump1416;
    fail_assertion("index too large");
    _jump1416:;
    if (h.d2 >= 0)
    goto _jump1417;
    fail_assertion("negative array index");
    _jump1417:;
    if (h.d2 < _261.d1)
    goto _jump1418;
    fail_assertion("index too large");
    _jump1418:;
    if (h.d1 >= 0)
    goto _jump1419;
    fail_assertion("negative array index");
    _jump1419:;
    if (h.d1 < _261.d2)
    goto _jump1420;
    fail_assertion("index too large");
    _jump1420:;
    int64_t _278 = 0;
    _278 *= _261.d0;
    _278 += _277;
    _278 *= _261.d1;
    _278 += h.d2;
    _278 *= _261.d2;
    _278 += h.d1;
    _a2_rgba _279 = _261.data[_278];
    _260 = _279;
    goto _jump1421;
    _jump1402:;
    bool _280 = true;
    _a2_rgba _281;
    if (!_280)
    goto _jump1422;
    _a2_rgba _282;
    // Computing bound for p
    _282.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1423;
    fail_assertion("non-positive loop bound");
    _jump1423:;
    // Computing bound for q
    bool _283 = false;
    int64_t _284;
    if (!_283)
    goto _jump1424;
    int64_t _285 = 4;
    _284 = _285;
    goto _jump1425;
    _jump1424:;
    int64_t _286 = 353;
    _284 = _286;
    _jump1425:;
    _282.d1 = _284;
    if (_284 > 0) 
    goto _jump1426;
    fail_assertion("non-positive loop bound");
    _jump1426:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= h.d1;
    _287 *= _284;
    _287 *= sizeof(rgba);
    _282.data = jpl_alloc(_287);
    int64_t _288 = 0; // q
    int64_t _289 = 0; // p
    _jump1427:; // Begin body of loop
    int64_t _290 = 0;
    _290 *= _282.d0;
    _290 += _289;
    _290 *= _282.d1;
    _290 += _288;
    _282.data[_290] = d;
    _288++;
    if (_288 < _284)
    goto _jump1427;
    _288 = 0;
    _289++;
    if (_289 < h.d1)
    goto _jump1427;
    // End body of loop
    _281 = _282;
    goto _jump1428;
    _jump1422:;
    _a2_rgba _291;
    // Computing bound for p
    bool _292 = true;
    int64_t _293;
    if (!_292)
    goto _jump1429;
    _293 = l.d0;
    goto _jump1430;
    _jump1429:;
    _293 = l.d0;
    _jump1430:;
    _291.d0 = _293;
    if (_293 > 0) 
    goto _jump1431;
    fail_assertion("non-positive loop bound");
    _jump1431:;
    // Computing bound for q
    int64_t _294 = 847;
    int64_t _295 = 665;
    int64_t _296 = _294 + _295;
    _291.d1 = _296;
    if (_296 > 0) 
    goto _jump1432;
    fail_assertion("non-positive loop bound");
    _jump1432:;
    // Computing total size of heap memory to allocate
    int64_t _297 = 1;
    _297 *= _293;
    _297 *= _296;
    _297 *= sizeof(rgba);
    _291.data = jpl_alloc(_297);
    int64_t _298 = 0; // q
    int64_t _299 = 0; // p
    _jump1433:; // Begin body of loop
    int64_t _300 = 0;
    _300 *= _291.d0;
    _300 += _299;
    _300 *= _291.d1;
    _300 += _298;
    _291.data[_300] = d;
    _298++;
    if (_298 < _296)
    goto _jump1433;
    _298 = 0;
    _299++;
    if (_299 < _293)
    goto _jump1433;
    // End body of loop
    _281 = _291;
    _jump1428:;
    _260 = _281;
    _jump1421:;
    _218 = _260;
    _jump1397:;
    int64_t _301 = b(_49, _155, _218);
    _a1__a2__a3_rgba _302;
    // Computing bound for p
    _302.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= h.d1;
    _303 *= sizeof(_a2__a3_rgba);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // p
    _jump1435:; // Begin body of loop
    _a2__a3_rgba _305;
    // Computing bound for q
    _305.d0 = _0;
    if (_0 > 0) 
    goto _jump1436;
    fail_assertion("non-positive loop bound");
    _jump1436:;
    // Computing bound for r
    _305.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1437;
    fail_assertion("non-positive loop bound");
    _jump1437:;
    // Computing total size of heap memory to allocate
    int64_t _306 = 1;
    _306 *= _0;
    _306 *= h.d2;
    _306 *= sizeof(_a3_rgba);
    _305.data = jpl_alloc(_306);
    int64_t _307 = 0; // r
    int64_t _308 = 0; // q
    _jump1438:; // Begin body of loop
    _a3_rgba _309;
    // Computing bound for s
    _309.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1439;
    fail_assertion("non-positive loop bound");
    _jump1439:;
    // Computing bound for t
    _309.d1 = l.d1;
    if (l.d1 > 0) 
    goto _jump1440;
    fail_assertion("non-positive loop bound");
    _jump1440:;
    // Computing bound for u
    _309.d2 = l.d1;
    if (l.d1 > 0) 
    goto _jump1441;
    fail_assertion("non-positive loop bound");
    _jump1441:;
    // Computing total size of heap memory to allocate
    int64_t _310 = 1;
    _310 *= l.d0;
    _310 *= l.d1;
    _310 *= l.d1;
    _310 *= sizeof(rgba);
    _309.data = jpl_alloc(_310);
    int64_t _311 = 0; // u
    int64_t _312 = 0; // t
    int64_t _313 = 0; // s
    _jump1442:; // Begin body of loop
    int64_t _314 = 0;
    _314 *= _309.d0;
    _314 += _313;
    _314 *= _309.d1;
    _314 += _312;
    _314 *= _309.d2;
    _314 += _311;
    _309.data[_314] = d;
    _311++;
    if (_311 < l.d1)
    goto _jump1442;
    _311 = 0;
    _312++;
    if (_312 < l.d1)
    goto _jump1442;
    _312 = 0;
    _313++;
    if (_313 < l.d0)
    goto _jump1442;
    // End body of loop
    int64_t _315 = 0;
    _315 *= _305.d0;
    _315 += _308;
    _315 *= _305.d1;
    _315 += _307;
    _305.data[_315] = _309;
    _307++;
    if (_307 < h.d2)
    goto _jump1438;
    _307 = 0;
    _308++;
    if (_308 < _0)
    goto _jump1438;
    // End body of loop
    int64_t _316 = 0;
    _316 *= _302.d0;
    _316 += _304;
    _302.data[_316] = _305;
    _304++;
    if (_304 < h.d1)
    goto _jump1435;
    // End body of loop
    if (h.d2 >= 0)
    goto _jump1443;
    fail_assertion("negative array index");
    _jump1443:;
    if (h.d2 < _302.d0)
    goto _jump1444;
    fail_assertion("index too large");
    _jump1444:;
    int64_t _317 = 0;
    _317 *= _302.d0;
    _317 += h.d2;
    _a2__a3_rgba _318 = _302.data[_317];
    int64_t _319 = 589;
    if (_319 >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (_319 < _318.d0)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    if (l.d1 >= 0)
    goto _jump1447;
    fail_assertion("negative array index");
    _jump1447:;
    if (l.d1 < _318.d1)
    goto _jump1448;
    fail_assertion("index too large");
    _jump1448:;
    int64_t _320 = 0;
    _320 *= _318.d0;
    _320 += _319;
    _320 *= _318.d1;
    _320 += l.d1;
    _a3_rgba _321 = _318.data[_320];
    double _323 = d.g;
    double _324 = d.a;
    bool _325 = _323 < _324;
    bool _322 = _325;
    if (0 != _325)
    goto _jump1449;
    bool _326 = true;
    _322 = _326;
    _jump1449:;
    bool _327;
    if (!_322)
    goto _jump1450;
    bool _330 = true;
    bool _329 = _330;
    if (0 == _330)
    goto _jump1451;
    bool _331 = l.d1 > l.d1;
    _329 = _331;
    _jump1451:;
    bool _328 = _329;
    if (0 == _329)
    goto _jump1452;
    bool _332 = _0 == l.d0;
    _328 = _332;
    _jump1452:;
    _327 = _328;
    goto _jump1453;
    _jump1450:;
    double _333 = d.r;
    double _334 = 21.0;
    bool _335 = _333 != _334;
    _327 = _335;
    _jump1453:;
    _a1_bool _336;
    if (!_327)
    goto _jump1454;
    _a1_bool _337;
    // Computing bound for p
    _a1_bool _338;
    // Computing bound for p
    _338.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1455;
    fail_assertion("non-positive loop bound");
    _jump1455:;
    // Computing total size of heap memory to allocate
    int64_t _339 = 1;
    _339 *= h.d1;
    _339 *= sizeof(bool);
    _338.data = jpl_alloc(_339);
    int64_t _340 = 0; // p
    _jump1456:; // Begin body of loop
    bool _341 = true;
    int64_t _342 = 0;
    _342 *= _338.d0;
    _342 += _340;
    _338.data[_342] = _341;
    _340++;
    if (_340 < h.d1)
    goto _jump1456;
    // End body of loop
    if (l.d0 >= 0)
    goto _jump1457;
    fail_assertion("negative array index");
    _jump1457:;
    if (l.d0 < _338.d0)
    goto _jump1458;
    fail_assertion("index too large");
    _jump1458:;
    int64_t _343 = 0;
    _343 *= _338.d0;
    _343 += l.d0;
    bool _344 = _338.data[_343];
    int64_t _345;
    if (!_344)
    goto _jump1459;
    bool _346 = true;
    int64_t _347;
    if (!_346)
    goto _jump1460;
    bool _348 = false;
    int64_t _349;
    if (!_348)
    goto _jump1461;
    int64_t _350 = 851;
    _349 = _350;
    goto _jump1462;
    _jump1461:;
    _349 = h.d2;
    _jump1462:;
    _347 = _349;
    goto _jump1463;
    _jump1460:;
    _347 = h.d2;
    _jump1463:;
    _345 = _347;
    goto _jump1464;
    _jump1459:;
    _345 = l.d0;
    _jump1464:;
    _337.d0 = _345;
    if (_345 > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    // Computing total size of heap memory to allocate
    int64_t _351 = 1;
    _351 *= _345;
    _351 *= sizeof(bool);
    _337.data = jpl_alloc(_351);
    int64_t _352 = 0; // p
    _jump1466:; // Begin body of loop
    bool _353 = true;
    bool _354 = true;
    bool _355 = !_354;
    bool _356;
    if (!_355)
    goto _jump1467;
    bool _357 = true;
    _356 = _357;
    goto _jump1468;
    _jump1467:;
    bool _358 = false;
    _356 = _358;
    _jump1468:;
    bool _359 = _353 != _356;
    int64_t _360 = 0;
    _360 *= _337.d0;
    _360 += _352;
    _337.data[_360] = _359;
    _352++;
    if (_352 < _345)
    goto _jump1466;
    // End body of loop
    _336 = _337;
    goto _jump1469;
    _jump1454:;
    _a1_bool _361;
    // Computing bound for p
    _361.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1470;
    fail_assertion("non-positive loop bound");
    _jump1470:;
    // Computing total size of heap memory to allocate
    int64_t _362 = 1;
    _362 *= l.d1;
    _362 *= sizeof(bool);
    _361.data = jpl_alloc(_362);
    int64_t _363 = 0; // p
    _jump1471:; // Begin body of loop
    if (_0 >= 0)
    goto _jump1472;
    fail_assertion("negative array index");
    _jump1472:;
    if (_0 < a.d0)
    goto _jump1473;
    fail_assertion("index too large");
    _jump1473:;
    int64_t _364 = 0;
    _364 *= a.d0;
    _364 += _0;
    bool _365 = a.data[_364];
    int64_t _366 = 0;
    _366 *= _361.d0;
    _366 += _363;
    _361.data[_366] = _365;
    _363++;
    if (_363 < l.d1)
    goto _jump1471;
    // End body of loop
    int64_t _367 = 241;
    bool _368 = _367 != h.d0;
    _a1_bool _369;
    if (!_368)
    goto _jump1474;
    _a1_bool _370;
    // Computing bound for p
    _370.d0 = h.d2;
    if (h.d2 > 0) 
    goto _jump1475;
    fail_assertion("non-positive loop bound");
    _jump1475:;
    // Computing total size of heap memory to allocate
    int64_t _371 = 1;
    _371 *= h.d2;
    _371 *= sizeof(bool);
    _370.data = jpl_alloc(_371);
    int64_t _372 = 0; // p
    _jump1476:; // Begin body of loop
    bool _373 = false;
    int64_t _374 = 0;
    _374 *= _370.d0;
    _374 += _372;
    _370.data[_374] = _373;
    _372++;
    if (_372 < h.d2)
    goto _jump1476;
    // End body of loop
    _369 = _370;
    goto _jump1477;
    _jump1474:;
    _369 = a;
    _jump1477:;
    _a1__a1_bool _375;
    _375.d0 = 1;
    _375.data = jpl_alloc(sizeof(_a1_bool) * 1);
    _375.data[0] = a;
    int64_t _376 = h.d1 % h.d1;
    if (_376 >= 0)
    goto _jump1478;
    fail_assertion("negative array index");
    _jump1478:;
    if (_376 < _375.d0)
    goto _jump1479;
    fail_assertion("index too large");
    _jump1479:;
    int64_t _377 = 0;
    _377 *= _375.d0;
    _377 += _376;
    _a1_bool _378 = _375.data[_377];
    _a1__a1_bool _379;
    _379.d0 = 3;
    _379.data = jpl_alloc(sizeof(_a1_bool) * 3);
    _379.data[0] = _361;
    _379.data[1] = _369;
    _379.data[2] = _378;
    _a1_int64_t _380;
    _380.d0 = 2;
    _380.data = jpl_alloc(sizeof(int64_t) * 2);
    _380.data[0] = l.d1;
    _380.data[1] = l.d0;
    if (l.d1 >= 0)
    goto _jump1480;
    fail_assertion("negative array index");
    _jump1480:;
    if (l.d1 < _380.d0)
    goto _jump1481;
    fail_assertion("index too large");
    _jump1481:;
    int64_t _381 = 0;
    _381 *= _380.d0;
    _381 += l.d1;
    int64_t _382 = _380.data[_381];
    if (_382 >= 0)
    goto _jump1482;
    fail_assertion("negative array index");
    _jump1482:;
    if (_382 < _379.d0)
    goto _jump1483;
    fail_assertion("index too large");
    _jump1483:;
    int64_t _383 = 0;
    _383 *= _379.d0;
    _383 += _382;
    _a1_bool _384 = _379.data[_383];
    _336 = _384;
    _jump1469:;
    _a2_rgba _385;
    // Computing bound for p
    int64_t _386;
    // Computing bound for p
    int64_t _387 = 254;
    if (_387 > 0) 
    goto _jump1484;
    fail_assertion("non-positive loop bound");
    _jump1484:;
    // Computing bound for q
    if (_0 > 0) 
    goto _jump1485;
    fail_assertion("non-positive loop bound");
    _jump1485:;
    _386 = 0;
    int64_t _388 = 0; // q
    int64_t _389 = 0; // p
    _jump1486:; // Begin body of loop
    _386 += h.d1;
    _388++;
    if (_388 < _0)
    goto _jump1486;
    _388 = 0;
    _389++;
    if (_389 < _387)
    goto _jump1486;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump1487;
    fail_assertion("negative array index");
    _jump1487:;
    if (h.d1 < h.d0)
    goto _jump1488;
    fail_assertion("index too large");
    _jump1488:;
    if (_386 >= 0)
    goto _jump1489;
    fail_assertion("negative array index");
    _jump1489:;
    if (_386 < h.d1)
    goto _jump1490;
    fail_assertion("index too large");
    _jump1490:;
    if (l.d0 >= 0)
    goto _jump1491;
    fail_assertion("negative array index");
    _jump1491:;
    if (l.d0 < h.d2)
    goto _jump1492;
    fail_assertion("index too large");
    _jump1492:;
    int64_t _390 = 0;
    _390 *= h.d0;
    _390 += h.d1;
    _390 *= h.d1;
    _390 += _386;
    _390 *= h.d2;
    _390 += l.d0;
    int64_t _391 = h.data[_390];
    _385.d0 = _391;
    if (_391 > 0) 
    goto _jump1493;
    fail_assertion("non-positive loop bound");
    _jump1493:;
    // Computing bound for q
    _385.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1494;
    fail_assertion("non-positive loop bound");
    _jump1494:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= _391;
    _392 *= h.d2;
    _392 *= sizeof(rgba);
    _385.data = jpl_alloc(_392);
    int64_t _393 = 0; // q
    int64_t _394 = 0; // p
    _jump1495:; // Begin body of loop
    double _395 = d.b;
    double _396 = 33.0;
    double _397 = -_396;
    double _398 = 67.0;
    double _399 = 86.0;
    rgba _400 = { _395, _397, _398, _399 };
    int64_t _401 = 0;
    _401 *= _385.d0;
    _401 += _394;
    _401 *= _385.d1;
    _401 += _393;
    _385.data[_401] = _400;
    _393++;
    if (_393 < h.d2)
    goto _jump1495;
    _393 = 0;
    _394++;
    if (_394 < _391)
    goto _jump1495;
    // End body of loop
    _a2_rgba _402;
    // Computing bound for p
    int64_t _403 = 398;
    _402.d0 = _403;
    if (_403 > 0) 
    goto _jump1496;
    fail_assertion("non-positive loop bound");
    _jump1496:;
    // Computing bound for q
    if (l.d0 >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (l.d0 < h.d0)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    if (h.d0 >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (h.d0 < h.d1)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    if (h.d1 >= 0)
    goto _jump1501;
    fail_assertion("negative array index");
    _jump1501:;
    if (h.d1 < h.d2)
    goto _jump1502;
    fail_assertion("index too large");
    _jump1502:;
    int64_t _404 = 0;
    _404 *= h.d0;
    _404 += l.d0;
    _404 *= h.d1;
    _404 += h.d0;
    _404 *= h.d2;
    _404 += h.d1;
    int64_t _405 = h.data[_404];
    _402.d1 = _405;
    if (_405 > 0) 
    goto _jump1503;
    fail_assertion("non-positive loop bound");
    _jump1503:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _403;
    _406 *= _405;
    _406 *= sizeof(rgba);
    _402.data = jpl_alloc(_406);
    int64_t _407 = 0; // q
    int64_t _408 = 0; // p
    _jump1504:; // Begin body of loop
    _a1_rgba _409;
    _409.d0 = 2;
    _409.data = jpl_alloc(sizeof(rgba) * 2);
    _409.data[0] = d;
    _409.data[1] = d;
    if (l.d1 >= 0)
    goto _jump1505;
    fail_assertion("negative array index");
    _jump1505:;
    if (l.d1 < _409.d0)
    goto _jump1506;
    fail_assertion("index too large");
    _jump1506:;
    int64_t _410 = 0;
    _410 *= _409.d0;
    _410 += l.d1;
    rgba _411 = _409.data[_410];
    int64_t _412 = 0;
    _412 *= _402.d0;
    _412 += _408;
    _412 *= _402.d1;
    _412 += _407;
    _402.data[_412] = _411;
    _407++;
    if (_407 < _405)
    goto _jump1504;
    _407 = 0;
    _408++;
    if (_408 < _403)
    goto _jump1504;
    // End body of loop
    _a1__a2_rgba _413;
    _413.d0 = 2;
    _413.data = jpl_alloc(sizeof(_a2_rgba) * 2);
    _413.data[0] = _385;
    _413.data[1] = _402;
    if (h.d1 >= 0)
    goto _jump1507;
    fail_assertion("negative array index");
    _jump1507:;
    if (h.d1 < _413.d0)
    goto _jump1508;
    fail_assertion("index too large");
    _jump1508:;
    int64_t _414 = 0;
    _414 *= _413.d0;
    _414 += h.d1;
    _a2_rgba _415 = _413.data[_414];
    int64_t _416 = b(_321, _336, _415);
    if (_301 >= 0)
    goto _jump1509;
    fail_assertion("negative array index");
    _jump1509:;
    if (_301 < _18.d0)
    goto _jump1510;
    fail_assertion("index too large");
    _jump1510:;
    if (_416 >= 0)
    goto _jump1511;
    fail_assertion("negative array index");
    _jump1511:;
    if (_416 < _18.d1)
    goto _jump1512;
    fail_assertion("index too large");
    _jump1512:;
    int64_t _417 = 0;
    _417 *= _18.d0;
    _417 += _301;
    _417 *= _18.d1;
    _417 += _416;
    _a2_int64_t _418 = _18.data[_417];
    bool _419 = l.d1 < h.d1;
    bool _420 = !_419;
    bool _421 = !_420;
    _a2_bool _422;
    if (!_421)
    goto _jump1513;
    double _423 = 8.0;
    double _424 = 15.0;
    double _425 = 64.0;
    double _426 = 95.0;
    rgba _427 = { _423, _424, _425, _426 };
    double _428 = _427.r;
    if (_418.d0 >= 0)
    goto _jump1514;
    fail_assertion("negative array index");
    _jump1514:;
    if (_418.d0 < a.d0)
    goto _jump1515;
    fail_assertion("index too large");
    _jump1515:;
    int64_t _429 = 0;
    _429 *= a.d0;
    _429 += _418.d0;
    bool _430 = a.data[_429];
    double _431;
    if (!_430)
    goto _jump1516;
    double _432 = 55.0;
    _431 = _432;
    goto _jump1517;
    _jump1516:;
    double _433 = d.a;
    _431 = _433;
    _jump1517:;
    bool _434 = _428 == _431;
    _a2_bool _435;
    if (!_434)
    goto _jump1518;
    _a2_bool _436;
    // Computing bound for s
    _436.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1519;
    fail_assertion("non-positive loop bound");
    _jump1519:;
    // Computing bound for t
    _436.d1 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1520;
    fail_assertion("non-positive loop bound");
    _jump1520:;
    // Computing total size of heap memory to allocate
    int64_t _437 = 1;
    _437 *= h.d0;
    _437 *= _418.d0;
    _437 *= sizeof(bool);
    _436.data = jpl_alloc(_437);
    int64_t _438 = 0; // t
    int64_t _439 = 0; // s
    _jump1521:; // Begin body of loop
    if (h.d2 >= 0)
    goto _jump1522;
    fail_assertion("negative array index");
    _jump1522:;
    if (h.d2 < l.d0)
    goto _jump1523;
    fail_assertion("index too large");
    _jump1523:;
    if (_418.d0 >= 0)
    goto _jump1524;
    fail_assertion("negative array index");
    _jump1524:;
    if (_418.d0 < l.d1)
    goto _jump1525;
    fail_assertion("index too large");
    _jump1525:;
    int64_t _440 = 0;
    _440 *= l.d0;
    _440 += h.d2;
    _440 *= l.d1;
    _440 += _418.d0;
    void_t _441 = l.data[_440];
    bool _442 = c(_441);
    int64_t _443 = 0;
    _443 *= _436.d0;
    _443 += _439;
    _443 *= _436.d1;
    _443 += _438;
    _436.data[_443] = _442;
    _438++;
    if (_438 < _418.d0)
    goto _jump1521;
    _438 = 0;
    _439++;
    if (_439 < h.d0)
    goto _jump1521;
    // End body of loop
    _435 = _436;
    goto _jump1526;
    _jump1518:;
    _a2_bool _444;
    // Computing bound for s
    _444.d0 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing bound for t
    _444.d1 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1528;
    fail_assertion("non-positive loop bound");
    _jump1528:;
    // Computing total size of heap memory to allocate
    int64_t _445 = 1;
    _445 *= _418.d1;
    _445 *= _418.d0;
    _445 *= sizeof(bool);
    _444.data = jpl_alloc(_445);
    int64_t _446 = 0; // t
    int64_t _447 = 0; // s
    _jump1529:; // Begin body of loop
    if (_447 >= 0)
    goto _jump1530;
    fail_assertion("negative array index");
    _jump1530:;
    if (_447 < _418.d0)
    goto _jump1531;
    fail_assertion("index too large");
    _jump1531:;
    if (_418.d1 >= 0)
    goto _jump1532;
    fail_assertion("negative array index");
    _jump1532:;
    if (_418.d1 < _418.d1)
    goto _jump1533;
    fail_assertion("index too large");
    _jump1533:;
    int64_t _448 = 0;
    _448 *= _418.d0;
    _448 += _447;
    _448 *= _418.d1;
    _448 += _418.d1;
    int64_t _449 = _418.data[_448];
    bool _450 = _449 > _447;
    int64_t _451 = 0;
    _451 *= _444.d0;
    _451 += _447;
    _451 *= _444.d1;
    _451 += _446;
    _444.data[_451] = _450;
    _446++;
    if (_446 < _418.d0)
    goto _jump1529;
    _446 = 0;
    _447++;
    if (_447 < _418.d1)
    goto _jump1529;
    // End body of loop
    _435 = _444;
    _jump1526:;
    _422 = _435;
    goto _jump1534;
    _jump1513:;
    int64_t _452 = -h.d1;
    int64_t _453 = -_418.d1;
    if (_452 >= 0)
    goto _jump1535;
    fail_assertion("negative array index");
    _jump1535:;
    if (_452 < l.d0)
    goto _jump1536;
    fail_assertion("index too large");
    _jump1536:;
    if (_453 >= 0)
    goto _jump1537;
    fail_assertion("negative array index");
    _jump1537:;
    if (_453 < l.d1)
    goto _jump1538;
    fail_assertion("index too large");
    _jump1538:;
    int64_t _454 = 0;
    _454 *= l.d0;
    _454 += _452;
    _454 *= l.d1;
    _454 += _453;
    void_t _455 = l.data[_454];
    bool _456 = c(_455);
    _a2_bool _457;
    if (!_456)
    goto _jump1539;
    _a2_bool _458;
    // Computing bound for s
    int64_t _459;
    // Computing bound for s
    if (_418.d1 > 0) 
    goto _jump1540;
    fail_assertion("non-positive loop bound");
    _jump1540:;
    // Computing bound for t
    if (_418.d1 > 0) 
    goto _jump1541;
    fail_assertion("non-positive loop bound");
    _jump1541:;
    // Computing bound for u
    if (_418.d0 > 0) 
    goto _jump1542;
    fail_assertion("non-positive loop bound");
    _jump1542:;
    _459 = 0;
    int64_t _460 = 0; // u
    int64_t _461 = 0; // t
    int64_t _462 = 0; // s
    _jump1543:; // Begin body of loop
    int64_t _463 = -_460;
    _459 += _463;
    _460++;
    if (_460 < _418.d0)
    goto _jump1543;
    _460 = 0;
    _461++;
    if (_461 < _418.d1)
    goto _jump1543;
    _461 = 0;
    _462++;
    if (_462 < _418.d1)
    goto _jump1543;
    // End body of loop
    _458.d0 = _459;
    if (_459 > 0) 
    goto _jump1544;
    fail_assertion("non-positive loop bound");
    _jump1544:;
    // Computing bound for t
    _458.d1 = h.d1;
    if (h.d1 > 0) 
    goto _jump1545;
    fail_assertion("non-positive loop bound");
    _jump1545:;
    // Computing total size of heap memory to allocate
    int64_t _464 = 1;
    _464 *= _459;
    _464 *= h.d1;
    _464 *= sizeof(bool);
    _458.data = jpl_alloc(_464);
    int64_t _465 = 0; // t
    int64_t _466 = 0; // s
    _jump1546:; // Begin body of loop
    double _467 = d.b;
    double _468 = d.g;
    bool _469 = _467 <= _468;
    int64_t _470 = 0;
    _470 *= _458.d0;
    _470 += _466;
    _470 *= _458.d1;
    _470 += _465;
    _458.data[_470] = _469;
    _465++;
    if (_465 < h.d1)
    goto _jump1546;
    _465 = 0;
    _466++;
    if (_466 < _459)
    goto _jump1546;
    // End body of loop
    _457 = _458;
    goto _jump1547;
    _jump1539:;
    _a2_bool _471;
    // Computing bound for s
    int64_t _472 = 878;
    _471.d0 = _472;
    if (_472 > 0) 
    goto _jump1548;
    fail_assertion("non-positive loop bound");
    _jump1548:;
    // Computing bound for t
    _471.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    // Computing total size of heap memory to allocate
    int64_t _473 = 1;
    _473 *= _472;
    _473 *= h.d2;
    _473 *= sizeof(bool);
    _471.data = jpl_alloc(_473);
    int64_t _474 = 0; // t
    int64_t _475 = 0; // s
    _jump1550:; // Begin body of loop
    bool _476 = l.d0 < h.d2;
    bool _477 = !_476;
    int64_t _478 = 0;
    _478 *= _471.d0;
    _478 += _475;
    _478 *= _471.d1;
    _478 += _474;
    _471.data[_478] = _477;
    _474++;
    if (_474 < h.d2)
    goto _jump1550;
    _474 = 0;
    _475++;
    if (_475 < _472)
    goto _jump1550;
    // End body of loop
    _457 = _471;
    _jump1547:;
    _422 = _457;
    _jump1534:;
    int64_t _479;
    // Computing bound for s
    _a2__a3_rgba _480;
    // Computing bound for s
    int64_t _481 = -l.d1;
    _480.d0 = _481;
    if (_481 > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    // Computing bound for t
    _480.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing total size of heap memory to allocate
    int64_t _482 = 1;
    _482 *= _481;
    _482 *= l.d0;
    _482 *= sizeof(_a3_rgba);
    _480.data = jpl_alloc(_482);
    int64_t _483 = 0; // t
    int64_t _484 = 0; // s
    _jump1553:; // Begin body of loop
    _a3_rgba _485;
    // Computing bound for u
    _485.d0 = _484;
    if (_484 > 0) 
    goto _jump1554;
    fail_assertion("non-positive loop bound");
    _jump1554:;
    // Computing bound for v
    _485.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump1555;
    fail_assertion("non-positive loop bound");
    _jump1555:;
    // Computing bound for w
    _485.d2 = _483;
    if (_483 > 0) 
    goto _jump1556;
    fail_assertion("non-positive loop bound");
    _jump1556:;
    // Computing total size of heap memory to allocate
    int64_t _486 = 1;
    _486 *= _484;
    _486 *= h.d0;
    _486 *= _483;
    _486 *= sizeof(rgba);
    _485.data = jpl_alloc(_486);
    int64_t _487 = 0; // w
    int64_t _488 = 0; // v
    int64_t _489 = 0; // u
    _jump1557:; // Begin body of loop
    int64_t _490 = 0;
    _490 *= _485.d0;
    _490 += _489;
    _490 *= _485.d1;
    _490 += _488;
    _490 *= _485.d2;
    _490 += _487;
    _485.data[_490] = d;
    _487++;
    if (_487 < _483)
    goto _jump1557;
    _487 = 0;
    _488++;
    if (_488 < h.d0)
    goto _jump1557;
    _488 = 0;
    _489++;
    if (_489 < _484)
    goto _jump1557;
    // End body of loop
    int64_t _491 = 0;
    _491 *= _480.d0;
    _491 += _484;
    _491 *= _480.d1;
    _491 += _483;
    _480.data[_491] = _485;
    _483++;
    if (_483 < l.d0)
    goto _jump1553;
    _483 = 0;
    _484++;
    if (_484 < _481)
    goto _jump1553;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump1558;
    fail_assertion("negative array index");
    _jump1558:;
    if (h.d1 < _480.d0)
    goto _jump1559;
    fail_assertion("index too large");
    _jump1559:;
    if (_418.d0 >= 0)
    goto _jump1560;
    fail_assertion("negative array index");
    _jump1560:;
    if (_418.d0 < _480.d1)
    goto _jump1561;
    fail_assertion("index too large");
    _jump1561:;
    int64_t _492 = 0;
    _492 *= _480.d0;
    _492 += h.d1;
    _492 *= _480.d1;
    _492 += _418.d0;
    _a3_rgba _493 = _480.data[_492];
    _a1_bool _494;
    // Computing bound for s
    _494.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1562;
    fail_assertion("non-positive loop bound");
    _jump1562:;
    // Computing total size of heap memory to allocate
    int64_t _495 = 1;
    _495 *= l.d0;
    _495 *= sizeof(bool);
    _494.data = jpl_alloc(_495);
    int64_t _496 = 0; // s
    _jump1563:; // Begin body of loop
    _a2_bool _497;
    // Computing bound for t
    _497.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1564;
    fail_assertion("non-positive loop bound");
    _jump1564:;
    // Computing bound for u
    _497.d1 = h.d1;
    if (h.d1 > 0) 
    goto _jump1565;
    fail_assertion("non-positive loop bound");
    _jump1565:;
    // Computing total size of heap memory to allocate
    int64_t _498 = 1;
    _498 *= h.d1;
    _498 *= h.d1;
    _498 *= sizeof(bool);
    _497.data = jpl_alloc(_498);
    int64_t _499 = 0; // u
    int64_t _500 = 0; // t
    _jump1566:; // Begin body of loop
    bool _501 = false;
    int64_t _502 = 0;
    _502 *= _497.d0;
    _502 += _500;
    _502 *= _497.d1;
    _502 += _499;
    _497.data[_502] = _501;
    _499++;
    if (_499 < h.d1)
    goto _jump1566;
    _499 = 0;
    _500++;
    if (_500 < h.d1)
    goto _jump1566;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump1567;
    fail_assertion("negative array index");
    _jump1567:;
    if (h.d0 < _497.d0)
    goto _jump1568;
    fail_assertion("index too large");
    _jump1568:;
    if (l.d1 >= 0)
    goto _jump1569;
    fail_assertion("negative array index");
    _jump1569:;
    if (l.d1 < _497.d1)
    goto _jump1570;
    fail_assertion("index too large");
    _jump1570:;
    int64_t _503 = 0;
    _503 *= _497.d0;
    _503 += h.d0;
    _503 *= _497.d1;
    _503 += l.d1;
    bool _504 = _497.data[_503];
    int64_t _505 = 0;
    _505 *= _494.d0;
    _505 += _496;
    _494.data[_505] = _504;
    _496++;
    if (_496 < l.d0)
    goto _jump1563;
    // End body of loop
    _a2_rgba _506;
    // Computing bound for s
    _506.d0 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1571;
    fail_assertion("non-positive loop bound");
    _jump1571:;
    // Computing bound for t
    int64_t _507 = 528;
    _506.d1 = _507;
    if (_507 > 0) 
    goto _jump1572;
    fail_assertion("non-positive loop bound");
    _jump1572:;
    // Computing total size of heap memory to allocate
    int64_t _508 = 1;
    _508 *= _418.d0;
    _508 *= _507;
    _508 *= sizeof(rgba);
    _506.data = jpl_alloc(_508);
    int64_t _509 = 0; // t
    int64_t _510 = 0; // s
    _jump1573:; // Begin body of loop
    int64_t _511 = 0;
    _511 *= _506.d0;
    _511 += _510;
    _511 *= _506.d1;
    _511 += _509;
    _506.data[_511] = d;
    _509++;
    if (_509 < _507)
    goto _jump1573;
    _509 = 0;
    _510++;
    if (_510 < _418.d0)
    goto _jump1573;
    // End body of loop
    int64_t _512 = b(_493, _494, _506);
    if (_512 > 0) 
    goto _jump1574;
    fail_assertion("non-positive loop bound");
    _jump1574:;
    _479 = 0;
    int64_t _513 = 0; // s
    _jump1575:; // Begin body of loop
    _479 += l.d1;
    _513++;
    if (_513 < _512)
    goto _jump1575;
    // End body of loop
    if (_479 >= 0)
    goto _jump1576;
    fail_assertion("negative array index");
    _jump1576:;
    if (_479 < _422.d0)
    goto _jump1577;
    fail_assertion("index too large");
    _jump1577:;
    if (l.d1 >= 0)
    goto _jump1578;
    fail_assertion("negative array index");
    _jump1578:;
    if (l.d1 < _422.d1)
    goto _jump1579;
    fail_assertion("index too large");
    _jump1579:;
    int64_t _514 = 0;
    _514 *= _422.d0;
    _514 += _479;
    _514 *= _422.d1;
    _514 += l.d1;
    bool _515 = _422.data[_514];
    bool _516 = !_515;
    _a3_bool _517;
    // Computing bound for t
    _a3__a3_rgba _518;
    // Computing bound for t
    _518.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1580;
    fail_assertion("non-positive loop bound");
    _jump1580:;
    // Computing bound for u
    if (_418.d1 >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (_418.d1 < _418.d0)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    if (h.d2 >= 0)
    goto _jump1583;
    fail_assertion("negative array index");
    _jump1583:;
    if (h.d2 < _418.d1)
    goto _jump1584;
    fail_assertion("index too large");
    _jump1584:;
    int64_t _519 = 0;
    _519 *= _418.d0;
    _519 += _418.d1;
    _519 *= _418.d1;
    _519 += h.d2;
    int64_t _520 = _418.data[_519];
    _518.d1 = _520;
    if (_520 > 0) 
    goto _jump1585;
    fail_assertion("non-positive loop bound");
    _jump1585:;
    // Computing bound for v
    int64_t _521 = -_418.d0;
    _518.d2 = _521;
    if (_521 > 0) 
    goto _jump1586;
    fail_assertion("non-positive loop bound");
    _jump1586:;
    // Computing total size of heap memory to allocate
    int64_t _522 = 1;
    _522 *= h.d1;
    _522 *= _520;
    _522 *= _521;
    _522 *= sizeof(_a3_rgba);
    _518.data = jpl_alloc(_522);
    int64_t _523 = 0; // v
    int64_t _524 = 0; // u
    int64_t _525 = 0; // t
    _jump1587:; // Begin body of loop
    _a3_rgba _526;
    // Computing bound for w
    _526.d0 = _523;
    if (_523 > 0) 
    goto _jump1588;
    fail_assertion("non-positive loop bound");
    _jump1588:;
    // Computing bound for x
    _526.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1589;
    fail_assertion("non-positive loop bound");
    _jump1589:;
    // Computing bound for y
    _526.d2 = _525;
    if (_525 > 0) 
    goto _jump1590;
    fail_assertion("non-positive loop bound");
    _jump1590:;
    // Computing total size of heap memory to allocate
    int64_t _527 = 1;
    _527 *= _523;
    _527 *= l.d0;
    _527 *= _525;
    _527 *= sizeof(rgba);
    _526.data = jpl_alloc(_527);
    int64_t _528 = 0; // y
    int64_t _529 = 0; // x
    int64_t _530 = 0; // w
    _jump1591:; // Begin body of loop
    int64_t _531 = 0;
    _531 *= _526.d0;
    _531 += _530;
    _531 *= _526.d1;
    _531 += _529;
    _531 *= _526.d2;
    _531 += _528;
    _526.data[_531] = d;
    _528++;
    if (_528 < _525)
    goto _jump1591;
    _528 = 0;
    _529++;
    if (_529 < l.d0)
    goto _jump1591;
    _529 = 0;
    _530++;
    if (_530 < _523)
    goto _jump1591;
    // End body of loop
    int64_t _532 = 0;
    _532 *= _518.d0;
    _532 += _525;
    _532 *= _518.d1;
    _532 += _524;
    _532 *= _518.d2;
    _532 += _523;
    _518.data[_532] = _526;
    _523++;
    if (_523 < _521)
    goto _jump1587;
    _523 = 0;
    _524++;
    if (_524 < _520)
    goto _jump1587;
    _524 = 0;
    _525++;
    if (_525 < h.d1)
    goto _jump1587;
    // End body of loop
    int64_t _533 = 903;
    if (_418.d0 >= 0)
    goto _jump1592;
    fail_assertion("negative array index");
    _jump1592:;
    if (_418.d0 < _518.d0)
    goto _jump1593;
    fail_assertion("index too large");
    _jump1593:;
    if (_533 >= 0)
    goto _jump1594;
    fail_assertion("negative array index");
    _jump1594:;
    if (_533 < _518.d1)
    goto _jump1595;
    fail_assertion("index too large");
    _jump1595:;
    if (_418.d1 >= 0)
    goto _jump1596;
    fail_assertion("negative array index");
    _jump1596:;
    if (_418.d1 < _518.d2)
    goto _jump1597;
    fail_assertion("index too large");
    _jump1597:;
    int64_t _534 = 0;
    _534 *= _518.d0;
    _534 += _418.d0;
    _534 *= _518.d1;
    _534 += _533;
    _534 *= _518.d2;
    _534 += _418.d1;
    _a3_rgba _535 = _518.data[_534];
    _a2_bool _536;
    // Computing bound for t
    _536.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    // Computing bound for u
    _536.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1599;
    fail_assertion("non-positive loop bound");
    _jump1599:;
    // Computing total size of heap memory to allocate
    int64_t _537 = 1;
    _537 *= l.d1;
    _537 *= l.d0;
    _537 *= sizeof(bool);
    _536.data = jpl_alloc(_537);
    int64_t _538 = 0; // u
    int64_t _539 = 0; // t
    _jump1600:; // Begin body of loop
    bool _540 = true;
    int64_t _541 = 0;
    _541 *= _536.d0;
    _541 += _539;
    _541 *= _536.d1;
    _541 += _538;
    _536.data[_541] = _540;
    _538++;
    if (_538 < l.d0)
    goto _jump1600;
    _538 = 0;
    _539++;
    if (_539 < l.d1)
    goto _jump1600;
    // End body of loop
    if (h.d2 >= 0)
    goto _jump1601;
    fail_assertion("negative array index");
    _jump1601:;
    if (h.d2 < _536.d0)
    goto _jump1602;
    fail_assertion("index too large");
    _jump1602:;
    if (h.d2 >= 0)
    goto _jump1603;
    fail_assertion("negative array index");
    _jump1603:;
    if (h.d2 < _536.d1)
    goto _jump1604;
    fail_assertion("index too large");
    _jump1604:;
    int64_t _542 = 0;
    _542 *= _536.d0;
    _542 += h.d2;
    _542 *= _536.d1;
    _542 += h.d2;
    bool _543 = _536.data[_542];
    _a2_rgba _544;
    if (!_543)
    goto _jump1605;
    _a2_rgba _545;
    // Computing bound for t
    _545.d0 = _0;
    if (_0 > 0) 
    goto _jump1606;
    fail_assertion("non-positive loop bound");
    _jump1606:;
    // Computing bound for u
    _545.d1 = h.d1;
    if (h.d1 > 0) 
    goto _jump1607;
    fail_assertion("non-positive loop bound");
    _jump1607:;
    // Computing total size of heap memory to allocate
    int64_t _546 = 1;
    _546 *= _0;
    _546 *= h.d1;
    _546 *= sizeof(rgba);
    _545.data = jpl_alloc(_546);
    int64_t _547 = 0; // u
    int64_t _548 = 0; // t
    _jump1608:; // Begin body of loop
    int64_t _549 = 0;
    _549 *= _545.d0;
    _549 += _548;
    _549 *= _545.d1;
    _549 += _547;
    _545.data[_549] = d;
    _547++;
    if (_547 < h.d1)
    goto _jump1608;
    _547 = 0;
    _548++;
    if (_548 < _0)
    goto _jump1608;
    // End body of loop
    _544 = _545;
    goto _jump1609;
    _jump1605:;
    _a2_rgba _550;
    // Computing bound for t
    int64_t _551 = -h.d1;
    _550.d0 = _551;
    if (_551 > 0) 
    goto _jump1610;
    fail_assertion("non-positive loop bound");
    _jump1610:;
    // Computing bound for u
    _550.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1611;
    fail_assertion("non-positive loop bound");
    _jump1611:;
    // Computing total size of heap memory to allocate
    int64_t _552 = 1;
    _552 *= _551;
    _552 *= h.d2;
    _552 *= sizeof(rgba);
    _550.data = jpl_alloc(_552);
    int64_t _553 = 0; // u
    int64_t _554 = 0; // t
    _jump1612:; // Begin body of loop
    int64_t _555 = 0;
    _555 *= _550.d0;
    _555 += _554;
    _555 *= _550.d1;
    _555 += _553;
    _550.data[_555] = d;
    _553++;
    if (_553 < h.d2)
    goto _jump1612;
    _553 = 0;
    _554++;
    if (_554 < _551)
    goto _jump1612;
    // End body of loop
    _544 = _550;
    _jump1609:;
    int64_t _556 = b(_535, a, _544);
    _517.d0 = _556;
    if (_556 > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for u
    _517.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for v
    int64_t _557 = -l.d1;
    _517.d2 = _557;
    if (_557 > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    // Computing total size of heap memory to allocate
    int64_t _558 = 1;
    _558 *= _556;
    _558 *= l.d0;
    _558 *= _557;
    _558 *= sizeof(bool);
    _517.data = jpl_alloc(_558);
    int64_t _559 = 0; // v
    int64_t _560 = 0; // u
    int64_t _561 = 0; // t
    _jump1616:; // Begin body of loop
    _a3_bool _562;
    // Computing bound for w
    _562.d0 = _0;
    if (_0 > 0) 
    goto _jump1617;
    fail_assertion("non-positive loop bound");
    _jump1617:;
    // Computing bound for x
    _562.d1 = h.d1;
    if (h.d1 > 0) 
    goto _jump1618;
    fail_assertion("non-positive loop bound");
    _jump1618:;
    // Computing bound for y
    _562.d2 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    // Computing total size of heap memory to allocate
    int64_t _563 = 1;
    _563 *= _0;
    _563 *= h.d1;
    _563 *= _418.d1;
    _563 *= sizeof(bool);
    _562.data = jpl_alloc(_563);
    int64_t _564 = 0; // y
    int64_t _565 = 0; // x
    int64_t _566 = 0; // w
    _jump1620:; // Begin body of loop
    bool _567 = !_516;
    int64_t _568 = 0;
    _568 *= _562.d0;
    _568 += _566;
    _568 *= _562.d1;
    _568 += _565;
    _568 *= _562.d2;
    _568 += _564;
    _562.data[_568] = _567;
    _564++;
    if (_564 < _418.d1)
    goto _jump1620;
    _564 = 0;
    _565++;
    if (_565 < h.d1)
    goto _jump1620;
    _565 = 0;
    _566++;
    if (_566 < _0)
    goto _jump1620;
    // End body of loop
    e _569 = { _562 };
    _a3_int64_t _570;
    // Computing bound for w
    _570.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    // Computing bound for x
    _570.d1 = _0;
    if (_0 > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    // Computing bound for y
    _570.d2 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1623;
    fail_assertion("non-positive loop bound");
    _jump1623:;
    // Computing total size of heap memory to allocate
    int64_t _571 = 1;
    _571 *= h.d1;
    _571 *= _0;
    _571 *= _418.d0;
    _571 *= sizeof(int64_t);
    _570.data = jpl_alloc(_571);
    int64_t _572 = 0; // y
    int64_t _573 = 0; // x
    int64_t _574 = 0; // w
    _jump1624:; // Begin body of loop
    int64_t _575 = h.d0 * h.d1;
    int64_t _576 = 0;
    _576 *= _570.d0;
    _576 += _574;
    _576 *= _570.d1;
    _576 += _573;
    _576 *= _570.d2;
    _576 += _572;
    _570.data[_576] = _575;
    _572++;
    if (_572 < _418.d0)
    goto _jump1624;
    _572 = 0;
    _573++;
    if (_573 < _0)
    goto _jump1624;
    _573 = 0;
    _574++;
    if (_574 < h.d1)
    goto _jump1624;
    // End body of loop
    bool _577 = false;
    bool _578 = !_577;
    _a2_void_t _579;
    if (!_578)
    goto _jump1625;
    _a1__a2_void_t _580;
    // Computing bound for w
    _580.d0 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1626;
    fail_assertion("non-positive loop bound");
    _jump1626:;
    // Computing total size of heap memory to allocate
    int64_t _581 = 1;
    _581 *= _418.d1;
    _581 *= sizeof(_a2_void_t);
    _580.data = jpl_alloc(_581);
    int64_t _582 = 0; // w
    _jump1627:; // Begin body of loop
    int64_t _583 = 0;
    _583 *= _580.d0;
    _583 += _582;
    _580.data[_583] = l;
    _582++;
    if (_582 < _418.d1)
    goto _jump1627;
    // End body of loop
    if (h.d1 >= 0)
    goto _jump1628;
    fail_assertion("negative array index");
    _jump1628:;
    if (h.d1 < _580.d0)
    goto _jump1629;
    fail_assertion("index too large");
    _jump1629:;
    int64_t _584 = 0;
    _584 *= _580.d0;
    _584 += h.d1;
    _a2_void_t _585 = _580.data[_584];
    _579 = _585;
    goto _jump1630;
    _jump1625:;
    _a2_void_t _586;
    if (!_516)
    goto _jump1631;
    _586 = l;
    goto _jump1632;
    _jump1631:;
    _586 = l;
    _jump1632:;
    _579 = _586;
    _jump1630:;
    bool _587 = f(_569, _570, _579);
    int64_t _588 = 0;
    _588 *= _517.d0;
    _588 += _561;
    _588 *= _517.d1;
    _588 += _560;
    _588 *= _517.d2;
    _588 += _559;
    _517.data[_588] = _587;
    _559++;
    if (_559 < _557)
    goto _jump1616;
    _559 = 0;
    _560++;
    if (_560 < l.d0)
    goto _jump1616;
    _560 = 0;
    _561++;
    if (_561 < _556)
    goto _jump1616;
    // End body of loop
    e _589 = { _517 };
    bool _590 = true;
    bool _591;
    if (!_590)
    goto _jump1633;
    double _592;
    // Computing bound for t
    _a3_rgba _593;
    // Computing bound for t
    int64_t _594 = 367;
    _593.d0 = _594;
    if (_594 > 0) 
    goto _jump1634;
    fail_assertion("non-positive loop bound");
    _jump1634:;
    // Computing bound for u
    _593.d1 = _0;
    if (_0 > 0) 
    goto _jump1635;
    fail_assertion("non-positive loop bound");
    _jump1635:;
    // Computing bound for v
    _593.d2 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1636;
    fail_assertion("non-positive loop bound");
    _jump1636:;
    // Computing total size of heap memory to allocate
    int64_t _595 = 1;
    _595 *= _594;
    _595 *= _0;
    _595 *= _418.d0;
    _595 *= sizeof(rgba);
    _593.data = jpl_alloc(_595);
    int64_t _596 = 0; // v
    int64_t _597 = 0; // u
    int64_t _598 = 0; // t
    _jump1637:; // Begin body of loop
    int64_t _599 = 0;
    _599 *= _593.d0;
    _599 += _598;
    _599 *= _593.d1;
    _599 += _597;
    _599 *= _593.d2;
    _599 += _596;
    _593.data[_599] = d;
    _596++;
    if (_596 < _418.d0)
    goto _jump1637;
    _596 = 0;
    _597++;
    if (_597 < _0)
    goto _jump1637;
    _597 = 0;
    _598++;
    if (_598 < _594)
    goto _jump1637;
    // End body of loop
    _a1_bool _600;
    // Computing bound for t
    _600.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1638;
    fail_assertion("non-positive loop bound");
    _jump1638:;
    // Computing total size of heap memory to allocate
    int64_t _601 = 1;
    _601 *= h.d0;
    _601 *= sizeof(bool);
    _600.data = jpl_alloc(_601);
    int64_t _602 = 0; // t
    _jump1639:; // Begin body of loop
    bool _603 = false;
    int64_t _604 = 0;
    _604 *= _600.d0;
    _604 += _602;
    _600.data[_604] = _603;
    _602++;
    if (_602 < h.d0)
    goto _jump1639;
    // End body of loop
    _a2_rgba _605;
    // Computing bound for t
    int64_t _606 = 375;
    _605.d0 = _606;
    if (_606 > 0) 
    goto _jump1640;
    fail_assertion("non-positive loop bound");
    _jump1640:;
    // Computing bound for u
    _605.d1 = l.d1;
    if (l.d1 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    // Computing total size of heap memory to allocate
    int64_t _607 = 1;
    _607 *= _606;
    _607 *= l.d1;
    _607 *= sizeof(rgba);
    _605.data = jpl_alloc(_607);
    int64_t _608 = 0; // u
    int64_t _609 = 0; // t
    _jump1642:; // Begin body of loop
    int64_t _610 = 0;
    _610 *= _605.d0;
    _610 += _609;
    _610 *= _605.d1;
    _610 += _608;
    _605.data[_610] = d;
    _608++;
    if (_608 < l.d1)
    goto _jump1642;
    _608 = 0;
    _609++;
    if (_609 < _606)
    goto _jump1642;
    // End body of loop
    int64_t _611 = b(_593, _600, _605);
    if (_611 > 0) 
    goto _jump1643;
    fail_assertion("non-positive loop bound");
    _jump1643:;
    // Computing bound for u
    if (h.d0 > 0) 
    goto _jump1644;
    fail_assertion("non-positive loop bound");
    _jump1644:;
    // Computing bound for v
    int64_t _612 = -h.d2;
    int64_t _613 = _418.d1 % _612;
    if (_613 > 0) 
    goto _jump1645;
    fail_assertion("non-positive loop bound");
    _jump1645:;
    _592 = 0;
    int64_t _614 = 0; // v
    int64_t _615 = 0; // u
    int64_t _616 = 0; // t
    _jump1646:; // Begin body of loop
    double _617;
    // Computing bound for w
    if (l.d0 > 0) 
    goto _jump1647;
    fail_assertion("non-positive loop bound");
    _jump1647:;
    // Computing bound for x
    if (l.d1 > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    // Computing bound for y
    if (l.d0 > 0) 
    goto _jump1649;
    fail_assertion("non-positive loop bound");
    _jump1649:;
    _617 = 0;
    int64_t _618 = 0; // y
    int64_t _619 = 0; // x
    int64_t _620 = 0; // w
    _jump1650:; // Begin body of loop
    double _621 = 52.0;
    _617 += _621;
    _618++;
    if (_618 < l.d0)
    goto _jump1650;
    _618 = 0;
    _619++;
    if (_619 < l.d1)
    goto _jump1650;
    _619 = 0;
    _620++;
    if (_620 < l.d0)
    goto _jump1650;
    // End body of loop
    double _622 = -_617;
    _592 += _622;
    _614++;
    if (_614 < _613)
    goto _jump1646;
    _614 = 0;
    _615++;
    if (_615 < h.d0)
    goto _jump1646;
    _615 = 0;
    _616++;
    if (_616 < _611)
    goto _jump1646;
    // End body of loop
    bool _623 = _0 == h.d0;
    bool _624 = true;
    bool _625 = _623 != _624;
    double _626;
    if (!_625)
    goto _jump1651;
    double _627;
    if (!_516)
    goto _jump1652;
    double _628 = 33.0;
    _627 = _628;
    goto _jump1653;
    _jump1652:;
    double _629;
    // Computing bound for t
    if (_418.d0 > 0) 
    goto _jump1654;
    fail_assertion("non-positive loop bound");
    _jump1654:;
    _629 = 0;
    int64_t _630 = 0; // t
    _jump1655:; // Begin body of loop
    double _631 = 51.0;
    _629 += _631;
    _630++;
    if (_630 < _418.d0)
    goto _jump1655;
    // End body of loop
    _627 = _629;
    _jump1653:;
    _626 = _627;
    goto _jump1656;
    _jump1651:;
    double _632 = 29.0;
    double _633;
    // Computing bound for t
    if (_418.d1 > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    // Computing bound for u
    if (h.d2 > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    _633 = 0;
    int64_t _634 = 0; // u
    int64_t _635 = 0; // t
    _jump1659:; // Begin body of loop
    double _636 = 25.0;
    _633 += _636;
    _634++;
    if (_634 < h.d2)
    goto _jump1659;
    _634 = 0;
    _635++;
    if (_635 < _418.d1)
    goto _jump1659;
    // End body of loop
    double _637 = _632 + _633;
    _626 = _637;
    _jump1656:;
    bool _638 = _592 < _626;
    _591 = _638;
    goto _jump1660;
    _jump1633:;
    int64_t _639;
    // Computing bound for t
    if (l.d1 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing bound for u
    if (l.d0 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    // Computing bound for v
    int64_t _640 = -h.d1;
    if (_640 > 0) 
    goto _jump1663;
    fail_assertion("non-positive loop bound");
    _jump1663:;
    _639 = 0;
    int64_t _641 = 0; // v
    int64_t _642 = 0; // u
    int64_t _643 = 0; // t
    _jump1664:; // Begin body of loop
    _639 += _643;
    _641++;
    if (_641 < _640)
    goto _jump1664;
    _641 = 0;
    _642++;
    if (_642 < l.d0)
    goto _jump1664;
    _642 = 0;
    _643++;
    if (_643 < l.d1)
    goto _jump1664;
    // End body of loop
    int64_t _644 = -_639;
    if (_644 >= 0)
    goto _jump1665;
    fail_assertion("negative array index");
    _jump1665:;
    if (_644 < a.d0)
    goto _jump1666;
    fail_assertion("index too large");
    _jump1666:;
    int64_t _645 = 0;
    _645 *= a.d0;
    _645 += _644;
    bool _646 = a.data[_645];
    _591 = _646;
    _jump1660:;
    _a3_int64_t _647;
    if (!_591)
    goto _jump1667;
    _a3_int64_t _648;
    // Computing bound for t
    _648.d0 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1668;
    fail_assertion("non-positive loop bound");
    _jump1668:;
    // Computing bound for u
    _648.d1 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1669;
    fail_assertion("non-positive loop bound");
    _jump1669:;
    // Computing bound for v
    _648.d2 = l.d1;
    if (l.d1 > 0) 
    goto _jump1670;
    fail_assertion("non-positive loop bound");
    _jump1670:;
    // Computing total size of heap memory to allocate
    int64_t _649 = 1;
    _649 *= _418.d0;
    _649 *= _418.d1;
    _649 *= l.d1;
    _649 *= sizeof(int64_t);
    _648.data = jpl_alloc(_649);
    int64_t _650 = 0; // v
    int64_t _651 = 0; // u
    int64_t _652 = 0; // t
    _jump1671:; // Begin body of loop
    int64_t _653 = 0;
    _653 *= _648.d0;
    _653 += _652;
    _653 *= _648.d1;
    _653 += _651;
    _653 *= _648.d2;
    _653 += _650;
    _648.data[_653] = _650;
    _650++;
    if (_650 < l.d1)
    goto _jump1671;
    _650 = 0;
    _651++;
    if (_651 < _418.d1)
    goto _jump1671;
    _651 = 0;
    _652++;
    if (_652 < _418.d0)
    goto _jump1671;
    // End body of loop
    _647 = _648;
    goto _jump1672;
    _jump1667:;
    _647 = h;
    _jump1672:;
    bool _654 = true;
    bool _655;
    if (!_654)
    goto _jump1673;
    int64_t _656;
    // Computing bound for t
    if (l.d0 > 0) 
    goto _jump1674;
    fail_assertion("non-positive loop bound");
    _jump1674:;
    _656 = 0;
    int64_t _657 = 0; // t
    _jump1675:; // Begin body of loop
    int64_t _658;
    // Computing bound for u
    int64_t _659 = 814;
    if (_659 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing bound for v
    if (_418.d1 > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    // Computing bound for w
    if (l.d1 > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    _658 = 0;
    int64_t _660 = 0; // w
    int64_t _661 = 0; // v
    int64_t _662 = 0; // u
    _jump1679:; // Begin body of loop
    _658 += _0;
    _660++;
    if (_660 < l.d1)
    goto _jump1679;
    _660 = 0;
    _661++;
    if (_661 < _418.d1)
    goto _jump1679;
    _661 = 0;
    _662++;
    if (_662 < _659)
    goto _jump1679;
    // End body of loop
    _656 += _658;
    _657++;
    if (_657 < l.d0)
    goto _jump1675;
    // End body of loop
    int64_t _663 = -_656;
    bool _664 = _418.d0 < _663;
    _655 = _664;
    goto _jump1680;
    _jump1673:;
    bool _665 = h.d0 > h.d0;
    e _666;
    if (!_665)
    goto _jump1681;
    _666 = g;
    goto _jump1682;
    _jump1681:;
    _666 = g;
    _jump1682:;
    _a3_bool _667 = _666.a;
    int64_t _668;
    // Computing bound for t
    if (_0 > 0) 
    goto _jump1683;
    fail_assertion("non-positive loop bound");
    _jump1683:;
    // Computing bound for u
    if (h.d2 > 0) 
    goto _jump1684;
    fail_assertion("non-positive loop bound");
    _jump1684:;
    _668 = 0;
    int64_t _669 = 0; // u
    int64_t _670 = 0; // t
    _jump1685:; // Begin body of loop
    int64_t _671;
    if (!_516)
    goto _jump1686;
    _671 = _418.d1;
    goto _jump1687;
    _jump1686:;
    _671 = l.d0;
    _jump1687:;
    _668 += _671;
    _669++;
    if (_669 < h.d2)
    goto _jump1685;
    _669 = 0;
    _670++;
    if (_670 < _0)
    goto _jump1685;
    // End body of loop
    int64_t _672 = -l.d1;
    int64_t _673 = _668 + _672;
    _a1_int64_t _674;
    // Computing bound for t
    _674.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing total size of heap memory to allocate
    int64_t _675 = 1;
    _675 *= h.d0;
    _675 *= sizeof(int64_t);
    _674.data = jpl_alloc(_675);
    int64_t _676 = 0; // t
    _jump1689:; // Begin body of loop
    int64_t _677;
    // Computing bound for u
    int64_t _678 = 362;
    if (_678 > 0) 
    goto _jump1690;
    fail_assertion("non-positive loop bound");
    _jump1690:;
    // Computing bound for v
    if (l.d0 > 0) 
    goto _jump1691;
    fail_assertion("non-positive loop bound");
    _jump1691:;
    _677 = 0;
    int64_t _679 = 0; // v
    int64_t _680 = 0; // u
    _jump1692:; // Begin body of loop
    _677 += _680;
    _679++;
    if (_679 < l.d0)
    goto _jump1692;
    _679 = 0;
    _680++;
    if (_680 < _678)
    goto _jump1692;
    // End body of loop
    int64_t _681 = 0;
    _681 *= _674.d0;
    _681 += _676;
    _674.data[_681] = _677;
    _676++;
    if (_676 < h.d0)
    goto _jump1689;
    // End body of loop
    int64_t _682 = l.d0 % h.d0;
    int64_t _683 = 457;
    int64_t _684 = _682 / _683;
    if (_684 >= 0)
    goto _jump1693;
    fail_assertion("negative array index");
    _jump1693:;
    if (_684 < _674.d0)
    goto _jump1694;
    fail_assertion("index too large");
    _jump1694:;
    int64_t _685 = 0;
    _685 *= _674.d0;
    _685 += _684;
    int64_t _686 = _674.data[_685];
    if (l.d1 >= 0)
    goto _jump1695;
    fail_assertion("negative array index");
    _jump1695:;
    if (l.d1 < _667.d0)
    goto _jump1696;
    fail_assertion("index too large");
    _jump1696:;
    if (_673 >= 0)
    goto _jump1697;
    fail_assertion("negative array index");
    _jump1697:;
    if (_673 < _667.d1)
    goto _jump1698;
    fail_assertion("index too large");
    _jump1698:;
    if (_686 >= 0)
    goto _jump1699;
    fail_assertion("negative array index");
    _jump1699:;
    if (_686 < _667.d2)
    goto _jump1700;
    fail_assertion("index too large");
    _jump1700:;
    int64_t _687 = 0;
    _687 *= _667.d0;
    _687 += l.d1;
    _687 *= _667.d1;
    _687 += _673;
    _687 *= _667.d2;
    _687 += _686;
    bool _688 = _667.data[_687];
    _655 = _688;
    _jump1680:;
    _a2_void_t _689;
    if (!_655)
    goto _jump1701;
    _a2_void_t _690;
    // Computing bound for t
    _690.d0 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1702;
    fail_assertion("non-positive loop bound");
    _jump1702:;
    // Computing bound for u
    _690.d1 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1703;
    fail_assertion("non-positive loop bound");
    _jump1703:;
    // Computing total size of heap memory to allocate
    int64_t _691 = 1;
    _691 *= _418.d0;
    _691 *= _418.d0;
    _691 *= sizeof(void_t);
    _690.data = jpl_alloc(_691);
    int64_t _692 = 0; // u
    int64_t _693 = 0; // t
    _jump1704:; // Begin body of loop
    _a1__a2_void_t _694;
    _694.d0 = 1;
    _694.data = jpl_alloc(sizeof(_a2_void_t) * 1);
    _694.data[0] = l;
    int64_t _695 = -_693;
    int64_t _696 = h.d0 * _695;
    if (_696 >= 0)
    goto _jump1705;
    fail_assertion("negative array index");
    _jump1705:;
    if (_696 < _694.d0)
    goto _jump1706;
    fail_assertion("index too large");
    _jump1706:;
    int64_t _697 = 0;
    _697 *= _694.d0;
    _697 += _696;
    _a2_void_t _698 = _694.data[_697];
    bool _699 = false;
    bool _700 = !_699;
    int64_t _701;
    if (!_700)
    goto _jump1707;
    int64_t _702 = 347;
    if (_702 >= 0)
    goto _jump1708;
    fail_assertion("negative array index");
    _jump1708:;
    if (_702 < _418.d0)
    goto _jump1709;
    fail_assertion("index too large");
    _jump1709:;
    if (_692 >= 0)
    goto _jump1710;
    fail_assertion("negative array index");
    _jump1710:;
    if (_692 < _418.d1)
    goto _jump1711;
    fail_assertion("index too large");
    _jump1711:;
    int64_t _703 = 0;
    _703 *= _418.d0;
    _703 += _702;
    _703 *= _418.d1;
    _703 += _692;
    int64_t _704 = _418.data[_703];
    _701 = _704;
    goto _jump1712;
    _jump1707:;
    _701 = h.d1;
    _jump1712:;
    int64_t _705 = 579;
    _a1_int64_t _706;
    // Computing bound for v
    _706.d0 = l.d0;
    if (l.d0 > 0) 
    goto _jump1713;
    fail_assertion("non-positive loop bound");
    _jump1713:;
    // Computing total size of heap memory to allocate
    int64_t _707 = 1;
    _707 *= l.d0;
    _707 *= sizeof(int64_t);
    _706.data = jpl_alloc(_707);
    int64_t _708 = 0; // v
    _jump1714:; // Begin body of loop
    int64_t _709 = 0;
    _709 *= _706.d0;
    _709 += _708;
    _706.data[_709] = h.d2;
    _708++;
    if (_708 < l.d0)
    goto _jump1714;
    // End body of loop
    if (l.d1 >= 0)
    goto _jump1715;
    fail_assertion("negative array index");
    _jump1715:;
    if (l.d1 < _706.d0)
    goto _jump1716;
    fail_assertion("index too large");
    _jump1716:;
    int64_t _710 = 0;
    _710 *= _706.d0;
    _710 += l.d1;
    int64_t _711 = _706.data[_710];
    if (_701 >= 0)
    goto _jump1717;
    fail_assertion("negative array index");
    _jump1717:;
    if (_701 < h.d0)
    goto _jump1718;
    fail_assertion("index too large");
    _jump1718:;
    if (_705 >= 0)
    goto _jump1719;
    fail_assertion("negative array index");
    _jump1719:;
    if (_705 < h.d1)
    goto _jump1720;
    fail_assertion("index too large");
    _jump1720:;
    if (_711 >= 0)
    goto _jump1721;
    fail_assertion("negative array index");
    _jump1721:;
    if (_711 < h.d2)
    goto _jump1722;
    fail_assertion("index too large");
    _jump1722:;
    int64_t _712 = 0;
    _712 *= h.d0;
    _712 += _701;
    _712 *= h.d1;
    _712 += _705;
    _712 *= h.d2;
    _712 += _711;
    int64_t _713 = h.data[_712];
    if (_713 >= 0)
    goto _jump1723;
    fail_assertion("negative array index");
    _jump1723:;
    if (_713 < _698.d0)
    goto _jump1724;
    fail_assertion("index too large");
    _jump1724:;
    if (_693 >= 0)
    goto _jump1725;
    fail_assertion("negative array index");
    _jump1725:;
    if (_693 < _698.d1)
    goto _jump1726;
    fail_assertion("index too large");
    _jump1726:;
    int64_t _714 = 0;
    _714 *= _698.d0;
    _714 += _713;
    _714 *= _698.d1;
    _714 += _693;
    void_t _715 = _698.data[_714];
    int64_t _716 = 0;
    _716 *= _690.d0;
    _716 += _693;
    _716 *= _690.d1;
    _716 += _692;
    _690.data[_716] = _715;
    _692++;
    if (_692 < _418.d0)
    goto _jump1704;
    _692 = 0;
    _693++;
    if (_693 < _418.d0)
    goto _jump1704;
    // End body of loop
    _689 = _690;
    goto _jump1727;
    _jump1701:;
    bool _717 = !_516;
    _a1__a2_void_t _718;
    if (!_717)
    goto _jump1728;
    _a1__a2_void_t _719;
    _719.d0 = 3;
    _719.data = jpl_alloc(sizeof(_a2_void_t) * 3);
    _719.data[0] = l;
    _719.data[1] = l;
    _719.data[2] = l;
    _718 = _719;
    goto _jump1729;
    _jump1728:;
    _a2_bool _720;
    // Computing bound for t
    _720.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1730;
    fail_assertion("non-positive loop bound");
    _jump1730:;
    // Computing bound for u
    _720.d1 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    // Computing total size of heap memory to allocate
    int64_t _721 = 1;
    _721 *= l.d1;
    _721 *= _418.d1;
    _721 *= sizeof(bool);
    _720.data = jpl_alloc(_721);
    int64_t _722 = 0; // u
    int64_t _723 = 0; // t
    _jump1732:; // Begin body of loop
    int64_t _724 = 0;
    _724 *= _720.d0;
    _724 += _723;
    _724 *= _720.d1;
    _724 += _722;
    _720.data[_724] = _516;
    _722++;
    if (_722 < _418.d1)
    goto _jump1732;
    _722 = 0;
    _723++;
    if (_723 < l.d1)
    goto _jump1732;
    // End body of loop
    if (h.d0 >= 0)
    goto _jump1733;
    fail_assertion("negative array index");
    _jump1733:;
    if (h.d0 < _720.d0)
    goto _jump1734;
    fail_assertion("index too large");
    _jump1734:;
    if (_418.d1 >= 0)
    goto _jump1735;
    fail_assertion("negative array index");
    _jump1735:;
    if (_418.d1 < _720.d1)
    goto _jump1736;
    fail_assertion("index too large");
    _jump1736:;
    int64_t _725 = 0;
    _725 *= _720.d0;
    _725 += h.d0;
    _725 *= _720.d1;
    _725 += _418.d1;
    bool _726 = _720.data[_725];
    _a1__a2_void_t _727;
    if (!_726)
    goto _jump1737;
    _a1__a2_void_t _728;
    _728.d0 = 2;
    _728.data = jpl_alloc(sizeof(_a2_void_t) * 2);
    _728.data[0] = l;
    _728.data[1] = l;
    _727 = _728;
    goto _jump1738;
    _jump1737:;
    bool _729 = _0 >= h.d0;
    _a1__a2_void_t _730;
    if (!_729)
    goto _jump1739;
    _a1__a2_void_t _731;
    // Computing bound for t
    _731.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing total size of heap memory to allocate
    int64_t _732 = 1;
    _732 *= h.d0;
    _732 *= sizeof(_a2_void_t);
    _731.data = jpl_alloc(_732);
    int64_t _733 = 0; // t
    _jump1741:; // Begin body of loop
    int64_t _734 = 0;
    _734 *= _731.d0;
    _734 += _733;
    _731.data[_734] = l;
    _733++;
    if (_733 < h.d0)
    goto _jump1741;
    // End body of loop
    _730 = _731;
    goto _jump1742;
    _jump1739:;
    _a1__a2_void_t _735;
    _735.d0 = 3;
    _735.data = jpl_alloc(sizeof(_a2_void_t) * 3);
    _735.data[0] = l;
    _735.data[1] = l;
    _735.data[2] = l;
    _730 = _735;
    _jump1742:;
    _727 = _730;
    _jump1738:;
    _718 = _727;
    _jump1729:;
    _a2__a2_int64_t _736;
    // Computing bound for t
    _736.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1743;
    fail_assertion("non-positive loop bound");
    _jump1743:;
    // Computing bound for u
    _736.d1 = _418.d0;
    if (_418.d0 > 0) 
    goto _jump1744;
    fail_assertion("non-positive loop bound");
    _jump1744:;
    // Computing total size of heap memory to allocate
    int64_t _737 = 1;
    _737 *= h.d1;
    _737 *= _418.d0;
    _737 *= sizeof(_a2_int64_t);
    _736.data = jpl_alloc(_737);
    int64_t _738 = 0; // u
    int64_t _739 = 0; // t
    _jump1745:; // Begin body of loop
    int64_t _740 = 0;
    _740 *= _736.d0;
    _740 += _739;
    _740 *= _736.d1;
    _740 += _738;
    _736.data[_740] = _418;
    _738++;
    if (_738 < _418.d0)
    goto _jump1745;
    _738 = 0;
    _739++;
    if (_739 < h.d1)
    goto _jump1745;
    // End body of loop
    int64_t _741;
    if (!_516)
    goto _jump1746;
    _741 = _418.d1;
    goto _jump1747;
    _jump1746:;
    _741 = _418.d1;
    _jump1747:;
    if (_741 >= 0)
    goto _jump1748;
    fail_assertion("negative array index");
    _jump1748:;
    if (_741 < _736.d0)
    goto _jump1749;
    fail_assertion("index too large");
    _jump1749:;
    if (_0 >= 0)
    goto _jump1750;
    fail_assertion("negative array index");
    _jump1750:;
    if (_0 < _736.d1)
    goto _jump1751;
    fail_assertion("index too large");
    _jump1751:;
    int64_t _742 = 0;
    _742 *= _736.d0;
    _742 += _741;
    _742 *= _736.d1;
    _742 += _0;
    _a2_int64_t _743 = _736.data[_742];
    bool _744 = true;
    int64_t _745;
    if (!_744)
    goto _jump1752;
    _745 = l.d1;
    goto _jump1753;
    _jump1752:;
    _745 = _418.d0;
    _jump1753:;
    int64_t _746 = -_745;
    if (_418.d0 >= 0)
    goto _jump1754;
    fail_assertion("negative array index");
    _jump1754:;
    if (_418.d0 < _743.d0)
    goto _jump1755;
    fail_assertion("index too large");
    _jump1755:;
    if (_746 >= 0)
    goto _jump1756;
    fail_assertion("negative array index");
    _jump1756:;
    if (_746 < _743.d1)
    goto _jump1757;
    fail_assertion("index too large");
    _jump1757:;
    int64_t _747 = 0;
    _747 *= _743.d0;
    _747 += _418.d0;
    _747 *= _743.d1;
    _747 += _746;
    int64_t _748 = _743.data[_747];
    if (_748 >= 0)
    goto _jump1758;
    fail_assertion("negative array index");
    _jump1758:;
    if (_748 < _718.d0)
    goto _jump1759;
    fail_assertion("index too large");
    _jump1759:;
    int64_t _749 = 0;
    _749 *= _718.d0;
    _749 += _748;
    _a2_void_t _750 = _718.data[_749];
    _689 = _750;
    _jump1727:;
    bool _751 = f(_589, _647, _689);
    return _751;
    _a1__a2_void_t _752;
    _752.d0 = 3;
    _752.data = jpl_alloc(sizeof(_a2_void_t) * 3);
    _752.data[0] = l;
    _752.data[1] = l;
    _752.data[2] = l;
    int64_t _753 = 864;
    int64_t _754 = h.d2 * _753;
    if (_754 >= 0)
    goto _jump1760;
    fail_assertion("negative array index");
    _jump1760:;
    if (_754 < _752.d0)
    goto _jump1761;
    fail_assertion("index too large");
    _jump1761:;
    int64_t _755 = 0;
    _755 *= _752.d0;
    _755 += _754;
    _a2_void_t _756 = _752.data[_755];
    int64_t _757 = 336;
    if (_757 >= 0)
    goto _jump1762;
    fail_assertion("negative array index");
    _jump1762:;
    if (_757 < _756.d0)
    goto _jump1763;
    fail_assertion("index too large");
    _jump1763:;
    if (l.d1 >= 0)
    goto _jump1764;
    fail_assertion("negative array index");
    _jump1764:;
    if (l.d1 < _756.d1)
    goto _jump1765;
    fail_assertion("index too large");
    _jump1765:;
    int64_t _758 = 0;
    _758 *= _756.d0;
    _758 += _757;
    _758 *= _756.d1;
    _758 += l.d1;
    void_t _759 = _756.data[_758];
    bool _760 = c(_759);
    double _761;
    if (!_760)
    goto _jump1766;
    double _762 = 30.0;
    double _763;
    // Computing bound for t
    int64_t _764 = -l.d0;
    if (_764 > 0) 
    goto _jump1767;
    fail_assertion("non-positive loop bound");
    _jump1767:;
    // Computing bound for u
    int64_t _765 = -l.d1;
    if (_765 > 0) 
    goto _jump1768;
    fail_assertion("non-positive loop bound");
    _jump1768:;
    _763 = 0;
    int64_t _766 = 0; // u
    int64_t _767 = 0; // t
    _jump1769:; // Begin body of loop
    double _768 = 62.0;
    double _769 = 47.0;
    double _770 = _768 - _769;
    _763 += _770;
    _766++;
    if (_766 < _765)
    goto _jump1769;
    _766 = 0;
    _767++;
    if (_767 < _764)
    goto _jump1769;
    // End body of loop
    double _771;
    if (!_516)
    goto _jump1770;
    double _772 = 23.0;
    _771 = _772;
    goto _jump1771;
    _jump1770:;
    double _773 = 83.0;
    _771 = _773;
    _jump1771:;
    double _774 = -_771;
    double _775 = 68.0;
    rgba _776 = { _762, _763, _774, _775 };
    double _777 = _776.g;
    _761 = _777;
    goto _jump1772;
    _jump1766:;
    double _778;
    // Computing bound for t
    if (h.d1 > 0) 
    goto _jump1773;
    fail_assertion("non-positive loop bound");
    _jump1773:;
    // Computing bound for u
    int64_t _779;
    // Computing bound for t
    if (h.d2 > 0) 
    goto _jump1774;
    fail_assertion("non-positive loop bound");
    _jump1774:;
    // Computing bound for u
    if (l.d1 > 0) 
    goto _jump1775;
    fail_assertion("non-positive loop bound");
    _jump1775:;
    _779 = 0;
    int64_t _780 = 0; // u
    int64_t _781 = 0; // t
    _jump1776:; // Begin body of loop
    _779 += _418.d0;
    _780++;
    if (_780 < l.d1)
    goto _jump1776;
    _780 = 0;
    _781++;
    if (_781 < h.d2)
    goto _jump1776;
    // End body of loop
    int64_t _782 = -_779;
    int64_t _783 = l.d1 % _782;
    if (_783 > 0) 
    goto _jump1777;
    fail_assertion("non-positive loop bound");
    _jump1777:;
    _778 = 0;
    int64_t _784 = 0; // u
    int64_t _785 = 0; // t
    _jump1778:; // Begin body of loop
    double _786 = d.a;
    _778 += _786;
    _784++;
    if (_784 < _783)
    goto _jump1778;
    _784 = 0;
    _785++;
    if (_785 < h.d1)
    goto _jump1778;
    // End body of loop
    _761 = _778;
    _jump1772:;
    double _787 = -_761;
    double _788;
    // Computing bound for t
    if (l.d0 > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    // Computing bound for u
    int64_t _789 = -l.d1;
    if (_789 > 0) 
    goto _jump1780;
    fail_assertion("non-positive loop bound");
    _jump1780:;
    _788 = 0;
    int64_t _790 = 0; // u
    int64_t _791 = 0; // t
    _jump1781:; // Begin body of loop
    double _792 = 20.0;
    _788 += _792;
    _790++;
    if (_790 < _789)
    goto _jump1781;
    _790 = 0;
    _791++;
    if (_791 < l.d0)
    goto _jump1781;
    // End body of loop
    bool _793 = _787 != _788;
    return _793;
    _a1__a2_bool _794;
    // Computing bound for t
    _794.d0 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1782;
    fail_assertion("non-positive loop bound");
    _jump1782:;
    // Computing total size of heap memory to allocate
    int64_t _795 = 1;
    _795 *= _418.d1;
    _795 *= sizeof(_a2_bool);
    _794.data = jpl_alloc(_795);
    int64_t _796 = 0; // t
    _jump1783:; // Begin body of loop
    _a2_bool _797;
    // Computing bound for u
    _797.d0 = h.d1;
    if (h.d1 > 0) 
    goto _jump1784;
    fail_assertion("non-positive loop bound");
    _jump1784:;
    // Computing bound for v
    int64_t _798 = _796 % _0;
    int64_t _799 = -_798;
    int64_t _800 = h.d1 * _418.d1;
    int64_t _801 = _799 * _800;
    _797.d1 = _801;
    if (_801 > 0) 
    goto _jump1785;
    fail_assertion("non-positive loop bound");
    _jump1785:;
    // Computing total size of heap memory to allocate
    int64_t _802 = 1;
    _802 *= h.d1;
    _802 *= _801;
    _802 *= sizeof(bool);
    _797.data = jpl_alloc(_802);
    int64_t _803 = 0; // v
    int64_t _804 = 0; // u
    _jump1786:; // Begin body of loop
    _a2_e _805;
    // Computing bound for w
    _805.d0 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1787;
    fail_assertion("non-positive loop bound");
    _jump1787:;
    // Computing bound for x
    _805.d1 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1788;
    fail_assertion("non-positive loop bound");
    _jump1788:;
    // Computing total size of heap memory to allocate
    int64_t _806 = 1;
    _806 *= _418.d1;
    _806 *= _418.d1;
    _806 *= sizeof(e);
    _805.data = jpl_alloc(_806);
    int64_t _807 = 0; // x
    int64_t _808 = 0; // w
    _jump1789:; // Begin body of loop
    int64_t _809 = 0;
    _809 *= _805.d0;
    _809 += _808;
    _809 *= _805.d1;
    _809 += _807;
    _805.data[_809] = g;
    _807++;
    if (_807 < _418.d1)
    goto _jump1789;
    _807 = 0;
    _808++;
    if (_808 < _418.d1)
    goto _jump1789;
    // End body of loop
    int64_t _810 = _0 - l.d1;
    if (_418.d1 >= 0)
    goto _jump1790;
    fail_assertion("negative array index");
    _jump1790:;
    if (_418.d1 < _805.d0)
    goto _jump1791;
    fail_assertion("index too large");
    _jump1791:;
    if (_810 >= 0)
    goto _jump1792;
    fail_assertion("negative array index");
    _jump1792:;
    if (_810 < _805.d1)
    goto _jump1793;
    fail_assertion("index too large");
    _jump1793:;
    int64_t _811 = 0;
    _811 *= _805.d0;
    _811 += _418.d1;
    _811 *= _805.d1;
    _811 += _810;
    e _812 = _805.data[_811];
    bool _813 = true;
    _a2_void_t _814;
    if (!_813)
    goto _jump1794;
    _814 = l;
    goto _jump1795;
    _jump1794:;
    bool _815 = true;
    _a2_void_t _816;
    if (!_815)
    goto _jump1796;
    _816 = l;
    goto _jump1797;
    _jump1796:;
    _816 = l;
    _jump1797:;
    _814 = _816;
    _jump1795:;
    bool _817 = f(_812, h, _814);
    int64_t _818 = 0;
    _818 *= _797.d0;
    _818 += _804;
    _818 *= _797.d1;
    _818 += _803;
    _797.data[_818] = _817;
    _803++;
    if (_803 < _801)
    goto _jump1786;
    _803 = 0;
    _804++;
    if (_804 < h.d1)
    goto _jump1786;
    // End body of loop
    int64_t _819 = 0;
    _819 *= _794.d0;
    _819 += _796;
    _794.data[_819] = _797;
    _796++;
    if (_796 < _418.d1)
    goto _jump1783;
    // End body of loop
    if (_418.d0 >= 0)
    goto _jump1798;
    fail_assertion("negative array index");
    _jump1798:;
    if (_418.d0 < _794.d0)
    goto _jump1799;
    fail_assertion("index too large");
    _jump1799:;
    int64_t _820 = 0;
    _820 *= _794.d0;
    _820 += _418.d0;
    _a2_bool _821 = _794.data[_820];
    if (l.d1 >= 0)
    goto _jump1800;
    fail_assertion("negative array index");
    _jump1800:;
    if (l.d1 < _821.d0)
    goto _jump1801;
    fail_assertion("index too large");
    _jump1801:;
    if (h.d2 >= 0)
    goto _jump1802;
    fail_assertion("negative array index");
    _jump1802:;
    if (h.d2 < _821.d1)
    goto _jump1803;
    fail_assertion("index too large");
    _jump1803:;
    int64_t _822 = 0;
    _822 *= _821.d0;
    _822 += l.d1;
    _822 *= _821.d1;
    _822 += h.d2;
    bool _823 = _821.data[_822];
    return _823;
    bool _824;
    if (!_516)
    goto _jump1804;
    bool _825 = true;
    bool _826 = !_825;
    bool _827 = !_826;
    bool _828;
    if (!_827)
    goto _jump1805;
    _a2_bool _829;
    // Computing bound for t
    _829.d0 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1806;
    fail_assertion("non-positive loop bound");
    _jump1806:;
    // Computing bound for u
    _829.d1 = h.d0;
    if (h.d0 > 0) 
    goto _jump1807;
    fail_assertion("non-positive loop bound");
    _jump1807:;
    // Computing total size of heap memory to allocate
    int64_t _830 = 1;
    _830 *= _418.d1;
    _830 *= h.d0;
    _830 *= sizeof(bool);
    _829.data = jpl_alloc(_830);
    int64_t _831 = 0; // u
    int64_t _832 = 0; // t
    _jump1808:; // Begin body of loop
    int64_t _833 = 0;
    _833 *= _829.d0;
    _833 += _832;
    _833 *= _829.d1;
    _833 += _831;
    _829.data[_833] = _516;
    _831++;
    if (_831 < h.d0)
    goto _jump1808;
    _831 = 0;
    _832++;
    if (_832 < _418.d1)
    goto _jump1808;
    // End body of loop
    int64_t _834 = 150;
    if (_834 >= 0)
    goto _jump1809;
    fail_assertion("negative array index");
    _jump1809:;
    if (_834 < _829.d0)
    goto _jump1810;
    fail_assertion("index too large");
    _jump1810:;
    if (h.d2 >= 0)
    goto _jump1811;
    fail_assertion("negative array index");
    _jump1811:;
    if (h.d2 < _829.d1)
    goto _jump1812;
    fail_assertion("index too large");
    _jump1812:;
    int64_t _835 = 0;
    _835 *= _829.d0;
    _835 += _834;
    _835 *= _829.d1;
    _835 += h.d2;
    bool _836 = _829.data[_835];
    _828 = _836;
    goto _jump1813;
    _jump1805:;
    bool _837 = false;
    bool _838 = !_837;
    _828 = _838;
    _jump1813:;
    e _839;
    if (!_828)
    goto _jump1814;
    _839 = g;
    goto _jump1815;
    _jump1814:;
    _839 = g;
    _jump1815:;
    _a3_int64_t _840;
    // Computing bound for t
    _840.d0 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1816;
    fail_assertion("non-positive loop bound");
    _jump1816:;
    // Computing bound for u
    int64_t _841 = _418.d1 * h.d0;
    _840.d1 = _841;
    if (_841 > 0) 
    goto _jump1817;
    fail_assertion("non-positive loop bound");
    _jump1817:;
    // Computing bound for v
    int64_t _842 = 583;
    _840.d2 = _842;
    if (_842 > 0) 
    goto _jump1818;
    fail_assertion("non-positive loop bound");
    _jump1818:;
    // Computing total size of heap memory to allocate
    int64_t _843 = 1;
    _843 *= _418.d1;
    _843 *= _841;
    _843 *= _842;
    _843 *= sizeof(int64_t);
    _840.data = jpl_alloc(_843);
    int64_t _844 = 0; // v
    int64_t _845 = 0; // u
    int64_t _846 = 0; // t
    _jump1819:; // Begin body of loop
    int64_t _847 = 0;
    _847 *= _840.d0;
    _847 += _846;
    _847 *= _840.d1;
    _847 += _845;
    _847 *= _840.d2;
    _847 += _844;
    _840.data[_847] = _418.d0;
    _844++;
    if (_844 < _842)
    goto _jump1819;
    _844 = 0;
    _845++;
    if (_845 < _841)
    goto _jump1819;
    _845 = 0;
    _846++;
    if (_846 < _418.d1)
    goto _jump1819;
    // End body of loop
    _a3_int64_t _848;
    // Computing bound for t
    _848.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing bound for u
    _848.d1 = h.d2;
    if (h.d2 > 0) 
    goto _jump1821;
    fail_assertion("non-positive loop bound");
    _jump1821:;
    // Computing bound for v
    _848.d2 = h.d2;
    if (h.d2 > 0) 
    goto _jump1822;
    fail_assertion("non-positive loop bound");
    _jump1822:;
    // Computing total size of heap memory to allocate
    int64_t _849 = 1;
    _849 *= l.d1;
    _849 *= h.d2;
    _849 *= h.d2;
    _849 *= sizeof(int64_t);
    _848.data = jpl_alloc(_849);
    int64_t _850 = 0; // v
    int64_t _851 = 0; // u
    int64_t _852 = 0; // t
    _jump1823:; // Begin body of loop
    bool _853 = false;
    int64_t _854;
    if (!_853)
    goto _jump1824;
    _854 = l.d1;
    goto _jump1825;
    _jump1824:;
    _854 = _0;
    _jump1825:;
    int64_t _855 = 0;
    _855 *= _848.d0;
    _855 += _852;
    _855 *= _848.d1;
    _855 += _851;
    _855 *= _848.d2;
    _855 += _850;
    _848.data[_855] = _854;
    _850++;
    if (_850 < h.d2)
    goto _jump1823;
    _850 = 0;
    _851++;
    if (_851 < h.d2)
    goto _jump1823;
    _851 = 0;
    _852++;
    if (_852 < l.d1)
    goto _jump1823;
    // End body of loop
    _a1__a3_int64_t _856;
    _856.d0 = 3;
    _856.data = jpl_alloc(sizeof(_a3_int64_t) * 3);
    _856.data[0] = _840;
    _856.data[1] = _848;
    _856.data[2] = h;
    if (_0 >= 0)
    goto _jump1826;
    fail_assertion("negative array index");
    _jump1826:;
    if (_0 < _856.d0)
    goto _jump1827;
    fail_assertion("index too large");
    _jump1827:;
    int64_t _857 = 0;
    _857 *= _856.d0;
    _857 += _0;
    _a3_int64_t _858 = _856.data[_857];
    bool _859 = f(g, h, l);
    _a2_void_t _860;
    if (!_859)
    goto _jump1828;
    _860 = l;
    goto _jump1829;
    _jump1828:;
    _860 = l;
    _jump1829:;
    double _861 = 11.0;
    double _862 = 40.0;
    bool _863 = _861 != _862;
    _a2_void_t _864;
    if (!_863)
    goto _jump1830;
    _864 = l;
    goto _jump1831;
    _jump1830:;
    _864 = l;
    _jump1831:;
    _a1__a2_void_t _865;
    _865.d0 = 2;
    _865.data = jpl_alloc(sizeof(_a2_void_t) * 2);
    _865.data[0] = _860;
    _865.data[1] = _864;
    int64_t _866 = h.d2 - l.d1;
    if (_866 >= 0)
    goto _jump1832;
    fail_assertion("negative array index");
    _jump1832:;
    if (_866 < _865.d0)
    goto _jump1833;
    fail_assertion("index too large");
    _jump1833:;
    int64_t _867 = 0;
    _867 *= _865.d0;
    _867 += _866;
    _a2_void_t _868 = _865.data[_867];
    bool _869 = f(_839, _858, _868);
    _824 = _869;
    goto _jump1834;
    _jump1804:;
    _a1_void_t _870;
    // Computing bound for t
    _870.d0 = _0;
    if (_0 > 0) 
    goto _jump1835;
    fail_assertion("non-positive loop bound");
    _jump1835:;
    // Computing total size of heap memory to allocate
    int64_t _871 = 1;
    _871 *= _0;
    _871 *= sizeof(void_t);
    _870.data = jpl_alloc(_871);
    int64_t _872 = 0; // t
    _jump1836:; // Begin body of loop
    if (l.d0 >= 0)
    goto _jump1837;
    fail_assertion("negative array index");
    _jump1837:;
    if (l.d0 < l.d0)
    goto _jump1838;
    fail_assertion("index too large");
    _jump1838:;
    if (_418.d0 >= 0)
    goto _jump1839;
    fail_assertion("negative array index");
    _jump1839:;
    if (_418.d0 < l.d1)
    goto _jump1840;
    fail_assertion("index too large");
    _jump1840:;
    int64_t _873 = 0;
    _873 *= l.d0;
    _873 += l.d0;
    _873 *= l.d1;
    _873 += _418.d0;
    void_t _874 = l.data[_873];
    int64_t _875 = 0;
    _875 *= _870.d0;
    _875 += _872;
    _870.data[_875] = _874;
    _872++;
    if (_872 < _0)
    goto _jump1836;
    // End body of loop
    if (_418.d0 >= 0)
    goto _jump1841;
    fail_assertion("negative array index");
    _jump1841:;
    if (_418.d0 < _870.d0)
    goto _jump1842;
    fail_assertion("index too large");
    _jump1842:;
    int64_t _876 = 0;
    _876 *= _870.d0;
    _876 += _418.d0;
    void_t _877 = _870.data[_876];
    bool _878 = c(_877);
    _824 = _878;
    _jump1834:;
    bool _879;
    if (!_824)
    goto _jump1843;
    bool _880 = h.d2 != _0;
    bool _881 = !_880;
    _879 = _881;
    goto _jump1844;
    _jump1843:;
    bool _882 = true;
    bool _883 = !_882;
    double _884;
    if (!_883)
    goto _jump1845;
    double _885 = 29.0;
    _884 = _885;
    goto _jump1846;
    _jump1845:;
    double _886;
    // Computing bound for t
    if (h.d1 > 0) 
    goto _jump1847;
    fail_assertion("non-positive loop bound");
    _jump1847:;
    _886 = 0;
    int64_t _887 = 0; // t
    _jump1848:; // Begin body of loop
    double _888 = d.r;
    _886 += _888;
    _887++;
    if (_887 < h.d1)
    goto _jump1848;
    // End body of loop
    _884 = _886;
    _jump1846:;
    _a2_double _889;
    // Computing bound for t
    _889.d0 = h.d0;
    if (h.d0 > 0) 
    goto _jump1849;
    fail_assertion("non-positive loop bound");
    _jump1849:;
    // Computing bound for u
    _889.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump1850;
    fail_assertion("non-positive loop bound");
    _jump1850:;
    // Computing total size of heap memory to allocate
    int64_t _890 = 1;
    _890 *= h.d0;
    _890 *= l.d0;
    _890 *= sizeof(double);
    _889.data = jpl_alloc(_890);
    int64_t _891 = 0; // u
    int64_t _892 = 0; // t
    _jump1851:; // Begin body of loop
    double _893 = 14.0;
    int64_t _894 = 0;
    _894 *= _889.d0;
    _894 += _892;
    _894 *= _889.d1;
    _894 += _891;
    _889.data[_894] = _893;
    _891++;
    if (_891 < l.d0)
    goto _jump1851;
    _891 = 0;
    _892++;
    if (_892 < h.d0)
    goto _jump1851;
    // End body of loop
    int64_t _895 = 912;
    if (_895 >= 0)
    goto _jump1852;
    fail_assertion("negative array index");
    _jump1852:;
    if (_895 < _889.d0)
    goto _jump1853;
    fail_assertion("index too large");
    _jump1853:;
    if (h.d1 >= 0)
    goto _jump1854;
    fail_assertion("negative array index");
    _jump1854:;
    if (h.d1 < _889.d1)
    goto _jump1855;
    fail_assertion("index too large");
    _jump1855:;
    int64_t _896 = 0;
    _896 *= _889.d0;
    _896 += _895;
    _896 *= _889.d1;
    _896 += h.d1;
    double _897 = _889.data[_896];
    double _898 = -_897;
    bool _899 = _884 >= _898;
    _a2_bool _900;
    if (!_899)
    goto _jump1856;
    _a2_bool _901;
    // Computing bound for t
    int64_t _902 = l.d1 / l.d1;
    _901.d0 = _902;
    if (_902 > 0) 
    goto _jump1857;
    fail_assertion("non-positive loop bound");
    _jump1857:;
    // Computing bound for u
    int64_t _903;
    // Computing bound for t
    int64_t _904 = h.d0 - h.d2;
    if (_904 > 0) 
    goto _jump1858;
    fail_assertion("non-positive loop bound");
    _jump1858:;
    _903 = 0;
    int64_t _905 = 0; // t
    _jump1859:; // Begin body of loop
    _903 += l.d0;
    _905++;
    if (_905 < _904)
    goto _jump1859;
    // End body of loop
    int64_t _906 = -_903;
    _901.d1 = _906;
    if (_906 > 0) 
    goto _jump1860;
    fail_assertion("non-positive loop bound");
    _jump1860:;
    // Computing total size of heap memory to allocate
    int64_t _907 = 1;
    _907 *= _902;
    _907 *= _906;
    _907 *= sizeof(bool);
    _901.data = jpl_alloc(_907);
    int64_t _908 = 0; // u
    int64_t _909 = 0; // t
    _jump1861:; // Begin body of loop
    if (l.d1 >= 0)
    goto _jump1862;
    fail_assertion("negative array index");
    _jump1862:;
    if (l.d1 < l.d0)
    goto _jump1863;
    fail_assertion("index too large");
    _jump1863:;
    if (h.d0 >= 0)
    goto _jump1864;
    fail_assertion("negative array index");
    _jump1864:;
    if (h.d0 < l.d1)
    goto _jump1865;
    fail_assertion("index too large");
    _jump1865:;
    int64_t _911 = 0;
    _911 *= l.d0;
    _911 += l.d1;
    _911 *= l.d1;
    _911 += h.d0;
    void_t _912 = l.data[_911];
    bool _913 = c(_912);
    bool _910 = _913;
    if (0 == _913)
    goto _jump1866;
    _910 = _516;
    _jump1866:;
    int64_t _914 = 0;
    _914 *= _901.d0;
    _914 += _909;
    _914 *= _901.d1;
    _914 += _908;
    _901.data[_914] = _910;
    _908++;
    if (_908 < _906)
    goto _jump1861;
    _908 = 0;
    _909++;
    if (_909 < _902)
    goto _jump1861;
    // End body of loop
    _900 = _901;
    goto _jump1867;
    _jump1856:;
    _a2_bool _915;
    // Computing bound for t
    _a2_int64_t _916;
    // Computing bound for t
    int64_t _917 = 774;
    _916.d0 = _917;
    if (_917 > 0) 
    goto _jump1868;
    fail_assertion("non-positive loop bound");
    _jump1868:;
    // Computing bound for u
    _916.d1 = _418.d1;
    if (_418.d1 > 0) 
    goto _jump1869;
    fail_assertion("non-positive loop bound");
    _jump1869:;
    // Computing total size of heap memory to allocate
    int64_t _918 = 1;
    _918 *= _917;
    _918 *= _418.d1;
    _918 *= sizeof(int64_t);
    _916.data = jpl_alloc(_918);
    int64_t _919 = 0; // u
    int64_t _920 = 0; // t
    _jump1870:; // Begin body of loop
    int64_t _921 = 0;
    _921 *= _916.d0;
    _921 += _920;
    _921 *= _916.d1;
    _921 += _919;
    _916.data[_921] = h.d1;
    _919++;
    if (_919 < _418.d1)
    goto _jump1870;
    _919 = 0;
    _920++;
    if (_920 < _917)
    goto _jump1870;
    // End body of loop
    int64_t _922 = -l.d1;
    if (l.d1 >= 0)
    goto _jump1871;
    fail_assertion("negative array index");
    _jump1871:;
    if (l.d1 < _916.d0)
    goto _jump1872;
    fail_assertion("index too large");
    _jump1872:;
    if (_922 >= 0)
    goto _jump1873;
    fail_assertion("negative array index");
    _jump1873:;
    if (_922 < _916.d1)
    goto _jump1874;
    fail_assertion("index too large");
    _jump1874:;
    int64_t _923 = 0;
    _923 *= _916.d0;
    _923 += l.d1;
    _923 *= _916.d1;
    _923 += _922;
    int64_t _924 = _916.data[_923];
    _915.d0 = _924;
    if (_924 > 0) 
    goto _jump1875;
    fail_assertion("non-positive loop bound");
    _jump1875:;
    // Computing bound for u
    int64_t _925 = h.d0 * l.d0;
    int64_t _926 = l.d1 % _925;
    _915.d1 = _926;
    if (_926 > 0) 
    goto _jump1876;
    fail_assertion("non-positive loop bound");
    _jump1876:;
    // Computing total size of heap memory to allocate
    int64_t _927 = 1;
    _927 *= _924;
    _927 *= _926;
    _927 *= sizeof(bool);
    _915.data = jpl_alloc(_927);
    int64_t _928 = 0; // u
    int64_t _929 = 0; // t
    _jump1877:; // Begin body of loop
    int64_t _930 = 961;
    bool _931 = l.d1 == _930;
    bool _932;
    if (!_931)
    goto _jump1878;
    bool _933 = false;
    bool _934 = !_933;
    _932 = _934;
    goto _jump1879;
    _jump1878:;
    bool _936 = false;
    bool _935 = _936;
    if (0 == _936)
    goto _jump1880;
    bool _937 = !_516;
    _935 = _937;
    _jump1880:;
    _932 = _935;
    _jump1879:;
    int64_t _938 = 0;
    _938 *= _915.d0;
    _938 += _929;
    _938 *= _915.d1;
    _938 += _928;
    _915.data[_938] = _932;
    _928++;
    if (_928 < _926)
    goto _jump1877;
    _928 = 0;
    _929++;
    if (_929 < _924)
    goto _jump1877;
    // End body of loop
    _900 = _915;
    _jump1867:;
    int64_t _939 = l.d0 % _418.d1;
    int64_t _940 = _418.d1 - _939;
    if (_418.d0 >= 0)
    goto _jump1881;
    fail_assertion("negative array index");
    _jump1881:;
    if (_418.d0 < _900.d0)
    goto _jump1882;
    fail_assertion("index too large");
    _jump1882:;
    if (_940 >= 0)
    goto _jump1883;
    fail_assertion("negative array index");
    _jump1883:;
    if (_940 < _900.d1)
    goto _jump1884;
    fail_assertion("index too large");
    _jump1884:;
    int64_t _941 = 0;
    _941 *= _900.d0;
    _941 += _418.d0;
    _941 *= _900.d1;
    _941 += _940;
    bool _942 = _900.data[_941];
    _879 = _942;
    _jump1844:;
    return _879;
}

_a3_double z(int64_t A) {
    _a2__a3_rgba _0;
    // Computing bound for B
    int64_t _1 = 155;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump2432;
    fail_assertion("non-positive loop bound");
    _jump2432:;
    // Computing bound for C
    _0.d1 = A;
    if (A > 0) 
    goto _jump2433;
    fail_assertion("non-positive loop bound");
    _jump2433:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= _1;
    _2 *= A;
    _2 *= sizeof(_a3_rgba);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // C
    int64_t _4 = 0; // B
    _jump2434:; // Begin body of loop
    _a3_rgba _5;
    // Computing bound for D
    _5.d0 = s;
    if (s > 0) 
    goto _jump2435;
    fail_assertion("non-positive loop bound");
    _jump2435:;
    // Computing bound for E
    _5.d1 = _3;
    if (_3 > 0) 
    goto _jump2436;
    fail_assertion("non-positive loop bound");
    _jump2436:;
    // Computing bound for F
    _5.d2 = r;
    if (r > 0) 
    goto _jump2437;
    fail_assertion("non-positive loop bound");
    _jump2437:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= s;
    _6 *= _3;
    _6 *= r;
    _6 *= sizeof(rgba);
    _5.data = jpl_alloc(_6);
    int64_t _7 = 0; // F
    int64_t _8 = 0; // E
    int64_t _9 = 0; // D
    _jump2438:; // Begin body of loop
    int64_t _10 = 0;
    _10 *= _5.d0;
    _10 += _9;
    _10 *= _5.d1;
    _10 += _8;
    _10 *= _5.d2;
    _10 += _7;
    _5.data[_10] = d;
    _7++;
    if (_7 < r)
    goto _jump2438;
    _7 = 0;
    _8++;
    if (_8 < _3)
    goto _jump2438;
    _8 = 0;
    _9++;
    if (_9 < s)
    goto _jump2438;
    // End body of loop
    int64_t _11 = 0;
    _11 *= _0.d0;
    _11 += _4;
    _11 *= _0.d1;
    _11 += _3;
    _0.data[_11] = _5;
    _3++;
    if (_3 < A)
    goto _jump2434;
    _3 = 0;
    _4++;
    if (_4 < _1)
    goto _jump2434;
    // End body of loop
    int64_t _12 = 590;
    if (A >= 0)
    goto _jump2439;
    fail_assertion("negative array index");
    _jump2439:;
    if (A < _0.d0)
    goto _jump2440;
    fail_assertion("index too large");
    _jump2440:;
    if (_12 >= 0)
    goto _jump2441;
    fail_assertion("negative array index");
    _jump2441:;
    if (_12 < _0.d1)
    goto _jump2442;
    fail_assertion("index too large");
    _jump2442:;
    int64_t _13 = 0;
    _13 *= _0.d0;
    _13 += A;
    _13 *= _0.d1;
    _13 += _12;
    _a3_rgba _14 = _0.data[_13];
    bool _15 = false;
    bool _16;
    if (!_15)
    goto _jump2443;
    bool _17 = true;
    _16 = _17;
    goto _jump2444;
    _jump2443:;
    double _18 = -n;
    double _19;
    // Computing bound for B
    if (m > 0) 
    goto _jump2445;
    fail_assertion("non-positive loop bound");
    _jump2445:;
    // Computing bound for C
    if (r > 0) 
    goto _jump2446;
    fail_assertion("non-positive loop bound");
    _jump2446:;
    // Computing bound for D
    if (s > 0) 
    goto _jump2447;
    fail_assertion("non-positive loop bound");
    _jump2447:;
    _19 = 0;
    int64_t _20 = 0; // D
    int64_t _21 = 0; // C
    int64_t _22 = 0; // B
    _jump2448:; // Begin body of loop
    double _23 = 36.0;
    double _24 = 91.0;
    double _25 = _23 * _24;
    _19 += _25;
    _20++;
    if (_20 < s)
    goto _jump2448;
    _20 = 0;
    _21++;
    if (_21 < r)
    goto _jump2448;
    _21 = 0;
    _22++;
    if (_22 < m)
    goto _jump2448;
    // End body of loop
    bool _26 = _18 <= _19;
    _16 = _26;
    _jump2444:;
    _a1_bool _27;
    if (!_16)
    goto _jump2449;
    _a1_bool _28;
    // Computing bound for B
    _a1_int64_t _29;
    // Computing bound for B
    bool _30 = true;
    int64_t _31;
    if (!_30)
    goto _jump2450;
    _31 = y;
    goto _jump2451;
    _jump2450:;
    int64_t _32 = 421;
    _31 = _32;
    _jump2451:;
    _29.d0 = _31;
    if (_31 > 0) 
    goto _jump2452;
    fail_assertion("non-positive loop bound");
    _jump2452:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= _31;
    _33 *= sizeof(int64_t);
    _29.data = jpl_alloc(_33);
    int64_t _34 = 0; // B
    _jump2453:; // Begin body of loop
    int64_t _35 = 0;
    _35 *= _29.d0;
    _35 += _34;
    _29.data[_35] = l;
    _34++;
    if (_34 < _31)
    goto _jump2453;
    // End body of loop
    if (s >= 0)
    goto _jump2454;
    fail_assertion("negative array index");
    _jump2454:;
    if (s < _29.d0)
    goto _jump2455;
    fail_assertion("index too large");
    _jump2455:;
    int64_t _36 = 0;
    _36 *= _29.d0;
    _36 += s;
    int64_t _37 = _29.data[_36];
    _28.d0 = _37;
    if (_37 > 0) 
    goto _jump2456;
    fail_assertion("non-positive loop bound");
    _jump2456:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= _37;
    _38 *= sizeof(bool);
    _28.data = jpl_alloc(_38);
    int64_t _39 = 0; // B
    _jump2457:; // Begin body of loop
    if (A >= 0)
    goto _jump2458;
    fail_assertion("negative array index");
    _jump2458:;
    if (A < t.d0)
    goto _jump2459;
    fail_assertion("index too large");
    _jump2459:;
    if (s >= 0)
    goto _jump2460;
    fail_assertion("negative array index");
    _jump2460:;
    if (s < t.d1)
    goto _jump2461;
    fail_assertion("index too large");
    _jump2461:;
    int64_t _40 = 0;
    _40 *= t.d0;
    _40 += A;
    _40 *= t.d1;
    _40 += s;
    bool _41 = t.data[_40];
    _a2_bool _42;
    if (!_41)
    goto _jump2462;
    bool _43 = true;
    _a2_bool _44;
    if (!_43)
    goto _jump2463;
    _44 = t;
    goto _jump2464;
    _jump2463:;
    _44 = t;
    _jump2464:;
    _42 = _44;
    goto _jump2465;
    _jump2462:;
    _42 = t;
    _jump2465:;
    _a3_int64_t _45;
    // Computing bound for C
    _45.d0 = v;
    if (v > 0) 
    goto _jump2466;
    fail_assertion("non-positive loop bound");
    _jump2466:;
    // Computing bound for D
    _45.d1 = x;
    if (x > 0) 
    goto _jump2467;
    fail_assertion("non-positive loop bound");
    _jump2467:;
    // Computing bound for E
    _45.d2 = v;
    if (v > 0) 
    goto _jump2468;
    fail_assertion("non-positive loop bound");
    _jump2468:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= v;
    _46 *= x;
    _46 *= v;
    _46 *= sizeof(int64_t);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // E
    int64_t _48 = 0; // D
    int64_t _49 = 0; // C
    _jump2469:; // Begin body of loop
    int64_t _50 = 0;
    _50 *= _45.d0;
    _50 += _49;
    _50 *= _45.d1;
    _50 += _48;
    _50 *= _45.d2;
    _50 += _47;
    _45.data[_50] = l;
    _47++;
    if (_47 < v)
    goto _jump2469;
    _47 = 0;
    _48++;
    if (_48 < x)
    goto _jump2469;
    _48 = 0;
    _49++;
    if (_49 < v)
    goto _jump2469;
    // End body of loop
    if (v >= 0)
    goto _jump2470;
    fail_assertion("negative array index");
    _jump2470:;
    if (v < _45.d0)
    goto _jump2471;
    fail_assertion("index too large");
    _jump2471:;
    if (u >= 0)
    goto _jump2472;
    fail_assertion("negative array index");
    _jump2472:;
    if (u < _45.d1)
    goto _jump2473;
    fail_assertion("index too large");
    _jump2473:;
    if (s >= 0)
    goto _jump2474;
    fail_assertion("negative array index");
    _jump2474:;
    if (s < _45.d2)
    goto _jump2475;
    fail_assertion("index too large");
    _jump2475:;
    int64_t _51 = 0;
    _51 *= _45.d0;
    _51 += v;
    _51 *= _45.d1;
    _51 += u;
    _51 *= _45.d2;
    _51 += s;
    int64_t _52 = _45.data[_51];
    if (s >= 0)
    goto _jump2476;
    fail_assertion("negative array index");
    _jump2476:;
    if (s < _42.d0)
    goto _jump2477;
    fail_assertion("index too large");
    _jump2477:;
    if (_52 >= 0)
    goto _jump2478;
    fail_assertion("negative array index");
    _jump2478:;
    if (_52 < _42.d1)
    goto _jump2479;
    fail_assertion("index too large");
    _jump2479:;
    int64_t _53 = 0;
    _53 *= _42.d0;
    _53 += s;
    _53 *= _42.d1;
    _53 += _52;
    bool _54 = _42.data[_53];
    int64_t _55 = 0;
    _55 *= _28.d0;
    _55 += _39;
    _28.data[_55] = _54;
    _39++;
    if (_39 < _37)
    goto _jump2457;
    // End body of loop
    _27 = _28;
    goto _jump2480;
    _jump2449:;
    bool _56 = false;
    _a1_bool _57;
    _57.d0 = 1;
    _57.data = jpl_alloc(sizeof(bool) * 1);
    _57.data[0] = _56;
    _27 = _57;
    _jump2480:;
    _a2_rgba _58;
    // Computing bound for B
    _a3__a3_rgba _59;
    // Computing bound for B
    int64_t _60;
    // Computing bound for B
    if (v > 0) 
    goto _jump2481;
    fail_assertion("non-positive loop bound");
    _jump2481:;
    // Computing bound for C
    if (r > 0) 
    goto _jump2482;
    fail_assertion("non-positive loop bound");
    _jump2482:;
    _60 = 0;
    int64_t _61 = 0; // C
    int64_t _62 = 0; // B
    _jump2483:; // Begin body of loop
    _60 += _62;
    _61++;
    if (_61 < r)
    goto _jump2483;
    _61 = 0;
    _62++;
    if (_62 < v)
    goto _jump2483;
    // End body of loop
    _59.d0 = _60;
    if (_60 > 0) 
    goto _jump2484;
    fail_assertion("non-positive loop bound");
    _jump2484:;
    // Computing bound for C
    int64_t _63 = u * m;
    _59.d1 = _63;
    if (_63 > 0) 
    goto _jump2485;
    fail_assertion("non-positive loop bound");
    _jump2485:;
    // Computing bound for D
    int64_t _64 = u / m;
    _59.d2 = _64;
    if (_64 > 0) 
    goto _jump2486;
    fail_assertion("non-positive loop bound");
    _jump2486:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= _60;
    _65 *= _63;
    _65 *= _64;
    _65 *= sizeof(_a3_rgba);
    _59.data = jpl_alloc(_65);
    int64_t _66 = 0; // D
    int64_t _67 = 0; // C
    int64_t _68 = 0; // B
    _jump2487:; // Begin body of loop
    _a3_rgba _69;
    // Computing bound for E
    _69.d0 = y;
    if (y > 0) 
    goto _jump2488;
    fail_assertion("non-positive loop bound");
    _jump2488:;
    // Computing bound for F
    _69.d1 = l;
    if (l > 0) 
    goto _jump2489;
    fail_assertion("non-positive loop bound");
    _jump2489:;
    // Computing bound for G
    _69.d2 = m;
    if (m > 0) 
    goto _jump2490;
    fail_assertion("non-positive loop bound");
    _jump2490:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= y;
    _70 *= l;
    _70 *= m;
    _70 *= sizeof(rgba);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // G
    int64_t _72 = 0; // F
    int64_t _73 = 0; // E
    _jump2491:; // Begin body of loop
    int64_t _74 = 0;
    _74 *= _69.d0;
    _74 += _73;
    _74 *= _69.d1;
    _74 += _72;
    _74 *= _69.d2;
    _74 += _71;
    _69.data[_74] = d;
    _71++;
    if (_71 < m)
    goto _jump2491;
    _71 = 0;
    _72++;
    if (_72 < l)
    goto _jump2491;
    _72 = 0;
    _73++;
    if (_73 < y)
    goto _jump2491;
    // End body of loop
    int64_t _75 = 0;
    _75 *= _59.d0;
    _75 += _68;
    _75 *= _59.d1;
    _75 += _67;
    _75 *= _59.d2;
    _75 += _66;
    _59.data[_75] = _69;
    _66++;
    if (_66 < _64)
    goto _jump2487;
    _66 = 0;
    _67++;
    if (_67 < _63)
    goto _jump2487;
    _67 = 0;
    _68++;
    if (_68 < _60)
    goto _jump2487;
    // End body of loop
    int64_t _76 = 65;
    int64_t _77;
    // Computing bound for B
    if (m > 0) 
    goto _jump2492;
    fail_assertion("non-positive loop bound");
    _jump2492:;
    // Computing bound for C
    int64_t _78;
    // Computing bound for B
    if (A > 0) 
    goto _jump2493;
    fail_assertion("non-positive loop bound");
    _jump2493:;
    // Computing bound for C
    if (y > 0) 
    goto _jump2494;
    fail_assertion("non-positive loop bound");
    _jump2494:;
    // Computing bound for D
    if (u > 0) 
    goto _jump2495;
    fail_assertion("non-positive loop bound");
    _jump2495:;
    _78 = 0;
    int64_t _79 = 0; // D
    int64_t _80 = 0; // C
    int64_t _81 = 0; // B
    _jump2496:; // Begin body of loop
    _78 += A;
    _79++;
    if (_79 < u)
    goto _jump2496;
    _79 = 0;
    _80++;
    if (_80 < y)
    goto _jump2496;
    _80 = 0;
    _81++;
    if (_81 < A)
    goto _jump2496;
    // End body of loop
    if (_78 > 0) 
    goto _jump2497;
    fail_assertion("non-positive loop bound");
    _jump2497:;
    // Computing bound for D
    if (v > 0) 
    goto _jump2498;
    fail_assertion("non-positive loop bound");
    _jump2498:;
    _77 = 0;
    int64_t _82 = 0; // D
    int64_t _83 = 0; // C
    int64_t _84 = 0; // B
    _jump2499:; // Begin body of loop
    _77 += A;
    _82++;
    if (_82 < v)
    goto _jump2499;
    _82 = 0;
    _83++;
    if (_83 < _78)
    goto _jump2499;
    _83 = 0;
    _84++;
    if (_84 < m)
    goto _jump2499;
    // End body of loop
    if (l >= 0)
    goto _jump2500;
    fail_assertion("negative array index");
    _jump2500:;
    if (l < _59.d0)
    goto _jump2501;
    fail_assertion("index too large");
    _jump2501:;
    if (_76 >= 0)
    goto _jump2502;
    fail_assertion("negative array index");
    _jump2502:;
    if (_76 < _59.d1)
    goto _jump2503;
    fail_assertion("index too large");
    _jump2503:;
    if (_77 >= 0)
    goto _jump2504;
    fail_assertion("negative array index");
    _jump2504:;
    if (_77 < _59.d2)
    goto _jump2505;
    fail_assertion("index too large");
    _jump2505:;
    int64_t _85 = 0;
    _85 *= _59.d0;
    _85 += l;
    _85 *= _59.d1;
    _85 += _76;
    _85 *= _59.d2;
    _85 += _77;
    _a3_rgba _86 = _59.data[_85];
    _a2_rgba _87;
    // Computing bound for B
    _87.d0 = v;
    if (v > 0) 
    goto _jump2506;
    fail_assertion("non-positive loop bound");
    _jump2506:;
    // Computing bound for C
    _a3_rgba _88;
    // Computing bound for B
    _88.d0 = m;
    if (m > 0) 
    goto _jump2507;
    fail_assertion("non-positive loop bound");
    _jump2507:;
    // Computing bound for C
    _88.d1 = y;
    if (y > 0) 
    goto _jump2508;
    fail_assertion("non-positive loop bound");
    _jump2508:;
    // Computing bound for D
    _88.d2 = u;
    if (u > 0) 
    goto _jump2509;
    fail_assertion("non-positive loop bound");
    _jump2509:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= m;
    _89 *= y;
    _89 *= u;
    _89 *= sizeof(rgba);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // D
    int64_t _91 = 0; // C
    int64_t _92 = 0; // B
    _jump2510:; // Begin body of loop
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _92;
    _93 *= _88.d1;
    _93 += _91;
    _93 *= _88.d2;
    _93 += _90;
    _88.data[_93] = d;
    _90++;
    if (_90 < u)
    goto _jump2510;
    _90 = 0;
    _91++;
    if (_91 < y)
    goto _jump2510;
    _91 = 0;
    _92++;
    if (_92 < m)
    goto _jump2510;
    // End body of loop
    int64_t _94 = b(_88, a, k);
    _87.d1 = _94;
    if (_94 > 0) 
    goto _jump2511;
    fail_assertion("non-positive loop bound");
    _jump2511:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= v;
    _95 *= _94;
    _95 *= sizeof(rgba);
    _87.data = jpl_alloc(_95);
    int64_t _96 = 0; // C
    int64_t _97 = 0; // B
    _jump2512:; // Begin body of loop
    int64_t _98 = 0;
    _98 *= _87.d0;
    _98 += _97;
    _98 *= _87.d1;
    _98 += _96;
    _87.data[_98] = d;
    _96++;
    if (_96 < _94)
    goto _jump2512;
    _96 = 0;
    _97++;
    if (_97 < v)
    goto _jump2512;
    // End body of loop
    int64_t _99 = b(_86, a, _87);
    _58.d0 = _99;
    if (_99 > 0) 
    goto _jump2513;
    fail_assertion("non-positive loop bound");
    _jump2513:;
    // Computing bound for C
    int64_t _100 = m - s;
    _58.d1 = _100;
    if (_100 > 0) 
    goto _jump2514;
    fail_assertion("non-positive loop bound");
    _jump2514:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _99;
    _101 *= _100;
    _101 *= sizeof(rgba);
    _58.data = jpl_alloc(_101);
    int64_t _102 = 0; // C
    int64_t _103 = 0; // B
    _jump2515:; // Begin body of loop
    double _104 = -n;
    bool _105 = _104 <= n;
    double _106;
    if (!_105)
    goto _jump2516;
    _106 = n;
    goto _jump2517;
    _jump2516:;
    _a2_double _107;
    // Computing bound for D
    _107.d0 = A;
    if (A > 0) 
    goto _jump2518;
    fail_assertion("non-positive loop bound");
    _jump2518:;
    // Computing bound for E
    _107.d1 = v;
    if (v > 0) 
    goto _jump2519;
    fail_assertion("non-positive loop bound");
    _jump2519:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= A;
    _108 *= v;
    _108 *= sizeof(double);
    _107.data = jpl_alloc(_108);
    int64_t _109 = 0; // E
    int64_t _110 = 0; // D
    _jump2520:; // Begin body of loop
    int64_t _111 = 0;
    _111 *= _107.d0;
    _111 += _110;
    _111 *= _107.d1;
    _111 += _109;
    _107.data[_111] = h;
    _109++;
    if (_109 < v)
    goto _jump2520;
    _109 = 0;
    _110++;
    if (_110 < A)
    goto _jump2520;
    // End body of loop
    int64_t _112;
    // Computing bound for D
    if (m > 0) 
    goto _jump2521;
    fail_assertion("non-positive loop bound");
    _jump2521:;
    // Computing bound for E
    if (s > 0) 
    goto _jump2522;
    fail_assertion("non-positive loop bound");
    _jump2522:;
    // Computing bound for F
    if (_102 > 0) 
    goto _jump2523;
    fail_assertion("non-positive loop bound");
    _jump2523:;
    _112 = 0;
    int64_t _113 = 0; // F
    int64_t _114 = 0; // E
    int64_t _115 = 0; // D
    _jump2524:; // Begin body of loop
    _112 += r;
    _113++;
    if (_113 < _102)
    goto _jump2524;
    _113 = 0;
    _114++;
    if (_114 < s)
    goto _jump2524;
    _114 = 0;
    _115++;
    if (_115 < m)
    goto _jump2524;
    // End body of loop
    if (_112 >= 0)
    goto _jump2525;
    fail_assertion("negative array index");
    _jump2525:;
    if (_112 < _107.d0)
    goto _jump2526;
    fail_assertion("index too large");
    _jump2526:;
    if (_102 >= 0)
    goto _jump2527;
    fail_assertion("negative array index");
    _jump2527:;
    if (_102 < _107.d1)
    goto _jump2528;
    fail_assertion("index too large");
    _jump2528:;
    int64_t _116 = 0;
    _116 *= _107.d0;
    _116 += _112;
    _116 *= _107.d1;
    _116 += _102;
    double _117 = _107.data[_116];
    _106 = _117;
    _jump2517:;
    _a3_double _118;
    // Computing bound for D
    int64_t _119;
    // Computing bound for D
    if (l > 0) 
    goto _jump2529;
    fail_assertion("non-positive loop bound");
    _jump2529:;
    // Computing bound for E
    if (r > 0) 
    goto _jump2530;
    fail_assertion("non-positive loop bound");
    _jump2530:;
    _119 = 0;
    int64_t _120 = 0; // E
    int64_t _121 = 0; // D
    _jump2531:; // Begin body of loop
    _119 += _103;
    _120++;
    if (_120 < r)
    goto _jump2531;
    _120 = 0;
    _121++;
    if (_121 < l)
    goto _jump2531;
    // End body of loop
    _118.d0 = _119;
    if (_119 > 0) 
    goto _jump2532;
    fail_assertion("non-positive loop bound");
    _jump2532:;
    // Computing bound for E
    _118.d1 = _102;
    if (_102 > 0) 
    goto _jump2533;
    fail_assertion("non-positive loop bound");
    _jump2533:;
    // Computing bound for F
    _118.d2 = y;
    if (y > 0) 
    goto _jump2534;
    fail_assertion("non-positive loop bound");
    _jump2534:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _119;
    _122 *= _102;
    _122 *= y;
    _122 *= sizeof(double);
    _118.data = jpl_alloc(_122);
    int64_t _123 = 0; // F
    int64_t _124 = 0; // E
    int64_t _125 = 0; // D
    _jump2535:; // Begin body of loop
    double _126 = d.r;
    int64_t _127 = 0;
    _127 *= _118.d0;
    _127 += _125;
    _127 *= _118.d1;
    _127 += _124;
    _127 *= _118.d2;
    _127 += _123;
    _118.data[_127] = _126;
    _123++;
    if (_123 < y)
    goto _jump2535;
    _123 = 0;
    _124++;
    if (_124 < _102)
    goto _jump2535;
    _124 = 0;
    _125++;
    if (_125 < _119)
    goto _jump2535;
    // End body of loop
    if (_103 >= 0)
    goto _jump2536;
    fail_assertion("negative array index");
    _jump2536:;
    if (_103 < _118.d0)
    goto _jump2537;
    fail_assertion("index too large");
    _jump2537:;
    if (_103 >= 0)
    goto _jump2538;
    fail_assertion("negative array index");
    _jump2538:;
    if (_103 < _118.d1)
    goto _jump2539;
    fail_assertion("index too large");
    _jump2539:;
    if (m >= 0)
    goto _jump2540;
    fail_assertion("negative array index");
    _jump2540:;
    if (m < _118.d2)
    goto _jump2541;
    fail_assertion("index too large");
    _jump2541:;
    int64_t _128 = 0;
    _128 *= _118.d0;
    _128 += _103;
    _128 *= _118.d1;
    _128 += _103;
    _128 *= _118.d2;
    _128 += m;
    double _129 = _118.data[_128];
    double _130 = -j;
    rgba _131 = { _106, _129, n, _130 };
    int64_t _132 = 0;
    _132 *= _58.d0;
    _132 += _103;
    _132 *= _58.d1;
    _132 += _102;
    _58.data[_132] = _131;
    _102++;
    if (_102 < _100)
    goto _jump2515;
    _102 = 0;
    _103++;
    if (_103 < _99)
    goto _jump2515;
    // End body of loop
    int64_t _133 = b(_14, _27, _58);
    int64_t _134 = 386;
    int64_t _135 = -_134;
    bool _136 = _133 > _135;
    if (0 != _136)
    goto _jump2542;
    fail_assertion("B");
    _jump2542:;
    int64_t _137;
    // Computing bound for C
    int64_t _138 = -s;
    int64_t _139 = -_138;
    if (_139 > 0) 
    goto _jump2543;
    fail_assertion("non-positive loop bound");
    _jump2543:;
    // Computing bound for D
    if (r > 0) 
    goto _jump2544;
    fail_assertion("non-positive loop bound");
    _jump2544:;
    _137 = 0;
    int64_t _140 = 0; // D
    int64_t _141 = 0; // C
    _jump2545:; // Begin body of loop
    int64_t _142;
    // Computing bound for E
    if (A > 0) 
    goto _jump2546;
    fail_assertion("non-positive loop bound");
    _jump2546:;
    // Computing bound for F
    if (l > 0) 
    goto _jump2547;
    fail_assertion("non-positive loop bound");
    _jump2547:;
    // Computing bound for G
    if (s > 0) 
    goto _jump2548;
    fail_assertion("non-positive loop bound");
    _jump2548:;
    _142 = 0;
    int64_t _143 = 0; // G
    int64_t _144 = 0; // F
    int64_t _145 = 0; // E
    _jump2549:; // Begin body of loop
    _142 += r;
    _143++;
    if (_143 < s)
    goto _jump2549;
    _143 = 0;
    _144++;
    if (_144 < l)
    goto _jump2549;
    _144 = 0;
    _145++;
    if (_145 < A)
    goto _jump2549;
    // End body of loop
    int64_t _146 = y % _142;
    _137 += _146;
    _140++;
    if (_140 < r)
    goto _jump2545;
    _140 = 0;
    _141++;
    if (_141 < _139)
    goto _jump2545;
    // End body of loop
    bool _147 = x != _137;
    bool _148 = !_147;
    _a1_bool _149;
    if (!_148)
    goto _jump2550;
    _a1_bool _150;
    // Computing bound for C
    int64_t _151;
    // Computing bound for C
    if (x > 0) 
    goto _jump2551;
    fail_assertion("non-positive loop bound");
    _jump2551:;
    _151 = 0;
    int64_t _152 = 0; // C
    _jump2552:; // Begin body of loop
    _151 += y;
    _152++;
    if (_152 < x)
    goto _jump2552;
    // End body of loop
    _150.d0 = _151;
    if (_151 > 0) 
    goto _jump2553;
    fail_assertion("non-positive loop bound");
    _jump2553:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _151;
    _153 *= sizeof(bool);
    _150.data = jpl_alloc(_153);
    int64_t _154 = 0; // C
    _jump2554:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _150.d0;
    _155 += _154;
    _150.data[_155] = g;
    _154++;
    if (_154 < _151)
    goto _jump2554;
    // End body of loop
    _149 = _150;
    goto _jump2555;
    _jump2550:;
    _a1_bool _156;
    // Computing bound for C
    _156.d0 = x;
    if (x > 0) 
    goto _jump2556;
    fail_assertion("non-positive loop bound");
    _jump2556:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= x;
    _157 *= sizeof(bool);
    _156.data = jpl_alloc(_157);
    int64_t _158 = 0; // C
    _jump2557:; // Begin body of loop
    if (m >= 0)
    goto _jump2558;
    fail_assertion("negative array index");
    _jump2558:;
    if (m < p.d0)
    goto _jump2559;
    fail_assertion("index too large");
    _jump2559:;
    int64_t _159 = 0;
    _159 *= p.d0;
    _159 += m;
    _a3_bool _160 = p.data[_159];
    int64_t _161 = -x;
    int64_t _162 = 759;
    if (_158 >= 0)
    goto _jump2560;
    fail_assertion("negative array index");
    _jump2560:;
    if (_158 < _160.d0)
    goto _jump2561;
    fail_assertion("index too large");
    _jump2561:;
    if (_161 >= 0)
    goto _jump2562;
    fail_assertion("negative array index");
    _jump2562:;
    if (_161 < _160.d1)
    goto _jump2563;
    fail_assertion("index too large");
    _jump2563:;
    if (_162 >= 0)
    goto _jump2564;
    fail_assertion("negative array index");
    _jump2564:;
    if (_162 < _160.d2)
    goto _jump2565;
    fail_assertion("index too large");
    _jump2565:;
    int64_t _163 = 0;
    _163 *= _160.d0;
    _163 += _158;
    _163 *= _160.d1;
    _163 += _161;
    _163 *= _160.d2;
    _163 += _162;
    bool _164 = _160.data[_163];
    int64_t _165 = 0;
    _165 *= _156.d0;
    _165 += _158;
    _156.data[_165] = _164;
    _158++;
    if (_158 < x)
    goto _jump2557;
    // End body of loop
    _a1_int64_t _166;
    // Computing bound for C
    _166.d0 = u;
    if (u > 0) 
    goto _jump2566;
    fail_assertion("non-positive loop bound");
    _jump2566:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= u;
    _167 *= sizeof(int64_t);
    _166.data = jpl_alloc(_167);
    int64_t _168 = 0; // C
    _jump2567:; // Begin body of loop
    int64_t _169 = 0;
    _169 *= _166.d0;
    _169 += _168;
    _166.data[_169] = y;
    _168++;
    if (_168 < u)
    goto _jump2567;
    // End body of loop
    if (r >= 0)
    goto _jump2568;
    fail_assertion("negative array index");
    _jump2568:;
    if (r < _166.d0)
    goto _jump2569;
    fail_assertion("index too large");
    _jump2569:;
    int64_t _170 = 0;
    _170 *= _166.d0;
    _170 += r;
    int64_t _171 = _166.data[_170];
    if (_171 >= 0)
    goto _jump2570;
    fail_assertion("negative array index");
    _jump2570:;
    if (_171 < _156.d0)
    goto _jump2571;
    fail_assertion("index too large");
    _jump2571:;
    int64_t _172 = 0;
    _172 *= _156.d0;
    _172 += _171;
    bool _173 = _156.data[_172];
    double _174 = 88.0;
    bool _175 = j == _174;
    bool _177 = false;
    bool _176 = _177;
    if (0 != _177)
    goto _jump2572;
    double _178 = n + h;
    double _179;
    // Computing bound for C
    if (x > 0) 
    goto _jump2573;
    fail_assertion("non-positive loop bound");
    _jump2573:;
    // Computing bound for D
    if (x > 0) 
    goto _jump2574;
    fail_assertion("non-positive loop bound");
    _jump2574:;
    _179 = 0;
    int64_t _180 = 0; // D
    int64_t _181 = 0; // C
    _jump2575:; // Begin body of loop
    _179 += n;
    _180++;
    if (_180 < x)
    goto _jump2575;
    _180 = 0;
    _181++;
    if (_181 < x)
    goto _jump2575;
    // End body of loop
    bool _182 = _178 < _179;
    _176 = _182;
    _jump2572:;
    _a1_bool _183;
    _183.d0 = 3;
    _183.data = jpl_alloc(sizeof(bool) * 3);
    _183.data[0] = _173;
    _183.data[1] = _175;
    _183.data[2] = _176;
    _149 = _183;
    _jump2555:;
    _a1__a1_bool _184;
    _184.d0 = 3;
    _184.data = jpl_alloc(sizeof(_a1_bool) * 3);
    _184.data[0] = a;
    _184.data[1] = _149;
    _184.data[2] = a;
    _a1__a3_bool _185;
    // Computing bound for D
    _185.d0 = r;
    if (r > 0) 
    goto _jump2576;
    fail_assertion("non-positive loop bound");
    _jump2576:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= r;
    _186 *= sizeof(_a3_bool);
    _185.data = jpl_alloc(_186);
    int64_t _187 = 0; // D
    _jump2577:; // Begin body of loop
    _a2__a3_bool _188;
    // Computing bound for E
    int64_t _189;
    // Computing bound for E
    if (l > 0) 
    goto _jump2578;
    fail_assertion("non-positive loop bound");
    _jump2578:;
    // Computing bound for F
    if (y > 0) 
    goto _jump2579;
    fail_assertion("non-positive loop bound");
    _jump2579:;
    // Computing bound for G
    if (y > 0) 
    goto _jump2580;
    fail_assertion("non-positive loop bound");
    _jump2580:;
    _189 = 0;
    int64_t _190 = 0; // G
    int64_t _191 = 0; // F
    int64_t _192 = 0; // E
    _jump2581:; // Begin body of loop
    _189 += x;
    _190++;
    if (_190 < y)
    goto _jump2581;
    _190 = 0;
    _191++;
    if (_191 < y)
    goto _jump2581;
    _191 = 0;
    _192++;
    if (_192 < l)
    goto _jump2581;
    // End body of loop
    int64_t _193 = -_189;
    _188.d0 = _193;
    if (_193 > 0) 
    goto _jump2582;
    fail_assertion("non-positive loop bound");
    _jump2582:;
    // Computing bound for F
    _188.d1 = y;
    if (y > 0) 
    goto _jump2583;
    fail_assertion("non-positive loop bound");
    _jump2583:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= _193;
    _194 *= y;
    _194 *= sizeof(_a3_bool);
    _188.data = jpl_alloc(_194);
    int64_t _195 = 0; // F
    int64_t _196 = 0; // E
    _jump2584:; // Begin body of loop
    _a3_bool _197;
    // Computing bound for G
    _197.d0 = y;
    if (y > 0) 
    goto _jump2585;
    fail_assertion("non-positive loop bound");
    _jump2585:;
    // Computing bound for H
    int64_t _198 = 882;
    _197.d1 = _198;
    if (_198 > 0) 
    goto _jump2586;
    fail_assertion("non-positive loop bound");
    _jump2586:;
    // Computing bound for I
    _197.d2 = A;
    if (A > 0) 
    goto _jump2587;
    fail_assertion("non-positive loop bound");
    _jump2587:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= y;
    _199 *= _198;
    _199 *= A;
    _199 *= sizeof(bool);
    _197.data = jpl_alloc(_199);
    int64_t _200 = 0; // I
    int64_t _201 = 0; // H
    int64_t _202 = 0; // G
    _jump2588:; // Begin body of loop
    bool _203 = _202 == v;
    int64_t _204 = 0;
    _204 *= _197.d0;
    _204 += _202;
    _204 *= _197.d1;
    _204 += _201;
    _204 *= _197.d2;
    _204 += _200;
    _197.data[_204] = _203;
    _200++;
    if (_200 < A)
    goto _jump2588;
    _200 = 0;
    _201++;
    if (_201 < _198)
    goto _jump2588;
    _201 = 0;
    _202++;
    if (_202 < y)
    goto _jump2588;
    // End body of loop
    int64_t _205 = 0;
    _205 *= _188.d0;
    _205 += _196;
    _205 *= _188.d1;
    _205 += _195;
    _188.data[_205] = _197;
    _195++;
    if (_195 < y)
    goto _jump2584;
    _195 = 0;
    _196++;
    if (_196 < _193)
    goto _jump2584;
    // End body of loop
    int64_t _206 = 750;
    if (l >= 0)
    goto _jump2589;
    fail_assertion("negative array index");
    _jump2589:;
    if (l < _188.d0)
    goto _jump2590;
    fail_assertion("index too large");
    _jump2590:;
    if (_206 >= 0)
    goto _jump2591;
    fail_assertion("negative array index");
    _jump2591:;
    if (_206 < _188.d1)
    goto _jump2592;
    fail_assertion("index too large");
    _jump2592:;
    int64_t _207 = 0;
    _207 *= _188.d0;
    _207 += l;
    _207 *= _188.d1;
    _207 += _206;
    _a3_bool _208 = _188.data[_207];
    int64_t _209 = 0;
    _209 *= _185.d0;
    _209 += _187;
    _185.data[_209] = _208;
    _187++;
    if (_187 < r)
    goto _jump2577;
    // End body of loop
    _a1__a1__a3_bool _210;
    _210.d0 = 2;
    _210.data = jpl_alloc(sizeof(_a1__a3_bool) * 2);
    _210.data[0] = p;
    _210.data[1] = _185;
    if (u >= 0)
    goto _jump2593;
    fail_assertion("negative array index");
    _jump2593:;
    if (u < _210.d0)
    goto _jump2594;
    fail_assertion("index too large");
    _jump2594:;
    int64_t _211 = 0;
    _211 *= _210.d0;
    _211 += u;
    _a1__a3_bool _212 = _210.data[_211];
    bool _213;
    if (!g)
    goto _jump2595;
    bool _214 = r != y;
    _213 = _214;
    goto _jump2596;
    _jump2595:;
    _a1_int64_t _215;
    // Computing bound for F
    _215.d0 = v;
    if (v > 0) 
    goto _jump2597;
    fail_assertion("non-positive loop bound");
    _jump2597:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= v;
    _216 *= sizeof(int64_t);
    _215.data = jpl_alloc(_216);
    int64_t _217 = 0; // F
    _jump2598:; // Begin body of loop
    int64_t _218 = -v;
    int64_t _219 = 0;
    _219 *= _215.d0;
    _219 += _217;
    _215.data[_219] = _218;
    _217++;
    if (_217 < v)
    goto _jump2598;
    // End body of loop
    int64_t _220 = -y;
    if (_220 >= 0)
    goto _jump2599;
    fail_assertion("negative array index");
    _jump2599:;
    if (_220 < _215.d0)
    goto _jump2600;
    fail_assertion("index too large");
    _jump2600:;
    int64_t _221 = 0;
    _221 *= _215.d0;
    _221 += _220;
    int64_t _222 = _215.data[_221];
    bool _223 = _222 == l;
    _a1_bool _224;
    if (!_223)
    goto _jump2601;
    if (r >= 0)
    goto _jump2602;
    fail_assertion("negative array index");
    _jump2602:;
    if (r < a.d0)
    goto _jump2603;
    fail_assertion("index too large");
    _jump2603:;
    int64_t _225 = 0;
    _225 *= a.d0;
    _225 += r;
    bool _226 = a.data[_225];
    bool _227 = !_226;
    _a1_bool _228;
    _228.d0 = 1;
    _228.data = jpl_alloc(sizeof(bool) * 1);
    _228.data[0] = _227;
    _224 = _228;
    goto _jump2604;
    _jump2601:;
    _a2__a1_bool _229;
    if (!g)
    goto _jump2605;
    _a2__a1_bool _230;
    // Computing bound for F
    _230.d0 = y;
    if (y > 0) 
    goto _jump2606;
    fail_assertion("non-positive loop bound");
    _jump2606:;
    // Computing bound for G
    int64_t _231 = -u;
    _230.d1 = _231;
    if (_231 > 0) 
    goto _jump2607;
    fail_assertion("non-positive loop bound");
    _jump2607:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= y;
    _232 *= _231;
    _232 *= sizeof(_a1_bool);
    _230.data = jpl_alloc(_232);
    int64_t _233 = 0; // G
    int64_t _234 = 0; // F
    _jump2608:; // Begin body of loop
    _a1_bool _235;
    _235.d0 = 2;
    _235.data = jpl_alloc(sizeof(bool) * 2);
    _235.data[0] = g;
    _235.data[1] = g;
    int64_t _236 = 0;
    _236 *= _230.d0;
    _236 += _234;
    _236 *= _230.d1;
    _236 += _233;
    _230.data[_236] = _235;
    _233++;
    if (_233 < _231)
    goto _jump2608;
    _233 = 0;
    _234++;
    if (_234 < y)
    goto _jump2608;
    // End body of loop
    _229 = _230;
    goto _jump2609;
    _jump2605:;
    _a2__a1_bool _237;
    // Computing bound for F
    int64_t _238 = x + r;
    _237.d0 = _238;
    if (_238 > 0) 
    goto _jump2610;
    fail_assertion("non-positive loop bound");
    _jump2610:;
    // Computing bound for G
    _237.d1 = l;
    if (l > 0) 
    goto _jump2611;
    fail_assertion("non-positive loop bound");
    _jump2611:;
    // Computing total size of heap memory to allocate
    int64_t _239 = 1;
    _239 *= _238;
    _239 *= l;
    _239 *= sizeof(_a1_bool);
    _237.data = jpl_alloc(_239);
    int64_t _240 = 0; // G
    int64_t _241 = 0; // F
    _jump2612:; // Begin body of loop
    _a1_bool _242;
    // Computing bound for H
    _242.d0 = y;
    if (y > 0) 
    goto _jump2613;
    fail_assertion("non-positive loop bound");
    _jump2613:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= y;
    _243 *= sizeof(bool);
    _242.data = jpl_alloc(_243);
    int64_t _244 = 0; // H
    _jump2614:; // Begin body of loop
    bool _245 = true;
    int64_t _246 = 0;
    _246 *= _242.d0;
    _246 += _244;
    _242.data[_246] = _245;
    _244++;
    if (_244 < y)
    goto _jump2614;
    // End body of loop
    int64_t _247 = 0;
    _247 *= _237.d0;
    _247 += _241;
    _247 *= _237.d1;
    _247 += _240;
    _237.data[_247] = _242;
    _240++;
    if (_240 < l)
    goto _jump2612;
    _240 = 0;
    _241++;
    if (_241 < _238)
    goto _jump2612;
    // End body of loop
    _229 = _237;
    _jump2609:;
    int64_t _248 = r + u;
    int64_t _249 = _248 % m;
    int64_t _250 = _249 / y;
    if (x >= 0)
    goto _jump2615;
    fail_assertion("negative array index");
    _jump2615:;
    if (x < _229.d0)
    goto _jump2616;
    fail_assertion("index too large");
    _jump2616:;
    if (_250 >= 0)
    goto _jump2617;
    fail_assertion("negative array index");
    _jump2617:;
    if (_250 < _229.d1)
    goto _jump2618;
    fail_assertion("index too large");
    _jump2618:;
    int64_t _251 = 0;
    _251 *= _229.d0;
    _251 += x;
    _251 *= _229.d1;
    _251 += _250;
    _a1_bool _252 = _229.data[_251];
    _224 = _252;
    _jump2604:;
    if (m >= 0)
    goto _jump2619;
    fail_assertion("negative array index");
    _jump2619:;
    if (m < _224.d0)
    goto _jump2620;
    fail_assertion("index too large");
    _jump2620:;
    int64_t _253 = 0;
    _253 *= _224.d0;
    _253 += m;
    bool _254 = _224.data[_253];
    _213 = _254;
    _jump2596:;
    int64_t _255 = 864;
    bool _256 = s != _255;
    if (0 != _256)
    goto _jump2621;
    fail_assertion("G");
    _jump2621:;
    bool _257 = !g;
    _a3_double _258;
    if (!_257)
    goto _jump2622;
    bool _259 = !_213;
    _a3_double _260;
    if (!_259)
    goto _jump2623;
    int64_t _261;
    if (!_213)
    goto _jump2624;
    _a3_rgba _262;
    // Computing bound for G
    _262.d0 = m;
    if (m > 0) 
    goto _jump2625;
    fail_assertion("non-positive loop bound");
    _jump2625:;
    // Computing bound for H
    _262.d1 = _212.d0;
    if (_212.d0 > 0) 
    goto _jump2626;
    fail_assertion("non-positive loop bound");
    _jump2626:;
    // Computing bound for I
    _262.d2 = r;
    if (r > 0) 
    goto _jump2627;
    fail_assertion("non-positive loop bound");
    _jump2627:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= m;
    _263 *= _212.d0;
    _263 *= r;
    _263 *= sizeof(rgba);
    _262.data = jpl_alloc(_263);
    int64_t _264 = 0; // I
    int64_t _265 = 0; // H
    int64_t _266 = 0; // G
    _jump2628:; // Begin body of loop
    double _267 = 60.0;
    double _268 = 63.0;
    rgba _269 = { n, _267, _268, j };
    int64_t _270 = 0;
    _270 *= _262.d0;
    _270 += _266;
    _270 *= _262.d1;
    _270 += _265;
    _270 *= _262.d2;
    _270 += _264;
    _262.data[_270] = _269;
    _264++;
    if (_264 < r)
    goto _jump2628;
    _264 = 0;
    _265++;
    if (_265 < _212.d0)
    goto _jump2628;
    _265 = 0;
    _266++;
    if (_266 < m)
    goto _jump2628;
    // End body of loop
    _a1_bool _271;
    _271.d0 = 1;
    _271.data = jpl_alloc(sizeof(bool) * 1);
    _271.data[0] = _213;
    _a2_rgba _272;
    // Computing bound for G
    _272.d0 = x;
    if (x > 0) 
    goto _jump2629;
    fail_assertion("non-positive loop bound");
    _jump2629:;
    // Computing bound for H
    _272.d1 = y;
    if (y > 0) 
    goto _jump2630;
    fail_assertion("non-positive loop bound");
    _jump2630:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= x;
    _273 *= y;
    _273 *= sizeof(rgba);
    _272.data = jpl_alloc(_273);
    int64_t _274 = 0; // H
    int64_t _275 = 0; // G
    _jump2631:; // Begin body of loop
    int64_t _276 = 0;
    _276 *= _272.d0;
    _276 += _275;
    _276 *= _272.d1;
    _276 += _274;
    _272.data[_276] = d;
    _274++;
    if (_274 < y)
    goto _jump2631;
    _274 = 0;
    _275++;
    if (_275 < x)
    goto _jump2631;
    // End body of loop
    int64_t _277 = b(_262, _271, _272);
    _261 = _277;
    goto _jump2632;
    _jump2624:;
    _261 = v;
    _jump2632:;
    _a3_double _278 = z(_261);
    _260 = _278;
    goto _jump2633;
    _jump2623:;
    _a3_double _279;
    // Computing bound for G
    int64_t _280;
    // Computing bound for G
    int64_t _281 = 969;
    if (_281 > 0) 
    goto _jump2634;
    fail_assertion("non-positive loop bound");
    _jump2634:;
    // Computing bound for H
    _a1_int64_t _282;
    // Computing bound for G
    _282.d0 = l;
    if (l > 0) 
    goto _jump2635;
    fail_assertion("non-positive loop bound");
    _jump2635:;
    // Computing total size of heap memory to allocate
    int64_t _283 = 1;
    _283 *= l;
    _283 *= sizeof(int64_t);
    _282.data = jpl_alloc(_283);
    int64_t _284 = 0; // G
    _jump2636:; // Begin body of loop
    int64_t _285 = 0;
    _285 *= _282.d0;
    _285 += _284;
    _282.data[_285] = l;
    _284++;
    if (_284 < l)
    goto _jump2636;
    // End body of loop
    int64_t _286 = 994;
    if (_286 >= 0)
    goto _jump2637;
    fail_assertion("negative array index");
    _jump2637:;
    if (_286 < _282.d0)
    goto _jump2638;
    fail_assertion("index too large");
    _jump2638:;
    int64_t _287 = 0;
    _287 *= _282.d0;
    _287 += _286;
    int64_t _288 = _282.data[_287];
    if (_288 > 0) 
    goto _jump2639;
    fail_assertion("non-positive loop bound");
    _jump2639:;
    _280 = 0;
    int64_t _289 = 0; // H
    int64_t _290 = 0; // G
    _jump2640:; // Begin body of loop
    _280 += y;
    _289++;
    if (_289 < _288)
    goto _jump2640;
    _289 = 0;
    _290++;
    if (_290 < _281)
    goto _jump2640;
    // End body of loop
    int64_t _291 = -_280;
    _279.d0 = _291;
    if (_291 > 0) 
    goto _jump2641;
    fail_assertion("non-positive loop bound");
    _jump2641:;
    // Computing bound for H
    _279.d1 = l;
    if (l > 0) 
    goto _jump2642;
    fail_assertion("non-positive loop bound");
    _jump2642:;
    // Computing bound for I
    _279.d2 = v;
    if (v > 0) 
    goto _jump2643;
    fail_assertion("non-positive loop bound");
    _jump2643:;
    // Computing total size of heap memory to allocate
    int64_t _292 = 1;
    _292 *= _291;
    _292 *= l;
    _292 *= v;
    _292 *= sizeof(double);
    _279.data = jpl_alloc(_292);
    int64_t _293 = 0; // I
    int64_t _294 = 0; // H
    int64_t _295 = 0; // G
    _jump2644:; // Begin body of loop
    int64_t _296 = 0;
    _296 *= _279.d0;
    _296 += _295;
    _296 *= _279.d1;
    _296 += _294;
    _296 *= _279.d2;
    _296 += _293;
    _279.data[_296] = n;
    _293++;
    if (_293 < v)
    goto _jump2644;
    _293 = 0;
    _294++;
    if (_294 < l)
    goto _jump2644;
    _294 = 0;
    _295++;
    if (_295 < _291)
    goto _jump2644;
    // End body of loop
    _260 = _279;
    _jump2633:;
    _258 = _260;
    goto _jump2645;
    _jump2622:;
    bool _297 = false;
    bool _298 = !_297;
    _a3__a3_double _299;
    if (!_298)
    goto _jump2646;
    int64_t _300 = 943;
    bool _301 = y < _300;
    _a3__a3_double _302;
    if (!_301)
    goto _jump2647;
    bool _303 = h >= j;
    _a3__a3_double _304;
    if (!_303)
    goto _jump2648;
    _a3__a3_double _305;
    // Computing bound for G
    _305.d0 = _212.d0;
    if (_212.d0 > 0) 
    goto _jump2649;
    fail_assertion("non-positive loop bound");
    _jump2649:;
    // Computing bound for H
    int64_t _306 = 332;
    _305.d1 = _306;
    if (_306 > 0) 
    goto _jump2650;
    fail_assertion("non-positive loop bound");
    _jump2650:;
    // Computing bound for I
    _305.d2 = s;
    if (s > 0) 
    goto _jump2651;
    fail_assertion("non-positive loop bound");
    _jump2651:;
    // Computing total size of heap memory to allocate
    int64_t _307 = 1;
    _307 *= _212.d0;
    _307 *= _306;
    _307 *= s;
    _307 *= sizeof(_a3_double);
    _305.data = jpl_alloc(_307);
    int64_t _308 = 0; // I
    int64_t _309 = 0; // H
    int64_t _310 = 0; // G
    _jump2652:; // Begin body of loop
    _a3_double _311 = z(u);
    int64_t _312 = 0;
    _312 *= _305.d0;
    _312 += _310;
    _312 *= _305.d1;
    _312 += _309;
    _312 *= _305.d2;
    _312 += _308;
    _305.data[_312] = _311;
    _308++;
    if (_308 < s)
    goto _jump2652;
    _308 = 0;
    _309++;
    if (_309 < _306)
    goto _jump2652;
    _309 = 0;
    _310++;
    if (_310 < _212.d0)
    goto _jump2652;
    // End body of loop
    _304 = _305;
    goto _jump2653;
    _jump2648:;
    _a3__a3_double _313;
    // Computing bound for G
    _313.d0 = m;
    if (m > 0) 
    goto _jump2654;
    fail_assertion("non-positive loop bound");
    _jump2654:;
    // Computing bound for H
    _313.d1 = s;
    if (s > 0) 
    goto _jump2655;
    fail_assertion("non-positive loop bound");
    _jump2655:;
    // Computing bound for I
    _313.d2 = y;
    if (y > 0) 
    goto _jump2656;
    fail_assertion("non-positive loop bound");
    _jump2656:;
    // Computing total size of heap memory to allocate
    int64_t _314 = 1;
    _314 *= m;
    _314 *= s;
    _314 *= y;
    _314 *= sizeof(_a3_double);
    _313.data = jpl_alloc(_314);
    int64_t _315 = 0; // I
    int64_t _316 = 0; // H
    int64_t _317 = 0; // G
    _jump2657:; // Begin body of loop
    _a3_double _318 = z(s);
    int64_t _319 = 0;
    _319 *= _313.d0;
    _319 += _317;
    _319 *= _313.d1;
    _319 += _316;
    _319 *= _313.d2;
    _319 += _315;
    _313.data[_319] = _318;
    _315++;
    if (_315 < y)
    goto _jump2657;
    _315 = 0;
    _316++;
    if (_316 < s)
    goto _jump2657;
    _316 = 0;
    _317++;
    if (_317 < m)
    goto _jump2657;
    // End body of loop
    _304 = _313;
    _jump2653:;
    _302 = _304;
    goto _jump2658;
    _jump2647:;
    _a3__a3_double _320;
    // Computing bound for G
    int64_t _321 = 284;
    _320.d0 = _321;
    if (_321 > 0) 
    goto _jump2659;
    fail_assertion("non-positive loop bound");
    _jump2659:;
    // Computing bound for H
    _320.d1 = r;
    if (r > 0) 
    goto _jump2660;
    fail_assertion("non-positive loop bound");
    _jump2660:;
    // Computing bound for I
    _320.d2 = A;
    if (A > 0) 
    goto _jump2661;
    fail_assertion("non-positive loop bound");
    _jump2661:;
    // Computing total size of heap memory to allocate
    int64_t _322 = 1;
    _322 *= _321;
    _322 *= r;
    _322 *= A;
    _322 *= sizeof(_a3_double);
    _320.data = jpl_alloc(_322);
    int64_t _323 = 0; // I
    int64_t _324 = 0; // H
    int64_t _325 = 0; // G
    _jump2662:; // Begin body of loop
    int64_t _326 = -v;
    _a3_double _327 = z(_326);
    int64_t _328 = 0;
    _328 *= _320.d0;
    _328 += _325;
    _328 *= _320.d1;
    _328 += _324;
    _328 *= _320.d2;
    _328 += _323;
    _320.data[_328] = _327;
    _323++;
    if (_323 < A)
    goto _jump2662;
    _323 = 0;
    _324++;
    if (_324 < r)
    goto _jump2662;
    _324 = 0;
    _325++;
    if (_325 < _321)
    goto _jump2662;
    // End body of loop
    _302 = _320;
    _jump2658:;
    _299 = _302;
    goto _jump2663;
    _jump2646:;
    _a3__a3_double _329;
    // Computing bound for G
    bool _330 = false;
    int64_t _331;
    if (!_330)
    goto _jump2664;
    _331 = s;
    goto _jump2665;
    _jump2664:;
    _331 = u;
    _jump2665:;
    int64_t _332 = -_331;
    _329.d0 = _332;
    if (_332 > 0) 
    goto _jump2666;
    fail_assertion("non-positive loop bound");
    _jump2666:;
    // Computing bound for H
    int64_t _333 = 425;
    _329.d1 = _333;
    if (_333 > 0) 
    goto _jump2667;
    fail_assertion("non-positive loop bound");
    _jump2667:;
    // Computing bound for I
    int64_t _334;
    // Computing bound for G
    if (u > 0) 
    goto _jump2668;
    fail_assertion("non-positive loop bound");
    _jump2668:;
    // Computing bound for H
    int64_t _335 = 61;
    if (_335 > 0) 
    goto _jump2669;
    fail_assertion("non-positive loop bound");
    _jump2669:;
    _334 = 0;
    int64_t _336 = 0; // H
    int64_t _337 = 0; // G
    _jump2670:; // Begin body of loop
    _334 += v;
    _336++;
    if (_336 < _335)
    goto _jump2670;
    _336 = 0;
    _337++;
    if (_337 < u)
    goto _jump2670;
    // End body of loop
    int64_t _338 = -_334;
    int64_t _339 = _338 - u;
    _329.d2 = _339;
    if (_339 > 0) 
    goto _jump2671;
    fail_assertion("non-positive loop bound");
    _jump2671:;
    // Computing total size of heap memory to allocate
    int64_t _340 = 1;
    _340 *= _332;
    _340 *= _333;
    _340 *= _339;
    _340 *= sizeof(_a3_double);
    _329.data = jpl_alloc(_340);
    int64_t _341 = 0; // I
    int64_t _342 = 0; // H
    int64_t _343 = 0; // G
    _jump2672:; // Begin body of loop
    _a3_double _344;
    // Computing bound for J
    int64_t _345;
    // Computing bound for J
    if (_341 > 0) 
    goto _jump2673;
    fail_assertion("non-positive loop bound");
    _jump2673:;
    // Computing bound for K
    if (v > 0) 
    goto _jump2674;
    fail_assertion("non-positive loop bound");
    _jump2674:;
    _345 = 0;
    int64_t _346 = 0; // K
    int64_t _347 = 0; // J
    _jump2675:; // Begin body of loop
    _345 += _343;
    _346++;
    if (_346 < v)
    goto _jump2675;
    _346 = 0;
    _347++;
    if (_347 < _341)
    goto _jump2675;
    // End body of loop
    _344.d0 = _345;
    if (_345 > 0) 
    goto _jump2676;
    fail_assertion("non-positive loop bound");
    _jump2676:;
    // Computing bound for K
    _344.d1 = y;
    if (y > 0) 
    goto _jump2677;
    fail_assertion("non-positive loop bound");
    _jump2677:;
    // Computing bound for L
    _344.d2 = y;
    if (y > 0) 
    goto _jump2678;
    fail_assertion("non-positive loop bound");
    _jump2678:;
    // Computing total size of heap memory to allocate
    int64_t _348 = 1;
    _348 *= _345;
    _348 *= y;
    _348 *= y;
    _348 *= sizeof(double);
    _344.data = jpl_alloc(_348);
    int64_t _349 = 0; // L
    int64_t _350 = 0; // K
    int64_t _351 = 0; // J
    _jump2679:; // Begin body of loop
    double _352;
    // Computing bound for M
    if (x > 0) 
    goto _jump2680;
    fail_assertion("non-positive loop bound");
    _jump2680:;
    // Computing bound for N
    if (r > 0) 
    goto _jump2681;
    fail_assertion("non-positive loop bound");
    _jump2681:;
    // Computing bound for O
    if (_343 > 0) 
    goto _jump2682;
    fail_assertion("non-positive loop bound");
    _jump2682:;
    _352 = 0;
    int64_t _353 = 0; // O
    int64_t _354 = 0; // N
    int64_t _355 = 0; // M
    _jump2683:; // Begin body of loop
    double _356 = d.a;
    _352 += _356;
    _353++;
    if (_353 < _343)
    goto _jump2683;
    _353 = 0;
    _354++;
    if (_354 < r)
    goto _jump2683;
    _354 = 0;
    _355++;
    if (_355 < x)
    goto _jump2683;
    // End body of loop
    int64_t _357 = 0;
    _357 *= _344.d0;
    _357 += _351;
    _357 *= _344.d1;
    _357 += _350;
    _357 *= _344.d2;
    _357 += _349;
    _344.data[_357] = _352;
    _349++;
    if (_349 < y)
    goto _jump2679;
    _349 = 0;
    _350++;
    if (_350 < y)
    goto _jump2679;
    _350 = 0;
    _351++;
    if (_351 < _345)
    goto _jump2679;
    // End body of loop
    int64_t _358 = 0;
    _358 *= _329.d0;
    _358 += _343;
    _358 *= _329.d1;
    _358 += _342;
    _358 *= _329.d2;
    _358 += _341;
    _329.data[_358] = _344;
    _341++;
    if (_341 < _339)
    goto _jump2672;
    _341 = 0;
    _342++;
    if (_342 < _333)
    goto _jump2672;
    _342 = 0;
    _343++;
    if (_343 < _332)
    goto _jump2672;
    // End body of loop
    _299 = _329;
    _jump2663:;
    int64_t _359;
    // Computing bound for G
    if (y > 0) 
    goto _jump2684;
    fail_assertion("non-positive loop bound");
    _jump2684:;
    _359 = 0;
    int64_t _360 = 0; // G
    _jump2685:; // Begin body of loop
    _359 += r;
    _360++;
    if (_360 < y)
    goto _jump2685;
    // End body of loop
    if (_359 >= 0)
    goto _jump2686;
    fail_assertion("negative array index");
    _jump2686:;
    if (_359 < _299.d0)
    goto _jump2687;
    fail_assertion("index too large");
    _jump2687:;
    if (y >= 0)
    goto _jump2688;
    fail_assertion("negative array index");
    _jump2688:;
    if (y < _299.d1)
    goto _jump2689;
    fail_assertion("index too large");
    _jump2689:;
    if (r >= 0)
    goto _jump2690;
    fail_assertion("negative array index");
    _jump2690:;
    if (r < _299.d2)
    goto _jump2691;
    fail_assertion("index too large");
    _jump2691:;
    int64_t _361 = 0;
    _361 *= _299.d0;
    _361 += _359;
    _361 *= _299.d1;
    _361 += y;
    _361 *= _299.d2;
    _361 += r;
    _a3_double _362 = _299.data[_361];
    _258 = _362;
    _jump2645:;
    return _258;
}

bool A() {
    _a2__a3_bool _0;
    if (!g)
    goto _jump2692;
    bool _1 = A();
    bool _2 = !_1;
    bool _3 = !_2;
    _a2__a3_bool _4;
    if (!_3)
    goto _jump2693;
    _a2__a3_bool _5;
    // Computing bound for C
    _5.d0 = m;
    if (m > 0) 
    goto _jump2694;
    fail_assertion("non-positive loop bound");
    _jump2694:;
    // Computing bound for D
    int64_t _6;
    // Computing bound for C
    if (r > 0) 
    goto _jump2695;
    fail_assertion("non-positive loop bound");
    _jump2695:;
    // Computing bound for D
    if (r > 0) 
    goto _jump2696;
    fail_assertion("non-positive loop bound");
    _jump2696:;
    // Computing bound for E
    if (x > 0) 
    goto _jump2697;
    fail_assertion("non-positive loop bound");
    _jump2697:;
    _6 = 0;
    int64_t _7 = 0; // E
    int64_t _8 = 0; // D
    int64_t _9 = 0; // C
    _jump2698:; // Begin body of loop
    _6 += v;
    _7++;
    if (_7 < x)
    goto _jump2698;
    _7 = 0;
    _8++;
    if (_8 < r)
    goto _jump2698;
    _8 = 0;
    _9++;
    if (_9 < r)
    goto _jump2698;
    // End body of loop
    _5.d1 = _6;
    if (_6 > 0) 
    goto _jump2699;
    fail_assertion("non-positive loop bound");
    _jump2699:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= m;
    _10 *= _6;
    _10 *= sizeof(_a3_bool);
    _5.data = jpl_alloc(_10);
    int64_t _11 = 0; // D
    int64_t _12 = 0; // C
    _jump2700:; // Begin body of loop
    if (_12 >= 0)
    goto _jump2701;
    fail_assertion("negative array index");
    _jump2701:;
    if (_12 < p.d0)
    goto _jump2702;
    fail_assertion("index too large");
    _jump2702:;
    int64_t _13 = 0;
    _13 *= p.d0;
    _13 += _12;
    _a3_bool _14 = p.data[_13];
    int64_t _15 = 0;
    _15 *= _5.d0;
    _15 += _12;
    _15 *= _5.d1;
    _15 += _11;
    _5.data[_15] = _14;
    _11++;
    if (_11 < _6)
    goto _jump2700;
    _11 = 0;
    _12++;
    if (_12 < m)
    goto _jump2700;
    // End body of loop
    _4 = _5;
    goto _jump2703;
    _jump2693:;
    _a2__a3_bool _16;
    // Computing bound for C
    _16.d0 = m;
    if (m > 0) 
    goto _jump2704;
    fail_assertion("non-positive loop bound");
    _jump2704:;
    // Computing bound for D
    _16.d1 = l;
    if (l > 0) 
    goto _jump2705;
    fail_assertion("non-positive loop bound");
    _jump2705:;
    // Computing total size of heap memory to allocate
    int64_t _17 = 1;
    _17 *= m;
    _17 *= l;
    _17 *= sizeof(_a3_bool);
    _16.data = jpl_alloc(_17);
    int64_t _18 = 0; // D
    int64_t _19 = 0; // C
    _jump2706:; // Begin body of loop
    _a3_bool _20;
    // Computing bound for E
    _20.d0 = v;
    if (v > 0) 
    goto _jump2707;
    fail_assertion("non-positive loop bound");
    _jump2707:;
    // Computing bound for F
    int64_t _21 = u + u;
    _20.d1 = _21;
    if (_21 > 0) 
    goto _jump2708;
    fail_assertion("non-positive loop bound");
    _jump2708:;
    // Computing bound for G
    _20.d2 = m;
    if (m > 0) 
    goto _jump2709;
    fail_assertion("non-positive loop bound");
    _jump2709:;
    // Computing total size of heap memory to allocate
    int64_t _22 = 1;
    _22 *= v;
    _22 *= _21;
    _22 *= m;
    _22 *= sizeof(bool);
    _20.data = jpl_alloc(_22);
    int64_t _23 = 0; // G
    int64_t _24 = 0; // F
    int64_t _25 = 0; // E
    _jump2710:; // Begin body of loop
    int64_t _26 = 529;
    bool _27 = _26 != u;
    int64_t _28 = 0;
    _28 *= _20.d0;
    _28 += _25;
    _28 *= _20.d1;
    _28 += _24;
    _28 *= _20.d2;
    _28 += _23;
    _20.data[_28] = _27;
    _23++;
    if (_23 < m)
    goto _jump2710;
    _23 = 0;
    _24++;
    if (_24 < _21)
    goto _jump2710;
    _24 = 0;
    _25++;
    if (_25 < v)
    goto _jump2710;
    // End body of loop
    int64_t _29 = 0;
    _29 *= _16.d0;
    _29 += _19;
    _29 *= _16.d1;
    _29 += _18;
    _16.data[_29] = _20;
    _18++;
    if (_18 < l)
    goto _jump2706;
    _18 = 0;
    _19++;
    if (_19 < m)
    goto _jump2706;
    // End body of loop
    _4 = _16;
    _jump2703:;
    _0 = _4;
    goto _jump2711;
    _jump2692:;
    _a2__a3_bool _30;
    // Computing bound for C
    int64_t _31 = 486;
    _30.d0 = _31;
    if (_31 > 0) 
    goto _jump2712;
    fail_assertion("non-positive loop bound");
    _jump2712:;
    // Computing bound for D
    _30.d1 = m;
    if (m > 0) 
    goto _jump2713;
    fail_assertion("non-positive loop bound");
    _jump2713:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _31;
    _32 *= m;
    _32 *= sizeof(_a3_bool);
    _30.data = jpl_alloc(_32);
    int64_t _33 = 0; // D
    int64_t _34 = 0; // C
    _jump2714:; // Begin body of loop
    _a3_bool _35;
    if (!g)
    goto _jump2715;
    _a3_bool _36;
    // Computing bound for E
    _36.d0 = x;
    if (x > 0) 
    goto _jump2716;
    fail_assertion("non-positive loop bound");
    _jump2716:;
    // Computing bound for F
    _36.d1 = l;
    if (l > 0) 
    goto _jump2717;
    fail_assertion("non-positive loop bound");
    _jump2717:;
    // Computing bound for G
    int64_t _37 = -r;
    _36.d2 = _37;
    if (_37 > 0) 
    goto _jump2718;
    fail_assertion("non-positive loop bound");
    _jump2718:;
    // Computing total size of heap memory to allocate
    int64_t _38 = 1;
    _38 *= x;
    _38 *= l;
    _38 *= _37;
    _38 *= sizeof(bool);
    _36.data = jpl_alloc(_38);
    int64_t _39 = 0; // G
    int64_t _40 = 0; // F
    int64_t _41 = 0; // E
    _jump2719:; // Begin body of loop
    bool _42 = A();
    int64_t _43 = 0;
    _43 *= _36.d0;
    _43 += _41;
    _43 *= _36.d1;
    _43 += _40;
    _43 *= _36.d2;
    _43 += _39;
    _36.data[_43] = _42;
    _39++;
    if (_39 < _37)
    goto _jump2719;
    _39 = 0;
    _40++;
    if (_40 < l)
    goto _jump2719;
    _40 = 0;
    _41++;
    if (_41 < x)
    goto _jump2719;
    // End body of loop
    _35 = _36;
    goto _jump2720;
    _jump2715:;
    _a3_bool _44;
    if (!g)
    goto _jump2721;
    _a3_bool _45;
    // Computing bound for E
    _45.d0 = l;
    if (l > 0) 
    goto _jump2722;
    fail_assertion("non-positive loop bound");
    _jump2722:;
    // Computing bound for F
    _45.d1 = y;
    if (y > 0) 
    goto _jump2723;
    fail_assertion("non-positive loop bound");
    _jump2723:;
    // Computing bound for G
    _45.d2 = _34;
    if (_34 > 0) 
    goto _jump2724;
    fail_assertion("non-positive loop bound");
    _jump2724:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= l;
    _46 *= y;
    _46 *= _34;
    _46 *= sizeof(bool);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // G
    int64_t _48 = 0; // F
    int64_t _49 = 0; // E
    _jump2725:; // Begin body of loop
    int64_t _50 = 0;
    _50 *= _45.d0;
    _50 += _49;
    _50 *= _45.d1;
    _50 += _48;
    _50 *= _45.d2;
    _50 += _47;
    _45.data[_50] = g;
    _47++;
    if (_47 < _34)
    goto _jump2725;
    _47 = 0;
    _48++;
    if (_48 < y)
    goto _jump2725;
    _48 = 0;
    _49++;
    if (_49 < l)
    goto _jump2725;
    // End body of loop
    _44 = _45;
    goto _jump2726;
    _jump2721:;
    _a3_bool _51;
    // Computing bound for E
    _51.d0 = l;
    if (l > 0) 
    goto _jump2727;
    fail_assertion("non-positive loop bound");
    _jump2727:;
    // Computing bound for F
    int64_t _52 = 829;
    _51.d1 = _52;
    if (_52 > 0) 
    goto _jump2728;
    fail_assertion("non-positive loop bound");
    _jump2728:;
    // Computing bound for G
    int64_t _53 = 686;
    _51.d2 = _53;
    if (_53 > 0) 
    goto _jump2729;
    fail_assertion("non-positive loop bound");
    _jump2729:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= l;
    _54 *= _52;
    _54 *= _53;
    _54 *= sizeof(bool);
    _51.data = jpl_alloc(_54);
    int64_t _55 = 0; // G
    int64_t _56 = 0; // F
    int64_t _57 = 0; // E
    _jump2730:; // Begin body of loop
    bool _58 = true;
    int64_t _59 = 0;
    _59 *= _51.d0;
    _59 += _57;
    _59 *= _51.d1;
    _59 += _56;
    _59 *= _51.d2;
    _59 += _55;
    _51.data[_59] = _58;
    _55++;
    if (_55 < _53)
    goto _jump2730;
    _55 = 0;
    _56++;
    if (_56 < _52)
    goto _jump2730;
    _56 = 0;
    _57++;
    if (_57 < l)
    goto _jump2730;
    // End body of loop
    _44 = _51;
    _jump2726:;
    _35 = _44;
    _jump2720:;
    int64_t _60 = 0;
    _60 *= _30.d0;
    _60 += _34;
    _60 *= _30.d1;
    _60 += _33;
    _30.data[_60] = _35;
    _33++;
    if (_33 < m)
    goto _jump2714;
    _33 = 0;
    _34++;
    if (_34 < _31)
    goto _jump2714;
    // End body of loop
    _0 = _30;
    _jump2711:;
    int64_t _61 = 712;
    if (_61 >= 0)
    goto _jump2731;
    fail_assertion("negative array index");
    _jump2731:;
    if (_61 < _0.d0)
    goto _jump2732;
    fail_assertion("index too large");
    _jump2732:;
    if (x >= 0)
    goto _jump2733;
    fail_assertion("negative array index");
    _jump2733:;
    if (x < _0.d1)
    goto _jump2734;
    fail_assertion("index too large");
    _jump2734:;
    int64_t _62 = 0;
    _62 *= _0.d0;
    _62 += _61;
    _62 *= _0.d1;
    _62 += x;
    _a3_bool _63 = _0.data[_62];
    e _64 = { _63 };
    rgba _65;
    if (!g)
    goto _jump2735;
    int64_t _66 = m + u;
    bool _67 = u != _66;
    rgba _68;
    if (!_67)
    goto _jump2736;
    bool _69 = false;
    rgba _70;
    if (!_69)
    goto _jump2737;
    double _71;
    // Computing bound for F
    if (m > 0) 
    goto _jump2738;
    fail_assertion("non-positive loop bound");
    _jump2738:;
    _71 = 0;
    int64_t _72 = 0; // F
    _jump2739:; // Begin body of loop
    _71 += j;
    _72++;
    if (_72 < m)
    goto _jump2739;
    // End body of loop
    _a2_double _73;
    // Computing bound for F
    _73.d0 = x;
    if (x > 0) 
    goto _jump2740;
    fail_assertion("non-positive loop bound");
    _jump2740:;
    // Computing bound for G
    _73.d1 = y;
    if (y > 0) 
    goto _jump2741;
    fail_assertion("non-positive loop bound");
    _jump2741:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= x;
    _74 *= y;
    _74 *= sizeof(double);
    _73.data = jpl_alloc(_74);
    int64_t _75 = 0; // G
    int64_t _76 = 0; // F
    _jump2742:; // Begin body of loop
    int64_t _77 = 0;
    _77 *= _73.d0;
    _77 += _76;
    _77 *= _73.d1;
    _77 += _75;
    _73.data[_77] = j;
    _75++;
    if (_75 < y)
    goto _jump2742;
    _75 = 0;
    _76++;
    if (_76 < x)
    goto _jump2742;
    // End body of loop
    if (y >= 0)
    goto _jump2743;
    fail_assertion("negative array index");
    _jump2743:;
    if (y < _73.d0)
    goto _jump2744;
    fail_assertion("index too large");
    _jump2744:;
    if (r >= 0)
    goto _jump2745;
    fail_assertion("negative array index");
    _jump2745:;
    if (r < _73.d1)
    goto _jump2746;
    fail_assertion("index too large");
    _jump2746:;
    int64_t _78 = 0;
    _78 *= _73.d0;
    _78 += y;
    _78 *= _73.d1;
    _78 += r;
    double _79 = _73.data[_78];
    double _80 = d.r;
    rgba _81 = { j, _71, _79, _80 };
    _70 = _81;
    goto _jump2747;
    _jump2737:;
    int64_t _82 = -m;
    int64_t _83;
    // Computing bound for F
    if (v > 0) 
    goto _jump2748;
    fail_assertion("non-positive loop bound");
    _jump2748:;
    // Computing bound for G
    if (l > 0) 
    goto _jump2749;
    fail_assertion("non-positive loop bound");
    _jump2749:;
    // Computing bound for H
    if (u > 0) 
    goto _jump2750;
    fail_assertion("non-positive loop bound");
    _jump2750:;
    _83 = 0;
    int64_t _84 = 0; // H
    int64_t _85 = 0; // G
    int64_t _86 = 0; // F
    _jump2751:; // Begin body of loop
    _83 += v;
    _84++;
    if (_84 < u)
    goto _jump2751;
    _84 = 0;
    _85++;
    if (_85 < l)
    goto _jump2751;
    _85 = 0;
    _86++;
    if (_86 < v)
    goto _jump2751;
    // End body of loop
    bool _87 = _82 != _83;
    rgba _88;
    if (!_87)
    goto _jump2752;
    _88 = d;
    goto _jump2753;
    _jump2752:;
    i _89 = { d };
    rgba _90 = _89.a;
    _88 = _90;
    _jump2753:;
    _70 = _88;
    _jump2747:;
    _68 = _70;
    goto _jump2754;
    _jump2736:;
    _a1_i _91;
    // Computing bound for F
    _91.d0 = u;
    if (u > 0) 
    goto _jump2755;
    fail_assertion("non-positive loop bound");
    _jump2755:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= u;
    _92 *= sizeof(i);
    _91.data = jpl_alloc(_92);
    int64_t _93 = 0; // F
    _jump2756:; // Begin body of loop
    i _94 = { d };
    int64_t _95 = 0;
    _95 *= _91.d0;
    _95 += _93;
    _91.data[_95] = _94;
    _93++;
    if (_93 < u)
    goto _jump2756;
    // End body of loop
    if (v >= 0)
    goto _jump2757;
    fail_assertion("negative array index");
    _jump2757:;
    if (v < _91.d0)
    goto _jump2758;
    fail_assertion("index too large");
    _jump2758:;
    int64_t _96 = 0;
    _96 *= _91.d0;
    _96 += v;
    i _97 = _91.data[_96];
    rgba _98 = _97.a;
    _68 = _98;
    _jump2754:;
    _65 = _68;
    goto _jump2759;
    _jump2735:;
    int64_t _99;
    // Computing bound for F
    if (l > 0) 
    goto _jump2760;
    fail_assertion("non-positive loop bound");
    _jump2760:;
    // Computing bound for G
    if (x > 0) 
    goto _jump2761;
    fail_assertion("non-positive loop bound");
    _jump2761:;
    // Computing bound for H
    if (l > 0) 
    goto _jump2762;
    fail_assertion("non-positive loop bound");
    _jump2762:;
    _99 = 0;
    int64_t _100 = 0; // H
    int64_t _101 = 0; // G
    int64_t _102 = 0; // F
    _jump2763:; // Begin body of loop
    _99 += _102;
    _100++;
    if (_100 < l)
    goto _jump2763;
    _100 = 0;
    _101++;
    if (_101 < x)
    goto _jump2763;
    _101 = 0;
    _102++;
    if (_102 < l)
    goto _jump2763;
    // End body of loop
    int64_t _103 = 117;
    int64_t _104 = _103 * u;
    if (_99 >= 0)
    goto _jump2764;
    fail_assertion("negative array index");
    _jump2764:;
    if (_99 < q.d0)
    goto _jump2765;
    fail_assertion("index too large");
    _jump2765:;
    if (_104 >= 0)
    goto _jump2766;
    fail_assertion("negative array index");
    _jump2766:;
    if (_104 < q.d1)
    goto _jump2767;
    fail_assertion("index too large");
    _jump2767:;
    int64_t _105 = 0;
    _105 *= q.d0;
    _105 += _99;
    _105 *= q.d1;
    _105 += _104;
    rgba _106 = q.data[_105];
    _65 = _106;
    _jump2759:;
    double _107 = _65.g;
    _a1__a2_e _108;
    // Computing bound for G
    _108.d0 = v;
    if (v > 0) 
    goto _jump2768;
    fail_assertion("non-positive loop bound");
    _jump2768:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= v;
    _109 *= sizeof(_a2_e);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // G
    _jump2769:; // Begin body of loop
    _a2_e _111;
    // Computing bound for H
    int64_t _112 = y / x;
    _111.d0 = _112;
    if (_112 > 0) 
    goto _jump2770;
    fail_assertion("non-positive loop bound");
    _jump2770:;
    // Computing bound for I
    _111.d1 = u;
    if (u > 0) 
    goto _jump2771;
    fail_assertion("non-positive loop bound");
    _jump2771:;
    // Computing total size of heap memory to allocate
    int64_t _113 = 1;
    _113 *= _112;
    _113 *= u;
    _113 *= sizeof(e);
    _111.data = jpl_alloc(_113);
    int64_t _114 = 0; // I
    int64_t _115 = 0; // H
    _jump2772:; // Begin body of loop
    int64_t _116 = 0;
    _116 *= _111.d0;
    _116 += _115;
    _116 *= _111.d1;
    _116 += _114;
    _111.data[_116] = _64;
    _114++;
    if (_114 < u)
    goto _jump2772;
    _114 = 0;
    _115++;
    if (_115 < _112)
    goto _jump2772;
    // End body of loop
    int64_t _117 = 0;
    _117 *= _108.d0;
    _117 += _110;
    _108.data[_117] = _111;
    _110++;
    if (_110 < v)
    goto _jump2769;
    // End body of loop
    int64_t _118 = -m;
    if (_118 >= 0)
    goto _jump2773;
    fail_assertion("negative array index");
    _jump2773:;
    if (_118 < _108.d0)
    goto _jump2774;
    fail_assertion("index too large");
    _jump2774:;
    int64_t _119 = 0;
    _119 *= _108.d0;
    _119 += _118;
    _a2_e _120 = _108.data[_119];
    _a3_rgba _121;
    // Computing bound for G
    _a2_int64_t _122;
    // Computing bound for G
    _122.d0 = l;
    if (l > 0) 
    goto _jump2775;
    fail_assertion("non-positive loop bound");
    _jump2775:;
    // Computing bound for H
    bool _123 = A();
    int64_t _124;
    if (!_123)
    goto _jump2776;
    _124 = r;
    goto _jump2777;
    _jump2776:;
    _124 = r;
    _jump2777:;
    _122.d1 = _124;
    if (_124 > 0) 
    goto _jump2778;
    fail_assertion("non-positive loop bound");
    _jump2778:;
    // Computing total size of heap memory to allocate
    int64_t _125 = 1;
    _125 *= l;
    _125 *= _124;
    _125 *= sizeof(int64_t);
    _122.data = jpl_alloc(_125);
    int64_t _126 = 0; // H
    int64_t _127 = 0; // G
    _jump2779:; // Begin body of loop
    int64_t _128 = -x;
    int64_t _129 = 0;
    _129 *= _122.d0;
    _129 += _127;
    _129 *= _122.d1;
    _129 += _126;
    _122.data[_129] = _128;
    _126++;
    if (_126 < _124)
    goto _jump2779;
    _126 = 0;
    _127++;
    if (_127 < l)
    goto _jump2779;
    // End body of loop
    int64_t _130 = -y;
    if (y >= 0)
    goto _jump2780;
    fail_assertion("negative array index");
    _jump2780:;
    if (y < _122.d0)
    goto _jump2781;
    fail_assertion("index too large");
    _jump2781:;
    if (_130 >= 0)
    goto _jump2782;
    fail_assertion("negative array index");
    _jump2782:;
    if (_130 < _122.d1)
    goto _jump2783;
    fail_assertion("index too large");
    _jump2783:;
    int64_t _131 = 0;
    _131 *= _122.d0;
    _131 += y;
    _131 *= _122.d1;
    _131 += _130;
    int64_t _132 = _122.data[_131];
    _121.d0 = _132;
    if (_132 > 0) 
    goto _jump2784;
    fail_assertion("non-positive loop bound");
    _jump2784:;
    // Computing bound for H
    _121.d1 = u;
    if (u > 0) 
    goto _jump2785;
    fail_assertion("non-positive loop bound");
    _jump2785:;
    // Computing bound for I
    _a1_int64_t _133;
    // Computing bound for G
    _133.d0 = u;
    if (u > 0) 
    goto _jump2786;
    fail_assertion("non-positive loop bound");
    _jump2786:;
    // Computing total size of heap memory to allocate
    int64_t _134 = 1;
    _134 *= u;
    _134 *= sizeof(int64_t);
    _133.data = jpl_alloc(_134);
    int64_t _135 = 0; // G
    _jump2787:; // Begin body of loop
    int64_t _136 = 0;
    _136 *= _133.d0;
    _136 += _135;
    _133.data[_136] = _135;
    _135++;
    if (_135 < u)
    goto _jump2787;
    // End body of loop
    if (s >= 0)
    goto _jump2788;
    fail_assertion("negative array index");
    _jump2788:;
    if (s < _133.d0)
    goto _jump2789;
    fail_assertion("index too large");
    _jump2789:;
    int64_t _137 = 0;
    _137 *= _133.d0;
    _137 += s;
    int64_t _138 = _133.data[_137];
    int64_t _139 = u * _138;
    _121.d2 = _139;
    if (_139 > 0) 
    goto _jump2790;
    fail_assertion("non-positive loop bound");
    _jump2790:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= _132;
    _140 *= u;
    _140 *= _139;
    _140 *= sizeof(rgba);
    _121.data = jpl_alloc(_140);
    int64_t _141 = 0; // I
    int64_t _142 = 0; // H
    int64_t _143 = 0; // G
    _jump2791:; // Begin body of loop
    double _144;
    // Computing bound for J
    if (_141 > 0) 
    goto _jump2792;
    fail_assertion("non-positive loop bound");
    _jump2792:;
    _144 = 0;
    int64_t _145 = 0; // J
    _jump2793:; // Begin body of loop
    double _146 = n + j;
    _144 += _146;
    _145++;
    if (_145 < _141)
    goto _jump2793;
    // End body of loop
    double _147 = 27.0;
    double _148 = -_147;
    rgba _149 = { _144, j, h, _148 };
    int64_t _150 = 0;
    _150 *= _121.d0;
    _150 += _143;
    _150 *= _121.d1;
    _150 += _142;
    _150 *= _121.d2;
    _150 += _141;
    _121.data[_150] = _149;
    _141++;
    if (_141 < _139)
    goto _jump2791;
    _141 = 0;
    _142++;
    if (_142 < u)
    goto _jump2791;
    _142 = 0;
    _143++;
    if (_143 < _132)
    goto _jump2791;
    // End body of loop
    _a1_bool _151;
    _151.d0 = 3;
    _151.data = jpl_alloc(sizeof(bool) * 3);
    _151.data[0] = g;
    _151.data[1] = g;
    _151.data[2] = g;
    _a2_rgba _152;
    // Computing bound for G
    _152.d0 = y;
    if (y > 0) 
    goto _jump2794;
    fail_assertion("non-positive loop bound");
    _jump2794:;
    // Computing bound for H
    int64_t _153 = -x;
    _152.d1 = _153;
    if (_153 > 0) 
    goto _jump2795;
    fail_assertion("non-positive loop bound");
    _jump2795:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= y;
    _154 *= _153;
    _154 *= sizeof(rgba);
    _152.data = jpl_alloc(_154);
    int64_t _155 = 0; // H
    int64_t _156 = 0; // G
    _jump2796:; // Begin body of loop
    double _157 = 65.0;
    double _158 = 93.0;
    bool _159 = _157 >= _158;
    bool _160 = !_159;
    rgba _161;
    if (!_160)
    goto _jump2797;
    bool _162 = false;
    rgba _163;
    if (!_162)
    goto _jump2798;
    _163 = d;
    goto _jump2799;
    _jump2798:;
    int64_t _164 = 790;
    if (x >= 0)
    goto _jump2800;
    fail_assertion("negative array index");
    _jump2800:;
    if (x < o.d0)
    goto _jump2801;
    fail_assertion("index too large");
    _jump2801:;
    if (_164 >= 0)
    goto _jump2802;
    fail_assertion("negative array index");
    _jump2802:;
    if (_164 < o.d1)
    goto _jump2803;
    fail_assertion("index too large");
    _jump2803:;
    int64_t _165 = 0;
    _165 *= o.d0;
    _165 += x;
    _165 *= o.d1;
    _165 += _164;
    rgba _166 = o.data[_165];
    _163 = _166;
    _jump2799:;
    _161 = _163;
    goto _jump2804;
    _jump2797:;
    _a1_rgba _167;
    // Computing bound for I
    int64_t _168 = 747;
    _167.d0 = _168;
    if (_168 > 0) 
    goto _jump2805;
    fail_assertion("non-positive loop bound");
    _jump2805:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= _168;
    _169 *= sizeof(rgba);
    _167.data = jpl_alloc(_169);
    int64_t _170 = 0; // I
    _jump2806:; // Begin body of loop
    int64_t _171 = 0;
    _171 *= _167.d0;
    _171 += _170;
    _167.data[_171] = d;
    _170++;
    if (_170 < _168)
    goto _jump2806;
    // End body of loop
    int64_t _172 = y / s;
    if (_172 >= 0)
    goto _jump2807;
    fail_assertion("negative array index");
    _jump2807:;
    if (_172 < _167.d0)
    goto _jump2808;
    fail_assertion("index too large");
    _jump2808:;
    int64_t _173 = 0;
    _173 *= _167.d0;
    _173 += _172;
    rgba _174 = _167.data[_173];
    _161 = _174;
    _jump2804:;
    int64_t _175 = 0;
    _175 *= _152.d0;
    _175 += _156;
    _175 *= _152.d1;
    _175 += _155;
    _152.data[_175] = _161;
    _155++;
    if (_155 < _153)
    goto _jump2796;
    _155 = 0;
    _156++;
    if (_156 < y)
    goto _jump2796;
    // End body of loop
    int64_t _176 = b(_121, _151, _152);
    if (_176 >= 0)
    goto _jump2809;
    fail_assertion("negative array index");
    _jump2809:;
    if (_176 < _120.d0)
    goto _jump2810;
    fail_assertion("index too large");
    _jump2810:;
    if (x >= 0)
    goto _jump2811;
    fail_assertion("negative array index");
    _jump2811:;
    if (x < _120.d1)
    goto _jump2812;
    fail_assertion("index too large");
    _jump2812:;
    int64_t _177 = 0;
    _177 *= _120.d0;
    _177 += _176;
    _177 *= _120.d1;
    _177 += x;
    e _178 = _120.data[_177];
    _a3_bool _179 = _178.a;
    bool _180 = v > u;
    return _180;
}

void jpl_main(struct args args) {
    _a1_bool _0;
    // Computing bound for a
    int64_t _1;
    // Computing bound for a
    int64_t _2 = 930;
    if (_2 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing bound for b
    int64_t _3 = 92;
    if (_3 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for c
    int64_t _4 = 383;
    int64_t _5 = 351;
    _a1_int64_t _6;
    _6.d0 = 2;
    _6.data = jpl_alloc(sizeof(int64_t) * 2);
    _6.data[0] = _4;
    _6.data[1] = _5;
    int64_t _7 = 260;
    int64_t _8 = -_7;
    int64_t _9 = 840;
    int64_t _10 = _8 * _9;
    if (_10 >= 0)
    goto _jump3;
    fail_assertion("negative array index");
    _jump3:;
    if (_10 < _6.d0)
    goto _jump4;
    fail_assertion("index too large");
    _jump4:;
    int64_t _11 = 0;
    _11 *= _6.d0;
    _11 += _10;
    int64_t _12 = _6.data[_11];
    if (_12 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    _1 = 0;
    int64_t _13 = 0; // c
    int64_t _14 = 0; // b
    int64_t _15 = 0; // a
    _jump6:; // Begin body of loop
    int64_t _16;
    // Computing bound for d
    bool _17 = true;
    int64_t _18;
    if (!_17)
    goto _jump7;
    _18 = _13;
    goto _jump8;
    _jump7:;
    int64_t _19 = 645;
    int64_t _20 = _13 + _19;
    _18 = _20;
    _jump8:;
    if (_18 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    // Computing bound for e
    if (_15 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    _16 = 0;
    int64_t _21 = 0; // e
    int64_t _22 = 0; // d
    _jump11:; // Begin body of loop
    _16 += _13;
    _21++;
    if (_21 < _15)
    goto _jump11;
    _21 = 0;
    _22++;
    if (_22 < _18)
    goto _jump11;
    // End body of loop
    _1 += _16;
    _13++;
    if (_13 < _12)
    goto _jump6;
    _13 = 0;
    _14++;
    if (_14 < _3)
    goto _jump6;
    _14 = 0;
    _15++;
    if (_15 < _2)
    goto _jump6;
    // End body of loop
    int64_t _23;
    // Computing bound for a
    int64_t _24 = 256;
    if (_24 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    // Computing bound for b
    _a1_bool _25;
    // Computing bound for a
    int64_t _26 = 478;
    _25.d0 = _26;
    if (_26 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= _26;
    _27 *= sizeof(bool);
    _25.data = jpl_alloc(_27);
    int64_t _28 = 0; // a
    _jump14:; // Begin body of loop
    bool _29 = false;
    int64_t _30 = 0;
    _30 *= _25.d0;
    _30 += _28;
    _25.data[_30] = _29;
    _28++;
    if (_28 < _26)
    goto _jump14;
    // End body of loop
    int64_t _31 = 105;
    int64_t _32 = -_31;
    if (_32 >= 0)
    goto _jump15;
    fail_assertion("negative array index");
    _jump15:;
    if (_32 < _25.d0)
    goto _jump16;
    fail_assertion("index too large");
    _jump16:;
    int64_t _33 = 0;
    _33 *= _25.d0;
    _33 += _32;
    bool _34 = _25.data[_33];
    int64_t _35;
    if (!_34)
    goto _jump17;
    int64_t _36 = 716;
    _35 = _36;
    goto _jump18;
    _jump17:;
    bool _37 = false;
    bool _38;
    if (!_37)
    goto _jump19;
    double _39 = 78.0;
    double _40 = 20.0;
    bool _41 = _39 != _40;
    _38 = _41;
    goto _jump20;
    _jump19:;
    bool _42 = true;
    bool _43 = !_42;
    _38 = _43;
    _jump20:;
    int64_t _44;
    if (!_38)
    goto _jump21;
    bool _45 = false;
    int64_t _46;
    if (!_45)
    goto _jump22;
    int64_t _47 = 811;
    _46 = _47;
    goto _jump23;
    _jump22:;
    int64_t _48 = 112;
    _46 = _48;
    _jump23:;
    int64_t _49 = -_46;
    _44 = _49;
    goto _jump24;
    _jump21:;
    int64_t _50;
    // Computing bound for a
    int64_t _51 = 749;
    if (_51 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for b
    int64_t _52 = 125;
    if (_52 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for c
    int64_t _53 = 834;
    if (_53 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _50 = 0;
    int64_t _54 = 0; // c
    int64_t _55 = 0; // b
    int64_t _56 = 0; // a
    _jump28:; // Begin body of loop
    int64_t _57 = -_56;
    _50 += _57;
    _54++;
    if (_54 < _53)
    goto _jump28;
    _54 = 0;
    _55++;
    if (_55 < _52)
    goto _jump28;
    _55 = 0;
    _56++;
    if (_56 < _51)
    goto _jump28;
    // End body of loop
    _44 = _50;
    _jump24:;
    _35 = _44;
    _jump18:;
    if (_35 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    // Computing bound for c
    int64_t _58;
    // Computing bound for a
    bool _59 = true;
    int64_t _60;
    if (!_59)
    goto _jump30;
    int64_t _61 = 453;
    _60 = _61;
    goto _jump31;
    _jump30:;
    int64_t _62 = 961;
    _60 = _62;
    _jump31:;
    if (_60 > 0) 
    goto _jump32;
    fail_assertion("non-positive loop bound");
    _jump32:;
    // Computing bound for b
    int64_t _63 = 370;
    int64_t _64 = -_63;
    if (_64 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing bound for c
    int64_t _65 = 460;
    int64_t _66 = -_65;
    if (_66 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    _58 = 0;
    int64_t _67 = 0; // c
    int64_t _68 = 0; // b
    int64_t _69 = 0; // a
    _jump35:; // Begin body of loop
    int64_t _70 = 767;
    _58 += _70;
    _67++;
    if (_67 < _66)
    goto _jump35;
    _67 = 0;
    _68++;
    if (_68 < _64)
    goto _jump35;
    _68 = 0;
    _69++;
    if (_69 < _60)
    goto _jump35;
    // End body of loop
    int64_t _71 = 410;
    bool _72 = _58 >= _71;
    int64_t _73;
    if (!_72)
    goto _jump36;
    _a1_int64_t _74;
    // Computing bound for a
    int64_t _75 = 965;
    _74.d0 = _75;
    if (_75 > 0) 
    goto _jump37;
    fail_assertion("non-positive loop bound");
    _jump37:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _75;
    _76 *= sizeof(int64_t);
    _74.data = jpl_alloc(_76);
    int64_t _77 = 0; // a
    _jump38:; // Begin body of loop
    int64_t _78 = 0;
    _78 *= _74.d0;
    _78 += _77;
    _74.data[_78] = _77;
    _77++;
    if (_77 < _75)
    goto _jump38;
    // End body of loop
    int64_t _79 = 764;
    if (_79 >= 0)
    goto _jump39;
    fail_assertion("negative array index");
    _jump39:;
    if (_79 < _74.d0)
    goto _jump40;
    fail_assertion("index too large");
    _jump40:;
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += _79;
    int64_t _81 = _74.data[_80];
    _73 = _81;
    goto _jump41;
    _jump36:;
    bool _82 = false;
    int64_t _83;
    if (!_82)
    goto _jump42;
    int64_t _84 = 768;
    _83 = _84;
    goto _jump43;
    _jump42:;
    int64_t _85 = 567;
    _83 = _85;
    _jump43:;
    _73 = _83;
    _jump41:;
    if (_73 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    _23 = 0;
    int64_t _86 = 0; // c
    int64_t _87 = 0; // b
    int64_t _88 = 0; // a
    _jump45:; // Begin body of loop
    int64_t _89 = 522;
    int64_t _90 = -_89;
    bool _91 = _90 == _87;
    int64_t _92;
    if (!_91)
    goto _jump46;
    _92 = _87;
    goto _jump47;
    _jump46:;
    int64_t _93 = 81;
    _92 = _93;
    _jump47:;
    int64_t _94 = _87 / _92;
    _23 += _94;
    _86++;
    if (_86 < _73)
    goto _jump45;
    _86 = 0;
    _87++;
    if (_87 < _35)
    goto _jump45;
    _87 = 0;
    _88++;
    if (_88 < _24)
    goto _jump45;
    // End body of loop
    int64_t _95 = _1 / _23;
    _0.d0 = _95;
    if (_95 > 0) 
    goto _jump48;
    fail_assertion("non-positive loop bound");
    _jump48:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= _95;
    _96 *= sizeof(bool);
    _0.data = jpl_alloc(_96);
    int64_t _97 = 0; // a
    _jump49:; // Begin body of loop
    double _98 = 37.0;
    double _99 = -_98;
    double _100 = 33.0;
    double _101 = _99 * _100;
    double _102;
    // Computing bound for b
    _a1_int64_t _103;
    _103.d0 = 1;
    _103.data = jpl_alloc(sizeof(int64_t) * 1);
    _103.data[0] = _97;
    int64_t _104 = 637;
    if (_104 >= 0)
    goto _jump50;
    fail_assertion("negative array index");
    _jump50:;
    if (_104 < _103.d0)
    goto _jump51;
    fail_assertion("index too large");
    _jump51:;
    int64_t _105 = 0;
    _105 *= _103.d0;
    _105 += _104;
    int64_t _106 = _103.data[_105];
    int64_t _107 = -_106;
    if (_107 > 0) 
    goto _jump52;
    fail_assertion("non-positive loop bound");
    _jump52:;
    // Computing bound for c
    bool _108 = false;
    int64_t _109;
    if (!_108)
    goto _jump53;
    int64_t _110 = 490;
    int64_t _111 = _110 % _97;
    _109 = _111;
    goto _jump54;
    _jump53:;
    int64_t _112 = 736;
    _109 = _112;
    _jump54:;
    if (_109 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    // Computing bound for d
    int64_t _113;
    // Computing bound for b
    int64_t _114 = 996;
    if (_114 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    // Computing bound for c
    int64_t _115 = 230;
    int64_t _116 = 160;
    int64_t _117 = -_116;
    int64_t _118 = _115 - _117;
    if (_118 > 0) 
    goto _jump57;
    fail_assertion("non-positive loop bound");
    _jump57:;
    // Computing bound for d
    bool _119 = true;
    int64_t _120;
    if (!_119)
    goto _jump58;
    int64_t _121 = 223;
    int64_t _122 = 624;
    int64_t _123 = _121 / _122;
    _120 = _123;
    goto _jump59;
    _jump58:;
    int64_t _124 = -_97;
    _120 = _124;
    _jump59:;
    if (_120 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    _113 = 0;
    int64_t _125 = 0; // d
    int64_t _126 = 0; // c
    int64_t _127 = 0; // b
    _jump61:; // Begin body of loop
    _113 += _127;
    _125++;
    if (_125 < _120)
    goto _jump61;
    _125 = 0;
    _126++;
    if (_126 < _118)
    goto _jump61;
    _126 = 0;
    _127++;
    if (_127 < _114)
    goto _jump61;
    // End body of loop
    if (_113 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    _102 = 0;
    int64_t _128 = 0; // d
    int64_t _129 = 0; // c
    int64_t _130 = 0; // b
    _jump63:; // Begin body of loop
    bool _131 = true;
    _a3_double _132;
    if (!_131)
    goto _jump64;
    _a3_double _133;
    // Computing bound for e
    int64_t _134 = 535;
    _133.d0 = _134;
    if (_134 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing bound for f
    _133.d1 = _129;
    if (_129 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing bound for g
    _133.d2 = _130;
    if (_130 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= _134;
    _135 *= _129;
    _135 *= _130;
    _135 *= sizeof(double);
    _133.data = jpl_alloc(_135);
    int64_t _136 = 0; // g
    int64_t _137 = 0; // f
    int64_t _138 = 0; // e
    _jump68:; // Begin body of loop
    double _139 = 73.0;
    int64_t _140 = 0;
    _140 *= _133.d0;
    _140 += _138;
    _140 *= _133.d1;
    _140 += _137;
    _140 *= _133.d2;
    _140 += _136;
    _133.data[_140] = _139;
    _136++;
    if (_136 < _130)
    goto _jump68;
    _136 = 0;
    _137++;
    if (_137 < _129)
    goto _jump68;
    _137 = 0;
    _138++;
    if (_138 < _134)
    goto _jump68;
    // End body of loop
    _132 = _133;
    goto _jump69;
    _jump64:;
    _a3_double _141;
    // Computing bound for e
    _141.d0 = _130;
    if (_130 > 0) 
    goto _jump70;
    fail_assertion("non-positive loop bound");
    _jump70:;
    // Computing bound for f
    _141.d1 = _97;
    if (_97 > 0) 
    goto _jump71;
    fail_assertion("non-positive loop bound");
    _jump71:;
    // Computing bound for g
    _141.d2 = _128;
    if (_128 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _130;
    _142 *= _97;
    _142 *= _128;
    _142 *= sizeof(double);
    _141.data = jpl_alloc(_142);
    int64_t _143 = 0; // g
    int64_t _144 = 0; // f
    int64_t _145 = 0; // e
    _jump73:; // Begin body of loop
    double _146 = 63.0;
    int64_t _147 = 0;
    _147 *= _141.d0;
    _147 += _145;
    _147 *= _141.d1;
    _147 += _144;
    _147 *= _141.d2;
    _147 += _143;
    _141.data[_147] = _146;
    _143++;
    if (_143 < _128)
    goto _jump73;
    _143 = 0;
    _144++;
    if (_144 < _97)
    goto _jump73;
    _144 = 0;
    _145++;
    if (_145 < _130)
    goto _jump73;
    // End body of loop
    _132 = _141;
    _jump69:;
    _a1_int64_t _148;
    // Computing bound for e
    _148.d0 = _97;
    if (_97 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _97;
    _149 *= sizeof(int64_t);
    _148.data = jpl_alloc(_149);
    int64_t _150 = 0; // e
    _jump75:; // Begin body of loop
    int64_t _151 = 0;
    _151 *= _148.d0;
    _151 += _150;
    _148.data[_151] = _130;
    _150++;
    if (_150 < _97)
    goto _jump75;
    // End body of loop
    int64_t _152 = _128 - _128;
    if (_152 >= 0)
    goto _jump76;
    fail_assertion("negative array index");
    _jump76:;
    if (_152 < _148.d0)
    goto _jump77;
    fail_assertion("index too large");
    _jump77:;
    int64_t _153 = 0;
    _153 *= _148.d0;
    _153 += _152;
    int64_t _154 = _148.data[_153];
    int64_t _155 = 203;
    if (_154 >= 0)
    goto _jump78;
    fail_assertion("negative array index");
    _jump78:;
    if (_154 < _132.d0)
    goto _jump79;
    fail_assertion("index too large");
    _jump79:;
    if (_155 >= 0)
    goto _jump80;
    fail_assertion("negative array index");
    _jump80:;
    if (_155 < _132.d1)
    goto _jump81;
    fail_assertion("index too large");
    _jump81:;
    if (_128 >= 0)
    goto _jump82;
    fail_assertion("negative array index");
    _jump82:;
    if (_128 < _132.d2)
    goto _jump83;
    fail_assertion("index too large");
    _jump83:;
    int64_t _156 = 0;
    _156 *= _132.d0;
    _156 += _154;
    _156 *= _132.d1;
    _156 += _155;
    _156 *= _132.d2;
    _156 += _128;
    double _157 = _132.data[_156];
    _102 += _157;
    _128++;
    if (_128 < _113)
    goto _jump63;
    _128 = 0;
    _129++;
    if (_129 < _109)
    goto _jump63;
    _129 = 0;
    _130++;
    if (_130 < _107)
    goto _jump63;
    // End body of loop
    bool _158 = _101 > _102;
    bool _159 = !_158;
    int64_t _160 = 0;
    _160 *= _0.d0;
    _160 += _97;
    _0.data[_160] = _159;
    _97++;
    if (_97 < _95)
    goto _jump49;
    // End body of loop
    _a2__a2_rgba _161;
    // Computing bound for b
    int64_t _162;
    // Computing bound for b
    int64_t _163 = 715;
    if (_163 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    // Computing bound for c
    int64_t _164 = 462;
    if (_164 > 0) 
    goto _jump85;
    fail_assertion("non-positive loop bound");
    _jump85:;
    // Computing bound for d
    bool _165 = false;
    bool _166 = !_165;
    bool _167;
    if (!_166)
    goto _jump86;
    bool _168 = false;
    _167 = _168;
    goto _jump87;
    _jump86:;
    bool _169 = false;
    bool _170 = !_169;
    _167 = _170;
    _jump87:;
    int64_t _171;
    if (!_167)
    goto _jump88;
    int64_t _172 = 208;
    int64_t _173 = -_172;
    _171 = _173;
    goto _jump89;
    _jump88:;
    bool _174 = false;
    int64_t _175;
    if (!_174)
    goto _jump90;
    int64_t _176 = 746;
    _175 = _176;
    goto _jump91;
    _jump90:;
    int64_t _177 = 542;
    int64_t _178 = -_177;
    _175 = _178;
    _jump91:;
    _171 = _175;
    _jump89:;
    if (_171 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    _162 = 0;
    int64_t _179 = 0; // d
    int64_t _180 = 0; // c
    int64_t _181 = 0; // b
    _jump93:; // Begin body of loop
    bool _182 = true;
    bool _183 = !_182;
    int64_t _184;
    if (!_183)
    goto _jump94;
    _184 = _180;
    goto _jump95;
    _jump94:;
    bool _185 = true;
    int64_t _186;
    if (!_185)
    goto _jump96;
    _186 = _180;
    goto _jump97;
    _jump96:;
    _186 = _181;
    _jump97:;
    int64_t _187;
    // Computing bound for e
    if (_180 > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    // Computing bound for f
    if (_179 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    _187 = 0;
    int64_t _188 = 0; // f
    int64_t _189 = 0; // e
    _jump100:; // Begin body of loop
    _187 += _181;
    _188++;
    if (_188 < _179)
    goto _jump100;
    _188 = 0;
    _189++;
    if (_189 < _180)
    goto _jump100;
    // End body of loop
    int64_t _190 = _186 * _187;
    _184 = _190;
    _jump95:;
    _162 += _184;
    _179++;
    if (_179 < _171)
    goto _jump93;
    _179 = 0;
    _180++;
    if (_180 < _164)
    goto _jump93;
    _180 = 0;
    _181++;
    if (_181 < _163)
    goto _jump93;
    // End body of loop
    bool _191 = false;
    int64_t _192;
    if (!_191)
    goto _jump101;
    double _193 = 33.0;
    double _194 = 65.0;
    bool _195 = _193 <= _194;
    bool _196 = !_195;
    int64_t _197;
    if (!_196)
    goto _jump102;
    int64_t _198 = 235;
    int64_t _199 = 873;
    int64_t _200 = _198 % _199;
    int64_t _201 = 431;
    int64_t _202 = _200 - _201;
    _197 = _202;
    goto _jump103;
    _jump102:;
    int64_t _203 = 518;
    int64_t _204 = 127;
    int64_t _205 = _203 + _204;
    _197 = _205;
    _jump103:;
    _192 = _197;
    goto _jump104;
    _jump101:;
    bool _206 = true;
    int64_t _207;
    if (!_206)
    goto _jump105;
    int64_t _208 = 843;
    _207 = _208;
    goto _jump106;
    _jump105:;
    int64_t _209 = 9;
    int64_t _210 = 265;
    int64_t _211 = _209 / _210;
    _207 = _211;
    _jump106:;
    int64_t _212 = -_207;
    _192 = _212;
    _jump104:;
    int64_t _213 = _162 + _192;
    _161.d0 = _213;
    if (_213 > 0) 
    goto _jump107;
    fail_assertion("non-positive loop bound");
    _jump107:;
    // Computing bound for c
    int64_t _214;
    // Computing bound for b
    int64_t _215;
    // Computing bound for b
    bool _217 = false;
    bool _218 = !_217;
    bool _216 = _218;
    if (0 == _218)
    goto _jump108;
    bool _219 = true;
    _216 = _219;
    _jump108:;
    int64_t _220;
    if (!_216)
    goto _jump109;
    int64_t _221;
    // Computing bound for b
    int64_t _222 = 15;
    int64_t _223 = 47;
    int64_t _224 = _222 - _223;
    if (_224 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    _221 = 0;
    int64_t _225 = 0; // b
    _jump111:; // Begin body of loop
    int64_t _226 = 1000;
    int64_t _227 = -_226;
    _221 += _227;
    _225++;
    if (_225 < _224)
    goto _jump111;
    // End body of loop
    _220 = _221;
    goto _jump112;
    _jump109:;
    int64_t _228 = 317;
    _220 = _228;
    _jump112:;
    if (_220 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    _215 = 0;
    int64_t _229 = 0; // b
    _jump114:; // Begin body of loop
    int64_t _230 = 6;
    int64_t _231 = -_230;
    _215 += _231;
    _229++;
    if (_229 < _220)
    goto _jump114;
    // End body of loop
    if (_215 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    _214 = 0;
    int64_t _232 = 0; // b
    _jump116:; // Begin body of loop
    bool _234 = false;
    bool _235 = !_234;
    bool _233 = _235;
    if (0 == _235)
    goto _jump117;
    bool _236 = false;
    _233 = _236;
    _jump117:;
    int64_t _237;
    if (!_233)
    goto _jump118;
    bool _238 = true;
    int64_t _239;
    if (!_238)
    goto _jump119;
    _239 = _232;
    goto _jump120;
    _jump119:;
    int64_t _240 = 220;
    _239 = _240;
    _jump120:;
    int64_t _241 = -_239;
    _237 = _241;
    goto _jump121;
    _jump118:;
    int64_t _242 = 858;
    int64_t _243 = -_242;
    _237 = _243;
    _jump121:;
    int64_t _244;
    // Computing bound for c
    int64_t _245 = 743;
    if (_245 >= 0)
    goto _jump122;
    fail_assertion("negative array index");
    _jump122:;
    if (_245 < _0.d0)
    goto _jump123;
    fail_assertion("index too large");
    _jump123:;
    int64_t _246 = 0;
    _246 *= _0.d0;
    _246 += _245;
    bool _247 = _0.data[_246];
    int64_t _248;
    if (!_247)
    goto _jump124;
    _248 = _232;
    goto _jump125;
    _jump124:;
    int64_t _249 = _232 - _232;
    _248 = _249;
    _jump125:;
    if (_248 > 0) 
    goto _jump126;
    fail_assertion("non-positive loop bound");
    _jump126:;
    // Computing bound for d
    int64_t _250 = 481;
    int64_t _251 = -_250;
    if (_251 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    _244 = 0;
    int64_t _252 = 0; // d
    int64_t _253 = 0; // c
    _jump128:; // Begin body of loop
    int64_t _254 = -_253;
    _244 += _254;
    _252++;
    if (_252 < _251)
    goto _jump128;
    _252 = 0;
    _253++;
    if (_253 < _248)
    goto _jump128;
    // End body of loop
    int64_t _255 = _237 - _244;
    _214 += _255;
    _232++;
    if (_232 < _215)
    goto _jump116;
    // End body of loop
    _161.d1 = _214;
    if (_214 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    // Computing total size of heap memory to allocate
    int64_t _256 = 1;
    _256 *= _213;
    _256 *= _214;
    _256 *= sizeof(_a2_rgba);
    _161.data = jpl_alloc(_256);
    int64_t _257 = 0; // c
    int64_t _258 = 0; // b
    _jump130:; // Begin body of loop
    _a2_rgba _259;
    // Computing bound for d
    _259.d0 = _258;
    if (_258 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing bound for e
    int64_t _260 = 18;
    _259.d1 = _260;
    if (_260 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _258;
    _261 *= _260;
    _261 *= sizeof(rgba);
    _259.data = jpl_alloc(_261);
    int64_t _262 = 0; // e
    int64_t _263 = 0; // d
    _jump133:; // Begin body of loop
    bool _264 = _263 <= _262;
    bool _266 = true;
    bool _267 = !_266;
    bool _265 = _267;
    if (0 == _267)
    goto _jump134;
    bool _268 = true;
    _265 = _268;
    _jump134:;
    bool _269 = _264 != _265;
    rgba _270;
    if (!_269)
    goto _jump135;
    _a2_double _271;
    // Computing bound for f
    _271.d0 = _262;
    if (_262 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    // Computing bound for g
    _271.d1 = _262;
    if (_262 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing total size of heap memory to allocate
    int64_t _272 = 1;
    _272 *= _262;
    _272 *= _262;
    _272 *= sizeof(double);
    _271.data = jpl_alloc(_272);
    int64_t _273 = 0; // g
    int64_t _274 = 0; // f
    _jump138:; // Begin body of loop
    double _275 = 8.0;
    int64_t _276 = 0;
    _276 *= _271.d0;
    _276 += _274;
    _276 *= _271.d1;
    _276 += _273;
    _271.data[_276] = _275;
    _273++;
    if (_273 < _262)
    goto _jump138;
    _273 = 0;
    _274++;
    if (_274 < _262)
    goto _jump138;
    // End body of loop
    int64_t _277 = 596;
    if (_277 >= 0)
    goto _jump139;
    fail_assertion("negative array index");
    _jump139:;
    if (_277 < _271.d0)
    goto _jump140;
    fail_assertion("index too large");
    _jump140:;
    if (_258 >= 0)
    goto _jump141;
    fail_assertion("negative array index");
    _jump141:;
    if (_258 < _271.d1)
    goto _jump142;
    fail_assertion("index too large");
    _jump142:;
    int64_t _278 = 0;
    _278 *= _271.d0;
    _278 += _277;
    _278 *= _271.d1;
    _278 += _258;
    double _279 = _271.data[_278];
    double _280 = 16.0;
    double _281 = -_280;
    _a1_double _282;
    // Computing bound for f
    _282.d0 = _257;
    if (_257 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing total size of heap memory to allocate
    int64_t _283 = 1;
    _283 *= _257;
    _283 *= sizeof(double);
    _282.data = jpl_alloc(_283);
    int64_t _284 = 0; // f
    _jump144:; // Begin body of loop
    double _285 = 16.0;
    int64_t _286 = 0;
    _286 *= _282.d0;
    _286 += _284;
    _282.data[_286] = _285;
    _284++;
    if (_284 < _257)
    goto _jump144;
    // End body of loop
    if (_262 >= 0)
    goto _jump145;
    fail_assertion("negative array index");
    _jump145:;
    if (_262 < _282.d0)
    goto _jump146;
    fail_assertion("index too large");
    _jump146:;
    int64_t _287 = 0;
    _287 *= _282.d0;
    _287 += _262;
    double _288 = _282.data[_287];
    _a2_double _289;
    // Computing bound for f
    _289.d0 = _262;
    if (_262 > 0) 
    goto _jump147;
    fail_assertion("non-positive loop bound");
    _jump147:;
    // Computing bound for g
    int64_t _290 = 741;
    _289.d1 = _290;
    if (_290 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= _262;
    _291 *= _290;
    _291 *= sizeof(double);
    _289.data = jpl_alloc(_291);
    int64_t _292 = 0; // g
    int64_t _293 = 0; // f
    _jump149:; // Begin body of loop
    double _294 = 26.0;
    int64_t _295 = 0;
    _295 *= _289.d0;
    _295 += _293;
    _295 *= _289.d1;
    _295 += _292;
    _289.data[_295] = _294;
    _292++;
    if (_292 < _290)
    goto _jump149;
    _292 = 0;
    _293++;
    if (_293 < _262)
    goto _jump149;
    // End body of loop
    int64_t _296 = 27;
    if (_263 >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (_263 < _289.d0)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    if (_296 >= 0)
    goto _jump152;
    fail_assertion("negative array index");
    _jump152:;
    if (_296 < _289.d1)
    goto _jump153;
    fail_assertion("index too large");
    _jump153:;
    int64_t _297 = 0;
    _297 *= _289.d0;
    _297 += _263;
    _297 *= _289.d1;
    _297 += _296;
    double _298 = _289.data[_297];
    rgba _299 = { _279, _281, _288, _298 };
    _270 = _299;
    goto _jump154;
    _jump135:;
    double _300;
    // Computing bound for f
    if (_262 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    _300 = 0;
    int64_t _301 = 0; // f
    _jump156:; // Begin body of loop
    double _302 = 42.0;
    _300 += _302;
    _301++;
    if (_301 < _262)
    goto _jump156;
    // End body of loop
    double _303 = 46.0;
    double _304;
    // Computing bound for f
    if (_262 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing bound for g
    int64_t _305 = -_262;
    if (_305 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    _304 = 0;
    int64_t _306 = 0; // g
    int64_t _307 = 0; // f
    _jump159:; // Begin body of loop
    double _308;
    // Computing bound for h
    if (_262 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    // Computing bound for i
    int64_t _309 = 166;
    if (_309 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for j
    int64_t _310 = 774;
    if (_310 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _308 = 0;
    int64_t _311 = 0; // j
    int64_t _312 = 0; // i
    int64_t _313 = 0; // h
    _jump163:; // Begin body of loop
    double _314 = 2.0;
    _308 += _314;
    _311++;
    if (_311 < _310)
    goto _jump163;
    _311 = 0;
    _312++;
    if (_312 < _309)
    goto _jump163;
    _312 = 0;
    _313++;
    if (_313 < _262)
    goto _jump163;
    // End body of loop
    _304 += _308;
    _306++;
    if (_306 < _305)
    goto _jump159;
    _306 = 0;
    _307++;
    if (_307 < _262)
    goto _jump159;
    // End body of loop
    double _315 = 36.0;
    double _316 = 10.0;
    double _317 = 79.0;
    double _318 = 51.0;
    rgba _319 = { _315, _316, _317, _318 };
    double _320 = _319.r;
    rgba _321 = { _300, _303, _304, _320 };
    _270 = _321;
    _jump154:;
    int64_t _322 = 0;
    _322 *= _259.d0;
    _322 += _263;
    _322 *= _259.d1;
    _322 += _262;
    _259.data[_322] = _270;
    _262++;
    if (_262 < _260)
    goto _jump133;
    _262 = 0;
    _263++;
    if (_263 < _258)
    goto _jump133;
    // End body of loop
    int64_t _323 = 0;
    _323 *= _161.d0;
    _323 += _258;
    _323 *= _161.d1;
    _323 += _257;
    _161.data[_323] = _259;
    _257++;
    if (_257 < _214)
    goto _jump130;
    _257 = 0;
    _258++;
    if (_258 < _213)
    goto _jump130;
    // End body of loop
    _a1_int64_t _324;
    // Computing bound for b
    int64_t _325 = 161;
    int64_t _326 = 665;
    int64_t _327 = -_326;
    int64_t _328 = 862;
    int64_t _329 = _327 - _328;
    int64_t _330 = _325 + _329;
    int64_t _331 = -_330;
    _324.d0 = _331;
    if (_331 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= _331;
    _332 *= sizeof(int64_t);
    _324.data = jpl_alloc(_332);
    int64_t _333 = 0; // b
    _jump165:; // Begin body of loop
    int64_t _334 = -_333;
    int64_t _335;
    // Computing bound for c
    int64_t _336 = 133;
    if (_336 > 0) 
    goto _jump166;
    fail_assertion("non-positive loop bound");
    _jump166:;
    _335 = 0;
    int64_t _337 = 0; // c
    _jump167:; // Begin body of loop
    _335 += _337;
    _337++;
    if (_337 < _336)
    goto _jump167;
    // End body of loop
    bool _338 = _334 <= _335;
    int64_t _339;
    if (!_338)
    goto _jump168;
    int64_t _340;
    // Computing bound for c
    int64_t _341 = 848;
    if (_341 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    // Computing bound for d
    int64_t _342 = 929;
    int64_t _343 = -_342;
    if (_343 > 0) 
    goto _jump170;
    fail_assertion("non-positive loop bound");
    _jump170:;
    // Computing bound for e
    int64_t _344 = _333 / _333;
    if (_344 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    _340 = 0;
    int64_t _345 = 0; // e
    int64_t _346 = 0; // d
    int64_t _347 = 0; // c
    _jump172:; // Begin body of loop
    _340 += _333;
    _345++;
    if (_345 < _344)
    goto _jump172;
    _345 = 0;
    _346++;
    if (_346 < _343)
    goto _jump172;
    _346 = 0;
    _347++;
    if (_347 < _341)
    goto _jump172;
    // End body of loop
    _339 = _340;
    goto _jump173;
    _jump168:;
    bool _348 = true;
    bool _349 = !_348;
    int64_t _350;
    if (!_349)
    goto _jump174;
    int64_t _351;
    // Computing bound for c
    if (_333 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    _351 = 0;
    int64_t _352 = 0; // c
    _jump176:; // Begin body of loop
    _351 += _333;
    _352++;
    if (_352 < _333)
    goto _jump176;
    // End body of loop
    _350 = _351;
    goto _jump177;
    _jump174:;
    int64_t _353 = 309;
    _350 = _353;
    _jump177:;
    _339 = _350;
    _jump173:;
    int64_t _354 = -_339;
    int64_t _355 = 0;
    _355 *= _324.d0;
    _355 += _333;
    _324.data[_355] = _354;
    _333++;
    if (_333 < _331)
    goto _jump165;
    // End body of loop
    int64_t _356 = 874;
    if (_356 >= 0)
    goto _jump178;
    fail_assertion("negative array index");
    _jump178:;
    if (_356 < _0.d0)
    goto _jump179;
    fail_assertion("index too large");
    _jump179:;
    int64_t _357 = 0;
    _357 *= _0.d0;
    _357 += _356;
    bool _358 = _0.data[_357];
    bool _359;
    if (!_358)
    goto _jump180;
    double _360 = 86.0;
    bool _361 = true;
    double _362;
    if (!_361)
    goto _jump181;
    double _363 = 8.0;
    _362 = _363;
    goto _jump182;
    _jump181:;
    double _364 = 22.0;
    _362 = _364;
    _jump182:;
    double _365 = _360 / _362;
    bool _366 = true;
    double _367;
    if (!_366)
    goto _jump183;
    double _368 = 27.0;
    double _369 = 45.0;
    double _370 = _368 / _369;
    _367 = _370;
    goto _jump184;
    _jump183:;
    double _371 = 40.0;
    double _372 = 63.0;
    double _373 = _371 * _372;
    _367 = _373;
    _jump184:;
    bool _374 = _365 > _367;
    _359 = _374;
    goto _jump185;
    _jump180:;
    double _375;
    // Computing bound for b
    int64_t _376 = 278;
    if (_376 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    _375 = 0;
    int64_t _377 = 0; // b
    _jump187:; // Begin body of loop
    double _378 = 61.0;
    _375 += _378;
    _377++;
    if (_377 < _376)
    goto _jump187;
    // End body of loop
    double _379 = 53.0;
    double _380 = -_379;
    double _381 = -_380;
    bool _382 = _375 < _381;
    _359 = _382;
    _jump185:;
    int64_t _383;
    if (!_359)
    goto _jump188;
    int64_t _384 = 247;
    _383 = _384;
    goto _jump189;
    _jump188:;
    int64_t _385;
    // Computing bound for b
    int64_t _386 = 788;
    int64_t _387 = 383;
    int64_t _388 = _386 * _387;
    _a1_int64_t _389;
    _389.d0 = 1;
    _389.data = jpl_alloc(sizeof(int64_t) * 1);
    _389.data[0] = _388;
    int64_t _390 = 185;
    if (_390 >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (_390 < _389.d0)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    int64_t _391 = 0;
    _391 *= _389.d0;
    _391 += _390;
    int64_t _392 = _389.data[_391];
    if (_392 > 0) 
    goto _jump192;
    fail_assertion("non-positive loop bound");
    _jump192:;
    _385 = 0;
    int64_t _393 = 0; // b
    _jump193:; // Begin body of loop
    bool _394 = false;
    _a1_int64_t _395;
    if (!_394)
    goto _jump194;
    _a1_int64_t _396;
    // Computing bound for c
    int64_t _397 = 993;
    _396.d0 = _397;
    if (_397 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    // Computing total size of heap memory to allocate
    int64_t _398 = 1;
    _398 *= _397;
    _398 *= sizeof(int64_t);
    _396.data = jpl_alloc(_398);
    int64_t _399 = 0; // c
    _jump196:; // Begin body of loop
    int64_t _400 = 455;
    int64_t _401 = 0;
    _401 *= _396.d0;
    _401 += _399;
    _396.data[_401] = _400;
    _399++;
    if (_399 < _397)
    goto _jump196;
    // End body of loop
    _395 = _396;
    goto _jump197;
    _jump194:;
    _a1_int64_t _402;
    // Computing bound for c
    _402.d0 = _393;
    if (_393 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing total size of heap memory to allocate
    int64_t _403 = 1;
    _403 *= _393;
    _403 *= sizeof(int64_t);
    _402.data = jpl_alloc(_403);
    int64_t _404 = 0; // c
    _jump199:; // Begin body of loop
    int64_t _405 = 0;
    _405 *= _402.d0;
    _405 += _404;
    _402.data[_405] = _393;
    _404++;
    if (_404 < _393)
    goto _jump199;
    // End body of loop
    _395 = _402;
    _jump197:;
    _a1_int64_t _406;
    // Computing bound for c
    int64_t _407 = 593;
    _406.d0 = _407;
    if (_407 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing total size of heap memory to allocate
    int64_t _408 = 1;
    _408 *= _407;
    _408 *= sizeof(int64_t);
    _406.data = jpl_alloc(_408);
    int64_t _409 = 0; // c
    _jump201:; // Begin body of loop
    int64_t _410 = 0;
    _410 *= _406.d0;
    _410 += _409;
    _406.data[_410] = _393;
    _409++;
    if (_409 < _407)
    goto _jump201;
    // End body of loop
    int64_t _411 = -_393;
    if (_411 >= 0)
    goto _jump202;
    fail_assertion("negative array index");
    _jump202:;
    if (_411 < _406.d0)
    goto _jump203;
    fail_assertion("index too large");
    _jump203:;
    int64_t _412 = 0;
    _412 *= _406.d0;
    _412 += _411;
    int64_t _413 = _406.data[_412];
    if (_413 >= 0)
    goto _jump204;
    fail_assertion("negative array index");
    _jump204:;
    if (_413 < _395.d0)
    goto _jump205;
    fail_assertion("index too large");
    _jump205:;
    int64_t _414 = 0;
    _414 *= _395.d0;
    _414 += _413;
    int64_t _415 = _395.data[_414];
    _385 += _415;
    _393++;
    if (_393 < _392)
    goto _jump193;
    // End body of loop
    _383 = _385;
    _jump189:;
    if (_383 >= 0)
    goto _jump206;
    fail_assertion("negative array index");
    _jump206:;
    if (_383 < _324.d0)
    goto _jump207;
    fail_assertion("index too large");
    _jump207:;
    int64_t _416 = 0;
    _416 *= _324.d0;
    _416 += _383;
    int64_t _417 = _324.data[_416];
    int64_t _418;
    // Computing bound for b
    bool _419 = false;
    int64_t _420;
    if (!_419)
    goto _jump208;
    int64_t _421 = 804;
    _420 = _421;
    goto _jump209;
    _jump208:;
    int64_t _422 = 851;
    _420 = _422;
    _jump209:;
    if (_420 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    _418 = 0;
    int64_t _423 = 0; // b
    _jump211:; // Begin body of loop
    _a2_int64_t _424;
    // Computing bound for c
    int64_t _425 = 710;
    _424.d0 = _425;
    if (_425 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for d
    int64_t _426 = 941;
    int64_t _427 = -_426;
    _424.d1 = _427;
    if (_427 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= _425;
    _428 *= _427;
    _428 *= sizeof(int64_t);
    _424.data = jpl_alloc(_428);
    int64_t _429 = 0; // d
    int64_t _430 = 0; // c
    _jump214:; // Begin body of loop
    int64_t _431 = 312;
    int64_t _432 = _431 - _429;
    int64_t _433 = 0;
    _433 *= _424.d0;
    _433 += _430;
    _433 *= _424.d1;
    _433 += _429;
    _424.data[_433] = _432;
    _429++;
    if (_429 < _427)
    goto _jump214;
    _429 = 0;
    _430++;
    if (_430 < _425)
    goto _jump214;
    // End body of loop
    int64_t _434 = 175;
    int64_t _435 = 436;
    int64_t _436 = _434 * _435;
    if (_423 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (_423 < _424.d0)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    if (_436 >= 0)
    goto _jump217;
    fail_assertion("negative array index");
    _jump217:;
    if (_436 < _424.d1)
    goto _jump218;
    fail_assertion("index too large");
    _jump218:;
    int64_t _437 = 0;
    _437 *= _424.d0;
    _437 += _423;
    _437 *= _424.d1;
    _437 += _436;
    int64_t _438 = _424.data[_437];
    _418 += _438;
    _423++;
    if (_423 < _420)
    goto _jump211;
    // End body of loop
    int64_t _439 = -_418;
    int64_t _440;
    // Computing bound for b
    bool _441 = false;
    double _442;
    if (!_441)
    goto _jump219;
    double _443 = 81.0;
    _442 = _443;
    goto _jump220;
    _jump219:;
    double _444 = 76.0;
    _442 = _444;
    _jump220:;
    double _445 = 58.0;
    double _446 = -_445;
    double _447 = -_446;
    bool _448 = _442 == _447;
    int64_t _449;
    if (!_448)
    goto _jump221;
    int64_t _450 = 773;
    int64_t _451 = -_450;
    int64_t _452 = -_451;
    int64_t _453;
    // Computing bound for b
    int64_t _454 = 861;
    if (_454 > 0) 
    goto _jump222;
    fail_assertion("non-positive loop bound");
    _jump222:;
    // Computing bound for c
    int64_t _455 = 108;
    if (_455 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    _453 = 0;
    int64_t _456 = 0; // c
    int64_t _457 = 0; // b
    _jump224:; // Begin body of loop
    _453 += _457;
    _456++;
    if (_456 < _455)
    goto _jump224;
    _456 = 0;
    _457++;
    if (_457 < _454)
    goto _jump224;
    // End body of loop
    int64_t _458 = 800;
    int64_t _459 = _453 / _458;
    int64_t _460 = _452 / _459;
    _449 = _460;
    goto _jump225;
    _jump221:;
    int64_t _461 = 644;
    _449 = _461;
    _jump225:;
    if (_449 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for c
    int64_t _462 = 262;
    int64_t _463 = -_462;
    int64_t _464 = -_463;
    int64_t _465 = -_464;
    if (_465 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    _440 = 0;
    int64_t _466 = 0; // c
    int64_t _467 = 0; // b
    _jump228:; // Begin body of loop
    _440 += _467;
    _466++;
    if (_466 < _465)
    goto _jump228;
    _466 = 0;
    _467++;
    if (_467 < _449)
    goto _jump228;
    // End body of loop
    int64_t _468 = _439 + _440;
    if (_417 >= 0)
    goto _jump229;
    fail_assertion("negative array index");
    _jump229:;
    if (_417 < _161.d0)
    goto _jump230;
    fail_assertion("index too large");
    _jump230:;
    if (_468 >= 0)
    goto _jump231;
    fail_assertion("negative array index");
    _jump231:;
    if (_468 < _161.d1)
    goto _jump232;
    fail_assertion("index too large");
    _jump232:;
    int64_t _469 = 0;
    _469 *= _161.d0;
    _469 += _417;
    _469 *= _161.d1;
    _469 += _468;
    _a2_rgba _470 = _161.data[_469];
    write_image(_470, "b.png");
    print("b");
    double _471 = 11.0;
    _a1_double _472;
    // Computing bound for d
    int64_t _473 = 272;
    int64_t _474 = -_473;
    _472.d0 = _474;
    if (_474 > 0) 
    goto _jump1089;
    fail_assertion("non-positive loop bound");
    _jump1089:;
    // Computing total size of heap memory to allocate
    int64_t _475 = 1;
    _475 *= _474;
    _475 *= sizeof(double);
    _472.data = jpl_alloc(_475);
    int64_t _476 = 0; // d
    _jump1090:; // Begin body of loop
    _a3_double _477;
    // Computing bound for e
    _477.d0 = _476;
    if (_476 > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    // Computing bound for f
    int64_t _478 = 272;
    int64_t _479 = _478 * _476;
    _477.d1 = _479;
    if (_479 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing bound for g
    int64_t _480 = 880;
    _477.d2 = _480;
    if (_480 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing total size of heap memory to allocate
    int64_t _481 = 1;
    _481 *= _476;
    _481 *= _479;
    _481 *= _480;
    _481 *= sizeof(double);
    _477.data = jpl_alloc(_481);
    int64_t _482 = 0; // g
    int64_t _483 = 0; // f
    int64_t _484 = 0; // e
    _jump1094:; // Begin body of loop
    double _485 = 49.0;
    double _486 = 15.0;
    double _487 = _485 + _486;
    int64_t _488 = 0;
    _488 *= _477.d0;
    _488 += _484;
    _488 *= _477.d1;
    _488 += _483;
    _488 *= _477.d2;
    _488 += _482;
    _477.data[_488] = _487;
    _482++;
    if (_482 < _480)
    goto _jump1094;
    _482 = 0;
    _483++;
    if (_483 < _479)
    goto _jump1094;
    _483 = 0;
    _484++;
    if (_484 < _476)
    goto _jump1094;
    // End body of loop
    int64_t _489 = -_476;
    int64_t _490 = -_489;
    int64_t _491;
    // Computing bound for e
    int64_t _492 = -_476;
    if (_492 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    _491 = 0;
    int64_t _493 = 0; // e
    _jump1096:; // Begin body of loop
    _491 += _493;
    _493++;
    if (_493 < _492)
    goto _jump1096;
    // End body of loop
    int64_t _494;
    // Computing bound for e
    int64_t _495 = -_476;
    if (_495 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for f
    int64_t _496 = 325;
    if (_496 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    // Computing bound for g
    int64_t _497;
    // Computing bound for e
    if (_476 > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    // Computing bound for f
    if (_476 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing bound for g
    int64_t _498 = 902;
    if (_498 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    _497 = 0;
    int64_t _499 = 0; // g
    int64_t _500 = 0; // f
    int64_t _501 = 0; // e
    _jump1102:; // Begin body of loop
    int64_t _502 = 9;
    _497 += _502;
    _499++;
    if (_499 < _498)
    goto _jump1102;
    _499 = 0;
    _500++;
    if (_500 < _476)
    goto _jump1102;
    _500 = 0;
    _501++;
    if (_501 < _476)
    goto _jump1102;
    // End body of loop
    if (_497 > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    _494 = 0;
    int64_t _503 = 0; // g
    int64_t _504 = 0; // f
    int64_t _505 = 0; // e
    _jump1104:; // Begin body of loop
    int64_t _506 = -_476;
    _494 += _506;
    _503++;
    if (_503 < _497)
    goto _jump1104;
    _503 = 0;
    _504++;
    if (_504 < _496)
    goto _jump1104;
    _504 = 0;
    _505++;
    if (_505 < _495)
    goto _jump1104;
    // End body of loop
    if (_490 >= 0)
    goto _jump1105;
    fail_assertion("negative array index");
    _jump1105:;
    if (_490 < _477.d0)
    goto _jump1106;
    fail_assertion("index too large");
    _jump1106:;
    if (_491 >= 0)
    goto _jump1107;
    fail_assertion("negative array index");
    _jump1107:;
    if (_491 < _477.d1)
    goto _jump1108;
    fail_assertion("index too large");
    _jump1108:;
    if (_494 >= 0)
    goto _jump1109;
    fail_assertion("negative array index");
    _jump1109:;
    if (_494 < _477.d2)
    goto _jump1110;
    fail_assertion("index too large");
    _jump1110:;
    int64_t _507 = 0;
    _507 *= _477.d0;
    _507 += _490;
    _507 *= _477.d1;
    _507 += _491;
    _507 *= _477.d2;
    _507 += _494;
    double _508 = _477.data[_507];
    int64_t _509 = 0;
    _509 *= _472.d0;
    _509 += _476;
    _472.data[_509] = _508;
    _476++;
    if (_476 < _474)
    goto _jump1090;
    // End body of loop
    int64_t _510 = 339;
    int64_t _511 = -_510;
    if (_511 >= 0)
    goto _jump1111;
    fail_assertion("negative array index");
    _jump1111:;
    if (_511 < _472.d0)
    goto _jump1112;
    fail_assertion("index too large");
    _jump1112:;
    int64_t _512 = 0;
    _512 *= _472.d0;
    _512 += _511;
    double _513 = _472.data[_512];
    bool _514 = _471 <= _513;
    rgba _515;
    if (!_514)
    goto _jump1113;
    _a1_double _516;
    // Computing bound for d
    int64_t _517 = 591;
    int64_t _518 = 263;
    int64_t _519 = _517 / _518;
    int64_t _520 = -_519;
    _516.d0 = _520;
    if (_520 > 0) 
    goto _jump1114;
    fail_assertion("non-positive loop bound");
    _jump1114:;
    // Computing total size of heap memory to allocate
    int64_t _521 = 1;
    _521 *= _520;
    _521 *= sizeof(double);
    _516.data = jpl_alloc(_521);
    int64_t _522 = 0; // d
    _jump1115:; // Begin body of loop
    double _523;
    // Computing bound for e
    int64_t _524;
    // Computing bound for e
    int64_t _525 = 406;
    if (_525 > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    _524 = 0;
    int64_t _526 = 0; // e
    _jump1117:; // Begin body of loop
    int64_t _527 = 849;
    _524 += _527;
    _526++;
    if (_526 < _525)
    goto _jump1117;
    // End body of loop
    if (_524 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    // Computing bound for f
    if (_522 > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing bound for g
    double _528 = 35.0;
    double _529 = 54.0;
    bool _530 = _528 != _529;
    int64_t _531;
    if (!_530)
    goto _jump1120;
    int64_t _532 = 709;
    _531 = _532;
    goto _jump1121;
    _jump1120:;
    int64_t _533 = 405;
    _531 = _533;
    _jump1121:;
    if (_531 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    _523 = 0;
    int64_t _534 = 0; // g
    int64_t _535 = 0; // f
    int64_t _536 = 0; // e
    _jump1123:; // Begin body of loop
    double _537 = 4.0;
    _523 += _537;
    _534++;
    if (_534 < _531)
    goto _jump1123;
    _534 = 0;
    _535++;
    if (_535 < _522)
    goto _jump1123;
    _535 = 0;
    _536++;
    if (_536 < _524)
    goto _jump1123;
    // End body of loop
    int64_t _538 = 0;
    _538 *= _516.d0;
    _538 += _522;
    _516.data[_538] = _523;
    _522++;
    if (_522 < _520)
    goto _jump1115;
    // End body of loop
    int64_t _539 = 612;
    int64_t _540 = 196;
    int64_t _541 = _539 % _540;
    if (_541 >= 0)
    goto _jump1124;
    fail_assertion("negative array index");
    _jump1124:;
    if (_541 < _516.d0)
    goto _jump1125;
    fail_assertion("index too large");
    _jump1125:;
    int64_t _542 = 0;
    _542 *= _516.d0;
    _542 += _541;
    double _543 = _516.data[_542];
    double _544 = 14.0;
    double _545 = -_544;
    double _546 = -_545;
    double _547 = 10.0;
    double _548 = -_547;
    double _549 = 1.0;
    double _550 = 58.0;
    double _551 = 98.0;
    rgba _552 = { _548, _549, _550, _551 };
    double _553 = _552.b;
    double _554;
    // Computing bound for d
    int64_t _555 = 666;
    if (_555 > 0) 
    goto _jump1126;
    fail_assertion("non-positive loop bound");
    _jump1126:;
    _554 = 0;
    int64_t _556 = 0; // d
    _jump1127:; // Begin body of loop
    double _557;
    // Computing bound for e
    int64_t _558 = 330;
    if (_558 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    _557 = 0;
    int64_t _559 = 0; // e
    _jump1129:; // Begin body of loop
    double _560 = 11.0;
    _557 += _560;
    _559++;
    if (_559 < _558)
    goto _jump1129;
    // End body of loop
    _554 += _557;
    _556++;
    if (_556 < _555)
    goto _jump1127;
    // End body of loop
    double _561 = 97.0;
    double _562 = 54.0;
    double _563 = _561 * _562;
    double _564 = 15.0;
    double _565 = _563 * _564;
    double _566 = fmod(_554, _565);
    int64_t _567 = 419;
    int64_t _568 = 397;
    bool _569 = _567 != _568;
    bool _570 = !_569;
    double _571;
    if (!_570)
    goto _jump1130;
    double _572 = 72.0;
    _571 = _572;
    goto _jump1131;
    _jump1130:;
    double _573 = 53.0;
    _571 = _573;
    _jump1131:;
    rgba _574 = { _546, _553, _566, _571 };
    double _575 = _574.g;
    double _576 = 17.0;
    double _577 = -_576;
    double _578 = 2.0;
    double _579 = fmod(_577, _578);
    bool _580 = true;
    double _581;
    if (!_580)
    goto _jump1132;
    double _582 = 29.0;
    double _583 = -_582;
    _581 = _583;
    goto _jump1133;
    _jump1132:;
    double _584 = 25.0;
    _581 = _584;
    _jump1133:;
    double _585 = _579 / _581;
    bool _586 = false;
    double _587;
    if (!_586)
    goto _jump1134;
    bool _588 = true;
    double _589;
    if (!_588)
    goto _jump1135;
    double _590 = 97.0;
    double _591 = 69.0;
    double _592 = _590 * _591;
    _589 = _592;
    goto _jump1136;
    _jump1135:;
    double _593 = 41.0;
    _589 = _593;
    _jump1136:;
    _587 = _589;
    goto _jump1137;
    _jump1134:;
    double _594 = 46.0;
    _587 = _594;
    _jump1137:;
    bool _595 = false;
    bool _596 = !_595;
    bool _597 = true;
    bool _598 = !_597;
    bool _599 = _596 == _598;
    double _600;
    if (!_599)
    goto _jump1138;
    bool _601 = false;
    bool _602;
    if (!_601)
    goto _jump1139;
    bool _603 = true;
    _602 = _603;
    goto _jump1140;
    _jump1139:;
    bool _604 = false;
    _602 = _604;
    _jump1140:;
    double _605;
    if (!_602)
    goto _jump1141;
    double _606 = 99.0;
    _605 = _606;
    goto _jump1142;
    _jump1141:;
    double _607 = 95.0;
    _605 = _607;
    _jump1142:;
    _600 = _605;
    goto _jump1143;
    _jump1138:;
    double _608 = 99.0;
    _600 = _608;
    _jump1143:;
    double _609 = 95.0;
    double _610 = 32.0;
    double _611 = 84.0;
    double _612 = 30.0;
    rgba _613 = { _609, _610, _611, _612 };
    double _614 = _613.g;
    rgba _615 = { _585, _587, _600, _614 };
    double _616 = _615.r;
    double _617 = 38.0;
    double _618 = -_617;
    double _619 = -_618;
    double _620 = -_619;
    double _621 = 99.0;
    double _622 = -_621;
    double _623 = 65.0;
    double _624 = -_623;
    double _625 = -_624;
    double _626 = _622 + _625;
    double _627;
    // Computing bound for d
    int64_t _628 = 535;
    if (_628 > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    _627 = 0;
    int64_t _629 = 0; // d
    _jump1145:; // Begin body of loop
    double _630 = 7.0;
    _627 += _630;
    _629++;
    if (_629 < _628)
    goto _jump1145;
    // End body of loop
    double _631 = -_627;
    double _632;
    // Computing bound for d
    int64_t _633 = 578;
    int64_t _634 = -_633;
    int64_t _635 = -_634;
    if (_635 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing bound for e
    int64_t _636 = 485;
    int64_t _637 = 603;
    int64_t _638 = -_637;
    int64_t _639 = _636 - _638;
    if (_639 > 0) 
    goto _jump1147;
    fail_assertion("non-positive loop bound");
    _jump1147:;
    _632 = 0;
    int64_t _640 = 0; // e
    int64_t _641 = 0; // d
    _jump1148:; // Begin body of loop
    double _642 = 30.0;
    _632 += _642;
    _640++;
    if (_640 < _639)
    goto _jump1148;
    _640 = 0;
    _641++;
    if (_641 < _635)
    goto _jump1148;
    // End body of loop
    rgba _643 = { _620, _626, _631, _632 };
    double _644 = _643.b;
    rgba _645 = { _543, _575, _616, _644 };
    _515 = _645;
    goto _jump1149;
    _jump1113:;
    double _646 = 78.0;
    double _647;
    // Computing bound for d
    int64_t _648 = 38;
    int64_t _649 = -_648;
    if (_649 > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    _647 = 0;
    int64_t _650 = 0; // d
    _jump1151:; // Begin body of loop
    double _651 = 51.0;
    _647 += _651;
    _650++;
    if (_650 < _649)
    goto _jump1151;
    // End body of loop
    double _652 = _646 / _647;
    double _653 = 68.0;
    double _654 = 6.0;
    double _655 = 21.0;
    rgba _656 = { _652, _653, _654, _655 };
    double _657 = _656.r;
    _a1_double _658;
    // Computing bound for d
    bool _659 = true;
    int64_t _660;
    if (!_659)
    goto _jump1152;
    int64_t _661;
    // Computing bound for d
    int64_t _662 = 887;
    if (_662 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    // Computing bound for e
    bool _663 = false;
    int64_t _664;
    if (!_663)
    goto _jump1154;
    int64_t _665 = 32;
    _664 = _665;
    goto _jump1155;
    _jump1154:;
    int64_t _666 = 693;
    _664 = _666;
    _jump1155:;
    if (_664 > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    // Computing bound for f
    bool _667 = false;
    int64_t _668;
    if (!_667)
    goto _jump1157;
    int64_t _669 = 525;
    _668 = _669;
    goto _jump1158;
    _jump1157:;
    int64_t _670 = 155;
    _668 = _670;
    _jump1158:;
    if (_668 > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    _661 = 0;
    int64_t _671 = 0; // f
    int64_t _672 = 0; // e
    int64_t _673 = 0; // d
    _jump1160:; // Begin body of loop
    _661 += _671;
    _671++;
    if (_671 < _668)
    goto _jump1160;
    _671 = 0;
    _672++;
    if (_672 < _664)
    goto _jump1160;
    _672 = 0;
    _673++;
    if (_673 < _662)
    goto _jump1160;
    // End body of loop
    _660 = _661;
    goto _jump1161;
    _jump1152:;
    int64_t _674 = 68;
    _660 = _674;
    _jump1161:;
    _658.d0 = _660;
    if (_660 > 0) 
    goto _jump1162;
    fail_assertion("non-positive loop bound");
    _jump1162:;
    // Computing total size of heap memory to allocate
    int64_t _675 = 1;
    _675 *= _660;
    _675 *= sizeof(double);
    _658.data = jpl_alloc(_675);
    int64_t _676 = 0; // d
    _jump1163:; // Begin body of loop
    bool _678 = false;
    bool _677 = _678;
    if (0 != _678)
    goto _jump1164;
    bool _679 = true;
    bool _680 = !_679;
    _677 = _680;
    _jump1164:;
    double _681;
    if (!_677)
    goto _jump1165;
    double _682 = 47.0;
    double _683 = -_682;
    _681 = _683;
    goto _jump1166;
    _jump1165:;
    double _684 = 19.0;
    _681 = _684;
    _jump1166:;
    int64_t _685 = 0;
    _685 *= _658.d0;
    _685 += _676;
    _658.data[_685] = _681;
    _676++;
    if (_676 < _660)
    goto _jump1163;
    // End body of loop
    _a1__a2_int64_t _686;
    // Computing bound for d
    int64_t _687 = 234;
    int64_t _688 = -_687;
    _686.d0 = _688;
    if (_688 > 0) 
    goto _jump1167;
    fail_assertion("non-positive loop bound");
    _jump1167:;
    // Computing total size of heap memory to allocate
    int64_t _689 = 1;
    _689 *= _688;
    _689 *= sizeof(_a2_int64_t);
    _686.data = jpl_alloc(_689);
    int64_t _690 = 0; // d
    _jump1168:; // Begin body of loop
    _a2_int64_t _691;
    // Computing bound for e
    _691.d0 = _690;
    if (_690 > 0) 
    goto _jump1169;
    fail_assertion("non-positive loop bound");
    _jump1169:;
    // Computing bound for f
    _691.d1 = _690;
    if (_690 > 0) 
    goto _jump1170;
    fail_assertion("non-positive loop bound");
    _jump1170:;
    // Computing total size of heap memory to allocate
    int64_t _692 = 1;
    _692 *= _690;
    _692 *= _690;
    _692 *= sizeof(int64_t);
    _691.data = jpl_alloc(_692);
    int64_t _693 = 0; // f
    int64_t _694 = 0; // e
    _jump1171:; // Begin body of loop
    int64_t _695 = 388;
    int64_t _696 = 0;
    _696 *= _691.d0;
    _696 += _694;
    _696 *= _691.d1;
    _696 += _693;
    _691.data[_696] = _695;
    _693++;
    if (_693 < _690)
    goto _jump1171;
    _693 = 0;
    _694++;
    if (_694 < _690)
    goto _jump1171;
    // End body of loop
    int64_t _697 = 0;
    _697 *= _686.d0;
    _697 += _690;
    _686.data[_697] = _691;
    _690++;
    if (_690 < _688)
    goto _jump1168;
    // End body of loop
    int64_t _698;
    // Computing bound for d
    int64_t _699 = 423;
    if (_699 > 0) 
    goto _jump1172;
    fail_assertion("non-positive loop bound");
    _jump1172:;
    _698 = 0;
    int64_t _700 = 0; // d
    _jump1173:; // Begin body of loop
    _698 += _700;
    _700++;
    if (_700 < _699)
    goto _jump1173;
    // End body of loop
    int64_t _701 = 244;
    int64_t _702 = _698 - _701;
    if (_702 >= 0)
    goto _jump1174;
    fail_assertion("negative array index");
    _jump1174:;
    if (_702 < _686.d0)
    goto _jump1175;
    fail_assertion("index too large");
    _jump1175:;
    int64_t _703 = 0;
    _703 *= _686.d0;
    _703 += _702;
    _a2_int64_t _704 = _686.data[_703];
    int64_t _705 = 166;
    int64_t _706;
    // Computing bound for d
    int64_t _707 = 158;
    int64_t _708 = -_707;
    int64_t _709 = -_708;
    if (_709 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing bound for e
    double _710 = 6.0;
    double _711 = 19.0;
    bool _712 = _710 > _711;
    int64_t _713;
    if (!_712)
    goto _jump1177;
    int64_t _714 = 743;
    int64_t _715 = -_714;
    _713 = _715;
    goto _jump1178;
    _jump1177:;
    int64_t _716;
    // Computing bound for d
    int64_t _717 = 626;
    if (_717 > 0) 
    goto _jump1179;
    fail_assertion("non-positive loop bound");
    _jump1179:;
    _716 = 0;
    int64_t _718 = 0; // d
    _jump1180:; // Begin body of loop
    _716 += _718;
    _718++;
    if (_718 < _717)
    goto _jump1180;
    // End body of loop
    _713 = _716;
    _jump1178:;
    if (_713 > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    // Computing bound for f
    int64_t _719 = 771;
    if (_719 > 0) 
    goto _jump1182;
    fail_assertion("non-positive loop bound");
    _jump1182:;
    _706 = 0;
    int64_t _720 = 0; // f
    int64_t _721 = 0; // e
    int64_t _722 = 0; // d
    _jump1183:; // Begin body of loop
    _706 += _722;
    _720++;
    if (_720 < _719)
    goto _jump1183;
    _720 = 0;
    _721++;
    if (_721 < _713)
    goto _jump1183;
    _721 = 0;
    _722++;
    if (_722 < _709)
    goto _jump1183;
    // End body of loop
    if (_705 >= 0)
    goto _jump1184;
    fail_assertion("negative array index");
    _jump1184:;
    if (_705 < _704.d0)
    goto _jump1185;
    fail_assertion("index too large");
    _jump1185:;
    if (_706 >= 0)
    goto _jump1186;
    fail_assertion("negative array index");
    _jump1186:;
    if (_706 < _704.d1)
    goto _jump1187;
    fail_assertion("index too large");
    _jump1187:;
    int64_t _723 = 0;
    _723 *= _704.d0;
    _723 += _705;
    _723 *= _704.d1;
    _723 += _706;
    int64_t _724 = _704.data[_723];
    if (_724 >= 0)
    goto _jump1188;
    fail_assertion("negative array index");
    _jump1188:;
    if (_724 < _658.d0)
    goto _jump1189;
    fail_assertion("index too large");
    _jump1189:;
    int64_t _725 = 0;
    _725 *= _658.d0;
    _725 += _724;
    double _726 = _658.data[_725];
    double _727 = 49.0;
    _a1_bool _728;
    // Computing bound for d
    int64_t _729 = 643;
    _728.d0 = _729;
    if (_729 > 0) 
    goto _jump1190;
    fail_assertion("non-positive loop bound");
    _jump1190:;
    // Computing total size of heap memory to allocate
    int64_t _730 = 1;
    _730 *= _729;
    _730 *= sizeof(bool);
    _728.data = jpl_alloc(_730);
    int64_t _731 = 0; // d
    _jump1191:; // Begin body of loop
    bool _732 = true;
    int64_t _733 = 0;
    _733 *= _728.d0;
    _733 += _731;
    _728.data[_733] = _732;
    _731++;
    if (_731 < _729)
    goto _jump1191;
    // End body of loop
    int64_t _734 = 129;
    if (_734 >= 0)
    goto _jump1192;
    fail_assertion("negative array index");
    _jump1192:;
    if (_734 < _728.d0)
    goto _jump1193;
    fail_assertion("index too large");
    _jump1193:;
    int64_t _735 = 0;
    _735 *= _728.d0;
    _735 += _734;
    bool _736 = _728.data[_735];
    double _737 = 26.0;
    double _738 = 98.0;
    bool _739 = _737 != _738;
    bool _740 = _736 == _739;
    double _741;
    if (!_740)
    goto _jump1194;
    bool _742 = false;
    bool _743 = !_742;
    double _744;
    if (!_743)
    goto _jump1195;
    double _745 = 5.0;
    _744 = _745;
    goto _jump1196;
    _jump1195:;
    double _746 = 46.0;
    _744 = _746;
    _jump1196:;
    double _747 = 26.0;
    double _748 = 32.0;
    double _749 = _747 - _748;
    double _750 = _744 * _749;
    _741 = _750;
    goto _jump1197;
    _jump1194:;
    double _751 = 30.0;
    _741 = _751;
    _jump1197:;
    double _752 = -_741;
    rgba _753 = { _657, _726, _727, _752 };
    _515 = _753;
    _jump1149:;
    _a3__a1_bool _754;
    // Computing bound for g
    int64_t _755 = 574;
    _754.d0 = _755;
    if (_755 > 0) 
    goto _jump1885;
    fail_assertion("non-positive loop bound");
    _jump1885:;
    // Computing bound for h
    int64_t _756 = 97;
    _754.d1 = _756;
    if (_756 > 0) 
    goto _jump1886;
    fail_assertion("non-positive loop bound");
    _jump1886:;
    // Computing bound for i
    _a2_int64_t _757;
    // Computing bound for g
    int64_t _758;
    // Computing bound for g
    int64_t _759 = 591;
    if (_759 > 0) 
    goto _jump1887;
    fail_assertion("non-positive loop bound");
    _jump1887:;
    // Computing bound for h
    int64_t _760 = 736;
    if (_760 > 0) 
    goto _jump1888;
    fail_assertion("non-positive loop bound");
    _jump1888:;
    _758 = 0;
    int64_t _761 = 0; // h
    int64_t _762 = 0; // g
    _jump1889:; // Begin body of loop
    _758 += _761;
    _761++;
    if (_761 < _760)
    goto _jump1889;
    _761 = 0;
    _762++;
    if (_762 < _759)
    goto _jump1889;
    // End body of loop
    _757.d0 = _758;
    if (_758 > 0) 
    goto _jump1890;
    fail_assertion("non-positive loop bound");
    _jump1890:;
    // Computing bound for h
    int64_t _763 = 151;
    int64_t _764 = 426;
    int64_t _765 = _763 - _764;
    _757.d1 = _765;
    if (_765 > 0) 
    goto _jump1891;
    fail_assertion("non-positive loop bound");
    _jump1891:;
    // Computing total size of heap memory to allocate
    int64_t _766 = 1;
    _766 *= _758;
    _766 *= _765;
    _766 *= sizeof(int64_t);
    _757.data = jpl_alloc(_766);
    int64_t _767 = 0; // h
    int64_t _768 = 0; // g
    _jump1892:; // Begin body of loop
    int64_t _769 = 0;
    _769 *= _757.d0;
    _769 += _768;
    _769 *= _757.d1;
    _769 += _767;
    _757.data[_769] = _768;
    _767++;
    if (_767 < _765)
    goto _jump1892;
    _767 = 0;
    _768++;
    if (_768 < _758)
    goto _jump1892;
    // End body of loop
    int64_t _770 = 612;
    int64_t _771 = 663;
    int64_t _772 = _770 - _771;
    int64_t _773 = -_772;
    int64_t _774 = 984;
    if (_773 >= 0)
    goto _jump1893;
    fail_assertion("negative array index");
    _jump1893:;
    if (_773 < _757.d0)
    goto _jump1894;
    fail_assertion("index too large");
    _jump1894:;
    if (_774 >= 0)
    goto _jump1895;
    fail_assertion("negative array index");
    _jump1895:;
    if (_774 < _757.d1)
    goto _jump1896;
    fail_assertion("index too large");
    _jump1896:;
    int64_t _775 = 0;
    _775 *= _757.d0;
    _775 += _773;
    _775 *= _757.d1;
    _775 += _774;
    int64_t _776 = _757.data[_775];
    _754.d2 = _776;
    if (_776 > 0) 
    goto _jump1897;
    fail_assertion("non-positive loop bound");
    _jump1897:;
    // Computing total size of heap memory to allocate
    int64_t _777 = 1;
    _777 *= _755;
    _777 *= _756;
    _777 *= _776;
    _777 *= sizeof(_a1_bool);
    _754.data = jpl_alloc(_777);
    int64_t _778 = 0; // i
    int64_t _779 = 0; // h
    int64_t _780 = 0; // g
    _jump1898:; // Begin body of loop
    int64_t _781 = 0;
    _781 *= _754.d0;
    _781 += _780;
    _781 *= _754.d1;
    _781 += _779;
    _781 *= _754.d2;
    _781 += _778;
    _754.data[_781] = _0;
    _778++;
    if (_778 < _776)
    goto _jump1898;
    _778 = 0;
    _779++;
    if (_779 < _756)
    goto _jump1898;
    _779 = 0;
    _780++;
    if (_780 < _755)
    goto _jump1898;
    // End body of loop
    double _782 = _515.a;
    double _783 = 83.0;
    bool _784 = _782 == _783;
    int64_t _785;
    if (!_784)
    goto _jump1899;
    int64_t _786 = 828;
    _785 = _786;
    goto _jump1900;
    _jump1899:;
    int64_t _787 = 461;
    int64_t _788 = 342;
    int64_t _789 = _787 / _788;
    int64_t _790 = 234;
    bool _791 = _789 >= _790;
    int64_t _792;
    if (!_791)
    goto _jump1901;
    int64_t _793 = 545;
    int64_t _794 = -_793;
    int64_t _795 = -_794;
    _792 = _795;
    goto _jump1902;
    _jump1901:;
    int64_t _796 = 97;
    int64_t _797 = 456;
    int64_t _798 = _796 % _797;
    _792 = _798;
    _jump1902:;
    _785 = _792;
    _jump1900:;
    int64_t _799 = 623;
    if (_799 >= 0)
    goto _jump1903;
    fail_assertion("negative array index");
    _jump1903:;
    if (_799 < _0.d0)
    goto _jump1904;
    fail_assertion("index too large");
    _jump1904:;
    int64_t _800 = 0;
    _800 *= _0.d0;
    _800 += _799;
    bool _801 = _0.data[_800];
    int64_t _802;
    if (!_801)
    goto _jump1905;
    int64_t _803 = 450;
    int64_t _804 = -_803;
    int64_t _805 = 106;
    int64_t _806 = _804 % _805;
    _802 = _806;
    goto _jump1906;
    _jump1905:;
    int64_t _807;
    // Computing bound for g
    int64_t _808 = 587;
    if (_808 > 0) 
    goto _jump1907;
    fail_assertion("non-positive loop bound");
    _jump1907:;
    // Computing bound for h
    int64_t _809 = 61;
    int64_t _810 = -_809;
    if (_810 > 0) 
    goto _jump1908;
    fail_assertion("non-positive loop bound");
    _jump1908:;
    _807 = 0;
    int64_t _811 = 0; // h
    int64_t _812 = 0; // g
    _jump1909:; // Begin body of loop
    _807 += _812;
    _811++;
    if (_811 < _810)
    goto _jump1909;
    _811 = 0;
    _812++;
    if (_812 < _808)
    goto _jump1909;
    // End body of loop
    _802 = _807;
    _jump1906:;
    bool _813 = true;
    int64_t _814;
    if (!_813)
    goto _jump1910;
    int64_t _815 = 888;
    int64_t _816 = -_815;
    _814 = _816;
    goto _jump1911;
    _jump1910:;
    int64_t _817 = 510;
    int64_t _818 = 199;
    int64_t _819 = _817 - _818;
    _814 = _819;
    _jump1911:;
    int64_t _820 = _802 / _814;
    bool _822 = true;
    bool _821 = _822;
    if (0 != _822)
    goto _jump1912;
    bool _823 = true;
    bool _824;
    if (!_823)
    goto _jump1913;
    bool _825 = true;
    bool _826 = !_825;
    _824 = _826;
    goto _jump1914;
    _jump1913:;
    int64_t _827 = 698;
    int64_t _828 = 189;
    bool _829 = _827 == _828;
    _824 = _829;
    _jump1914:;
    _821 = _824;
    _jump1912:;
    int64_t _830;
    if (!_821)
    goto _jump1915;
    int64_t _831 = 223;
    int64_t _832 = -_831;
    int64_t _833 = -_832;
    _830 = _833;
    goto _jump1916;
    _jump1915:;
    int64_t _834 = 297;
    int64_t _835 = -_834;
    bool _836 = false;
    bool _837 = !_836;
    int64_t _838;
    if (!_837)
    goto _jump1917;
    int64_t _839 = 440;
    _838 = _839;
    goto _jump1918;
    _jump1917:;
    int64_t _840 = 940;
    int64_t _841 = 88;
    int64_t _842 = _840 + _841;
    _838 = _842;
    _jump1918:;
    int64_t _843 = _835 - _838;
    _830 = _843;
    _jump1916:;
    if (_785 >= 0)
    goto _jump1919;
    fail_assertion("negative array index");
    _jump1919:;
    if (_785 < _754.d0)
    goto _jump1920;
    fail_assertion("index too large");
    _jump1920:;
    if (_820 >= 0)
    goto _jump1921;
    fail_assertion("negative array index");
    _jump1921:;
    if (_820 < _754.d1)
    goto _jump1922;
    fail_assertion("index too large");
    _jump1922:;
    if (_830 >= 0)
    goto _jump1923;
    fail_assertion("negative array index");
    _jump1923:;
    if (_830 < _754.d2)
    goto _jump1924;
    fail_assertion("index too large");
    _jump1924:;
    int64_t _844 = 0;
    _844 *= _754.d0;
    _844 += _785;
    _844 *= _754.d1;
    _844 += _820;
    _844 *= _754.d2;
    _844 += _830;
    _a1_bool _845 = _754.data[_844];
    int64_t _846 = 558;
    int64_t _847 = 595;
    int64_t _848 = _846 + _847;
    if (_848 >= 0)
    goto _jump1925;
    fail_assertion("negative array index");
    _jump1925:;
    if (_848 < _845.d0)
    goto _jump1926;
    fail_assertion("index too large");
    _jump1926:;
    int64_t _849 = 0;
    _849 *= _845.d0;
    _849 += _848;
    bool _850 = _845.data[_849];
    bool _851 = !_850;
    double _852 = 10.0;
    double _853 = 95.0;
    bool _854 = _852 >= _853;
    _a2_rgba _855;
    if (!_854)
    goto _jump1927;
    _a2_rgba _856;
    if (!_851)
    goto _jump1928;
    bool _857;
    if (!_851)
    goto _jump1929;
    bool _858 = true;
    bool _859;
    if (!_858)
    goto _jump1930;
    _859 = _851;
    goto _jump1931;
    _jump1930:;
    _859 = _851;
    _jump1931:;
    _857 = _859;
    goto _jump1932;
    _jump1929:;
    bool _860 = false;
    bool _861;
    if (!_860)
    goto _jump1933;
    double _862 = 49.0;
    double _863 = -_862;
    double _864 = 95.0;
    double _865 = -_864;
    bool _866 = _863 <= _865;
    _861 = _866;
    goto _jump1934;
    _jump1933:;
    double _867 = _515.a;
    double _868 = 38.0;
    bool _869 = _867 < _868;
    _861 = _869;
    _jump1934:;
    _857 = _861;
    _jump1932:;
    _a2_rgba _870;
    if (!_857)
    goto _jump1935;
    _a2_rgba _871;
    // Computing bound for i
    bool _872 = true;
    int64_t _873;
    if (!_872)
    goto _jump1936;
    int64_t _874 = 893;
    int64_t _875 = 979;
    int64_t _876 = _874 % _875;
    _873 = _876;
    goto _jump1937;
    _jump1936:;
    int64_t _877;
    if (!_851)
    goto _jump1938;
    int64_t _878 = 604;
    _877 = _878;
    goto _jump1939;
    _jump1938:;
    int64_t _879 = 649;
    _877 = _879;
    _jump1939:;
    int64_t _880 = 377;
    int64_t _881 = _877 % _880;
    _873 = _881;
    _jump1937:;
    _871.d0 = _873;
    if (_873 > 0) 
    goto _jump1940;
    fail_assertion("non-positive loop bound");
    _jump1940:;
    // Computing bound for j
    _a3_int64_t _882;
    // Computing bound for i
    int64_t _883 = 92;
    _882.d0 = _883;
    if (_883 > 0) 
    goto _jump1941;
    fail_assertion("non-positive loop bound");
    _jump1941:;
    // Computing bound for j
    int64_t _884 = 744;
    _882.d1 = _884;
    if (_884 > 0) 
    goto _jump1942;
    fail_assertion("non-positive loop bound");
    _jump1942:;
    // Computing bound for k
    int64_t _885 = 855;
    _882.d2 = _885;
    if (_885 > 0) 
    goto _jump1943;
    fail_assertion("non-positive loop bound");
    _jump1943:;
    // Computing total size of heap memory to allocate
    int64_t _886 = 1;
    _886 *= _883;
    _886 *= _884;
    _886 *= _885;
    _886 *= sizeof(int64_t);
    _882.data = jpl_alloc(_886);
    int64_t _887 = 0; // k
    int64_t _888 = 0; // j
    int64_t _889 = 0; // i
    _jump1944:; // Begin body of loop
    int64_t _890 = 0;
    _890 *= _882.d0;
    _890 += _889;
    _890 *= _882.d1;
    _890 += _888;
    _890 *= _882.d2;
    _890 += _887;
    _882.data[_890] = _889;
    _887++;
    if (_887 < _885)
    goto _jump1944;
    _887 = 0;
    _888++;
    if (_888 < _884)
    goto _jump1944;
    _888 = 0;
    _889++;
    if (_889 < _883)
    goto _jump1944;
    // End body of loop
    int64_t _891 = 623;
    int64_t _892 = 866;
    bool _893 = false;
    int64_t _894;
    if (!_893)
    goto _jump1945;
    int64_t _895 = 55;
    _894 = _895;
    goto _jump1946;
    _jump1945:;
    int64_t _896 = 81;
    _894 = _896;
    _jump1946:;
    if (_891 >= 0)
    goto _jump1947;
    fail_assertion("negative array index");
    _jump1947:;
    if (_891 < _882.d0)
    goto _jump1948;
    fail_assertion("index too large");
    _jump1948:;
    if (_892 >= 0)
    goto _jump1949;
    fail_assertion("negative array index");
    _jump1949:;
    if (_892 < _882.d1)
    goto _jump1950;
    fail_assertion("index too large");
    _jump1950:;
    if (_894 >= 0)
    goto _jump1951;
    fail_assertion("negative array index");
    _jump1951:;
    if (_894 < _882.d2)
    goto _jump1952;
    fail_assertion("index too large");
    _jump1952:;
    int64_t _897 = 0;
    _897 *= _882.d0;
    _897 += _891;
    _897 *= _882.d1;
    _897 += _892;
    _897 *= _882.d2;
    _897 += _894;
    int64_t _898 = _882.data[_897];
    int64_t _899 = -_898;
    _871.d1 = _899;
    if (_899 > 0) 
    goto _jump1953;
    fail_assertion("non-positive loop bound");
    _jump1953:;
    // Computing total size of heap memory to allocate
    int64_t _900 = 1;
    _900 *= _873;
    _900 *= _899;
    _900 *= sizeof(rgba);
    _871.data = jpl_alloc(_900);
    int64_t _901 = 0; // j
    int64_t _902 = 0; // i
    _jump1954:; // Begin body of loop
    bool _903 = !_851;
    rgba _904;
    if (!_903)
    goto _jump1955;
    _a1_rgba _905;
    // Computing bound for k
    _905.d0 = _901;
    if (_901 > 0) 
    goto _jump1956;
    fail_assertion("non-positive loop bound");
    _jump1956:;
    // Computing total size of heap memory to allocate
    int64_t _906 = 1;
    _906 *= _901;
    _906 *= sizeof(rgba);
    _905.data = jpl_alloc(_906);
    int64_t _907 = 0; // k
    _jump1957:; // Begin body of loop
    int64_t _908 = 0;
    _908 *= _905.d0;
    _908 += _907;
    _905.data[_908] = _515;
    _907++;
    if (_907 < _901)
    goto _jump1957;
    // End body of loop
    int64_t _909;
    // Computing bound for k
    if (_902 > 0) 
    goto _jump1958;
    fail_assertion("non-positive loop bound");
    _jump1958:;
    // Computing bound for l
    if (_901 > 0) 
    goto _jump1959;
    fail_assertion("non-positive loop bound");
    _jump1959:;
    // Computing bound for m
    int64_t _910 = 630;
    if (_910 > 0) 
    goto _jump1960;
    fail_assertion("non-positive loop bound");
    _jump1960:;
    _909 = 0;
    int64_t _911 = 0; // m
    int64_t _912 = 0; // l
    int64_t _913 = 0; // k
    _jump1961:; // Begin body of loop
    _909 += _913;
    _911++;
    if (_911 < _910)
    goto _jump1961;
    _911 = 0;
    _912++;
    if (_912 < _901)
    goto _jump1961;
    _912 = 0;
    _913++;
    if (_913 < _902)
    goto _jump1961;
    // End body of loop
    if (_909 >= 0)
    goto _jump1962;
    fail_assertion("negative array index");
    _jump1962:;
    if (_909 < _905.d0)
    goto _jump1963;
    fail_assertion("index too large");
    _jump1963:;
    int64_t _914 = 0;
    _914 *= _905.d0;
    _914 += _909;
    rgba _915 = _905.data[_914];
    _904 = _915;
    goto _jump1964;
    _jump1955:;
    _a1_rgba _916;
    // Computing bound for k
    int64_t _917 = 866;
    _916.d0 = _917;
    if (_917 > 0) 
    goto _jump1965;
    fail_assertion("non-positive loop bound");
    _jump1965:;
    // Computing total size of heap memory to allocate
    int64_t _918 = 1;
    _918 *= _917;
    _918 *= sizeof(rgba);
    _916.data = jpl_alloc(_918);
    int64_t _919 = 0; // k
    _jump1966:; // Begin body of loop
    int64_t _920 = 0;
    _920 *= _916.d0;
    _920 += _919;
    _916.data[_920] = _515;
    _919++;
    if (_919 < _917)
    goto _jump1966;
    // End body of loop
    int64_t _921 = -_901;
    if (_921 >= 0)
    goto _jump1967;
    fail_assertion("negative array index");
    _jump1967:;
    if (_921 < _916.d0)
    goto _jump1968;
    fail_assertion("index too large");
    _jump1968:;
    int64_t _922 = 0;
    _922 *= _916.d0;
    _922 += _921;
    rgba _923 = _916.data[_922];
    _904 = _923;
    _jump1964:;
    int64_t _924 = 0;
    _924 *= _871.d0;
    _924 += _902;
    _924 *= _871.d1;
    _924 += _901;
    _871.data[_924] = _904;
    _901++;
    if (_901 < _899)
    goto _jump1954;
    _901 = 0;
    _902++;
    if (_902 < _873)
    goto _jump1954;
    // End body of loop
    _870 = _871;
    goto _jump1969;
    _jump1935:;
    _a2_rgba _925;
    // Computing bound for i
    _a3_int64_t _926;
    // Computing bound for i
    int64_t _927 = 40;
    _926.d0 = _927;
    if (_927 > 0) 
    goto _jump1970;
    fail_assertion("non-positive loop bound");
    _jump1970:;
    // Computing bound for j
    int64_t _928 = 815;
    _926.d1 = _928;
    if (_928 > 0) 
    goto _jump1971;
    fail_assertion("non-positive loop bound");
    _jump1971:;
    // Computing bound for k
    int64_t _929 = 33;
    _926.d2 = _929;
    if (_929 > 0) 
    goto _jump1972;
    fail_assertion("non-positive loop bound");
    _jump1972:;
    // Computing total size of heap memory to allocate
    int64_t _930 = 1;
    _930 *= _927;
    _930 *= _928;
    _930 *= _929;
    _930 *= sizeof(int64_t);
    _926.data = jpl_alloc(_930);
    int64_t _931 = 0; // k
    int64_t _932 = 0; // j
    int64_t _933 = 0; // i
    _jump1973:; // Begin body of loop
    int64_t _934 = 0;
    _934 *= _926.d0;
    _934 += _933;
    _934 *= _926.d1;
    _934 += _932;
    _934 *= _926.d2;
    _934 += _931;
    _926.data[_934] = _931;
    _931++;
    if (_931 < _929)
    goto _jump1973;
    _931 = 0;
    _932++;
    if (_932 < _928)
    goto _jump1973;
    _932 = 0;
    _933++;
    if (_933 < _927)
    goto _jump1973;
    // End body of loop
    int64_t _935 = 77;
    int64_t _936 = 481;
    int64_t _937 = 61;
    int64_t _938 = -_937;
    if (_935 >= 0)
    goto _jump1974;
    fail_assertion("negative array index");
    _jump1974:;
    if (_935 < _926.d0)
    goto _jump1975;
    fail_assertion("index too large");
    _jump1975:;
    if (_936 >= 0)
    goto _jump1976;
    fail_assertion("negative array index");
    _jump1976:;
    if (_936 < _926.d1)
    goto _jump1977;
    fail_assertion("index too large");
    _jump1977:;
    if (_938 >= 0)
    goto _jump1978;
    fail_assertion("negative array index");
    _jump1978:;
    if (_938 < _926.d2)
    goto _jump1979;
    fail_assertion("index too large");
    _jump1979:;
    int64_t _939 = 0;
    _939 *= _926.d0;
    _939 += _935;
    _939 *= _926.d1;
    _939 += _936;
    _939 *= _926.d2;
    _939 += _938;
    int64_t _940 = _926.data[_939];
    int64_t _941 = 999;
    int64_t _942 = -_941;
    int64_t _943 = _940 + _942;
    _925.d0 = _943;
    if (_943 > 0) 
    goto _jump1980;
    fail_assertion("non-positive loop bound");
    _jump1980:;
    // Computing bound for j
    int64_t _944 = 595;
    int64_t _945 = -_944;
    int64_t _946 = -_945;
    int64_t _947 = -_946;
    _925.d1 = _947;
    if (_947 > 0) 
    goto _jump1981;
    fail_assertion("non-positive loop bound");
    _jump1981:;
    // Computing total size of heap memory to allocate
    int64_t _948 = 1;
    _948 *= _943;
    _948 *= _947;
    _948 *= sizeof(rgba);
    _925.data = jpl_alloc(_948);
    int64_t _949 = 0; // j
    int64_t _950 = 0; // i
    _jump1982:; // Begin body of loop
    bool _951 = _852 != _852;
    rgba _952;
    if (!_951)
    goto _jump1983;
    bool _953 = false;
    rgba _954;
    if (!_953)
    goto _jump1984;
    _954 = _515;
    goto _jump1985;
    _jump1984:;
    _954 = _515;
    _jump1985:;
    _952 = _954;
    goto _jump1986;
    _jump1983:;
    _952 = _515;
    _jump1986:;
    int64_t _955 = 0;
    _955 *= _925.d0;
    _955 += _950;
    _955 *= _925.d1;
    _955 += _949;
    _925.data[_955] = _952;
    _949++;
    if (_949 < _947)
    goto _jump1982;
    _949 = 0;
    _950++;
    if (_950 < _943)
    goto _jump1982;
    // End body of loop
    _870 = _925;
    _jump1969:;
    _856 = _870;
    goto _jump1987;
    _jump1928:;
    _a1__a2_rgba _956;
    // Computing bound for i
    int64_t _957 = 411;
    int64_t _958 = 725;
    int64_t _959 = _957 * _958;
    int64_t _960 = -_959;
    int64_t _961 = -_960;
    _956.d0 = _961;
    if (_961 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    // Computing total size of heap memory to allocate
    int64_t _962 = 1;
    _962 *= _961;
    _962 *= sizeof(_a2_rgba);
    _956.data = jpl_alloc(_962);
    int64_t _963 = 0; // i
    _jump1989:; // Begin body of loop
    _a2_rgba _964;
    if (!_851)
    goto _jump1990;
    _a2_rgba _965;
    // Computing bound for j
    int64_t _966 = 248;
    int64_t _967 = _966 % _963;
    _965.d0 = _967;
    if (_967 > 0) 
    goto _jump1991;
    fail_assertion("non-positive loop bound");
    _jump1991:;
    // Computing bound for k
    int64_t _968 = 972;
    _965.d1 = _968;
    if (_968 > 0) 
    goto _jump1992;
    fail_assertion("non-positive loop bound");
    _jump1992:;
    // Computing total size of heap memory to allocate
    int64_t _969 = 1;
    _969 *= _967;
    _969 *= _968;
    _969 *= sizeof(rgba);
    _965.data = jpl_alloc(_969);
    int64_t _970 = 0; // k
    int64_t _971 = 0; // j
    _jump1993:; // Begin body of loop
    int64_t _972 = 0;
    _972 *= _965.d0;
    _972 += _971;
    _972 *= _965.d1;
    _972 += _970;
    _965.data[_972] = _515;
    _970++;
    if (_970 < _968)
    goto _jump1993;
    _970 = 0;
    _971++;
    if (_971 < _967)
    goto _jump1993;
    // End body of loop
    _964 = _965;
    goto _jump1994;
    _jump1990:;
    _a2_rgba _973;
    // Computing bound for j
    int64_t _974 = 910;
    _973.d0 = _974;
    if (_974 > 0) 
    goto _jump1995;
    fail_assertion("non-positive loop bound");
    _jump1995:;
    // Computing bound for k
    int64_t _975 = 205;
    _973.d1 = _975;
    if (_975 > 0) 
    goto _jump1996;
    fail_assertion("non-positive loop bound");
    _jump1996:;
    // Computing total size of heap memory to allocate
    int64_t _976 = 1;
    _976 *= _974;
    _976 *= _975;
    _976 *= sizeof(rgba);
    _973.data = jpl_alloc(_976);
    int64_t _977 = 0; // k
    int64_t _978 = 0; // j
    _jump1997:; // Begin body of loop
    int64_t _979 = 0;
    _979 *= _973.d0;
    _979 += _978;
    _979 *= _973.d1;
    _979 += _977;
    _973.data[_979] = _515;
    _977++;
    if (_977 < _975)
    goto _jump1997;
    _977 = 0;
    _978++;
    if (_978 < _974)
    goto _jump1997;
    // End body of loop
    _964 = _973;
    _jump1994:;
    int64_t _980 = 0;
    _980 *= _956.d0;
    _980 += _963;
    _956.data[_980] = _964;
    _963++;
    if (_963 < _961)
    goto _jump1989;
    // End body of loop
    int64_t _981 = 969;
    if (_981 >= 0)
    goto _jump1998;
    fail_assertion("negative array index");
    _jump1998:;
    if (_981 < _956.d0)
    goto _jump1999;
    fail_assertion("index too large");
    _jump1999:;
    int64_t _982 = 0;
    _982 *= _956.d0;
    _982 += _981;
    _a2_rgba _983 = _956.data[_982];
    _856 = _983;
    _jump1987:;
    _855 = _856;
    goto _jump2000;
    _jump1927:;
    bool _984 = true;
    _a2_rgba _985;
    if (!_984)
    goto _jump2001;
    bool _987 = true;
    bool _986 = _987;
    if (0 != _987)
    goto _jump2002;
    bool _988 = false;
    _986 = _988;
    _jump2002:;
    _a2_rgba _989;
    if (!_986)
    goto _jump2003;
    _a2_rgba _990;
    // Computing bound for i
    int64_t _991 = 809;
    _990.d0 = _991;
    if (_991 > 0) 
    goto _jump2004;
    fail_assertion("non-positive loop bound");
    _jump2004:;
    // Computing bound for j
    int64_t _992 = 578;
    _990.d1 = _992;
    if (_992 > 0) 
    goto _jump2005;
    fail_assertion("non-positive loop bound");
    _jump2005:;
    // Computing total size of heap memory to allocate
    int64_t _993 = 1;
    _993 *= _991;
    _993 *= _992;
    _993 *= sizeof(rgba);
    _990.data = jpl_alloc(_993);
    int64_t _994 = 0; // j
    int64_t _995 = 0; // i
    _jump2006:; // Begin body of loop
    int64_t _996 = 0;
    _996 *= _990.d0;
    _996 += _995;
    _996 *= _990.d1;
    _996 += _994;
    _990.data[_996] = _515;
    _994++;
    if (_994 < _992)
    goto _jump2006;
    _994 = 0;
    _995++;
    if (_995 < _991)
    goto _jump2006;
    // End body of loop
    _989 = _990;
    goto _jump2007;
    _jump2003:;
    _a2_rgba _997;
    // Computing bound for i
    int64_t _998 = 868;
    int64_t _999 = 951;
    int64_t _1000 = _998 % _999;
    _997.d0 = _1000;
    if (_1000 > 0) 
    goto _jump2008;
    fail_assertion("non-positive loop bound");
    _jump2008:;
    // Computing bound for j
    int64_t _1001 = 416;
    int64_t _1002 = 198;
    int64_t _1003 = _1001 / _1002;
    _997.d1 = _1003;
    if (_1003 > 0) 
    goto _jump2009;
    fail_assertion("non-positive loop bound");
    _jump2009:;
    // Computing total size of heap memory to allocate
    int64_t _1004 = 1;
    _1004 *= _1000;
    _1004 *= _1003;
    _1004 *= sizeof(rgba);
    _997.data = jpl_alloc(_1004);
    int64_t _1005 = 0; // j
    int64_t _1006 = 0; // i
    _jump2010:; // Begin body of loop
    int64_t _1007 = 0;
    _1007 *= _997.d0;
    _1007 += _1006;
    _1007 *= _997.d1;
    _1007 += _1005;
    _997.data[_1007] = _515;
    _1005++;
    if (_1005 < _1003)
    goto _jump2010;
    _1005 = 0;
    _1006++;
    if (_1006 < _1000)
    goto _jump2010;
    // End body of loop
    _989 = _997;
    _jump2007:;
    _a1__a2_rgba _1008;
    _1008.d0 = 1;
    _1008.data = jpl_alloc(sizeof(_a2_rgba) * 1);
    _1008.data[0] = _989;
    int64_t _1009;
    // Computing bound for i
    int64_t _1010 = 473;
    int64_t _1011 = 61;
    int64_t _1012 = 55;
    int64_t _1013 = _1011 - _1012;
    int64_t _1014 = 861;
    int64_t _1015 = _1013 * _1014;
    int64_t _1016 = _1010 - _1015;
    if (_1016 > 0) 
    goto _jump2011;
    fail_assertion("non-positive loop bound");
    _jump2011:;
    // Computing bound for j
    int64_t _1017 = 668;
    if (_1017 > 0) 
    goto _jump2012;
    fail_assertion("non-positive loop bound");
    _jump2012:;
    _1009 = 0;
    int64_t _1018 = 0; // j
    int64_t _1019 = 0; // i
    _jump2013:; // Begin body of loop
    int64_t _1020 = 993;
    _1009 += _1020;
    _1018++;
    if (_1018 < _1017)
    goto _jump2013;
    _1018 = 0;
    _1019++;
    if (_1019 < _1016)
    goto _jump2013;
    // End body of loop
    if (_1009 >= 0)
    goto _jump2014;
    fail_assertion("negative array index");
    _jump2014:;
    if (_1009 < _1008.d0)
    goto _jump2015;
    fail_assertion("index too large");
    _jump2015:;
    int64_t _1021 = 0;
    _1021 *= _1008.d0;
    _1021 += _1009;
    _a2_rgba _1022 = _1008.data[_1021];
    _985 = _1022;
    goto _jump2016;
    _jump2001:;
    int64_t _1023 = 810;
    int64_t _1024 = 430;
    int64_t _1025 = -_1024;
    bool _1026 = _1023 >= _1025;
    bool _1027;
    if (!_1026)
    goto _jump2017;
    double _1029 = 40.0;
    double _1030 = 60.0;
    bool _1031 = _1029 <= _1030;
    bool _1028 = _1031;
    if (0 != _1031)
    goto _jump2018;
    _1028 = _851;
    _jump2018:;
    _1027 = _1028;
    goto _jump2019;
    _jump2017:;
    int64_t _1032 = 394;
    int64_t _1033 = -_1032;
    if (_1033 >= 0)
    goto _jump2020;
    fail_assertion("negative array index");
    _jump2020:;
    if (_1033 < _0.d0)
    goto _jump2021;
    fail_assertion("index too large");
    _jump2021:;
    int64_t _1034 = 0;
    _1034 *= _0.d0;
    _1034 += _1033;
    bool _1035 = _0.data[_1034];
    _1027 = _1035;
    _jump2019:;
    bool _1036 = true;
    bool _1037 = _1027 != _1036;
    _a2_rgba _1038;
    if (!_1037)
    goto _jump2022;
    _a2_rgba _1039;
    // Computing bound for i
    bool _1040 = true;
    int64_t _1041;
    if (!_1040)
    goto _jump2023;
    int64_t _1042 = 493;
    _1041 = _1042;
    goto _jump2024;
    _jump2023:;
    int64_t _1043 = 380;
    _1041 = _1043;
    _jump2024:;
    int64_t _1044 = -_1041;
    int64_t _1045 = 768;
    int64_t _1046 = -_1045;
    int64_t _1047 = 24;
    int64_t _1048 = _1046 + _1047;
    int64_t _1049 = _1044 - _1048;
    _1039.d0 = _1049;
    if (_1049 > 0) 
    goto _jump2025;
    fail_assertion("non-positive loop bound");
    _jump2025:;
    // Computing bound for j
    int64_t _1050 = 648;
    int64_t _1051 = 577;
    int64_t _1052 = _1050 + _1051;
    int64_t _1053 = -_1052;
    _1039.d1 = _1053;
    if (_1053 > 0) 
    goto _jump2026;
    fail_assertion("non-positive loop bound");
    _jump2026:;
    // Computing total size of heap memory to allocate
    int64_t _1054 = 1;
    _1054 *= _1049;
    _1054 *= _1053;
    _1054 *= sizeof(rgba);
    _1039.data = jpl_alloc(_1054);
    int64_t _1055 = 0; // j
    int64_t _1056 = 0; // i
    _jump2027:; // Begin body of loop
    int64_t _1057 = 0;
    _1057 *= _1039.d0;
    _1057 += _1056;
    _1057 *= _1039.d1;
    _1057 += _1055;
    _1039.data[_1057] = _515;
    _1055++;
    if (_1055 < _1053)
    goto _jump2027;
    _1055 = 0;
    _1056++;
    if (_1056 < _1049)
    goto _jump2027;
    // End body of loop
    _1038 = _1039;
    goto _jump2028;
    _jump2022:;
    bool _1058 = true;
    _a2_rgba _1059;
    if (!_1058)
    goto _jump2029;
    _a2_rgba _1060;
    // Computing bound for i
    int64_t _1061;
    // Computing bound for i
    int64_t _1062 = 459;
    if (_1062 > 0) 
    goto _jump2030;
    fail_assertion("non-positive loop bound");
    _jump2030:;
    // Computing bound for j
    int64_t _1063 = 962;
    if (_1063 > 0) 
    goto _jump2031;
    fail_assertion("non-positive loop bound");
    _jump2031:;
    _1061 = 0;
    int64_t _1064 = 0; // j
    int64_t _1065 = 0; // i
    _jump2032:; // Begin body of loop
    int64_t _1066 = 194;
    _1061 += _1066;
    _1064++;
    if (_1064 < _1063)
    goto _jump2032;
    _1064 = 0;
    _1065++;
    if (_1065 < _1062)
    goto _jump2032;
    // End body of loop
    int64_t _1067 = -_1061;
    _1060.d0 = _1067;
    if (_1067 > 0) 
    goto _jump2033;
    fail_assertion("non-positive loop bound");
    _jump2033:;
    // Computing bound for j
    _a1_int64_t _1068;
    // Computing bound for i
    int64_t _1069 = 646;
    _1068.d0 = _1069;
    if (_1069 > 0) 
    goto _jump2034;
    fail_assertion("non-positive loop bound");
    _jump2034:;
    // Computing total size of heap memory to allocate
    int64_t _1070 = 1;
    _1070 *= _1069;
    _1070 *= sizeof(int64_t);
    _1068.data = jpl_alloc(_1070);
    int64_t _1071 = 0; // i
    _jump2035:; // Begin body of loop
    int64_t _1072 = 923;
    int64_t _1073 = 0;
    _1073 *= _1068.d0;
    _1073 += _1071;
    _1068.data[_1073] = _1072;
    _1071++;
    if (_1071 < _1069)
    goto _jump2035;
    // End body of loop
    int64_t _1074 = 750;
    int64_t _1075 = -_1074;
    if (_1075 >= 0)
    goto _jump2036;
    fail_assertion("negative array index");
    _jump2036:;
    if (_1075 < _1068.d0)
    goto _jump2037;
    fail_assertion("index too large");
    _jump2037:;
    int64_t _1076 = 0;
    _1076 *= _1068.d0;
    _1076 += _1075;
    int64_t _1077 = _1068.data[_1076];
    _1060.d1 = _1077;
    if (_1077 > 0) 
    goto _jump2038;
    fail_assertion("non-positive loop bound");
    _jump2038:;
    // Computing total size of heap memory to allocate
    int64_t _1078 = 1;
    _1078 *= _1067;
    _1078 *= _1077;
    _1078 *= sizeof(rgba);
    _1060.data = jpl_alloc(_1078);
    int64_t _1079 = 0; // j
    int64_t _1080 = 0; // i
    _jump2039:; // Begin body of loop
    _a1_rgba _1081;
    // Computing bound for k
    _1081.d0 = _1080;
    if (_1080 > 0) 
    goto _jump2040;
    fail_assertion("non-positive loop bound");
    _jump2040:;
    // Computing total size of heap memory to allocate
    int64_t _1082 = 1;
    _1082 *= _1080;
    _1082 *= sizeof(rgba);
    _1081.data = jpl_alloc(_1082);
    int64_t _1083 = 0; // k
    _jump2041:; // Begin body of loop
    int64_t _1084 = 0;
    _1084 *= _1081.d0;
    _1084 += _1083;
    _1081.data[_1084] = _515;
    _1083++;
    if (_1083 < _1080)
    goto _jump2041;
    // End body of loop
    int64_t _1085 = -_1079;
    if (_1085 >= 0)
    goto _jump2042;
    fail_assertion("negative array index");
    _jump2042:;
    if (_1085 < _1081.d0)
    goto _jump2043;
    fail_assertion("index too large");
    _jump2043:;
    int64_t _1086 = 0;
    _1086 *= _1081.d0;
    _1086 += _1085;
    rgba _1087 = _1081.data[_1086];
    int64_t _1088 = 0;
    _1088 *= _1060.d0;
    _1088 += _1080;
    _1088 *= _1060.d1;
    _1088 += _1079;
    _1060.data[_1088] = _1087;
    _1079++;
    if (_1079 < _1077)
    goto _jump2039;
    _1079 = 0;
    _1080++;
    if (_1080 < _1067)
    goto _jump2039;
    // End body of loop
    _1059 = _1060;
    goto _jump2044;
    _jump2029:;
    _a2_rgba _1089;
    // Computing bound for i
    int64_t _1090 = 639;
    int64_t _1091 = 235;
    int64_t _1092 = _1090 / _1091;
    _1089.d0 = _1092;
    if (_1092 > 0) 
    goto _jump2045;
    fail_assertion("non-positive loop bound");
    _jump2045:;
    // Computing bound for j
    int64_t _1093 = 113;
    int64_t _1094 = -_1093;
    _1089.d1 = _1094;
    if (_1094 > 0) 
    goto _jump2046;
    fail_assertion("non-positive loop bound");
    _jump2046:;
    // Computing total size of heap memory to allocate
    int64_t _1095 = 1;
    _1095 *= _1092;
    _1095 *= _1094;
    _1095 *= sizeof(rgba);
    _1089.data = jpl_alloc(_1095);
    int64_t _1096 = 0; // j
    int64_t _1097 = 0; // i
    _jump2047:; // Begin body of loop
    int64_t _1098 = 0;
    _1098 *= _1089.d0;
    _1098 += _1097;
    _1098 *= _1089.d1;
    _1098 += _1096;
    _1089.data[_1098] = _515;
    _1096++;
    if (_1096 < _1094)
    goto _jump2047;
    _1096 = 0;
    _1097++;
    if (_1097 < _1092)
    goto _jump2047;
    // End body of loop
    _1059 = _1089;
    _jump2044:;
    _1038 = _1059;
    _jump2028:;
    _985 = _1038;
    _jump2016:;
    _855 = _985;
    _jump2000:;
    write_image(_855, "i.png");
    _a3_double _1099;
    // Computing bound for i
    int64_t _1100;
    // Computing bound for i
    int64_t _1101 = 352;
    if (_1101 > 0) 
    goto _jump2048;
    fail_assertion("non-positive loop bound");
    _jump2048:;
    // Computing bound for j
    int64_t _1102;
    // Computing bound for i
    int64_t _1103 = 718;
    if (_1103 > 0) 
    goto _jump2049;
    fail_assertion("non-positive loop bound");
    _jump2049:;
    _1102 = 0;
    int64_t _1104 = 0; // i
    _jump2050:; // Begin body of loop
    int64_t _1105;
    // Computing bound for j
    int64_t _1106 = 680;
    if (_1106 > 0) 
    goto _jump2051;
    fail_assertion("non-positive loop bound");
    _jump2051:;
    // Computing bound for k
    int64_t _1107 = 947;
    if (_1107 > 0) 
    goto _jump2052;
    fail_assertion("non-positive loop bound");
    _jump2052:;
    _1105 = 0;
    int64_t _1108 = 0; // k
    int64_t _1109 = 0; // j
    _jump2053:; // Begin body of loop
    _1105 += _1108;
    _1108++;
    if (_1108 < _1107)
    goto _jump2053;
    _1108 = 0;
    _1109++;
    if (_1109 < _1106)
    goto _jump2053;
    // End body of loop
    _1102 += _1105;
    _1104++;
    if (_1104 < _1103)
    goto _jump2050;
    // End body of loop
    if (_1102 > 0) 
    goto _jump2054;
    fail_assertion("non-positive loop bound");
    _jump2054:;
    _1100 = 0;
    int64_t _1110 = 0; // j
    int64_t _1111 = 0; // i
    _jump2055:; // Begin body of loop
    int64_t _1112 = 125;
    _1100 += _1112;
    _1110++;
    if (_1110 < _1102)
    goto _jump2055;
    _1110 = 0;
    _1111++;
    if (_1111 < _1101)
    goto _jump2055;
    // End body of loop
    int64_t _1113 = -_1100;
    _1099.d0 = _1113;
    if (_1113 > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing bound for j
    bool _1114 = true;
    _a1_bool _1115;
    if (!_1114)
    goto _jump2057;
    _1115 = _0;
    goto _jump2058;
    _jump2057:;
    _1115 = _0;
    _jump2058:;
    int64_t _1116 = 384;
    if (_1116 >= 0)
    goto _jump2059;
    fail_assertion("negative array index");
    _jump2059:;
    if (_1116 < _1115.d0)
    goto _jump2060;
    fail_assertion("index too large");
    _jump2060:;
    int64_t _1117 = 0;
    _1117 *= _1115.d0;
    _1117 += _1116;
    bool _1118 = _1115.data[_1117];
    int64_t _1119;
    if (!_1118)
    goto _jump2061;
    int64_t _1120 = 15;
    _1119 = _1120;
    goto _jump2062;
    _jump2061:;
    int64_t _1121 = 252;
    int64_t _1122 = -_1121;
    _1119 = _1122;
    _jump2062:;
    int64_t _1123 = 626;
    int64_t _1124 = _1119 - _1123;
    int64_t _1125 = -_1124;
    _1099.d1 = _1125;
    if (_1125 > 0) 
    goto _jump2063;
    fail_assertion("non-positive loop bound");
    _jump2063:;
    // Computing bound for k
    _a3_rgba _1126;
    // Computing bound for i
    int64_t _1127 = 884;
    int64_t _1128 = -_1127;
    _1126.d0 = _1128;
    if (_1128 > 0) 
    goto _jump2064;
    fail_assertion("non-positive loop bound");
    _jump2064:;
    // Computing bound for j
    int64_t _1129 = 396;
    _1126.d1 = _1129;
    if (_1129 > 0) 
    goto _jump2065;
    fail_assertion("non-positive loop bound");
    _jump2065:;
    // Computing bound for k
    int64_t _1130 = 448;
    _1126.d2 = _1130;
    if (_1130 > 0) 
    goto _jump2066;
    fail_assertion("non-positive loop bound");
    _jump2066:;
    // Computing total size of heap memory to allocate
    int64_t _1131 = 1;
    _1131 *= _1128;
    _1131 *= _1129;
    _1131 *= _1130;
    _1131 *= sizeof(rgba);
    _1126.data = jpl_alloc(_1131);
    int64_t _1132 = 0; // k
    int64_t _1133 = 0; // j
    int64_t _1134 = 0; // i
    _jump2067:; // Begin body of loop
    int64_t _1135 = 0;
    _1135 *= _1126.d0;
    _1135 += _1134;
    _1135 *= _1126.d1;
    _1135 += _1133;
    _1135 *= _1126.d2;
    _1135 += _1132;
    _1126.data[_1135] = _515;
    _1132++;
    if (_1132 < _1130)
    goto _jump2067;
    _1132 = 0;
    _1133++;
    if (_1133 < _1129)
    goto _jump2067;
    _1133 = 0;
    _1134++;
    if (_1134 < _1128)
    goto _jump2067;
    // End body of loop
    bool _1136 = false;
    _a2_rgba _1137;
    if (!_1136)
    goto _jump2068;
    _a2_rgba _1138;
    // Computing bound for i
    int64_t _1139 = 571;
    _1138.d0 = _1139;
    if (_1139 > 0) 
    goto _jump2069;
    fail_assertion("non-positive loop bound");
    _jump2069:;
    // Computing bound for j
    int64_t _1140 = 137;
    _1138.d1 = _1140;
    if (_1140 > 0) 
    goto _jump2070;
    fail_assertion("non-positive loop bound");
    _jump2070:;
    // Computing total size of heap memory to allocate
    int64_t _1141 = 1;
    _1141 *= _1139;
    _1141 *= _1140;
    _1141 *= sizeof(rgba);
    _1138.data = jpl_alloc(_1141);
    int64_t _1142 = 0; // j
    int64_t _1143 = 0; // i
    _jump2071:; // Begin body of loop
    int64_t _1144 = 0;
    _1144 *= _1138.d0;
    _1144 += _1143;
    _1144 *= _1138.d1;
    _1144 += _1142;
    _1138.data[_1144] = _515;
    _1142++;
    if (_1142 < _1140)
    goto _jump2071;
    _1142 = 0;
    _1143++;
    if (_1143 < _1139)
    goto _jump2071;
    // End body of loop
    _1137 = _1138;
    goto _jump2072;
    _jump2068:;
    _a2_rgba _1145;
    // Computing bound for i
    int64_t _1146 = 830;
    _1145.d0 = _1146;
    if (_1146 > 0) 
    goto _jump2073;
    fail_assertion("non-positive loop bound");
    _jump2073:;
    // Computing bound for j
    int64_t _1147 = 416;
    _1145.d1 = _1147;
    if (_1147 > 0) 
    goto _jump2074;
    fail_assertion("non-positive loop bound");
    _jump2074:;
    // Computing total size of heap memory to allocate
    int64_t _1148 = 1;
    _1148 *= _1146;
    _1148 *= _1147;
    _1148 *= sizeof(rgba);
    _1145.data = jpl_alloc(_1148);
    int64_t _1149 = 0; // j
    int64_t _1150 = 0; // i
    _jump2075:; // Begin body of loop
    int64_t _1151 = 0;
    _1151 *= _1145.d0;
    _1151 += _1150;
    _1151 *= _1145.d1;
    _1151 += _1149;
    _1145.data[_1151] = _515;
    _1149++;
    if (_1149 < _1147)
    goto _jump2075;
    _1149 = 0;
    _1150++;
    if (_1150 < _1146)
    goto _jump2075;
    // End body of loop
    _1137 = _1145;
    _jump2072:;
    int64_t _1152 = b(_1126, _0, _1137);
    int64_t _1153 = -_1152;
    int64_t _1154 = -_1153;
    _1099.d2 = _1154;
    if (_1154 > 0) 
    goto _jump2076;
    fail_assertion("non-positive loop bound");
    _jump2076:;
    // Computing total size of heap memory to allocate
    int64_t _1155 = 1;
    _1155 *= _1113;
    _1155 *= _1125;
    _1155 *= _1154;
    _1155 *= sizeof(double);
    _1099.data = jpl_alloc(_1155);
    int64_t _1156 = 0; // k
    int64_t _1157 = 0; // j
    int64_t _1158 = 0; // i
    _jump2077:; // Begin body of loop
    int64_t _1159 = 0;
    _1159 *= _1099.d0;
    _1159 += _1158;
    _1159 *= _1099.d1;
    _1159 += _1157;
    _1159 *= _1099.d2;
    _1159 += _1156;
    _1099.data[_1159] = _852;
    _1156++;
    if (_1156 < _1154)
    goto _jump2077;
    _1156 = 0;
    _1157++;
    if (_1157 < _1125)
    goto _jump2077;
    _1157 = 0;
    _1158++;
    if (_1158 < _1113)
    goto _jump2077;
    // End body of loop
    int64_t _1160 = 367;
    _a2__a3_rgba _1161;
    // Computing bound for i
    int64_t _1162 = 789;
    int64_t _1163 = -_1162;
    _1161.d0 = _1163;
    if (_1163 > 0) 
    goto _jump2078;
    fail_assertion("non-positive loop bound");
    _jump2078:;
    // Computing bound for j
    int64_t _1164;
    if (!_851)
    goto _jump2079;
    int64_t _1165 = 863;
    _1164 = _1165;
    goto _jump2080;
    _jump2079:;
    int64_t _1166 = 945;
    int64_t _1167 = -_1166;
    _1164 = _1167;
    _jump2080:;
    int64_t _1168 = -_1164;
    _1161.d1 = _1168;
    if (_1168 > 0) 
    goto _jump2081;
    fail_assertion("non-positive loop bound");
    _jump2081:;
    // Computing total size of heap memory to allocate
    int64_t _1169 = 1;
    _1169 *= _1163;
    _1169 *= _1168;
    _1169 *= sizeof(_a3_rgba);
    _1161.data = jpl_alloc(_1169);
    int64_t _1170 = 0; // j
    int64_t _1171 = 0; // i
    _jump2082:; // Begin body of loop
    _a3_rgba _1172;
    // Computing bound for k
    int64_t _1173 = _1170 % _1170;
    _1172.d0 = _1173;
    if (_1173 > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing bound for l
    int64_t _1174;
    // Computing bound for k
    int64_t _1175 = 199;
    if (_1175 > 0) 
    goto _jump2084;
    fail_assertion("non-positive loop bound");
    _jump2084:;
    // Computing bound for l
    if (_1171 > 0) 
    goto _jump2085;
    fail_assertion("non-positive loop bound");
    _jump2085:;
    _1174 = 0;
    int64_t _1176 = 0; // l
    int64_t _1177 = 0; // k
    _jump2086:; // Begin body of loop
    int64_t _1178 = 752;
    _1174 += _1178;
    _1176++;
    if (_1176 < _1171)
    goto _jump2086;
    _1176 = 0;
    _1177++;
    if (_1177 < _1175)
    goto _jump2086;
    // End body of loop
    _1172.d1 = _1174;
    if (_1174 > 0) 
    goto _jump2087;
    fail_assertion("non-positive loop bound");
    _jump2087:;
    // Computing bound for m
    _1172.d2 = _1170;
    if (_1170 > 0) 
    goto _jump2088;
    fail_assertion("non-positive loop bound");
    _jump2088:;
    // Computing total size of heap memory to allocate
    int64_t _1179 = 1;
    _1179 *= _1173;
    _1179 *= _1174;
    _1179 *= _1170;
    _1179 *= sizeof(rgba);
    _1172.data = jpl_alloc(_1179);
    int64_t _1180 = 0; // m
    int64_t _1181 = 0; // l
    int64_t _1182 = 0; // k
    _jump2089:; // Begin body of loop
    double _1183 = 35.0;
    double _1184;
    // Computing bound for n
    if (_1170 > 0) 
    goto _jump2090;
    fail_assertion("non-positive loop bound");
    _jump2090:;
    _1184 = 0;
    int64_t _1185 = 0; // n
    _jump2091:; // Begin body of loop
    _1184 += _852;
    _1185++;
    if (_1185 < _1170)
    goto _jump2091;
    // End body of loop
    double _1186;
    // Computing bound for n
    if (_1180 > 0) 
    goto _jump2092;
    fail_assertion("non-positive loop bound");
    _jump2092:;
    // Computing bound for o
    if (_1171 > 0) 
    goto _jump2093;
    fail_assertion("non-positive loop bound");
    _jump2093:;
    _1186 = 0;
    int64_t _1187 = 0; // o
    int64_t _1188 = 0; // n
    _jump2094:; // Begin body of loop
    double _1189 = 90.0;
    _1186 += _1189;
    _1187++;
    if (_1187 < _1171)
    goto _jump2094;
    _1187 = 0;
    _1188++;
    if (_1188 < _1180)
    goto _jump2094;
    // End body of loop
    rgba _1190 = { _1183, _1184, _852, _1186 };
    int64_t _1191 = 0;
    _1191 *= _1172.d0;
    _1191 += _1182;
    _1191 *= _1172.d1;
    _1191 += _1181;
    _1191 *= _1172.d2;
    _1191 += _1180;
    _1172.data[_1191] = _1190;
    _1180++;
    if (_1180 < _1170)
    goto _jump2089;
    _1180 = 0;
    _1181++;
    if (_1181 < _1174)
    goto _jump2089;
    _1181 = 0;
    _1182++;
    if (_1182 < _1173)
    goto _jump2089;
    // End body of loop
    int64_t _1192 = 0;
    _1192 *= _1161.d0;
    _1192 += _1171;
    _1192 *= _1161.d1;
    _1192 += _1170;
    _1161.data[_1192] = _1172;
    _1170++;
    if (_1170 < _1168)
    goto _jump2082;
    _1170 = 0;
    _1171++;
    if (_1171 < _1163)
    goto _jump2082;
    // End body of loop
    _a3_int64_t _1193;
    // Computing bound for i
    int64_t _1194 = 79;
    int64_t _1195 = -_1194;
    int64_t _1196 = -_1195;
    _1193.d0 = _1196;
    if (_1196 > 0) 
    goto _jump2095;
    fail_assertion("non-positive loop bound");
    _jump2095:;
    // Computing bound for j
    int64_t _1197;
    // Computing bound for i
    int64_t _1198;
    // Computing bound for i
    int64_t _1199 = 626;
    if (_1199 > 0) 
    goto _jump2096;
    fail_assertion("non-positive loop bound");
    _jump2096:;
    // Computing bound for j
    int64_t _1200 = 427;
    if (_1200 > 0) 
    goto _jump2097;
    fail_assertion("non-positive loop bound");
    _jump2097:;
    // Computing bound for k
    int64_t _1201 = 380;
    if (_1201 > 0) 
    goto _jump2098;
    fail_assertion("non-positive loop bound");
    _jump2098:;
    _1198 = 0;
    int64_t _1202 = 0; // k
    int64_t _1203 = 0; // j
    int64_t _1204 = 0; // i
    _jump2099:; // Begin body of loop
    _1198 += _1203;
    _1202++;
    if (_1202 < _1201)
    goto _jump2099;
    _1202 = 0;
    _1203++;
    if (_1203 < _1200)
    goto _jump2099;
    _1203 = 0;
    _1204++;
    if (_1204 < _1199)
    goto _jump2099;
    // End body of loop
    if (_1198 > 0) 
    goto _jump2100;
    fail_assertion("non-positive loop bound");
    _jump2100:;
    _1197 = 0;
    int64_t _1205 = 0; // i
    _jump2101:; // Begin body of loop
    _1197 += _1205;
    _1205++;
    if (_1205 < _1198)
    goto _jump2101;
    // End body of loop
    _1193.d1 = _1197;
    if (_1197 > 0) 
    goto _jump2102;
    fail_assertion("non-positive loop bound");
    _jump2102:;
    // Computing bound for k
    bool _1206 = _851;
    if (0 == _851)
    goto _jump2103;
    _1206 = _851;
    _jump2103:;
    int64_t _1207;
    if (!_1206)
    goto _jump2104;
    int64_t _1208 = 577;
    _1207 = _1208;
    goto _jump2105;
    _jump2104:;
    int64_t _1209 = 626;
    int64_t _1210 = 349;
    int64_t _1211 = _1209 % _1210;
    _1207 = _1211;
    _jump2105:;
    _1193.d2 = _1207;
    if (_1207 > 0) 
    goto _jump2106;
    fail_assertion("non-positive loop bound");
    _jump2106:;
    // Computing total size of heap memory to allocate
    int64_t _1212 = 1;
    _1212 *= _1196;
    _1212 *= _1197;
    _1212 *= _1207;
    _1212 *= sizeof(int64_t);
    _1193.data = jpl_alloc(_1212);
    int64_t _1213 = 0; // k
    int64_t _1214 = 0; // j
    int64_t _1215 = 0; // i
    _jump2107:; // Begin body of loop
    int64_t _1216 = 170;
    int64_t _1217 = 0;
    _1217 *= _1193.d0;
    _1217 += _1215;
    _1217 *= _1193.d1;
    _1217 += _1214;
    _1217 *= _1193.d2;
    _1217 += _1213;
    _1193.data[_1217] = _1216;
    _1213++;
    if (_1213 < _1207)
    goto _jump2107;
    _1213 = 0;
    _1214++;
    if (_1214 < _1197)
    goto _jump2107;
    _1214 = 0;
    _1215++;
    if (_1215 < _1196)
    goto _jump2107;
    // End body of loop
    int64_t _1218;
    // Computing bound for i
    int64_t _1219 = 484;
    if (_1219 > 0) 
    goto _jump2108;
    fail_assertion("non-positive loop bound");
    _jump2108:;
    _1218 = 0;
    int64_t _1220 = 0; // i
    _jump2109:; // Begin body of loop
    int64_t _1221 = 669;
    _1218 += _1221;
    _1220++;
    if (_1220 < _1219)
    goto _jump2109;
    // End body of loop
    int64_t _1222 = -_1218;
    _a1_int64_t _1223;
    // Computing bound for i
    int64_t _1224 = 924;
    _1223.d0 = _1224;
    if (_1224 > 0) 
    goto _jump2110;
    fail_assertion("non-positive loop bound");
    _jump2110:;
    // Computing total size of heap memory to allocate
    int64_t _1225 = 1;
    _1225 *= _1224;
    _1225 *= sizeof(int64_t);
    _1223.data = jpl_alloc(_1225);
    int64_t _1226 = 0; // i
    _jump2111:; // Begin body of loop
    int64_t _1227 = -_1226;
    int64_t _1228 = 0;
    _1228 *= _1223.d0;
    _1228 += _1226;
    _1223.data[_1228] = _1227;
    _1226++;
    if (_1226 < _1224)
    goto _jump2111;
    // End body of loop
    int64_t _1229 = 15;
    int64_t _1230 = 766;
    int64_t _1231 = _1229 / _1230;
    int64_t _1232 = 848;
    int64_t _1233 = _1231 - _1232;
    if (_1233 >= 0)
    goto _jump2112;
    fail_assertion("negative array index");
    _jump2112:;
    if (_1233 < _1223.d0)
    goto _jump2113;
    fail_assertion("index too large");
    _jump2113:;
    int64_t _1234 = 0;
    _1234 *= _1223.d0;
    _1234 += _1233;
    int64_t _1235 = _1223.data[_1234];
    int64_t _1236 = 877;
    if (_1222 >= 0)
    goto _jump2114;
    fail_assertion("negative array index");
    _jump2114:;
    if (_1222 < _1193.d0)
    goto _jump2115;
    fail_assertion("index too large");
    _jump2115:;
    if (_1235 >= 0)
    goto _jump2116;
    fail_assertion("negative array index");
    _jump2116:;
    if (_1235 < _1193.d1)
    goto _jump2117;
    fail_assertion("index too large");
    _jump2117:;
    if (_1236 >= 0)
    goto _jump2118;
    fail_assertion("negative array index");
    _jump2118:;
    if (_1236 < _1193.d2)
    goto _jump2119;
    fail_assertion("index too large");
    _jump2119:;
    int64_t _1237 = 0;
    _1237 *= _1193.d0;
    _1237 += _1222;
    _1237 *= _1193.d1;
    _1237 += _1235;
    _1237 *= _1193.d2;
    _1237 += _1236;
    int64_t _1238 = _1193.data[_1237];
    double _1239 = 41.0;
    double _1240 = _1239 / _852;
    double _1241 = _515.r;
    bool _1242 = _1240 <= _1241;
    int64_t _1243;
    if (!_1242)
    goto _jump2120;
    int64_t _1244;
    // Computing bound for i
    int64_t _1245 = 133;
    int64_t _1246 = 328;
    int64_t _1247 = _1245 * _1246;
    if (_1247 > 0) 
    goto _jump2121;
    fail_assertion("non-positive loop bound");
    _jump2121:;
    // Computing bound for j
    int64_t _1248 = 49;
    int64_t _1249 = -_1248;
    if (_1249 > 0) 
    goto _jump2122;
    fail_assertion("non-positive loop bound");
    _jump2122:;
    // Computing bound for k
    int64_t _1250 = 640;
    if (_1250 > 0) 
    goto _jump2123;
    fail_assertion("non-positive loop bound");
    _jump2123:;
    _1244 = 0;
    int64_t _1251 = 0; // k
    int64_t _1252 = 0; // j
    int64_t _1253 = 0; // i
    _jump2124:; // Begin body of loop
    _1244 += _1251;
    _1251++;
    if (_1251 < _1250)
    goto _jump2124;
    _1251 = 0;
    _1252++;
    if (_1252 < _1249)
    goto _jump2124;
    _1252 = 0;
    _1253++;
    if (_1253 < _1247)
    goto _jump2124;
    // End body of loop
    _1243 = _1244;
    goto _jump2125;
    _jump2120:;
    int64_t _1254 = 983;
    _1243 = _1254;
    _jump2125:;
    int64_t _1255 = -_1243;
    if (_1238 >= 0)
    goto _jump2126;
    fail_assertion("negative array index");
    _jump2126:;
    if (_1238 < _1161.d0)
    goto _jump2127;
    fail_assertion("index too large");
    _jump2127:;
    if (_1255 >= 0)
    goto _jump2128;
    fail_assertion("negative array index");
    _jump2128:;
    if (_1255 < _1161.d1)
    goto _jump2129;
    fail_assertion("index too large");
    _jump2129:;
    int64_t _1256 = 0;
    _1256 *= _1161.d0;
    _1256 += _1238;
    _1256 *= _1161.d1;
    _1256 += _1255;
    _a3_rgba _1257 = _1161.data[_1256];
    _a2_rgba _1258;
    // Computing bound for i
    int64_t _1259;
    // Computing bound for i
    _a1_int64_t _1260;
    // Computing bound for i
    bool _1261 = false;
    int64_t _1262;
    if (!_1261)
    goto _jump2130;
    int64_t _1263 = 188;
    _1262 = _1263;
    goto _jump2131;
    _jump2130:;
    int64_t _1264 = 539;
    _1262 = _1264;
    _jump2131:;
    _1260.d0 = _1262;
    if (_1262 > 0) 
    goto _jump2132;
    fail_assertion("non-positive loop bound");
    _jump2132:;
    // Computing total size of heap memory to allocate
    int64_t _1265 = 1;
    _1265 *= _1262;
    _1265 *= sizeof(int64_t);
    _1260.data = jpl_alloc(_1265);
    int64_t _1266 = 0; // i
    _jump2133:; // Begin body of loop
    int64_t _1267 = 193;
    int64_t _1268 = 0;
    _1268 *= _1260.d0;
    _1268 += _1266;
    _1260.data[_1268] = _1267;
    _1266++;
    if (_1266 < _1262)
    goto _jump2133;
    // End body of loop
    int64_t _1269 = 764;
    int64_t _1270 = 4;
    int64_t _1271 = _1269 % _1270;
    int64_t _1272 = 752;
    int64_t _1273 = -_1272;
    int64_t _1274 = _1271 / _1273;
    if (_1274 >= 0)
    goto _jump2134;
    fail_assertion("negative array index");
    _jump2134:;
    if (_1274 < _1260.d0)
    goto _jump2135;
    fail_assertion("index too large");
    _jump2135:;
    int64_t _1275 = 0;
    _1275 *= _1260.d0;
    _1275 += _1274;
    int64_t _1276 = _1260.data[_1275];
    if (_1276 > 0) 
    goto _jump2136;
    fail_assertion("non-positive loop bound");
    _jump2136:;
    // Computing bound for j
    int64_t _1277;
    // Computing bound for i
    int64_t _1278 = 699;
    int64_t _1279 = -_1278;
    if (_1279 > 0) 
    goto _jump2137;
    fail_assertion("non-positive loop bound");
    _jump2137:;
    _1277 = 0;
    int64_t _1280 = 0; // i
    _jump2138:; // Begin body of loop
    int64_t _1281 = -_1280;
    _1277 += _1281;
    _1280++;
    if (_1280 < _1279)
    goto _jump2138;
    // End body of loop
    int64_t _1282 = 159;
    int64_t _1283 = _1277 / _1282;
    if (_1283 > 0) 
    goto _jump2139;
    fail_assertion("non-positive loop bound");
    _jump2139:;
    _1259 = 0;
    int64_t _1284 = 0; // j
    int64_t _1285 = 0; // i
    _jump2140:; // Begin body of loop
    int64_t _1286 = -_1284;
    int64_t _1287 = 802;
    int64_t _1288 = -_1287;
    bool _1289 = _1286 > _1288;
    int64_t _1290;
    if (!_1289)
    goto _jump2141;
    int64_t _1291;
    // Computing bound for k
    if (_1285 > 0) 
    goto _jump2142;
    fail_assertion("non-positive loop bound");
    _jump2142:;
    _1291 = 0;
    int64_t _1292 = 0; // k
    _jump2143:; // Begin body of loop
    int64_t _1293;
    // Computing bound for l
    int64_t _1294 = 414;
    if (_1294 > 0) 
    goto _jump2144;
    fail_assertion("non-positive loop bound");
    _jump2144:;
    _1293 = 0;
    int64_t _1295 = 0; // l
    _jump2145:; // Begin body of loop
    _1293 += _1295;
    _1295++;
    if (_1295 < _1294)
    goto _jump2145;
    // End body of loop
    _1291 += _1293;
    _1292++;
    if (_1292 < _1285)
    goto _jump2143;
    // End body of loop
    _1290 = _1291;
    goto _jump2146;
    _jump2141:;
    int64_t _1296 = _1284 * _1285;
    int64_t _1297 = -_1296;
    _1290 = _1297;
    _jump2146:;
    _1259 += _1290;
    _1284++;
    if (_1284 < _1283)
    goto _jump2140;
    _1284 = 0;
    _1285++;
    if (_1285 < _1276)
    goto _jump2140;
    // End body of loop
    _1258.d0 = _1259;
    if (_1259 > 0) 
    goto _jump2147;
    fail_assertion("non-positive loop bound");
    _jump2147:;
    // Computing bound for j
    int64_t _1298;
    // Computing bound for i
    int64_t _1299 = 399;
    int64_t _1300 = 396;
    int64_t _1301 = _1299 - _1300;
    int64_t _1302 = -_1301;
    if (_1302 > 0) 
    goto _jump2148;
    fail_assertion("non-positive loop bound");
    _jump2148:;
    // Computing bound for j
    int64_t _1303;
    // Computing bound for i
    int64_t _1304 = 533;
    if (_1304 > 0) 
    goto _jump2149;
    fail_assertion("non-positive loop bound");
    _jump2149:;
    _1303 = 0;
    int64_t _1305 = 0; // i
    _jump2150:; // Begin body of loop
    int64_t _1306 = 762;
    int64_t _1307 = -_1306;
    int64_t _1308 = _1305 / _1307;
    _1303 += _1308;
    _1305++;
    if (_1305 < _1304)
    goto _jump2150;
    // End body of loop
    if (_1303 > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    _1298 = 0;
    int64_t _1309 = 0; // j
    int64_t _1310 = 0; // i
    _jump2152:; // Begin body of loop
    _a3_int64_t _1311;
    // Computing bound for k
    _1311.d0 = _1309;
    if (_1309 > 0) 
    goto _jump2153;
    fail_assertion("non-positive loop bound");
    _jump2153:;
    // Computing bound for l
    _1311.d1 = _1309;
    if (_1309 > 0) 
    goto _jump2154;
    fail_assertion("non-positive loop bound");
    _jump2154:;
    // Computing bound for m
    _1311.d2 = _1309;
    if (_1309 > 0) 
    goto _jump2155;
    fail_assertion("non-positive loop bound");
    _jump2155:;
    // Computing total size of heap memory to allocate
    int64_t _1312 = 1;
    _1312 *= _1309;
    _1312 *= _1309;
    _1312 *= _1309;
    _1312 *= sizeof(int64_t);
    _1311.data = jpl_alloc(_1312);
    int64_t _1313 = 0; // m
    int64_t _1314 = 0; // l
    int64_t _1315 = 0; // k
    _jump2156:; // Begin body of loop
    int64_t _1316 = 0;
    _1316 *= _1311.d0;
    _1316 += _1315;
    _1316 *= _1311.d1;
    _1316 += _1314;
    _1316 *= _1311.d2;
    _1316 += _1313;
    _1311.data[_1316] = _1310;
    _1313++;
    if (_1313 < _1309)
    goto _jump2156;
    _1313 = 0;
    _1314++;
    if (_1314 < _1309)
    goto _jump2156;
    _1314 = 0;
    _1315++;
    if (_1315 < _1309)
    goto _jump2156;
    // End body of loop
    int64_t _1317;
    // Computing bound for k
    bool _1318 = true;
    int64_t _1319;
    if (!_1318)
    goto _jump2157;
    _1319 = _1309;
    goto _jump2158;
    _jump2157:;
    _1319 = _1310;
    _jump2158:;
    if (_1319 > 0) 
    goto _jump2159;
    fail_assertion("non-positive loop bound");
    _jump2159:;
    _1317 = 0;
    int64_t _1320 = 0; // k
    _jump2160:; // Begin body of loop
    _1317 += _1309;
    _1320++;
    if (_1320 < _1319)
    goto _jump2160;
    // End body of loop
    if (_1309 >= 0)
    goto _jump2161;
    fail_assertion("negative array index");
    _jump2161:;
    if (_1309 < _1311.d0)
    goto _jump2162;
    fail_assertion("index too large");
    _jump2162:;
    if (_1309 >= 0)
    goto _jump2163;
    fail_assertion("negative array index");
    _jump2163:;
    if (_1309 < _1311.d1)
    goto _jump2164;
    fail_assertion("index too large");
    _jump2164:;
    if (_1317 >= 0)
    goto _jump2165;
    fail_assertion("negative array index");
    _jump2165:;
    if (_1317 < _1311.d2)
    goto _jump2166;
    fail_assertion("index too large");
    _jump2166:;
    int64_t _1321 = 0;
    _1321 *= _1311.d0;
    _1321 += _1309;
    _1321 *= _1311.d1;
    _1321 += _1309;
    _1321 *= _1311.d2;
    _1321 += _1317;
    int64_t _1322 = _1311.data[_1321];
    _1298 += _1322;
    _1309++;
    if (_1309 < _1303)
    goto _jump2152;
    _1309 = 0;
    _1310++;
    if (_1310 < _1302)
    goto _jump2152;
    // End body of loop
    _1258.d1 = _1298;
    if (_1298 > 0) 
    goto _jump2167;
    fail_assertion("non-positive loop bound");
    _jump2167:;
    // Computing total size of heap memory to allocate
    int64_t _1323 = 1;
    _1323 *= _1259;
    _1323 *= _1298;
    _1323 *= sizeof(rgba);
    _1258.data = jpl_alloc(_1323);
    int64_t _1324 = 0; // j
    int64_t _1325 = 0; // i
    _jump2168:; // Begin body of loop
    double _1326 = -_852;
    double _1327 = fmod(_852, _1326);
    bool _1328 = _1327 != _852;
    rgba _1329;
    if (!_1328)
    goto _jump2169;
    double _1330 = 18.0;
    double _1331 = 13.0;
    bool _1332 = false;
    double _1333;
    if (!_1332)
    goto _jump2170;
    _1333 = _852;
    goto _jump2171;
    _jump2170:;
    _1333 = _852;
    _jump2171:;
    double _1334 = 73.0;
    bool _1335 = _852 != _1334;
    double _1336;
    if (!_1335)
    goto _jump2172;
    double _1337 = 71.0;
    _1336 = _1337;
    goto _jump2173;
    _jump2172:;
    double _1338 = 11.0;
    _1336 = _1338;
    _jump2173:;
    rgba _1339 = { _1330, _1331, _1333, _1336 };
    _1329 = _1339;
    goto _jump2174;
    _jump2169:;
    double _1340 = 59.0;
    double _1341 = -_1340;
    bool _1342 = true;
    double _1343;
    if (!_1342)
    goto _jump2175;
    double _1344 = 42.0;
    _1343 = _1344;
    goto _jump2176;
    _jump2175:;
    double _1345 = 32.0;
    _1343 = _1345;
    _jump2176:;
    bool _1346 = _1341 == _1343;
    rgba _1347;
    if (!_1346)
    goto _jump2177;
    _1347 = _515;
    goto _jump2178;
    _jump2177:;
    _1347 = _515;
    _jump2178:;
    _1329 = _1347;
    _jump2174:;
    int64_t _1348 = 0;
    _1348 *= _1258.d0;
    _1348 += _1325;
    _1348 *= _1258.d1;
    _1348 += _1324;
    _1258.data[_1348] = _1329;
    _1324++;
    if (_1324 < _1298)
    goto _jump2168;
    _1324 = 0;
    _1325++;
    if (_1325 < _1259)
    goto _jump2168;
    // End body of loop
    int64_t _1349 = b(_1257, _0, _1258);
    int64_t _1350;
    // Computing bound for i
    _a1_int64_t _1351;
    // Computing bound for i
    int64_t _1352 = 151;
    _1351.d0 = _1352;
    if (_1352 > 0) 
    goto _jump2179;
    fail_assertion("non-positive loop bound");
    _jump2179:;
    // Computing total size of heap memory to allocate
    int64_t _1353 = 1;
    _1353 *= _1352;
    _1353 *= sizeof(int64_t);
    _1351.data = jpl_alloc(_1353);
    int64_t _1354 = 0; // i
    _jump2180:; // Begin body of loop
    int64_t _1355 = 281;
    int64_t _1356 = 0;
    _1356 *= _1351.d0;
    _1356 += _1354;
    _1351.data[_1356] = _1355;
    _1354++;
    if (_1354 < _1352)
    goto _jump2180;
    // End body of loop
    int64_t _1357 = 444;
    if (_1357 >= 0)
    goto _jump2181;
    fail_assertion("negative array index");
    _jump2181:;
    if (_1357 < _1351.d0)
    goto _jump2182;
    fail_assertion("index too large");
    _jump2182:;
    int64_t _1358 = 0;
    _1358 *= _1351.d0;
    _1358 += _1357;
    int64_t _1359 = _1351.data[_1358];
    int64_t _1360 = 213;
    _a1_int64_t _1361;
    _1361.d0 = 2;
    _1361.data = jpl_alloc(sizeof(int64_t) * 2);
    _1361.data[0] = _1359;
    _1361.data[1] = _1360;
    int64_t _1362 = 872;
    if (_1362 >= 0)
    goto _jump2183;
    fail_assertion("negative array index");
    _jump2183:;
    if (_1362 < _1361.d0)
    goto _jump2184;
    fail_assertion("index too large");
    _jump2184:;
    int64_t _1363 = 0;
    _1363 *= _1361.d0;
    _1363 += _1362;
    int64_t _1364 = _1361.data[_1363];
    double _1365 = 54.0;
    bool _1366 = _852 != _1365;
    int64_t _1367;
    if (!_1366)
    goto _jump2185;
    int64_t _1368 = 848;
    int64_t _1369 = -_1368;
    _1367 = _1369;
    goto _jump2186;
    _jump2185:;
    double _1370 = 98.0;
    bool _1371 = _852 == _1370;
    int64_t _1372;
    if (!_1371)
    goto _jump2187;
    int64_t _1373 = 883;
    int64_t _1374 = 623;
    int64_t _1375 = _1373 + _1374;
    _1372 = _1375;
    goto _jump2188;
    _jump2187:;
    int64_t _1376 = 889;
    _1372 = _1376;
    _jump2188:;
    _1367 = _1372;
    _jump2186:;
    int64_t _1377 = -_1367;
    int64_t _1378 = _1364 / _1377;
    if (_1378 > 0) 
    goto _jump2189;
    fail_assertion("non-positive loop bound");
    _jump2189:;
    // Computing bound for j
    _a3_bool _1379;
    // Computing bound for i
    int64_t _1380 = 338;
    int64_t _1381 = 877;
    int64_t _1382 = _1380 - _1381;
    _1379.d0 = _1382;
    if (_1382 > 0) 
    goto _jump2190;
    fail_assertion("non-positive loop bound");
    _jump2190:;
    // Computing bound for j
    int64_t _1383;
    // Computing bound for i
    int64_t _1384 = 715;
    int64_t _1385 = 302;
    int64_t _1386 = _1384 % _1385;
    if (_1386 > 0) 
    goto _jump2191;
    fail_assertion("non-positive loop bound");
    _jump2191:;
    _1383 = 0;
    int64_t _1387 = 0; // i
    _jump2192:; // Begin body of loop
    int64_t _1388 = 199;
    _1383 += _1388;
    _1387++;
    if (_1387 < _1386)
    goto _jump2192;
    // End body of loop
    _1379.d1 = _1383;
    if (_1383 > 0) 
    goto _jump2193;
    fail_assertion("non-positive loop bound");
    _jump2193:;
    // Computing bound for k
    int64_t _1389;
    // Computing bound for i
    int64_t _1390 = 410;
    if (_1390 > 0) 
    goto _jump2194;
    fail_assertion("non-positive loop bound");
    _jump2194:;
    _1389 = 0;
    int64_t _1391 = 0; // i
    _jump2195:; // Begin body of loop
    int64_t _1392 = 644;
    int64_t _1393 = _1392 - _1391;
    _1389 += _1393;
    _1391++;
    if (_1391 < _1390)
    goto _jump2195;
    // End body of loop
    _1379.d2 = _1389;
    if (_1389 > 0) 
    goto _jump2196;
    fail_assertion("non-positive loop bound");
    _jump2196:;
    // Computing total size of heap memory to allocate
    int64_t _1394 = 1;
    _1394 *= _1382;
    _1394 *= _1383;
    _1394 *= _1389;
    _1394 *= sizeof(bool);
    _1379.data = jpl_alloc(_1394);
    int64_t _1395 = 0; // k
    int64_t _1396 = 0; // j
    int64_t _1397 = 0; // i
    _jump2197:; // Begin body of loop
    bool _1398 = false;
    bool _1399;
    if (!_1398)
    goto _jump2198;
    double _1400 = 32.0;
    bool _1401 = _852 != _1400;
    _1399 = _1401;
    goto _jump2199;
    _jump2198:;
    _1399 = _851;
    _jump2199:;
    int64_t _1402 = 0;
    _1402 *= _1379.d0;
    _1402 += _1397;
    _1402 *= _1379.d1;
    _1402 += _1396;
    _1402 *= _1379.d2;
    _1402 += _1395;
    _1379.data[_1402] = _1399;
    _1395++;
    if (_1395 < _1389)
    goto _jump2197;
    _1395 = 0;
    _1396++;
    if (_1396 < _1383)
    goto _jump2197;
    _1396 = 0;
    _1397++;
    if (_1397 < _1382)
    goto _jump2197;
    // End body of loop
    int64_t _1403 = 331;
    int64_t _1404 = -_1403;
    int64_t _1405 = 407;
    int64_t _1406 = 994;
    if (_1404 >= 0)
    goto _jump2200;
    fail_assertion("negative array index");
    _jump2200:;
    if (_1404 < _1379.d0)
    goto _jump2201;
    fail_assertion("index too large");
    _jump2201:;
    if (_1405 >= 0)
    goto _jump2202;
    fail_assertion("negative array index");
    _jump2202:;
    if (_1405 < _1379.d1)
    goto _jump2203;
    fail_assertion("index too large");
    _jump2203:;
    if (_1406 >= 0)
    goto _jump2204;
    fail_assertion("negative array index");
    _jump2204:;
    if (_1406 < _1379.d2)
    goto _jump2205;
    fail_assertion("index too large");
    _jump2205:;
    int64_t _1407 = 0;
    _1407 *= _1379.d0;
    _1407 += _1404;
    _1407 *= _1379.d1;
    _1407 += _1405;
    _1407 *= _1379.d2;
    _1407 += _1406;
    bool _1408 = _1379.data[_1407];
    int64_t _1409;
    if (!_1408)
    goto _jump2206;
    int64_t _1410 = 1000;
    _1409 = _1410;
    goto _jump2207;
    _jump2206:;
    int64_t _1411;
    // Computing bound for i
    int64_t _1412 = 599;
    if (_1412 > 0) 
    goto _jump2208;
    fail_assertion("non-positive loop bound");
    _jump2208:;
    // Computing bound for j
    int64_t _1413 = 492;
    if (_1413 > 0) 
    goto _jump2209;
    fail_assertion("non-positive loop bound");
    _jump2209:;
    // Computing bound for k
    int64_t _1414 = 271;
    if (_1414 > 0) 
    goto _jump2210;
    fail_assertion("non-positive loop bound");
    _jump2210:;
    _1411 = 0;
    int64_t _1415 = 0; // k
    int64_t _1416 = 0; // j
    int64_t _1417 = 0; // i
    _jump2211:; // Begin body of loop
    int64_t _1418 = 661;
    _1411 += _1418;
    _1415++;
    if (_1415 < _1414)
    goto _jump2211;
    _1415 = 0;
    _1416++;
    if (_1416 < _1413)
    goto _jump2211;
    _1416 = 0;
    _1417++;
    if (_1417 < _1412)
    goto _jump2211;
    // End body of loop
    _1409 = _1411;
    _jump2207:;
    if (_1409 > 0) 
    goto _jump2212;
    fail_assertion("non-positive loop bound");
    _jump2212:;
    _1350 = 0;
    int64_t _1419 = 0; // j
    int64_t _1420 = 0; // i
    _jump2213:; // Begin body of loop
    bool _1421;
    if (!_851)
    goto _jump2214;
    double _1422 = 71.0;
    bool _1423 = _1422 <= _852;
    _1421 = _1423;
    goto _jump2215;
    _jump2214:;
    double _1424 = _515.a;
    double _1425 = 64.0;
    double _1426 = -_1425;
    bool _1427 = _1424 < _1426;
    bool _1428 = !_1427;
    _1421 = _1428;
    _jump2215:;
    int64_t _1429;
    if (!_1421)
    goto _jump2216;
    _a3_int64_t _1430;
    // Computing bound for k
    int64_t _1431 = -_1420;
    _1430.d0 = _1431;
    if (_1431 > 0) 
    goto _jump2217;
    fail_assertion("non-positive loop bound");
    _jump2217:;
    // Computing bound for l
    int64_t _1432 = -_1419;
    int64_t _1433 = -_1432;
    _1430.d1 = _1433;
    if (_1433 > 0) 
    goto _jump2218;
    fail_assertion("non-positive loop bound");
    _jump2218:;
    // Computing bound for m
    _1430.d2 = _1419;
    if (_1419 > 0) 
    goto _jump2219;
    fail_assertion("non-positive loop bound");
    _jump2219:;
    // Computing total size of heap memory to allocate
    int64_t _1434 = 1;
    _1434 *= _1431;
    _1434 *= _1433;
    _1434 *= _1419;
    _1434 *= sizeof(int64_t);
    _1430.data = jpl_alloc(_1434);
    int64_t _1435 = 0; // m
    int64_t _1436 = 0; // l
    int64_t _1437 = 0; // k
    _jump2220:; // Begin body of loop
    int64_t _1438;
    // Computing bound for n
    int64_t _1439;
    // Computing bound for n
    if (_1420 > 0) 
    goto _jump2221;
    fail_assertion("non-positive loop bound");
    _jump2221:;
    // Computing bound for o
    if (_1435 > 0) 
    goto _jump2222;
    fail_assertion("non-positive loop bound");
    _jump2222:;
    _1439 = 0;
    int64_t _1440 = 0; // o
    int64_t _1441 = 0; // n
    _jump2223:; // Begin body of loop
    _1439 += _1440;
    _1440++;
    if (_1440 < _1435)
    goto _jump2223;
    _1440 = 0;
    _1441++;
    if (_1441 < _1420)
    goto _jump2223;
    // End body of loop
    if (_1439 > 0) 
    goto _jump2224;
    fail_assertion("non-positive loop bound");
    _jump2224:;
    // Computing bound for o
    if (_1435 > 0) 
    goto _jump2225;
    fail_assertion("non-positive loop bound");
    _jump2225:;
    // Computing bound for p
    bool _1442 = true;
    int64_t _1443;
    if (!_1442)
    goto _jump2226;
    _1443 = _1437;
    goto _jump2227;
    _jump2226:;
    int64_t _1444 = 614;
    _1443 = _1444;
    _jump2227:;
    if (_1443 > 0) 
    goto _jump2228;
    fail_assertion("non-positive loop bound");
    _jump2228:;
    _1438 = 0;
    int64_t _1445 = 0; // p
    int64_t _1446 = 0; // o
    int64_t _1447 = 0; // n
    _jump2229:; // Begin body of loop
    bool _1448 = true;
    int64_t _1449;
    if (!_1448)
    goto _jump2230;
    _1449 = _1435;
    goto _jump2231;
    _jump2230:;
    _1449 = _1435;
    _jump2231:;
    _1438 += _1449;
    _1445++;
    if (_1445 < _1443)
    goto _jump2229;
    _1445 = 0;
    _1446++;
    if (_1446 < _1435)
    goto _jump2229;
    _1446 = 0;
    _1447++;
    if (_1447 < _1439)
    goto _jump2229;
    // End body of loop
    int64_t _1450 = 0;
    _1450 *= _1430.d0;
    _1450 += _1437;
    _1450 *= _1430.d1;
    _1450 += _1436;
    _1450 *= _1430.d2;
    _1450 += _1435;
    _1430.data[_1450] = _1438;
    _1435++;
    if (_1435 < _1419)
    goto _jump2220;
    _1435 = 0;
    _1436++;
    if (_1436 < _1433)
    goto _jump2220;
    _1436 = 0;
    _1437++;
    if (_1437 < _1431)
    goto _jump2220;
    // End body of loop
    int64_t _1451 = 640;
    int64_t _1452 = -_1451;
    _a3_rgba _1453;
    // Computing bound for k
    int64_t _1454;
    // Computing bound for k
    if (_1420 > 0) 
    goto _jump2232;
    fail_assertion("non-positive loop bound");
    _jump2232:;
    // Computing bound for l
    if (_1420 > 0) 
    goto _jump2233;
    fail_assertion("non-positive loop bound");
    _jump2233:;
    // Computing bound for m
    if (_1420 > 0) 
    goto _jump2234;
    fail_assertion("non-positive loop bound");
    _jump2234:;
    _1454 = 0;
    int64_t _1455 = 0; // m
    int64_t _1456 = 0; // l
    int64_t _1457 = 0; // k
    _jump2235:; // Begin body of loop
    _1454 += _1457;
    _1455++;
    if (_1455 < _1420)
    goto _jump2235;
    _1455 = 0;
    _1456++;
    if (_1456 < _1420)
    goto _jump2235;
    _1456 = 0;
    _1457++;
    if (_1457 < _1420)
    goto _jump2235;
    // End body of loop
    _1453.d0 = _1454;
    if (_1454 > 0) 
    goto _jump2236;
    fail_assertion("non-positive loop bound");
    _jump2236:;
    // Computing bound for l
    _1453.d1 = _1419;
    if (_1419 > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    // Computing bound for m
    _1453.d2 = _1420;
    if (_1420 > 0) 
    goto _jump2238;
    fail_assertion("non-positive loop bound");
    _jump2238:;
    // Computing total size of heap memory to allocate
    int64_t _1458 = 1;
    _1458 *= _1454;
    _1458 *= _1419;
    _1458 *= _1420;
    _1458 *= sizeof(rgba);
    _1453.data = jpl_alloc(_1458);
    int64_t _1459 = 0; // m
    int64_t _1460 = 0; // l
    int64_t _1461 = 0; // k
    _jump2239:; // Begin body of loop
    rgba _1462;
    if (!_851)
    goto _jump2240;
    _1462 = _515;
    goto _jump2241;
    _jump2240:;
    _1462 = _515;
    _jump2241:;
    int64_t _1463 = 0;
    _1463 *= _1453.d0;
    _1463 += _1461;
    _1463 *= _1453.d1;
    _1463 += _1460;
    _1463 *= _1453.d2;
    _1463 += _1459;
    _1453.data[_1463] = _1462;
    _1459++;
    if (_1459 < _1420)
    goto _jump2239;
    _1459 = 0;
    _1460++;
    if (_1460 < _1419)
    goto _jump2239;
    _1460 = 0;
    _1461++;
    if (_1461 < _1454)
    goto _jump2239;
    // End body of loop
    _a1__a1_bool _1464;
    _1464.d0 = 1;
    _1464.data = jpl_alloc(sizeof(_a1_bool) * 1);
    _1464.data[0] = _0;
    int64_t _1465 = 750;
    int64_t _1466 = -_1465;
    if (_1466 >= 0)
    goto _jump2242;
    fail_assertion("negative array index");
    _jump2242:;
    if (_1466 < _1464.d0)
    goto _jump2243;
    fail_assertion("index too large");
    _jump2243:;
    int64_t _1467 = 0;
    _1467 *= _1464.d0;
    _1467 += _1466;
    _a1_bool _1468 = _1464.data[_1467];
    _a2_rgba _1469;
    // Computing bound for k
    int64_t _1470 = 117;
    _1469.d0 = _1470;
    if (_1470 > 0) 
    goto _jump2244;
    fail_assertion("non-positive loop bound");
    _jump2244:;
    // Computing bound for l
    int64_t _1471 = -_1419;
    _1469.d1 = _1471;
    if (_1471 > 0) 
    goto _jump2245;
    fail_assertion("non-positive loop bound");
    _jump2245:;
    // Computing total size of heap memory to allocate
    int64_t _1472 = 1;
    _1472 *= _1470;
    _1472 *= _1471;
    _1472 *= sizeof(rgba);
    _1469.data = jpl_alloc(_1472);
    int64_t _1473 = 0; // l
    int64_t _1474 = 0; // k
    _jump2246:; // Begin body of loop
    bool _1475 = false;
    rgba _1476;
    if (!_1475)
    goto _jump2247;
    _1476 = _515;
    goto _jump2248;
    _jump2247:;
    _1476 = _515;
    _jump2248:;
    int64_t _1477 = 0;
    _1477 *= _1469.d0;
    _1477 += _1474;
    _1477 *= _1469.d1;
    _1477 += _1473;
    _1469.data[_1477] = _1476;
    _1473++;
    if (_1473 < _1471)
    goto _jump2246;
    _1473 = 0;
    _1474++;
    if (_1474 < _1470)
    goto _jump2246;
    // End body of loop
    int64_t _1478 = b(_1453, _1468, _1469);
    if (_1452 >= 0)
    goto _jump2249;
    fail_assertion("negative array index");
    _jump2249:;
    if (_1452 < _1430.d0)
    goto _jump2250;
    fail_assertion("index too large");
    _jump2250:;
    if (_1478 >= 0)
    goto _jump2251;
    fail_assertion("negative array index");
    _jump2251:;
    if (_1478 < _1430.d1)
    goto _jump2252;
    fail_assertion("index too large");
    _jump2252:;
    if (_1420 >= 0)
    goto _jump2253;
    fail_assertion("negative array index");
    _jump2253:;
    if (_1420 < _1430.d2)
    goto _jump2254;
    fail_assertion("index too large");
    _jump2254:;
    int64_t _1479 = 0;
    _1479 *= _1430.d0;
    _1479 += _1452;
    _1479 *= _1430.d1;
    _1479 += _1478;
    _1479 *= _1430.d2;
    _1479 += _1420;
    int64_t _1480 = _1430.data[_1479];
    _1429 = _1480;
    goto _jump2255;
    _jump2216:;
    int64_t _1481 = 795;
    _a1_int64_t _1482;
    _1482.d0 = 1;
    _1482.data = jpl_alloc(sizeof(int64_t) * 1);
    _1482.data[0] = _1481;
    _a3_rgba _1483;
    // Computing bound for k
    int64_t _1484 = 751;
    _1483.d0 = _1484;
    if (_1484 > 0) 
    goto _jump2256;
    fail_assertion("non-positive loop bound");
    _jump2256:;
    // Computing bound for l
    _1483.d1 = _1420;
    if (_1420 > 0) 
    goto _jump2257;
    fail_assertion("non-positive loop bound");
    _jump2257:;
    // Computing bound for m
    int64_t _1485 = _1420 + _1419;
    _1483.d2 = _1485;
    if (_1485 > 0) 
    goto _jump2258;
    fail_assertion("non-positive loop bound");
    _jump2258:;
    // Computing total size of heap memory to allocate
    int64_t _1486 = 1;
    _1486 *= _1484;
    _1486 *= _1420;
    _1486 *= _1485;
    _1486 *= sizeof(rgba);
    _1483.data = jpl_alloc(_1486);
    int64_t _1487 = 0; // m
    int64_t _1488 = 0; // l
    int64_t _1489 = 0; // k
    _jump2259:; // Begin body of loop
    rgba _1490;
    if (!_851)
    goto _jump2260;
    _1490 = _515;
    goto _jump2261;
    _jump2260:;
    _1490 = _515;
    _jump2261:;
    int64_t _1491 = 0;
    _1491 *= _1483.d0;
    _1491 += _1489;
    _1491 *= _1483.d1;
    _1491 += _1488;
    _1491 *= _1483.d2;
    _1491 += _1487;
    _1483.data[_1491] = _1490;
    _1487++;
    if (_1487 < _1485)
    goto _jump2259;
    _1487 = 0;
    _1488++;
    if (_1488 < _1420)
    goto _jump2259;
    _1488 = 0;
    _1489++;
    if (_1489 < _1484)
    goto _jump2259;
    // End body of loop
    bool _1492 = true;
    bool _1493 = !_1492;
    _a1_bool _1494;
    if (!_1493)
    goto _jump2262;
    _1494 = _0;
    goto _jump2263;
    _jump2262:;
    _1494 = _0;
    _jump2263:;
    _a2_rgba _1495;
    // Computing bound for k
    int64_t _1496 = 477;
    _1495.d0 = _1496;
    if (_1496 > 0) 
    goto _jump2264;
    fail_assertion("non-positive loop bound");
    _jump2264:;
    // Computing bound for l
    _1495.d1 = _1419;
    if (_1419 > 0) 
    goto _jump2265;
    fail_assertion("non-positive loop bound");
    _jump2265:;
    // Computing total size of heap memory to allocate
    int64_t _1497 = 1;
    _1497 *= _1496;
    _1497 *= _1419;
    _1497 *= sizeof(rgba);
    _1495.data = jpl_alloc(_1497);
    int64_t _1498 = 0; // l
    int64_t _1499 = 0; // k
    _jump2266:; // Begin body of loop
    int64_t _1500 = 0;
    _1500 *= _1495.d0;
    _1500 += _1499;
    _1500 *= _1495.d1;
    _1500 += _1498;
    _1495.data[_1500] = _515;
    _1498++;
    if (_1498 < _1419)
    goto _jump2266;
    _1498 = 0;
    _1499++;
    if (_1499 < _1496)
    goto _jump2266;
    // End body of loop
    int64_t _1501 = b(_1483, _1494, _1495);
    if (_1501 >= 0)
    goto _jump2267;
    fail_assertion("negative array index");
    _jump2267:;
    if (_1501 < _1482.d0)
    goto _jump2268;
    fail_assertion("index too large");
    _jump2268:;
    int64_t _1502 = 0;
    _1502 *= _1482.d0;
    _1502 += _1501;
    int64_t _1503 = _1482.data[_1502];
    _1429 = _1503;
    _jump2255:;
    _1350 += _1429;
    _1419++;
    if (_1419 < _1409)
    goto _jump2213;
    _1419 = 0;
    _1420++;
    if (_1420 < _1378)
    goto _jump2213;
    // End body of loop
    if (_1160 >= 0)
    goto _jump2269;
    fail_assertion("negative array index");
    _jump2269:;
    if (_1160 < _1099.d0)
    goto _jump2270;
    fail_assertion("index too large");
    _jump2270:;
    if (_1349 >= 0)
    goto _jump2271;
    fail_assertion("negative array index");
    _jump2271:;
    if (_1349 < _1099.d1)
    goto _jump2272;
    fail_assertion("index too large");
    _jump2272:;
    if (_1350 >= 0)
    goto _jump2273;
    fail_assertion("negative array index");
    _jump2273:;
    if (_1350 < _1099.d2)
    goto _jump2274;
    fail_assertion("index too large");
    _jump2274:;
    int64_t _1504 = 0;
    _1504 *= _1099.d0;
    _1504 += _1160;
    _1504 *= _1099.d1;
    _1504 += _1349;
    _1504 *= _1099.d2;
    _1504 += _1350;
    double _1505 = _1099.data[_1504];
    show("(FloatType)", &_1505);
    double _1506;
    // Computing bound for j
    int64_t _1507 = 309;
    int64_t _1508 = 846;
    bool _1509 = _1507 >= _1508;
    bool _1510;
    if (!_1509)
    goto _jump2275;
    double _1511 = 68.0;
    double _1512 = 1.0;
    double _1513 = _1511 / _1512;
    double _1514 = 13.0;
    bool _1515 = _1513 != _1514;
    _1510 = _1515;
    goto _jump2276;
    _jump2275:;
    double _1516 = _515.a;
    bool _1517 = _1516 == _852;
    _1510 = _1517;
    _jump2276:;
    _a1_int64_t _1518;
    if (!_1510)
    goto _jump2277;
    int64_t _1519 = 721;
    int64_t _1520;
    // Computing bound for j
    int64_t _1521 = 677;
    if (_1521 > 0) 
    goto _jump2278;
    fail_assertion("non-positive loop bound");
    _jump2278:;
    _1520 = 0;
    int64_t _1522 = 0; // j
    _jump2279:; // Begin body of loop
    _1520 += _1522;
    _1522++;
    if (_1522 < _1521)
    goto _jump2279;
    // End body of loop
    int64_t _1523 = _1519 * _1520;
    int64_t _1524;
    // Computing bound for j
    int64_t _1525 = 139;
    int64_t _1526 = -_1525;
    if (_1526 > 0) 
    goto _jump2280;
    fail_assertion("non-positive loop bound");
    _jump2280:;
    _1524 = 0;
    int64_t _1527 = 0; // j
    _jump2281:; // Begin body of loop
    bool _1528 = true;
    int64_t _1529;
    if (!_1528)
    goto _jump2282;
    int64_t _1530 = 777;
    _1529 = _1530;
    goto _jump2283;
    _jump2282:;
    _1529 = _1527;
    _jump2283:;
    _1524 += _1529;
    _1527++;
    if (_1527 < _1526)
    goto _jump2281;
    // End body of loop
    _a1_int64_t _1531;
    _1531.d0 = 2;
    _1531.data = jpl_alloc(sizeof(int64_t) * 2);
    _1531.data[0] = _1523;
    _1531.data[1] = _1524;
    _1518 = _1531;
    goto _jump2284;
    _jump2277:;
    _a1_int64_t _1532;
    // Computing bound for j
    bool _1533 = true;
    bool _1534 = _851 != _1533;
    int64_t _1535;
    if (!_1534)
    goto _jump2285;
    int64_t _1536 = 126;
    _1535 = _1536;
    goto _jump2286;
    _jump2285:;
    int64_t _1537 = 826;
    _1535 = _1537;
    _jump2286:;
    _1532.d0 = _1535;
    if (_1535 > 0) 
    goto _jump2287;
    fail_assertion("non-positive loop bound");
    _jump2287:;
    // Computing total size of heap memory to allocate
    int64_t _1538 = 1;
    _1538 *= _1535;
    _1538 *= sizeof(int64_t);
    _1532.data = jpl_alloc(_1538);
    int64_t _1539 = 0; // j
    _jump2288:; // Begin body of loop
    int64_t _1540 = 297;
    int64_t _1541 = -_1540;
    int64_t _1542 = 0;
    _1542 *= _1532.d0;
    _1542 += _1539;
    _1532.data[_1542] = _1541;
    _1539++;
    if (_1539 < _1535)
    goto _jump2288;
    // End body of loop
    _1518 = _1532;
    _jump2284:;
    int64_t _1543 = 211;
    if (_1543 >= 0)
    goto _jump2289;
    fail_assertion("negative array index");
    _jump2289:;
    if (_1543 < _1518.d0)
    goto _jump2290;
    fail_assertion("index too large");
    _jump2290:;
    int64_t _1544 = 0;
    _1544 *= _1518.d0;
    _1544 += _1543;
    int64_t _1545 = _1518.data[_1544];
    int64_t _1546 = -_1545;
    if (_1546 > 0) 
    goto _jump2291;
    fail_assertion("non-positive loop bound");
    _jump2291:;
    _1506 = 0;
    int64_t _1547 = 0; // j
    _jump2292:; // Begin body of loop
    double _1548 = _515.g;
    _1506 += _1548;
    _1547++;
    if (_1547 < _1546)
    goto _jump2292;
    // End body of loop
    _a2_rgba _1549;
    // Computing bound for k
    double _1551;
    if (!_851)
    goto _jump2293;
    _1551 = _852;
    goto _jump2294;
    _jump2293:;
    double _1552 = 2.0;
    _1551 = _1552;
    _jump2294:;
    double _1553 = 82.0;
    bool _1554 = _1551 != _1553;
    bool _1555 = !_1554;
    bool _1550 = _1555;
    if (0 == _1555)
    goto _jump2295;
    bool _1556 = false;
    bool _1557 = !_1556;
    _1550 = _1557;
    _jump2295:;
    int64_t _1558;
    if (!_1550)
    goto _jump2296;
    int64_t _1559 = 218;
    int64_t _1560;
    // Computing bound for k
    int64_t _1561 = 306;
    if (_1561 > 0) 
    goto _jump2297;
    fail_assertion("non-positive loop bound");
    _jump2297:;
    // Computing bound for l
    int64_t _1562 = 817;
    int64_t _1563 = 109;
    int64_t _1564 = -_1563;
    int64_t _1565 = _1562 / _1564;
    if (_1565 > 0) 
    goto _jump2298;
    fail_assertion("non-positive loop bound");
    _jump2298:;
    _1560 = 0;
    int64_t _1566 = 0; // l
    int64_t _1567 = 0; // k
    _jump2299:; // Begin body of loop
    int64_t _1568;
    // Computing bound for m
    int64_t _1569 = 854;
    if (_1569 > 0) 
    goto _jump2300;
    fail_assertion("non-positive loop bound");
    _jump2300:;
    _1568 = 0;
    int64_t _1570 = 0; // m
    _jump2301:; // Begin body of loop
    int64_t _1571 = 737;
    _1568 += _1571;
    _1570++;
    if (_1570 < _1569)
    goto _jump2301;
    // End body of loop
    int64_t _1572 = -_1568;
    _1560 += _1572;
    _1566++;
    if (_1566 < _1565)
    goto _jump2299;
    _1566 = 0;
    _1567++;
    if (_1567 < _1561)
    goto _jump2299;
    // End body of loop
    int64_t _1573 = _1559 - _1560;
    _1558 = _1573;
    goto _jump2302;
    _jump2296:;
    _a2_int64_t _1574;
    // Computing bound for k
    int64_t _1575 = 938;
    _1574.d0 = _1575;
    if (_1575 > 0) 
    goto _jump2303;
    fail_assertion("non-positive loop bound");
    _jump2303:;
    // Computing bound for l
    int64_t _1576;
    // Computing bound for k
    int64_t _1577 = 483;
    if (_1577 > 0) 
    goto _jump2304;
    fail_assertion("non-positive loop bound");
    _jump2304:;
    _1576 = 0;
    int64_t _1578 = 0; // k
    _jump2305:; // Begin body of loop
    int64_t _1579 = 230;
    _1576 += _1579;
    _1578++;
    if (_1578 < _1577)
    goto _jump2305;
    // End body of loop
    _1574.d1 = _1576;
    if (_1576 > 0) 
    goto _jump2306;
    fail_assertion("non-positive loop bound");
    _jump2306:;
    // Computing total size of heap memory to allocate
    int64_t _1580 = 1;
    _1580 *= _1575;
    _1580 *= _1576;
    _1580 *= sizeof(int64_t);
    _1574.data = jpl_alloc(_1580);
    int64_t _1581 = 0; // l
    int64_t _1582 = 0; // k
    _jump2307:; // Begin body of loop
    int64_t _1583 = -_1581;
    int64_t _1584 = 0;
    _1584 *= _1574.d0;
    _1584 += _1582;
    _1584 *= _1574.d1;
    _1584 += _1581;
    _1574.data[_1584] = _1583;
    _1581++;
    if (_1581 < _1576)
    goto _jump2307;
    _1581 = 0;
    _1582++;
    if (_1582 < _1575)
    goto _jump2307;
    // End body of loop
    int64_t _1585 = 723;
    int64_t _1586 = 231;
    bool _1587 = _1585 <= _1586;
    int64_t _1588;
    if (!_1587)
    goto _jump2308;
    int64_t _1589 = 75;
    _1588 = _1589;
    goto _jump2309;
    _jump2308:;
    int64_t _1590 = 352;
    int64_t _1591 = -_1590;
    _1588 = _1591;
    _jump2309:;
    int64_t _1592;
    // Computing bound for k
    int64_t _1593 = 820;
    if (_1593 > 0) 
    goto _jump2310;
    fail_assertion("non-positive loop bound");
    _jump2310:;
    // Computing bound for l
    int64_t _1594 = 442;
    if (_1594 > 0) 
    goto _jump2311;
    fail_assertion("non-positive loop bound");
    _jump2311:;
    _1592 = 0;
    int64_t _1595 = 0; // l
    int64_t _1596 = 0; // k
    _jump2312:; // Begin body of loop
    int64_t _1597 = 111;
    int64_t _1598 = _1596 / _1597;
    _1592 += _1598;
    _1595++;
    if (_1595 < _1594)
    goto _jump2312;
    _1595 = 0;
    _1596++;
    if (_1596 < _1593)
    goto _jump2312;
    // End body of loop
    if (_1588 >= 0)
    goto _jump2313;
    fail_assertion("negative array index");
    _jump2313:;
    if (_1588 < _1574.d0)
    goto _jump2314;
    fail_assertion("index too large");
    _jump2314:;
    if (_1592 >= 0)
    goto _jump2315;
    fail_assertion("negative array index");
    _jump2315:;
    if (_1592 < _1574.d1)
    goto _jump2316;
    fail_assertion("index too large");
    _jump2316:;
    int64_t _1599 = 0;
    _1599 *= _1574.d0;
    _1599 += _1588;
    _1599 *= _1574.d1;
    _1599 += _1592;
    int64_t _1600 = _1574.data[_1599];
    _a2_int64_t _1601;
    // Computing bound for k
    int64_t _1602 = 660;
    int64_t _1603 = 828;
    int64_t _1604 = _1602 - _1603;
    _1601.d0 = _1604;
    if (_1604 > 0) 
    goto _jump2317;
    fail_assertion("non-positive loop bound");
    _jump2317:;
    // Computing bound for l
    int64_t _1605 = 878;
    _1601.d1 = _1605;
    if (_1605 > 0) 
    goto _jump2318;
    fail_assertion("non-positive loop bound");
    _jump2318:;
    // Computing total size of heap memory to allocate
    int64_t _1606 = 1;
    _1606 *= _1604;
    _1606 *= _1605;
    _1606 *= sizeof(int64_t);
    _1601.data = jpl_alloc(_1606);
    int64_t _1607 = 0; // l
    int64_t _1608 = 0; // k
    _jump2319:; // Begin body of loop
    int64_t _1609 = 0;
    _1609 *= _1601.d0;
    _1609 += _1608;
    _1609 *= _1601.d1;
    _1609 += _1607;
    _1601.data[_1609] = _1608;
    _1607++;
    if (_1607 < _1605)
    goto _jump2319;
    _1607 = 0;
    _1608++;
    if (_1608 < _1604)
    goto _jump2319;
    // End body of loop
    int64_t _1610;
    // Computing bound for k
    int64_t _1611 = 803;
    if (_1611 > 0) 
    goto _jump2320;
    fail_assertion("non-positive loop bound");
    _jump2320:;
    // Computing bound for l
    int64_t _1612 = 434;
    if (_1612 > 0) 
    goto _jump2321;
    fail_assertion("non-positive loop bound");
    _jump2321:;
    _1610 = 0;
    int64_t _1613 = 0; // l
    int64_t _1614 = 0; // k
    _jump2322:; // Begin body of loop
    _1610 += _1614;
    _1613++;
    if (_1613 < _1612)
    goto _jump2322;
    _1613 = 0;
    _1614++;
    if (_1614 < _1611)
    goto _jump2322;
    // End body of loop
    int64_t _1615 = 761;
    if (_1610 >= 0)
    goto _jump2323;
    fail_assertion("negative array index");
    _jump2323:;
    if (_1610 < _1601.d0)
    goto _jump2324;
    fail_assertion("index too large");
    _jump2324:;
    if (_1615 >= 0)
    goto _jump2325;
    fail_assertion("negative array index");
    _jump2325:;
    if (_1615 < _1601.d1)
    goto _jump2326;
    fail_assertion("index too large");
    _jump2326:;
    int64_t _1616 = 0;
    _1616 *= _1601.d0;
    _1616 += _1610;
    _1616 *= _1601.d1;
    _1616 += _1615;
    int64_t _1617 = _1601.data[_1616];
    int64_t _1618 = _1600 + _1617;
    _1558 = _1618;
    _jump2302:;
    int64_t _1619 = -_1558;
    _1549.d0 = _1619;
    if (_1619 > 0) 
    goto _jump2327;
    fail_assertion("non-positive loop bound");
    _jump2327:;
    // Computing bound for l
    _a3_rgba _1620;
    // Computing bound for k
    _a3_int64_t _1621;
    // Computing bound for k
    int64_t _1622;
    // Computing bound for k
    int64_t _1623 = 954;
    if (_1623 > 0) 
    goto _jump2328;
    fail_assertion("non-positive loop bound");
    _jump2328:;
    _1622 = 0;
    int64_t _1624 = 0; // k
    _jump2329:; // Begin body of loop
    int64_t _1625 = 42;
    _1622 += _1625;
    _1624++;
    if (_1624 < _1623)
    goto _jump2329;
    // End body of loop
    _1621.d0 = _1622;
    if (_1622 > 0) 
    goto _jump2330;
    fail_assertion("non-positive loop bound");
    _jump2330:;
    // Computing bound for l
    int64_t _1626 = 802;
    int64_t _1627 = -_1626;
    _1621.d1 = _1627;
    if (_1627 > 0) 
    goto _jump2331;
    fail_assertion("non-positive loop bound");
    _jump2331:;
    // Computing bound for m
    int64_t _1628 = 862;
    _1621.d2 = _1628;
    if (_1628 > 0) 
    goto _jump2332;
    fail_assertion("non-positive loop bound");
    _jump2332:;
    // Computing total size of heap memory to allocate
    int64_t _1629 = 1;
    _1629 *= _1622;
    _1629 *= _1627;
    _1629 *= _1628;
    _1629 *= sizeof(int64_t);
    _1621.data = jpl_alloc(_1629);
    int64_t _1630 = 0; // m
    int64_t _1631 = 0; // l
    int64_t _1632 = 0; // k
    _jump2333:; // Begin body of loop
    int64_t _1633 = 0;
    _1633 *= _1621.d0;
    _1633 += _1632;
    _1633 *= _1621.d1;
    _1633 += _1631;
    _1633 *= _1621.d2;
    _1633 += _1630;
    _1621.data[_1633] = _1631;
    _1630++;
    if (_1630 < _1628)
    goto _jump2333;
    _1630 = 0;
    _1631++;
    if (_1631 < _1627)
    goto _jump2333;
    _1631 = 0;
    _1632++;
    if (_1632 < _1622)
    goto _jump2333;
    // End body of loop
    int64_t _1634 = 268;
    int64_t _1635 = 133;
    int64_t _1636;
    // Computing bound for k
    int64_t _1637 = 825;
    if (_1637 > 0) 
    goto _jump2334;
    fail_assertion("non-positive loop bound");
    _jump2334:;
    _1636 = 0;
    int64_t _1638 = 0; // k
    _jump2335:; // Begin body of loop
    _1636 += _1638;
    _1638++;
    if (_1638 < _1637)
    goto _jump2335;
    // End body of loop
    int64_t _1639 = 319;
    int64_t _1640 = _1636 + _1639;
    if (_1634 >= 0)
    goto _jump2336;
    fail_assertion("negative array index");
    _jump2336:;
    if (_1634 < _1621.d0)
    goto _jump2337;
    fail_assertion("index too large");
    _jump2337:;
    if (_1635 >= 0)
    goto _jump2338;
    fail_assertion("negative array index");
    _jump2338:;
    if (_1635 < _1621.d1)
    goto _jump2339;
    fail_assertion("index too large");
    _jump2339:;
    if (_1640 >= 0)
    goto _jump2340;
    fail_assertion("negative array index");
    _jump2340:;
    if (_1640 < _1621.d2)
    goto _jump2341;
    fail_assertion("index too large");
    _jump2341:;
    int64_t _1641 = 0;
    _1641 *= _1621.d0;
    _1641 += _1634;
    _1641 *= _1621.d1;
    _1641 += _1635;
    _1641 *= _1621.d2;
    _1641 += _1640;
    int64_t _1642 = _1621.data[_1641];
    _1620.d0 = _1642;
    if (_1642 > 0) 
    goto _jump2342;
    fail_assertion("non-positive loop bound");
    _jump2342:;
    // Computing bound for l
    bool _1643 = true;
    int64_t _1644;
    if (!_1643)
    goto _jump2343;
    int64_t _1645 = 308;
    int64_t _1646 = -_1645;
    _1644 = _1646;
    goto _jump2344;
    _jump2343:;
    int64_t _1647 = 45;
    _1644 = _1647;
    _jump2344:;
    int64_t _1648 = -_1644;
    _1620.d1 = _1648;
    if (_1648 > 0) 
    goto _jump2345;
    fail_assertion("non-positive loop bound");
    _jump2345:;
    // Computing bound for m
    int64_t _1649 = 326;
    _1620.d2 = _1649;
    if (_1649 > 0) 
    goto _jump2346;
    fail_assertion("non-positive loop bound");
    _jump2346:;
    // Computing total size of heap memory to allocate
    int64_t _1650 = 1;
    _1650 *= _1642;
    _1650 *= _1648;
    _1650 *= _1649;
    _1650 *= sizeof(rgba);
    _1620.data = jpl_alloc(_1650);
    int64_t _1651 = 0; // m
    int64_t _1652 = 0; // l
    int64_t _1653 = 0; // k
    _jump2347:; // Begin body of loop
    int64_t _1654 = 0;
    _1654 *= _1620.d0;
    _1654 += _1653;
    _1654 *= _1620.d1;
    _1654 += _1652;
    _1654 *= _1620.d2;
    _1654 += _1651;
    _1620.data[_1654] = _515;
    _1651++;
    if (_1651 < _1649)
    goto _jump2347;
    _1651 = 0;
    _1652++;
    if (_1652 < _1648)
    goto _jump2347;
    _1652 = 0;
    _1653++;
    if (_1653 < _1642)
    goto _jump2347;
    // End body of loop
    _a1_bool _1655;
    if (!_851)
    goto _jump2348;
    _1655 = _0;
    goto _jump2349;
    _jump2348:;
    _1655 = _0;
    _jump2349:;
    _a2_rgba _1656;
    // Computing bound for k
    int64_t _1657 = 725;
    int64_t _1658 = 340;
    int64_t _1659 = -_1658;
    int64_t _1660 = _1657 / _1659;
    int64_t _1661 = -_1660;
    _1656.d0 = _1661;
    if (_1661 > 0) 
    goto _jump2350;
    fail_assertion("non-positive loop bound");
    _jump2350:;
    // Computing bound for l
    int64_t _1662 = 778;
    int64_t _1663 = -_1662;
    _1656.d1 = _1663;
    if (_1663 > 0) 
    goto _jump2351;
    fail_assertion("non-positive loop bound");
    _jump2351:;
    // Computing total size of heap memory to allocate
    int64_t _1664 = 1;
    _1664 *= _1661;
    _1664 *= _1663;
    _1664 *= sizeof(rgba);
    _1656.data = jpl_alloc(_1664);
    int64_t _1665 = 0; // l
    int64_t _1666 = 0; // k
    _jump2352:; // Begin body of loop
    i _1667 = { _515 };
    rgba _1668 = _1667.a;
    int64_t _1669 = 0;
    _1669 *= _1656.d0;
    _1669 += _1666;
    _1669 *= _1656.d1;
    _1669 += _1665;
    _1656.data[_1669] = _1668;
    _1665++;
    if (_1665 < _1663)
    goto _jump2352;
    _1665 = 0;
    _1666++;
    if (_1666 < _1661)
    goto _jump2352;
    // End body of loop
    int64_t _1670 = b(_1620, _1655, _1656);
    int64_t _1671 = -_1670;
    _1549.d1 = _1671;
    if (_1671 > 0) 
    goto _jump2353;
    fail_assertion("non-positive loop bound");
    _jump2353:;
    // Computing total size of heap memory to allocate
    int64_t _1672 = 1;
    _1672 *= _1619;
    _1672 *= _1671;
    _1672 *= sizeof(rgba);
    _1549.data = jpl_alloc(_1672);
    int64_t _1673 = 0; // l
    int64_t _1674 = 0; // k
    _jump2354:; // Begin body of loop
    int64_t _1675 = 0;
    _1675 *= _1549.d0;
    _1675 += _1674;
    _1675 *= _1549.d1;
    _1675 += _1673;
    _1549.data[_1675] = _515;
    _1673++;
    if (_1673 < _1671)
    goto _jump2354;
    _1673 = 0;
    _1674++;
    if (_1674 < _1619)
    goto _jump2354;
    // End body of loop
    double _1676;
    if (!_851)
    goto _jump2355;
    _a1_double _1677;
    // Computing bound for n
    _1677.d0 = _1549.d0;
    if (_1549.d0 > 0) 
    goto _jump2356;
    fail_assertion("non-positive loop bound");
    _jump2356:;
    // Computing total size of heap memory to allocate
    int64_t _1678 = 1;
    _1678 *= _1549.d0;
    _1678 *= sizeof(double);
    _1677.data = jpl_alloc(_1678);
    int64_t _1679 = 0; // n
    _jump2357:; // Begin body of loop
    double _1680 = 36.0;
    int64_t _1681 = 0;
    _1681 *= _1677.d0;
    _1681 += _1679;
    _1677.data[_1681] = _1680;
    _1679++;
    if (_1679 < _1549.d0)
    goto _jump2357;
    // End body of loop
    if (_1549.d0 >= 0)
    goto _jump2358;
    fail_assertion("negative array index");
    _jump2358:;
    if (_1549.d0 < _1677.d0)
    goto _jump2359;
    fail_assertion("index too large");
    _jump2359:;
    int64_t _1682 = 0;
    _1682 *= _1677.d0;
    _1682 += _1549.d0;
    double _1683 = _1677.data[_1682];
    _1676 = _1683;
    goto _jump2360;
    _jump2355:;
    double _1684 = 92.0;
    double _1685 = -_1684;
    double _1686 = 47.0;
    bool _1687 = _1685 < _1686;
    double _1688;
    if (!_1687)
    goto _jump2361;
    _a1_double _1689;
    // Computing bound for n
    _1689.d0 = _1549.d0;
    if (_1549.d0 > 0) 
    goto _jump2362;
    fail_assertion("non-positive loop bound");
    _jump2362:;
    // Computing total size of heap memory to allocate
    int64_t _1690 = 1;
    _1690 *= _1549.d0;
    _1690 *= sizeof(double);
    _1689.data = jpl_alloc(_1690);
    int64_t _1691 = 0; // n
    _jump2363:; // Begin body of loop
    double _1692 = _1506 - _852;
    int64_t _1693 = 0;
    _1693 *= _1689.d0;
    _1693 += _1691;
    _1689.data[_1693] = _1692;
    _1691++;
    if (_1691 < _1549.d0)
    goto _jump2363;
    // End body of loop
    int64_t _1694 = 331;
    if (_1694 >= 0)
    goto _jump2364;
    fail_assertion("negative array index");
    _jump2364:;
    if (_1694 < _1689.d0)
    goto _jump2365;
    fail_assertion("index too large");
    _jump2365:;
    int64_t _1695 = 0;
    _1695 *= _1689.d0;
    _1695 += _1694;
    double _1696 = _1689.data[_1695];
    double _1697;
    // Computing bound for n
    if (_1549.d1 > 0) 
    goto _jump2366;
    fail_assertion("non-positive loop bound");
    _jump2366:;
    // Computing bound for o
    int64_t _1698 = -_1549.d1;
    int64_t _1699 = 221;
    int64_t _1700 = _1698 / _1699;
    if (_1700 > 0) 
    goto _jump2367;
    fail_assertion("non-positive loop bound");
    _jump2367:;
    _1697 = 0;
    int64_t _1701 = 0; // o
    int64_t _1702 = 0; // n
    _jump2368:; // Begin body of loop
    double _1703 = 22.0;
    _1697 += _1703;
    _1701++;
    if (_1701 < _1700)
    goto _jump2368;
    _1701 = 0;
    _1702++;
    if (_1702 < _1549.d1)
    goto _jump2368;
    // End body of loop
    double _1704 = _1696 / _1697;
    double _1705 = 45.0;
    double _1706 = _1704 * _1705;
    _1688 = _1706;
    goto _jump2369;
    _jump2361:;
    _1688 = _852;
    _jump2369:;
    _1676 = _1688;
    _jump2360:;
    _a2_rgba _1707 = read_image("o.png");
    _a1__a3_bool _1708;
    // Computing bound for p
    int64_t _1709;
    // Computing bound for p
    _a3_rgba _1710;
    // Computing bound for p
    _a1_int64_t _1711;
    // Computing bound for p
    int64_t _1712 = 89;
    _1711.d0 = _1712;
    if (_1712 > 0) 
    goto _jump2370;
    fail_assertion("non-positive loop bound");
    _jump2370:;
    // Computing total size of heap memory to allocate
    int64_t _1713 = 1;
    _1713 *= _1712;
    _1713 *= sizeof(int64_t);
    _1711.data = jpl_alloc(_1713);
    int64_t _1714 = 0; // p
    _jump2371:; // Begin body of loop
    int64_t _1715 = 0;
    _1715 *= _1711.d0;
    _1715 += _1714;
    _1711.data[_1715] = _1714;
    _1714++;
    if (_1714 < _1712)
    goto _jump2371;
    // End body of loop
    if (_1549.d0 >= 0)
    goto _jump2372;
    fail_assertion("negative array index");
    _jump2372:;
    if (_1549.d0 < _1711.d0)
    goto _jump2373;
    fail_assertion("index too large");
    _jump2373:;
    int64_t _1716 = 0;
    _1716 *= _1711.d0;
    _1716 += _1549.d0;
    int64_t _1717 = _1711.data[_1716];
    _1710.d0 = _1717;
    if (_1717 > 0) 
    goto _jump2374;
    fail_assertion("non-positive loop bound");
    _jump2374:;
    // Computing bound for q
    int64_t _1718 = -_1549.d1;
    _1710.d1 = _1718;
    if (_1718 > 0) 
    goto _jump2375;
    fail_assertion("non-positive loop bound");
    _jump2375:;
    // Computing bound for r
    int64_t _1719 = 122;
    _1710.d2 = _1719;
    if (_1719 > 0) 
    goto _jump2376;
    fail_assertion("non-positive loop bound");
    _jump2376:;
    // Computing total size of heap memory to allocate
    int64_t _1720 = 1;
    _1720 *= _1717;
    _1720 *= _1718;
    _1720 *= _1719;
    _1720 *= sizeof(rgba);
    _1710.data = jpl_alloc(_1720);
    int64_t _1721 = 0; // r
    int64_t _1722 = 0; // q
    int64_t _1723 = 0; // p
    _jump2377:; // Begin body of loop
    int64_t _1724 = 0;
    _1724 *= _1710.d0;
    _1724 += _1723;
    _1724 *= _1710.d1;
    _1724 += _1722;
    _1724 *= _1710.d2;
    _1724 += _1721;
    _1710.data[_1724] = _515;
    _1721++;
    if (_1721 < _1719)
    goto _jump2377;
    _1721 = 0;
    _1722++;
    if (_1722 < _1718)
    goto _jump2377;
    _1722 = 0;
    _1723++;
    if (_1723 < _1717)
    goto _jump2377;
    // End body of loop
    _a1_bool _1725;
    // Computing bound for p
    bool _1726 = true;
    int64_t _1727;
    if (!_1726)
    goto _jump2378;
    int64_t _1728 = -_1549.d0;
    _1727 = _1728;
    goto _jump2379;
    _jump2378:;
    int64_t _1729 = 790;
    int64_t _1730 = _1549.d1 * _1729;
    _1727 = _1730;
    _jump2379:;
    _1725.d0 = _1727;
    if (_1727 > 0) 
    goto _jump2380;
    fail_assertion("non-positive loop bound");
    _jump2380:;
    // Computing total size of heap memory to allocate
    int64_t _1731 = 1;
    _1731 *= _1727;
    _1731 *= sizeof(bool);
    _1725.data = jpl_alloc(_1731);
    int64_t _1732 = 0; // p
    _jump2381:; // Begin body of loop
    double _1733 = 9.0;
    double _1734 = -_1733;
    bool _1735 = _1506 > _1734;
    int64_t _1736 = 0;
    _1736 *= _1725.d0;
    _1736 += _1732;
    _1725.data[_1736] = _1735;
    _1732++;
    if (_1732 < _1727)
    goto _jump2381;
    // End body of loop
    int64_t _1737 = b(_1710, _1725, _1549);
    if (_1737 > 0) 
    goto _jump2382;
    fail_assertion("non-positive loop bound");
    _jump2382:;
    // Computing bound for q
    int64_t _1738 = 127;
    if (_1738 > 0) 
    goto _jump2383;
    fail_assertion("non-positive loop bound");
    _jump2383:;
    _1709 = 0;
    int64_t _1739 = 0; // q
    int64_t _1740 = 0; // p
    _jump2384:; // Begin body of loop
    int64_t _1741;
    // Computing bound for r
    double _1742 = _515.r;
    double _1743 = 91.0;
    bool _1744 = _1742 < _1743;
    int64_t _1745;
    if (!_1744)
    goto _jump2385;
    int64_t _1746 = -_1549.d1;
    _1745 = _1746;
    goto _jump2386;
    _jump2385:;
    int64_t _1747 = _1740 * _1549.d0;
    _1745 = _1747;
    _jump2386:;
    if (_1745 > 0) 
    goto _jump2387;
    fail_assertion("non-positive loop bound");
    _jump2387:;
    // Computing bound for s
    if (_1549.d1 > 0) 
    goto _jump2388;
    fail_assertion("non-positive loop bound");
    _jump2388:;
    // Computing bound for t
    _a1_int64_t _1748;
    _1748.d0 = 1;
    _1748.data = jpl_alloc(sizeof(int64_t) * 1);
    _1748.data[0] = _1740;
    if (_1740 >= 0)
    goto _jump2389;
    fail_assertion("negative array index");
    _jump2389:;
    if (_1740 < _1748.d0)
    goto _jump2390;
    fail_assertion("index too large");
    _jump2390:;
    int64_t _1749 = 0;
    _1749 *= _1748.d0;
    _1749 += _1740;
    int64_t _1750 = _1748.data[_1749];
    if (_1750 > 0) 
    goto _jump2391;
    fail_assertion("non-positive loop bound");
    _jump2391:;
    _1741 = 0;
    int64_t _1751 = 0; // t
    int64_t _1752 = 0; // s
    int64_t _1753 = 0; // r
    _jump2392:; // Begin body of loop
    _1741 += _1751;
    _1751++;
    if (_1751 < _1750)
    goto _jump2392;
    _1751 = 0;
    _1752++;
    if (_1752 < _1549.d1)
    goto _jump2392;
    _1752 = 0;
    _1753++;
    if (_1753 < _1745)
    goto _jump2392;
    // End body of loop
    _1709 += _1741;
    _1739++;
    if (_1739 < _1738)
    goto _jump2384;
    _1739 = 0;
    _1740++;
    if (_1740 < _1737)
    goto _jump2384;
    // End body of loop
    int64_t _1754 = _1549.d1 % _1709;
    _1708.d0 = _1754;
    if (_1754 > 0) 
    goto _jump2393;
    fail_assertion("non-positive loop bound");
    _jump2393:;
    // Computing total size of heap memory to allocate
    int64_t _1755 = 1;
    _1755 *= _1754;
    _1755 *= sizeof(_a3_bool);
    _1708.data = jpl_alloc(_1755);
    int64_t _1756 = 0; // p
    _jump2394:; // Begin body of loop
    _a2_e _1757;
    // Computing bound for q
    int64_t _1758;
    // Computing bound for q
    if (_1756 > 0) 
    goto _jump2395;
    fail_assertion("non-positive loop bound");
    _jump2395:;
    // Computing bound for r
    if (_1756 > 0) 
    goto _jump2396;
    fail_assertion("non-positive loop bound");
    _jump2396:;
    _1758 = 0;
    int64_t _1759 = 0; // r
    int64_t _1760 = 0; // q
    _jump2397:; // Begin body of loop
    _1758 += _1760;
    _1759++;
    if (_1759 < _1756)
    goto _jump2397;
    _1759 = 0;
    _1760++;
    if (_1760 < _1756)
    goto _jump2397;
    // End body of loop
    int64_t _1761 = _1756 + _1758;
    _1757.d0 = _1761;
    if (_1761 > 0) 
    goto _jump2398;
    fail_assertion("non-positive loop bound");
    _jump2398:;
    // Computing bound for r
    int64_t _1762;
    // Computing bound for q
    int64_t _1763 = 347;
    if (_1763 > 0) 
    goto _jump2399;
    fail_assertion("non-positive loop bound");
    _jump2399:;
    // Computing bound for r
    int64_t _1764 = 526;
    int64_t _1765 = _1756 % _1764;
    if (_1765 > 0) 
    goto _jump2400;
    fail_assertion("non-positive loop bound");
    _jump2400:;
    _1762 = 0;
    int64_t _1766 = 0; // r
    int64_t _1767 = 0; // q
    _jump2401:; // Begin body of loop
    _1762 += _1549.d1;
    _1766++;
    if (_1766 < _1765)
    goto _jump2401;
    _1766 = 0;
    _1767++;
    if (_1767 < _1763)
    goto _jump2401;
    // End body of loop
    int64_t _1768 = 455;
    int64_t _1769 = 818;
    _a1_int64_t _1770;
    _1770.d0 = 2;
    _1770.data = jpl_alloc(sizeof(int64_t) * 2);
    _1770.data[0] = _1768;
    _1770.data[1] = _1769;
    if (_1756 >= 0)
    goto _jump2402;
    fail_assertion("negative array index");
    _jump2402:;
    if (_1756 < _1770.d0)
    goto _jump2403;
    fail_assertion("index too large");
    _jump2403:;
    int64_t _1771 = 0;
    _1771 *= _1770.d0;
    _1771 += _1756;
    int64_t _1772 = _1770.data[_1771];
    int64_t _1773 = _1762 % _1772;
    _1757.d1 = _1773;
    if (_1773 > 0) 
    goto _jump2404;
    fail_assertion("non-positive loop bound");
    _jump2404:;
    // Computing total size of heap memory to allocate
    int64_t _1774 = 1;
    _1774 *= _1761;
    _1774 *= _1773;
    _1774 *= sizeof(e);
    _1757.data = jpl_alloc(_1774);
    int64_t _1775 = 0; // r
    int64_t _1776 = 0; // q
    _jump2405:; // Begin body of loop
    _a3_bool _1777;
    // Computing bound for s
    _1777.d0 = _1775;
    if (_1775 > 0) 
    goto _jump2406;
    fail_assertion("non-positive loop bound");
    _jump2406:;
    // Computing bound for t
    int64_t _1778;
    // Computing bound for s
    if (_1549.d0 > 0) 
    goto _jump2407;
    fail_assertion("non-positive loop bound");
    _jump2407:;
    // Computing bound for t
    if (_1756 > 0) 
    goto _jump2408;
    fail_assertion("non-positive loop bound");
    _jump2408:;
    // Computing bound for u
    if (_1775 > 0) 
    goto _jump2409;
    fail_assertion("non-positive loop bound");
    _jump2409:;
    _1778 = 0;
    int64_t _1779 = 0; // u
    int64_t _1780 = 0; // t
    int64_t _1781 = 0; // s
    _jump2410:; // Begin body of loop
    _1778 += _1549.d1;
    _1779++;
    if (_1779 < _1775)
    goto _jump2410;
    _1779 = 0;
    _1780++;
    if (_1780 < _1756)
    goto _jump2410;
    _1780 = 0;
    _1781++;
    if (_1781 < _1549.d0)
    goto _jump2410;
    // End body of loop
    _1777.d1 = _1778;
    if (_1778 > 0) 
    goto _jump2411;
    fail_assertion("non-positive loop bound");
    _jump2411:;
    // Computing bound for u
    int64_t _1782 = -_1549.d0;
    _1777.d2 = _1782;
    if (_1782 > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    // Computing total size of heap memory to allocate
    int64_t _1783 = 1;
    _1783 *= _1775;
    _1783 *= _1778;
    _1783 *= _1782;
    _1783 *= sizeof(bool);
    _1777.data = jpl_alloc(_1783);
    int64_t _1784 = 0; // u
    int64_t _1785 = 0; // t
    int64_t _1786 = 0; // s
    _jump2413:; // Begin body of loop
    int64_t _1787 = 0;
    _1787 *= _1777.d0;
    _1787 += _1786;
    _1787 *= _1777.d1;
    _1787 += _1785;
    _1787 *= _1777.d2;
    _1787 += _1784;
    _1777.data[_1787] = _851;
    _1784++;
    if (_1784 < _1782)
    goto _jump2413;
    _1784 = 0;
    _1785++;
    if (_1785 < _1778)
    goto _jump2413;
    _1785 = 0;
    _1786++;
    if (_1786 < _1775)
    goto _jump2413;
    // End body of loop
    e _1788 = { _1777 };
    int64_t _1789 = 0;
    _1789 *= _1757.d0;
    _1789 += _1776;
    _1789 *= _1757.d1;
    _1789 += _1775;
    _1757.data[_1789] = _1788;
    _1775++;
    if (_1775 < _1773)
    goto _jump2405;
    _1775 = 0;
    _1776++;
    if (_1776 < _1761)
    goto _jump2405;
    // End body of loop
    int64_t _1790;
    // Computing bound for q
    int64_t _1791 = -_1756;
    if (_1791 > 0) 
    goto _jump2414;
    fail_assertion("non-positive loop bound");
    _jump2414:;
    _1790 = 0;
    int64_t _1792 = 0; // q
    _jump2415:; // Begin body of loop
    bool _1793 = _1549.d1 < _1756;
    bool _1794 = _1792 >= _1756;
    bool _1795 = _1793 != _1794;
    int64_t _1796;
    if (!_1795)
    goto _jump2416;
    int64_t _1797;
    if (!_851)
    goto _jump2417;
    int64_t _1798 = _1792 * _1549.d1;
    _1797 = _1798;
    goto _jump2418;
    _jump2417:;
    int64_t _1799;
    // Computing bound for r
    if (_1549.d1 > 0) 
    goto _jump2419;
    fail_assertion("non-positive loop bound");
    _jump2419:;
    // Computing bound for s
    if (_1756 > 0) 
    goto _jump2420;
    fail_assertion("non-positive loop bound");
    _jump2420:;
    _1799 = 0;
    int64_t _1800 = 0; // s
    int64_t _1801 = 0; // r
    _jump2421:; // Begin body of loop
    _1799 += _1800;
    _1800++;
    if (_1800 < _1756)
    goto _jump2421;
    _1800 = 0;
    _1801++;
    if (_1801 < _1549.d1)
    goto _jump2421;
    // End body of loop
    _1797 = _1799;
    _jump2418:;
    _1796 = _1797;
    goto _jump2422;
    _jump2416:;
    int64_t _1802 = 516;
    int64_t _1803 = -_1802;
    _1796 = _1803;
    _jump2422:;
    _1790 += _1796;
    _1792++;
    if (_1792 < _1791)
    goto _jump2415;
    // End body of loop
    if (_1549.d0 >= 0)
    goto _jump2423;
    fail_assertion("negative array index");
    _jump2423:;
    if (_1549.d0 < _1757.d0)
    goto _jump2424;
    fail_assertion("index too large");
    _jump2424:;
    if (_1790 >= 0)
    goto _jump2425;
    fail_assertion("negative array index");
    _jump2425:;
    if (_1790 < _1757.d1)
    goto _jump2426;
    fail_assertion("index too large");
    _jump2426:;
    int64_t _1804 = 0;
    _1804 *= _1757.d0;
    _1804 += _1549.d0;
    _1804 *= _1757.d1;
    _1804 += _1790;
    e _1805 = _1757.data[_1804];
    _a3_bool _1806 = _1805.a;
    int64_t _1807 = 0;
    _1807 *= _1708.d0;
    _1807 += _1756;
    _1708.data[_1807] = _1806;
    _1756++;
    if (_1756 < _1754)
    goto _jump2394;
    // End body of loop
    bool _1808 = _1506 >= _852;
    _a2_rgba _1809;
    if (!_1808)
    goto _jump2427;
    _1809 = _1707;
    goto _jump2428;
    _jump2427:;
    _1809 = _1549;
    _jump2428:;
    _a2_bool _1810;
    // Computing bound for t
    _1810.d0 = _1809.d1;
    if (_1809.d1 > 0) 
    goto _jump2429;
    fail_assertion("non-positive loop bound");
    _jump2429:;
    // Computing bound for u
    _1810.d1 = _1549.d0;
    if (_1549.d0 > 0) 
    goto _jump2430;
    fail_assertion("non-positive loop bound");
    _jump2430:;
    // Computing total size of heap memory to allocate
    int64_t _1811 = 1;
    _1811 *= _1809.d1;
    _1811 *= _1549.d0;
    _1811 *= sizeof(bool);
    _1810.data = jpl_alloc(_1811);
    int64_t _1812 = 0; // u
    int64_t _1813 = 0; // t
    _jump2431:; // Begin body of loop
    bool _1814 = true;
    int64_t _1815 = 0;
    _1815 *= _1810.d0;
    _1815 += _1813;
    _1815 *= _1810.d1;
    _1815 += _1812;
    _1810.data[_1815] = _1814;
    _1812++;
    if (_1812 < _1549.d0)
    goto _jump2431;
    _1812 = 0;
    _1813++;
    if (_1813 < _1809.d1)
    goto _jump2431;
    // End body of loop
}

