
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_int64_t *data;
} _a3__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2__a3_int64_t *data;
} _a2__a3__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a2_int64_t *data;
} _a3__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_rgba *data;
} _a3__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_void_t *data;
} _a3__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_int64_t *data;
} _a3__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  _a1_void_t *data;
} _a1__a1_void_t;

typedef struct {
  int64_t d0;
  _a1__a1_void_t *data;
} _a1__a1__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_void_t *data;
} _a2__a1_void_t;

typedef struct {
  int64_t d0;
  _a2__a1_void_t *data;
} _a1__a2__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_void_t *data;
} _a2__a2__a1_void_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  _a3__a3_int64_t *data;
} _a1__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

double f(bool g) {
    _a2_bool _0;
    // Computing bound for h
    int64_t _1 = -e;
    int64_t _2 = -_1;
    _0.d0 = _2;
    if (_2 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing bound for i
    _0.d1 = c;
    if (c > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _2;
    _3 *= c;
    _3 *= sizeof(bool);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // i
    int64_t _5 = 0; // h
    _jump265:; // Begin body of loop
    bool _6 = true;
    int64_t _7 = 0;
    _7 *= _0.d0;
    _7 += _5;
    _7 *= _0.d1;
    _7 += _4;
    _0.data[_7] = _6;
    _4++;
    if (_4 < c)
    goto _jump265;
    _4 = 0;
    _5++;
    if (_5 < _2)
    goto _jump265;
    // End body of loop
    double _8;
    // Computing bound for k
    if (_0.d0 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    _8 = 0;
    int64_t _9 = 0; // k
    _jump267:; // Begin body of loop
    bool _10 = false;
    double _11 = f(_10);
    _8 += _11;
    _9++;
    if (_9 < _0.d0)
    goto _jump267;
    // End body of loop
    double _12 = -_8;
    double _13 = _12 * a;
    double _14;
    // Computing bound for k
    int64_t _15;
    // Computing bound for k
    if (e > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    _15 = 0;
    int64_t _16 = 0; // k
    _jump269:; // Begin body of loop
    int64_t _17 = 921;
    int64_t _18 = -_17;
    _15 += _18;
    _16++;
    if (_16 < e)
    goto _jump269;
    // End body of loop
    if (_15 > 0) 
    goto _jump270;
    fail_assertion("non-positive loop bound");
    _jump270:;
    // Computing bound for l
    int64_t _19;
    // Computing bound for k
    if (d > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    _19 = 0;
    int64_t _20 = 0; // k
    _jump272:; // Begin body of loop
    int64_t _21;
    // Computing bound for l
    if (c > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    // Computing bound for m
    if (_0.d1 > 0) 
    goto _jump274;
    fail_assertion("non-positive loop bound");
    _jump274:;
    // Computing bound for n
    if (c > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    _21 = 0;
    int64_t _22 = 0; // n
    int64_t _23 = 0; // m
    int64_t _24 = 0; // l
    _jump276:; // Begin body of loop
    int64_t _25 = 98;
    _21 += _25;
    _22++;
    if (_22 < c)
    goto _jump276;
    _22 = 0;
    _23++;
    if (_23 < _0.d1)
    goto _jump276;
    _23 = 0;
    _24++;
    if (_24 < c)
    goto _jump276;
    // End body of loop
    int64_t _26 = -_21;
    _19 += _26;
    _20++;
    if (_20 < d)
    goto _jump272;
    // End body of loop
    if (_19 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    _14 = 0;
    int64_t _27 = 0; // l
    int64_t _28 = 0; // k
    _jump278:; // Begin body of loop
    bool _29 = false;
    bool _30;
    if (!_29)
    goto _jump279;
    bool _31 = true;
    bool _32 = !_31;
    _30 = _32;
    goto _jump280;
    _jump279:;
    _30 = g;
    _jump280:;
    double _33 = f(_30);
    _14 += _33;
    _27++;
    if (_27 < _19)
    goto _jump278;
    _27 = 0;
    _28++;
    if (_28 < _15)
    goto _jump278;
    // End body of loop
    bool _34 = _13 == _14;
    double _35;
    if (!_34)
    goto _jump281;
    double _36;
    if (!g)
    goto _jump282;
    _36 = a;
    goto _jump283;
    _jump282:;
    double _37 = 23.0;
    _36 = _37;
    _jump283:;
    double _38 = 96.0;
    double _39 = -_38;
    double _40 = 32.0;
    double _41 = -_40;
    double _42;
    // Computing bound for k
    if (_0.d0 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    _42 = 0;
    int64_t _43 = 0; // k
    _jump285:; // Begin body of loop
    _42 += a;
    _43++;
    if (_43 < _0.d0)
    goto _jump285;
    // End body of loop
    rgba _44 = { _36, _39, _41, _42 };
    double _45 = _44.a;
    double _46 = 72.0;
    bool _47 = true;
    double _48 = f(_47);
    double _49;
    // Computing bound for k
    if (_0.d1 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing bound for l
    if (_0.d1 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    _49 = 0;
    int64_t _50 = 0; // l
    int64_t _51 = 0; // k
    _jump288:; // Begin body of loop
    double _52 = 77.0;
    _49 += _52;
    _50++;
    if (_50 < _0.d1)
    goto _jump288;
    _50 = 0;
    _51++;
    if (_51 < _0.d1)
    goto _jump288;
    // End body of loop
    bool _53 = _48 >= _49;
    double _54;
    if (!_53)
    goto _jump289;
    double _55 = 98.0;
    _54 = _55;
    goto _jump290;
    _jump289:;
    double _56;
    if (!g)
    goto _jump291;
    _56 = a;
    goto _jump292;
    _jump291:;
    double _57 = 43.0;
    double _58 = -_57;
    _56 = _58;
    _jump292:;
    _54 = _56;
    _jump290:;
    rgba _59 = { _45, _46, _54, a };
    double _60 = _59.g;
    _35 = _60;
    goto _jump293;
    _jump281:;
    bool _62 = _0.d0 == _0.d0;
    bool _61 = _62;
    if (0 != _62)
    goto _jump294;
    _61 = g;
    _jump294:;
    bool _63 = !_61;
    double _64;
    if (!_63)
    goto _jump295;
    bool _65 = true;
    double _66;
    if (!_65)
    goto _jump296;
    double _67;
    // Computing bound for k
    if (_0.d0 > 0) 
    goto _jump297;
    fail_assertion("non-positive loop bound");
    _jump297:;
    // Computing bound for l
    int64_t _68 = -_0.d1;
    if (_68 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    _67 = 0;
    int64_t _69 = 0; // l
    int64_t _70 = 0; // k
    _jump299:; // Begin body of loop
    double _71;
    // Computing bound for m
    if (d > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing bound for n
    if (_69 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing bound for o
    if (_69 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    _71 = 0;
    int64_t _72 = 0; // o
    int64_t _73 = 0; // n
    int64_t _74 = 0; // m
    _jump303:; // Begin body of loop
    double _75 = 6.0;
    _71 += _75;
    _72++;
    if (_72 < _69)
    goto _jump303;
    _72 = 0;
    _73++;
    if (_73 < _69)
    goto _jump303;
    _73 = 0;
    _74++;
    if (_74 < d)
    goto _jump303;
    // End body of loop
    _67 += _71;
    _69++;
    if (_69 < _68)
    goto _jump299;
    _69 = 0;
    _70++;
    if (_70 < _0.d0)
    goto _jump299;
    // End body of loop
    double _76 = -_67;
    _66 = _76;
    goto _jump304;
    _jump296:;
    double _77 = 13.0;
    double _78 = 43.0;
    double _79 = fmod(_77, _78);
    _66 = _79;
    _jump304:;
    _64 = _66;
    goto _jump305;
    _jump295:;
    double _80 = 62.0;
    _64 = _80;
    _jump305:;
    _35 = _64;
    _jump293:;
    _a3_double _81;
    // Computing bound for k
    int64_t _82;
    // Computing bound for k
    if (_0.d0 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for l
    if (d > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    _82 = 0;
    int64_t _83 = 0; // l
    int64_t _84 = 0; // k
    _jump308:; // Begin body of loop
    int64_t _85 = -_83;
    _82 += _85;
    _83++;
    if (_83 < d)
    goto _jump308;
    _83 = 0;
    _84++;
    if (_84 < _0.d0)
    goto _jump308;
    // End body of loop
    int64_t _86 = _82 - e;
    _81.d0 = _86;
    if (_86 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for l
    _81.d1 = c;
    if (c > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    // Computing bound for m
    _81.d2 = d;
    if (d > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= _86;
    _87 *= c;
    _87 *= d;
    _87 *= sizeof(double);
    _81.data = jpl_alloc(_87);
    int64_t _88 = 0; // m
    int64_t _89 = 0; // l
    int64_t _90 = 0; // k
    _jump312:; // Begin body of loop
    double _91;
    // Computing bound for n
    if (_89 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for o
    if (_89 > 0) 
    goto _jump314;
    fail_assertion("non-positive loop bound");
    _jump314:;
    _91 = 0;
    int64_t _92 = 0; // o
    int64_t _93 = 0; // n
    _jump315:; // Begin body of loop
    _91 += a;
    _92++;
    if (_92 < _89)
    goto _jump315;
    _92 = 0;
    _93++;
    if (_93 < _89)
    goto _jump315;
    // End body of loop
    double _94 = 55.0;
    bool _95 = _91 == _94;
    _a3_double _96;
    if (!_95)
    goto _jump316;
    bool _98 = true;
    bool _97 = _98;
    if (0 == _98)
    goto _jump317;
    bool _99 = true;
    _97 = _99;
    _jump317:;
    _a3_double _100;
    if (!_97)
    goto _jump318;
    _a3_double _101;
    // Computing bound for n
    _101.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump319;
    fail_assertion("non-positive loop bound");
    _jump319:;
    // Computing bound for o
    _101.d1 = e;
    if (e > 0) 
    goto _jump320;
    fail_assertion("non-positive loop bound");
    _jump320:;
    // Computing bound for p
    _101.d2 = c;
    if (c > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= _0.d0;
    _102 *= e;
    _102 *= c;
    _102 *= sizeof(double);
    _101.data = jpl_alloc(_102);
    int64_t _103 = 0; // p
    int64_t _104 = 0; // o
    int64_t _105 = 0; // n
    _jump322:; // Begin body of loop
    double _106 = 86.0;
    int64_t _107 = 0;
    _107 *= _101.d0;
    _107 += _105;
    _107 *= _101.d1;
    _107 += _104;
    _107 *= _101.d2;
    _107 += _103;
    _101.data[_107] = _106;
    _103++;
    if (_103 < c)
    goto _jump322;
    _103 = 0;
    _104++;
    if (_104 < e)
    goto _jump322;
    _104 = 0;
    _105++;
    if (_105 < _0.d0)
    goto _jump322;
    // End body of loop
    _100 = _101;
    goto _jump323;
    _jump318:;
    _a3_double _108;
    // Computing bound for n
    _108.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing bound for o
    int64_t _109 = 457;
    _108.d1 = _109;
    if (_109 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    // Computing bound for p
    _108.d2 = c;
    if (c > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= _0.d1;
    _110 *= _109;
    _110 *= c;
    _110 *= sizeof(double);
    _108.data = jpl_alloc(_110);
    int64_t _111 = 0; // p
    int64_t _112 = 0; // o
    int64_t _113 = 0; // n
    _jump327:; // Begin body of loop
    double _114 = 90.0;
    int64_t _115 = 0;
    _115 *= _108.d0;
    _115 += _113;
    _115 *= _108.d1;
    _115 += _112;
    _115 *= _108.d2;
    _115 += _111;
    _108.data[_115] = _114;
    _111++;
    if (_111 < c)
    goto _jump327;
    _111 = 0;
    _112++;
    if (_112 < _109)
    goto _jump327;
    _112 = 0;
    _113++;
    if (_113 < _0.d1)
    goto _jump327;
    // End body of loop
    _100 = _108;
    _jump323:;
    _96 = _100;
    goto _jump328;
    _jump316:;
    _a3_double _116;
    // Computing bound for n
    _116.d0 = _90;
    if (_90 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for o
    _116.d1 = _90;
    if (_90 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for p
    _116.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= _90;
    _117 *= _90;
    _117 *= _0.d0;
    _117 *= sizeof(double);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // p
    int64_t _119 = 0; // o
    int64_t _120 = 0; // n
    _jump332:; // Begin body of loop
    double _121 = 58.0;
    int64_t _122 = 0;
    _122 *= _116.d0;
    _122 += _120;
    _122 *= _116.d1;
    _122 += _119;
    _122 *= _116.d2;
    _122 += _118;
    _116.data[_122] = _121;
    _118++;
    if (_118 < _0.d0)
    goto _jump332;
    _118 = 0;
    _119++;
    if (_119 < _90)
    goto _jump332;
    _119 = 0;
    _120++;
    if (_120 < _90)
    goto _jump332;
    // End body of loop
    _96 = _116;
    _jump328:;
    bool _123 = false;
    _a1_int64_t _124;
    if (!_123)
    goto _jump333;
    _a1_int64_t _125;
    // Computing bound for n
    _125.d0 = _88;
    if (_88 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    // Computing total size of heap memory to allocate
    int64_t _126 = 1;
    _126 *= _88;
    _126 *= sizeof(int64_t);
    _125.data = jpl_alloc(_126);
    int64_t _127 = 0; // n
    _jump335:; // Begin body of loop
    int64_t _128 = 0;
    _128 *= _125.d0;
    _128 += _127;
    _125.data[_128] = _88;
    _127++;
    if (_127 < _88)
    goto _jump335;
    // End body of loop
    _124 = _125;
    goto _jump336;
    _jump333:;
    _a1_int64_t _129;
    _129.d0 = 2;
    _129.data = jpl_alloc(sizeof(int64_t) * 2);
    _129.data[0] = _89;
    _129.data[1] = _89;
    _124 = _129;
    _jump336:;
    if (_0.d1 >= 0)
    goto _jump337;
    fail_assertion("negative array index");
    _jump337:;
    if (_0.d1 < _124.d0)
    goto _jump338;
    fail_assertion("index too large");
    _jump338:;
    int64_t _130 = 0;
    _130 *= _124.d0;
    _130 += _0.d1;
    int64_t _131 = _124.data[_130];
    int64_t _132;
    // Computing bound for n
    if (_90 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    // Computing bound for o
    if (d > 0) 
    goto _jump340;
    fail_assertion("non-positive loop bound");
    _jump340:;
    _132 = 0;
    int64_t _133 = 0; // o
    int64_t _134 = 0; // n
    _jump341:; // Begin body of loop
    _132 += _0.d1;
    _133++;
    if (_133 < d)
    goto _jump341;
    _133 = 0;
    _134++;
    if (_134 < _90)
    goto _jump341;
    // End body of loop
    int64_t _135 = _132 - _88;
    int64_t _136 = _135 * _0.d1;
    int64_t _137 = 728;
    int64_t _138 = _88 / _137;
    if (_131 >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (_131 < _96.d0)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    if (_136 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (_136 < _96.d1)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    if (_138 >= 0)
    goto _jump346;
    fail_assertion("negative array index");
    _jump346:;
    if (_138 < _96.d2)
    goto _jump347;
    fail_assertion("index too large");
    _jump347:;
    int64_t _139 = 0;
    _139 *= _96.d0;
    _139 += _131;
    _139 *= _96.d1;
    _139 += _136;
    _139 *= _96.d2;
    _139 += _138;
    double _140 = _96.data[_139];
    int64_t _141 = 0;
    _141 *= _81.d0;
    _141 += _90;
    _141 *= _81.d1;
    _141 += _89;
    _141 *= _81.d2;
    _141 += _88;
    _81.data[_141] = _140;
    _88++;
    if (_88 < d)
    goto _jump312;
    _88 = 0;
    _89++;
    if (_89 < c)
    goto _jump312;
    _89 = 0;
    _90++;
    if (_90 < _86)
    goto _jump312;
    // End body of loop
    int64_t _142 = 962;
    _a2_int64_t _143;
    // Computing bound for k
    int64_t _144 = 172;
    _143.d0 = _144;
    if (_144 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing bound for l
    _143.d1 = e;
    if (e > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= _144;
    _145 *= e;
    _145 *= sizeof(int64_t);
    _143.data = jpl_alloc(_145);
    int64_t _146 = 0; // l
    int64_t _147 = 0; // k
    _jump350:; // Begin body of loop
    int64_t _148 = -d;
    int64_t _149 = 0;
    _149 *= _143.d0;
    _149 += _147;
    _149 *= _143.d1;
    _149 += _146;
    _143.data[_149] = _148;
    _146++;
    if (_146 < e)
    goto _jump350;
    _146 = 0;
    _147++;
    if (_147 < _144)
    goto _jump350;
    // End body of loop
    if (_0.d0 >= 0)
    goto _jump351;
    fail_assertion("negative array index");
    _jump351:;
    if (_0.d0 < _143.d0)
    goto _jump352;
    fail_assertion("index too large");
    _jump352:;
    if (_0.d0 >= 0)
    goto _jump353;
    fail_assertion("negative array index");
    _jump353:;
    if (_0.d0 < _143.d1)
    goto _jump354;
    fail_assertion("index too large");
    _jump354:;
    int64_t _150 = 0;
    _150 *= _143.d0;
    _150 += _0.d0;
    _150 *= _143.d1;
    _150 += _0.d0;
    int64_t _151 = _143.data[_150];
    if (_142 >= 0)
    goto _jump355;
    fail_assertion("negative array index");
    _jump355:;
    if (_142 < _81.d0)
    goto _jump356;
    fail_assertion("index too large");
    _jump356:;
    if (d >= 0)
    goto _jump357;
    fail_assertion("negative array index");
    _jump357:;
    if (d < _81.d1)
    goto _jump358;
    fail_assertion("index too large");
    _jump358:;
    if (_151 >= 0)
    goto _jump359;
    fail_assertion("negative array index");
    _jump359:;
    if (_151 < _81.d2)
    goto _jump360;
    fail_assertion("index too large");
    _jump360:;
    int64_t _152 = 0;
    _152 *= _81.d0;
    _152 += _142;
    _152 *= _81.d1;
    _152 += d;
    _152 *= _81.d2;
    _152 += _151;
    double _153 = _81.data[_152];
    double _154 = fmod(_35, _153);
    _a2_double _155;
    // Computing bound for m
    int64_t _156 = -e;
    _155.d0 = _156;
    if (_156 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    // Computing bound for n
    bool _157 = false;
    int64_t _158;
    if (!_157)
    goto _jump362;
    _158 = d;
    goto _jump363;
    _jump362:;
    int64_t _159 = 694;
    _158 = _159;
    _jump363:;
    _155.d1 = _158;
    if (_158 > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= _156;
    _160 *= _158;
    _160 *= sizeof(double);
    _155.data = jpl_alloc(_160);
    int64_t _161 = 0; // n
    int64_t _162 = 0; // m
    _jump365:; // Begin body of loop
    int64_t _163 = 0;
    _163 *= _155.d0;
    _163 += _162;
    _163 *= _155.d1;
    _163 += _161;
    _155.data[_163] = a;
    _161++;
    if (_161 < _158)
    goto _jump365;
    _161 = 0;
    _162++;
    if (_162 < _156)
    goto _jump365;
    // End body of loop
    _a3_rgba _164;
    // Computing bound for p
    bool _166 = true;
    bool _167;
    if (!_166)
    goto _jump366;
    bool _168 = true;
    _167 = _168;
    goto _jump367;
    _jump366:;
    bool _169 = true;
    _167 = _169;
    _jump367:;
    double _170;
    if (!_167)
    goto _jump368;
    _170 = _154;
    goto _jump369;
    _jump368:;
    bool _171 = false;
    bool _172 = !_171;
    double _173;
    if (!_172)
    goto _jump370;
    _173 = a;
    goto _jump371;
    _jump370:;
    if (e >= 0)
    goto _jump372;
    fail_assertion("negative array index");
    _jump372:;
    if (e < _155.d0)
    goto _jump373;
    fail_assertion("index too large");
    _jump373:;
    if (c >= 0)
    goto _jump374;
    fail_assertion("negative array index");
    _jump374:;
    if (c < _155.d1)
    goto _jump375;
    fail_assertion("index too large");
    _jump375:;
    int64_t _174 = 0;
    _174 *= _155.d0;
    _174 += e;
    _174 *= _155.d1;
    _174 += c;
    double _175 = _155.data[_174];
    _173 = _175;
    _jump371:;
    _170 = _173;
    _jump369:;
    double _176 = 79.0;
    double _177 = 85.0;
    rgba _178 = { _176, _154, _177, a };
    double _179 = _178.a;
    double _180 = -_179;
    bool _181 = _170 == _180;
    bool _165 = _181;
    if (0 != _181)
    goto _jump376;
    bool _183 = true;
    bool _182 = _183;
    if (0 == _183)
    goto _jump377;
    bool _184 = false;
    _182 = _184;
    _jump377:;
    _a1_bool _185;
    if (!_182)
    goto _jump378;
    bool _186 = true;
    _a1_bool _187;
    _187.d0 = 2;
    _187.data = jpl_alloc(sizeof(bool) * 2);
    _187.data[0] = g;
    _187.data[1] = _186;
    _185 = _187;
    goto _jump379;
    _jump378:;
    _a1_bool _188;
    _188.d0 = 2;
    _188.data = jpl_alloc(sizeof(bool) * 2);
    _188.data[0] = g;
    _188.data[1] = g;
    _185 = _188;
    _jump379:;
    if (c >= 0)
    goto _jump380;
    fail_assertion("negative array index");
    _jump380:;
    if (c < _185.d0)
    goto _jump381;
    fail_assertion("index too large");
    _jump381:;
    int64_t _189 = 0;
    _189 *= _185.d0;
    _189 += c;
    bool _190 = _185.data[_189];
    bool _191;
    if (!_190)
    goto _jump382;
    bool _192 = true;
    _191 = _192;
    goto _jump383;
    _jump382:;
    bool _193 = g;
    if (0 != g)
    goto _jump384;
    _193 = g;
    _jump384:;
    _191 = _193;
    _jump383:;
    _165 = _191;
    _jump376:;
    int64_t _194;
    if (!_165)
    goto _jump385;
    _194 = _0.d1;
    goto _jump386;
    _jump385:;
    int64_t _195 = 1000;
    _194 = _195;
    _jump386:;
    _164.d0 = _194;
    if (_194 > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    // Computing bound for q
    _164.d1 = c;
    if (c > 0) 
    goto _jump388;
    fail_assertion("non-positive loop bound");
    _jump388:;
    // Computing bound for r
    _a1_int64_t _196;
    // Computing bound for p
    _196.d0 = e;
    if (e > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= e;
    _197 *= sizeof(int64_t);
    _196.data = jpl_alloc(_197);
    int64_t _198 = 0; // p
    _jump390:; // Begin body of loop
    int64_t _199 = 0;
    _199 *= _196.d0;
    _199 += _198;
    _196.data[_199] = d;
    _198++;
    if (_198 < e)
    goto _jump390;
    // End body of loop
    _a3_int64_t _200;
    // Computing bound for p
    int64_t _201;
    // Computing bound for p
    int64_t _202 = 70;
    if (_202 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for q
    int64_t _203 = 923;
    int64_t _204 = -_203;
    if (_204 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    _201 = 0;
    int64_t _205 = 0; // q
    int64_t _206 = 0; // p
    _jump393:; // Begin body of loop
    _201 += _205;
    _205++;
    if (_205 < _204)
    goto _jump393;
    _205 = 0;
    _206++;
    if (_206 < _202)
    goto _jump393;
    // End body of loop
    int64_t _207 = -_201;
    _200.d0 = _207;
    if (_207 > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing bound for q
    int64_t _208 = 625;
    _200.d1 = _208;
    if (_208 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    // Computing bound for r
    _200.d2 = d;
    if (d > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    // Computing total size of heap memory to allocate
    int64_t _209 = 1;
    _209 *= _207;
    _209 *= _208;
    _209 *= d;
    _209 *= sizeof(int64_t);
    _200.data = jpl_alloc(_209);
    int64_t _210 = 0; // r
    int64_t _211 = 0; // q
    int64_t _212 = 0; // p
    _jump397:; // Begin body of loop
    bool _213 = false;
    bool _214 = !_213;
    int64_t _215;
    if (!_214)
    goto _jump398;
    _215 = _155.d0;
    goto _jump399;
    _jump398:;
    int64_t _216;
    // Computing bound for s
    if (e > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for t
    if (_0.d1 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for u
    if (_210 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    _216 = 0;
    int64_t _217 = 0; // u
    int64_t _218 = 0; // t
    int64_t _219 = 0; // s
    _jump403:; // Begin body of loop
    _216 += _211;
    _217++;
    if (_217 < _210)
    goto _jump403;
    _217 = 0;
    _218++;
    if (_218 < _0.d1)
    goto _jump403;
    _218 = 0;
    _219++;
    if (_219 < e)
    goto _jump403;
    // End body of loop
    _215 = _216;
    _jump399:;
    int64_t _220 = 0;
    _220 *= _200.d0;
    _220 += _212;
    _220 *= _200.d1;
    _220 += _211;
    _220 *= _200.d2;
    _220 += _210;
    _200.data[_220] = _215;
    _210++;
    if (_210 < d)
    goto _jump397;
    _210 = 0;
    _211++;
    if (_211 < _208)
    goto _jump397;
    _211 = 0;
    _212++;
    if (_212 < _207)
    goto _jump397;
    // End body of loop
    int64_t _221 = -_155.d0;
    int64_t _222;
    // Computing bound for p
    if (_155.d0 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    // Computing bound for q
    int64_t _223 = 860;
    if (_223 > 0) 
    goto _jump405;
    fail_assertion("non-positive loop bound");
    _jump405:;
    _222 = 0;
    int64_t _224 = 0; // q
    int64_t _225 = 0; // p
    _jump406:; // Begin body of loop
    int64_t _226;
    // Computing bound for r
    if (_155.d0 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    // Computing bound for s
    if (_0.d0 > 0) 
    goto _jump408;
    fail_assertion("non-positive loop bound");
    _jump408:;
    // Computing bound for t
    int64_t _227 = -_0.d0;
    if (_227 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    _226 = 0;
    int64_t _228 = 0; // t
    int64_t _229 = 0; // s
    int64_t _230 = 0; // r
    _jump410:; // Begin body of loop
    int64_t _231 = 935;
    _226 += _231;
    _228++;
    if (_228 < _227)
    goto _jump410;
    _228 = 0;
    _229++;
    if (_229 < _0.d0)
    goto _jump410;
    _229 = 0;
    _230++;
    if (_230 < _155.d0)
    goto _jump410;
    // End body of loop
    _222 += _226;
    _224++;
    if (_224 < _223)
    goto _jump406;
    _224 = 0;
    _225++;
    if (_225 < _155.d0)
    goto _jump406;
    // End body of loop
    if (_221 >= 0)
    goto _jump411;
    fail_assertion("negative array index");
    _jump411:;
    if (_221 < _200.d0)
    goto _jump412;
    fail_assertion("index too large");
    _jump412:;
    if (_155.d1 >= 0)
    goto _jump413;
    fail_assertion("negative array index");
    _jump413:;
    if (_155.d1 < _200.d1)
    goto _jump414;
    fail_assertion("index too large");
    _jump414:;
    if (_222 >= 0)
    goto _jump415;
    fail_assertion("negative array index");
    _jump415:;
    if (_222 < _200.d2)
    goto _jump416;
    fail_assertion("index too large");
    _jump416:;
    int64_t _232 = 0;
    _232 *= _200.d0;
    _232 += _221;
    _232 *= _200.d1;
    _232 += _155.d1;
    _232 *= _200.d2;
    _232 += _222;
    int64_t _233 = _200.data[_232];
    if (_233 >= 0)
    goto _jump417;
    fail_assertion("negative array index");
    _jump417:;
    if (_233 < _196.d0)
    goto _jump418;
    fail_assertion("index too large");
    _jump418:;
    int64_t _234 = 0;
    _234 *= _196.d0;
    _234 += _233;
    int64_t _235 = _196.data[_234];
    _164.d2 = _235;
    if (_235 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    // Computing total size of heap memory to allocate
    int64_t _236 = 1;
    _236 *= _194;
    _236 *= c;
    _236 *= _235;
    _236 *= sizeof(rgba);
    _164.data = jpl_alloc(_236);
    int64_t _237 = 0; // r
    int64_t _238 = 0; // q
    int64_t _239 = 0; // p
    _jump420:; // Begin body of loop
    double _240 = _154 + a;
    bool _241 = false;
    _a2_bool _242;
    if (!_241)
    goto _jump421;
    _242 = _0;
    goto _jump422;
    _jump421:;
    _242 = _0;
    _jump422:;
    if (_239 >= 0)
    goto _jump423;
    fail_assertion("negative array index");
    _jump423:;
    if (_239 < _242.d0)
    goto _jump424;
    fail_assertion("index too large");
    _jump424:;
    if (e >= 0)
    goto _jump425;
    fail_assertion("negative array index");
    _jump425:;
    if (e < _242.d1)
    goto _jump426;
    fail_assertion("index too large");
    _jump426:;
    int64_t _243 = 0;
    _243 *= _242.d0;
    _243 += _239;
    _243 *= _242.d1;
    _243 += e;
    bool _244 = _242.data[_243];
    _a3_double _245;
    if (!_244)
    goto _jump427;
    _a3_double _246;
    // Computing bound for s
    _246.d0 = _237;
    if (_237 > 0) 
    goto _jump428;
    fail_assertion("non-positive loop bound");
    _jump428:;
    // Computing bound for t
    _246.d1 = e;
    if (e > 0) 
    goto _jump429;
    fail_assertion("non-positive loop bound");
    _jump429:;
    // Computing bound for u
    _246.d2 = _155.d0;
    if (_155.d0 > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= _237;
    _247 *= e;
    _247 *= _155.d0;
    _247 *= sizeof(double);
    _246.data = jpl_alloc(_247);
    int64_t _248 = 0; // u
    int64_t _249 = 0; // t
    int64_t _250 = 0; // s
    _jump431:; // Begin body of loop
    int64_t _251 = 0;
    _251 *= _246.d0;
    _251 += _250;
    _251 *= _246.d1;
    _251 += _249;
    _251 *= _246.d2;
    _251 += _248;
    _246.data[_251] = a;
    _248++;
    if (_248 < _155.d0)
    goto _jump431;
    _248 = 0;
    _249++;
    if (_249 < e)
    goto _jump431;
    _249 = 0;
    _250++;
    if (_250 < _237)
    goto _jump431;
    // End body of loop
    _245 = _246;
    goto _jump432;
    _jump427:;
    _a2__a3_double _252;
    // Computing bound for s
    _252.d0 = d;
    if (d > 0) 
    goto _jump433;
    fail_assertion("non-positive loop bound");
    _jump433:;
    // Computing bound for t
    int64_t _253 = 433;
    _252.d1 = _253;
    if (_253 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= d;
    _254 *= _253;
    _254 *= sizeof(_a3_double);
    _252.data = jpl_alloc(_254);
    int64_t _255 = 0; // t
    int64_t _256 = 0; // s
    _jump435:; // Begin body of loop
    _a3_double _257;
    // Computing bound for u
    _257.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing bound for v
    _257.d1 = _239;
    if (_239 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing bound for w
    _257.d2 = _255;
    if (_255 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    // Computing total size of heap memory to allocate
    int64_t _258 = 1;
    _258 *= _0.d1;
    _258 *= _239;
    _258 *= _255;
    _258 *= sizeof(double);
    _257.data = jpl_alloc(_258);
    int64_t _259 = 0; // w
    int64_t _260 = 0; // v
    int64_t _261 = 0; // u
    _jump439:; // Begin body of loop
    int64_t _262 = 0;
    _262 *= _257.d0;
    _262 += _261;
    _262 *= _257.d1;
    _262 += _260;
    _262 *= _257.d2;
    _262 += _259;
    _257.data[_262] = a;
    _259++;
    if (_259 < _255)
    goto _jump439;
    _259 = 0;
    _260++;
    if (_260 < _239)
    goto _jump439;
    _260 = 0;
    _261++;
    if (_261 < _0.d1)
    goto _jump439;
    // End body of loop
    int64_t _263 = 0;
    _263 *= _252.d0;
    _263 += _256;
    _263 *= _252.d1;
    _263 += _255;
    _252.data[_263] = _257;
    _255++;
    if (_255 < _253)
    goto _jump435;
    _255 = 0;
    _256++;
    if (_256 < d)
    goto _jump435;
    // End body of loop
    int64_t _264 = -_155.d0;
    if (_264 >= 0)
    goto _jump440;
    fail_assertion("negative array index");
    _jump440:;
    if (_264 < _252.d0)
    goto _jump441;
    fail_assertion("index too large");
    _jump441:;
    if (_155.d1 >= 0)
    goto _jump442;
    fail_assertion("negative array index");
    _jump442:;
    if (_155.d1 < _252.d1)
    goto _jump443;
    fail_assertion("index too large");
    _jump443:;
    int64_t _265 = 0;
    _265 *= _252.d0;
    _265 += _264;
    _265 *= _252.d1;
    _265 += _155.d1;
    _a3_double _266 = _252.data[_265];
    _245 = _266;
    _jump432:;
    int64_t _267 = _237 % _155.d1;
    bool _269 = true;
    bool _268 = _269;
    if (0 == _269)
    goto _jump444;
    bool _270 = g;
    if (0 != g)
    goto _jump445;
    bool _271 = true;
    _270 = _271;
    _jump445:;
    _268 = _270;
    _jump444:;
    int64_t _272;
    if (!_268)
    goto _jump446;
    _272 = e;
    goto _jump447;
    _jump446:;
    double _274 = 16.0;
    bool _275 = a >= _274;
    bool _273 = _275;
    if (0 != _275)
    goto _jump448;
    bool _276 = true;
    _273 = _276;
    _jump448:;
    int64_t _277;
    if (!_273)
    goto _jump449;
    _277 = c;
    goto _jump450;
    _jump449:;
    _277 = e;
    _jump450:;
    _272 = _277;
    _jump447:;
    if (_267 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (_267 < _245.d0)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    if (_272 >= 0)
    goto _jump453;
    fail_assertion("negative array index");
    _jump453:;
    if (_272 < _245.d1)
    goto _jump454;
    fail_assertion("index too large");
    _jump454:;
    if (e >= 0)
    goto _jump455;
    fail_assertion("negative array index");
    _jump455:;
    if (e < _245.d2)
    goto _jump456;
    fail_assertion("index too large");
    _jump456:;
    int64_t _278 = 0;
    _278 *= _245.d0;
    _278 += _267;
    _278 *= _245.d1;
    _278 += _272;
    _278 *= _245.d2;
    _278 += e;
    double _279 = _245.data[_278];
    double _280;
    // Computing bound for s
    if (_155.d0 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    _280 = 0;
    int64_t _281 = 0; // s
    _jump458:; // Begin body of loop
    double _282 = _154 * _154;
    bool _283 = true;
    double _284;
    if (!_283)
    goto _jump459;
    double _285 = -a;
    _284 = _285;
    goto _jump460;
    _jump459:;
    _284 = _154;
    _jump460:;
    bool _286 = _282 != _284;
    double _287 = f(_286);
    _280 += _287;
    _281++;
    if (_281 < _155.d0)
    goto _jump458;
    // End body of loop
    rgba _288 = { _240, a, _279, _280 };
    int64_t _289 = 0;
    _289 *= _164.d0;
    _289 += _239;
    _289 *= _164.d1;
    _289 += _238;
    _289 *= _164.d2;
    _289 += _237;
    _164.data[_289] = _288;
    _237++;
    if (_237 < _235)
    goto _jump420;
    _237 = 0;
    _238++;
    if (_238 < c)
    goto _jump420;
    _238 = 0;
    _239++;
    if (_239 < _194)
    goto _jump420;
    // End body of loop
    bool _290 = false;
    _a3_bool _291;
    if (!_290)
    goto _jump461;
    _a3_bool _292;
    // Computing bound for t
    _292.d0 = c;
    if (c > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing bound for u
    _292.d1 = _164.d0;
    if (_164.d0 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing bound for v
    _292.d2 = _155.d0;
    if (_155.d0 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    // Computing total size of heap memory to allocate
    int64_t _293 = 1;
    _293 *= c;
    _293 *= _164.d0;
    _293 *= _155.d0;
    _293 *= sizeof(bool);
    _292.data = jpl_alloc(_293);
    int64_t _294 = 0; // v
    int64_t _295 = 0; // u
    int64_t _296 = 0; // t
    _jump465:; // Begin body of loop
    int64_t _297 = 0;
    _297 *= _292.d0;
    _297 += _296;
    _297 *= _292.d1;
    _297 += _295;
    _297 *= _292.d2;
    _297 += _294;
    _292.data[_297] = g;
    _294++;
    if (_294 < _155.d0)
    goto _jump465;
    _294 = 0;
    _295++;
    if (_295 < _164.d0)
    goto _jump465;
    _295 = 0;
    _296++;
    if (_296 < c)
    goto _jump465;
    // End body of loop
    _291 = _292;
    goto _jump466;
    _jump461:;
    _a3_bool _298;
    // Computing bound for t
    _298.d0 = d;
    if (d > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing bound for u
    _298.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for v
    _298.d2 = _155.d0;
    if (_155.d0 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= d;
    _299 *= _0.d0;
    _299 *= _155.d0;
    _299 *= sizeof(bool);
    _298.data = jpl_alloc(_299);
    int64_t _300 = 0; // v
    int64_t _301 = 0; // u
    int64_t _302 = 0; // t
    _jump470:; // Begin body of loop
    int64_t _303 = 0;
    _303 *= _298.d0;
    _303 += _302;
    _303 *= _298.d1;
    _303 += _301;
    _303 *= _298.d2;
    _303 += _300;
    _298.data[_303] = g;
    _300++;
    if (_300 < _155.d0)
    goto _jump470;
    _300 = 0;
    _301++;
    if (_301 < _0.d0)
    goto _jump470;
    _301 = 0;
    _302++;
    if (_302 < d)
    goto _jump470;
    // End body of loop
    _291 = _298;
    _jump466:;
    _a3_int64_t _304;
    // Computing bound for t
    int64_t _305;
    // Computing bound for t
    int64_t _306 = 645;
    if (_306 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    _305 = 0;
    int64_t _307 = 0; // t
    _jump472:; // Begin body of loop
    _305 += _0.d1;
    _307++;
    if (_307 < _306)
    goto _jump472;
    // End body of loop
    _304.d0 = _305;
    if (_305 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for u
    _304.d1 = _155.d1;
    if (_155.d1 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing bound for v
    _304.d2 = e;
    if (e > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing total size of heap memory to allocate
    int64_t _308 = 1;
    _308 *= _305;
    _308 *= _155.d1;
    _308 *= e;
    _308 *= sizeof(int64_t);
    _304.data = jpl_alloc(_308);
    int64_t _309 = 0; // v
    int64_t _310 = 0; // u
    int64_t _311 = 0; // t
    _jump476:; // Begin body of loop
    int64_t _312 = 0;
    _312 *= _304.d0;
    _312 += _311;
    _312 *= _304.d1;
    _312 += _310;
    _312 *= _304.d2;
    _312 += _309;
    _304.data[_312] = _311;
    _309++;
    if (_309 < e)
    goto _jump476;
    _309 = 0;
    _310++;
    if (_310 < _155.d1)
    goto _jump476;
    _310 = 0;
    _311++;
    if (_311 < _305)
    goto _jump476;
    // End body of loop
    int64_t _313;
    // Computing bound for t
    int64_t _314 = 787;
    if (_314 > 0) 
    goto _jump477;
    fail_assertion("non-positive loop bound");
    _jump477:;
    // Computing bound for u
    if (_164.d0 > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    // Computing bound for v
    if (_0.d1 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    _313 = 0;
    int64_t _315 = 0; // v
    int64_t _316 = 0; // u
    int64_t _317 = 0; // t
    _jump480:; // Begin body of loop
    _313 += _164.d1;
    _315++;
    if (_315 < _0.d1)
    goto _jump480;
    _315 = 0;
    _316++;
    if (_316 < _164.d0)
    goto _jump480;
    _316 = 0;
    _317++;
    if (_317 < _314)
    goto _jump480;
    // End body of loop
    int64_t _318;
    if (!g)
    goto _jump481;
    _318 = _155.d0;
    goto _jump482;
    _jump481:;
    _318 = _164.d1;
    _jump482:;
    _a1_int64_t _319;
    _319.d0 = 3;
    _319.data = jpl_alloc(sizeof(int64_t) * 3);
    _319.data[0] = e;
    _319.data[1] = _313;
    _319.data[2] = _318;
    if (c >= 0)
    goto _jump483;
    fail_assertion("negative array index");
    _jump483:;
    if (c < _319.d0)
    goto _jump484;
    fail_assertion("index too large");
    _jump484:;
    int64_t _320 = 0;
    _320 *= _319.d0;
    _320 += c;
    int64_t _321 = _319.data[_320];
    int64_t _322 = -_321;
    if (_155.d0 >= 0)
    goto _jump485;
    fail_assertion("negative array index");
    _jump485:;
    if (_155.d0 < _304.d0)
    goto _jump486;
    fail_assertion("index too large");
    _jump486:;
    if (_164.d1 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_164.d1 < _304.d1)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (_322 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_322 < _304.d2)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _323 = 0;
    _323 *= _304.d0;
    _323 += _155.d0;
    _323 *= _304.d1;
    _323 += _164.d1;
    _323 *= _304.d2;
    _323 += _322;
    int64_t _324 = _304.data[_323];
    int64_t _325 = _155.d1 - _155.d1;
    if (_324 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_324 < _291.d0)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_325 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_325 < _291.d1)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    if (_0.d1 >= 0)
    goto _jump495;
    fail_assertion("negative array index");
    _jump495:;
    if (_0.d1 < _291.d2)
    goto _jump496;
    fail_assertion("index too large");
    _jump496:;
    int64_t _326 = 0;
    _326 *= _291.d0;
    _326 += _324;
    _326 *= _291.d1;
    _326 += _325;
    _326 *= _291.d2;
    _326 += _0.d1;
    bool _327 = _291.data[_326];
    _a1_bool _328;
    if (!_327)
    goto _jump497;
    int64_t _329;
    if (!g)
    goto _jump498;
    if (_0.d0 >= 0)
    goto _jump499;
    fail_assertion("negative array index");
    _jump499:;
    if (_0.d0 < _0.d0)
    goto _jump500;
    fail_assertion("index too large");
    _jump500:;
    if (_0.d0 >= 0)
    goto _jump501;
    fail_assertion("negative array index");
    _jump501:;
    if (_0.d0 < _0.d1)
    goto _jump502;
    fail_assertion("index too large");
    _jump502:;
    int64_t _330 = 0;
    _330 *= _0.d0;
    _330 += _0.d0;
    _330 *= _0.d1;
    _330 += _0.d0;
    bool _331 = _0.data[_330];
    _a1_int64_t _332;
    if (!_331)
    goto _jump503;
    _a1_int64_t _333;
    _333.d0 = 2;
    _333.data = jpl_alloc(sizeof(int64_t) * 2);
    _333.data[0] = _164.d2;
    _333.data[1] = _0.d0;
    _332 = _333;
    goto _jump504;
    _jump503:;
    _a1_int64_t _334;
    _334.d0 = 1;
    _334.data = jpl_alloc(sizeof(int64_t) * 1);
    _334.data[0] = c;
    _332 = _334;
    _jump504:;
    _a1_int64_t _335;
    // Computing bound for t
    _335.d0 = _155.d1;
    if (_155.d1 > 0) 
    goto _jump505;
    fail_assertion("non-positive loop bound");
    _jump505:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _155.d1;
    _336 *= sizeof(int64_t);
    _335.data = jpl_alloc(_336);
    int64_t _337 = 0; // t
    _jump506:; // Begin body of loop
    int64_t _338 = 0;
    _338 *= _335.d0;
    _338 += _337;
    _335.data[_338] = _0.d1;
    _337++;
    if (_337 < _155.d1)
    goto _jump506;
    // End body of loop
    if (_155.d0 >= 0)
    goto _jump507;
    fail_assertion("negative array index");
    _jump507:;
    if (_155.d0 < _335.d0)
    goto _jump508;
    fail_assertion("index too large");
    _jump508:;
    int64_t _339 = 0;
    _339 *= _335.d0;
    _339 += _155.d0;
    int64_t _340 = _335.data[_339];
    if (_340 >= 0)
    goto _jump509;
    fail_assertion("negative array index");
    _jump509:;
    if (_340 < _332.d0)
    goto _jump510;
    fail_assertion("index too large");
    _jump510:;
    int64_t _341 = 0;
    _341 *= _332.d0;
    _341 += _340;
    int64_t _342 = _332.data[_341];
    _329 = _342;
    goto _jump511;
    _jump498:;
    _329 = c;
    _jump511:;
    int64_t _343 = -_155.d0;
    bool _344 = _329 < _343;
    bool _345 = !g;
    _a1_bool _346;
    _346.d0 = 2;
    _346.data = jpl_alloc(sizeof(bool) * 2);
    _346.data[0] = _344;
    _346.data[1] = _345;
    _328 = _346;
    goto _jump512;
    _jump497:;
    _a1_bool _347;
    // Computing bound for t
    _347.d0 = e;
    if (e > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing total size of heap memory to allocate
    int64_t _348 = 1;
    _348 *= e;
    _348 *= sizeof(bool);
    _347.data = jpl_alloc(_348);
    int64_t _349 = 0; // t
    _jump514:; // Begin body of loop
    bool _350 = a != _154;
    bool _351 = !_350;
    bool _352;
    if (!_351)
    goto _jump515;
    bool _354 = !g;
    bool _353 = _354;
    if (0 != _354)
    goto _jump516;
    bool _355 = _0.d0 > _155.d1;
    _353 = _355;
    _jump516:;
    bool _356;
    if (!_353)
    goto _jump517;
    double _358 = -a;
    double _359 = 81.0;
    bool _360 = _358 > _359;
    bool _357 = _360;
    if (0 == _360)
    goto _jump518;
    _357 = g;
    _jump518:;
    _356 = _357;
    goto _jump519;
    _jump517:;
    double _361 = 16.0;
    bool _362 = a > _361;
    bool _363 = !_362;
    _356 = _363;
    _jump519:;
    _352 = _356;
    goto _jump520;
    _jump515:;
    _352 = g;
    _jump520:;
    int64_t _364 = 0;
    _364 *= _347.d0;
    _364 += _349;
    _347.data[_364] = _352;
    _349++;
    if (_349 < e)
    goto _jump514;
    // End body of loop
    _328 = _347;
    _jump512:;
    return _154;
}

bool v(rgba w) {
    bool _0 = true;
    bool _1;
    if (!_0)
    goto _jump664;
    _a3_double _2;
    // Computing bound for x
    _2.d0 = d;
    if (d > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for y
    _2.d1 = m;
    if (m > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing bound for z
    _2.d2 = n;
    if (n > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= d;
    _3 *= m;
    _3 *= n;
    _3 *= sizeof(double);
    _2.data = jpl_alloc(_3);
    int64_t _4 = 0; // z
    int64_t _5 = 0; // y
    int64_t _6 = 0; // x
    _jump668:; // Begin body of loop
    double _7 = 0.0;
    double _8 = -_7;
    int64_t _9 = 0;
    _9 *= _2.d0;
    _9 += _6;
    _9 *= _2.d1;
    _9 += _5;
    _9 *= _2.d2;
    _9 += _4;
    _2.data[_9] = _8;
    _4++;
    if (_4 < n)
    goto _jump668;
    _4 = 0;
    _5++;
    if (_5 < m)
    goto _jump668;
    _5 = 0;
    _6++;
    if (_6 < d)
    goto _jump668;
    // End body of loop
    int64_t _10 = u - n;
    if (m >= 0)
    goto _jump669;
    fail_assertion("negative array index");
    _jump669:;
    if (m < _2.d0)
    goto _jump670;
    fail_assertion("index too large");
    _jump670:;
    if (l >= 0)
    goto _jump671;
    fail_assertion("negative array index");
    _jump671:;
    if (l < _2.d1)
    goto _jump672;
    fail_assertion("index too large");
    _jump672:;
    if (_10 >= 0)
    goto _jump673;
    fail_assertion("negative array index");
    _jump673:;
    if (_10 < _2.d2)
    goto _jump674;
    fail_assertion("index too large");
    _jump674:;
    int64_t _11 = 0;
    _11 *= _2.d0;
    _11 += m;
    _11 *= _2.d1;
    _11 += l;
    _11 *= _2.d2;
    _11 += _10;
    double _12 = _2.data[_11];
    double _13 = w.b;
    bool _14 = _12 <= _13;
    _1 = _14;
    goto _jump675;
    _jump664:;
    bool _15 = true;
    int64_t _16;
    if (!_15)
    goto _jump676;
    _16 = r;
    goto _jump677;
    _jump676:;
    int64_t _17 = l - q;
    _16 = _17;
    _jump677:;
    bool _18 = m != _16;
    _1 = _18;
    _jump675:;
    bool _19 = !_1;
    bool _20;
    if (!_19)
    goto _jump678;
    bool _22 = v(w);
    bool _23;
    if (!_22)
    goto _jump679;
    bool _24 = true;
    _23 = _24;
    goto _jump680;
    _jump679:;
    bool _25 = v(w);
    bool _26;
    if (!_25)
    goto _jump681;
    bool _27 = true;
    _26 = _27;
    goto _jump682;
    _jump681:;
    bool _28 = o == a;
    _26 = _28;
    _jump682:;
    bool _29 = !_26;
    bool _30 = !_29;
    _23 = _30;
    _jump680:;
    bool _21 = _23;
    if (0 == _23)
    goto _jump683;
    double _31 = 84.0;
    double _32;
    // Computing bound for x
    double _33;
    // Computing bound for x
    if (h > 0) 
    goto _jump684;
    fail_assertion("non-positive loop bound");
    _jump684:;
    // Computing bound for y
    if (d > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    _33 = 0;
    int64_t _34 = 0; // y
    int64_t _35 = 0; // x
    _jump686:; // Begin body of loop
    _33 += o;
    _34++;
    if (_34 < d)
    goto _jump686;
    _34 = 0;
    _35++;
    if (_35 < h)
    goto _jump686;
    // End body of loop
    double _36 = o + a;
    bool _37 = _33 == _36;
    int64_t _38;
    if (!_37)
    goto _jump687;
    int64_t _39 = s / t;
    _38 = _39;
    goto _jump688;
    _jump687:;
    _38 = l;
    _jump688:;
    if (_38 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing bound for y
    if (m > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    // Computing bound for z
    int64_t _40;
    // Computing bound for x
    if (u > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    _40 = 0;
    int64_t _41 = 0; // x
    _jump692:; // Begin body of loop
    _40 += _41;
    _41++;
    if (_41 < u)
    goto _jump692;
    // End body of loop
    if (_40 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    _32 = 0;
    int64_t _42 = 0; // z
    int64_t _43 = 0; // y
    int64_t _44 = 0; // x
    _jump694:; // Begin body of loop
    double _45 = 5.0;
    _32 += _45;
    _42++;
    if (_42 < _40)
    goto _jump694;
    _42 = 0;
    _43++;
    if (_43 < m)
    goto _jump694;
    _43 = 0;
    _44++;
    if (_44 < _38)
    goto _jump694;
    // End body of loop
    bool _46 = _31 >= _32;
    _21 = _46;
    _jump683:;
    _20 = _21;
    goto _jump695;
    _jump678:;
    double _50;
    // Computing bound for x
    int64_t _51 = 39;
    if (_51 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for y
    if (c > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    // Computing bound for z
    if (i > 0) 
    goto _jump698;
    fail_assertion("non-positive loop bound");
    _jump698:;
    _50 = 0;
    int64_t _52 = 0; // z
    int64_t _53 = 0; // y
    int64_t _54 = 0; // x
    _jump699:; // Begin body of loop
    _50 += a;
    _52++;
    if (_52 < i)
    goto _jump699;
    _52 = 0;
    _53++;
    if (_53 < c)
    goto _jump699;
    _53 = 0;
    _54++;
    if (_54 < _51)
    goto _jump699;
    // End body of loop
    double _55;
    // Computing bound for x
    if (l > 0) 
    goto _jump700;
    fail_assertion("non-positive loop bound");
    _jump700:;
    // Computing bound for y
    if (j > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    _55 = 0;
    int64_t _56 = 0; // y
    int64_t _57 = 0; // x
    _jump702:; // Begin body of loop
    _55 += o;
    _56++;
    if (_56 < j)
    goto _jump702;
    _56 = 0;
    _57++;
    if (_57 < l)
    goto _jump702;
    // End body of loop
    double _58;
    // Computing bound for x
    if (q > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing bound for y
    if (e > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for z
    if (c > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    _58 = 0;
    int64_t _59 = 0; // z
    int64_t _60 = 0; // y
    int64_t _61 = 0; // x
    _jump706:; // Begin body of loop
    double _62 = 83.0;
    _58 += _62;
    _59++;
    if (_59 < c)
    goto _jump706;
    _59 = 0;
    _60++;
    if (_60 < e)
    goto _jump706;
    _60 = 0;
    _61++;
    if (_61 < q)
    goto _jump706;
    // End body of loop
    rgba _63 = { _50, _55, _58, a };
    bool _64 = v(_63);
    bool _49 = _64;
    if (0 != _64)
    goto _jump707;
    bool _65 = false;
    _49 = _65;
    _jump707:;
    bool _48 = _49;
    if (0 == _49)
    goto _jump708;
    double _66 = 13.0;
    rgba _67 = { a, _66, a, a };
    bool _68 = v(_67);
    bool _69;
    if (!_68)
    goto _jump709;
    bool _71 = h < s;
    bool _70 = _71;
    if (0 == _71)
    goto _jump710;
    bool _72 = false;
    bool _73 = !_72;
    _70 = _73;
    _jump710:;
    _69 = _70;
    goto _jump711;
    _jump709:;
    bool _74 = v(w);
    _69 = _74;
    _jump711:;
    _a3_bool _75;
    // Computing bound for x
    _75.d0 = t;
    if (t > 0) 
    goto _jump712;
    fail_assertion("non-positive loop bound");
    _jump712:;
    // Computing bound for y
    int64_t _76 = -j;
    _75.d1 = _76;
    if (_76 > 0) 
    goto _jump713;
    fail_assertion("non-positive loop bound");
    _jump713:;
    // Computing bound for z
    int64_t _77 = -l;
    _75.d2 = _77;
    if (_77 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= t;
    _78 *= _76;
    _78 *= _77;
    _78 *= sizeof(bool);
    _75.data = jpl_alloc(_78);
    int64_t _79 = 0; // z
    int64_t _80 = 0; // y
    int64_t _81 = 0; // x
    _jump715:; // Begin body of loop
    bool _82 = m >= c;
    int64_t _83 = 0;
    _83 *= _75.d0;
    _83 += _81;
    _83 *= _75.d1;
    _83 += _80;
    _83 *= _75.d2;
    _83 += _79;
    _75.data[_83] = _82;
    _79++;
    if (_79 < _77)
    goto _jump715;
    _79 = 0;
    _80++;
    if (_80 < _76)
    goto _jump715;
    _80 = 0;
    _81++;
    if (_81 < t)
    goto _jump715;
    // End body of loop
    int64_t _84 = -c;
    if (d >= 0)
    goto _jump716;
    fail_assertion("negative array index");
    _jump716:;
    if (d < _75.d0)
    goto _jump717;
    fail_assertion("index too large");
    _jump717:;
    if (_84 >= 0)
    goto _jump718;
    fail_assertion("negative array index");
    _jump718:;
    if (_84 < _75.d1)
    goto _jump719;
    fail_assertion("index too large");
    _jump719:;
    if (q >= 0)
    goto _jump720;
    fail_assertion("negative array index");
    _jump720:;
    if (q < _75.d2)
    goto _jump721;
    fail_assertion("index too large");
    _jump721:;
    int64_t _85 = 0;
    _85 *= _75.d0;
    _85 += d;
    _85 *= _75.d1;
    _85 += _84;
    _85 *= _75.d2;
    _85 += q;
    bool _86 = _75.data[_85];
    bool _87 = _69 != _86;
    _48 = _87;
    _jump708:;
    bool _47 = _48;
    if (0 == _48)
    goto _jump722;
    bool _91 = false;
    bool _90 = _91;
    if (0 == _91)
    goto _jump723;
    bool _92 = true;
    bool _93;
    if (!_92)
    goto _jump724;
    bool _94 = h > l;
    _93 = _94;
    goto _jump725;
    _jump724:;
    bool _95 = true;
    _93 = _95;
    _jump725:;
    _90 = _93;
    _jump723:;
    bool _89 = _90;
    if (0 == _90)
    goto _jump726;
    double _96 = 39.0;
    double _97 = 37.0;
    rgba _98 = { o, _96, o, _97 };
    double _99 = _98.g;
    bool _100 = _99 > a;
    _89 = _100;
    _jump726:;
    bool _88 = _89;
    if (0 == _89)
    goto _jump727;
    bool _101 = v(w);
    _88 = _101;
    _jump727:;
    _47 = _88;
    _jump722:;
    _20 = _47;
    _jump695:;
    return _20;
    double _102 = 36.0;
    double _103 = -_102;
    bool _104 = a <= _103;
    double _105;
    if (!_104)
    goto _jump728;
    double _106 = 38.0;
    _105 = _106;
    goto _jump729;
    _jump728:;
    bool _107 = false;
    bool _108 = !_107;
    double _109;
    if (!_108)
    goto _jump730;
    double _110 = 72.0;
    _109 = _110;
    goto _jump731;
    _jump730:;
    bool _111 = false;
    double _112 = f(_111);
    _109 = _112;
    _jump731:;
    _105 = _109;
    _jump729:;
    double _113 = 48.0;
    bool _114 = _105 != _113;
    _a3_bool _115;
    if (!_114)
    goto _jump732;
    _a2__a3_bool _116;
    // Computing bound for x
    _116.d0 = d;
    if (d > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for y
    _116.d1 = c;
    if (c > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= d;
    _117 *= c;
    _117 *= sizeof(_a3_bool);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // y
    int64_t _119 = 0; // x
    _jump735:; // Begin body of loop
    _a3_bool _120;
    // Computing bound for z
    _120.d0 = d;
    if (d > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for A
    _120.d1 = q;
    if (q > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    // Computing bound for B
    _120.d2 = n;
    if (n > 0) 
    goto _jump738;
    fail_assertion("non-positive loop bound");
    _jump738:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= d;
    _121 *= q;
    _121 *= n;
    _121 *= sizeof(bool);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // B
    int64_t _123 = 0; // A
    int64_t _124 = 0; // z
    _jump739:; // Begin body of loop
    bool _125 = false;
    int64_t _126 = 0;
    _126 *= _120.d0;
    _126 += _124;
    _126 *= _120.d1;
    _126 += _123;
    _126 *= _120.d2;
    _126 += _122;
    _120.data[_126] = _125;
    _122++;
    if (_122 < n)
    goto _jump739;
    _122 = 0;
    _123++;
    if (_123 < q)
    goto _jump739;
    _123 = 0;
    _124++;
    if (_124 < d)
    goto _jump739;
    // End body of loop
    int64_t _127 = 0;
    _127 *= _116.d0;
    _127 += _119;
    _127 *= _116.d1;
    _127 += _118;
    _116.data[_127] = _120;
    _118++;
    if (_118 < c)
    goto _jump735;
    _118 = 0;
    _119++;
    if (_119 < d)
    goto _jump735;
    // End body of loop
    if (m >= 0)
    goto _jump740;
    fail_assertion("negative array index");
    _jump740:;
    if (m < _116.d0)
    goto _jump741;
    fail_assertion("index too large");
    _jump741:;
    if (s >= 0)
    goto _jump742;
    fail_assertion("negative array index");
    _jump742:;
    if (s < _116.d1)
    goto _jump743;
    fail_assertion("index too large");
    _jump743:;
    int64_t _128 = 0;
    _128 *= _116.d0;
    _128 += m;
    _128 *= _116.d1;
    _128 += s;
    _a3_bool _129 = _116.data[_128];
    _115 = _129;
    goto _jump744;
    _jump732:;
    _a3_bool _130;
    // Computing bound for x
    _130.d0 = u;
    if (u > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    // Computing bound for y
    int64_t _131 = 176;
    _130.d1 = _131;
    if (_131 > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing bound for z
    _130.d2 = n;
    if (n > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= u;
    _132 *= _131;
    _132 *= n;
    _132 *= sizeof(bool);
    _130.data = jpl_alloc(_132);
    int64_t _133 = 0; // z
    int64_t _134 = 0; // y
    int64_t _135 = 0; // x
    _jump748:; // Begin body of loop
    bool _136 = s > s;
    int64_t _137 = 0;
    _137 *= _130.d0;
    _137 += _135;
    _137 *= _130.d1;
    _137 += _134;
    _137 *= _130.d2;
    _137 += _133;
    _130.data[_137] = _136;
    _133++;
    if (_133 < n)
    goto _jump748;
    _133 = 0;
    _134++;
    if (_134 < _131)
    goto _jump748;
    _134 = 0;
    _135++;
    if (_135 < u)
    goto _jump748;
    // End body of loop
    _a3_bool _138;
    // Computing bound for x
    _138.d0 = t;
    if (t > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing bound for y
    _138.d1 = i;
    if (i > 0) 
    goto _jump750;
    fail_assertion("non-positive loop bound");
    _jump750:;
    // Computing bound for z
    _138.d2 = e;
    if (e > 0) 
    goto _jump751;
    fail_assertion("non-positive loop bound");
    _jump751:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= t;
    _139 *= i;
    _139 *= e;
    _139 *= sizeof(bool);
    _138.data = jpl_alloc(_139);
    int64_t _140 = 0; // z
    int64_t _141 = 0; // y
    int64_t _142 = 0; // x
    _jump752:; // Begin body of loop
    bool _143 = true;
    int64_t _144 = 0;
    _144 *= _138.d0;
    _144 += _142;
    _144 *= _138.d1;
    _144 += _141;
    _144 *= _138.d2;
    _144 += _140;
    _138.data[_144] = _143;
    _140++;
    if (_140 < e)
    goto _jump752;
    _140 = 0;
    _141++;
    if (_141 < i)
    goto _jump752;
    _141 = 0;
    _142++;
    if (_142 < t)
    goto _jump752;
    // End body of loop
    _a1__a3_bool _145;
    _145.d0 = 2;
    _145.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _145.data[0] = _130;
    _145.data[1] = _138;
    if (j >= 0)
    goto _jump753;
    fail_assertion("negative array index");
    _jump753:;
    if (j < _145.d0)
    goto _jump754;
    fail_assertion("index too large");
    _jump754:;
    int64_t _146 = 0;
    _146 *= _145.d0;
    _146 += j;
    _a3_bool _147 = _145.data[_146];
    _115 = _147;
    _jump744:;
    bool _149 = o == o;
    bool _148 = _149;
    if (0 != _149)
    goto _jump755;
    bool _150 = v(w);
    _148 = _150;
    _jump755:;
    bool _151 = !_148;
    bool _152;
    if (!_151)
    goto _jump756;
    bool _153 = false;
    bool _154 = false;
    bool _155 = _153 == _154;
    bool _156 = !_155;
    bool _157 = !_156;
    _152 = _157;
    goto _jump757;
    _jump756:;
    bool _158 = true;
    bool _159;
    if (!_158)
    goto _jump758;
    bool _160 = false;
    _159 = _160;
    goto _jump759;
    _jump758:;
    bool _161 = v(w);
    _159 = _161;
    _jump759:;
    _152 = _159;
    _jump757:;
    int64_t _162;
    if (!_152)
    goto _jump760;
    int64_t _163 = 202;
    _162 = _163;
    goto _jump761;
    _jump760:;
    bool _164 = i != r;
    int64_t _165;
    if (!_164)
    goto _jump762;
    _165 = d;
    goto _jump763;
    _jump762:;
    _165 = l;
    _jump763:;
    _162 = _165;
    _jump761:;
    if (e >= 0)
    goto _jump764;
    fail_assertion("negative array index");
    _jump764:;
    if (e < _115.d0)
    goto _jump765;
    fail_assertion("index too large");
    _jump765:;
    if (_162 >= 0)
    goto _jump766;
    fail_assertion("negative array index");
    _jump766:;
    if (_162 < _115.d1)
    goto _jump767;
    fail_assertion("index too large");
    _jump767:;
    if (n >= 0)
    goto _jump768;
    fail_assertion("negative array index");
    _jump768:;
    if (n < _115.d2)
    goto _jump769;
    fail_assertion("index too large");
    _jump769:;
    int64_t _166 = 0;
    _166 *= _115.d0;
    _166 += e;
    _166 *= _115.d1;
    _166 += _162;
    _166 *= _115.d2;
    _166 += n;
    bool _167 = _115.data[_166];
    _a2_int64_t _168;
    if (!_167)
    goto _jump770;
    double _169 = w.r;
    double _170 = -_169;
    bool _171 = l < u;
    double _172 = f(_171);
    double _173 = fmod(_170, _172);
    bool _175 = false;
    bool _174 = _175;
    if (0 == _175)
    goto _jump771;
    bool _176 = true;
    _174 = _176;
    _jump771:;
    double _177 = f(_174);
    rgba _178 = { _173, _177, a, a };
    bool _179 = v(_178);
    _a2_int64_t _180;
    if (!_179)
    goto _jump772;
    _a2_bool _181;
    // Computing bound for x
    _181.d0 = u;
    if (u > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing bound for y
    bool _182 = v(w);
    int64_t _183;
    if (!_182)
    goto _jump774;
    _183 = u;
    goto _jump775;
    _jump774:;
    _183 = c;
    _jump775:;
    _181.d1 = _183;
    if (_183 > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= u;
    _184 *= _183;
    _184 *= sizeof(bool);
    _181.data = jpl_alloc(_184);
    int64_t _185 = 0; // y
    int64_t _186 = 0; // x
    _jump777:; // Begin body of loop
    bool _187 = s != r;
    int64_t _188 = 0;
    _188 *= _181.d0;
    _188 += _186;
    _188 *= _181.d1;
    _188 += _185;
    _181.data[_188] = _187;
    _185++;
    if (_185 < _183)
    goto _jump777;
    _185 = 0;
    _186++;
    if (_186 < u)
    goto _jump777;
    // End body of loop
    if (m >= 0)
    goto _jump778;
    fail_assertion("negative array index");
    _jump778:;
    if (m < _181.d0)
    goto _jump779;
    fail_assertion("index too large");
    _jump779:;
    if (h >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (h < _181.d1)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _189 = 0;
    _189 *= _181.d0;
    _189 += m;
    _189 *= _181.d1;
    _189 += h;
    bool _190 = _181.data[_189];
    _a2_int64_t _191;
    if (!_190)
    goto _jump782;
    _a2_int64_t _192;
    // Computing bound for x
    _192.d0 = t;
    if (t > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing bound for y
    int64_t _193 = m / t;
    int64_t _194 = h * _193;
    _192.d1 = _194;
    if (_194 > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= t;
    _195 *= _194;
    _195 *= sizeof(int64_t);
    _192.data = jpl_alloc(_195);
    int64_t _196 = 0; // y
    int64_t _197 = 0; // x
    _jump785:; // Begin body of loop
    int64_t _198 = 0;
    _198 *= _192.d0;
    _198 += _197;
    _198 *= _192.d1;
    _198 += _196;
    _192.data[_198] = _197;
    _196++;
    if (_196 < _194)
    goto _jump785;
    _196 = 0;
    _197++;
    if (_197 < t)
    goto _jump785;
    // End body of loop
    _191 = _192;
    goto _jump786;
    _jump782:;
    bool _199 = false;
    bool _200 = !_199;
    bool _201 = !_200;
    _a2_int64_t _202;
    if (!_201)
    goto _jump787;
    double _203 = 74.0;
    double _204 = 91.0;
    bool _205 = _203 == _204;
    _a2_int64_t _206;
    if (!_205)
    goto _jump788;
    _a2_int64_t _207;
    // Computing bound for x
    int64_t _208;
    // Computing bound for x
    if (e > 0) 
    goto _jump789;
    fail_assertion("non-positive loop bound");
    _jump789:;
    // Computing bound for y
    if (e > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    _208 = 0;
    int64_t _209 = 0; // y
    int64_t _210 = 0; // x
    _jump791:; // Begin body of loop
    int64_t _211 = 125;
    _208 += _211;
    _209++;
    if (_209 < e)
    goto _jump791;
    _209 = 0;
    _210++;
    if (_210 < e)
    goto _jump791;
    // End body of loop
    _207.d0 = _208;
    if (_208 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing bound for y
    int64_t _212 = 29;
    _207.d1 = _212;
    if (_212 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= _208;
    _213 *= _212;
    _213 *= sizeof(int64_t);
    _207.data = jpl_alloc(_213);
    int64_t _214 = 0; // y
    int64_t _215 = 0; // x
    _jump794:; // Begin body of loop
    int64_t _216 = 0;
    _216 *= _207.d0;
    _216 += _215;
    _216 *= _207.d1;
    _216 += _214;
    _207.data[_216] = h;
    _214++;
    if (_214 < _212)
    goto _jump794;
    _214 = 0;
    _215++;
    if (_215 < _208)
    goto _jump794;
    // End body of loop
    _206 = _207;
    goto _jump795;
    _jump788:;
    bool _217 = e != h;
    _a2_int64_t _218;
    if (!_217)
    goto _jump796;
    _a2_int64_t _219;
    // Computing bound for x
    _219.d0 = n;
    if (n > 0) 
    goto _jump797;
    fail_assertion("non-positive loop bound");
    _jump797:;
    // Computing bound for y
    _219.d1 = l;
    if (l > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing total size of heap memory to allocate
    int64_t _220 = 1;
    _220 *= n;
    _220 *= l;
    _220 *= sizeof(int64_t);
    _219.data = jpl_alloc(_220);
    int64_t _221 = 0; // y
    int64_t _222 = 0; // x
    _jump799:; // Begin body of loop
    int64_t _223 = 0;
    _223 *= _219.d0;
    _223 += _222;
    _223 *= _219.d1;
    _223 += _221;
    _219.data[_223] = h;
    _221++;
    if (_221 < l)
    goto _jump799;
    _221 = 0;
    _222++;
    if (_222 < n)
    goto _jump799;
    // End body of loop
    _218 = _219;
    goto _jump800;
    _jump796:;
    _a2_int64_t _224;
    // Computing bound for x
    _224.d0 = d;
    if (d > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing bound for y
    _224.d1 = d;
    if (d > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing total size of heap memory to allocate
    int64_t _225 = 1;
    _225 *= d;
    _225 *= d;
    _225 *= sizeof(int64_t);
    _224.data = jpl_alloc(_225);
    int64_t _226 = 0; // y
    int64_t _227 = 0; // x
    _jump803:; // Begin body of loop
    int64_t _228 = 0;
    _228 *= _224.d0;
    _228 += _227;
    _228 *= _224.d1;
    _228 += _226;
    _224.data[_228] = q;
    _226++;
    if (_226 < d)
    goto _jump803;
    _226 = 0;
    _227++;
    if (_227 < d)
    goto _jump803;
    // End body of loop
    _218 = _224;
    _jump800:;
    _206 = _218;
    _jump795:;
    _202 = _206;
    goto _jump804;
    _jump787:;
    _a2__a2_int64_t _229;
    // Computing bound for x
    _229.d0 = c;
    if (c > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing bound for y
    _229.d1 = u;
    if (u > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= c;
    _230 *= u;
    _230 *= sizeof(_a2_int64_t);
    _229.data = jpl_alloc(_230);
    int64_t _231 = 0; // y
    int64_t _232 = 0; // x
    _jump807:; // Begin body of loop
    _a2_int64_t _233;
    // Computing bound for z
    _233.d0 = _231;
    if (_231 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing bound for A
    _233.d1 = u;
    if (u > 0) 
    goto _jump809;
    fail_assertion("non-positive loop bound");
    _jump809:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= _231;
    _234 *= u;
    _234 *= sizeof(int64_t);
    _233.data = jpl_alloc(_234);
    int64_t _235 = 0; // A
    int64_t _236 = 0; // z
    _jump810:; // Begin body of loop
    int64_t _237 = 0;
    _237 *= _233.d0;
    _237 += _236;
    _237 *= _233.d1;
    _237 += _235;
    _233.data[_237] = _232;
    _235++;
    if (_235 < u)
    goto _jump810;
    _235 = 0;
    _236++;
    if (_236 < _231)
    goto _jump810;
    // End body of loop
    int64_t _238 = 0;
    _238 *= _229.d0;
    _238 += _232;
    _238 *= _229.d1;
    _238 += _231;
    _229.data[_238] = _233;
    _231++;
    if (_231 < u)
    goto _jump807;
    _231 = 0;
    _232++;
    if (_232 < c)
    goto _jump807;
    // End body of loop
    if (l >= 0)
    goto _jump811;
    fail_assertion("negative array index");
    _jump811:;
    if (l < _229.d0)
    goto _jump812;
    fail_assertion("index too large");
    _jump812:;
    if (i >= 0)
    goto _jump813;
    fail_assertion("negative array index");
    _jump813:;
    if (i < _229.d1)
    goto _jump814;
    fail_assertion("index too large");
    _jump814:;
    int64_t _239 = 0;
    _239 *= _229.d0;
    _239 += l;
    _239 *= _229.d1;
    _239 += i;
    _a2_int64_t _240 = _229.data[_239];
    _202 = _240;
    _jump804:;
    _191 = _202;
    _jump786:;
    _180 = _191;
    goto _jump815;
    _jump772:;
    _a3__a1__a2_int64_t _241;
    // Computing bound for x
    _241.d0 = n;
    if (n > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    // Computing bound for y
    _241.d1 = t;
    if (t > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for z
    _241.d2 = l;
    if (l > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing total size of heap memory to allocate
    int64_t _242 = 1;
    _242 *= n;
    _242 *= t;
    _242 *= l;
    _242 *= sizeof(_a1__a2_int64_t);
    _241.data = jpl_alloc(_242);
    int64_t _243 = 0; // z
    int64_t _244 = 0; // y
    int64_t _245 = 0; // x
    _jump819:; // Begin body of loop
    _a1__a2_int64_t _246;
    // Computing bound for A
    _246.d0 = r;
    if (r > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= r;
    _247 *= sizeof(_a2_int64_t);
    _246.data = jpl_alloc(_247);
    int64_t _248 = 0; // A
    _jump821:; // Begin body of loop
    _a2_int64_t _249;
    // Computing bound for B
    _249.d0 = e;
    if (e > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    // Computing bound for C
    _249.d1 = e;
    if (e > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= e;
    _250 *= e;
    _250 *= sizeof(int64_t);
    _249.data = jpl_alloc(_250);
    int64_t _251 = 0; // C
    int64_t _252 = 0; // B
    _jump824:; // Begin body of loop
    int64_t _253 = 0;
    _253 *= _249.d0;
    _253 += _252;
    _253 *= _249.d1;
    _253 += _251;
    _249.data[_253] = d;
    _251++;
    if (_251 < e)
    goto _jump824;
    _251 = 0;
    _252++;
    if (_252 < e)
    goto _jump824;
    // End body of loop
    int64_t _254 = 0;
    _254 *= _246.d0;
    _254 += _248;
    _246.data[_254] = _249;
    _248++;
    if (_248 < r)
    goto _jump821;
    // End body of loop
    int64_t _255 = 0;
    _255 *= _241.d0;
    _255 += _245;
    _255 *= _241.d1;
    _255 += _244;
    _255 *= _241.d2;
    _255 += _243;
    _241.data[_255] = _246;
    _243++;
    if (_243 < l)
    goto _jump819;
    _243 = 0;
    _244++;
    if (_244 < t)
    goto _jump819;
    _244 = 0;
    _245++;
    if (_245 < n)
    goto _jump819;
    // End body of loop
    int64_t _256 = d + q;
    if (c >= 0)
    goto _jump825;
    fail_assertion("negative array index");
    _jump825:;
    if (c < _241.d0)
    goto _jump826;
    fail_assertion("index too large");
    _jump826:;
    if (_256 >= 0)
    goto _jump827;
    fail_assertion("negative array index");
    _jump827:;
    if (_256 < _241.d1)
    goto _jump828;
    fail_assertion("index too large");
    _jump828:;
    if (r >= 0)
    goto _jump829;
    fail_assertion("negative array index");
    _jump829:;
    if (r < _241.d2)
    goto _jump830;
    fail_assertion("index too large");
    _jump830:;
    int64_t _257 = 0;
    _257 *= _241.d0;
    _257 += c;
    _257 *= _241.d1;
    _257 += _256;
    _257 *= _241.d2;
    _257 += r;
    _a1__a2_int64_t _258 = _241.data[_257];
    if (q >= 0)
    goto _jump831;
    fail_assertion("negative array index");
    _jump831:;
    if (q < _258.d0)
    goto _jump832;
    fail_assertion("index too large");
    _jump832:;
    int64_t _259 = 0;
    _259 *= _258.d0;
    _259 += q;
    _a2_int64_t _260 = _258.data[_259];
    _180 = _260;
    _jump815:;
    _168 = _180;
    goto _jump833;
    _jump770:;
    _a2__a2_int64_t _261;
    // Computing bound for x
    _261.d0 = r;
    if (r > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing bound for y
    _261.d1 = u;
    if (u > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing total size of heap memory to allocate
    int64_t _262 = 1;
    _262 *= r;
    _262 *= u;
    _262 *= sizeof(_a2_int64_t);
    _261.data = jpl_alloc(_262);
    int64_t _263 = 0; // y
    int64_t _264 = 0; // x
    _jump836:; // Begin body of loop
    _a2_int64_t _265;
    // Computing bound for z
    _265.d0 = l;
    if (l > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for A
    _265.d1 = c;
    if (c > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing total size of heap memory to allocate
    int64_t _266 = 1;
    _266 *= l;
    _266 *= c;
    _266 *= sizeof(int64_t);
    _265.data = jpl_alloc(_266);
    int64_t _267 = 0; // A
    int64_t _268 = 0; // z
    _jump839:; // Begin body of loop
    int64_t _269 = 0;
    _269 *= _265.d0;
    _269 += _268;
    _269 *= _265.d1;
    _269 += _267;
    _265.data[_269] = q;
    _267++;
    if (_267 < c)
    goto _jump839;
    _267 = 0;
    _268++;
    if (_268 < l)
    goto _jump839;
    // End body of loop
    int64_t _270 = 0;
    _270 *= _261.d0;
    _270 += _264;
    _270 *= _261.d1;
    _270 += _263;
    _261.data[_270] = _265;
    _263++;
    if (_263 < u)
    goto _jump836;
    _263 = 0;
    _264++;
    if (_264 < r)
    goto _jump836;
    // End body of loop
    _a3_int64_t _271;
    // Computing bound for x
    _271.d0 = m;
    if (m > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for y
    _271.d1 = r;
    if (r > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing bound for z
    _271.d2 = m;
    if (m > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing total size of heap memory to allocate
    int64_t _272 = 1;
    _272 *= m;
    _272 *= r;
    _272 *= m;
    _272 *= sizeof(int64_t);
    _271.data = jpl_alloc(_272);
    int64_t _273 = 0; // z
    int64_t _274 = 0; // y
    int64_t _275 = 0; // x
    _jump843:; // Begin body of loop
    int64_t _276 = 0;
    _276 *= _271.d0;
    _276 += _275;
    _276 *= _271.d1;
    _276 += _274;
    _276 *= _271.d2;
    _276 += _273;
    _271.data[_276] = r;
    _273++;
    if (_273 < m)
    goto _jump843;
    _273 = 0;
    _274++;
    if (_274 < r)
    goto _jump843;
    _274 = 0;
    _275++;
    if (_275 < m)
    goto _jump843;
    // End body of loop
    _a2_int64_t _277;
    // Computing bound for x
    int64_t _278;
    // Computing bound for x
    if (u > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    _278 = 0;
    int64_t _279 = 0; // x
    _jump845:; // Begin body of loop
    _278 += d;
    _279++;
    if (_279 < u)
    goto _jump845;
    // End body of loop
    _277.d0 = _278;
    if (_278 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    // Computing bound for y
    _277.d1 = s;
    if (s > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing total size of heap memory to allocate
    int64_t _280 = 1;
    _280 *= _278;
    _280 *= s;
    _280 *= sizeof(int64_t);
    _277.data = jpl_alloc(_280);
    int64_t _281 = 0; // y
    int64_t _282 = 0; // x
    _jump848:; // Begin body of loop
    int64_t _283 = 0;
    _283 *= _277.d0;
    _283 += _282;
    _283 *= _277.d1;
    _283 += _281;
    _277.data[_283] = u;
    _281++;
    if (_281 < s)
    goto _jump848;
    _281 = 0;
    _282++;
    if (_282 < _278)
    goto _jump848;
    // End body of loop
    int64_t _284 = -q;
    if (u >= 0)
    goto _jump849;
    fail_assertion("negative array index");
    _jump849:;
    if (u < _277.d0)
    goto _jump850;
    fail_assertion("index too large");
    _jump850:;
    if (_284 >= 0)
    goto _jump851;
    fail_assertion("negative array index");
    _jump851:;
    if (_284 < _277.d1)
    goto _jump852;
    fail_assertion("index too large");
    _jump852:;
    int64_t _285 = 0;
    _285 *= _277.d0;
    _285 += u;
    _285 *= _277.d1;
    _285 += _284;
    int64_t _286 = _277.data[_285];
    int64_t _287 = 58;
    if (_286 >= 0)
    goto _jump853;
    fail_assertion("negative array index");
    _jump853:;
    if (_286 < _271.d0)
    goto _jump854;
    fail_assertion("index too large");
    _jump854:;
    if (_287 >= 0)
    goto _jump855;
    fail_assertion("negative array index");
    _jump855:;
    if (_287 < _271.d1)
    goto _jump856;
    fail_assertion("index too large");
    _jump856:;
    if (m >= 0)
    goto _jump857;
    fail_assertion("negative array index");
    _jump857:;
    if (m < _271.d2)
    goto _jump858;
    fail_assertion("index too large");
    _jump858:;
    int64_t _288 = 0;
    _288 *= _271.d0;
    _288 += _286;
    _288 *= _271.d1;
    _288 += _287;
    _288 *= _271.d2;
    _288 += m;
    int64_t _289 = _271.data[_288];
    int64_t _290 = _289 / c;
    _a1_rgba _291;
    // Computing bound for x
    _291.d0 = c;
    if (c > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    // Computing total size of heap memory to allocate
    int64_t _292 = 1;
    _292 *= c;
    _292 *= sizeof(rgba);
    _291.data = jpl_alloc(_292);
    int64_t _293 = 0; // x
    _jump860:; // Begin body of loop
    int64_t _294 = 0;
    _294 *= _291.d0;
    _294 += _293;
    _291.data[_294] = w;
    _293++;
    if (_293 < c)
    goto _jump860;
    // End body of loop
    if (e >= 0)
    goto _jump861;
    fail_assertion("negative array index");
    _jump861:;
    if (e < _291.d0)
    goto _jump862;
    fail_assertion("index too large");
    _jump862:;
    int64_t _295 = 0;
    _295 *= _291.d0;
    _295 += e;
    rgba _296 = _291.data[_295];
    bool _297 = v(_296);
    bool _298;
    if (!_297)
    goto _jump863;
    bool _299 = v(w);
    bool _300;
    if (!_299)
    goto _jump864;
    bool _301 = true;
    bool _302 = !_301;
    _300 = _302;
    goto _jump865;
    _jump864:;
    bool _303 = false;
    _300 = _303;
    _jump865:;
    _298 = _300;
    goto _jump866;
    _jump863:;
    bool _305 = false;
    bool _304 = _305;
    if (0 != _305)
    goto _jump867;
    bool _306 = i >= m;
    _304 = _306;
    _jump867:;
    bool _307;
    if (!_304)
    goto _jump868;
    bool _308 = true;
    _307 = _308;
    goto _jump869;
    _jump868:;
    bool _309 = false;
    bool _310 = !_309;
    bool _311 = true;
    bool _312 = _310 != _311;
    _307 = _312;
    _jump869:;
    _298 = _307;
    _jump866:;
    int64_t _313;
    if (!_298)
    goto _jump870;
    _313 = s;
    goto _jump871;
    _jump870:;
    int64_t _314;
    // Computing bound for x
    if (c > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    // Computing bound for y
    if (s > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    // Computing bound for z
    if (e > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    _314 = 0;
    int64_t _315 = 0; // z
    int64_t _316 = 0; // y
    int64_t _317 = 0; // x
    _jump875:; // Begin body of loop
    _314 += i;
    _315++;
    if (_315 < e)
    goto _jump875;
    _315 = 0;
    _316++;
    if (_316 < s)
    goto _jump875;
    _316 = 0;
    _317++;
    if (_317 < c)
    goto _jump875;
    // End body of loop
    _313 = _314;
    _jump871:;
    if (_290 >= 0)
    goto _jump876;
    fail_assertion("negative array index");
    _jump876:;
    if (_290 < _261.d0)
    goto _jump877;
    fail_assertion("index too large");
    _jump877:;
    if (_313 >= 0)
    goto _jump878;
    fail_assertion("negative array index");
    _jump878:;
    if (_313 < _261.d1)
    goto _jump879;
    fail_assertion("index too large");
    _jump879:;
    int64_t _318 = 0;
    _318 *= _261.d0;
    _318 += _290;
    _318 *= _261.d1;
    _318 += _313;
    _a2_int64_t _319 = _261.data[_318];
    _168 = _319;
    _jump833:;
    bool _320 = v(w);
    rgba _321;
    if (!_320)
    goto _jump880;
    if (h >= 0)
    goto _jump881;
    fail_assertion("negative array index");
    _jump881:;
    if (h < k.d0)
    goto _jump882;
    fail_assertion("index too large");
    _jump882:;
    if (j >= 0)
    goto _jump883;
    fail_assertion("negative array index");
    _jump883:;
    if (j < k.d1)
    goto _jump884;
    fail_assertion("index too large");
    _jump884:;
    if (l >= 0)
    goto _jump885;
    fail_assertion("negative array index");
    _jump885:;
    if (l < k.d2)
    goto _jump886;
    fail_assertion("index too large");
    _jump886:;
    int64_t _322 = 0;
    _322 *= k.d0;
    _322 += h;
    _322 *= k.d1;
    _322 += j;
    _322 *= k.d2;
    _322 += l;
    rgba _323 = k.data[_322];
    _321 = _323;
    goto _jump887;
    _jump880:;
    _321 = w;
    _jump887:;
    double _324 = _321.a;
    bool _325 = v(w);
    double _326;
    if (!_325)
    goto _jump888;
    bool _327 = true;
    rgba _328;
    if (!_327)
    goto _jump889;
    _328 = w;
    goto _jump890;
    _jump889:;
    _328 = w;
    _jump890:;
    double _329 = _328.r;
    _326 = _329;
    goto _jump891;
    _jump888:;
    bool _330 = false;
    double _331;
    if (!_330)
    goto _jump892;
    _331 = o;
    goto _jump893;
    _jump892:;
    double _332;
    // Computing bound for A
    int64_t _333 = 5;
    if (_333 > 0) 
    goto _jump894;
    fail_assertion("non-positive loop bound");
    _jump894:;
    // Computing bound for B
    if (s > 0) 
    goto _jump895;
    fail_assertion("non-positive loop bound");
    _jump895:;
    // Computing bound for C
    if (s > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    _332 = 0;
    int64_t _334 = 0; // C
    int64_t _335 = 0; // B
    int64_t _336 = 0; // A
    _jump897:; // Begin body of loop
    _332 += a;
    _334++;
    if (_334 < s)
    goto _jump897;
    _334 = 0;
    _335++;
    if (_335 < s)
    goto _jump897;
    _335 = 0;
    _336++;
    if (_336 < _333)
    goto _jump897;
    // End body of loop
    _331 = _332;
    _jump893:;
    _326 = _331;
    _jump891:;
    double _337 = 99.0;
    double _338 = -_337;
    double _339 = 51.0;
    rgba _340 = { _324, _326, _338, _339 };
    bool _341 = v(_340);
    bool _342;
    if (!_341)
    goto _jump898;
    double _343 = 7.0;
    bool _344 = _343 != o;
    bool _345 = true;
    int64_t _346;
    if (!_345)
    goto _jump899;
    _346 = u;
    goto _jump900;
    _jump899:;
    _346 = u;
    _jump900:;
    bool _347 = d < _346;
    bool _348 = _344 == _347;
    _342 = _348;
    goto _jump901;
    _jump898:;
    bool _349 = false;
    _342 = _349;
    _jump901:;
    int64_t _350;
    if (!_342)
    goto _jump902;
    _350 = d;
    goto _jump903;
    _jump902:;
    _350 = r;
    _jump903:;
    _a1_int64_t _351;
    // Computing bound for G
    bool _352 = true;
    _a2_bool _353;
    if (!_352)
    goto _jump904;
    _a2_bool _354;
    // Computing bound for G
    _354.d0 = _168.d0;
    if (_168.d0 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for H
    _354.d1 = c;
    if (c > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    // Computing total size of heap memory to allocate
    int64_t _355 = 1;
    _355 *= _168.d0;
    _355 *= c;
    _355 *= sizeof(bool);
    _354.data = jpl_alloc(_355);
    int64_t _356 = 0; // H
    int64_t _357 = 0; // G
    _jump907:; // Begin body of loop
    bool _358 = true;
    int64_t _359 = 0;
    _359 *= _354.d0;
    _359 += _357;
    _359 *= _354.d1;
    _359 += _356;
    _354.data[_359] = _358;
    _356++;
    if (_356 < c)
    goto _jump907;
    _356 = 0;
    _357++;
    if (_357 < _168.d0)
    goto _jump907;
    // End body of loop
    _353 = _354;
    goto _jump908;
    _jump904:;
    _a2_bool _360;
    // Computing bound for G
    _360.d0 = s;
    if (s > 0) 
    goto _jump909;
    fail_assertion("non-positive loop bound");
    _jump909:;
    // Computing bound for H
    _360.d1 = c;
    if (c > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= s;
    _361 *= c;
    _361 *= sizeof(bool);
    _360.data = jpl_alloc(_361);
    int64_t _362 = 0; // H
    int64_t _363 = 0; // G
    _jump911:; // Begin body of loop
    bool _364 = false;
    int64_t _365 = 0;
    _365 *= _360.d0;
    _365 += _363;
    _365 *= _360.d1;
    _365 += _362;
    _360.data[_365] = _364;
    _362++;
    if (_362 < c)
    goto _jump911;
    _362 = 0;
    _363++;
    if (_363 < s)
    goto _jump911;
    // End body of loop
    _353 = _360;
    _jump908:;
    if (t >= 0)
    goto _jump912;
    fail_assertion("negative array index");
    _jump912:;
    if (t < _353.d0)
    goto _jump913;
    fail_assertion("index too large");
    _jump913:;
    if (c >= 0)
    goto _jump914;
    fail_assertion("negative array index");
    _jump914:;
    if (c < _353.d1)
    goto _jump915;
    fail_assertion("index too large");
    _jump915:;
    int64_t _366 = 0;
    _366 *= _353.d0;
    _366 += t;
    _366 *= _353.d1;
    _366 += c;
    bool _367 = _353.data[_366];
    int64_t _368;
    if (!_367)
    goto _jump916;
    int64_t _369 = _168.d0 / i;
    _368 = _369;
    goto _jump917;
    _jump916:;
    _368 = b.d0;
    _jump917:;
    _351.d0 = _368;
    if (_368 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing total size of heap memory to allocate
    int64_t _370 = 1;
    _370 *= _368;
    _370 *= sizeof(int64_t);
    _351.data = jpl_alloc(_370);
    int64_t _371 = 0; // G
    _jump919:; // Begin body of loop
    int64_t _372 = 0;
    _372 *= _351.d0;
    _372 += _371;
    _351.data[_372] = _168.d1;
    _371++;
    if (_371 < _368)
    goto _jump919;
    // End body of loop
    int64_t _373 = 954;
    if (_373 >= 0)
    goto _jump920;
    fail_assertion("negative array index");
    _jump920:;
    if (_373 < _351.d0)
    goto _jump921;
    fail_assertion("index too large");
    _jump921:;
    int64_t _374 = 0;
    _374 *= _351.d0;
    _374 += _373;
    int64_t _375 = _351.data[_374];
    bool _376 = _375 <= b.d2;
    return _376;
}

_a3_void_t y(_a2_void_t z) {
    double _1;
    // Computing bound for C
    if (t > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    // Computing bound for D
    if (r > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for E
    if (q > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    _1 = 0;
    int64_t _2 = 0; // E
    int64_t _3 = 0; // D
    int64_t _4 = 0; // C
    _jump936:; // Begin body of loop
    _1 += o;
    _2++;
    if (_2 < q)
    goto _jump936;
    _2 = 0;
    _3++;
    if (_3 < r)
    goto _jump936;
    _3 = 0;
    _4++;
    if (_4 < t)
    goto _jump936;
    // End body of loop
    bool _5 = _1 <= a;
    double _6 = f(_5);
    double _7 = 97.0;
    bool _8 = _6 <= _7;
    bool _0 = _8;
    if (0 != _8)
    goto _jump937;
    bool _11 = true;
    bool _10 = _11;
    if (0 != _11)
    goto _jump938;
    bool _12 = false;
    bool _13 = !_12;
    _10 = _13;
    _jump938:;
    bool _9 = _10;
    if (0 != _10)
    goto _jump939;
    bool _14 = e < m;
    _9 = _14;
    _jump939:;
    _0 = _9;
    _jump937:;
    bool _15;
    if (!_0)
    goto _jump940;
    bool _16 = true;
    int64_t _17 = -i;
    bool _18 = _17 <= u;
    bool _19 = _16 == _18;
    rgba _20;
    if (!_19)
    goto _jump941;
    int64_t _21 = d - l;
    if (j >= 0)
    goto _jump942;
    fail_assertion("negative array index");
    _jump942:;
    if (j < k.d0)
    goto _jump943;
    fail_assertion("index too large");
    _jump943:;
    if (_21 >= 0)
    goto _jump944;
    fail_assertion("negative array index");
    _jump944:;
    if (_21 < k.d1)
    goto _jump945;
    fail_assertion("index too large");
    _jump945:;
    if (j >= 0)
    goto _jump946;
    fail_assertion("negative array index");
    _jump946:;
    if (j < k.d2)
    goto _jump947;
    fail_assertion("index too large");
    _jump947:;
    int64_t _22 = 0;
    _22 *= k.d0;
    _22 += j;
    _22 *= k.d1;
    _22 += _21;
    _22 *= k.d2;
    _22 += j;
    rgba _23 = k.data[_22];
    _20 = _23;
    goto _jump948;
    _jump941:;
    _a3__a3_rgba _24;
    // Computing bound for C
    _24.d0 = q;
    if (q > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    // Computing bound for D
    _24.d1 = t;
    if (t > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing bound for E
    int64_t _25 = 612;
    _24.d2 = _25;
    if (_25 > 0) 
    goto _jump951;
    fail_assertion("non-positive loop bound");
    _jump951:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= q;
    _26 *= t;
    _26 *= _25;
    _26 *= sizeof(_a3_rgba);
    _24.data = jpl_alloc(_26);
    int64_t _27 = 0; // E
    int64_t _28 = 0; // D
    int64_t _29 = 0; // C
    _jump952:; // Begin body of loop
    int64_t _30 = 0;
    _30 *= _24.d0;
    _30 += _29;
    _30 *= _24.d1;
    _30 += _28;
    _30 *= _24.d2;
    _30 += _27;
    _24.data[_30] = k;
    _27++;
    if (_27 < _25)
    goto _jump952;
    _27 = 0;
    _28++;
    if (_28 < t)
    goto _jump952;
    _28 = 0;
    _29++;
    if (_29 < q)
    goto _jump952;
    // End body of loop
    bool _31 = true;
    int64_t _32;
    if (!_31)
    goto _jump953;
    _32 = h;
    goto _jump954;
    _jump953:;
    _32 = c;
    _jump954:;
    int64_t _33 = 447;
    if (_32 >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (_32 < _24.d0)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    if (d >= 0)
    goto _jump957;
    fail_assertion("negative array index");
    _jump957:;
    if (d < _24.d1)
    goto _jump958;
    fail_assertion("index too large");
    _jump958:;
    if (_33 >= 0)
    goto _jump959;
    fail_assertion("negative array index");
    _jump959:;
    if (_33 < _24.d2)
    goto _jump960;
    fail_assertion("index too large");
    _jump960:;
    int64_t _34 = 0;
    _34 *= _24.d0;
    _34 += _32;
    _34 *= _24.d1;
    _34 += d;
    _34 *= _24.d2;
    _34 += _33;
    _a3_rgba _35 = _24.data[_34];
    int64_t _36;
    // Computing bound for C
    if (z.d0 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for D
    if (i > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing bound for E
    if (l > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    _36 = 0;
    int64_t _37 = 0; // E
    int64_t _38 = 0; // D
    int64_t _39 = 0; // C
    _jump964:; // Begin body of loop
    _36 += w;
    _37++;
    if (_37 < l)
    goto _jump964;
    _37 = 0;
    _38++;
    if (_38 < i)
    goto _jump964;
    _38 = 0;
    _39++;
    if (_39 < z.d0)
    goto _jump964;
    // End body of loop
    int64_t _40 = 848;
    int64_t _41 = _36 / _40;
    bool _42 = l == s;
    int64_t _43;
    if (!_42)
    goto _jump965;
    _43 = r;
    goto _jump966;
    _jump965:;
    _43 = s;
    _jump966:;
    if (_41 >= 0)
    goto _jump967;
    fail_assertion("negative array index");
    _jump967:;
    if (_41 < _35.d0)
    goto _jump968;
    fail_assertion("index too large");
    _jump968:;
    if (_43 >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (_43 < _35.d1)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    if (u >= 0)
    goto _jump971;
    fail_assertion("negative array index");
    _jump971:;
    if (u < _35.d2)
    goto _jump972;
    fail_assertion("index too large");
    _jump972:;
    int64_t _44 = 0;
    _44 *= _35.d0;
    _44 += _41;
    _44 *= _35.d1;
    _44 += _43;
    _44 *= _35.d2;
    _44 += u;
    rgba _45 = _35.data[_44];
    _20 = _45;
    _jump948:;
    bool _46 = v(_20);
    _15 = _46;
    goto _jump973;
    _jump940:;
    _a2_rgba _47;
    // Computing bound for C
    _47.d0 = i;
    if (i > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for D
    int64_t _48 = t + u;
    _47.d1 = _48;
    if (_48 > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= i;
    _49 *= _48;
    _49 *= sizeof(rgba);
    _47.data = jpl_alloc(_49);
    int64_t _50 = 0; // D
    int64_t _51 = 0; // C
    _jump976:; // Begin body of loop
    bool _52 = o <= x;
    rgba _53;
    if (!_52)
    goto _jump977;
    rgba _54 = { o, a, a, o };
    _53 = _54;
    goto _jump978;
    _jump977:;
    if (d >= 0)
    goto _jump979;
    fail_assertion("negative array index");
    _jump979:;
    if (d < k.d0)
    goto _jump980;
    fail_assertion("index too large");
    _jump980:;
    if (_51 >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (_51 < k.d1)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    if (l >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (l < k.d2)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    int64_t _55 = 0;
    _55 *= k.d0;
    _55 += d;
    _55 *= k.d1;
    _55 += _51;
    _55 *= k.d2;
    _55 += l;
    rgba _56 = k.data[_55];
    _53 = _56;
    _jump978:;
    int64_t _57 = 0;
    _57 *= _47.d0;
    _57 += _51;
    _57 *= _47.d1;
    _57 += _50;
    _47.data[_57] = _53;
    _50++;
    if (_50 < _48)
    goto _jump976;
    _50 = 0;
    _51++;
    if (_51 < i)
    goto _jump976;
    // End body of loop
    if (s >= 0)
    goto _jump985;
    fail_assertion("negative array index");
    _jump985:;
    if (s < _47.d0)
    goto _jump986;
    fail_assertion("index too large");
    _jump986:;
    if (e >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (e < _47.d1)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    int64_t _58 = 0;
    _58 *= _47.d0;
    _58 += s;
    _58 *= _47.d1;
    _58 += e;
    rgba _59 = _47.data[_58];
    bool _60 = v(_59);
    _15 = _60;
    _jump973:;
    double _61 = f(_15);
    double _62 = 40.0;
    _a3_void_t _63 = y(z);
    bool _65 = _61 != a;
    bool _66;
    if (!_65)
    goto _jump989;
    bool _67 = true;
    _66 = _67;
    goto _jump990;
    _jump989:;
    bool _68 = x > _62;
    _66 = _68;
    _jump990:;
    bool _64 = _66;
    if (0 == _66)
    goto _jump991;
    bool _69 = x != a;
    bool _70;
    if (!_69)
    goto _jump992;
    bool _71 = _61 <= _61;
    _70 = _71;
    goto _jump993;
    _jump992:;
    bool _72 = false;
    _70 = _72;
    _jump993:;
    _64 = _70;
    _jump991:;
    bool _73;
    if (!_64)
    goto _jump994;
    bool _74 = o > o;
    _73 = _74;
    goto _jump995;
    _jump994:;
    bool _76 = _63.d1 != c;
    bool _77 = !_76;
    bool _75 = _77;
    if (0 == _77)
    goto _jump996;
    bool _78 = true;
    _75 = _78;
    _jump996:;
    _73 = _75;
    _jump995:;
    _a3__a2_void_t _79;
    if (!_73)
    goto _jump997;
    _a3__a2_void_t _80;
    // Computing bound for K
    _80.d0 = t;
    if (t > 0) 
    goto _jump998;
    fail_assertion("non-positive loop bound");
    _jump998:;
    // Computing bound for L
    _80.d1 = i;
    if (i > 0) 
    goto _jump999;
    fail_assertion("non-positive loop bound");
    _jump999:;
    // Computing bound for M
    int64_t _81;
    // Computing bound for K
    if (c > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for L
    if (h > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    // Computing bound for M
    _a3_int64_t _82;
    // Computing bound for K
    _82.d0 = t;
    if (t > 0) 
    goto _jump1002;
    fail_assertion("non-positive loop bound");
    _jump1002:;
    // Computing bound for L
    _82.d1 = n;
    if (n > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    // Computing bound for M
    int64_t _83 = 327;
    _82.d2 = _83;
    if (_83 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= t;
    _84 *= n;
    _84 *= _83;
    _84 *= sizeof(int64_t);
    _82.data = jpl_alloc(_84);
    int64_t _85 = 0; // M
    int64_t _86 = 0; // L
    int64_t _87 = 0; // K
    _jump1005:; // Begin body of loop
    int64_t _88 = 0;
    _88 *= _82.d0;
    _88 += _87;
    _88 *= _82.d1;
    _88 += _86;
    _88 *= _82.d2;
    _88 += _85;
    _82.data[_88] = z.d1;
    _85++;
    if (_85 < _83)
    goto _jump1005;
    _85 = 0;
    _86++;
    if (_86 < n)
    goto _jump1005;
    _86 = 0;
    _87++;
    if (_87 < t)
    goto _jump1005;
    // End body of loop
    if (t >= 0)
    goto _jump1006;
    fail_assertion("negative array index");
    _jump1006:;
    if (t < _82.d0)
    goto _jump1007;
    fail_assertion("index too large");
    _jump1007:;
    if (z.d1 >= 0)
    goto _jump1008;
    fail_assertion("negative array index");
    _jump1008:;
    if (z.d1 < _82.d1)
    goto _jump1009;
    fail_assertion("index too large");
    _jump1009:;
    if (e >= 0)
    goto _jump1010;
    fail_assertion("negative array index");
    _jump1010:;
    if (e < _82.d2)
    goto _jump1011;
    fail_assertion("index too large");
    _jump1011:;
    int64_t _89 = 0;
    _89 *= _82.d0;
    _89 += t;
    _89 *= _82.d1;
    _89 += z.d1;
    _89 *= _82.d2;
    _89 += e;
    int64_t _90 = _82.data[_89];
    if (_90 > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    _81 = 0;
    int64_t _91 = 0; // M
    int64_t _92 = 0; // L
    int64_t _93 = 0; // K
    _jump1013:; // Begin body of loop
    _81 += u;
    _91++;
    if (_91 < _90)
    goto _jump1013;
    _91 = 0;
    _92++;
    if (_92 < h)
    goto _jump1013;
    _92 = 0;
    _93++;
    if (_93 < c)
    goto _jump1013;
    // End body of loop
    _80.d2 = _81;
    if (_81 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing total size of heap memory to allocate
    int64_t _94 = 1;
    _94 *= t;
    _94 *= i;
    _94 *= _81;
    _94 *= sizeof(_a2_void_t);
    _80.data = jpl_alloc(_94);
    int64_t _95 = 0; // M
    int64_t _96 = 0; // L
    int64_t _97 = 0; // K
    _jump1015:; // Begin body of loop
    rgba _98 = { a, _61, _61, o };
    bool _99 = v(_98);
    _a2_void_t _100;
    if (!_99)
    goto _jump1016;
    bool _101 = true;
    _a2_void_t _102;
    if (!_101)
    goto _jump1017;
    _102 = z;
    goto _jump1018;
    _jump1017:;
    _102 = z;
    _jump1018:;
    _100 = _102;
    goto _jump1019;
    _jump1016:;
    _a2_void_t _103;
    // Computing bound for N
    _103.d0 = z.d1;
    if (z.d1 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing bound for O
    _103.d1 = z.d1;
    if (z.d1 > 0) 
    goto _jump1021;
    fail_assertion("non-positive loop bound");
    _jump1021:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= z.d1;
    _104 *= z.d1;
    _104 *= sizeof(void_t);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // O
    int64_t _106 = 0; // N
    _jump1022:; // Begin body of loop
    if (c >= 0)
    goto _jump1023;
    fail_assertion("negative array index");
    _jump1023:;
    if (c < z.d0)
    goto _jump1024;
    fail_assertion("index too large");
    _jump1024:;
    if (z.d1 >= 0)
    goto _jump1025;
    fail_assertion("negative array index");
    _jump1025:;
    if (z.d1 < z.d1)
    goto _jump1026;
    fail_assertion("index too large");
    _jump1026:;
    int64_t _107 = 0;
    _107 *= z.d0;
    _107 += c;
    _107 *= z.d1;
    _107 += z.d1;
    void_t _108 = z.data[_107];
    int64_t _109 = 0;
    _109 *= _103.d0;
    _109 += _106;
    _109 *= _103.d1;
    _109 += _105;
    _103.data[_109] = _108;
    _105++;
    if (_105 < z.d1)
    goto _jump1022;
    _105 = 0;
    _106++;
    if (_106 < z.d1)
    goto _jump1022;
    // End body of loop
    _100 = _103;
    _jump1019:;
    int64_t _110 = 0;
    _110 *= _80.d0;
    _110 += _97;
    _110 *= _80.d1;
    _110 += _96;
    _110 *= _80.d2;
    _110 += _95;
    _80.data[_110] = _100;
    _95++;
    if (_95 < _81)
    goto _jump1015;
    _95 = 0;
    _96++;
    if (_96 < i)
    goto _jump1015;
    _96 = 0;
    _97++;
    if (_97 < t)
    goto _jump1015;
    // End body of loop
    _79 = _80;
    goto _jump1027;
    _jump997:;
    _a3__a2_void_t _111;
    // Computing bound for K
    int64_t _112;
    // Computing bound for K
    if (m > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing bound for L
    if (c > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    _112 = 0;
    int64_t _113 = 0; // L
    int64_t _114 = 0; // K
    _jump1030:; // Begin body of loop
    int64_t _115 = 170;
    _112 += _115;
    _113++;
    if (_113 < c)
    goto _jump1030;
    _113 = 0;
    _114++;
    if (_114 < m)
    goto _jump1030;
    // End body of loop
    _111.d0 = _112;
    if (_112 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    // Computing bound for L
    int64_t _116 = 114;
    _111.d1 = _116;
    if (_116 > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    // Computing bound for M
    _a2_int64_t _117;
    // Computing bound for K
    _117.d0 = c;
    if (c > 0) 
    goto _jump1033;
    fail_assertion("non-positive loop bound");
    _jump1033:;
    // Computing bound for L
    _117.d1 = _63.d2;
    if (_63.d2 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= c;
    _118 *= _63.d2;
    _118 *= sizeof(int64_t);
    _117.data = jpl_alloc(_118);
    int64_t _119 = 0; // L
    int64_t _120 = 0; // K
    _jump1035:; // Begin body of loop
    int64_t _121 = 0;
    _121 *= _117.d0;
    _121 += _120;
    _121 *= _117.d1;
    _121 += _119;
    _117.data[_121] = _119;
    _119++;
    if (_119 < _63.d2)
    goto _jump1035;
    _119 = 0;
    _120++;
    if (_120 < c)
    goto _jump1035;
    // End body of loop
    if (t >= 0)
    goto _jump1036;
    fail_assertion("negative array index");
    _jump1036:;
    if (t < _117.d0)
    goto _jump1037;
    fail_assertion("index too large");
    _jump1037:;
    if (z.d1 >= 0)
    goto _jump1038;
    fail_assertion("negative array index");
    _jump1038:;
    if (z.d1 < _117.d1)
    goto _jump1039;
    fail_assertion("index too large");
    _jump1039:;
    int64_t _122 = 0;
    _122 *= _117.d0;
    _122 += t;
    _122 *= _117.d1;
    _122 += z.d1;
    int64_t _123 = _117.data[_122];
    _111.d2 = _123;
    if (_123 > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _112;
    _124 *= _116;
    _124 *= _123;
    _124 *= sizeof(_a2_void_t);
    _111.data = jpl_alloc(_124);
    int64_t _125 = 0; // M
    int64_t _126 = 0; // L
    int64_t _127 = 0; // K
    _jump1041:; // Begin body of loop
    _a2_void_t _128;
    // Computing bound for N
    _128.d0 = r;
    if (r > 0) 
    goto _jump1042;
    fail_assertion("non-positive loop bound");
    _jump1042:;
    // Computing bound for O
    _128.d1 = m;
    if (m > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= r;
    _129 *= m;
    _129 *= sizeof(void_t);
    _128.data = jpl_alloc(_129);
    int64_t _130 = 0; // O
    int64_t _131 = 0; // N
    _jump1044:; // Begin body of loop
    if (u >= 0)
    goto _jump1045;
    fail_assertion("negative array index");
    _jump1045:;
    if (u < z.d0)
    goto _jump1046;
    fail_assertion("index too large");
    _jump1046:;
    if (_127 >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (_127 < z.d1)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    int64_t _132 = 0;
    _132 *= z.d0;
    _132 += u;
    _132 *= z.d1;
    _132 += _127;
    void_t _133 = z.data[_132];
    int64_t _134 = 0;
    _134 *= _128.d0;
    _134 += _131;
    _134 *= _128.d1;
    _134 += _130;
    _128.data[_134] = _133;
    _130++;
    if (_130 < m)
    goto _jump1044;
    _130 = 0;
    _131++;
    if (_131 < r)
    goto _jump1044;
    // End body of loop
    int64_t _135 = 0;
    _135 *= _111.d0;
    _135 += _127;
    _135 *= _111.d1;
    _135 += _126;
    _135 *= _111.d2;
    _135 += _125;
    _111.data[_135] = _128;
    _125++;
    if (_125 < _123)
    goto _jump1041;
    _125 = 0;
    _126++;
    if (_126 < _116)
    goto _jump1041;
    _126 = 0;
    _127++;
    if (_127 < _112)
    goto _jump1041;
    // End body of loop
    _79 = _111;
    _jump1027:;
    if (d >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (d < _79.d0)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    if (_63.d1 >= 0)
    goto _jump1051;
    fail_assertion("negative array index");
    _jump1051:;
    if (_63.d1 < _79.d1)
    goto _jump1052;
    fail_assertion("index too large");
    _jump1052:;
    if (_63.d2 >= 0)
    goto _jump1053;
    fail_assertion("negative array index");
    _jump1053:;
    if (_63.d2 < _79.d2)
    goto _jump1054;
    fail_assertion("index too large");
    _jump1054:;
    int64_t _136 = 0;
    _136 *= _79.d0;
    _136 += d;
    _136 *= _79.d1;
    _136 += _63.d1;
    _136 *= _79.d2;
    _136 += _63.d2;
    _a2_void_t _137 = _79.data[_136];
    _a3_void_t _138 = y(_137);
    return _138;
    _a3__a3_void_t _139;
    // Computing bound for K
    _139.d0 = w;
    if (w > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    // Computing bound for L
    int64_t _140 = s / q;
    _139.d1 = _140;
    if (_140 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    // Computing bound for M
    _139.d2 = z.d0;
    if (z.d0 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= w;
    _141 *= _140;
    _141 *= z.d0;
    _141 *= sizeof(_a3_void_t);
    _139.data = jpl_alloc(_141);
    int64_t _142 = 0; // M
    int64_t _143 = 0; // L
    int64_t _144 = 0; // K
    _jump1058:; // Begin body of loop
    _a3_void_t _145;
    // Computing bound for N
    _145.d0 = u;
    if (u > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing bound for O
    int64_t _146;
    // Computing bound for N
    if (_142 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing bound for O
    if (z.d1 > 0) 
    goto _jump1061;
    fail_assertion("non-positive loop bound");
    _jump1061:;
    _146 = 0;
    int64_t _147 = 0; // O
    int64_t _148 = 0; // N
    _jump1062:; // Begin body of loop
    _146 += n;
    _147++;
    if (_147 < z.d1)
    goto _jump1062;
    _147 = 0;
    _148++;
    if (_148 < _142)
    goto _jump1062;
    // End body of loop
    _145.d1 = _146;
    if (_146 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for P
    _145.d2 = j;
    if (j > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= u;
    _149 *= _146;
    _149 *= j;
    _149 *= sizeof(void_t);
    _145.data = jpl_alloc(_149);
    int64_t _150 = 0; // P
    int64_t _151 = 0; // O
    int64_t _152 = 0; // N
    _jump1065:; // Begin body of loop
    if (e >= 0)
    goto _jump1066;
    fail_assertion("negative array index");
    _jump1066:;
    if (e < z.d0)
    goto _jump1067;
    fail_assertion("index too large");
    _jump1067:;
    if (e >= 0)
    goto _jump1068;
    fail_assertion("negative array index");
    _jump1068:;
    if (e < z.d1)
    goto _jump1069;
    fail_assertion("index too large");
    _jump1069:;
    int64_t _153 = 0;
    _153 *= z.d0;
    _153 += e;
    _153 *= z.d1;
    _153 += e;
    void_t _154 = z.data[_153];
    int64_t _155 = 0;
    _155 *= _145.d0;
    _155 += _152;
    _155 *= _145.d1;
    _155 += _151;
    _155 *= _145.d2;
    _155 += _150;
    _145.data[_155] = _154;
    _150++;
    if (_150 < j)
    goto _jump1065;
    _150 = 0;
    _151++;
    if (_151 < _146)
    goto _jump1065;
    _151 = 0;
    _152++;
    if (_152 < u)
    goto _jump1065;
    // End body of loop
    int64_t _156 = 0;
    _156 *= _139.d0;
    _156 += _144;
    _156 *= _139.d1;
    _156 += _143;
    _156 *= _139.d2;
    _156 += _142;
    _139.data[_156] = _145;
    _142++;
    if (_142 < z.d0)
    goto _jump1058;
    _142 = 0;
    _143++;
    if (_143 < _140)
    goto _jump1058;
    _143 = 0;
    _144++;
    if (_144 < w)
    goto _jump1058;
    // End body of loop
    if (u >= 0)
    goto _jump1070;
    fail_assertion("negative array index");
    _jump1070:;
    if (u < _139.d0)
    goto _jump1071;
    fail_assertion("index too large");
    _jump1071:;
    if (m >= 0)
    goto _jump1072;
    fail_assertion("negative array index");
    _jump1072:;
    if (m < _139.d1)
    goto _jump1073;
    fail_assertion("index too large");
    _jump1073:;
    if (i >= 0)
    goto _jump1074;
    fail_assertion("negative array index");
    _jump1074:;
    if (i < _139.d2)
    goto _jump1075;
    fail_assertion("index too large");
    _jump1075:;
    int64_t _157 = 0;
    _157 *= _139.d0;
    _157 += u;
    _157 *= _139.d1;
    _157 += m;
    _157 *= _139.d2;
    _157 += i;
    _a3_void_t _158 = _139.data[_157];
    return _158;
}

rgba B(_a3_bool C) {
    bool _0 = u <= c;
    bool _1 = !_0;
    _a2__a3_int64_t _2;
    if (!_1)
    goto _jump1150;
    _a2__a3_int64_t _3;
    // Computing bound for G
    int64_t _4;
    // Computing bound for G
    if (C.d0 > 0) 
    goto _jump1151;
    fail_assertion("non-positive loop bound");
    _jump1151:;
    _4 = 0;
    int64_t _5 = 0; // G
    _jump1152:; // Begin body of loop
    _4 += e;
    _5++;
    if (_5 < C.d0)
    goto _jump1152;
    // End body of loop
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    // Computing bound for H
    _3.d1 = n;
    if (n > 0) 
    goto _jump1154;
    fail_assertion("non-positive loop bound");
    _jump1154:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _4;
    _6 *= n;
    _6 *= sizeof(_a3_int64_t);
    _3.data = jpl_alloc(_6);
    int64_t _7 = 0; // H
    int64_t _8 = 0; // G
    _jump1155:; // Begin body of loop
    int64_t _9 = 0;
    _9 *= _3.d0;
    _9 += _8;
    _9 *= _3.d1;
    _9 += _7;
    _3.data[_9] = p;
    _7++;
    if (_7 < n)
    goto _jump1155;
    _7 = 0;
    _8++;
    if (_8 < _4)
    goto _jump1155;
    // End body of loop
    _2 = _3;
    goto _jump1156;
    _jump1150:;
    _a2__a3_int64_t _10;
    // Computing bound for G
    bool _11 = x != x;
    _a1_int64_t _12;
    if (!_11)
    goto _jump1157;
    _a1_int64_t _13;
    _13.d0 = 3;
    _13.data = jpl_alloc(sizeof(int64_t) * 3);
    _13.data[0] = d;
    _13.data[1] = e;
    _13.data[2] = z;
    _12 = _13;
    goto _jump1158;
    _jump1157:;
    _a3__a1_int64_t _14;
    // Computing bound for G
    int64_t _15 = 119;
    _14.d0 = _15;
    if (_15 > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    // Computing bound for H
    _14.d1 = e;
    if (e > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing bound for I
    _14.d2 = j;
    if (j > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _15;
    _16 *= e;
    _16 *= j;
    _16 *= sizeof(_a1_int64_t);
    _14.data = jpl_alloc(_16);
    int64_t _17 = 0; // I
    int64_t _18 = 0; // H
    int64_t _19 = 0; // G
    _jump1162:; // Begin body of loop
    _a1_int64_t _20;
    // Computing bound for J
    _20.d0 = h;
    if (h > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= h;
    _21 *= sizeof(int64_t);
    _20.data = jpl_alloc(_21);
    int64_t _22 = 0; // J
    _jump1164:; // Begin body of loop
    int64_t _23 = 0;
    _23 *= _20.d0;
    _23 += _22;
    _20.data[_23] = _22;
    _22++;
    if (_22 < h)
    goto _jump1164;
    // End body of loop
    int64_t _24 = 0;
    _24 *= _14.d0;
    _24 += _19;
    _24 *= _14.d1;
    _24 += _18;
    _24 *= _14.d2;
    _24 += _17;
    _14.data[_24] = _20;
    _17++;
    if (_17 < j)
    goto _jump1162;
    _17 = 0;
    _18++;
    if (_18 < e)
    goto _jump1162;
    _18 = 0;
    _19++;
    if (_19 < _15)
    goto _jump1162;
    // End body of loop
    if (e >= 0)
    goto _jump1165;
    fail_assertion("negative array index");
    _jump1165:;
    if (e < _14.d0)
    goto _jump1166;
    fail_assertion("index too large");
    _jump1166:;
    if (e >= 0)
    goto _jump1167;
    fail_assertion("negative array index");
    _jump1167:;
    if (e < _14.d1)
    goto _jump1168;
    fail_assertion("index too large");
    _jump1168:;
    if (j >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (j < _14.d2)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    int64_t _25 = 0;
    _25 *= _14.d0;
    _25 += e;
    _25 *= _14.d1;
    _25 += e;
    _25 *= _14.d2;
    _25 += j;
    _a1_int64_t _26 = _14.data[_25];
    _12 = _26;
    _jump1158:;
    if (u >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (u < _12.d0)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    int64_t _27 = 0;
    _27 *= _12.d0;
    _27 += u;
    int64_t _28 = _12.data[_27];
    _10.d0 = _28;
    if (_28 > 0) 
    goto _jump1173;
    fail_assertion("non-positive loop bound");
    _jump1173:;
    // Computing bound for H
    int64_t _29 = 488;
    _10.d1 = _29;
    if (_29 > 0) 
    goto _jump1174;
    fail_assertion("non-positive loop bound");
    _jump1174:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _28;
    _30 *= _29;
    _30 *= sizeof(_a3_int64_t);
    _10.data = jpl_alloc(_30);
    int64_t _31 = 0; // H
    int64_t _32 = 0; // G
    _jump1175:; // Begin body of loop
    _a3_int64_t _33;
    // Computing bound for I
    _33.d0 = m;
    if (m > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing bound for J
    _33.d1 = i;
    if (i > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing bound for K
    _33.d2 = d;
    if (d > 0) 
    goto _jump1178;
    fail_assertion("non-positive loop bound");
    _jump1178:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= m;
    _34 *= i;
    _34 *= d;
    _34 *= sizeof(int64_t);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // K
    int64_t _36 = 0; // J
    int64_t _37 = 0; // I
    _jump1179:; // Begin body of loop
    int64_t _38 = 0;
    _38 *= _33.d0;
    _38 += _37;
    _38 *= _33.d1;
    _38 += _36;
    _38 *= _33.d2;
    _38 += _35;
    _33.data[_38] = _37;
    _35++;
    if (_35 < d)
    goto _jump1179;
    _35 = 0;
    _36++;
    if (_36 < i)
    goto _jump1179;
    _36 = 0;
    _37++;
    if (_37 < m)
    goto _jump1179;
    // End body of loop
    int64_t _39 = 0;
    _39 *= _10.d0;
    _39 += _32;
    _39 *= _10.d1;
    _39 += _31;
    _10.data[_39] = _33;
    _31++;
    if (_31 < _29)
    goto _jump1175;
    _31 = 0;
    _32++;
    if (_32 < _28)
    goto _jump1175;
    // End body of loop
    _2 = _10;
    _jump1156:;
    bool _40 = _2.d0 > d;
    if (0 != _40)
    goto _jump1180;
    fail_assertion("J");
    _jump1180:;
    int64_t _41;
    // Computing bound for K
    if (z > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    // Computing bound for L
    int64_t _42;
    // Computing bound for K
    if (C.d1 > 0) 
    goto _jump1182;
    fail_assertion("non-positive loop bound");
    _jump1182:;
    // Computing bound for L
    int64_t _43;
    // Computing bound for K
    if (n > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    _43 = 0;
    int64_t _44 = 0; // K
    _jump1184:; // Begin body of loop
    _43 += q;
    _44++;
    if (_44 < n)
    goto _jump1184;
    // End body of loop
    if (_43 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing bound for M
    int64_t _45 = 781;
    if (_45 > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    _42 = 0;
    int64_t _46 = 0; // M
    int64_t _47 = 0; // L
    int64_t _48 = 0; // K
    _jump1187:; // Begin body of loop
    _42 += j;
    _46++;
    if (_46 < _45)
    goto _jump1187;
    _46 = 0;
    _47++;
    if (_47 < _43)
    goto _jump1187;
    _47 = 0;
    _48++;
    if (_48 < C.d1)
    goto _jump1187;
    // End body of loop
    if (_42 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    _41 = 0;
    int64_t _49 = 0; // L
    int64_t _50 = 0; // K
    _jump1189:; // Begin body of loop
    _41 += C.d0;
    _49++;
    if (_49 < _42)
    goto _jump1189;
    _49 = 0;
    _50++;
    if (_50 < z)
    goto _jump1189;
    // End body of loop
    bool _52 = false;
    bool _51 = _52;
    if (0 == _52)
    goto _jump1190;
    bool _53 = t >= e;
    bool _54 = !_53;
    _51 = _54;
    _jump1190:;
    _a3__a3_int64_t _55;
    if (!_51)
    goto _jump1191;
    _a3__a3_int64_t _56;
    // Computing bound for L
    _56.d0 = C.d2;
    if (C.d2 > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    // Computing bound for M
    int64_t _57 = 829;
    _56.d1 = _57;
    if (_57 > 0) 
    goto _jump1193;
    fail_assertion("non-positive loop bound");
    _jump1193:;
    // Computing bound for N
    _56.d2 = l;
    if (l > 0) 
    goto _jump1194;
    fail_assertion("non-positive loop bound");
    _jump1194:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= C.d2;
    _58 *= _57;
    _58 *= l;
    _58 *= sizeof(_a3_int64_t);
    _56.data = jpl_alloc(_58);
    int64_t _59 = 0; // N
    int64_t _60 = 0; // M
    int64_t _61 = 0; // L
    _jump1195:; // Begin body of loop
    int64_t _62 = 0;
    _62 *= _56.d0;
    _62 += _61;
    _62 *= _56.d1;
    _62 += _60;
    _62 *= _56.d2;
    _62 += _59;
    _56.data[_62] = g;
    _59++;
    if (_59 < l)
    goto _jump1195;
    _59 = 0;
    _60++;
    if (_60 < _57)
    goto _jump1195;
    _60 = 0;
    _61++;
    if (_61 < C.d2)
    goto _jump1195;
    // End body of loop
    _55 = _56;
    goto _jump1196;
    _jump1191:;
    bool _63 = C.d1 >= d;
    _a3__a3_int64_t _64;
    if (!_63)
    goto _jump1197;
    _a3_rgba _66;
    // Computing bound for L
    _66.d0 = n;
    if (n > 0) 
    goto _jump1198;
    fail_assertion("non-positive loop bound");
    _jump1198:;
    // Computing bound for M
    _66.d1 = j;
    if (j > 0) 
    goto _jump1199;
    fail_assertion("non-positive loop bound");
    _jump1199:;
    // Computing bound for N
    _66.d2 = n;
    if (n > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= n;
    _67 *= j;
    _67 *= n;
    _67 *= sizeof(rgba);
    _66.data = jpl_alloc(_67);
    int64_t _68 = 0; // N
    int64_t _69 = 0; // M
    int64_t _70 = 0; // L
    _jump1201:; // Begin body of loop
    int64_t _71 = 0;
    _71 *= _66.d0;
    _71 += _70;
    _71 *= _66.d1;
    _71 += _69;
    _71 *= _66.d2;
    _71 += _68;
    _66.data[_71] = A;
    _68++;
    if (_68 < n)
    goto _jump1201;
    _68 = 0;
    _69++;
    if (_69 < j)
    goto _jump1201;
    _69 = 0;
    _70++;
    if (_70 < n)
    goto _jump1201;
    // End body of loop
    if (e >= 0)
    goto _jump1202;
    fail_assertion("negative array index");
    _jump1202:;
    if (e < _66.d0)
    goto _jump1203;
    fail_assertion("index too large");
    _jump1203:;
    if (r >= 0)
    goto _jump1204;
    fail_assertion("negative array index");
    _jump1204:;
    if (r < _66.d1)
    goto _jump1205;
    fail_assertion("index too large");
    _jump1205:;
    if (c >= 0)
    goto _jump1206;
    fail_assertion("negative array index");
    _jump1206:;
    if (c < _66.d2)
    goto _jump1207;
    fail_assertion("index too large");
    _jump1207:;
    int64_t _72 = 0;
    _72 *= _66.d0;
    _72 += e;
    _72 *= _66.d1;
    _72 += r;
    _72 *= _66.d2;
    _72 += c;
    rgba _73 = _66.data[_72];
    bool _74 = v(_73);
    bool _65 = _74;
    if (0 != _74)
    goto _jump1208;
    int64_t _75 = c - s;
    bool _76 = z > _75;
    bool _77;
    if (!_76)
    goto _jump1209;
    bool _79 = v(A);
    bool _78 = _79;
    if (0 != _79)
    goto _jump1210;
    bool _80 = i != i;
    _78 = _80;
    _jump1210:;
    _77 = _78;
    goto _jump1211;
    _jump1209:;
    bool _82 = true;
    bool _81 = _82;
    if (0 != _82)
    goto _jump1212;
    bool _83 = r == c;
    _81 = _83;
    _jump1212:;
    _77 = _81;
    _jump1211:;
    _65 = _77;
    _jump1208:;
    _a3__a3_int64_t _84;
    if (!_65)
    goto _jump1213;
    bool _85 = v(A);
    bool _86 = !_85;
    _a3__a3__a3_int64_t _87;
    if (!_86)
    goto _jump1214;
    _a3__a3__a3_int64_t _88;
    // Computing bound for L
    _88.d0 = m;
    if (m > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    // Computing bound for M
    _88.d1 = r;
    if (r > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing bound for N
    bool _89 = false;
    int64_t _90;
    if (!_89)
    goto _jump1217;
    _90 = u;
    goto _jump1218;
    _jump1217:;
    _90 = _41;
    _jump1218:;
    _88.d2 = _90;
    if (_90 > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= m;
    _91 *= r;
    _91 *= _90;
    _91 *= sizeof(_a3__a3_int64_t);
    _88.data = jpl_alloc(_91);
    int64_t _92 = 0; // N
    int64_t _93 = 0; // M
    int64_t _94 = 0; // L
    _jump1220:; // Begin body of loop
    _a3__a3_int64_t _95;
    // Computing bound for O
    _95.d0 = h;
    if (h > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing bound for P
    _95.d1 = r;
    if (r > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for Q
    _95.d2 = w;
    if (w > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= h;
    _96 *= r;
    _96 *= w;
    _96 *= sizeof(_a3_int64_t);
    _95.data = jpl_alloc(_96);
    int64_t _97 = 0; // Q
    int64_t _98 = 0; // P
    int64_t _99 = 0; // O
    _jump1224:; // Begin body of loop
    int64_t _100 = 0;
    _100 *= _95.d0;
    _100 += _99;
    _100 *= _95.d1;
    _100 += _98;
    _100 *= _95.d2;
    _100 += _97;
    _95.data[_100] = p;
    _97++;
    if (_97 < w)
    goto _jump1224;
    _97 = 0;
    _98++;
    if (_98 < r)
    goto _jump1224;
    _98 = 0;
    _99++;
    if (_99 < h)
    goto _jump1224;
    // End body of loop
    int64_t _101 = 0;
    _101 *= _88.d0;
    _101 += _94;
    _101 *= _88.d1;
    _101 += _93;
    _101 *= _88.d2;
    _101 += _92;
    _88.data[_101] = _95;
    _92++;
    if (_92 < _90)
    goto _jump1220;
    _92 = 0;
    _93++;
    if (_93 < r)
    goto _jump1220;
    _93 = 0;
    _94++;
    if (_94 < m)
    goto _jump1220;
    // End body of loop
    _87 = _88;
    goto _jump1225;
    _jump1214:;
    _a3__a3__a3_int64_t _102;
    // Computing bound for L
    _102.d0 = j;
    if (j > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for M
    _102.d1 = C.d1;
    if (C.d1 > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing bound for N
    _102.d2 = i;
    if (i > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= j;
    _103 *= C.d1;
    _103 *= i;
    _103 *= sizeof(_a3__a3_int64_t);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // N
    int64_t _105 = 0; // M
    int64_t _106 = 0; // L
    _jump1229:; // Begin body of loop
    _a3__a3_int64_t _107;
    // Computing bound for O
    _107.d0 = m;
    if (m > 0) 
    goto _jump1230;
    fail_assertion("non-positive loop bound");
    _jump1230:;
    // Computing bound for P
    _107.d1 = s;
    if (s > 0) 
    goto _jump1231;
    fail_assertion("non-positive loop bound");
    _jump1231:;
    // Computing bound for Q
    _107.d2 = _104;
    if (_104 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= m;
    _108 *= s;
    _108 *= _104;
    _108 *= sizeof(_a3_int64_t);
    _107.data = jpl_alloc(_108);
    int64_t _109 = 0; // Q
    int64_t _110 = 0; // P
    int64_t _111 = 0; // O
    _jump1233:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _107.d0;
    _112 += _111;
    _112 *= _107.d1;
    _112 += _110;
    _112 *= _107.d2;
    _112 += _109;
    _107.data[_112] = g;
    _109++;
    if (_109 < _104)
    goto _jump1233;
    _109 = 0;
    _110++;
    if (_110 < s)
    goto _jump1233;
    _110 = 0;
    _111++;
    if (_111 < m)
    goto _jump1233;
    // End body of loop
    int64_t _113 = 0;
    _113 *= _102.d0;
    _113 += _106;
    _113 *= _102.d1;
    _113 += _105;
    _113 *= _102.d2;
    _113 += _104;
    _102.data[_113] = _107;
    _104++;
    if (_104 < i)
    goto _jump1229;
    _104 = 0;
    _105++;
    if (_105 < C.d1)
    goto _jump1229;
    _105 = 0;
    _106++;
    if (_106 < j)
    goto _jump1229;
    // End body of loop
    _87 = _102;
    _jump1225:;
    int64_t _114 = 991;
    if (_2.d1 >= 0)
    goto _jump1234;
    fail_assertion("negative array index");
    _jump1234:;
    if (_2.d1 < _87.d0)
    goto _jump1235;
    fail_assertion("index too large");
    _jump1235:;
    if (C.d1 >= 0)
    goto _jump1236;
    fail_assertion("negative array index");
    _jump1236:;
    if (C.d1 < _87.d1)
    goto _jump1237;
    fail_assertion("index too large");
    _jump1237:;
    if (_114 >= 0)
    goto _jump1238;
    fail_assertion("negative array index");
    _jump1238:;
    if (_114 < _87.d2)
    goto _jump1239;
    fail_assertion("index too large");
    _jump1239:;
    int64_t _115 = 0;
    _115 *= _87.d0;
    _115 += _2.d1;
    _115 *= _87.d1;
    _115 += C.d1;
    _115 *= _87.d2;
    _115 += _114;
    _a3__a3_int64_t _116 = _87.data[_115];
    _84 = _116;
    goto _jump1240;
    _jump1213:;
    _a3__a3_int64_t _117;
    // Computing bound for L
    _117.d0 = h;
    if (h > 0) 
    goto _jump1241;
    fail_assertion("non-positive loop bound");
    _jump1241:;
    // Computing bound for M
    bool _118 = true;
    _a1_int64_t _119;
    if (!_118)
    goto _jump1242;
    _a1_int64_t _120;
    _120.d0 = 1;
    _120.data = jpl_alloc(sizeof(int64_t) * 1);
    _120.data[0] = t;
    _119 = _120;
    goto _jump1243;
    _jump1242:;
    _a1_int64_t _121;
    // Computing bound for L
    _121.d0 = l;
    if (l > 0) 
    goto _jump1244;
    fail_assertion("non-positive loop bound");
    _jump1244:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= l;
    _122 *= sizeof(int64_t);
    _121.data = jpl_alloc(_122);
    int64_t _123 = 0; // L
    _jump1245:; // Begin body of loop
    int64_t _124 = 0;
    _124 *= _121.d0;
    _124 += _123;
    _121.data[_124] = C.d0;
    _123++;
    if (_123 < l)
    goto _jump1245;
    // End body of loop
    _119 = _121;
    _jump1243:;
    if (u >= 0)
    goto _jump1246;
    fail_assertion("negative array index");
    _jump1246:;
    if (u < _119.d0)
    goto _jump1247;
    fail_assertion("index too large");
    _jump1247:;
    int64_t _125 = 0;
    _125 *= _119.d0;
    _125 += u;
    int64_t _126 = _119.data[_125];
    _117.d1 = _126;
    if (_126 > 0) 
    goto _jump1248;
    fail_assertion("non-positive loop bound");
    _jump1248:;
    // Computing bound for N
    _117.d2 = d;
    if (d > 0) 
    goto _jump1249;
    fail_assertion("non-positive loop bound");
    _jump1249:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= h;
    _127 *= _126;
    _127 *= d;
    _127 *= sizeof(_a3_int64_t);
    _117.data = jpl_alloc(_127);
    int64_t _128 = 0; // N
    int64_t _129 = 0; // M
    int64_t _130 = 0; // L
    _jump1250:; // Begin body of loop
    bool _131 = true;
    int64_t _132;
    if (!_131)
    goto _jump1251;
    _132 = j;
    goto _jump1252;
    _jump1251:;
    _132 = t;
    _jump1252:;
    bool _133 = _132 >= C.d1;
    _a3_int64_t _134;
    if (!_133)
    goto _jump1253;
    _134 = b;
    goto _jump1254;
    _jump1253:;
    _a3_int64_t _135;
    // Computing bound for O
    _135.d0 = l;
    if (l > 0) 
    goto _jump1255;
    fail_assertion("non-positive loop bound");
    _jump1255:;
    // Computing bound for P
    _135.d1 = u;
    if (u > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    // Computing bound for Q
    int64_t _136;
    // Computing bound for O
    if (_128 > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    // Computing bound for P
    if (C.d1 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    _136 = 0;
    int64_t _137 = 0; // P
    int64_t _138 = 0; // O
    _jump1259:; // Begin body of loop
    _136 += u;
    _137++;
    if (_137 < C.d1)
    goto _jump1259;
    _137 = 0;
    _138++;
    if (_138 < _128)
    goto _jump1259;
    // End body of loop
    _135.d2 = _136;
    if (_136 > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= l;
    _139 *= u;
    _139 *= _136;
    _139 *= sizeof(int64_t);
    _135.data = jpl_alloc(_139);
    int64_t _140 = 0; // Q
    int64_t _141 = 0; // P
    int64_t _142 = 0; // O
    _jump1261:; // Begin body of loop
    int64_t _143 = 0;
    _143 *= _135.d0;
    _143 += _142;
    _143 *= _135.d1;
    _143 += _141;
    _143 *= _135.d2;
    _143 += _140;
    _135.data[_143] = _142;
    _140++;
    if (_140 < _136)
    goto _jump1261;
    _140 = 0;
    _141++;
    if (_141 < u)
    goto _jump1261;
    _141 = 0;
    _142++;
    if (_142 < l)
    goto _jump1261;
    // End body of loop
    _134 = _135;
    _jump1254:;
    int64_t _144 = 0;
    _144 *= _117.d0;
    _144 += _130;
    _144 *= _117.d1;
    _144 += _129;
    _144 *= _117.d2;
    _144 += _128;
    _117.data[_144] = _134;
    _128++;
    if (_128 < d)
    goto _jump1250;
    _128 = 0;
    _129++;
    if (_129 < _126)
    goto _jump1250;
    _129 = 0;
    _130++;
    if (_130 < h)
    goto _jump1250;
    // End body of loop
    _84 = _117;
    _jump1240:;
    _64 = _84;
    goto _jump1262;
    _jump1197:;
    _a3__a3_int64_t _145;
    // Computing bound for L
    _145.d0 = d;
    if (d > 0) 
    goto _jump1263;
    fail_assertion("non-positive loop bound");
    _jump1263:;
    // Computing bound for M
    _145.d1 = q;
    if (q > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing bound for N
    _145.d2 = j;
    if (j > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= d;
    _146 *= q;
    _146 *= j;
    _146 *= sizeof(_a3_int64_t);
    _145.data = jpl_alloc(_146);
    int64_t _147 = 0; // N
    int64_t _148 = 0; // M
    int64_t _149 = 0; // L
    _jump1266:; // Begin body of loop
    double _151 = -a;
    double _152 = fmod(o, o);
    bool _153 = _151 == _152;
    bool _150 = _153;
    if (0 != _153)
    goto _jump1267;
    if (_2.d1 >= 0)
    goto _jump1268;
    fail_assertion("negative array index");
    _jump1268:;
    if (_2.d1 < C.d0)
    goto _jump1269;
    fail_assertion("index too large");
    _jump1269:;
    if (w >= 0)
    goto _jump1270;
    fail_assertion("negative array index");
    _jump1270:;
    if (w < C.d1)
    goto _jump1271;
    fail_assertion("index too large");
    _jump1271:;
    if (_2.d1 >= 0)
    goto _jump1272;
    fail_assertion("negative array index");
    _jump1272:;
    if (_2.d1 < C.d2)
    goto _jump1273;
    fail_assertion("index too large");
    _jump1273:;
    int64_t _154 = 0;
    _154 *= C.d0;
    _154 += _2.d1;
    _154 *= C.d1;
    _154 += w;
    _154 *= C.d2;
    _154 += _2.d1;
    bool _155 = C.data[_154];
    bool _156 = !_155;
    _150 = _156;
    _jump1267:;
    _a3_int64_t _157;
    if (!_150)
    goto _jump1274;
    _157 = b;
    goto _jump1275;
    _jump1274:;
    bool _158 = false;
    _a3__a3_int64_t _159;
    if (!_158)
    goto _jump1276;
    _a3__a3_int64_t _160;
    // Computing bound for O
    _160.d0 = _41;
    if (_41 > 0) 
    goto _jump1277;
    fail_assertion("non-positive loop bound");
    _jump1277:;
    // Computing bound for P
    _160.d1 = s;
    if (s > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing bound for Q
    _160.d2 = w;
    if (w > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing total size of heap memory to allocate
    int64_t _161 = 1;
    _161 *= _41;
    _161 *= s;
    _161 *= w;
    _161 *= sizeof(_a3_int64_t);
    _160.data = jpl_alloc(_161);
    int64_t _162 = 0; // Q
    int64_t _163 = 0; // P
    int64_t _164 = 0; // O
    _jump1280:; // Begin body of loop
    int64_t _165 = 0;
    _165 *= _160.d0;
    _165 += _164;
    _165 *= _160.d1;
    _165 += _163;
    _165 *= _160.d2;
    _165 += _162;
    _160.data[_165] = p;
    _162++;
    if (_162 < w)
    goto _jump1280;
    _162 = 0;
    _163++;
    if (_163 < s)
    goto _jump1280;
    _163 = 0;
    _164++;
    if (_164 < _41)
    goto _jump1280;
    // End body of loop
    _159 = _160;
    goto _jump1281;
    _jump1276:;
    _a3__a3_int64_t _166;
    // Computing bound for O
    _166.d0 = c;
    if (c > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing bound for P
    _166.d1 = q;
    if (q > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for Q
    _166.d2 = t;
    if (t > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= c;
    _167 *= q;
    _167 *= t;
    _167 *= sizeof(_a3_int64_t);
    _166.data = jpl_alloc(_167);
    int64_t _168 = 0; // Q
    int64_t _169 = 0; // P
    int64_t _170 = 0; // O
    _jump1285:; // Begin body of loop
    int64_t _171 = 0;
    _171 *= _166.d0;
    _171 += _170;
    _171 *= _166.d1;
    _171 += _169;
    _171 *= _166.d2;
    _171 += _168;
    _166.data[_171] = b;
    _168++;
    if (_168 < t)
    goto _jump1285;
    _168 = 0;
    _169++;
    if (_169 < q)
    goto _jump1285;
    _169 = 0;
    _170++;
    if (_170 < c)
    goto _jump1285;
    // End body of loop
    _159 = _166;
    _jump1281:;
    if (t >= 0)
    goto _jump1286;
    fail_assertion("negative array index");
    _jump1286:;
    if (t < _159.d0)
    goto _jump1287;
    fail_assertion("index too large");
    _jump1287:;
    if (_2.d1 >= 0)
    goto _jump1288;
    fail_assertion("negative array index");
    _jump1288:;
    if (_2.d1 < _159.d1)
    goto _jump1289;
    fail_assertion("index too large");
    _jump1289:;
    if (_148 >= 0)
    goto _jump1290;
    fail_assertion("negative array index");
    _jump1290:;
    if (_148 < _159.d2)
    goto _jump1291;
    fail_assertion("index too large");
    _jump1291:;
    int64_t _172 = 0;
    _172 *= _159.d0;
    _172 += t;
    _172 *= _159.d1;
    _172 += _2.d1;
    _172 *= _159.d2;
    _172 += _148;
    _a3_int64_t _173 = _159.data[_172];
    _157 = _173;
    _jump1275:;
    int64_t _174 = 0;
    _174 *= _145.d0;
    _174 += _149;
    _174 *= _145.d1;
    _174 += _148;
    _174 *= _145.d2;
    _174 += _147;
    _145.data[_174] = _157;
    _147++;
    if (_147 < j)
    goto _jump1266;
    _147 = 0;
    _148++;
    if (_148 < q)
    goto _jump1266;
    _148 = 0;
    _149++;
    if (_149 < d)
    goto _jump1266;
    // End body of loop
    _64 = _145;
    _jump1262:;
    _55 = _64;
    _jump1196:;
    rgba _175 = B(C);
    return _175;
}

_a1_void_t F() {
    bool _0 = false;
    bool _1 = !_0;
    _a1__a1_void_t _2;
    if (!_1)
    goto _jump1336;
    _a1__a1_void_t _3;
    // Computing bound for G
    _3.d0 = t;
    if (t > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    // Computing total size of heap memory to allocate
    int64_t _4 = 1;
    _4 *= t;
    _4 *= sizeof(_a1_void_t);
    _3.data = jpl_alloc(_4);
    int64_t _5 = 0; // G
    _jump1338:; // Begin body of loop
    bool _6 = o >= o;
    _a1_void_t _7;
    if (!_6)
    goto _jump1339;
    _a1_void_t _8 = F();
    _7 = _8;
    goto _jump1340;
    _jump1339:;
    _a1_void_t _9 = F();
    _7 = _9;
    _jump1340:;
    int64_t _10 = 0;
    _10 *= _3.d0;
    _10 += _5;
    _3.data[_10] = _7;
    _5++;
    if (_5 < t)
    goto _jump1338;
    // End body of loop
    if (l >= 0)
    goto _jump1341;
    fail_assertion("negative array index");
    _jump1341:;
    if (l < _3.d0)
    goto _jump1342;
    fail_assertion("index too large");
    _jump1342:;
    int64_t _11 = 0;
    _11 *= _3.d0;
    _11 += l;
    _a1_void_t _12 = _3.data[_11];
    _a1__a1_void_t _13;
    _13.d0 = 1;
    _13.data = jpl_alloc(sizeof(_a1_void_t) * 1);
    _13.data[0] = _12;
    _2 = _13;
    goto _jump1343;
    _jump1336:;
    bool _14 = a == x;
    _a1_bool _15;
    if (!_14)
    goto _jump1344;
    _a1_bool _16;
    // Computing bound for G
    int64_t _17;
    // Computing bound for G
    if (s > 0) 
    goto _jump1345;
    fail_assertion("non-positive loop bound");
    _jump1345:;
    // Computing bound for H
    if (D > 0) 
    goto _jump1346;
    fail_assertion("non-positive loop bound");
    _jump1346:;
    // Computing bound for I
    if (u > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    _17 = 0;
    int64_t _18 = 0; // I
    int64_t _19 = 0; // H
    int64_t _20 = 0; // G
    _jump1348:; // Begin body of loop
    _17 += m;
    _18++;
    if (_18 < u)
    goto _jump1348;
    _18 = 0;
    _19++;
    if (_19 < D)
    goto _jump1348;
    _19 = 0;
    _20++;
    if (_20 < s)
    goto _jump1348;
    // End body of loop
    _16.d0 = _17;
    if (_17 > 0) 
    goto _jump1349;
    fail_assertion("non-positive loop bound");
    _jump1349:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= _17;
    _21 *= sizeof(bool);
    _16.data = jpl_alloc(_21);
    int64_t _22 = 0; // G
    _jump1350:; // Begin body of loop
    bool _23 = false;
    int64_t _24 = 0;
    _24 *= _16.d0;
    _24 += _22;
    _16.data[_24] = _23;
    _22++;
    if (_22 < _17)
    goto _jump1350;
    // End body of loop
    _15 = _16;
    goto _jump1351;
    _jump1344:;
    _a1_bool _25;
    // Computing bound for G
    _25.d0 = E;
    if (E > 0) 
    goto _jump1352;
    fail_assertion("non-positive loop bound");
    _jump1352:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= E;
    _26 *= sizeof(bool);
    _25.data = jpl_alloc(_26);
    int64_t _27 = 0; // G
    _jump1353:; // Begin body of loop
    bool _28 = D > q;
    int64_t _29 = 0;
    _29 *= _25.d0;
    _29 += _27;
    _25.data[_29] = _28;
    _27++;
    if (_27 < E)
    goto _jump1353;
    // End body of loop
    _15 = _25;
    _jump1351:;
    if (t >= 0)
    goto _jump1354;
    fail_assertion("negative array index");
    _jump1354:;
    if (t < _15.d0)
    goto _jump1355;
    fail_assertion("index too large");
    _jump1355:;
    int64_t _30 = 0;
    _30 *= _15.d0;
    _30 += t;
    bool _31 = _15.data[_30];
    _a1__a1_void_t _32;
    if (!_31)
    goto _jump1356;
    _a1__a1__a1_void_t _33;
    // Computing bound for G
    _33.d0 = m;
    if (m > 0) 
    goto _jump1357;
    fail_assertion("non-positive loop bound");
    _jump1357:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= m;
    _34 *= sizeof(_a1__a1_void_t);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // G
    _jump1358:; // Begin body of loop
    _a1_void_t _36 = F();
    _a1__a1_void_t _37;
    _37.d0 = 1;
    _37.data = jpl_alloc(sizeof(_a1_void_t) * 1);
    _37.data[0] = _36;
    int64_t _38 = 0;
    _38 *= _33.d0;
    _38 += _35;
    _33.data[_38] = _37;
    _35++;
    if (_35 < m)
    goto _jump1358;
    // End body of loop
    if (i >= 0)
    goto _jump1359;
    fail_assertion("negative array index");
    _jump1359:;
    if (i < _33.d0)
    goto _jump1360;
    fail_assertion("index too large");
    _jump1360:;
    int64_t _39 = 0;
    _39 *= _33.d0;
    _39 += i;
    _a1__a1_void_t _40 = _33.data[_39];
    _32 = _40;
    goto _jump1361;
    _jump1356:;
    _a1__a1__a1_void_t _41;
    // Computing bound for G
    _41.d0 = n;
    if (n > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= n;
    _42 *= sizeof(_a1__a1_void_t);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // G
    _jump1363:; // Begin body of loop
    bool _44 = x != o;
    _a1__a1_void_t _45;
    if (!_44)
    goto _jump1364;
    _a1__a1_void_t _46;
    // Computing bound for H
    _46.d0 = z;
    if (z > 0) 
    goto _jump1365;
    fail_assertion("non-positive loop bound");
    _jump1365:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= z;
    _47 *= sizeof(_a1_void_t);
    _46.data = jpl_alloc(_47);
    int64_t _48 = 0; // H
    _jump1366:; // Begin body of loop
    _a1_void_t _49 = F();
    int64_t _50 = 0;
    _50 *= _46.d0;
    _50 += _48;
    _46.data[_50] = _49;
    _48++;
    if (_48 < z)
    goto _jump1366;
    // End body of loop
    _45 = _46;
    goto _jump1367;
    _jump1364:;
    _a1_void_t _51 = F();
    _a1_void_t _52 = F();
    _a1_void_t _53 = F();
    _a1__a1_void_t _54;
    _54.d0 = 3;
    _54.data = jpl_alloc(sizeof(_a1_void_t) * 3);
    _54.data[0] = _51;
    _54.data[1] = _52;
    _54.data[2] = _53;
    _45 = _54;
    _jump1367:;
    int64_t _55 = 0;
    _55 *= _41.d0;
    _55 += _43;
    _41.data[_55] = _45;
    _43++;
    if (_43 < n)
    goto _jump1363;
    // End body of loop
    int64_t _57 = 147;
    bool _58 = l == _57;
    bool _56 = _58;
    if (0 == _58)
    goto _jump1368;
    bool _59 = v(A);
    _56 = _59;
    _jump1368:;
    int64_t _60;
    if (!_56)
    goto _jump1369;
    int64_t _61;
    // Computing bound for G
    if (d > 0) 
    goto _jump1370;
    fail_assertion("non-positive loop bound");
    _jump1370:;
    // Computing bound for H
    int64_t _62 = 665;
    if (_62 > 0) 
    goto _jump1371;
    fail_assertion("non-positive loop bound");
    _jump1371:;
    // Computing bound for I
    int64_t _63;
    // Computing bound for G
    if (w > 0) 
    goto _jump1372;
    fail_assertion("non-positive loop bound");
    _jump1372:;
    _63 = 0;
    int64_t _64 = 0; // G
    _jump1373:; // Begin body of loop
    _63 += m;
    _64++;
    if (_64 < w)
    goto _jump1373;
    // End body of loop
    if (_63 > 0) 
    goto _jump1374;
    fail_assertion("non-positive loop bound");
    _jump1374:;
    _61 = 0;
    int64_t _65 = 0; // I
    int64_t _66 = 0; // H
    int64_t _67 = 0; // G
    _jump1375:; // Begin body of loop
    _61 += e;
    _65++;
    if (_65 < _63)
    goto _jump1375;
    _65 = 0;
    _66++;
    if (_66 < _62)
    goto _jump1375;
    _66 = 0;
    _67++;
    if (_67 < d)
    goto _jump1375;
    // End body of loop
    _60 = _61;
    goto _jump1376;
    _jump1369:;
    _60 = w;
    _jump1376:;
    if (_60 >= 0)
    goto _jump1377;
    fail_assertion("negative array index");
    _jump1377:;
    if (_60 < _41.d0)
    goto _jump1378;
    fail_assertion("index too large");
    _jump1378:;
    int64_t _68 = 0;
    _68 *= _41.d0;
    _68 += _60;
    _a1__a1_void_t _69 = _41.data[_68];
    _32 = _69;
    _jump1361:;
    _2 = _32;
    _jump1343:;
    if (z >= 0)
    goto _jump1379;
    fail_assertion("negative array index");
    _jump1379:;
    if (z < _2.d0)
    goto _jump1380;
    fail_assertion("index too large");
    _jump1380:;
    int64_t _70 = 0;
    _70 *= _2.d0;
    _70 += z;
    _a1_void_t _71 = _2.data[_70];
    return _71;
    bool _73 = v(A);
    bool _72 = _73;
    if (0 != _73)
    goto _jump1381;
    bool _75 = D != i;
    bool _74 = _75;
    if (0 != _75)
    goto _jump1382;
    bool _77 = true;
    bool _78 = !_77;
    bool _76 = _78;
    if (0 != _78)
    goto _jump1383;
    int64_t _79 = 851;
    int64_t _80 = -_79;
    bool _81 = _80 != e;
    _76 = _81;
    _jump1383:;
    _74 = _76;
    _jump1382:;
    _72 = _74;
    _jump1381:;
    _a2_int64_t _82;
    if (!_72)
    goto _jump1384;
    double _83;
    // Computing bound for G
    if (n > 0) 
    goto _jump1385;
    fail_assertion("non-positive loop bound");
    _jump1385:;
    // Computing bound for H
    if (u > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing bound for I
    if (m > 0) 
    goto _jump1387;
    fail_assertion("non-positive loop bound");
    _jump1387:;
    _83 = 0;
    int64_t _84 = 0; // I
    int64_t _85 = 0; // H
    int64_t _86 = 0; // G
    _jump1388:; // Begin body of loop
    _83 += o;
    _84++;
    if (_84 < m)
    goto _jump1388;
    _84 = 0;
    _85++;
    if (_85 < u)
    goto _jump1388;
    _85 = 0;
    _86++;
    if (_86 < n)
    goto _jump1388;
    // End body of loop
    double _87 = 42.0;
    bool _88 = _83 >= _87;
    bool _89 = !_88;
    _a2_int64_t _90;
    if (!_89)
    goto _jump1389;
    _a2_int64_t _91;
    // Computing bound for G
    _91.d0 = i;
    if (i > 0) 
    goto _jump1390;
    fail_assertion("non-positive loop bound");
    _jump1390:;
    // Computing bound for H
    _91.d1 = m;
    if (m > 0) 
    goto _jump1391;
    fail_assertion("non-positive loop bound");
    _jump1391:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= i;
    _92 *= m;
    _92 *= sizeof(int64_t);
    _91.data = jpl_alloc(_92);
    int64_t _93 = 0; // H
    int64_t _94 = 0; // G
    _jump1392:; // Begin body of loop
    int64_t _95 = 0;
    _95 *= _91.d0;
    _95 += _94;
    _95 *= _91.d1;
    _95 += _93;
    _91.data[_95] = E;
    _93++;
    if (_93 < m)
    goto _jump1392;
    _93 = 0;
    _94++;
    if (_94 < i)
    goto _jump1392;
    // End body of loop
    _90 = _91;
    goto _jump1393;
    _jump1389:;
    _a1__a2_int64_t _96;
    _96.d0 = 2;
    _96.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _96.data[0] = C;
    _96.data[1] = C;
    int64_t _97;
    // Computing bound for G
    if (n > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    _97 = 0;
    int64_t _98 = 0; // G
    _jump1395:; // Begin body of loop
    _97 += E;
    _98++;
    if (_98 < n)
    goto _jump1395;
    // End body of loop
    if (_97 >= 0)
    goto _jump1396;
    fail_assertion("negative array index");
    _jump1396:;
    if (_97 < _96.d0)
    goto _jump1397;
    fail_assertion("index too large");
    _jump1397:;
    int64_t _99 = 0;
    _99 *= _96.d0;
    _99 += _97;
    _a2_int64_t _100 = _96.data[_99];
    _90 = _100;
    _jump1393:;
    _82 = _90;
    goto _jump1398;
    _jump1384:;
    _a2_int64_t _101;
    // Computing bound for G
    int64_t _102 = 654;
    _101.d0 = _102;
    if (_102 > 0) 
    goto _jump1399;
    fail_assertion("non-positive loop bound");
    _jump1399:;
    // Computing bound for H
    _101.d1 = s;
    if (s > 0) 
    goto _jump1400;
    fail_assertion("non-positive loop bound");
    _jump1400:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= _102;
    _103 *= s;
    _103 *= sizeof(int64_t);
    _101.data = jpl_alloc(_103);
    int64_t _104 = 0; // H
    int64_t _105 = 0; // G
    _jump1401:; // Begin body of loop
    int64_t _106 = 0;
    _106 *= _101.d0;
    _106 += _105;
    _106 *= _101.d1;
    _106 += _104;
    _101.data[_106] = l;
    _104++;
    if (_104 < s)
    goto _jump1401;
    _104 = 0;
    _105++;
    if (_105 < _102)
    goto _jump1401;
    // End body of loop
    _82 = _101;
    _jump1398:;
    bool _108 = true;
    bool _109 = !_108;
    bool _107 = _109;
    if (0 != _109)
    goto _jump1402;
    bool _110 = v(A);
    _107 = _110;
    _jump1402:;
    bool _111 = j >= i;
    bool _112 = !_111;
    bool _113 = _107 == _112;
    bool _114 = !_113;
    bool _115 = !_114;
    _a2__a1_void_t _116;
    if (!_115)
    goto _jump1403;
    bool _117 = false;
    _a2__a1_void_t _118;
    if (!_117)
    goto _jump1404;
    bool _119 = true;
    bool _120;
    if (!_119)
    goto _jump1405;
    bool _121 = true;
    bool _122 = !_121;
    _120 = _122;
    goto _jump1406;
    _jump1405:;
    bool _123 = true;
    bool _124 = !_123;
    bool _125 = !_124;
    _120 = _125;
    _jump1406:;
    _a2__a1_void_t _126;
    if (!_120)
    goto _jump1407;
    bool _128 = false;
    bool _129 = !_128;
    bool _127 = _129;
    if (0 == _129)
    goto _jump1408;
    bool _130 = false;
    _127 = _130;
    _jump1408:;
    _a2__a1_void_t _131;
    if (!_127)
    goto _jump1409;
    _a2__a1_void_t _132;
    // Computing bound for Q
    _132.d0 = _82.d0;
    if (_82.d0 > 0) 
    goto _jump1410;
    fail_assertion("non-positive loop bound");
    _jump1410:;
    // Computing bound for R
    _132.d1 = E;
    if (E > 0) 
    goto _jump1411;
    fail_assertion("non-positive loop bound");
    _jump1411:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _82.d0;
    _133 *= E;
    _133 *= sizeof(_a1_void_t);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // R
    int64_t _135 = 0; // Q
    _jump1412:; // Begin body of loop
    _a1_void_t _136 = F();
    int64_t _137 = 0;
    _137 *= _132.d0;
    _137 += _135;
    _137 *= _132.d1;
    _137 += _134;
    _132.data[_137] = _136;
    _134++;
    if (_134 < E)
    goto _jump1412;
    _134 = 0;
    _135++;
    if (_135 < _82.d0)
    goto _jump1412;
    // End body of loop
    _131 = _132;
    goto _jump1413;
    _jump1409:;
    bool _138 = v(A);
    _a2__a1_void_t _139;
    if (!_138)
    goto _jump1414;
    _a2__a1_void_t _140;
    // Computing bound for Q
    _140.d0 = z;
    if (z > 0) 
    goto _jump1415;
    fail_assertion("non-positive loop bound");
    _jump1415:;
    // Computing bound for R
    _140.d1 = u;
    if (u > 0) 
    goto _jump1416;
    fail_assertion("non-positive loop bound");
    _jump1416:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= z;
    _141 *= u;
    _141 *= sizeof(_a1_void_t);
    _140.data = jpl_alloc(_141);
    int64_t _142 = 0; // R
    int64_t _143 = 0; // Q
    _jump1417:; // Begin body of loop
    _a1_void_t _144 = F();
    int64_t _145 = 0;
    _145 *= _140.d0;
    _145 += _143;
    _145 *= _140.d1;
    _145 += _142;
    _140.data[_145] = _144;
    _142++;
    if (_142 < u)
    goto _jump1417;
    _142 = 0;
    _143++;
    if (_143 < z)
    goto _jump1417;
    // End body of loop
    _139 = _140;
    goto _jump1418;
    _jump1414:;
    _a2__a1_void_t _146;
    // Computing bound for Q
    _146.d0 = i;
    if (i > 0) 
    goto _jump1419;
    fail_assertion("non-positive loop bound");
    _jump1419:;
    // Computing bound for R
    _146.d1 = d;
    if (d > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= i;
    _147 *= d;
    _147 *= sizeof(_a1_void_t);
    _146.data = jpl_alloc(_147);
    int64_t _148 = 0; // R
    int64_t _149 = 0; // Q
    _jump1421:; // Begin body of loop
    _a1_void_t _150 = F();
    int64_t _151 = 0;
    _151 *= _146.d0;
    _151 += _149;
    _151 *= _146.d1;
    _151 += _148;
    _146.data[_151] = _150;
    _148++;
    if (_148 < d)
    goto _jump1421;
    _148 = 0;
    _149++;
    if (_149 < i)
    goto _jump1421;
    // End body of loop
    _139 = _146;
    _jump1418:;
    _131 = _139;
    _jump1413:;
    _126 = _131;
    goto _jump1422;
    _jump1407:;
    _a2__a1_void_t _152;
    // Computing bound for Q
    _152.d0 = i;
    if (i > 0) 
    goto _jump1423;
    fail_assertion("non-positive loop bound");
    _jump1423:;
    // Computing bound for R
    _152.d1 = E;
    if (E > 0) 
    goto _jump1424;
    fail_assertion("non-positive loop bound");
    _jump1424:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= i;
    _153 *= E;
    _153 *= sizeof(_a1_void_t);
    _152.data = jpl_alloc(_153);
    int64_t _154 = 0; // R
    int64_t _155 = 0; // Q
    _jump1425:; // Begin body of loop
    _a1_void_t _156;
    // Computing bound for S
    _156.d0 = i;
    if (i > 0) 
    goto _jump1426;
    fail_assertion("non-positive loop bound");
    _jump1426:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= i;
    _157 *= sizeof(void_t);
    _156.data = jpl_alloc(_157);
    int64_t _158 = 0; // S
    _jump1427:; // Begin body of loop
    _a1_void_t _159 = F();
    if (t >= 0)
    goto _jump1428;
    fail_assertion("negative array index");
    _jump1428:;
    if (t < _159.d0)
    goto _jump1429;
    fail_assertion("index too large");
    _jump1429:;
    int64_t _160 = 0;
    _160 *= _159.d0;
    _160 += t;
    void_t _161 = _159.data[_160];
    int64_t _162 = 0;
    _162 *= _156.d0;
    _162 += _158;
    _156.data[_162] = _161;
    _158++;
    if (_158 < i)
    goto _jump1427;
    // End body of loop
    int64_t _163 = 0;
    _163 *= _152.d0;
    _163 += _155;
    _163 *= _152.d1;
    _163 += _154;
    _152.data[_163] = _156;
    _154++;
    if (_154 < E)
    goto _jump1425;
    _154 = 0;
    _155++;
    if (_155 < i)
    goto _jump1425;
    // End body of loop
    _126 = _152;
    _jump1422:;
    _118 = _126;
    goto _jump1430;
    _jump1404:;
    _a1__a2__a1_void_t _164;
    // Computing bound for Q
    _164.d0 = h;
    if (h > 0) 
    goto _jump1431;
    fail_assertion("non-positive loop bound");
    _jump1431:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= h;
    _165 *= sizeof(_a2__a1_void_t);
    _164.data = jpl_alloc(_165);
    int64_t _166 = 0; // Q
    _jump1432:; // Begin body of loop
    _a2__a1_void_t _167;
    // Computing bound for R
    _167.d0 = h;
    if (h > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing bound for S
    _167.d1 = w;
    if (w > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing total size of heap memory to allocate
    int64_t _168 = 1;
    _168 *= h;
    _168 *= w;
    _168 *= sizeof(_a1_void_t);
    _167.data = jpl_alloc(_168);
    int64_t _169 = 0; // S
    int64_t _170 = 0; // R
    _jump1435:; // Begin body of loop
    _a1_void_t _171 = F();
    int64_t _172 = 0;
    _172 *= _167.d0;
    _172 += _170;
    _172 *= _167.d1;
    _172 += _169;
    _167.data[_172] = _171;
    _169++;
    if (_169 < w)
    goto _jump1435;
    _169 = 0;
    _170++;
    if (_170 < h)
    goto _jump1435;
    // End body of loop
    int64_t _173 = 0;
    _173 *= _164.d0;
    _173 += _166;
    _164.data[_173] = _167;
    _166++;
    if (_166 < h)
    goto _jump1432;
    // End body of loop
    if (_82.d1 >= 0)
    goto _jump1436;
    fail_assertion("negative array index");
    _jump1436:;
    if (_82.d1 < _164.d0)
    goto _jump1437;
    fail_assertion("index too large");
    _jump1437:;
    int64_t _174 = 0;
    _174 *= _164.d0;
    _174 += _82.d1;
    _a2__a1_void_t _175 = _164.data[_174];
    _118 = _175;
    _jump1430:;
    _116 = _118;
    goto _jump1438;
    _jump1403:;
    _a2__a2__a1_void_t _176;
    // Computing bound for Q
    _176.d0 = z;
    if (z > 0) 
    goto _jump1439;
    fail_assertion("non-positive loop bound");
    _jump1439:;
    // Computing bound for R
    _176.d1 = d;
    if (d > 0) 
    goto _jump1440;
    fail_assertion("non-positive loop bound");
    _jump1440:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= z;
    _177 *= d;
    _177 *= sizeof(_a2__a1_void_t);
    _176.data = jpl_alloc(_177);
    int64_t _178 = 0; // R
    int64_t _179 = 0; // Q
    _jump1441:; // Begin body of loop
    _a2__a1_void_t _180;
    // Computing bound for S
    _180.d0 = w;
    if (w > 0) 
    goto _jump1442;
    fail_assertion("non-positive loop bound");
    _jump1442:;
    // Computing bound for T
    _180.d1 = D;
    if (D > 0) 
    goto _jump1443;
    fail_assertion("non-positive loop bound");
    _jump1443:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= w;
    _181 *= D;
    _181 *= sizeof(_a1_void_t);
    _180.data = jpl_alloc(_181);
    int64_t _182 = 0; // T
    int64_t _183 = 0; // S
    _jump1444:; // Begin body of loop
    _a1_void_t _184 = F();
    int64_t _185 = 0;
    _185 *= _180.d0;
    _185 += _183;
    _185 *= _180.d1;
    _185 += _182;
    _180.data[_185] = _184;
    _182++;
    if (_182 < D)
    goto _jump1444;
    _182 = 0;
    _183++;
    if (_183 < w)
    goto _jump1444;
    // End body of loop
    int64_t _186 = 0;
    _186 *= _176.d0;
    _186 += _179;
    _186 *= _176.d1;
    _186 += _178;
    _176.data[_186] = _180;
    _178++;
    if (_178 < d)
    goto _jump1441;
    _178 = 0;
    _179++;
    if (_179 < z)
    goto _jump1441;
    // End body of loop
    if (u >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (u < _176.d0)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    if (_82.d1 >= 0)
    goto _jump1447;
    fail_assertion("negative array index");
    _jump1447:;
    if (_82.d1 < _176.d1)
    goto _jump1448;
    fail_assertion("index too large");
    _jump1448:;
    int64_t _187 = 0;
    _187 *= _176.d0;
    _187 += u;
    _187 *= _176.d1;
    _187 += _82.d1;
    _a2__a1_void_t _188 = _176.data[_187];
    _116 = _188;
    _jump1438:;
    rgba _190 = { o, x, o, x };
    bool _191 = v(_190);
    bool _192;
    if (!_191)
    goto _jump1449;
    bool _193 = true;
    _192 = _193;
    goto _jump1450;
    _jump1449:;
    bool _194 = true;
    _192 = _194;
    _jump1450:;
    bool _189 = _192;
    if (0 != _192)
    goto _jump1451;
    bool _195 = v(A);
    _189 = _195;
    _jump1451:;
    _a1_int64_t _196;
    if (!_189)
    goto _jump1452;
    bool _197 = false;
    bool _198 = !_197;
    _a2__a1_int64_t _199;
    if (!_198)
    goto _jump1453;
    _a2__a1_int64_t _200;
    // Computing bound for Q
    int64_t _201 = -c;
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump1454;
    fail_assertion("non-positive loop bound");
    _jump1454:;
    // Computing bound for R
    _200.d1 = d;
    if (d > 0) 
    goto _jump1455;
    fail_assertion("non-positive loop bound");
    _jump1455:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _201;
    _202 *= d;
    _202 *= sizeof(_a1_int64_t);
    _200.data = jpl_alloc(_202);
    int64_t _203 = 0; // R
    int64_t _204 = 0; // Q
    _jump1456:; // Begin body of loop
    _a1_int64_t _205;
    // Computing bound for S
    _205.d0 = e;
    if (e > 0) 
    goto _jump1457;
    fail_assertion("non-positive loop bound");
    _jump1457:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= e;
    _206 *= sizeof(int64_t);
    _205.data = jpl_alloc(_206);
    int64_t _207 = 0; // S
    _jump1458:; // Begin body of loop
    int64_t _208 = 0;
    _208 *= _205.d0;
    _208 += _207;
    _205.data[_208] = w;
    _207++;
    if (_207 < e)
    goto _jump1458;
    // End body of loop
    int64_t _209 = 0;
    _209 *= _200.d0;
    _209 += _204;
    _209 *= _200.d1;
    _209 += _203;
    _200.data[_209] = _205;
    _203++;
    if (_203 < d)
    goto _jump1456;
    _203 = 0;
    _204++;
    if (_204 < _201)
    goto _jump1456;
    // End body of loop
    _199 = _200;
    goto _jump1459;
    _jump1453:;
    _a2__a1_int64_t _210;
    // Computing bound for Q
    _210.d0 = r;
    if (r > 0) 
    goto _jump1460;
    fail_assertion("non-positive loop bound");
    _jump1460:;
    // Computing bound for R
    _210.d1 = w;
    if (w > 0) 
    goto _jump1461;
    fail_assertion("non-positive loop bound");
    _jump1461:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= r;
    _211 *= w;
    _211 *= sizeof(_a1_int64_t);
    _210.data = jpl_alloc(_211);
    int64_t _212 = 0; // R
    int64_t _213 = 0; // Q
    _jump1462:; // Begin body of loop
    _a1_int64_t _214;
    _214.d0 = 1;
    _214.data = jpl_alloc(sizeof(int64_t) * 1);
    _214.data[0] = d;
    int64_t _215 = 0;
    _215 *= _210.d0;
    _215 += _213;
    _215 *= _210.d1;
    _215 += _212;
    _210.data[_215] = _214;
    _212++;
    if (_212 < w)
    goto _jump1462;
    _212 = 0;
    _213++;
    if (_213 < r)
    goto _jump1462;
    // End body of loop
    _199 = _210;
    _jump1459:;
    bool _216 = false;
    int64_t _217;
    if (!_216)
    goto _jump1463;
    _217 = q;
    goto _jump1464;
    _jump1463:;
    _217 = s;
    _jump1464:;
    if (_217 >= 0)
    goto _jump1465;
    fail_assertion("negative array index");
    _jump1465:;
    if (_217 < _199.d0)
    goto _jump1466;
    fail_assertion("index too large");
    _jump1466:;
    if (z >= 0)
    goto _jump1467;
    fail_assertion("negative array index");
    _jump1467:;
    if (z < _199.d1)
    goto _jump1468;
    fail_assertion("index too large");
    _jump1468:;
    int64_t _218 = 0;
    _218 *= _199.d0;
    _218 += _217;
    _218 *= _199.d1;
    _218 += z;
    _a1_int64_t _219 = _199.data[_218];
    _196 = _219;
    goto _jump1469;
    _jump1452:;
    _a1_int64_t _220;
    _220.d0 = 1;
    _220.data = jpl_alloc(sizeof(int64_t) * 1);
    _220.data[0] = e;
    _196 = _220;
    _jump1469:;
    if (_82.d0 >= 0)
    goto _jump1470;
    fail_assertion("negative array index");
    _jump1470:;
    if (_82.d0 < _196.d0)
    goto _jump1471;
    fail_assertion("index too large");
    _jump1471:;
    int64_t _221 = 0;
    _221 *= _196.d0;
    _221 += _82.d0;
    int64_t _222 = _196.data[_221];
    if (_222 >= 0)
    goto _jump1472;
    fail_assertion("negative array index");
    _jump1472:;
    if (_222 < _116.d0)
    goto _jump1473;
    fail_assertion("index too large");
    _jump1473:;
    if (_82.d0 >= 0)
    goto _jump1474;
    fail_assertion("negative array index");
    _jump1474:;
    if (_82.d0 < _116.d1)
    goto _jump1475;
    fail_assertion("index too large");
    _jump1475:;
    int64_t _223 = 0;
    _223 *= _116.d0;
    _223 += _222;
    _223 *= _116.d1;
    _223 += _82.d0;
    _a1_void_t _224 = _116.data[_223];
    return _224;
    double _225 = 44.0;
    bool _226 = _225 >= o;
    _a1_void_t _227;
    if (!_226)
    goto _jump1476;
    _a1_void_t _228;
    // Computing bound for Q
    _228.d0 = _82.d1;
    if (_82.d1 > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    // Computing total size of heap memory to allocate
    int64_t _229 = 1;
    _229 *= _82.d1;
    _229 *= sizeof(void_t);
    _228.data = jpl_alloc(_229);
    int64_t _230 = 0; // Q
    _jump1478:; // Begin body of loop
    _a2_void_t _231;
    // Computing bound for R
    _231.d0 = _230;
    if (_230 > 0) 
    goto _jump1479;
    fail_assertion("non-positive loop bound");
    _jump1479:;
    // Computing bound for S
    _231.d1 = t;
    if (t > 0) 
    goto _jump1480;
    fail_assertion("non-positive loop bound");
    _jump1480:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= _230;
    _232 *= t;
    _232 *= sizeof(void_t);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // S
    int64_t _234 = 0; // R
    _jump1481:; // Begin body of loop
    _a1_void_t _235 = F();
    if (l >= 0)
    goto _jump1482;
    fail_assertion("negative array index");
    _jump1482:;
    if (l < _235.d0)
    goto _jump1483;
    fail_assertion("index too large");
    _jump1483:;
    int64_t _236 = 0;
    _236 *= _235.d0;
    _236 += l;
    void_t _237 = _235.data[_236];
    int64_t _238 = 0;
    _238 *= _231.d0;
    _238 += _234;
    _238 *= _231.d1;
    _238 += _233;
    _231.data[_238] = _237;
    _233++;
    if (_233 < t)
    goto _jump1481;
    _233 = 0;
    _234++;
    if (_234 < _230)
    goto _jump1481;
    // End body of loop
    if (d >= 0)
    goto _jump1484;
    fail_assertion("negative array index");
    _jump1484:;
    if (d < _231.d0)
    goto _jump1485;
    fail_assertion("index too large");
    _jump1485:;
    if (i >= 0)
    goto _jump1486;
    fail_assertion("negative array index");
    _jump1486:;
    if (i < _231.d1)
    goto _jump1487;
    fail_assertion("index too large");
    _jump1487:;
    int64_t _239 = 0;
    _239 *= _231.d0;
    _239 += d;
    _239 *= _231.d1;
    _239 += i;
    void_t _240 = _231.data[_239];
    int64_t _241 = 0;
    _241 *= _228.d0;
    _241 += _230;
    _228.data[_241] = _240;
    _230++;
    if (_230 < _82.d1)
    goto _jump1478;
    // End body of loop
    _227 = _228;
    goto _jump1488;
    _jump1476:;
    bool _242 = true;
    _a1_void_t _243;
    if (!_242)
    goto _jump1489;
    bool _244 = true;
    bool _245;
    if (!_244)
    goto _jump1490;
    int64_t _246;
    // Computing bound for Q
    if (_82.d1 > 0) 
    goto _jump1491;
    fail_assertion("non-positive loop bound");
    _jump1491:;
    // Computing bound for R
    if (h > 0) 
    goto _jump1492;
    fail_assertion("non-positive loop bound");
    _jump1492:;
    _246 = 0;
    int64_t _247 = 0; // R
    int64_t _248 = 0; // Q
    _jump1493:; // Begin body of loop
    _246 += _248;
    _247++;
    if (_247 < h)
    goto _jump1493;
    _247 = 0;
    _248++;
    if (_248 < _82.d1)
    goto _jump1493;
    // End body of loop
    bool _249 = _82.d0 > _246;
    _245 = _249;
    goto _jump1494;
    _jump1490:;
    bool _251 = h > d;
    bool _250 = _251;
    if (0 == _251)
    goto _jump1495;
    bool _252 = v(A);
    _250 = _252;
    _jump1495:;
    _245 = _250;
    _jump1494:;
    void_t _253;
    if (!_245)
    goto _jump1496;
    _a1_void_t _254 = F();
    _a1__a1_void_t _255;
    _255.d0 = 1;
    _255.data = jpl_alloc(sizeof(_a1_void_t) * 1);
    _255.data[0] = _254;
    if (q >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (q < _255.d0)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    int64_t _256 = 0;
    _256 *= _255.d0;
    _256 += q;
    _a1_void_t _257 = _255.data[_256];
    _a3_int64_t _258;
    // Computing bound for Q
    _258.d0 = D;
    if (D > 0) 
    goto _jump1499;
    fail_assertion("non-positive loop bound");
    _jump1499:;
    // Computing bound for R
    _258.d1 = e;
    if (e > 0) 
    goto _jump1500;
    fail_assertion("non-positive loop bound");
    _jump1500:;
    // Computing bound for S
    _258.d2 = E;
    if (E > 0) 
    goto _jump1501;
    fail_assertion("non-positive loop bound");
    _jump1501:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= D;
    _259 *= e;
    _259 *= E;
    _259 *= sizeof(int64_t);
    _258.data = jpl_alloc(_259);
    int64_t _260 = 0; // S
    int64_t _261 = 0; // R
    int64_t _262 = 0; // Q
    _jump1502:; // Begin body of loop
    int64_t _263 = 518;
    int64_t _264 = 0;
    _264 *= _258.d0;
    _264 += _262;
    _264 *= _258.d1;
    _264 += _261;
    _264 *= _258.d2;
    _264 += _260;
    _258.data[_264] = _263;
    _260++;
    if (_260 < E)
    goto _jump1502;
    _260 = 0;
    _261++;
    if (_261 < e)
    goto _jump1502;
    _261 = 0;
    _262++;
    if (_262 < D)
    goto _jump1502;
    // End body of loop
    if (l >= 0)
    goto _jump1503;
    fail_assertion("negative array index");
    _jump1503:;
    if (l < _258.d0)
    goto _jump1504;
    fail_assertion("index too large");
    _jump1504:;
    if (r >= 0)
    goto _jump1505;
    fail_assertion("negative array index");
    _jump1505:;
    if (r < _258.d1)
    goto _jump1506;
    fail_assertion("index too large");
    _jump1506:;
    if (e >= 0)
    goto _jump1507;
    fail_assertion("negative array index");
    _jump1507:;
    if (e < _258.d2)
    goto _jump1508;
    fail_assertion("index too large");
    _jump1508:;
    int64_t _265 = 0;
    _265 *= _258.d0;
    _265 += l;
    _265 *= _258.d1;
    _265 += r;
    _265 *= _258.d2;
    _265 += e;
    int64_t _266 = _258.data[_265];
    if (_266 >= 0)
    goto _jump1509;
    fail_assertion("negative array index");
    _jump1509:;
    if (_266 < _257.d0)
    goto _jump1510;
    fail_assertion("index too large");
    _jump1510:;
    int64_t _267 = 0;
    _267 *= _257.d0;
    _267 += _266;
    void_t _268 = _257.data[_267];
    _253 = _268;
    goto _jump1511;
    _jump1496:;
    _a1_void_t _269 = F();
    _a1__a1_void_t _270;
    _270.d0 = 1;
    _270.data = jpl_alloc(sizeof(_a1_void_t) * 1);
    _270.data[0] = _269;
    int64_t _271 = -q;
    if (_271 >= 0)
    goto _jump1512;
    fail_assertion("negative array index");
    _jump1512:;
    if (_271 < _270.d0)
    goto _jump1513;
    fail_assertion("index too large");
    _jump1513:;
    int64_t _272 = 0;
    _272 *= _270.d0;
    _272 += _271;
    _a1_void_t _273 = _270.data[_272];
    if (w >= 0)
    goto _jump1514;
    fail_assertion("negative array index");
    _jump1514:;
    if (w < _273.d0)
    goto _jump1515;
    fail_assertion("index too large");
    _jump1515:;
    int64_t _274 = 0;
    _274 *= _273.d0;
    _274 += w;
    void_t _275 = _273.data[_274];
    _253 = _275;
    _jump1511:;
    _a2_rgba _276;
    // Computing bound for Q
    _276.d0 = w;
    if (w > 0) 
    goto _jump1516;
    fail_assertion("non-positive loop bound");
    _jump1516:;
    // Computing bound for R
    _276.d1 = n;
    if (n > 0) 
    goto _jump1517;
    fail_assertion("non-positive loop bound");
    _jump1517:;
    // Computing total size of heap memory to allocate
    int64_t _277 = 1;
    _277 *= w;
    _277 *= n;
    _277 *= sizeof(rgba);
    _276.data = jpl_alloc(_277);
    int64_t _278 = 0; // R
    int64_t _279 = 0; // Q
    _jump1518:; // Begin body of loop
    int64_t _280 = 0;
    _280 *= _276.d0;
    _280 += _279;
    _280 *= _276.d1;
    _280 += _278;
    _276.data[_280] = A;
    _278++;
    if (_278 < n)
    goto _jump1518;
    _278 = 0;
    _279++;
    if (_279 < w)
    goto _jump1518;
    // End body of loop
    if (m >= 0)
    goto _jump1519;
    fail_assertion("negative array index");
    _jump1519:;
    if (m < _276.d0)
    goto _jump1520;
    fail_assertion("index too large");
    _jump1520:;
    if (d >= 0)
    goto _jump1521;
    fail_assertion("negative array index");
    _jump1521:;
    if (d < _276.d1)
    goto _jump1522;
    fail_assertion("index too large");
    _jump1522:;
    int64_t _281 = 0;
    _281 *= _276.d0;
    _281 += m;
    _281 *= _276.d1;
    _281 += d;
    rgba _282 = _276.data[_281];
    bool _283 = v(_282);
    void_t _284;
    if (!_283)
    goto _jump1523;
    _a1__a1_void_t _285;
    // Computing bound for Q
    _285.d0 = d;
    if (d > 0) 
    goto _jump1524;
    fail_assertion("non-positive loop bound");
    _jump1524:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= d;
    _286 *= sizeof(_a1_void_t);
    _285.data = jpl_alloc(_286);
    int64_t _287 = 0; // Q
    _jump1525:; // Begin body of loop
    _a1_void_t _288 = F();
    int64_t _289 = 0;
    _289 *= _285.d0;
    _289 += _287;
    _285.data[_289] = _288;
    _287++;
    if (_287 < d)
    goto _jump1525;
    // End body of loop
    if (u >= 0)
    goto _jump1526;
    fail_assertion("negative array index");
    _jump1526:;
    if (u < _285.d0)
    goto _jump1527;
    fail_assertion("index too large");
    _jump1527:;
    int64_t _290 = 0;
    _290 *= _285.d0;
    _290 += u;
    _a1_void_t _291 = _285.data[_290];
    if (t >= 0)
    goto _jump1528;
    fail_assertion("negative array index");
    _jump1528:;
    if (t < _291.d0)
    goto _jump1529;
    fail_assertion("index too large");
    _jump1529:;
    int64_t _292 = 0;
    _292 *= _291.d0;
    _292 += t;
    void_t _293 = _291.data[_292];
    _284 = _293;
    goto _jump1530;
    _jump1523:;
    _a3_void_t _294;
    // Computing bound for Q
    int64_t _295 = -_82.d0;
    _294.d0 = _295;
    if (_295 > 0) 
    goto _jump1531;
    fail_assertion("non-positive loop bound");
    _jump1531:;
    // Computing bound for R
    _294.d1 = l;
    if (l > 0) 
    goto _jump1532;
    fail_assertion("non-positive loop bound");
    _jump1532:;
    // Computing bound for S
    _294.d2 = d;
    if (d > 0) 
    goto _jump1533;
    fail_assertion("non-positive loop bound");
    _jump1533:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _295;
    _296 *= l;
    _296 *= d;
    _296 *= sizeof(void_t);
    _294.data = jpl_alloc(_296);
    int64_t _297 = 0; // S
    int64_t _298 = 0; // R
    int64_t _299 = 0; // Q
    _jump1534:; // Begin body of loop
    _a1_void_t _300 = F();
    if (D >= 0)
    goto _jump1535;
    fail_assertion("negative array index");
    _jump1535:;
    if (D < _300.d0)
    goto _jump1536;
    fail_assertion("index too large");
    _jump1536:;
    int64_t _301 = 0;
    _301 *= _300.d0;
    _301 += D;
    void_t _302 = _300.data[_301];
    int64_t _303 = 0;
    _303 *= _294.d0;
    _303 += _299;
    _303 *= _294.d1;
    _303 += _298;
    _303 *= _294.d2;
    _303 += _297;
    _294.data[_303] = _302;
    _297++;
    if (_297 < d)
    goto _jump1534;
    _297 = 0;
    _298++;
    if (_298 < l)
    goto _jump1534;
    _298 = 0;
    _299++;
    if (_299 < _295)
    goto _jump1534;
    // End body of loop
    int64_t _304 = 627;
    if (D >= 0)
    goto _jump1537;
    fail_assertion("negative array index");
    _jump1537:;
    if (D < _294.d0)
    goto _jump1538;
    fail_assertion("index too large");
    _jump1538:;
    if (_82.d1 >= 0)
    goto _jump1539;
    fail_assertion("negative array index");
    _jump1539:;
    if (_82.d1 < _294.d1)
    goto _jump1540;
    fail_assertion("index too large");
    _jump1540:;
    if (_304 >= 0)
    goto _jump1541;
    fail_assertion("negative array index");
    _jump1541:;
    if (_304 < _294.d2)
    goto _jump1542;
    fail_assertion("index too large");
    _jump1542:;
    int64_t _305 = 0;
    _305 *= _294.d0;
    _305 += D;
    _305 *= _294.d1;
    _305 += _82.d1;
    _305 *= _294.d2;
    _305 += _304;
    void_t _306 = _294.data[_305];
    _284 = _306;
    _jump1530:;
    double _307 = A.b;
    bool _308 = a < _307;
    _a1_void_t _309;
    if (!_308)
    goto _jump1543;
    _a1_void_t _310 = F();
    _309 = _310;
    goto _jump1544;
    _jump1543:;
    _a1_void_t _311 = F();
    _309 = _311;
    _jump1544:;
    if (t >= 0)
    goto _jump1545;
    fail_assertion("negative array index");
    _jump1545:;
    if (t < _309.d0)
    goto _jump1546;
    fail_assertion("index too large");
    _jump1546:;
    int64_t _312 = 0;
    _312 *= _309.d0;
    _312 += t;
    void_t _313 = _309.data[_312];
    _a1_void_t _314;
    _314.d0 = 3;
    _314.data = jpl_alloc(sizeof(void_t) * 3);
    _314.data[0] = _253;
    _314.data[1] = _284;
    _314.data[2] = _313;
    _243 = _314;
    goto _jump1547;
    _jump1489:;
    _a1_void_t _315 = F();
    _243 = _315;
    _jump1547:;
    _227 = _243;
    _jump1488:;
    return _227;
}

void jpl_main(struct args args) {
    int64_t _0 = 894;
    bool _1 = false;
    int64_t _2;
    if (!_1)
    goto _jump1;
    int64_t _3 = 172;
    int64_t _4 = -_3;
    _2 = _4;
    goto _jump2;
    _jump1:;
    int64_t _5 = 249;
    _2 = _5;
    _jump2:;
    bool _6 = _0 > _2;
    bool _7 = !_6;
    double _8;
    if (!_7)
    goto _jump3;
    _a1_bool _9;
    // Computing bound for a
    int64_t _10 = 613;
    int64_t _11 = -_10;
    _9.d0 = _11;
    if (_11 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _11;
    _12 *= sizeof(bool);
    _9.data = jpl_alloc(_12);
    int64_t _13 = 0; // a
    _jump5:; // Begin body of loop
    bool _14 = true;
    int64_t _15 = 0;
    _15 *= _9.d0;
    _15 += _13;
    _9.data[_15] = _14;
    _13++;
    if (_13 < _11)
    goto _jump5;
    // End body of loop
    int64_t _16 = 628;
    int64_t _17 = 550;
    int64_t _18 = _16 + _17;
    int64_t _19 = -_18;
    if (_19 >= 0)
    goto _jump6;
    fail_assertion("negative array index");
    _jump6:;
    if (_19 < _9.d0)
    goto _jump7;
    fail_assertion("index too large");
    _jump7:;
    int64_t _20 = 0;
    _20 *= _9.d0;
    _20 += _19;
    bool _21 = _9.data[_20];
    double _22;
    if (!_21)
    goto _jump8;
    double _23;
    // Computing bound for a
    int64_t _24;
    // Computing bound for a
    int64_t _25 = 1000;
    if (_25 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    // Computing bound for b
    int64_t _26 = 700;
    if (_26 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    _24 = 0;
    int64_t _27 = 0; // b
    int64_t _28 = 0; // a
    _jump11:; // Begin body of loop
    _24 += _28;
    _27++;
    if (_27 < _26)
    goto _jump11;
    _27 = 0;
    _28++;
    if (_28 < _25)
    goto _jump11;
    // End body of loop
    int64_t _29 = 650;
    int64_t _30 = _24 % _29;
    if (_30 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    _23 = 0;
    int64_t _31 = 0; // a
    _jump13:; // Begin body of loop
    double _32;
    // Computing bound for b
    if (_31 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing bound for c
    if (_31 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    _32 = 0;
    int64_t _33 = 0; // c
    int64_t _34 = 0; // b
    _jump16:; // Begin body of loop
    double _35 = 49.0;
    double _36 = -_35;
    _32 += _36;
    _33++;
    if (_33 < _31)
    goto _jump16;
    _33 = 0;
    _34++;
    if (_34 < _31)
    goto _jump16;
    // End body of loop
    _23 += _32;
    _31++;
    if (_31 < _30)
    goto _jump13;
    // End body of loop
    _22 = _23;
    goto _jump17;
    _jump8:;
    double _37 = 30.0;
    _a1_double _38;
    _38.d0 = 1;
    _38.data = jpl_alloc(sizeof(double) * 1);
    _38.data[0] = _37;
    int64_t _39 = 511;
    if (_39 >= 0)
    goto _jump18;
    fail_assertion("negative array index");
    _jump18:;
    if (_39 < _38.d0)
    goto _jump19;
    fail_assertion("index too large");
    _jump19:;
    int64_t _40 = 0;
    _40 *= _38.d0;
    _40 += _39;
    double _41 = _38.data[_40];
    double _42 = -_41;
    _22 = _42;
    _jump17:;
    _8 = _22;
    goto _jump20;
    _jump3:;
    double _43 = 5.0;
    double _44 = 1.0;
    double _45 = _43 / _44;
    _8 = _45;
    _jump20:;
    double _46 = -_8;
    double _47 = -_46;
    int64_t _48 = 11;
    _a2__a3_int64_t _49;
    // Computing bound for b
    int64_t _50 = 966;
    _49.d0 = _50;
    if (_50 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing bound for c
    bool _51 = _47 < _47;
    int64_t _52;
    if (!_51)
    goto _jump22;
    int64_t _53;
    // Computing bound for b
    int64_t _54 = 829;
    if (_54 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    // Computing bound for c
    int64_t _55 = 46;
    if (_55 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    // Computing bound for d
    int64_t _56 = 925;
    if (_56 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    _53 = 0;
    int64_t _57 = 0; // d
    int64_t _58 = 0; // c
    int64_t _59 = 0; // b
    _jump26:; // Begin body of loop
    _53 += _58;
    _57++;
    if (_57 < _56)
    goto _jump26;
    _57 = 0;
    _58++;
    if (_58 < _55)
    goto _jump26;
    _58 = 0;
    _59++;
    if (_59 < _54)
    goto _jump26;
    // End body of loop
    _52 = _53;
    goto _jump27;
    _jump22:;
    int64_t _60;
    // Computing bound for b
    int64_t _61 = 176;
    if (_61 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    _60 = 0;
    int64_t _62 = 0; // b
    _jump29:; // Begin body of loop
    int64_t _63 = 657;
    _60 += _63;
    _62++;
    if (_62 < _61)
    goto _jump29;
    // End body of loop
    _52 = _60;
    _jump27:;
    _49.d1 = _52;
    if (_52 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= _50;
    _64 *= _52;
    _64 *= sizeof(_a3_int64_t);
    _49.data = jpl_alloc(_64);
    int64_t _65 = 0; // c
    int64_t _66 = 0; // b
    _jump31:; // Begin body of loop
    _a3_int64_t _67;
    // Computing bound for d
    int64_t _68 = 974;
    _67.d0 = _68;
    if (_68 > 0) 
    goto _jump32;
    fail_assertion("non-positive loop bound");
    _jump32:;
    // Computing bound for e
    _67.d1 = _66;
    if (_66 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing bound for f
    _67.d2 = _66;
    if (_66 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    // Computing total size of heap memory to allocate
    int64_t _69 = 1;
    _69 *= _68;
    _69 *= _66;
    _69 *= _66;
    _69 *= sizeof(int64_t);
    _67.data = jpl_alloc(_69);
    int64_t _70 = 0; // f
    int64_t _71 = 0; // e
    int64_t _72 = 0; // d
    _jump35:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _67.d0;
    _73 += _72;
    _73 *= _67.d1;
    _73 += _71;
    _73 *= _67.d2;
    _73 += _70;
    _67.data[_73] = _70;
    _70++;
    if (_70 < _66)
    goto _jump35;
    _70 = 0;
    _71++;
    if (_71 < _66)
    goto _jump35;
    _71 = 0;
    _72++;
    if (_72 < _68)
    goto _jump35;
    // End body of loop
    int64_t _74 = 0;
    _74 *= _49.d0;
    _74 += _66;
    _74 *= _49.d1;
    _74 += _65;
    _49.data[_74] = _67;
    _65++;
    if (_65 < _52)
    goto _jump31;
    _65 = 0;
    _66++;
    if (_66 < _50)
    goto _jump31;
    // End body of loop
    int64_t _75 = 263;
    int64_t _76 = -_75;
    int64_t _77 = 276;
    int64_t _78 = _76 + _77;
    int64_t _79 = 350;
    int64_t _80 = -_79;
    if (_78 >= 0)
    goto _jump36;
    fail_assertion("negative array index");
    _jump36:;
    if (_78 < _49.d0)
    goto _jump37;
    fail_assertion("index too large");
    _jump37:;
    if (_80 >= 0)
    goto _jump38;
    fail_assertion("negative array index");
    _jump38:;
    if (_80 < _49.d1)
    goto _jump39;
    fail_assertion("index too large");
    _jump39:;
    int64_t _81 = 0;
    _81 *= _49.d0;
    _81 += _78;
    _81 *= _49.d1;
    _81 += _80;
    _a3_int64_t _82 = _49.data[_81];
    int64_t _83 = 371;
    int64_t _84 = -_83;
    int64_t _85;
    // Computing bound for b
    int64_t _86 = 722;
    if (_86 > 0) 
    goto _jump40;
    fail_assertion("non-positive loop bound");
    _jump40:;
    _85 = 0;
    int64_t _87 = 0; // b
    _jump41:; // Begin body of loop
    int64_t _88;
    // Computing bound for c
    int64_t _89 = -_87;
    int64_t _90 = _89 + _87;
    if (_90 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    // Computing bound for d
    int64_t _91;
    // Computing bound for c
    int64_t _92 = 828;
    int64_t _93 = _87 % _92;
    if (_93 > 0) 
    goto _jump43;
    fail_assertion("non-positive loop bound");
    _jump43:;
    _91 = 0;
    int64_t _94 = 0; // c
    _jump44:; // Begin body of loop
    int64_t _95 = 412;
    int64_t _96 = -_95;
    _91 += _96;
    _94++;
    if (_94 < _93)
    goto _jump44;
    // End body of loop
    if (_91 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    // Computing bound for e
    if (_87 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    _88 = 0;
    int64_t _97 = 0; // e
    int64_t _98 = 0; // d
    int64_t _99 = 0; // c
    _jump47:; // Begin body of loop
    _88 += _97;
    _97++;
    if (_97 < _87)
    goto _jump47;
    _97 = 0;
    _98++;
    if (_98 < _91)
    goto _jump47;
    _98 = 0;
    _99++;
    if (_99 < _90)
    goto _jump47;
    // End body of loop
    _85 += _88;
    _87++;
    if (_87 < _86)
    goto _jump41;
    // End body of loop
    int64_t _100 = 802;
    int64_t _101 = 612;
    int64_t _102 = 273;
    _a1_int64_t _103;
    _103.d0 = 3;
    _103.data = jpl_alloc(sizeof(int64_t) * 3);
    _103.data[0] = _100;
    _103.data[1] = _101;
    _103.data[2] = _102;
    int64_t _104 = 863;
    if (_104 >= 0)
    goto _jump48;
    fail_assertion("negative array index");
    _jump48:;
    if (_104 < _103.d0)
    goto _jump49;
    fail_assertion("index too large");
    _jump49:;
    int64_t _105 = 0;
    _105 *= _103.d0;
    _105 += _104;
    int64_t _106 = _103.data[_105];
    int64_t _107 = -_106;
    int64_t _108 = -_107;
    if (_84 >= 0)
    goto _jump50;
    fail_assertion("negative array index");
    _jump50:;
    if (_84 < _82.d0)
    goto _jump51;
    fail_assertion("index too large");
    _jump51:;
    if (_85 >= 0)
    goto _jump52;
    fail_assertion("negative array index");
    _jump52:;
    if (_85 < _82.d1)
    goto _jump53;
    fail_assertion("index too large");
    _jump53:;
    if (_108 >= 0)
    goto _jump54;
    fail_assertion("negative array index");
    _jump54:;
    if (_108 < _82.d2)
    goto _jump55;
    fail_assertion("index too large");
    _jump55:;
    int64_t _109 = 0;
    _109 *= _82.d0;
    _109 += _84;
    _109 *= _82.d1;
    _109 += _85;
    _109 *= _82.d2;
    _109 += _108;
    int64_t _110 = _82.data[_109];
    int64_t _111 = _48 + _110;
    _a1_int64_t _112;
    // Computing bound for b
    int64_t _113 = 297;
    int64_t _114 = -_113;
    _112.d0 = _114;
    if (_114 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _114;
    _115 *= sizeof(int64_t);
    _112.data = jpl_alloc(_115);
    int64_t _116 = 0; // b
    _jump57:; // Begin body of loop
    int64_t _117 = 0;
    _117 *= _112.d0;
    _117 += _116;
    _112.data[_117] = _116;
    _116++;
    if (_116 < _114)
    goto _jump57;
    // End body of loop
    _a1_bool _118;
    // Computing bound for b
    int64_t _119;
    // Computing bound for b
    int64_t _120 = 442;
    if (_120 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    _119 = 0;
    int64_t _121 = 0; // b
    _jump59:; // Begin body of loop
    int64_t _122 = 453;
    _119 += _122;
    _121++;
    if (_121 < _120)
    goto _jump59;
    // End body of loop
    _118.d0 = _119;
    if (_119 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= _119;
    _123 *= sizeof(bool);
    _118.data = jpl_alloc(_123);
    int64_t _124 = 0; // b
    _jump61:; // Begin body of loop
    double _125 = 0.0;
    double _126 = 65.0;
    bool _127 = _125 != _126;
    int64_t _128 = 0;
    _128 *= _118.d0;
    _128 += _124;
    _118.data[_128] = _127;
    _124++;
    if (_124 < _119)
    goto _jump61;
    // End body of loop
    int64_t _129;
    // Computing bound for b
    int64_t _130 = 884;
    int64_t _131 = -_130;
    if (_131 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    // Computing bound for c
    int64_t _132 = 16;
    int64_t _133 = -_132;
    if (_133 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing bound for d
    int64_t _134 = 381;
    int64_t _135 = -_134;
    if (_135 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    _129 = 0;
    int64_t _136 = 0; // d
    int64_t _137 = 0; // c
    int64_t _138 = 0; // b
    _jump65:; // Begin body of loop
    int64_t _139 = 693;
    int64_t _140 = _139 * _138;
    _129 += _140;
    _136++;
    if (_136 < _135)
    goto _jump65;
    _136 = 0;
    _137++;
    if (_137 < _133)
    goto _jump65;
    _137 = 0;
    _138++;
    if (_138 < _131)
    goto _jump65;
    // End body of loop
    if (_129 >= 0)
    goto _jump66;
    fail_assertion("negative array index");
    _jump66:;
    if (_129 < _118.d0)
    goto _jump67;
    fail_assertion("index too large");
    _jump67:;
    int64_t _141 = 0;
    _141 *= _118.d0;
    _141 += _129;
    bool _142 = _118.data[_141];
    int64_t _143;
    if (!_142)
    goto _jump68;
    int64_t _144 = 456;
    _143 = _144;
    goto _jump69;
    _jump68:;
    double _145 = 41.0;
    bool _146 = _145 >= _47;
    int64_t _147;
    if (!_146)
    goto _jump70;
    int64_t _148 = 979;
    int64_t _149 = 754;
    int64_t _150 = _148 / _149;
    _147 = _150;
    goto _jump71;
    _jump70:;
    _a1_int64_t _151;
    // Computing bound for b
    int64_t _152 = 985;
    _151.d0 = _152;
    if (_152 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _152;
    _153 *= sizeof(int64_t);
    _151.data = jpl_alloc(_153);
    int64_t _154 = 0; // b
    _jump73:; // Begin body of loop
    int64_t _155 = 888;
    int64_t _156 = 0;
    _156 *= _151.d0;
    _156 += _154;
    _151.data[_156] = _155;
    _154++;
    if (_154 < _152)
    goto _jump73;
    // End body of loop
    int64_t _157 = 306;
    int64_t _158 = -_157;
    if (_158 >= 0)
    goto _jump74;
    fail_assertion("negative array index");
    _jump74:;
    if (_158 < _151.d0)
    goto _jump75;
    fail_assertion("index too large");
    _jump75:;
    int64_t _159 = 0;
    _159 *= _151.d0;
    _159 += _158;
    int64_t _160 = _151.data[_159];
    _147 = _160;
    _jump71:;
    _143 = _147;
    _jump69:;
    int64_t _161 = -_143;
    if (_161 >= 0)
    goto _jump76;
    fail_assertion("negative array index");
    _jump76:;
    if (_161 < _112.d0)
    goto _jump77;
    fail_assertion("index too large");
    _jump77:;
    int64_t _162 = 0;
    _162 *= _112.d0;
    _162 += _161;
    int64_t _163 = _112.data[_162];
    bool _164 = _111 <= _163;
    show("(BoolType)", &_164);
    print("b");
    _a2__a3__a2__a3_int64_t _165;
    // Computing bound for b
    _a3_int64_t _166;
    // Computing bound for b
    int64_t _167 = 730;
    _166.d0 = _167;
    if (_167 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing bound for c
    int64_t _168 = 284;
    _166.d1 = _168;
    if (_168 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing bound for d
    int64_t _169 = 272;
    _166.d2 = _169;
    if (_169 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    // Computing total size of heap memory to allocate
    int64_t _170 = 1;
    _170 *= _167;
    _170 *= _168;
    _170 *= _169;
    _170 *= sizeof(int64_t);
    _166.data = jpl_alloc(_170);
    int64_t _171 = 0; // d
    int64_t _172 = 0; // c
    int64_t _173 = 0; // b
    _jump81:; // Begin body of loop
    int64_t _174;
    // Computing bound for e
    int64_t _175 = 407;
    if (_175 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing bound for f
    int64_t _176 = 10;
    if (_176 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    _174 = 0;
    int64_t _177 = 0; // f
    int64_t _178 = 0; // e
    _jump84:; // Begin body of loop
    _174 += _178;
    _177++;
    if (_177 < _176)
    goto _jump84;
    _177 = 0;
    _178++;
    if (_178 < _175)
    goto _jump84;
    // End body of loop
    int64_t _179 = 0;
    _179 *= _166.d0;
    _179 += _173;
    _179 *= _166.d1;
    _179 += _172;
    _179 *= _166.d2;
    _179 += _171;
    _166.data[_179] = _174;
    _171++;
    if (_171 < _169)
    goto _jump81;
    _171 = 0;
    _172++;
    if (_172 < _168)
    goto _jump81;
    _172 = 0;
    _173++;
    if (_173 < _167)
    goto _jump81;
    // End body of loop
    int64_t _180 = 2;
    bool _181 = true;
    int64_t _182;
    if (!_181)
    goto _jump85;
    int64_t _183 = 140;
    _182 = _183;
    goto _jump86;
    _jump85:;
    int64_t _184 = 128;
    _182 = _184;
    _jump86:;
    int64_t _185 = -_182;
    int64_t _186 = 854;
    int64_t _187 = -_186;
    if (_180 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_180 < _166.d0)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    if (_185 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (_185 < _166.d1)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    if (_187 >= 0)
    goto _jump91;
    fail_assertion("negative array index");
    _jump91:;
    if (_187 < _166.d2)
    goto _jump92;
    fail_assertion("index too large");
    _jump92:;
    int64_t _188 = 0;
    _188 *= _166.d0;
    _188 += _180;
    _188 *= _166.d1;
    _188 += _185;
    _188 *= _166.d2;
    _188 += _187;
    int64_t _189 = _166.data[_188];
    _165.d0 = _189;
    if (_189 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing bound for c
    int64_t _190;
    // Computing bound for b
    int64_t _191 = 171;
    if (_191 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    // Computing bound for c
    int64_t _192 = 157;
    if (_192 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    _190 = 0;
    int64_t _193 = 0; // c
    int64_t _194 = 0; // b
    _jump96:; // Begin body of loop
    _190 += _194;
    _193++;
    if (_193 < _192)
    goto _jump96;
    _193 = 0;
    _194++;
    if (_194 < _191)
    goto _jump96;
    // End body of loop
    int64_t _195 = 84;
    int64_t _196 = -_195;
    int64_t _197 = _190 + _196;
    int64_t _198 = -_197;
    _165.d1 = _198;
    if (_198 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing total size of heap memory to allocate
    int64_t _199 = 1;
    _199 *= _189;
    _199 *= _198;
    _199 *= sizeof(_a3__a2__a3_int64_t);
    _165.data = jpl_alloc(_199);
    int64_t _200 = 0; // c
    int64_t _201 = 0; // b
    _jump98:; // Begin body of loop
    _a3__a2__a3_int64_t _202;
    // Computing bound for d
    int64_t _203 = 689;
    int64_t _204 = _201 * _200;
    int64_t _205 = _203 - _204;
    _202.d0 = _205;
    if (_205 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing bound for e
    int64_t _206 = -_200;
    _202.d1 = _206;
    if (_206 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    // Computing bound for f
    bool _207 = false;
    bool _208 = !_207;
    int64_t _209;
    if (!_208)
    goto _jump101;
    int64_t _210 = 621;
    _209 = _210;
    goto _jump102;
    _jump101:;
    int64_t _211 = 694;
    int64_t _212 = _200 % _211;
    _209 = _212;
    _jump102:;
    _202.d2 = _209;
    if (_209 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= _205;
    _213 *= _206;
    _213 *= _209;
    _213 *= sizeof(_a2__a3_int64_t);
    _202.data = jpl_alloc(_213);
    int64_t _214 = 0; // f
    int64_t _215 = 0; // e
    int64_t _216 = 0; // d
    _jump104:; // Begin body of loop
    _a2__a3_int64_t _217;
    // Computing bound for g
    _217.d0 = _201;
    if (_201 > 0) 
    goto _jump105;
    fail_assertion("non-positive loop bound");
    _jump105:;
    // Computing bound for h
    _217.d1 = _215;
    if (_215 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing total size of heap memory to allocate
    int64_t _218 = 1;
    _218 *= _201;
    _218 *= _215;
    _218 *= sizeof(_a3_int64_t);
    _217.data = jpl_alloc(_218);
    int64_t _219 = 0; // h
    int64_t _220 = 0; // g
    _jump107:; // Begin body of loop
    _a3_int64_t _221;
    // Computing bound for i
    _221.d0 = _200;
    if (_200 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    // Computing bound for j
    _221.d1 = _214;
    if (_214 > 0) 
    goto _jump109;
    fail_assertion("non-positive loop bound");
    _jump109:;
    // Computing bound for k
    _221.d2 = _215;
    if (_215 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing total size of heap memory to allocate
    int64_t _222 = 1;
    _222 *= _200;
    _222 *= _214;
    _222 *= _215;
    _222 *= sizeof(int64_t);
    _221.data = jpl_alloc(_222);
    int64_t _223 = 0; // k
    int64_t _224 = 0; // j
    int64_t _225 = 0; // i
    _jump111:; // Begin body of loop
    int64_t _226 = 108;
    int64_t _227 = 0;
    _227 *= _221.d0;
    _227 += _225;
    _227 *= _221.d1;
    _227 += _224;
    _227 *= _221.d2;
    _227 += _223;
    _221.data[_227] = _226;
    _223++;
    if (_223 < _215)
    goto _jump111;
    _223 = 0;
    _224++;
    if (_224 < _214)
    goto _jump111;
    _224 = 0;
    _225++;
    if (_225 < _200)
    goto _jump111;
    // End body of loop
    int64_t _228 = 0;
    _228 *= _217.d0;
    _228 += _220;
    _228 *= _217.d1;
    _228 += _219;
    _217.data[_228] = _221;
    _219++;
    if (_219 < _215)
    goto _jump107;
    _219 = 0;
    _220++;
    if (_220 < _201)
    goto _jump107;
    // End body of loop
    int64_t _229 = 0;
    _229 *= _202.d0;
    _229 += _216;
    _229 *= _202.d1;
    _229 += _215;
    _229 *= _202.d2;
    _229 += _214;
    _202.data[_229] = _217;
    _214++;
    if (_214 < _209)
    goto _jump104;
    _214 = 0;
    _215++;
    if (_215 < _206)
    goto _jump104;
    _215 = 0;
    _216++;
    if (_216 < _205)
    goto _jump104;
    // End body of loop
    int64_t _230 = 0;
    _230 *= _165.d0;
    _230 += _201;
    _230 *= _165.d1;
    _230 += _200;
    _165.data[_230] = _202;
    _200++;
    if (_200 < _198)
    goto _jump98;
    _200 = 0;
    _201++;
    if (_201 < _189)
    goto _jump98;
    // End body of loop
    _a2_int64_t _231;
    // Computing bound for b
    int64_t _232 = 792;
    _231.d0 = _232;
    if (_232 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing bound for c
    int64_t _233 = 994;
    _231.d1 = _233;
    if (_233 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= _232;
    _234 *= _233;
    _234 *= sizeof(int64_t);
    _231.data = jpl_alloc(_234);
    int64_t _235 = 0; // c
    int64_t _236 = 0; // b
    _jump114:; // Begin body of loop
    int64_t _237 = 805;
    int64_t _238 = 0;
    _238 *= _231.d0;
    _238 += _236;
    _238 *= _231.d1;
    _238 += _235;
    _231.data[_238] = _237;
    _235++;
    if (_235 < _233)
    goto _jump114;
    _235 = 0;
    _236++;
    if (_236 < _232)
    goto _jump114;
    // End body of loop
    int64_t _239 = 206;
    int64_t _240;
    // Computing bound for b
    int64_t _241 = 951;
    if (_241 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing bound for c
    int64_t _242 = 584;
    if (_242 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _240 = 0;
    int64_t _243 = 0; // c
    int64_t _244 = 0; // b
    _jump117:; // Begin body of loop
    int64_t _245 = 82;
    _240 += _245;
    _243++;
    if (_243 < _242)
    goto _jump117;
    _243 = 0;
    _244++;
    if (_244 < _241)
    goto _jump117;
    // End body of loop
    if (_239 >= 0)
    goto _jump118;
    fail_assertion("negative array index");
    _jump118:;
    if (_239 < _231.d0)
    goto _jump119;
    fail_assertion("index too large");
    _jump119:;
    if (_240 >= 0)
    goto _jump120;
    fail_assertion("negative array index");
    _jump120:;
    if (_240 < _231.d1)
    goto _jump121;
    fail_assertion("index too large");
    _jump121:;
    int64_t _246 = 0;
    _246 *= _231.d0;
    _246 += _239;
    _246 *= _231.d1;
    _246 += _240;
    int64_t _247 = _231.data[_246];
    int64_t _248 = -_247;
    int64_t _249 = 116;
    if (_248 >= 0)
    goto _jump122;
    fail_assertion("negative array index");
    _jump122:;
    if (_248 < _165.d0)
    goto _jump123;
    fail_assertion("index too large");
    _jump123:;
    if (_249 >= 0)
    goto _jump124;
    fail_assertion("negative array index");
    _jump124:;
    if (_249 < _165.d1)
    goto _jump125;
    fail_assertion("index too large");
    _jump125:;
    int64_t _250 = 0;
    _250 *= _165.d0;
    _250 += _248;
    _250 *= _165.d1;
    _250 += _249;
    _a3__a2__a3_int64_t _251 = _165.data[_250];
    bool _252 = false;
    bool _253 = !_252;
    bool _254 = !_253;
    int64_t _255;
    if (!_254)
    goto _jump126;
    bool _257 = true;
    bool _258;
    if (!_257)
    goto _jump127;
    bool _259 = false;
    _258 = _259;
    goto _jump128;
    _jump127:;
    bool _260 = false;
    _258 = _260;
    _jump128:;
    bool _256 = _258;
    if (0 != _258)
    goto _jump129;
    bool _261 = true;
    _256 = _261;
    _jump129:;
    bool _262;
    if (!_256)
    goto _jump130;
    bool _264 = true;
    bool _265;
    if (!_264)
    goto _jump131;
    bool _266 = true;
    _265 = _266;
    goto _jump132;
    _jump131:;
    bool _267 = true;
    _265 = _267;
    _jump132:;
    bool _263 = _265;
    if (0 == _265)
    goto _jump133;
    bool _268 = true;
    _263 = _268;
    _jump133:;
    _262 = _263;
    goto _jump134;
    _jump130:;
    int64_t _270 = 380;
    int64_t _271 = 563;
    bool _272 = _270 < _271;
    bool _269 = _272;
    if (0 == _272)
    goto _jump135;
    bool _273 = false;
    _269 = _273;
    _jump135:;
    _262 = _269;
    _jump134:;
    int64_t _274;
    if (!_262)
    goto _jump136;
    int64_t _275 = 731;
    _274 = _275;
    goto _jump137;
    _jump136:;
    int64_t _276 = 838;
    _274 = _276;
    _jump137:;
    _255 = _274;
    goto _jump138;
    _jump126:;
    bool _277 = false;
    bool _278 = !_277;
    bool _279 = !_278;
    bool _280;
    if (!_279)
    goto _jump139;
    bool _281 = true;
    _280 = _281;
    goto _jump140;
    _jump139:;
    bool _282 = true;
    _280 = _282;
    _jump140:;
    int64_t _283;
    if (!_280)
    goto _jump141;
    int64_t _284 = 494;
    _283 = _284;
    goto _jump142;
    _jump141:;
    int64_t _285 = 363;
    _283 = _285;
    _jump142:;
    _255 = _283;
    _jump138:;
    bool _286 = true;
    bool _287 = true;
    bool _288 = true;
    _a1_bool _289;
    _289.d0 = 3;
    _289.data = jpl_alloc(sizeof(bool) * 3);
    _289.data[0] = _286;
    _289.data[1] = _287;
    _289.data[2] = _288;
    int64_t _290 = 277;
    if (_290 >= 0)
    goto _jump143;
    fail_assertion("negative array index");
    _jump143:;
    if (_290 < _289.d0)
    goto _jump144;
    fail_assertion("index too large");
    _jump144:;
    int64_t _291 = 0;
    _291 *= _289.d0;
    _291 += _290;
    bool _292 = _289.data[_291];
    bool _293;
    if (!_292)
    goto _jump145;
    bool _294 = false;
    _293 = _294;
    goto _jump146;
    _jump145:;
    bool _296 = false;
    bool _295 = _296;
    if (0 != _296)
    goto _jump147;
    bool _297 = false;
    _295 = _297;
    _jump147:;
    _293 = _295;
    _jump146:;
    int64_t _298;
    if (!_293)
    goto _jump148;
    int64_t _299 = 44;
    int64_t _300 = -_299;
    int64_t _301 = -_300;
    double _302 = 32.0;
    bool _303 = _302 != _47;
    int64_t _304;
    if (!_303)
    goto _jump149;
    int64_t _305 = 335;
    _304 = _305;
    goto _jump150;
    _jump149:;
    int64_t _306 = 290;
    int64_t _307 = 994;
    int64_t _308 = _306 % _307;
    _304 = _308;
    _jump150:;
    int64_t _309 = _301 * _304;
    _298 = _309;
    goto _jump151;
    _jump148:;
    bool _310 = false;
    int64_t _311;
    if (!_310)
    goto _jump152;
    int64_t _312 = 885;
    int64_t _313 = -_312;
    _311 = _313;
    goto _jump153;
    _jump152:;
    int64_t _314;
    // Computing bound for b
    int64_t _315 = 449;
    int64_t _316 = 252;
    int64_t _317 = _315 / _316;
    if (_317 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    _314 = 0;
    int64_t _318 = 0; // b
    _jump155:; // Begin body of loop
    int64_t _319 = 170;
    int64_t _320 = _319 * _318;
    _314 += _320;
    _318++;
    if (_318 < _317)
    goto _jump155;
    // End body of loop
    _311 = _314;
    _jump153:;
    _298 = _311;
    _jump151:;
    int64_t _321 = -_298;
    _a3_bool _322;
    // Computing bound for b
    int64_t _323 = 232;
    _322.d0 = _323;
    if (_323 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing bound for c
    int64_t _324 = 10;
    int64_t _325;
    // Computing bound for b
    int64_t _326 = 181;
    if (_326 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    _325 = 0;
    int64_t _327 = 0; // b
    _jump158:; // Begin body of loop
    _325 += _327;
    _327++;
    if (_327 < _326)
    goto _jump158;
    // End body of loop
    int64_t _328 = _324 - _325;
    _322.d1 = _328;
    if (_328 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing bound for d
    int64_t _329 = 868;
    _322.d2 = _329;
    if (_329 > 0) 
    goto _jump160;
    fail_assertion("non-positive loop bound");
    _jump160:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= _323;
    _330 *= _328;
    _330 *= _329;
    _330 *= sizeof(bool);
    _322.data = jpl_alloc(_330);
    int64_t _331 = 0; // d
    int64_t _332 = 0; // c
    int64_t _333 = 0; // b
    _jump161:; // Begin body of loop
    bool _334 = true;
    bool _335 = !_334;
    int64_t _336 = 0;
    _336 *= _322.d0;
    _336 += _333;
    _336 *= _322.d1;
    _336 += _332;
    _336 *= _322.d2;
    _336 += _331;
    _322.data[_336] = _335;
    _331++;
    if (_331 < _329)
    goto _jump161;
    _331 = 0;
    _332++;
    if (_332 < _328)
    goto _jump161;
    _332 = 0;
    _333++;
    if (_333 < _323)
    goto _jump161;
    // End body of loop
    int64_t _337;
    // Computing bound for b
    int64_t _338 = 565;
    if (_338 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    // Computing bound for c
    int64_t _339 = 478;
    if (_339 > 0) 
    goto _jump163;
    fail_assertion("non-positive loop bound");
    _jump163:;
    // Computing bound for d
    int64_t _340 = 121;
    if (_340 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    _337 = 0;
    int64_t _341 = 0; // d
    int64_t _342 = 0; // c
    int64_t _343 = 0; // b
    _jump165:; // Begin body of loop
    _337 += _343;
    _341++;
    if (_341 < _340)
    goto _jump165;
    _341 = 0;
    _342++;
    if (_342 < _339)
    goto _jump165;
    _342 = 0;
    _343++;
    if (_343 < _338)
    goto _jump165;
    // End body of loop
    int64_t _344 = 42;
    _a1_int64_t _345;
    _345.d0 = 2;
    _345.data = jpl_alloc(sizeof(int64_t) * 2);
    _345.data[0] = _337;
    _345.data[1] = _344;
    int64_t _346;
    // Computing bound for b
    int64_t _347 = 282;
    if (_347 > 0) 
    goto _jump166;
    fail_assertion("non-positive loop bound");
    _jump166:;
    // Computing bound for c
    int64_t _348 = 877;
    int64_t _349 = 876;
    int64_t _350 = _348 % _349;
    if (_350 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    _346 = 0;
    int64_t _351 = 0; // c
    int64_t _352 = 0; // b
    _jump168:; // Begin body of loop
    int64_t _353;
    // Computing bound for d
    int64_t _354 = 421;
    if (_354 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    // Computing bound for e
    int64_t _355 = 852;
    if (_355 > 0) 
    goto _jump170;
    fail_assertion("non-positive loop bound");
    _jump170:;
    // Computing bound for f
    if (_352 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    _353 = 0;
    int64_t _356 = 0; // f
    int64_t _357 = 0; // e
    int64_t _358 = 0; // d
    _jump172:; // Begin body of loop
    _353 += _358;
    _356++;
    if (_356 < _352)
    goto _jump172;
    _356 = 0;
    _357++;
    if (_357 < _355)
    goto _jump172;
    _357 = 0;
    _358++;
    if (_358 < _354)
    goto _jump172;
    // End body of loop
    _346 += _353;
    _351++;
    if (_351 < _350)
    goto _jump168;
    _351 = 0;
    _352++;
    if (_352 < _347)
    goto _jump168;
    // End body of loop
    if (_346 >= 0)
    goto _jump173;
    fail_assertion("negative array index");
    _jump173:;
    if (_346 < _345.d0)
    goto _jump174;
    fail_assertion("index too large");
    _jump174:;
    int64_t _359 = 0;
    _359 *= _345.d0;
    _359 += _346;
    int64_t _360 = _345.data[_359];
    int64_t _361 = 777;
    int64_t _362 = 410;
    int64_t _363 = _361 % _362;
    bool _364 = false;
    bool _365 = false;
    bool _366 = _364 != _365;
    bool _367 = true;
    bool _368 = _366 != _367;
    int64_t _369;
    if (!_368)
    goto _jump175;
    int64_t _370;
    // Computing bound for b
    int64_t _371 = 749;
    if (_371 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    _370 = 0;
    int64_t _372 = 0; // b
    _jump177:; // Begin body of loop
    int64_t _373 = -_372;
    _370 += _373;
    _372++;
    if (_372 < _371)
    goto _jump177;
    // End body of loop
    _369 = _370;
    goto _jump178;
    _jump175:;
    int64_t _374 = 716;
    _369 = _374;
    _jump178:;
    if (_360 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_360 < _322.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    if (_363 >= 0)
    goto _jump181;
    fail_assertion("negative array index");
    _jump181:;
    if (_363 < _322.d1)
    goto _jump182;
    fail_assertion("index too large");
    _jump182:;
    if (_369 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (_369 < _322.d2)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    int64_t _375 = 0;
    _375 *= _322.d0;
    _375 += _360;
    _375 *= _322.d1;
    _375 += _363;
    _375 *= _322.d2;
    _375 += _369;
    bool _376 = _322.data[_375];
    int64_t _377;
    if (!_376)
    goto _jump185;
    _a3_int64_t _378;
    // Computing bound for b
    int64_t _379 = 200;
    _378.d0 = _379;
    if (_379 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing bound for c
    _a2_int64_t _380;
    // Computing bound for b
    int64_t _381 = 769;
    _380.d0 = _381;
    if (_381 > 0) 
    goto _jump187;
    fail_assertion("non-positive loop bound");
    _jump187:;
    // Computing bound for c
    int64_t _382 = 609;
    _380.d1 = _382;
    if (_382 > 0) 
    goto _jump188;
    fail_assertion("non-positive loop bound");
    _jump188:;
    // Computing total size of heap memory to allocate
    int64_t _383 = 1;
    _383 *= _381;
    _383 *= _382;
    _383 *= sizeof(int64_t);
    _380.data = jpl_alloc(_383);
    int64_t _384 = 0; // c
    int64_t _385 = 0; // b
    _jump189:; // Begin body of loop
    int64_t _386 = 0;
    _386 *= _380.d0;
    _386 += _385;
    _386 *= _380.d1;
    _386 += _384;
    _380.data[_386] = _385;
    _384++;
    if (_384 < _382)
    goto _jump189;
    _384 = 0;
    _385++;
    if (_385 < _381)
    goto _jump189;
    // End body of loop
    int64_t _387 = 312;
    int64_t _388 = 797;
    if (_387 >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (_387 < _380.d0)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    if (_388 >= 0)
    goto _jump192;
    fail_assertion("negative array index");
    _jump192:;
    if (_388 < _380.d1)
    goto _jump193;
    fail_assertion("index too large");
    _jump193:;
    int64_t _389 = 0;
    _389 *= _380.d0;
    _389 += _387;
    _389 *= _380.d1;
    _389 += _388;
    int64_t _390 = _380.data[_389];
    _378.d1 = _390;
    if (_390 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for d
    bool _391 = true;
    bool _392 = !_391;
    int64_t _393;
    if (!_392)
    goto _jump195;
    int64_t _394 = 92;
    _393 = _394;
    goto _jump196;
    _jump195:;
    int64_t _395 = 283;
    int64_t _396 = -_395;
    _393 = _396;
    _jump196:;
    _378.d2 = _393;
    if (_393 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing total size of heap memory to allocate
    int64_t _397 = 1;
    _397 *= _379;
    _397 *= _390;
    _397 *= _393;
    _397 *= sizeof(int64_t);
    _378.data = jpl_alloc(_397);
    int64_t _398 = 0; // d
    int64_t _399 = 0; // c
    int64_t _400 = 0; // b
    _jump198:; // Begin body of loop
    int64_t _401 = 0;
    _401 *= _378.d0;
    _401 += _400;
    _401 *= _378.d1;
    _401 += _399;
    _401 *= _378.d2;
    _401 += _398;
    _378.data[_401] = _398;
    _398++;
    if (_398 < _393)
    goto _jump198;
    _398 = 0;
    _399++;
    if (_399 < _390)
    goto _jump198;
    _399 = 0;
    _400++;
    if (_400 < _379)
    goto _jump198;
    // End body of loop
    int64_t _402;
    // Computing bound for b
    int64_t _403 = 575;
    int64_t _404 = -_403;
    if (_404 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    _402 = 0;
    int64_t _405 = 0; // b
    _jump200:; // Begin body of loop
    _402 += _405;
    _405++;
    if (_405 < _404)
    goto _jump200;
    // End body of loop
    int64_t _406 = 798;
    _a1_int64_t _407;
    // Computing bound for b
    int64_t _408 = 45;
    _407.d0 = _408;
    if (_408 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing total size of heap memory to allocate
    int64_t _409 = 1;
    _409 *= _408;
    _409 *= sizeof(int64_t);
    _407.data = jpl_alloc(_409);
    int64_t _410 = 0; // b
    _jump202:; // Begin body of loop
    int64_t _411 = 526;
    int64_t _412 = 0;
    _412 *= _407.d0;
    _412 += _410;
    _407.data[_412] = _411;
    _410++;
    if (_410 < _408)
    goto _jump202;
    // End body of loop
    int64_t _413 = 583;
    if (_413 >= 0)
    goto _jump203;
    fail_assertion("negative array index");
    _jump203:;
    if (_413 < _407.d0)
    goto _jump204;
    fail_assertion("index too large");
    _jump204:;
    int64_t _414 = 0;
    _414 *= _407.d0;
    _414 += _413;
    int64_t _415 = _407.data[_414];
    int64_t _416 = 282;
    int64_t _417 = _415 % _416;
    if (_402 >= 0)
    goto _jump205;
    fail_assertion("negative array index");
    _jump205:;
    if (_402 < _378.d0)
    goto _jump206;
    fail_assertion("index too large");
    _jump206:;
    if (_406 >= 0)
    goto _jump207;
    fail_assertion("negative array index");
    _jump207:;
    if (_406 < _378.d1)
    goto _jump208;
    fail_assertion("index too large");
    _jump208:;
    if (_417 >= 0)
    goto _jump209;
    fail_assertion("negative array index");
    _jump209:;
    if (_417 < _378.d2)
    goto _jump210;
    fail_assertion("index too large");
    _jump210:;
    int64_t _418 = 0;
    _418 *= _378.d0;
    _418 += _402;
    _418 *= _378.d1;
    _418 += _406;
    _418 *= _378.d2;
    _418 += _417;
    int64_t _419 = _378.data[_418];
    _377 = _419;
    goto _jump211;
    _jump185:;
    bool _421 = true;
    bool _422 = !_421;
    bool _420 = _422;
    if (0 != _422)
    goto _jump212;
    bool _423 = false;
    _420 = _423;
    _jump212:;
    int64_t _424;
    if (!_420)
    goto _jump213;
    _a1_int64_t _425;
    // Computing bound for b
    int64_t _426 = 794;
    _425.d0 = _426;
    if (_426 > 0) 
    goto _jump214;
    fail_assertion("non-positive loop bound");
    _jump214:;
    // Computing total size of heap memory to allocate
    int64_t _427 = 1;
    _427 *= _426;
    _427 *= sizeof(int64_t);
    _425.data = jpl_alloc(_427);
    int64_t _428 = 0; // b
    _jump215:; // Begin body of loop
    int64_t _429 = 765;
    int64_t _430 = 0;
    _430 *= _425.d0;
    _430 += _428;
    _425.data[_430] = _429;
    _428++;
    if (_428 < _426)
    goto _jump215;
    // End body of loop
    int64_t _431 = 907;
    if (_431 >= 0)
    goto _jump216;
    fail_assertion("negative array index");
    _jump216:;
    if (_431 < _425.d0)
    goto _jump217;
    fail_assertion("index too large");
    _jump217:;
    int64_t _432 = 0;
    _432 *= _425.d0;
    _432 += _431;
    int64_t _433 = _425.data[_432];
    _424 = _433;
    goto _jump218;
    _jump213:;
    int64_t _434 = 436;
    int64_t _435 = 652;
    int64_t _436 = _434 * _435;
    _424 = _436;
    _jump218:;
    int64_t _437 = -_424;
    _377 = _437;
    _jump211:;
    if (_255 >= 0)
    goto _jump219;
    fail_assertion("negative array index");
    _jump219:;
    if (_255 < _251.d0)
    goto _jump220;
    fail_assertion("index too large");
    _jump220:;
    if (_321 >= 0)
    goto _jump221;
    fail_assertion("negative array index");
    _jump221:;
    if (_321 < _251.d1)
    goto _jump222;
    fail_assertion("index too large");
    _jump222:;
    if (_377 >= 0)
    goto _jump223;
    fail_assertion("negative array index");
    _jump223:;
    if (_377 < _251.d2)
    goto _jump224;
    fail_assertion("index too large");
    _jump224:;
    int64_t _438 = 0;
    _438 *= _251.d0;
    _438 += _255;
    _438 *= _251.d1;
    _438 += _321;
    _438 *= _251.d2;
    _438 += _377;
    _a2__a3_int64_t _439 = _251.data[_438];
    int64_t _440;
    // Computing bound for b
    int64_t _441 = 412;
    int64_t _442 = 397;
    int64_t _443 = _441 / _442;
    if (_443 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    _440 = 0;
    int64_t _444 = 0; // b
    _jump226:; // Begin body of loop
    int64_t _445;
    // Computing bound for c
    int64_t _446;
    // Computing bound for c
    int64_t _447 = 885;
    if (_447 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing bound for d
    int64_t _448 = 750;
    if (_448 > 0) 
    goto _jump228;
    fail_assertion("non-positive loop bound");
    _jump228:;
    // Computing bound for e
    if (_444 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    _446 = 0;
    int64_t _449 = 0; // e
    int64_t _450 = 0; // d
    int64_t _451 = 0; // c
    _jump230:; // Begin body of loop
    _446 += _444;
    _449++;
    if (_449 < _444)
    goto _jump230;
    _449 = 0;
    _450++;
    if (_450 < _448)
    goto _jump230;
    _450 = 0;
    _451++;
    if (_451 < _447)
    goto _jump230;
    // End body of loop
    int64_t _452 = _446 + _444;
    int64_t _453 = _444 - _452;
    int64_t _454 = -_453;
    if (_454 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    _445 = 0;
    int64_t _455 = 0; // c
    _jump232:; // Begin body of loop
    _445 += _455;
    _455++;
    if (_455 < _454)
    goto _jump232;
    // End body of loop
    _440 += _445;
    _444++;
    if (_444 < _443)
    goto _jump226;
    // End body of loop
    int64_t _456;
    // Computing bound for b
    int64_t _457 = 331;
    int64_t _458 = -_457;
    if (_458 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    // Computing bound for c
    int64_t _459;
    // Computing bound for b
    int64_t _460 = 123;
    int64_t _461 = -_460;
    if (_461 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing bound for c
    int64_t _462 = 446;
    if (_462 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing bound for d
    int64_t _463 = 159;
    if (_463 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    _459 = 0;
    int64_t _464 = 0; // d
    int64_t _465 = 0; // c
    int64_t _466 = 0; // b
    _jump237:; // Begin body of loop
    bool _467 = false;
    int64_t _468;
    if (!_467)
    goto _jump238;
    _a1_int64_t _469;
    // Computing bound for e
    _469.d0 = _464;
    if (_464 > 0) 
    goto _jump239;
    fail_assertion("non-positive loop bound");
    _jump239:;
    // Computing total size of heap memory to allocate
    int64_t _470 = 1;
    _470 *= _464;
    _470 *= sizeof(int64_t);
    _469.data = jpl_alloc(_470);
    int64_t _471 = 0; // e
    _jump240:; // Begin body of loop
    int64_t _472 = 0;
    _472 *= _469.d0;
    _472 += _471;
    _469.data[_472] = _464;
    _471++;
    if (_471 < _464)
    goto _jump240;
    // End body of loop
    if (_464 >= 0)
    goto _jump241;
    fail_assertion("negative array index");
    _jump241:;
    if (_464 < _469.d0)
    goto _jump242;
    fail_assertion("index too large");
    _jump242:;
    int64_t _473 = 0;
    _473 *= _469.d0;
    _473 += _464;
    int64_t _474 = _469.data[_473];
    _468 = _474;
    goto _jump243;
    _jump238:;
    _a2_int64_t _475;
    // Computing bound for e
    _475.d0 = _464;
    if (_464 > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing bound for f
    _475.d1 = _466;
    if (_466 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _476 = 1;
    _476 *= _464;
    _476 *= _466;
    _476 *= sizeof(int64_t);
    _475.data = jpl_alloc(_476);
    int64_t _477 = 0; // f
    int64_t _478 = 0; // e
    _jump246:; // Begin body of loop
    int64_t _479 = 0;
    _479 *= _475.d0;
    _479 += _478;
    _479 *= _475.d1;
    _479 += _477;
    _475.data[_479] = _478;
    _477++;
    if (_477 < _466)
    goto _jump246;
    _477 = 0;
    _478++;
    if (_478 < _464)
    goto _jump246;
    // End body of loop
    int64_t _480 = 964;
    if (_480 >= 0)
    goto _jump247;
    fail_assertion("negative array index");
    _jump247:;
    if (_480 < _475.d0)
    goto _jump248;
    fail_assertion("index too large");
    _jump248:;
    if (_466 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (_466 < _475.d1)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    int64_t _481 = 0;
    _481 *= _475.d0;
    _481 += _480;
    _481 *= _475.d1;
    _481 += _466;
    int64_t _482 = _475.data[_481];
    _468 = _482;
    _jump243:;
    _459 += _468;
    _464++;
    if (_464 < _463)
    goto _jump237;
    _464 = 0;
    _465++;
    if (_465 < _462)
    goto _jump237;
    _465 = 0;
    _466++;
    if (_466 < _461)
    goto _jump237;
    // End body of loop
    int64_t _483 = 997;
    int64_t _484 = 905;
    int64_t _485 = _483 % _484;
    bool _486 = false;
    int64_t _487;
    if (!_486)
    goto _jump251;
    int64_t _488 = 362;
    _487 = _488;
    goto _jump252;
    _jump251:;
    bool _489 = true;
    int64_t _490;
    if (!_489)
    goto _jump253;
    int64_t _491 = 437;
    int64_t _492 = 406;
    int64_t _493 = _491 % _492;
    _490 = _493;
    goto _jump254;
    _jump253:;
    int64_t _494 = 822;
    _490 = _494;
    _jump254:;
    _487 = _490;
    _jump252:;
    int64_t _495 = _485 * _487;
    int64_t _496 = _459 * _495;
    if (_496 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    _456 = 0;
    int64_t _497 = 0; // c
    int64_t _498 = 0; // b
    _jump256:; // Begin body of loop
    int64_t _499;
    // Computing bound for d
    int64_t _500 = -_497;
    if (_500 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    _499 = 0;
    int64_t _501 = 0; // d
    _jump258:; // Begin body of loop
    int64_t _502 = 498;
    _499 += _502;
    _501++;
    if (_501 < _500)
    goto _jump258;
    // End body of loop
    int64_t _503 = 997;
    int64_t _504 = -_503;
    int64_t _505 = _499 / _504;
    _456 += _505;
    _497++;
    if (_497 < _496)
    goto _jump256;
    _497 = 0;
    _498++;
    if (_498 < _458)
    goto _jump256;
    // End body of loop
    if (_440 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_440 < _439.d0)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    if (_456 >= 0)
    goto _jump261;
    fail_assertion("negative array index");
    _jump261:;
    if (_456 < _439.d1)
    goto _jump262;
    fail_assertion("index too large");
    _jump262:;
    int64_t _506 = 0;
    _506 *= _439.d0;
    _506 += _440;
    _506 *= _439.d1;
    _506 += _456;
    _a3_int64_t _507 = _439.data[_506];
    int64_t _510 = _507.d2 * _507.d2;
    int64_t _511 = _510 * _507.d0;
    int64_t _512 = -_511;
    bool _513 = _512 > _507.d1;
    bool _509 = _513;
    if (0 != _513)
    goto _jump521;
    double _514 = 28.0;
    double _515 = -_514;
    bool _516 = _515 != _47;
    _509 = _516;
    _jump521:;
    bool _508 = _509;
    if (0 != _509)
    goto _jump522;
    _a1_int64_t _517;
    // Computing bound for g
    int64_t _518 = 233;
    _517.d0 = _518;
    if (_518 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing total size of heap memory to allocate
    int64_t _519 = 1;
    _519 *= _518;
    _519 *= sizeof(int64_t);
    _517.data = jpl_alloc(_519);
    int64_t _520 = 0; // g
    _jump524:; // Begin body of loop
    int64_t _521 = 0;
    _521 *= _517.d0;
    _521 += _520;
    _517.data[_521] = _507.d2;
    _520++;
    if (_520 < _518)
    goto _jump524;
    // End body of loop
    if (_507.d1 >= 0)
    goto _jump525;
    fail_assertion("negative array index");
    _jump525:;
    if (_507.d1 < _517.d0)
    goto _jump526;
    fail_assertion("index too large");
    _jump526:;
    int64_t _522 = 0;
    _522 *= _517.d0;
    _522 += _507.d1;
    int64_t _523 = _517.data[_522];
    bool _524 = _523 >= _507.d2;
    bool _525 = !_524;
    _508 = _525;
    _jump522:;
    _a3_int64_t _526;
    if (!_508)
    goto _jump527;
    _526 = _507;
    goto _jump528;
    _jump527:;
    _526 = _507;
    _jump528:;
    _a3_rgba _527;
    // Computing bound for k
    int64_t _528 = 518;
    int64_t _529 = -_528;
    _527.d0 = _529;
    if (_529 > 0) 
    goto _jump529;
    fail_assertion("non-positive loop bound");
    _jump529:;
    // Computing bound for l
    _a1_bool _530;
    // Computing bound for k
    _530.d0 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump530;
    fail_assertion("non-positive loop bound");
    _jump530:;
    // Computing total size of heap memory to allocate
    int64_t _531 = 1;
    _531 *= _507.d2;
    _531 *= sizeof(bool);
    _530.data = jpl_alloc(_531);
    int64_t _532 = 0; // k
    _jump531:; // Begin body of loop
    bool _533 = true;
    int64_t _534 = 0;
    _534 *= _530.d0;
    _534 += _532;
    _530.data[_534] = _533;
    _532++;
    if (_532 < _507.d2)
    goto _jump531;
    // End body of loop
    int64_t _535 = 540;
    if (_535 >= 0)
    goto _jump532;
    fail_assertion("negative array index");
    _jump532:;
    if (_535 < _530.d0)
    goto _jump533;
    fail_assertion("index too large");
    _jump533:;
    int64_t _536 = 0;
    _536 *= _530.d0;
    _536 += _535;
    bool _537 = _530.data[_536];
    bool _538 = !_537;
    bool _539;
    if (!_538)
    goto _jump534;
    double _540 = 3.0;
    bool _541 = _540 < _47;
    _539 = _541;
    goto _jump535;
    _jump534:;
    bool _542 = false;
    _539 = _542;
    _jump535:;
    bool _543 = !_539;
    int64_t _544;
    if (!_543)
    goto _jump536;
    _544 = _507.d1;
    goto _jump537;
    _jump536:;
    _544 = _526.d2;
    _jump537:;
    _527.d1 = _544;
    if (_544 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing bound for m
    _527.d2 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    // Computing total size of heap memory to allocate
    int64_t _545 = 1;
    _545 *= _529;
    _545 *= _544;
    _545 *= _507.d0;
    _545 *= sizeof(rgba);
    _527.data = jpl_alloc(_545);
    int64_t _546 = 0; // m
    int64_t _547 = 0; // l
    int64_t _548 = 0; // k
    _jump540:; // Begin body of loop
    bool _549 = _546 != _526.d0;
    bool _550 = !_549;
    double _551 = f(_550);
    double _552;
    // Computing bound for n
    if (_526.d0 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing bound for o
    if (_547 >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (_547 < _526.d0)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    if (_507.d0 >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (_507.d0 < _526.d1)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    if (_526.d2 >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (_526.d2 < _526.d2)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    int64_t _553 = 0;
    _553 *= _526.d0;
    _553 += _547;
    _553 *= _526.d1;
    _553 += _507.d0;
    _553 *= _526.d2;
    _553 += _526.d2;
    int64_t _554 = _526.data[_553];
    int64_t _555 = -_554;
    int64_t _556 = _555 * _526.d0;
    if (_556 > 0) 
    goto _jump548;
    fail_assertion("non-positive loop bound");
    _jump548:;
    // Computing bound for p
    bool _557 = _507.d2 > _507.d0;
    int64_t _558;
    if (!_557)
    goto _jump549;
    _558 = _547;
    goto _jump550;
    _jump549:;
    _558 = _526.d2;
    _jump550:;
    int64_t _559 = _558 * _526.d1;
    if (_559 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    _552 = 0;
    int64_t _560 = 0; // p
    int64_t _561 = 0; // o
    int64_t _562 = 0; // n
    _jump552:; // Begin body of loop
    _552 += _47;
    _560++;
    if (_560 < _559)
    goto _jump552;
    _560 = 0;
    _561++;
    if (_561 < _556)
    goto _jump552;
    _561 = 0;
    _562++;
    if (_562 < _526.d0)
    goto _jump552;
    // End body of loop
    bool _563 = _526.d2 != _526.d2;
    double _564 = f(_563);
    double _565 = -_564;
    double _566 = _552 + _565;
    bool _567 = false;
    double _568;
    if (!_567)
    goto _jump553;
    _a3_double _569;
    // Computing bound for n
    _569.d0 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for o
    _569.d1 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing bound for p
    _569.d2 = _547;
    if (_547 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing total size of heap memory to allocate
    int64_t _570 = 1;
    _570 *= _526.d2;
    _570 *= _507.d1;
    _570 *= _547;
    _570 *= sizeof(double);
    _569.data = jpl_alloc(_570);
    int64_t _571 = 0; // p
    int64_t _572 = 0; // o
    int64_t _573 = 0; // n
    _jump557:; // Begin body of loop
    double _574 = 90.0;
    double _575 = fmod(_47, _574);
    int64_t _576 = 0;
    _576 *= _569.d0;
    _576 += _573;
    _576 *= _569.d1;
    _576 += _572;
    _576 *= _569.d2;
    _576 += _571;
    _569.data[_576] = _575;
    _571++;
    if (_571 < _547)
    goto _jump557;
    _571 = 0;
    _572++;
    if (_572 < _507.d1)
    goto _jump557;
    _572 = 0;
    _573++;
    if (_573 < _526.d2)
    goto _jump557;
    // End body of loop
    bool _577 = false;
    int64_t _578;
    if (!_577)
    goto _jump558;
    _578 = _547;
    goto _jump559;
    _jump558:;
    int64_t _579 = -_526.d0;
    _578 = _579;
    _jump559:;
    if (_548 >= 0)
    goto _jump560;
    fail_assertion("negative array index");
    _jump560:;
    if (_548 < _569.d0)
    goto _jump561;
    fail_assertion("index too large");
    _jump561:;
    if (_578 >= 0)
    goto _jump562;
    fail_assertion("negative array index");
    _jump562:;
    if (_578 < _569.d1)
    goto _jump563;
    fail_assertion("index too large");
    _jump563:;
    if (_547 >= 0)
    goto _jump564;
    fail_assertion("negative array index");
    _jump564:;
    if (_547 < _569.d2)
    goto _jump565;
    fail_assertion("index too large");
    _jump565:;
    int64_t _580 = 0;
    _580 *= _569.d0;
    _580 += _548;
    _580 *= _569.d1;
    _580 += _578;
    _580 *= _569.d2;
    _580 += _547;
    double _581 = _569.data[_580];
    double _582 = -_581;
    _568 = _582;
    goto _jump566;
    _jump553:;
    _a1__a3_double _583;
    // Computing bound for n
    _583.d0 = _548;
    if (_548 > 0) 
    goto _jump567;
    fail_assertion("non-positive loop bound");
    _jump567:;
    // Computing total size of heap memory to allocate
    int64_t _584 = 1;
    _584 *= _548;
    _584 *= sizeof(_a3_double);
    _583.data = jpl_alloc(_584);
    int64_t _585 = 0; // n
    _jump568:; // Begin body of loop
    _a3_double _586;
    // Computing bound for o
    _586.d0 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump569;
    fail_assertion("non-positive loop bound");
    _jump569:;
    // Computing bound for p
    _586.d1 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for q
    _586.d2 = _547;
    if (_547 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _587 = 1;
    _587 *= _526.d0;
    _587 *= _526.d0;
    _587 *= _547;
    _587 *= sizeof(double);
    _586.data = jpl_alloc(_587);
    int64_t _588 = 0; // q
    int64_t _589 = 0; // p
    int64_t _590 = 0; // o
    _jump572:; // Begin body of loop
    double _591 = 77.0;
    int64_t _592 = 0;
    _592 *= _586.d0;
    _592 += _590;
    _592 *= _586.d1;
    _592 += _589;
    _592 *= _586.d2;
    _592 += _588;
    _586.data[_592] = _591;
    _588++;
    if (_588 < _547)
    goto _jump572;
    _588 = 0;
    _589++;
    if (_589 < _526.d0)
    goto _jump572;
    _589 = 0;
    _590++;
    if (_590 < _526.d0)
    goto _jump572;
    // End body of loop
    int64_t _593 = 0;
    _593 *= _583.d0;
    _593 += _585;
    _583.data[_593] = _586;
    _585++;
    if (_585 < _548)
    goto _jump568;
    // End body of loop
    int64_t _594 = 524;
    if (_594 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (_594 < _583.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    int64_t _595 = 0;
    _595 *= _583.d0;
    _595 += _594;
    _a3_double _596 = _583.data[_595];
    int64_t _597 = -_526.d0;
    int64_t _598 = _597 * _526.d1;
    if (_507.d2 >= 0)
    goto _jump575;
    fail_assertion("negative array index");
    _jump575:;
    if (_507.d2 < _596.d0)
    goto _jump576;
    fail_assertion("index too large");
    _jump576:;
    if (_598 >= 0)
    goto _jump577;
    fail_assertion("negative array index");
    _jump577:;
    if (_598 < _596.d1)
    goto _jump578;
    fail_assertion("index too large");
    _jump578:;
    if (_526.d2 >= 0)
    goto _jump579;
    fail_assertion("negative array index");
    _jump579:;
    if (_526.d2 < _596.d2)
    goto _jump580;
    fail_assertion("index too large");
    _jump580:;
    int64_t _599 = 0;
    _599 *= _596.d0;
    _599 += _507.d2;
    _599 *= _596.d1;
    _599 += _598;
    _599 *= _596.d2;
    _599 += _526.d2;
    double _600 = _596.data[_599];
    _568 = _600;
    _jump566:;
    _a2__a2_double _601;
    // Computing bound for n
    _601.d0 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing bound for o
    _601.d1 = _546;
    if (_546 > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    // Computing total size of heap memory to allocate
    int64_t _602 = 1;
    _602 *= _507.d0;
    _602 *= _546;
    _602 *= sizeof(_a2_double);
    _601.data = jpl_alloc(_602);
    int64_t _603 = 0; // o
    int64_t _604 = 0; // n
    _jump583:; // Begin body of loop
    _a2_double _605;
    // Computing bound for p
    _605.d0 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing bound for q
    _605.d1 = _546;
    if (_546 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing total size of heap memory to allocate
    int64_t _606 = 1;
    _606 *= _526.d2;
    _606 *= _546;
    _606 *= sizeof(double);
    _605.data = jpl_alloc(_606);
    int64_t _607 = 0; // q
    int64_t _608 = 0; // p
    _jump586:; // Begin body of loop
    bool _609 = false;
    double _610 = f(_609);
    int64_t _611 = 0;
    _611 *= _605.d0;
    _611 += _608;
    _611 *= _605.d1;
    _611 += _607;
    _605.data[_611] = _610;
    _607++;
    if (_607 < _546)
    goto _jump586;
    _607 = 0;
    _608++;
    if (_608 < _526.d2)
    goto _jump586;
    // End body of loop
    int64_t _612 = 0;
    _612 *= _601.d0;
    _612 += _604;
    _612 *= _601.d1;
    _612 += _603;
    _601.data[_612] = _605;
    _603++;
    if (_603 < _546)
    goto _jump583;
    _603 = 0;
    _604++;
    if (_604 < _507.d0)
    goto _jump583;
    // End body of loop
    if (_526.d0 >= 0)
    goto _jump587;
    fail_assertion("negative array index");
    _jump587:;
    if (_526.d0 < _601.d0)
    goto _jump588;
    fail_assertion("index too large");
    _jump588:;
    if (_546 >= 0)
    goto _jump589;
    fail_assertion("negative array index");
    _jump589:;
    if (_546 < _601.d1)
    goto _jump590;
    fail_assertion("index too large");
    _jump590:;
    int64_t _613 = 0;
    _613 *= _601.d0;
    _613 += _526.d0;
    _613 *= _601.d1;
    _613 += _546;
    _a2_double _614 = _601.data[_613];
    if (_526.d0 >= 0)
    goto _jump591;
    fail_assertion("negative array index");
    _jump591:;
    if (_526.d0 < _614.d0)
    goto _jump592;
    fail_assertion("index too large");
    _jump592:;
    if (_547 >= 0)
    goto _jump593;
    fail_assertion("negative array index");
    _jump593:;
    if (_547 < _614.d1)
    goto _jump594;
    fail_assertion("index too large");
    _jump594:;
    int64_t _615 = 0;
    _615 *= _614.d0;
    _615 += _526.d0;
    _615 *= _614.d1;
    _615 += _547;
    double _616 = _614.data[_615];
    rgba _617 = { _551, _566, _568, _616 };
    int64_t _618 = 0;
    _618 *= _527.d0;
    _618 += _548;
    _618 *= _527.d1;
    _618 += _547;
    _618 *= _527.d2;
    _618 += _546;
    _527.data[_618] = _617;
    _546++;
    if (_546 < _507.d0)
    goto _jump540;
    _546 = 0;
    _547++;
    if (_547 < _544)
    goto _jump540;
    _547 = 0;
    _548++;
    if (_548 < _529)
    goto _jump540;
    // End body of loop
    bool _621 = true;
    bool _620 = _621;
    if (0 != _621)
    goto _jump595;
    bool _622 = false;
    _620 = _622;
    _jump595:;
    bool _623;
    if (!_620)
    goto _jump596;
    bool _624 = true;
    _623 = _624;
    goto _jump597;
    _jump596:;
    bool _625 = true;
    _623 = _625;
    _jump597:;
    bool _619 = _623;
    if (0 == _623)
    goto _jump598;
    _a3_bool _626;
    // Computing bound for o
    int64_t _627 = 318;
    _626.d0 = _627;
    if (_627 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    // Computing bound for p
    int64_t _628 = 823;
    _626.d1 = _628;
    if (_628 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing bound for q
    _626.d2 = _527.d0;
    if (_527.d0 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    // Computing total size of heap memory to allocate
    int64_t _629 = 1;
    _629 *= _627;
    _629 *= _628;
    _629 *= _527.d0;
    _629 *= sizeof(bool);
    _626.data = jpl_alloc(_629);
    int64_t _630 = 0; // q
    int64_t _631 = 0; // p
    int64_t _632 = 0; // o
    _jump602:; // Begin body of loop
    bool _633 = false;
    int64_t _634 = 0;
    _634 *= _626.d0;
    _634 += _632;
    _634 *= _626.d1;
    _634 += _631;
    _634 *= _626.d2;
    _634 += _630;
    _626.data[_634] = _633;
    _630++;
    if (_630 < _527.d0)
    goto _jump602;
    _630 = 0;
    _631++;
    if (_631 < _628)
    goto _jump602;
    _631 = 0;
    _632++;
    if (_632 < _627)
    goto _jump602;
    // End body of loop
    if (_507.d1 >= 0)
    goto _jump603;
    fail_assertion("negative array index");
    _jump603:;
    if (_507.d1 < _626.d0)
    goto _jump604;
    fail_assertion("index too large");
    _jump604:;
    if (_507.d0 >= 0)
    goto _jump605;
    fail_assertion("negative array index");
    _jump605:;
    if (_507.d0 < _626.d1)
    goto _jump606;
    fail_assertion("index too large");
    _jump606:;
    if (_526.d2 >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (_526.d2 < _626.d2)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    int64_t _635 = 0;
    _635 *= _626.d0;
    _635 += _507.d1;
    _635 *= _626.d1;
    _635 += _507.d0;
    _635 *= _626.d2;
    _635 += _526.d2;
    bool _636 = _626.data[_635];
    _619 = _636;
    _jump598:;
    bool _637 = !_619;
    double _638 = f(_637);
    double _639 = -_638;
    bool _641 = _527.d2 == _507.d0;
    bool _640 = _641;
    if (0 != _641)
    goto _jump609;
    bool _643 = false;
    int64_t _644;
    if (!_643)
    goto _jump610;
    _644 = _507.d2;
    goto _jump611;
    _jump610:;
    _644 = _527.d0;
    _jump611:;
    bool _645 = _507.d2 > _644;
    bool _642 = _645;
    if (0 != _645)
    goto _jump612;
    bool _646 = _526.d1 == _527.d2;
    bool _647;
    if (!_646)
    goto _jump613;
    bool _648 = _47 <= _47;
    _647 = _648;
    goto _jump614;
    _jump613:;
    bool _649 = false;
    _647 = _649;
    _jump614:;
    _642 = _647;
    _jump612:;
    _640 = _642;
    _jump609:;
    rgba _650;
    if (!_640)
    goto _jump615;
    if (_527.d0 >= 0)
    goto _jump616;
    fail_assertion("negative array index");
    _jump616:;
    if (_527.d0 < _527.d0)
    goto _jump617;
    fail_assertion("index too large");
    _jump617:;
    if (_507.d1 >= 0)
    goto _jump618;
    fail_assertion("negative array index");
    _jump618:;
    if (_507.d1 < _527.d1)
    goto _jump619;
    fail_assertion("index too large");
    _jump619:;
    if (_527.d1 >= 0)
    goto _jump620;
    fail_assertion("negative array index");
    _jump620:;
    if (_527.d1 < _527.d2)
    goto _jump621;
    fail_assertion("index too large");
    _jump621:;
    int64_t _651 = 0;
    _651 *= _527.d0;
    _651 += _527.d0;
    _651 *= _527.d1;
    _651 += _507.d1;
    _651 *= _527.d2;
    _651 += _527.d1;
    rgba _652 = _527.data[_651];
    _650 = _652;
    goto _jump622;
    _jump615:;
    double _653 = -_47;
    bool _654 = false;
    double _655 = f(_654);
    double _656 = 46.0;
    rgba _657 = { _47, _653, _655, _656 };
    _650 = _657;
    _jump622:;
    double _658 = _650.a;
    double _659 = _639 / _658;
    int64_t _660 = 196;
    int64_t _661 = 514;
    double _662 = 1.0;
    bool _663 = _662 >= _47;
    _a2__a1_int64_t _664;
    if (!_663)
    goto _jump623;
    _a2__a1_int64_t _665;
    // Computing bound for u
    _665.d0 = _527.d2;
    if (_527.d2 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    // Computing bound for v
    bool _666 = true;
    int64_t _667;
    if (!_666)
    goto _jump625;
    _667 = _526.d0;
    goto _jump626;
    _jump625:;
    _667 = _526.d0;
    _jump626:;
    _665.d1 = _667;
    if (_667 > 0) 
    goto _jump627;
    fail_assertion("non-positive loop bound");
    _jump627:;
    // Computing total size of heap memory to allocate
    int64_t _668 = 1;
    _668 *= _527.d2;
    _668 *= _667;
    _668 *= sizeof(_a1_int64_t);
    _665.data = jpl_alloc(_668);
    int64_t _669 = 0; // v
    int64_t _670 = 0; // u
    _jump628:; // Begin body of loop
    bool _671 = true;
    _a1_int64_t _672;
    if (!_671)
    goto _jump629;
    _a1_int64_t _673;
    // Computing bound for w
    _673.d0 = _527.d2;
    if (_527.d2 > 0) 
    goto _jump630;
    fail_assertion("non-positive loop bound");
    _jump630:;
    // Computing total size of heap memory to allocate
    int64_t _674 = 1;
    _674 *= _527.d2;
    _674 *= sizeof(int64_t);
    _673.data = jpl_alloc(_674);
    int64_t _675 = 0; // w
    _jump631:; // Begin body of loop
    int64_t _676 = 0;
    _676 *= _673.d0;
    _676 += _675;
    _673.data[_676] = _527.d0;
    _675++;
    if (_675 < _527.d2)
    goto _jump631;
    // End body of loop
    _672 = _673;
    goto _jump632;
    _jump629:;
    _a1_int64_t _677;
    // Computing bound for w
    _677.d0 = _670;
    if (_670 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing total size of heap memory to allocate
    int64_t _678 = 1;
    _678 *= _670;
    _678 *= sizeof(int64_t);
    _677.data = jpl_alloc(_678);
    int64_t _679 = 0; // w
    _jump634:; // Begin body of loop
    int64_t _680 = 0;
    _680 *= _677.d0;
    _680 += _679;
    _677.data[_680] = _526.d2;
    _679++;
    if (_679 < _670)
    goto _jump634;
    // End body of loop
    _672 = _677;
    _jump632:;
    int64_t _681 = 0;
    _681 *= _665.d0;
    _681 += _670;
    _681 *= _665.d1;
    _681 += _669;
    _665.data[_681] = _672;
    _669++;
    if (_669 < _667)
    goto _jump628;
    _669 = 0;
    _670++;
    if (_670 < _527.d2)
    goto _jump628;
    // End body of loop
    _664 = _665;
    goto _jump635;
    _jump623:;
    _a2__a1_int64_t _682;
    // Computing bound for u
    _682.d0 = _527.d1;
    if (_527.d1 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for v
    int64_t _683;
    // Computing bound for u
    if (_526.d0 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for v
    int64_t _684;
    // Computing bound for u
    if (_507.d1 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    // Computing bound for v
    int64_t _685 = 471;
    if (_685 > 0) 
    goto _jump639;
    fail_assertion("non-positive loop bound");
    _jump639:;
    _684 = 0;
    int64_t _686 = 0; // v
    int64_t _687 = 0; // u
    _jump640:; // Begin body of loop
    _684 += _526.d0;
    _686++;
    if (_686 < _685)
    goto _jump640;
    _686 = 0;
    _687++;
    if (_687 < _507.d1)
    goto _jump640;
    // End body of loop
    if (_684 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    _683 = 0;
    int64_t _688 = 0; // v
    int64_t _689 = 0; // u
    _jump642:; // Begin body of loop
    int64_t _690;
    // Computing bound for w
    if (_526.d0 > 0) 
    goto _jump643;
    fail_assertion("non-positive loop bound");
    _jump643:;
    // Computing bound for x
    if (_527.d1 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    _690 = 0;
    int64_t _691 = 0; // x
    int64_t _692 = 0; // w
    _jump645:; // Begin body of loop
    _690 += _526.d1;
    _691++;
    if (_691 < _527.d1)
    goto _jump645;
    _691 = 0;
    _692++;
    if (_692 < _526.d0)
    goto _jump645;
    // End body of loop
    _683 += _690;
    _688++;
    if (_688 < _684)
    goto _jump642;
    _688 = 0;
    _689++;
    if (_689 < _526.d0)
    goto _jump642;
    // End body of loop
    _682.d1 = _683;
    if (_683 > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing total size of heap memory to allocate
    int64_t _693 = 1;
    _693 *= _527.d1;
    _693 *= _683;
    _693 *= sizeof(_a1_int64_t);
    _682.data = jpl_alloc(_693);
    int64_t _694 = 0; // v
    int64_t _695 = 0; // u
    _jump647:; // Begin body of loop
    _a1_int64_t _696;
    // Computing bound for w
    int64_t _697 = _526.d0 % _507.d1;
    _696.d0 = _697;
    if (_697 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing total size of heap memory to allocate
    int64_t _698 = 1;
    _698 *= _697;
    _698 *= sizeof(int64_t);
    _696.data = jpl_alloc(_698);
    int64_t _699 = 0; // w
    _jump649:; // Begin body of loop
    int64_t _700 = _526.d0 % _507.d1;
    int64_t _701 = 0;
    _701 *= _696.d0;
    _701 += _699;
    _696.data[_701] = _700;
    _699++;
    if (_699 < _697)
    goto _jump649;
    // End body of loop
    int64_t _702 = 0;
    _702 *= _682.d0;
    _702 += _695;
    _702 *= _682.d1;
    _702 += _694;
    _682.data[_702] = _696;
    _694++;
    if (_694 < _683)
    goto _jump647;
    _694 = 0;
    _695++;
    if (_695 < _527.d1)
    goto _jump647;
    // End body of loop
    _664 = _682;
    _jump635:;
    _a1_int64_t _703;
    _703.d0 = 1;
    _703.data = jpl_alloc(sizeof(int64_t) * 1);
    _703.data[0] = _507.d2;
    bool _704 = _526.d1 != _507.d1;
    int64_t _705;
    if (!_704)
    goto _jump650;
    _705 = _526.d1;
    goto _jump651;
    _jump650:;
    _705 = _527.d0;
    _jump651:;
    if (_705 >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (_705 < _703.d0)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    int64_t _706 = 0;
    _706 *= _703.d0;
    _706 += _705;
    int64_t _707 = _703.data[_706];
    int64_t _708;
    // Computing bound for u
    if (_526.d2 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    _708 = 0;
    int64_t _709 = 0; // u
    _jump655:; // Begin body of loop
    double _710 = 88.0;
    double _711 = 81.0;
    bool _712 = _710 <= _711;
    int64_t _713;
    if (!_712)
    goto _jump656;
    _713 = _709;
    goto _jump657;
    _jump656:;
    _713 = _526.d1;
    _jump657:;
    int64_t _714 = _713 - _526.d1;
    _708 += _714;
    _709++;
    if (_709 < _526.d2)
    goto _jump655;
    // End body of loop
    if (_707 >= 0)
    goto _jump658;
    fail_assertion("negative array index");
    _jump658:;
    if (_707 < _664.d0)
    goto _jump659;
    fail_assertion("index too large");
    _jump659:;
    if (_708 >= 0)
    goto _jump660;
    fail_assertion("negative array index");
    _jump660:;
    if (_708 < _664.d1)
    goto _jump661;
    fail_assertion("index too large");
    _jump661:;
    int64_t _715 = 0;
    _715 *= _664.d0;
    _715 += _707;
    _715 *= _664.d1;
    _715 += _708;
    _a1_int64_t _716 = _664.data[_715];
    if (_527.d0 >= 0)
    goto _jump662;
    fail_assertion("negative array index");
    _jump662:;
    if (_527.d0 < _716.d0)
    goto _jump663;
    fail_assertion("index too large");
    _jump663:;
    int64_t _717 = 0;
    _717 *= _716.d0;
    _717 += _527.d0;
    int64_t _718 = _716.data[_717];
    int64_t _719 = _661 * _718;
    _a2_bool _720;
    // Computing bound for x
    _720.d0 = _660;
    if (_660 > 0) 
    goto _jump922;
    fail_assertion("non-positive loop bound");
    _jump922:;
    // Computing bound for y
    _720.d1 = _719;
    if (_719 > 0) 
    goto _jump923;
    fail_assertion("non-positive loop bound");
    _jump923:;
    // Computing total size of heap memory to allocate
    int64_t _721 = 1;
    _721 *= _660;
    _721 *= _719;
    _721 *= sizeof(bool);
    _720.data = jpl_alloc(_721);
    int64_t _722 = 0; // y
    int64_t _723 = 0; // x
    _jump924:; // Begin body of loop
    int64_t _724 = 203;
    bool _725 = _660 != _724;
    int64_t _726 = 0;
    _726 *= _720.d0;
    _726 += _723;
    _726 *= _720.d1;
    _726 += _722;
    _720.data[_726] = _725;
    _722++;
    if (_722 < _719)
    goto _jump924;
    _722 = 0;
    _723++;
    if (_723 < _660)
    goto _jump924;
    // End body of loop
    _a1_int64_t _727;
    // Computing bound for x
    _727.d0 = _660;
    if (_660 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing total size of heap memory to allocate
    int64_t _728 = 1;
    _728 *= _660;
    _728 *= sizeof(int64_t);
    _727.data = jpl_alloc(_728);
    int64_t _729 = 0; // x
    _jump926:; // Begin body of loop
    int64_t _730 = 0;
    _730 *= _727.d0;
    _730 += _729;
    _727.data[_730] = _526.d1;
    _729++;
    if (_729 < _660)
    goto _jump926;
    // End body of loop
    if (_526.d0 >= 0)
    goto _jump927;
    fail_assertion("negative array index");
    _jump927:;
    if (_526.d0 < _727.d0)
    goto _jump928;
    fail_assertion("index too large");
    _jump928:;
    int64_t _731 = 0;
    _731 *= _727.d0;
    _731 += _526.d0;
    int64_t _732 = _727.data[_731];
    if (_507.d1 >= 0)
    goto _jump929;
    fail_assertion("negative array index");
    _jump929:;
    if (_507.d1 < _720.d0)
    goto _jump930;
    fail_assertion("index too large");
    _jump930:;
    if (_732 >= 0)
    goto _jump931;
    fail_assertion("negative array index");
    _jump931:;
    if (_732 < _720.d1)
    goto _jump932;
    fail_assertion("index too large");
    _jump932:;
    int64_t _733 = 0;
    _733 *= _720.d0;
    _733 += _507.d1;
    _733 *= _720.d1;
    _733 += _732;
    bool _734 = _720.data[_733];
    double _735 = f(_734);
    show("(IntType)", &_526.d2);
    if (_526.d1 >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (_526.d1 < _527.d0)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    if (_507.d0 >= 0)
    goto _jump1078;
    fail_assertion("negative array index");
    _jump1078:;
    if (_507.d0 < _527.d1)
    goto _jump1079;
    fail_assertion("index too large");
    _jump1079:;
    if (_526.d2 >= 0)
    goto _jump1080;
    fail_assertion("negative array index");
    _jump1080:;
    if (_526.d2 < _527.d2)
    goto _jump1081;
    fail_assertion("index too large");
    _jump1081:;
    int64_t _736 = 0;
    _736 *= _527.d0;
    _736 += _526.d1;
    _736 *= _527.d1;
    _736 += _507.d0;
    _736 *= _527.d2;
    _736 += _526.d2;
    rgba _737 = _527.data[_736];
    bool _738 = v(_737);
    _a2_bool _739;
    if (!_738)
    goto _jump1082;
    _a2_bool _740;
    // Computing bound for A
    int64_t _741 = 395;
    _740.d0 = _741;
    if (_741 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing bound for B
    _740.d1 = _660;
    if (_660 > 0) 
    goto _jump1084;
    fail_assertion("non-positive loop bound");
    _jump1084:;
    // Computing total size of heap memory to allocate
    int64_t _742 = 1;
    _742 *= _741;
    _742 *= _660;
    _742 *= sizeof(bool);
    _740.data = jpl_alloc(_742);
    int64_t _743 = 0; // B
    int64_t _744 = 0; // A
    _jump1085:; // Begin body of loop
    double _745 = 61.0;
    bool _746 = _47 != _745;
    int64_t _747 = 0;
    _747 *= _740.d0;
    _747 += _744;
    _747 *= _740.d1;
    _747 += _743;
    _740.data[_747] = _746;
    _743++;
    if (_743 < _660)
    goto _jump1085;
    _743 = 0;
    _744++;
    if (_744 < _741)
    goto _jump1085;
    // End body of loop
    _739 = _740;
    goto _jump1086;
    _jump1082:;
    _a2_bool _748;
    // Computing bound for A
    int64_t _749 = 407;
    _748.d0 = _749;
    if (_749 > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing bound for B
    int64_t _750 = _527.d2 * _527.d0;
    _748.d1 = _750;
    if (_750 > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    // Computing total size of heap memory to allocate
    int64_t _751 = 1;
    _751 *= _749;
    _751 *= _750;
    _751 *= sizeof(bool);
    _748.data = jpl_alloc(_751);
    int64_t _752 = 0; // B
    int64_t _753 = 0; // A
    _jump1089:; // Begin body of loop
    bool _754 = false;
    int64_t _755 = 0;
    _755 *= _748.d0;
    _755 += _753;
    _755 *= _748.d1;
    _755 += _752;
    _748.data[_755] = _754;
    _752++;
    if (_752 < _750)
    goto _jump1089;
    _752 = 0;
    _753++;
    if (_753 < _749)
    goto _jump1089;
    // End body of loop
    _739 = _748;
    _jump1086:;
    int64_t _756 = 695;
    if (_756 >= 0)
    goto _jump1090;
    fail_assertion("negative array index");
    _jump1090:;
    if (_756 < _739.d0)
    goto _jump1091;
    fail_assertion("index too large");
    _jump1091:;
    if (_526.d2 >= 0)
    goto _jump1092;
    fail_assertion("negative array index");
    _jump1092:;
    if (_526.d2 < _739.d1)
    goto _jump1093;
    fail_assertion("index too large");
    _jump1093:;
    int64_t _757 = 0;
    _757 *= _739.d0;
    _757 += _756;
    _757 *= _739.d1;
    _757 += _526.d2;
    bool _758 = _739.data[_757];
    rgba _759;
    if (!_758)
    goto _jump1094;
    _a1_double _760;
    // Computing bound for A
    _760.d0 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing total size of heap memory to allocate
    int64_t _761 = 1;
    _761 *= _526.d0;
    _761 *= sizeof(double);
    _760.data = jpl_alloc(_761);
    int64_t _762 = 0; // A
    _jump1096:; // Begin body of loop
    double _763 = 96.0;
    int64_t _764 = 0;
    _764 *= _760.d0;
    _764 += _762;
    _760.data[_764] = _763;
    _762++;
    if (_762 < _526.d0)
    goto _jump1096;
    // End body of loop
    if (_660 >= 0)
    goto _jump1097;
    fail_assertion("negative array index");
    _jump1097:;
    if (_660 < _760.d0)
    goto _jump1098;
    fail_assertion("index too large");
    _jump1098:;
    int64_t _765 = 0;
    _765 *= _760.d0;
    _765 += _660;
    double _766 = _760.data[_765];
    double _767 = _766 + _659;
    double _768;
    // Computing bound for A
    if (_526.d0 > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    _768 = 0;
    int64_t _769 = 0; // A
    _jump1100:; // Begin body of loop
    double _770 = 46.0;
    _768 += _770;
    _769++;
    if (_769 < _526.d0)
    goto _jump1100;
    // End body of loop
    bool _771 = _526.d0 < _526.d2;
    bool _772;
    if (!_771)
    goto _jump1101;
    bool _773 = true;
    bool _774 = !_773;
    _772 = _774;
    goto _jump1102;
    _jump1101:;
    bool _775 = _526.d2 < _526.d0;
    _772 = _775;
    _jump1102:;
    double _776;
    if (!_772)
    goto _jump1103;
    int64_t _777 = 272;
    if (_777 >= 0)
    goto _jump1104;
    fail_assertion("negative array index");
    _jump1104:;
    if (_777 < _527.d0)
    goto _jump1105;
    fail_assertion("index too large");
    _jump1105:;
    if (_660 >= 0)
    goto _jump1106;
    fail_assertion("negative array index");
    _jump1106:;
    if (_660 < _527.d1)
    goto _jump1107;
    fail_assertion("index too large");
    _jump1107:;
    if (_507.d0 >= 0)
    goto _jump1108;
    fail_assertion("negative array index");
    _jump1108:;
    if (_507.d0 < _527.d2)
    goto _jump1109;
    fail_assertion("index too large");
    _jump1109:;
    int64_t _778 = 0;
    _778 *= _527.d0;
    _778 += _777;
    _778 *= _527.d1;
    _778 += _660;
    _778 *= _527.d2;
    _778 += _507.d0;
    rgba _779 = _527.data[_778];
    double _780 = _779.g;
    _776 = _780;
    goto _jump1110;
    _jump1103:;
    _a2_double _781;
    // Computing bound for A
    _781.d0 = _527.d1;
    if (_527.d1 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for B
    _781.d1 = _660;
    if (_660 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing total size of heap memory to allocate
    int64_t _782 = 1;
    _782 *= _527.d1;
    _782 *= _660;
    _782 *= sizeof(double);
    _781.data = jpl_alloc(_782);
    int64_t _783 = 0; // B
    int64_t _784 = 0; // A
    _jump1113:; // Begin body of loop
    int64_t _785 = 0;
    _785 *= _781.d0;
    _785 += _784;
    _785 *= _781.d1;
    _785 += _783;
    _781.data[_785] = _47;
    _783++;
    if (_783 < _660)
    goto _jump1113;
    _783 = 0;
    _784++;
    if (_784 < _527.d1)
    goto _jump1113;
    // End body of loop
    int64_t _786 = -_526.d0;
    if (_526.d1 >= 0)
    goto _jump1114;
    fail_assertion("negative array index");
    _jump1114:;
    if (_526.d1 < _781.d0)
    goto _jump1115;
    fail_assertion("index too large");
    _jump1115:;
    if (_786 >= 0)
    goto _jump1116;
    fail_assertion("negative array index");
    _jump1116:;
    if (_786 < _781.d1)
    goto _jump1117;
    fail_assertion("index too large");
    _jump1117:;
    int64_t _787 = 0;
    _787 *= _781.d0;
    _787 += _526.d1;
    _787 *= _781.d1;
    _787 += _786;
    double _788 = _781.data[_787];
    _776 = _788;
    _jump1110:;
    bool _789 = _526.d0 == _507.d0;
    double _790;
    if (!_789)
    goto _jump1118;
    bool _791 = true;
    double _792;
    if (!_791)
    goto _jump1119;
    double _793 = 32.0;
    double _794 = -_793;
    _792 = _794;
    goto _jump1120;
    _jump1119:;
    double _795;
    // Computing bound for A
    if (_527.d1 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing bound for B
    if (_527.d2 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    // Computing bound for C
    if (_527.d0 > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    _795 = 0;
    int64_t _796 = 0; // C
    int64_t _797 = 0; // B
    int64_t _798 = 0; // A
    _jump1124:; // Begin body of loop
    double _799 = 50.0;
    _795 += _799;
    _796++;
    if (_796 < _527.d0)
    goto _jump1124;
    _796 = 0;
    _797++;
    if (_797 < _527.d2)
    goto _jump1124;
    _797 = 0;
    _798++;
    if (_798 < _527.d1)
    goto _jump1124;
    // End body of loop
    _792 = _795;
    _jump1120:;
    _790 = _792;
    goto _jump1125;
    _jump1118:;
    double _800 = -_659;
    _790 = _800;
    _jump1125:;
    rgba _801 = { _767, _768, _776, _790 };
    _759 = _801;
    goto _jump1126;
    _jump1094:;
    double _802;
    // Computing bound for A
    int64_t _803 = 367;
    if (_803 > 0) 
    goto _jump1127;
    fail_assertion("non-positive loop bound");
    _jump1127:;
    // Computing bound for B
    if (_526.d0 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    _802 = 0;
    int64_t _804 = 0; // B
    int64_t _805 = 0; // A
    _jump1129:; // Begin body of loop
    _802 += _735;
    _804++;
    if (_804 < _526.d0)
    goto _jump1129;
    _804 = 0;
    _805++;
    if (_805 < _803)
    goto _jump1129;
    // End body of loop
    double _806 = 22.0;
    double _807 = 55.0;
    rgba _808 = { _802, _806, _47, _807 };
    bool _809 = v(_808);
    rgba _810;
    if (!_809)
    goto _jump1130;
    bool _811 = false;
    rgba _812;
    if (!_811)
    goto _jump1131;
    double _813 = -_659;
    double _814 = 51.0;
    rgba _815 = { _735, _735, _813, _814 };
    _812 = _815;
    goto _jump1132;
    _jump1131:;
    double _816;
    // Computing bound for A
    if (_507.d0 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    _816 = 0;
    int64_t _817 = 0; // A
    _jump1134:; // Begin body of loop
    _816 += _735;
    _817++;
    if (_817 < _507.d0)
    goto _jump1134;
    // End body of loop
    double _818;
    // Computing bound for A
    if (_526.d0 > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    // Computing bound for B
    if (_507.d0 > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    // Computing bound for C
    if (_660 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    _818 = 0;
    int64_t _819 = 0; // C
    int64_t _820 = 0; // B
    int64_t _821 = 0; // A
    _jump1138:; // Begin body of loop
    _818 += _735;
    _819++;
    if (_819 < _660)
    goto _jump1138;
    _819 = 0;
    _820++;
    if (_820 < _507.d0)
    goto _jump1138;
    _820 = 0;
    _821++;
    if (_821 < _526.d0)
    goto _jump1138;
    // End body of loop
    bool _822 = false;
    double _823;
    if (!_822)
    goto _jump1139;
    _823 = _735;
    goto _jump1140;
    _jump1139:;
    _823 = _735;
    _jump1140:;
    rgba _824 = { _735, _816, _818, _823 };
    _812 = _824;
    _jump1132:;
    _810 = _812;
    goto _jump1141;
    _jump1130:;
    double _825 = 69.0;
    bool _826 = _825 <= _735;
    double _827 = f(_826);
    double _828 = -_735;
    double _829 = _828 * _47;
    double _830 = 14.0;
    rgba _831 = { _827, _829, _659, _830 };
    _810 = _831;
    _jump1141:;
    _759 = _810;
    _jump1126:;
    double _832 = _759.a;
    if (_526.d0 >= 0)
    goto _jump1142;
    fail_assertion("negative array index");
    _jump1142:;
    if (_526.d0 < _527.d0)
    goto _jump1143;
    fail_assertion("index too large");
    _jump1143:;
    if (_507.d0 >= 0)
    goto _jump1144;
    fail_assertion("negative array index");
    _jump1144:;
    if (_507.d0 < _527.d1)
    goto _jump1145;
    fail_assertion("index too large");
    _jump1145:;
    if (_507.d0 >= 0)
    goto _jump1146;
    fail_assertion("negative array index");
    _jump1146:;
    if (_507.d0 < _527.d2)
    goto _jump1147;
    fail_assertion("index too large");
    _jump1147:;
    int64_t _833 = 0;
    _833 *= _527.d0;
    _833 += _526.d0;
    _833 *= _527.d1;
    _833 += _507.d0;
    _833 *= _527.d2;
    _833 += _507.d0;
    rgba _834 = _527.data[_833];
    bool _835 = v(_834);
    double _836;
    if (!_835)
    goto _jump1148;
    double _837 = 47.0;
    _836 = _837;
    goto _jump1149;
    _jump1148:;
    bool _838 = _660 == _507.d0;
    double _839 = f(_838);
    _836 = _839;
    _jump1149:;
    double _840 = 13.0;
    double _841 = 28.0;
    double _842 = _840 * _841;
    double _843 = -_842;
    double _844 = _836 - _843;
    bool _845 = _47 < _844;
    double _846 = f(_845);
    rgba _847 = { _832, _846, _659, _47 };
    show("(ArrayType (IntType) 3)", &_526);
    bool _848 = false;
    _a2_int64_t _849;
    if (!_848)
    goto _jump1292;
    _a2_int64_t _850;
    // Computing bound for C
    _a2_int64_t _851;
    // Computing bound for C
    _851.d0 = _527.d1;
    if (_527.d1 > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing bound for D
    _851.d1 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    // Computing total size of heap memory to allocate
    int64_t _852 = 1;
    _852 *= _527.d1;
    _852 *= _526.d1;
    _852 *= sizeof(int64_t);
    _851.data = jpl_alloc(_852);
    int64_t _853 = 0; // D
    int64_t _854 = 0; // C
    _jump1295:; // Begin body of loop
    int64_t _855 = 0;
    _855 *= _851.d0;
    _855 += _854;
    _855 *= _851.d1;
    _855 += _853;
    _851.data[_855] = _507.d2;
    _853++;
    if (_853 < _526.d1)
    goto _jump1295;
    _853 = 0;
    _854++;
    if (_854 < _527.d1)
    goto _jump1295;
    // End body of loop
    int64_t _856 = -_527.d1;
    int64_t _857 = -_856;
    if (_857 >= 0)
    goto _jump1296;
    fail_assertion("negative array index");
    _jump1296:;
    if (_857 < _851.d0)
    goto _jump1297;
    fail_assertion("index too large");
    _jump1297:;
    if (_507.d0 >= 0)
    goto _jump1298;
    fail_assertion("negative array index");
    _jump1298:;
    if (_507.d0 < _851.d1)
    goto _jump1299;
    fail_assertion("index too large");
    _jump1299:;
    int64_t _858 = 0;
    _858 *= _851.d0;
    _858 += _857;
    _858 *= _851.d1;
    _858 += _507.d0;
    int64_t _859 = _851.data[_858];
    _850.d0 = _859;
    if (_859 > 0) 
    goto _jump1300;
    fail_assertion("non-positive loop bound");
    _jump1300:;
    // Computing bound for D
    _850.d1 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump1301;
    fail_assertion("non-positive loop bound");
    _jump1301:;
    // Computing total size of heap memory to allocate
    int64_t _860 = 1;
    _860 *= _859;
    _860 *= _526.d0;
    _860 *= sizeof(int64_t);
    _850.data = jpl_alloc(_860);
    int64_t _861 = 0; // D
    int64_t _862 = 0; // C
    _jump1302:; // Begin body of loop
    int64_t _863 = 0;
    _863 *= _850.d0;
    _863 += _862;
    _863 *= _850.d1;
    _863 += _861;
    _850.data[_863] = _526.d0;
    _861++;
    if (_861 < _526.d0)
    goto _jump1302;
    _861 = 0;
    _862++;
    if (_862 < _859)
    goto _jump1302;
    // End body of loop
    _849 = _850;
    goto _jump1303;
    _jump1292:;
    bool _864 = true;
    bool _865;
    if (!_864)
    goto _jump1304;
    bool _866 = true;
    bool _867 = !_866;
    bool _868 = !_867;
    _865 = _868;
    goto _jump1305;
    _jump1304:;
    bool _869 = true;
    bool _870;
    if (!_869)
    goto _jump1306;
    bool _871 = true;
    _870 = _871;
    goto _jump1307;
    _jump1306:;
    double _872 = 11.0;
    bool _873 = _872 < _47;
    _870 = _873;
    _jump1307:;
    _865 = _870;
    _jump1305:;
    _a2_int64_t _874;
    if (!_865)
    goto _jump1308;
    bool _875 = _660 > _660;
    _a2_int64_t _876;
    if (!_875)
    goto _jump1309;
    _a2_int64_t _877;
    // Computing bound for C
    int64_t _878;
    // Computing bound for C
    if (_527.d1 > 0) 
    goto _jump1310;
    fail_assertion("non-positive loop bound");
    _jump1310:;
    // Computing bound for D
    if (_526.d0 > 0) 
    goto _jump1311;
    fail_assertion("non-positive loop bound");
    _jump1311:;
    _878 = 0;
    int64_t _879 = 0; // D
    int64_t _880 = 0; // C
    _jump1312:; // Begin body of loop
    _878 += _526.d0;
    _879++;
    if (_879 < _526.d0)
    goto _jump1312;
    _879 = 0;
    _880++;
    if (_880 < _527.d1)
    goto _jump1312;
    // End body of loop
    _877.d0 = _878;
    if (_878 > 0) 
    goto _jump1313;
    fail_assertion("non-positive loop bound");
    _jump1313:;
    // Computing bound for D
    _877.d1 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1314;
    fail_assertion("non-positive loop bound");
    _jump1314:;
    // Computing total size of heap memory to allocate
    int64_t _881 = 1;
    _881 *= _878;
    _881 *= _526.d1;
    _881 *= sizeof(int64_t);
    _877.data = jpl_alloc(_881);
    int64_t _882 = 0; // D
    int64_t _883 = 0; // C
    _jump1315:; // Begin body of loop
    int64_t _884 = 0;
    _884 *= _877.d0;
    _884 += _883;
    _884 *= _877.d1;
    _884 += _882;
    _877.data[_884] = _527.d0;
    _882++;
    if (_882 < _526.d1)
    goto _jump1315;
    _882 = 0;
    _883++;
    if (_883 < _878)
    goto _jump1315;
    // End body of loop
    _876 = _877;
    goto _jump1316;
    _jump1309:;
    _a2_int64_t _885;
    // Computing bound for C
    int64_t _886 = 742;
    _885.d0 = _886;
    if (_886 > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    // Computing bound for D
    _885.d1 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing total size of heap memory to allocate
    int64_t _887 = 1;
    _887 *= _886;
    _887 *= _526.d2;
    _887 *= sizeof(int64_t);
    _885.data = jpl_alloc(_887);
    int64_t _888 = 0; // D
    int64_t _889 = 0; // C
    _jump1319:; // Begin body of loop
    int64_t _890 = 0;
    _890 *= _885.d0;
    _890 += _889;
    _890 *= _885.d1;
    _890 += _888;
    _885.data[_890] = _507.d0;
    _888++;
    if (_888 < _526.d2)
    goto _jump1319;
    _888 = 0;
    _889++;
    if (_889 < _886)
    goto _jump1319;
    // End body of loop
    _876 = _885;
    _jump1316:;
    _874 = _876;
    goto _jump1320;
    _jump1308:;
    _a2_int64_t _891;
    // Computing bound for C
    _891.d0 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump1321;
    fail_assertion("non-positive loop bound");
    _jump1321:;
    // Computing bound for D
    _891.d1 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing total size of heap memory to allocate
    int64_t _892 = 1;
    _892 *= _507.d0;
    _892 *= _507.d2;
    _892 *= sizeof(int64_t);
    _891.data = jpl_alloc(_892);
    int64_t _893 = 0; // D
    int64_t _894 = 0; // C
    _jump1323:; // Begin body of loop
    int64_t _895 = 0;
    _895 *= _891.d0;
    _895 += _894;
    _895 *= _891.d1;
    _895 += _893;
    _891.data[_895] = _894;
    _893++;
    if (_893 < _507.d2)
    goto _jump1323;
    _893 = 0;
    _894++;
    if (_894 < _507.d0)
    goto _jump1323;
    // End body of loop
    _874 = _891;
    _jump1320:;
    _849 = _874;
    _jump1303:;
    _a2_int64_t _896;
    // Computing bound for C
    _896.d0 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing bound for D
    _896.d1 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump1325;
    fail_assertion("non-positive loop bound");
    _jump1325:;
    // Computing total size of heap memory to allocate
    int64_t _897 = 1;
    _897 *= _507.d0;
    _897 *= _507.d1;
    _897 *= sizeof(int64_t);
    _896.data = jpl_alloc(_897);
    int64_t _898 = 0; // D
    int64_t _899 = 0; // C
    _jump1326:; // Begin body of loop
    int64_t _900 = 0;
    _900 *= _896.d0;
    _900 += _899;
    _900 *= _896.d1;
    _900 += _898;
    _896.data[_900] = _527.d1;
    _898++;
    if (_898 < _507.d1)
    goto _jump1326;
    _898 = 0;
    _899++;
    if (_899 < _507.d0)
    goto _jump1326;
    // End body of loop
    _a1__a2_int64_t _901;
    _901.d0 = 1;
    _901.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _901.data[0] = _896;
    if (_526.d1 >= 0)
    goto _jump1327;
    fail_assertion("negative array index");
    _jump1327:;
    if (_526.d1 < _901.d0)
    goto _jump1328;
    fail_assertion("index too large");
    _jump1328:;
    int64_t _902 = 0;
    _902 *= _901.d0;
    _902 += _526.d1;
    _a2_int64_t _903 = _901.data[_902];
    _a2_int64_t _904;
    // Computing bound for C
    _904.d0 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump1329;
    fail_assertion("non-positive loop bound");
    _jump1329:;
    // Computing bound for D
    _904.d1 = _527.d0;
    if (_527.d0 > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    // Computing total size of heap memory to allocate
    int64_t _905 = 1;
    _905 *= _526.d2;
    _905 *= _527.d0;
    _905 *= sizeof(int64_t);
    _904.data = jpl_alloc(_905);
    int64_t _906 = 0; // D
    int64_t _907 = 0; // C
    _jump1331:; // Begin body of loop
    double _908 = -_735;
    bool _909 = _908 > _659;
    bool _910 = !_909;
    int64_t _911;
    if (!_910)
    goto _jump1332;
    _911 = _660;
    goto _jump1333;
    _jump1332:;
    _911 = _527.d1;
    _jump1333:;
    int64_t _912 = 0;
    _912 *= _904.d0;
    _912 += _907;
    _912 *= _904.d1;
    _912 += _906;
    _904.data[_912] = _911;
    _906++;
    if (_906 < _527.d0)
    goto _jump1331;
    _906 = 0;
    _907++;
    if (_907 < _526.d2)
    goto _jump1331;
    // End body of loop
    _a1__a2_int64_t _913;
    _913.d0 = 3;
    _913.data = jpl_alloc(sizeof(_a2_int64_t) * 3);
    _913.data[0] = _849;
    _913.data[1] = _903;
    _913.data[2] = _904;
    if (_660 >= 0)
    goto _jump1334;
    fail_assertion("negative array index");
    _jump1334:;
    if (_660 < _913.d0)
    goto _jump1335;
    fail_assertion("index too large");
    _jump1335:;
    int64_t _914 = 0;
    _914 *= _913.d0;
    _914 += _660;
    _a2_int64_t _915 = _913.data[_914];
    _a1__a2_bool _916;
    // Computing bound for G
    _916.d0 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1548;
    fail_assertion("non-positive loop bound");
    _jump1548:;
    // Computing total size of heap memory to allocate
    int64_t _917 = 1;
    _917 *= _526.d1;
    _917 *= sizeof(_a2_bool);
    _916.data = jpl_alloc(_917);
    int64_t _918 = 0; // G
    _jump1549:; // Begin body of loop
    _a2_bool _919;
    // Computing bound for H
    _919.d0 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump1550;
    fail_assertion("non-positive loop bound");
    _jump1550:;
    // Computing bound for I
    _919.d1 = _918;
    if (_918 > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    // Computing total size of heap memory to allocate
    int64_t _920 = 1;
    _920 *= _526.d0;
    _920 *= _918;
    _920 *= sizeof(bool);
    _919.data = jpl_alloc(_920);
    int64_t _921 = 0; // I
    int64_t _922 = 0; // H
    _jump1552:; // Begin body of loop
    bool _923 = _526.d2 > _915.d1;
    int64_t _924 = 0;
    _924 *= _919.d0;
    _924 += _922;
    _924 *= _919.d1;
    _924 += _921;
    _919.data[_924] = _923;
    _921++;
    if (_921 < _918)
    goto _jump1552;
    _921 = 0;
    _922++;
    if (_922 < _526.d0)
    goto _jump1552;
    // End body of loop
    int64_t _925 = 0;
    _925 *= _916.d0;
    _925 += _918;
    _916.data[_925] = _919;
    _918++;
    if (_918 < _526.d1)
    goto _jump1549;
    // End body of loop
    if (_915.d1 >= 0)
    goto _jump1553;
    fail_assertion("negative array index");
    _jump1553:;
    if (_915.d1 < _916.d0)
    goto _jump1554;
    fail_assertion("index too large");
    _jump1554:;
    int64_t _926 = 0;
    _926 *= _916.d0;
    _926 += _915.d1;
    _a2_bool _927 = _916.data[_926];
    double _928 = _47 + _735;
    bool _929 = _47 != _928;
    _a3_bool _930;
    if (!_929)
    goto _jump1555;
    _a3_bool _931;
    // Computing bound for G
    _931.d0 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump1556;
    fail_assertion("non-positive loop bound");
    _jump1556:;
    // Computing bound for H
    _931.d1 = _719;
    if (_719 > 0) 
    goto _jump1557;
    fail_assertion("non-positive loop bound");
    _jump1557:;
    // Computing bound for I
    _931.d2 = _915.d0;
    if (_915.d0 > 0) 
    goto _jump1558;
    fail_assertion("non-positive loop bound");
    _jump1558:;
    // Computing total size of heap memory to allocate
    int64_t _932 = 1;
    _932 *= _526.d2;
    _932 *= _719;
    _932 *= _915.d0;
    _932 *= sizeof(bool);
    _931.data = jpl_alloc(_932);
    int64_t _933 = 0; // I
    int64_t _934 = 0; // H
    int64_t _935 = 0; // G
    _jump1559:; // Begin body of loop
    bool _936 = false;
    int64_t _937 = 0;
    _937 *= _931.d0;
    _937 += _935;
    _937 *= _931.d1;
    _937 += _934;
    _937 *= _931.d2;
    _937 += _933;
    _931.data[_937] = _936;
    _933++;
    if (_933 < _915.d0)
    goto _jump1559;
    _933 = 0;
    _934++;
    if (_934 < _719)
    goto _jump1559;
    _934 = 0;
    _935++;
    if (_935 < _526.d2)
    goto _jump1559;
    // End body of loop
    _930 = _931;
    goto _jump1560;
    _jump1555:;
    _a3_bool _938;
    // Computing bound for G
    _938.d0 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump1561;
    fail_assertion("non-positive loop bound");
    _jump1561:;
    // Computing bound for H
    _938.d1 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump1562;
    fail_assertion("non-positive loop bound");
    _jump1562:;
    // Computing bound for I
    _938.d2 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing total size of heap memory to allocate
    int64_t _939 = 1;
    _939 *= _507.d2;
    _939 *= _526.d2;
    _939 *= _507.d1;
    _939 *= sizeof(bool);
    _938.data = jpl_alloc(_939);
    int64_t _940 = 0; // I
    int64_t _941 = 0; // H
    int64_t _942 = 0; // G
    _jump1564:; // Begin body of loop
    bool _943 = false;
    int64_t _944 = 0;
    _944 *= _938.d0;
    _944 += _942;
    _944 *= _938.d1;
    _944 += _941;
    _944 *= _938.d2;
    _944 += _940;
    _938.data[_944] = _943;
    _940++;
    if (_940 < _507.d1)
    goto _jump1564;
    _940 = 0;
    _941++;
    if (_941 < _526.d2)
    goto _jump1564;
    _941 = 0;
    _942++;
    if (_942 < _507.d2)
    goto _jump1564;
    // End body of loop
    _930 = _938;
    _jump1560:;
    if (_915.d1 >= 0)
    goto _jump1565;
    fail_assertion("negative array index");
    _jump1565:;
    if (_915.d1 < _930.d0)
    goto _jump1566;
    fail_assertion("index too large");
    _jump1566:;
    if (_507.d2 >= 0)
    goto _jump1567;
    fail_assertion("negative array index");
    _jump1567:;
    if (_507.d2 < _930.d1)
    goto _jump1568;
    fail_assertion("index too large");
    _jump1568:;
    if (_915.d1 >= 0)
    goto _jump1569;
    fail_assertion("negative array index");
    _jump1569:;
    if (_915.d1 < _930.d2)
    goto _jump1570;
    fail_assertion("index too large");
    _jump1570:;
    int64_t _945 = 0;
    _945 *= _930.d0;
    _945 += _915.d1;
    _945 *= _930.d1;
    _945 += _507.d2;
    _945 *= _930.d2;
    _945 += _915.d1;
    bool _946 = _930.data[_945];
    int64_t _947;
    if (!_946)
    goto _jump1571;
    _947 = _660;
    goto _jump1572;
    _jump1571:;
    int64_t _948 = -_526.d2;
    _947 = _948;
    _jump1572:;
    if (_526.d2 >= 0)
    goto _jump1573;
    fail_assertion("negative array index");
    _jump1573:;
    if (_526.d2 < _927.d0)
    goto _jump1574;
    fail_assertion("index too large");
    _jump1574:;
    if (_947 >= 0)
    goto _jump1575;
    fail_assertion("negative array index");
    _jump1575:;
    if (_947 < _927.d1)
    goto _jump1576;
    fail_assertion("index too large");
    _jump1576:;
    int64_t _949 = 0;
    _949 *= _927.d0;
    _949 += _526.d2;
    _949 *= _927.d1;
    _949 += _947;
    bool _950 = _927.data[_949];
    _a3__a3_int64_t _951;
    if (!_950)
    goto _jump1577;
    _a3__a3_int64_t _952;
    // Computing bound for G
    _952.d0 = _915.d0;
    if (_915.d0 > 0) 
    goto _jump1578;
    fail_assertion("non-positive loop bound");
    _jump1578:;
    // Computing bound for H
    int64_t _953 = 878;
    bool _954 = true;
    int64_t _955;
    if (!_954)
    goto _jump1579;
    _955 = _526.d1;
    goto _jump1580;
    _jump1579:;
    _955 = _660;
    _jump1580:;
    if (_953 >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (_953 < _526.d0)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    if (_955 >= 0)
    goto _jump1583;
    fail_assertion("negative array index");
    _jump1583:;
    if (_955 < _526.d1)
    goto _jump1584;
    fail_assertion("index too large");
    _jump1584:;
    if (_526.d1 >= 0)
    goto _jump1585;
    fail_assertion("negative array index");
    _jump1585:;
    if (_526.d1 < _526.d2)
    goto _jump1586;
    fail_assertion("index too large");
    _jump1586:;
    int64_t _956 = 0;
    _956 *= _526.d0;
    _956 += _953;
    _956 *= _526.d1;
    _956 += _955;
    _956 *= _526.d2;
    _956 += _526.d1;
    int64_t _957 = _526.data[_956];
    _952.d1 = _957;
    if (_957 > 0) 
    goto _jump1587;
    fail_assertion("non-positive loop bound");
    _jump1587:;
    // Computing bound for I
    int64_t _958;
    // Computing bound for G
    if (_660 > 0) 
    goto _jump1588;
    fail_assertion("non-positive loop bound");
    _jump1588:;
    _958 = 0;
    int64_t _959 = 0; // G
    _jump1589:; // Begin body of loop
    _958 += _507.d0;
    _959++;
    if (_959 < _660)
    goto _jump1589;
    // End body of loop
    _952.d2 = _958;
    if (_958 > 0) 
    goto _jump1590;
    fail_assertion("non-positive loop bound");
    _jump1590:;
    // Computing total size of heap memory to allocate
    int64_t _960 = 1;
    _960 *= _915.d0;
    _960 *= _957;
    _960 *= _958;
    _960 *= sizeof(_a3_int64_t);
    _952.data = jpl_alloc(_960);
    int64_t _961 = 0; // I
    int64_t _962 = 0; // H
    int64_t _963 = 0; // G
    _jump1591:; // Begin body of loop
    int64_t _964 = 0;
    _964 *= _952.d0;
    _964 += _963;
    _964 *= _952.d1;
    _964 += _962;
    _964 *= _952.d2;
    _964 += _961;
    _952.data[_964] = _507;
    _961++;
    if (_961 < _958)
    goto _jump1591;
    _961 = 0;
    _962++;
    if (_962 < _957)
    goto _jump1591;
    _962 = 0;
    _963++;
    if (_963 < _915.d0)
    goto _jump1591;
    // End body of loop
    _951 = _952;
    goto _jump1592;
    _jump1577:;
    bool _965 = false;
    _a3__a3_int64_t _966;
    if (!_965)
    goto _jump1593;
    bool _967 = _527.d2 < _507.d0;
    _a1__a3__a3_int64_t _968;
    if (!_967)
    goto _jump1594;
    double _969 = 18.0;
    bool _970 = _969 <= _47;
    bool _971 = !_970;
    _a1__a3__a3_int64_t _972;
    if (!_971)
    goto _jump1595;
    _a1__a3__a3_int64_t _973;
    // Computing bound for G
    _973.d0 = _915.d0;
    if (_915.d0 > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    // Computing total size of heap memory to allocate
    int64_t _974 = 1;
    _974 *= _915.d0;
    _974 *= sizeof(_a3__a3_int64_t);
    _973.data = jpl_alloc(_974);
    int64_t _975 = 0; // G
    _jump1597:; // Begin body of loop
    _a3__a3_int64_t _976;
    // Computing bound for H
    _976.d0 = _527.d2;
    if (_527.d2 > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    // Computing bound for I
    _976.d1 = _527.d0;
    if (_527.d0 > 0) 
    goto _jump1599;
    fail_assertion("non-positive loop bound");
    _jump1599:;
    // Computing bound for J
    _976.d2 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing total size of heap memory to allocate
    int64_t _977 = 1;
    _977 *= _527.d2;
    _977 *= _527.d0;
    _977 *= _526.d1;
    _977 *= sizeof(_a3_int64_t);
    _976.data = jpl_alloc(_977);
    int64_t _978 = 0; // J
    int64_t _979 = 0; // I
    int64_t _980 = 0; // H
    _jump1601:; // Begin body of loop
    int64_t _981 = 0;
    _981 *= _976.d0;
    _981 += _980;
    _981 *= _976.d1;
    _981 += _979;
    _981 *= _976.d2;
    _981 += _978;
    _976.data[_981] = _507;
    _978++;
    if (_978 < _526.d1)
    goto _jump1601;
    _978 = 0;
    _979++;
    if (_979 < _527.d0)
    goto _jump1601;
    _979 = 0;
    _980++;
    if (_980 < _527.d2)
    goto _jump1601;
    // End body of loop
    int64_t _982 = 0;
    _982 *= _973.d0;
    _982 += _975;
    _973.data[_982] = _976;
    _975++;
    if (_975 < _915.d0)
    goto _jump1597;
    // End body of loop
    _972 = _973;
    goto _jump1602;
    _jump1595:;
    _a3__a3_int64_t _983;
    // Computing bound for G
    _983.d0 = _915.d0;
    if (_915.d0 > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    // Computing bound for H
    _983.d1 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1604;
    fail_assertion("non-positive loop bound");
    _jump1604:;
    // Computing bound for I
    _983.d2 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1605;
    fail_assertion("non-positive loop bound");
    _jump1605:;
    // Computing total size of heap memory to allocate
    int64_t _984 = 1;
    _984 *= _915.d0;
    _984 *= _526.d1;
    _984 *= _526.d1;
    _984 *= sizeof(_a3_int64_t);
    _983.data = jpl_alloc(_984);
    int64_t _985 = 0; // I
    int64_t _986 = 0; // H
    int64_t _987 = 0; // G
    _jump1606:; // Begin body of loop
    int64_t _988 = 0;
    _988 *= _983.d0;
    _988 += _987;
    _988 *= _983.d1;
    _988 += _986;
    _988 *= _983.d2;
    _988 += _985;
    _983.data[_988] = _526;
    _985++;
    if (_985 < _526.d1)
    goto _jump1606;
    _985 = 0;
    _986++;
    if (_986 < _526.d1)
    goto _jump1606;
    _986 = 0;
    _987++;
    if (_987 < _915.d0)
    goto _jump1606;
    // End body of loop
    _a3__a3_int64_t _989;
    // Computing bound for G
    _989.d0 = _660;
    if (_660 > 0) 
    goto _jump1607;
    fail_assertion("non-positive loop bound");
    _jump1607:;
    // Computing bound for H
    _989.d1 = _660;
    if (_660 > 0) 
    goto _jump1608;
    fail_assertion("non-positive loop bound");
    _jump1608:;
    // Computing bound for I
    _989.d2 = _660;
    if (_660 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing total size of heap memory to allocate
    int64_t _990 = 1;
    _990 *= _660;
    _990 *= _660;
    _990 *= _660;
    _990 *= sizeof(_a3_int64_t);
    _989.data = jpl_alloc(_990);
    int64_t _991 = 0; // I
    int64_t _992 = 0; // H
    int64_t _993 = 0; // G
    _jump1610:; // Begin body of loop
    int64_t _994 = 0;
    _994 *= _989.d0;
    _994 += _993;
    _994 *= _989.d1;
    _994 += _992;
    _994 *= _989.d2;
    _994 += _991;
    _989.data[_994] = _526;
    _991++;
    if (_991 < _660)
    goto _jump1610;
    _991 = 0;
    _992++;
    if (_992 < _660)
    goto _jump1610;
    _992 = 0;
    _993++;
    if (_993 < _660)
    goto _jump1610;
    // End body of loop
    _a1__a3__a3_int64_t _995;
    _995.d0 = 2;
    _995.data = jpl_alloc(sizeof(_a3__a3_int64_t) * 2);
    _995.data[0] = _983;
    _995.data[1] = _989;
    _972 = _995;
    _jump1602:;
    _968 = _972;
    goto _jump1611;
    _jump1594:;
    bool _996 = _659 < _47;
    bool _997 = !_996;
    _a1__a3__a3_int64_t _998;
    if (!_997)
    goto _jump1612;
    _a3__a3_int64_t _999;
    // Computing bound for G
    _999.d0 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for H
    _999.d1 = _915.d1;
    if (_915.d1 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for I
    _999.d2 = _719;
    if (_719 > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    // Computing total size of heap memory to allocate
    int64_t _1000 = 1;
    _1000 *= _507.d0;
    _1000 *= _915.d1;
    _1000 *= _719;
    _1000 *= sizeof(_a3_int64_t);
    _999.data = jpl_alloc(_1000);
    int64_t _1001 = 0; // I
    int64_t _1002 = 0; // H
    int64_t _1003 = 0; // G
    _jump1616:; // Begin body of loop
    int64_t _1004 = 0;
    _1004 *= _999.d0;
    _1004 += _1003;
    _1004 *= _999.d1;
    _1004 += _1002;
    _1004 *= _999.d2;
    _1004 += _1001;
    _999.data[_1004] = _507;
    _1001++;
    if (_1001 < _719)
    goto _jump1616;
    _1001 = 0;
    _1002++;
    if (_1002 < _915.d1)
    goto _jump1616;
    _1002 = 0;
    _1003++;
    if (_1003 < _507.d0)
    goto _jump1616;
    // End body of loop
    _a1__a3__a3_int64_t _1005;
    _1005.d0 = 1;
    _1005.data = jpl_alloc(sizeof(_a3__a3_int64_t) * 1);
    _1005.data[0] = _999;
    _998 = _1005;
    goto _jump1617;
    _jump1612:;
    _a1__a3__a3_int64_t _1006;
    // Computing bound for G
    _1006.d0 = _527.d2;
    if (_527.d2 > 0) 
    goto _jump1618;
    fail_assertion("non-positive loop bound");
    _jump1618:;
    // Computing total size of heap memory to allocate
    int64_t _1007 = 1;
    _1007 *= _527.d2;
    _1007 *= sizeof(_a3__a3_int64_t);
    _1006.data = jpl_alloc(_1007);
    int64_t _1008 = 0; // G
    _jump1619:; // Begin body of loop
    _a3__a3_int64_t _1009;
    // Computing bound for H
    _1009.d0 = _527.d0;
    if (_527.d0 > 0) 
    goto _jump1620;
    fail_assertion("non-positive loop bound");
    _jump1620:;
    // Computing bound for I
    _1009.d1 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    // Computing bound for J
    _1009.d2 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    // Computing total size of heap memory to allocate
    int64_t _1010 = 1;
    _1010 *= _527.d0;
    _1010 *= _507.d0;
    _1010 *= _507.d1;
    _1010 *= sizeof(_a3_int64_t);
    _1009.data = jpl_alloc(_1010);
    int64_t _1011 = 0; // J
    int64_t _1012 = 0; // I
    int64_t _1013 = 0; // H
    _jump1623:; // Begin body of loop
    int64_t _1014 = 0;
    _1014 *= _1009.d0;
    _1014 += _1013;
    _1014 *= _1009.d1;
    _1014 += _1012;
    _1014 *= _1009.d2;
    _1014 += _1011;
    _1009.data[_1014] = _526;
    _1011++;
    if (_1011 < _507.d1)
    goto _jump1623;
    _1011 = 0;
    _1012++;
    if (_1012 < _507.d0)
    goto _jump1623;
    _1012 = 0;
    _1013++;
    if (_1013 < _527.d0)
    goto _jump1623;
    // End body of loop
    int64_t _1015 = 0;
    _1015 *= _1006.d0;
    _1015 += _1008;
    _1006.data[_1015] = _1009;
    _1008++;
    if (_1008 < _527.d2)
    goto _jump1619;
    // End body of loop
    _998 = _1006;
    _jump1617:;
    _968 = _998;
    _jump1611:;
    if (_526.d2 >= 0)
    goto _jump1624;
    fail_assertion("negative array index");
    _jump1624:;
    if (_526.d2 < _968.d0)
    goto _jump1625;
    fail_assertion("index too large");
    _jump1625:;
    int64_t _1016 = 0;
    _1016 *= _968.d0;
    _1016 += _526.d2;
    _a3__a3_int64_t _1017 = _968.data[_1016];
    _966 = _1017;
    goto _jump1626;
    _jump1593:;
    _a3__a3__a3_int64_t _1018;
    // Computing bound for G
    _1018.d0 = _660;
    if (_660 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing bound for H
    _1018.d1 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing bound for I
    _1018.d2 = _527.d1;
    if (_527.d1 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing total size of heap memory to allocate
    int64_t _1019 = 1;
    _1019 *= _660;
    _1019 *= _526.d1;
    _1019 *= _527.d1;
    _1019 *= sizeof(_a3__a3_int64_t);
    _1018.data = jpl_alloc(_1019);
    int64_t _1020 = 0; // I
    int64_t _1021 = 0; // H
    int64_t _1022 = 0; // G
    _jump1630:; // Begin body of loop
    _a3__a3_int64_t _1023;
    // Computing bound for J
    _1023.d0 = _915.d0;
    if (_915.d0 > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing bound for K
    _1023.d1 = _915.d0;
    if (_915.d0 > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    // Computing bound for L
    bool _1024 = true;
    _a3_int64_t _1025;
    if (!_1024)
    goto _jump1633;
    _1025 = _526;
    goto _jump1634;
    _jump1633:;
    _1025 = _526;
    _jump1634:;
    if (_915.d0 >= 0)
    goto _jump1635;
    fail_assertion("negative array index");
    _jump1635:;
    if (_915.d0 < _1025.d0)
    goto _jump1636;
    fail_assertion("index too large");
    _jump1636:;
    if (_527.d0 >= 0)
    goto _jump1637;
    fail_assertion("negative array index");
    _jump1637:;
    if (_527.d0 < _1025.d1)
    goto _jump1638;
    fail_assertion("index too large");
    _jump1638:;
    if (_526.d1 >= 0)
    goto _jump1639;
    fail_assertion("negative array index");
    _jump1639:;
    if (_526.d1 < _1025.d2)
    goto _jump1640;
    fail_assertion("index too large");
    _jump1640:;
    int64_t _1026 = 0;
    _1026 *= _1025.d0;
    _1026 += _915.d0;
    _1026 *= _1025.d1;
    _1026 += _527.d0;
    _1026 *= _1025.d2;
    _1026 += _526.d1;
    int64_t _1027 = _1025.data[_1026];
    _1023.d2 = _1027;
    if (_1027 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    // Computing total size of heap memory to allocate
    int64_t _1028 = 1;
    _1028 *= _915.d0;
    _1028 *= _915.d0;
    _1028 *= _1027;
    _1028 *= sizeof(_a3_int64_t);
    _1023.data = jpl_alloc(_1028);
    int64_t _1029 = 0; // L
    int64_t _1030 = 0; // K
    int64_t _1031 = 0; // J
    _jump1642:; // Begin body of loop
    _a1__a3_int64_t _1032;
    _1032.d0 = 1;
    _1032.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _1032.data[0] = _507;
    if (_507.d1 >= 0)
    goto _jump1643;
    fail_assertion("negative array index");
    _jump1643:;
    if (_507.d1 < _1032.d0)
    goto _jump1644;
    fail_assertion("index too large");
    _jump1644:;
    int64_t _1033 = 0;
    _1033 *= _1032.d0;
    _1033 += _507.d1;
    _a3_int64_t _1034 = _1032.data[_1033];
    int64_t _1035 = 0;
    _1035 *= _1023.d0;
    _1035 += _1031;
    _1035 *= _1023.d1;
    _1035 += _1030;
    _1035 *= _1023.d2;
    _1035 += _1029;
    _1023.data[_1035] = _1034;
    _1029++;
    if (_1029 < _1027)
    goto _jump1642;
    _1029 = 0;
    _1030++;
    if (_1030 < _915.d0)
    goto _jump1642;
    _1030 = 0;
    _1031++;
    if (_1031 < _915.d0)
    goto _jump1642;
    // End body of loop
    int64_t _1036 = 0;
    _1036 *= _1018.d0;
    _1036 += _1022;
    _1036 *= _1018.d1;
    _1036 += _1021;
    _1036 *= _1018.d2;
    _1036 += _1020;
    _1018.data[_1036] = _1023;
    _1020++;
    if (_1020 < _527.d1)
    goto _jump1630;
    _1020 = 0;
    _1021++;
    if (_1021 < _526.d1)
    goto _jump1630;
    _1021 = 0;
    _1022++;
    if (_1022 < _660)
    goto _jump1630;
    // End body of loop
    bool _1037 = true;
    int64_t _1038;
    if (!_1037)
    goto _jump1645;
    _1038 = _526.d2;
    goto _jump1646;
    _jump1645:;
    _1038 = _507.d1;
    _jump1646:;
    if (_507.d0 >= 0)
    goto _jump1647;
    fail_assertion("negative array index");
    _jump1647:;
    if (_507.d0 < _1018.d0)
    goto _jump1648;
    fail_assertion("index too large");
    _jump1648:;
    if (_526.d2 >= 0)
    goto _jump1649;
    fail_assertion("negative array index");
    _jump1649:;
    if (_526.d2 < _1018.d1)
    goto _jump1650;
    fail_assertion("index too large");
    _jump1650:;
    if (_1038 >= 0)
    goto _jump1651;
    fail_assertion("negative array index");
    _jump1651:;
    if (_1038 < _1018.d2)
    goto _jump1652;
    fail_assertion("index too large");
    _jump1652:;
    int64_t _1039 = 0;
    _1039 *= _1018.d0;
    _1039 += _507.d0;
    _1039 *= _1018.d1;
    _1039 += _526.d2;
    _1039 *= _1018.d2;
    _1039 += _1038;
    _a3__a3_int64_t _1040 = _1018.data[_1039];
    _966 = _1040;
    _jump1626:;
    _951 = _966;
    _jump1592:;
    _a1__a2_rgba _1041;
    // Computing bound for K
    int64_t _1042;
    // Computing bound for K
    if (_951.d2 > 0) 
    goto _jump1653;
    fail_assertion("non-positive loop bound");
    _jump1653:;
    _1042 = 0;
    int64_t _1043 = 0; // K
    _jump1654:; // Begin body of loop
    _1042 += _526.d0;
    _1043++;
    if (_1043 < _951.d2)
    goto _jump1654;
    // End body of loop
    _1041.d0 = _1042;
    if (_1042 > 0) 
    goto _jump1655;
    fail_assertion("non-positive loop bound");
    _jump1655:;
    // Computing total size of heap memory to allocate
    int64_t _1044 = 1;
    _1044 *= _1042;
    _1044 *= sizeof(_a2_rgba);
    _1041.data = jpl_alloc(_1044);
    int64_t _1045 = 0; // K
    _jump1656:; // Begin body of loop
    _a3_bool _1046;
    // Computing bound for L
    _1046.d0 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    // Computing bound for M
    _1046.d1 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    // Computing bound for N
    _1046.d2 = _526.d0;
    if (_526.d0 > 0) 
    goto _jump1659;
    fail_assertion("non-positive loop bound");
    _jump1659:;
    // Computing total size of heap memory to allocate
    int64_t _1047 = 1;
    _1047 *= _526.d1;
    _1047 *= _526.d0;
    _1047 *= _526.d0;
    _1047 *= sizeof(bool);
    _1046.data = jpl_alloc(_1047);
    int64_t _1048 = 0; // N
    int64_t _1049 = 0; // M
    int64_t _1050 = 0; // L
    _jump1660:; // Begin body of loop
    bool _1051 = _951.d1 != _526.d2;
    int64_t _1052 = 0;
    _1052 *= _1046.d0;
    _1052 += _1050;
    _1052 *= _1046.d1;
    _1052 += _1049;
    _1052 *= _1046.d2;
    _1052 += _1048;
    _1046.data[_1052] = _1051;
    _1048++;
    if (_1048 < _526.d0)
    goto _jump1660;
    _1048 = 0;
    _1049++;
    if (_1049 < _526.d0)
    goto _jump1660;
    _1049 = 0;
    _1050++;
    if (_1050 < _526.d1)
    goto _jump1660;
    // End body of loop
    bool _1053 = false;
    int64_t _1054;
    if (!_1053)
    goto _jump1661;
    _1054 = _527.d1;
    goto _jump1662;
    _jump1661:;
    _1054 = _527.d2;
    _jump1662:;
    if (_660 >= 0)
    goto _jump1663;
    fail_assertion("negative array index");
    _jump1663:;
    if (_660 < _1046.d0)
    goto _jump1664;
    fail_assertion("index too large");
    _jump1664:;
    if (_526.d0 >= 0)
    goto _jump1665;
    fail_assertion("negative array index");
    _jump1665:;
    if (_526.d0 < _1046.d1)
    goto _jump1666;
    fail_assertion("index too large");
    _jump1666:;
    if (_1054 >= 0)
    goto _jump1667;
    fail_assertion("negative array index");
    _jump1667:;
    if (_1054 < _1046.d2)
    goto _jump1668;
    fail_assertion("index too large");
    _jump1668:;
    int64_t _1055 = 0;
    _1055 *= _1046.d0;
    _1055 += _660;
    _1055 *= _1046.d1;
    _1055 += _526.d0;
    _1055 *= _1046.d2;
    _1055 += _1054;
    bool _1056 = _1046.data[_1055];
    bool _1057 = !_1056;
    _a2_rgba _1058;
    if (!_1057)
    goto _jump1669;
    double _1059 = 0.0;
    double _1060 = fmod(_47, _1059);
    double _1061 = -_659;
    double _1062 = _1060 * _1061;
    bool _1063 = _1062 >= _659;
    _a2_rgba _1064;
    if (!_1063)
    goto _jump1670;
    _a2_rgba _1065;
    // Computing bound for L
    int64_t _1066 = -_915.d1;
    _1065.d0 = _1066;
    if (_1066 > 0) 
    goto _jump1671;
    fail_assertion("non-positive loop bound");
    _jump1671:;
    // Computing bound for M
    _1065.d1 = _526.d1;
    if (_526.d1 > 0) 
    goto _jump1672;
    fail_assertion("non-positive loop bound");
    _jump1672:;
    // Computing total size of heap memory to allocate
    int64_t _1067 = 1;
    _1067 *= _1066;
    _1067 *= _526.d1;
    _1067 *= sizeof(rgba);
    _1065.data = jpl_alloc(_1067);
    int64_t _1068 = 0; // M
    int64_t _1069 = 0; // L
    _jump1673:; // Begin body of loop
    int64_t _1070 = 0;
    _1070 *= _1065.d0;
    _1070 += _1069;
    _1070 *= _1065.d1;
    _1070 += _1068;
    _1065.data[_1070] = _847;
    _1068++;
    if (_1068 < _526.d1)
    goto _jump1673;
    _1068 = 0;
    _1069++;
    if (_1069 < _1066)
    goto _jump1673;
    // End body of loop
    _1064 = _1065;
    goto _jump1674;
    _jump1670:;
    _a2_rgba _1071;
    // Computing bound for L
    int64_t _1072;
    // Computing bound for L
    int64_t _1073 = 270;
    if (_1073 > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    // Computing bound for M
    if (_526.d1 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    _1072 = 0;
    int64_t _1074 = 0; // M
    int64_t _1075 = 0; // L
    _jump1677:; // Begin body of loop
    _1072 += _951.d1;
    _1074++;
    if (_1074 < _526.d1)
    goto _jump1677;
    _1074 = 0;
    _1075++;
    if (_1075 < _1073)
    goto _jump1677;
    // End body of loop
    _1071.d0 = _1072;
    if (_1072 > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    // Computing bound for M
    _1071.d1 = _526.d2;
    if (_526.d2 > 0) 
    goto _jump1679;
    fail_assertion("non-positive loop bound");
    _jump1679:;
    // Computing total size of heap memory to allocate
    int64_t _1076 = 1;
    _1076 *= _1072;
    _1076 *= _526.d2;
    _1076 *= sizeof(rgba);
    _1071.data = jpl_alloc(_1076);
    int64_t _1077 = 0; // M
    int64_t _1078 = 0; // L
    _jump1680:; // Begin body of loop
    bool _1079 = false;
    double _1080 = f(_1079);
    double _1081 = 43.0;
    double _1082 = 31.0;
    double _1083 = -_1082;
    rgba _1084 = { _1080, _659, _1081, _1083 };
    int64_t _1085 = 0;
    _1085 *= _1071.d0;
    _1085 += _1078;
    _1085 *= _1071.d1;
    _1085 += _1077;
    _1071.data[_1085] = _1084;
    _1077++;
    if (_1077 < _526.d2)
    goto _jump1680;
    _1077 = 0;
    _1078++;
    if (_1078 < _1072)
    goto _jump1680;
    // End body of loop
    _1064 = _1071;
    _jump1674:;
    _1058 = _1064;
    goto _jump1681;
    _jump1669:;
    double _1086 = 91.0;
    bool _1087 = false;
    double _1088;
    if (!_1087)
    goto _jump1682;
    _1088 = _659;
    goto _jump1683;
    _jump1682:;
    _1088 = _735;
    _jump1683:;
    double _1089 = 49.0;
    double _1090 = 42.0;
    rgba _1091 = { _1086, _1088, _1089, _1090 };
    bool _1092 = v(_1091);
    _a2_rgba _1093;
    if (!_1092)
    goto _jump1684;
    _a2_rgba _1094;
    // Computing bound for L
    _1094.d0 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump1685;
    fail_assertion("non-positive loop bound");
    _jump1685:;
    // Computing bound for M
    _1094.d1 = _527.d2;
    if (_527.d2 > 0) 
    goto _jump1686;
    fail_assertion("non-positive loop bound");
    _jump1686:;
    // Computing total size of heap memory to allocate
    int64_t _1095 = 1;
    _1095 *= _507.d2;
    _1095 *= _527.d2;
    _1095 *= sizeof(rgba);
    _1094.data = jpl_alloc(_1095);
    int64_t _1096 = 0; // M
    int64_t _1097 = 0; // L
    _jump1687:; // Begin body of loop
    int64_t _1098 = 582;
    int64_t _1099 = _951.d0 % _526.d2;
    if (_1098 >= 0)
    goto _jump1688;
    fail_assertion("negative array index");
    _jump1688:;
    if (_1098 < _527.d0)
    goto _jump1689;
    fail_assertion("index too large");
    _jump1689:;
    if (_660 >= 0)
    goto _jump1690;
    fail_assertion("negative array index");
    _jump1690:;
    if (_660 < _527.d1)
    goto _jump1691;
    fail_assertion("index too large");
    _jump1691:;
    if (_1099 >= 0)
    goto _jump1692;
    fail_assertion("negative array index");
    _jump1692:;
    if (_1099 < _527.d2)
    goto _jump1693;
    fail_assertion("index too large");
    _jump1693:;
    int64_t _1100 = 0;
    _1100 *= _527.d0;
    _1100 += _1098;
    _1100 *= _527.d1;
    _1100 += _660;
    _1100 *= _527.d2;
    _1100 += _1099;
    rgba _1101 = _527.data[_1100];
    int64_t _1102 = 0;
    _1102 *= _1094.d0;
    _1102 += _1097;
    _1102 *= _1094.d1;
    _1102 += _1096;
    _1094.data[_1102] = _1101;
    _1096++;
    if (_1096 < _527.d2)
    goto _jump1687;
    _1096 = 0;
    _1097++;
    if (_1097 < _507.d2)
    goto _jump1687;
    // End body of loop
    _1093 = _1094;
    goto _jump1694;
    _jump1684:;
    _a2_rgba _1103;
    // Computing bound for L
    _1103.d0 = _951.d2;
    if (_951.d2 > 0) 
    goto _jump1695;
    fail_assertion("non-positive loop bound");
    _jump1695:;
    // Computing bound for M
    _1103.d1 = _951.d2;
    if (_951.d2 > 0) 
    goto _jump1696;
    fail_assertion("non-positive loop bound");
    _jump1696:;
    // Computing total size of heap memory to allocate
    int64_t _1104 = 1;
    _1104 *= _951.d2;
    _1104 *= _951.d2;
    _1104 *= sizeof(rgba);
    _1103.data = jpl_alloc(_1104);
    int64_t _1105 = 0; // M
    int64_t _1106 = 0; // L
    _jump1697:; // Begin body of loop
    int64_t _1107 = 0;
    _1107 *= _1103.d0;
    _1107 += _1106;
    _1107 *= _1103.d1;
    _1107 += _1105;
    _1103.data[_1107] = _847;
    _1105++;
    if (_1105 < _951.d2)
    goto _jump1697;
    _1105 = 0;
    _1106++;
    if (_1106 < _951.d2)
    goto _jump1697;
    // End body of loop
    _1093 = _1103;
    _jump1694:;
    _1058 = _1093;
    _jump1681:;
    int64_t _1108 = 0;
    _1108 *= _1041.d0;
    _1108 += _1045;
    _1041.data[_1108] = _1058;
    _1045++;
    if (_1045 < _1042)
    goto _jump1656;
    // End body of loop
    if (_526.d1 >= 0)
    goto _jump1698;
    fail_assertion("negative array index");
    _jump1698:;
    if (_526.d1 < _1041.d0)
    goto _jump1699;
    fail_assertion("index too large");
    _jump1699:;
    int64_t _1109 = 0;
    _1109 *= _1041.d0;
    _1109 += _526.d1;
    _a2_rgba _1110 = _1041.data[_1109];
    write_image(_1110, "K.png");
}

