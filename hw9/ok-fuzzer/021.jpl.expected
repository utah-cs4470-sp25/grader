
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  _a3__a3_bool *data;
} _a1__a3__a3_bool;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
    bool a;
    _a1__a2_double b;
} r;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  r *data;
} _a3_r;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a3_int64_t *data;
} _a1__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a1__a3_int64_t *data;
} _a1__a1__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_void_t *data;
} _a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_void_t *data;
} _a3__a3__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_int64_t *data;
} _a3__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_double *data;
} _a1__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_rgba *data;
} _a3__a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  _a1_rgba *data;
} _a1__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_int64_t *data;
} _a3__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  _a2__a3_int64_t *data;
} _a1__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a2__a3_int64_t *data;
} _a1__a1__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a3_int64_t *data;
} _a2__a1__a3_int64_t;

int64_t n() {
    bool _0 = i <= c;
    if (0 != _0)
    goto _jump407;
    fail_assertion("o");
    _jump407:;
    _a1__a3__a3_bool _1;
    // Computing bound for o
    _1.d0 = k;
    if (k > 0) 
    goto _jump408;
    fail_assertion("non-positive loop bound");
    _jump408:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= k;
    _2 *= sizeof(_a3__a3_bool);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // o
    _jump409:; // Begin body of loop
    bool _4 = false;
    _a3__a3_bool _5;
    if (!_4)
    goto _jump410;
    _a3__a3_bool _6;
    // Computing bound for p
    _6.d0 = d;
    if (d > 0) 
    goto _jump411;
    fail_assertion("non-positive loop bound");
    _jump411:;
    // Computing bound for q
    int64_t _7 = n();
    _6.d1 = _7;
    if (_7 > 0) 
    goto _jump412;
    fail_assertion("non-positive loop bound");
    _jump412:;
    // Computing bound for r
    _6.d2 = b;
    if (b > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= d;
    _8 *= _7;
    _8 *= b;
    _8 *= sizeof(_a3_bool);
    _6.data = jpl_alloc(_8);
    int64_t _9 = 0; // r
    int64_t _10 = 0; // q
    int64_t _11 = 0; // p
    _jump414:; // Begin body of loop
    int64_t _12 = 0;
    _12 *= _6.d0;
    _12 += _11;
    _12 *= _6.d1;
    _12 += _10;
    _12 *= _6.d2;
    _12 += _9;
    _6.data[_12] = h;
    _9++;
    if (_9 < b)
    goto _jump414;
    _9 = 0;
    _10++;
    if (_10 < _7)
    goto _jump414;
    _10 = 0;
    _11++;
    if (_11 < d)
    goto _jump414;
    // End body of loop
    _5 = _6;
    goto _jump415;
    _jump410:;
    _a3__a3_bool _13;
    // Computing bound for p
    _13.d0 = f;
    if (f > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    // Computing bound for q
    int64_t _14 = n();
    _13.d1 = _14;
    if (_14 > 0) 
    goto _jump417;
    fail_assertion("non-positive loop bound");
    _jump417:;
    // Computing bound for r
    _13.d2 = i;
    if (i > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= f;
    _15 *= _14;
    _15 *= i;
    _15 *= sizeof(_a3_bool);
    _13.data = jpl_alloc(_15);
    int64_t _16 = 0; // r
    int64_t _17 = 0; // q
    int64_t _18 = 0; // p
    _jump419:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _13.d0;
    _19 += _18;
    _19 *= _13.d1;
    _19 += _17;
    _19 *= _13.d2;
    _19 += _16;
    _13.data[_19] = h;
    _16++;
    if (_16 < i)
    goto _jump419;
    _16 = 0;
    _17++;
    if (_17 < _14)
    goto _jump419;
    _17 = 0;
    _18++;
    if (_18 < f)
    goto _jump419;
    // End body of loop
    _5 = _13;
    _jump415:;
    _a1__a3__a3_bool _20;
    _20.d0 = 1;
    _20.data = jpl_alloc(sizeof(_a3__a3_bool) * 1);
    _20.data[0] = _5;
    if (b >= 0)
    goto _jump420;
    fail_assertion("negative array index");
    _jump420:;
    if (b < _20.d0)
    goto _jump421;
    fail_assertion("index too large");
    _jump421:;
    int64_t _21 = 0;
    _21 *= _20.d0;
    _21 += b;
    _a3__a3_bool _22 = _20.data[_21];
    int64_t _23 = 0;
    _23 *= _1.d0;
    _23 += _3;
    _1.data[_23] = _22;
    _3++;
    if (_3 < k)
    goto _jump409;
    // End body of loop
    if (j >= 0)
    goto _jump422;
    fail_assertion("negative array index");
    _jump422:;
    if (j < _1.d0)
    goto _jump423;
    fail_assertion("index too large");
    _jump423:;
    int64_t _24 = 0;
    _24 *= _1.d0;
    _24 += j;
    _a3__a3_bool _25 = _1.data[_24];
    int64_t _26 = 157;
    int64_t _27 = -b;
    if (_26 >= 0)
    goto _jump424;
    fail_assertion("negative array index");
    _jump424:;
    if (_26 < _25.d0)
    goto _jump425;
    fail_assertion("index too large");
    _jump425:;
    if (j >= 0)
    goto _jump426;
    fail_assertion("negative array index");
    _jump426:;
    if (j < _25.d1)
    goto _jump427;
    fail_assertion("index too large");
    _jump427:;
    if (_27 >= 0)
    goto _jump428;
    fail_assertion("negative array index");
    _jump428:;
    if (_27 < _25.d2)
    goto _jump429;
    fail_assertion("index too large");
    _jump429:;
    int64_t _28 = 0;
    _28 *= _25.d0;
    _28 += _26;
    _28 *= _25.d1;
    _28 += j;
    _28 *= _25.d2;
    _28 += _27;
    _a3_bool _29 = _25.data[_28];
    bool _30 = true;
    if (0 != _30)
    goto _jump430;
    fail_assertion("s");
    _jump430:;
    int64_t _31 = 33;
    return _31;
    int64_t _32 = f / _29.d1;
    return _32;
}

double z(_a3__a2_void_t A, bool E, _a3_int64_t F) {
    _a1_int64_t _0;
    _0.d0 = 3;
    _0.data = jpl_alloc(sizeof(int64_t) * 3);
    _0.data[0] = s;
    _0.data[1] = b;
    _0.data[2] = y;
    _a3_double _1;
    // Computing bound for U
    int64_t _2 = A.d1 / j;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump572;
    fail_assertion("non-positive loop bound");
    _jump572:;
    // Computing bound for V
    int64_t _3;
    if (!E)
    goto _jump573;
    _3 = a.d1;
    goto _jump574;
    _jump573:;
    int64_t _4 = 91;
    _3 = _4;
    _jump574:;
    _1.d1 = _3;
    if (_3 > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    // Computing bound for W
    _1.d2 = F.d0;
    if (F.d0 > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _2;
    _5 *= _3;
    _5 *= F.d0;
    _5 *= sizeof(double);
    _1.data = jpl_alloc(_5);
    int64_t _6 = 0; // W
    int64_t _7 = 0; // V
    int64_t _8 = 0; // U
    _jump577:; // Begin body of loop
    double _9 = 98.0;
    int64_t _10 = 0;
    _10 *= _1.d0;
    _10 += _8;
    _10 *= _1.d1;
    _10 += _7;
    _10 *= _1.d2;
    _10 += _6;
    _1.data[_10] = _9;
    _6++;
    if (_6 < F.d0)
    goto _jump577;
    _6 = 0;
    _7++;
    if (_7 < _3)
    goto _jump577;
    _7 = 0;
    _8++;
    if (_8 < _2)
    goto _jump577;
    // End body of loop
    int64_t _11;
    // Computing bound for U
    if (d > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing bound for V
    if (F.d0 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for W
    if (d > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    _11 = 0;
    int64_t _12 = 0; // W
    int64_t _13 = 0; // V
    int64_t _14 = 0; // U
    _jump581:; // Begin body of loop
    int64_t _15 = n();
    _11 += _15;
    _12++;
    if (_12 < d)
    goto _jump581;
    _12 = 0;
    _13++;
    if (_13 < F.d0)
    goto _jump581;
    _13 = 0;
    _14++;
    if (_14 < d)
    goto _jump581;
    // End body of loop
    if (s >= 0)
    goto _jump582;
    fail_assertion("negative array index");
    _jump582:;
    if (s < _1.d0)
    goto _jump583;
    fail_assertion("index too large");
    _jump583:;
    if (F.d0 >= 0)
    goto _jump584;
    fail_assertion("negative array index");
    _jump584:;
    if (F.d0 < _1.d1)
    goto _jump585;
    fail_assertion("index too large");
    _jump585:;
    if (_11 >= 0)
    goto _jump586;
    fail_assertion("negative array index");
    _jump586:;
    if (_11 < _1.d2)
    goto _jump587;
    fail_assertion("index too large");
    _jump587:;
    int64_t _16 = 0;
    _16 *= _1.d0;
    _16 += s;
    _16 *= _1.d1;
    _16 += F.d0;
    _16 *= _1.d2;
    _16 += _11;
    double _17 = _1.data[_16];
    bool _18 = A.d1 < i;
    bool _19 = !_18;
    double _20;
    if (!_19)
    goto _jump588;
    double _21;
    // Computing bound for U
    int64_t _22 = 848;
    if (_22 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing bound for V
    if (q > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing bound for W
    if (w > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    _21 = 0;
    int64_t _23 = 0; // W
    int64_t _24 = 0; // V
    int64_t _25 = 0; // U
    _jump592:; // Begin body of loop
    double _26 = 44.0;
    _21 += _26;
    _23++;
    if (_23 < w)
    goto _jump592;
    _23 = 0;
    _24++;
    if (_24 < q)
    goto _jump592;
    _24 = 0;
    _25++;
    if (_25 < _22)
    goto _jump592;
    // End body of loop
    _20 = _21;
    goto _jump593;
    _jump588:;
    double _27;
    // Computing bound for U
    if (s > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    _27 = 0;
    int64_t _28 = 0; // U
    _jump595:; // Begin body of loop
    double _29 = 44.0;
    double _30 = -_29;
    _27 += _30;
    _28++;
    if (_28 < s)
    goto _jump595;
    // End body of loop
    _20 = _27;
    _jump593:;
    bool _31 = _17 > _20;
    bool _32;
    if (!_31)
    goto _jump596;
    bool _33 = E;
    if (0 != E)
    goto _jump597;
    _33 = E;
    _jump597:;
    bool _34 = !_33;
    _32 = _34;
    goto _jump598;
    _jump596:;
    _a1_bool _36;
    // Computing bound for U
    _36.d0 = F.d0;
    if (F.d0 > 0) 
    goto _jump599;
    fail_assertion("non-positive loop bound");
    _jump599:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= F.d0;
    _37 *= sizeof(bool);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // U
    _jump600:; // Begin body of loop
    bool _39 = false;
    int64_t _40 = 0;
    _40 *= _36.d0;
    _40 += _38;
    _36.data[_40] = _39;
    _38++;
    if (_38 < F.d0)
    goto _jump600;
    // End body of loop
    if (d >= 0)
    goto _jump601;
    fail_assertion("negative array index");
    _jump601:;
    if (d < _36.d0)
    goto _jump602;
    fail_assertion("index too large");
    _jump602:;
    int64_t _41 = 0;
    _41 *= _36.d0;
    _41 += d;
    bool _42 = _36.data[_41];
    bool _43;
    if (!_42)
    goto _jump603;
    bool _44 = a.d0 < F.d0;
    _43 = _44;
    goto _jump604;
    _jump603:;
    if (v >= 0)
    goto _jump605;
    fail_assertion("negative array index");
    _jump605:;
    if (v < h.d0)
    goto _jump606;
    fail_assertion("index too large");
    _jump606:;
    if (v >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (v < h.d1)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    if (g >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (g < h.d2)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _45 = 0;
    _45 *= h.d0;
    _45 += v;
    _45 *= h.d1;
    _45 += v;
    _45 *= h.d2;
    _45 += g;
    bool _46 = h.data[_45];
    _43 = _46;
    _jump604:;
    bool _35 = _43;
    if (0 == _43)
    goto _jump611;
    double _47 = 78.0;
    bool _48 = true;
    bool _49 = !_48;
    double _50;
    if (!_49)
    goto _jump612;
    double _51 = 9.0;
    _50 = _51;
    goto _jump613;
    _jump612:;
    double _52 = 49.0;
    _50 = _52;
    _jump613:;
    bool _53 = _47 >= _50;
    _35 = _53;
    _jump611:;
    _32 = _35;
    _jump598:;
    bool _54 = !_32;
    double _55;
    if (!_54)
    goto _jump614;
    int64_t _56;
    // Computing bound for U
    if (a.d1 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing bound for V
    if (F.d0 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing bound for W
    if (d > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    _56 = 0;
    int64_t _57 = 0; // W
    int64_t _58 = 0; // V
    int64_t _59 = 0; // U
    _jump618:; // Begin body of loop
    _56 += d;
    _57++;
    if (_57 < d)
    goto _jump618;
    _57 = 0;
    _58++;
    if (_58 < F.d0)
    goto _jump618;
    _58 = 0;
    _59++;
    if (_59 < a.d1)
    goto _jump618;
    // End body of loop
    int64_t _60 = 365;
    bool _61 = _56 <= _60;
    double _62;
    if (!_61)
    goto _jump619;
    double _63 = 82.0;
    double _64 = -_63;
    double _65 = -_64;
    _62 = _65;
    goto _jump620;
    _jump619:;
    double _66;
    // Computing bound for U
    int64_t _67 = -c;
    if (_67 > 0) 
    goto _jump621;
    fail_assertion("non-positive loop bound");
    _jump621:;
    // Computing bound for V
    if (p.d1 > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    // Computing bound for W
    if (j > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    _66 = 0;
    int64_t _68 = 0; // W
    int64_t _69 = 0; // V
    int64_t _70 = 0; // U
    _jump624:; // Begin body of loop
    double _71 = 87.0;
    _66 += _71;
    _68++;
    if (_68 < j)
    goto _jump624;
    _68 = 0;
    _69++;
    if (_69 < p.d1)
    goto _jump624;
    _69 = 0;
    _70++;
    if (_70 < _67)
    goto _jump624;
    // End body of loop
    _62 = _66;
    _jump620:;
    double _72 = 62.0;
    double _73;
    // Computing bound for U
    if (A.d0 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for V
    if (A.d0 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    _73 = 0;
    int64_t _74 = 0; // V
    int64_t _75 = 0; // U
    _jump627:; // Begin body of loop
    bool _76 = false;
    double _77 = z(A, _76, F);
    _73 += _77;
    _74++;
    if (_74 < A.d0)
    goto _jump627;
    _74 = 0;
    _75++;
    if (_75 < A.d0)
    goto _jump627;
    // End body of loop
    double _78 = _72 * _73;
    bool _79 = _62 <= _78;
    double _80;
    if (!_79)
    goto _jump628;
    double _81 = 52.0;
    _80 = _81;
    goto _jump629;
    _jump628:;
    bool _83 = d != A.d0;
    bool _82 = _83;
    if (0 != _83)
    goto _jump630;
    bool _84 = false;
    _82 = _84;
    _jump630:;
    bool _85 = !_82;
    double _86;
    if (!_85)
    goto _jump631;
    _a3__a3__a2_void_t _87;
    // Computing bound for U
    _87.d0 = p.d0;
    if (p.d0 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for V
    _87.d1 = A.d0;
    if (A.d0 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing bound for W
    _87.d2 = b;
    if (b > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= p.d0;
    _88 *= A.d0;
    _88 *= b;
    _88 *= sizeof(_a3__a2_void_t);
    _87.data = jpl_alloc(_88);
    int64_t _89 = 0; // W
    int64_t _90 = 0; // V
    int64_t _91 = 0; // U
    _jump635:; // Begin body of loop
    int64_t _92 = 0;
    _92 *= _87.d0;
    _92 += _91;
    _92 *= _87.d1;
    _92 += _90;
    _92 *= _87.d2;
    _92 += _89;
    _87.data[_92] = A;
    _89++;
    if (_89 < b)
    goto _jump635;
    _89 = 0;
    _90++;
    if (_90 < A.d0)
    goto _jump635;
    _90 = 0;
    _91++;
    if (_91 < p.d0)
    goto _jump635;
    // End body of loop
    if (F.d2 >= 0)
    goto _jump636;
    fail_assertion("negative array index");
    _jump636:;
    if (F.d2 < _87.d0)
    goto _jump637;
    fail_assertion("index too large");
    _jump637:;
    if (A.d0 >= 0)
    goto _jump638;
    fail_assertion("negative array index");
    _jump638:;
    if (A.d0 < _87.d1)
    goto _jump639;
    fail_assertion("index too large");
    _jump639:;
    if (m >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (m < _87.d2)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    int64_t _93 = 0;
    _93 *= _87.d0;
    _93 += F.d2;
    _93 *= _87.d1;
    _93 += A.d0;
    _93 *= _87.d2;
    _93 += m;
    _a3__a2_void_t _94 = _87.data[_93];
    double _95 = z(_94, E, a);
    _86 = _95;
    goto _jump642;
    _jump631:;
    double _96;
    // Computing bound for U
    if (v > 0) 
    goto _jump643;
    fail_assertion("non-positive loop bound");
    _jump643:;
    // Computing bound for V
    if (a.d2 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    _96 = 0;
    int64_t _97 = 0; // V
    int64_t _98 = 0; // U
    _jump645:; // Begin body of loop
    bool _99 = true;
    double _100 = z(A, _99, a);
    _96 += _100;
    _97++;
    if (_97 < a.d2)
    goto _jump645;
    _97 = 0;
    _98++;
    if (_98 < v)
    goto _jump645;
    // End body of loop
    _86 = _96;
    _jump642:;
    _80 = _86;
    _jump629:;
    _a3_double _101;
    // Computing bound for U
    _101.d0 = s;
    if (s > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing bound for V
    _101.d1 = w;
    if (w > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    // Computing bound for W
    _101.d2 = A.d1;
    if (A.d1 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing total size of heap memory to allocate
    int64_t _102 = 1;
    _102 *= s;
    _102 *= w;
    _102 *= A.d1;
    _102 *= sizeof(double);
    _101.data = jpl_alloc(_102);
    int64_t _103 = 0; // W
    int64_t _104 = 0; // V
    int64_t _105 = 0; // U
    _jump649:; // Begin body of loop
    bool _106 = w != _105;
    _a3_int64_t _107;
    if (!E)
    goto _jump650;
    _107 = a;
    goto _jump651;
    _jump650:;
    _107 = a;
    _jump651:;
    double _108 = z(A, _106, _107);
    double _109 = -_108;
    int64_t _110 = 0;
    _110 *= _101.d0;
    _110 += _105;
    _110 *= _101.d1;
    _110 += _104;
    _110 *= _101.d2;
    _110 += _103;
    _101.data[_110] = _109;
    _103++;
    if (_103 < A.d1)
    goto _jump649;
    _103 = 0;
    _104++;
    if (_104 < w)
    goto _jump649;
    _104 = 0;
    _105++;
    if (_105 < s)
    goto _jump649;
    // End body of loop
    if (A.d2 >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (A.d2 < _101.d0)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    if (A.d0 >= 0)
    goto _jump654;
    fail_assertion("negative array index");
    _jump654:;
    if (A.d0 < _101.d1)
    goto _jump655;
    fail_assertion("index too large");
    _jump655:;
    if (m >= 0)
    goto _jump656;
    fail_assertion("negative array index");
    _jump656:;
    if (m < _101.d2)
    goto _jump657;
    fail_assertion("index too large");
    _jump657:;
    int64_t _111 = 0;
    _111 *= _101.d0;
    _111 += A.d2;
    _111 *= _101.d1;
    _111 += A.d0;
    _111 *= _101.d2;
    _111 += m;
    double _112 = _101.data[_111];
    double _113 = fmod(_80, _112);
    _55 = _113;
    goto _jump658;
    _jump614:;
    double _114;
    // Computing bound for U
    if (v > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing bound for V
    _a3__a3__a3_int64_t _115;
    // Computing bound for U
    _115.d0 = A.d2;
    if (A.d2 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for V
    _115.d1 = a.d2;
    if (a.d2 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing bound for W
    _115.d2 = v;
    if (v > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= A.d2;
    _116 *= a.d2;
    _116 *= v;
    _116 *= sizeof(_a3__a3_int64_t);
    _115.data = jpl_alloc(_116);
    int64_t _117 = 0; // W
    int64_t _118 = 0; // V
    int64_t _119 = 0; // U
    _jump663:; // Begin body of loop
    _a3__a3_int64_t _120;
    // Computing bound for X
    _120.d0 = k;
    if (k > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing bound for Y
    _120.d1 = g;
    if (g > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for Z
    _120.d2 = c;
    if (c > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= k;
    _121 *= g;
    _121 *= c;
    _121 *= sizeof(_a3_int64_t);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // Z
    int64_t _123 = 0; // Y
    int64_t _124 = 0; // X
    _jump667:; // Begin body of loop
    int64_t _125 = 0;
    _125 *= _120.d0;
    _125 += _124;
    _125 *= _120.d1;
    _125 += _123;
    _125 *= _120.d2;
    _125 += _122;
    _120.data[_125] = a;
    _122++;
    if (_122 < c)
    goto _jump667;
    _122 = 0;
    _123++;
    if (_123 < g)
    goto _jump667;
    _123 = 0;
    _124++;
    if (_124 < k)
    goto _jump667;
    // End body of loop
    int64_t _126 = 0;
    _126 *= _115.d0;
    _126 += _119;
    _126 *= _115.d1;
    _126 += _118;
    _126 *= _115.d2;
    _126 += _117;
    _115.data[_126] = _120;
    _117++;
    if (_117 < v)
    goto _jump663;
    _117 = 0;
    _118++;
    if (_118 < a.d2)
    goto _jump663;
    _118 = 0;
    _119++;
    if (_119 < A.d2)
    goto _jump663;
    // End body of loop
    if (f >= 0)
    goto _jump668;
    fail_assertion("negative array index");
    _jump668:;
    if (f < _115.d0)
    goto _jump669;
    fail_assertion("index too large");
    _jump669:;
    if (d >= 0)
    goto _jump670;
    fail_assertion("negative array index");
    _jump670:;
    if (d < _115.d1)
    goto _jump671;
    fail_assertion("index too large");
    _jump671:;
    if (p.d1 >= 0)
    goto _jump672;
    fail_assertion("negative array index");
    _jump672:;
    if (p.d1 < _115.d2)
    goto _jump673;
    fail_assertion("index too large");
    _jump673:;
    int64_t _127 = 0;
    _127 *= _115.d0;
    _127 += f;
    _127 *= _115.d1;
    _127 += d;
    _127 *= _115.d2;
    _127 += p.d1;
    _a3__a3_int64_t _128 = _115.data[_127];
    if (A.d0 >= 0)
    goto _jump674;
    fail_assertion("negative array index");
    _jump674:;
    if (A.d0 < _128.d0)
    goto _jump675;
    fail_assertion("index too large");
    _jump675:;
    if (b >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (b < _128.d1)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    if (F.d1 >= 0)
    goto _jump678;
    fail_assertion("negative array index");
    _jump678:;
    if (F.d1 < _128.d2)
    goto _jump679;
    fail_assertion("index too large");
    _jump679:;
    int64_t _129 = 0;
    _129 *= _128.d0;
    _129 += A.d0;
    _129 *= _128.d1;
    _129 += b;
    _129 *= _128.d2;
    _129 += F.d1;
    _a3_int64_t _130 = _128.data[_129];
    int64_t _131;
    if (!E)
    goto _jump680;
    _131 = s;
    goto _jump681;
    _jump680:;
    _131 = u;
    _jump681:;
    if (_131 >= 0)
    goto _jump682;
    fail_assertion("negative array index");
    _jump682:;
    if (_131 < _130.d0)
    goto _jump683;
    fail_assertion("index too large");
    _jump683:;
    if (p.d1 >= 0)
    goto _jump684;
    fail_assertion("negative array index");
    _jump684:;
    if (p.d1 < _130.d1)
    goto _jump685;
    fail_assertion("index too large");
    _jump685:;
    if (d >= 0)
    goto _jump686;
    fail_assertion("negative array index");
    _jump686:;
    if (d < _130.d2)
    goto _jump687;
    fail_assertion("index too large");
    _jump687:;
    int64_t _132 = 0;
    _132 *= _130.d0;
    _132 += _131;
    _132 *= _130.d1;
    _132 += p.d1;
    _132 *= _130.d2;
    _132 += d;
    int64_t _133 = _130.data[_132];
    if (_133 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for W
    if (i > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    _114 = 0;
    int64_t _134 = 0; // W
    int64_t _135 = 0; // V
    int64_t _136 = 0; // U
    _jump690:; // Begin body of loop
    double _137;
    // Computing bound for X
    if (y > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for Y
    if (_0.d0 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing bound for Z
    if (A.d2 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    _137 = 0;
    int64_t _138 = 0; // Z
    int64_t _139 = 0; // Y
    int64_t _140 = 0; // X
    _jump694:; // Begin body of loop
    double _141 = 50.0;
    double _142 = -_141;
    _137 += _142;
    _138++;
    if (_138 < A.d2)
    goto _jump694;
    _138 = 0;
    _139++;
    if (_139 < _0.d0)
    goto _jump694;
    _139 = 0;
    _140++;
    if (_140 < y)
    goto _jump694;
    // End body of loop
    double _143 = -_137;
    double _144 = -_143;
    _114 += _144;
    _134++;
    if (_134 < i)
    goto _jump690;
    _134 = 0;
    _135++;
    if (_135 < _133)
    goto _jump690;
    _135 = 0;
    _136++;
    if (_136 < v)
    goto _jump690;
    // End body of loop
    _55 = _114;
    _jump658:;
    return _55;
    double _145;
    // Computing bound for U
    if (A.d0 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for V
    if (a.d0 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    _145 = 0;
    int64_t _146 = 0; // V
    int64_t _147 = 0; // U
    _jump697:; // Begin body of loop
    _a3_double _148;
    if (!E)
    goto _jump698;
    _a1__a3_double _149;
    // Computing bound for W
    _149.d0 = v;
    if (v > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= v;
    _150 *= sizeof(_a3_double);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // W
    _jump700:; // Begin body of loop
    _a3_double _152;
    // Computing bound for X
    int64_t _153 = -F.d2;
    _152.d0 = _153;
    if (_153 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing bound for Y
    _152.d1 = _147;
    if (_147 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    // Computing bound for Z
    _152.d2 = F.d0;
    if (F.d0 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= _153;
    _154 *= _147;
    _154 *= F.d0;
    _154 *= sizeof(double);
    _152.data = jpl_alloc(_154);
    int64_t _155 = 0; // Z
    int64_t _156 = 0; // Y
    int64_t _157 = 0; // X
    _jump704:; // Begin body of loop
    double _158 = 42.0;
    int64_t _159 = 0;
    _159 *= _152.d0;
    _159 += _157;
    _159 *= _152.d1;
    _159 += _156;
    _159 *= _152.d2;
    _159 += _155;
    _152.data[_159] = _158;
    _155++;
    if (_155 < F.d0)
    goto _jump704;
    _155 = 0;
    _156++;
    if (_156 < _147)
    goto _jump704;
    _156 = 0;
    _157++;
    if (_157 < _153)
    goto _jump704;
    // End body of loop
    int64_t _160 = 0;
    _160 *= _149.d0;
    _160 += _151;
    _149.data[_160] = _152;
    _151++;
    if (_151 < v)
    goto _jump700;
    // End body of loop
    if (F.d1 >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (F.d1 < _149.d0)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    int64_t _161 = 0;
    _161 *= _149.d0;
    _161 += F.d1;
    _a3_double _162 = _149.data[_161];
    _148 = _162;
    goto _jump707;
    _jump698:;
    _a3_double _163;
    // Computing bound for W
    _163.d0 = q;
    if (q > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    // Computing bound for X
    _163.d1 = A.d1;
    if (A.d1 > 0) 
    goto _jump709;
    fail_assertion("non-positive loop bound");
    _jump709:;
    // Computing bound for Y
    _163.d2 = j;
    if (j > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= q;
    _164 *= A.d1;
    _164 *= j;
    _164 *= sizeof(double);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // Y
    int64_t _166 = 0; // X
    int64_t _167 = 0; // W
    _jump711:; // Begin body of loop
    double _168 = 24.0;
    double _169 = 68.0;
    double _170 = _168 + _169;
    int64_t _171 = 0;
    _171 *= _163.d0;
    _171 += _167;
    _171 *= _163.d1;
    _171 += _166;
    _171 *= _163.d2;
    _171 += _165;
    _163.data[_171] = _170;
    _165++;
    if (_165 < j)
    goto _jump711;
    _165 = 0;
    _166++;
    if (_166 < A.d1)
    goto _jump711;
    _166 = 0;
    _167++;
    if (_167 < q)
    goto _jump711;
    // End body of loop
    _148 = _163;
    _jump707:;
    if (v >= 0)
    goto _jump712;
    fail_assertion("negative array index");
    _jump712:;
    if (v < _148.d0)
    goto _jump713;
    fail_assertion("index too large");
    _jump713:;
    if (w >= 0)
    goto _jump714;
    fail_assertion("negative array index");
    _jump714:;
    if (w < _148.d1)
    goto _jump715;
    fail_assertion("index too large");
    _jump715:;
    if (F.d1 >= 0)
    goto _jump716;
    fail_assertion("negative array index");
    _jump716:;
    if (F.d1 < _148.d2)
    goto _jump717;
    fail_assertion("index too large");
    _jump717:;
    int64_t _172 = 0;
    _172 *= _148.d0;
    _172 += v;
    _172 *= _148.d1;
    _172 += w;
    _172 *= _148.d2;
    _172 += F.d1;
    double _173 = _148.data[_172];
    _145 += _173;
    _146++;
    if (_146 < a.d0)
    goto _jump697;
    _146 = 0;
    _147++;
    if (_147 < A.d0)
    goto _jump697;
    // End body of loop
    return _145;
}

rgba A() {
    rgba _0 = A();
    return _0;
    _a2_rgba _1;
    // Computing bound for B
    _1.d0 = g;
    if (g > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for C
    _1.d1 = c;
    if (c > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= g;
    _2 *= c;
    _2 *= sizeof(rgba);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // C
    int64_t _4 = 0; // B
    _jump720:; // Begin body of loop
    int64_t _5 = -c;
    if (w >= 0)
    goto _jump721;
    fail_assertion("negative array index");
    _jump721:;
    if (w < o.d0)
    goto _jump722;
    fail_assertion("index too large");
    _jump722:;
    if (_5 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (_5 < o.d1)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    if (m >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (m < o.d2)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    int64_t _6 = 0;
    _6 *= o.d0;
    _6 += w;
    _6 *= o.d1;
    _6 += _5;
    _6 *= o.d2;
    _6 += m;
    bool _7 = o.data[_6];
    rgba _8;
    if (!_7)
    goto _jump727;
    _a3_rgba _9;
    // Computing bound for D
    _9.d0 = j;
    if (j > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for E
    _9.d1 = _4;
    if (_4 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing bound for F
    _9.d2 = j;
    if (j > 0) 
    goto _jump730;
    fail_assertion("non-positive loop bound");
    _jump730:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= j;
    _10 *= _4;
    _10 *= j;
    _10 *= sizeof(rgba);
    _9.data = jpl_alloc(_10);
    int64_t _11 = 0; // F
    int64_t _12 = 0; // E
    int64_t _13 = 0; // D
    _jump731:; // Begin body of loop
    rgba _14 = A();
    int64_t _15 = 0;
    _15 *= _9.d0;
    _15 += _13;
    _15 *= _9.d1;
    _15 += _12;
    _15 *= _9.d2;
    _15 += _11;
    _9.data[_15] = _14;
    _11++;
    if (_11 < j)
    goto _jump731;
    _11 = 0;
    _12++;
    if (_12 < _4)
    goto _jump731;
    _12 = 0;
    _13++;
    if (_13 < j)
    goto _jump731;
    // End body of loop
    int64_t _16;
    // Computing bound for D
    int64_t _17 = 446;
    if (_17 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    // Computing bound for E
    if (c > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for F
    if (q > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    _16 = 0;
    int64_t _18 = 0; // F
    int64_t _19 = 0; // E
    int64_t _20 = 0; // D
    _jump735:; // Begin body of loop
    _16 += m;
    _18++;
    if (_18 < q)
    goto _jump735;
    _18 = 0;
    _19++;
    if (_19 < c)
    goto _jump735;
    _19 = 0;
    _20++;
    if (_20 < _17)
    goto _jump735;
    // End body of loop
    if (k >= 0)
    goto _jump736;
    fail_assertion("negative array index");
    _jump736:;
    if (k < _9.d0)
    goto _jump737;
    fail_assertion("index too large");
    _jump737:;
    if (_16 >= 0)
    goto _jump738;
    fail_assertion("negative array index");
    _jump738:;
    if (_16 < _9.d1)
    goto _jump739;
    fail_assertion("index too large");
    _jump739:;
    if (_3 >= 0)
    goto _jump740;
    fail_assertion("negative array index");
    _jump740:;
    if (_3 < _9.d2)
    goto _jump741;
    fail_assertion("index too large");
    _jump741:;
    int64_t _21 = 0;
    _21 *= _9.d0;
    _21 += k;
    _21 *= _9.d1;
    _21 += _16;
    _21 *= _9.d2;
    _21 += _3;
    rgba _22 = _9.data[_21];
    _8 = _22;
    goto _jump742;
    _jump727:;
    rgba _23 = A();
    rgba _24 = A();
    rgba _25 = A();
    _a1_rgba _26;
    _26.d0 = 3;
    _26.data = jpl_alloc(sizeof(rgba) * 3);
    _26.data[0] = _23;
    _26.data[1] = _24;
    _26.data[2] = _25;
    if (v >= 0)
    goto _jump743;
    fail_assertion("negative array index");
    _jump743:;
    if (v < _26.d0)
    goto _jump744;
    fail_assertion("index too large");
    _jump744:;
    int64_t _27 = 0;
    _27 *= _26.d0;
    _27 += v;
    rgba _28 = _26.data[_27];
    _8 = _28;
    _jump742:;
    int64_t _29 = 0;
    _29 *= _1.d0;
    _29 += _4;
    _29 *= _1.d1;
    _29 += _3;
    _1.data[_29] = _8;
    _3++;
    if (_3 < c)
    goto _jump720;
    _3 = 0;
    _4++;
    if (_4 < g)
    goto _jump720;
    // End body of loop
    if (y >= 0)
    goto _jump745;
    fail_assertion("negative array index");
    _jump745:;
    if (y < _1.d0)
    goto _jump746;
    fail_assertion("index too large");
    _jump746:;
    if (c >= 0)
    goto _jump747;
    fail_assertion("negative array index");
    _jump747:;
    if (c < _1.d1)
    goto _jump748;
    fail_assertion("index too large");
    _jump748:;
    int64_t _30 = 0;
    _30 *= _1.d0;
    _30 += y;
    _30 *= _1.d1;
    _30 += c;
    rgba _31 = _1.data[_30];
    double _32 = _31.b;
    double _33;
    // Computing bound for B
    if (s > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    // Computing bound for C
    if (y > 0) 
    goto _jump750;
    fail_assertion("non-positive loop bound");
    _jump750:;
    // Computing bound for D
    if (s > 0) 
    goto _jump751;
    fail_assertion("non-positive loop bound");
    _jump751:;
    _33 = 0;
    int64_t _34 = 0; // D
    int64_t _35 = 0; // C
    int64_t _36 = 0; // B
    _jump752:; // Begin body of loop
    double _37;
    // Computing bound for E
    int64_t _39 = 36;
    bool _40 = _39 > c;
    bool _38 = _40;
    if (0 == _40)
    goto _jump753;
    bool _41 = _35 > u;
    _38 = _41;
    _jump753:;
    int64_t _42;
    if (!_38)
    goto _jump754;
    _42 = w;
    goto _jump755;
    _jump754:;
    int64_t _43 = c / b;
    _42 = _43;
    _jump755:;
    int64_t _44 = j * _42;
    if (_44 > 0) 
    goto _jump756;
    fail_assertion("non-positive loop bound");
    _jump756:;
    _37 = 0;
    int64_t _45 = 0; // E
    _jump757:; // Begin body of loop
    _a2_double _46;
    // Computing bound for F
    int64_t _47 = 115;
    int64_t _48 = s + _47;
    _46.d0 = _48;
    if (_48 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing bound for G
    int64_t _49 = u - u;
    _46.d1 = _49;
    if (_49 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _48;
    _50 *= _49;
    _50 *= sizeof(double);
    _46.data = jpl_alloc(_50);
    int64_t _51 = 0; // G
    int64_t _52 = 0; // F
    _jump760:; // Begin body of loop
    rgba _53 = A();
    double _54 = _53.a;
    int64_t _55 = 0;
    _55 *= _46.d0;
    _55 += _52;
    _55 *= _46.d1;
    _55 += _51;
    _46.data[_55] = _54;
    _51++;
    if (_51 < _49)
    goto _jump760;
    _51 = 0;
    _52++;
    if (_52 < _48)
    goto _jump760;
    // End body of loop
    int64_t _56 = 175;
    if (v >= 0)
    goto _jump761;
    fail_assertion("negative array index");
    _jump761:;
    if (v < _46.d0)
    goto _jump762;
    fail_assertion("index too large");
    _jump762:;
    if (_56 >= 0)
    goto _jump763;
    fail_assertion("negative array index");
    _jump763:;
    if (_56 < _46.d1)
    goto _jump764;
    fail_assertion("index too large");
    _jump764:;
    int64_t _57 = 0;
    _57 *= _46.d0;
    _57 += v;
    _57 *= _46.d1;
    _57 += _56;
    double _58 = _46.data[_57];
    _37 += _58;
    _45++;
    if (_45 < _44)
    goto _jump757;
    // End body of loop
    _33 += _37;
    _34++;
    if (_34 < s)
    goto _jump752;
    _34 = 0;
    _35++;
    if (_35 < y)
    goto _jump752;
    _35 = 0;
    _36++;
    if (_36 < s)
    goto _jump752;
    // End body of loop
    bool _59 = _32 != _33;
    _a1__a2_int64_t _60;
    // Computing bound for C
    _60.d0 = m;
    if (m > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= m;
    _61 *= sizeof(_a2_int64_t);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // C
    _jump766:; // Begin body of loop
    _a2_int64_t _63;
    // Computing bound for D
    _63.d0 = s;
    if (s > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for E
    _63.d1 = y;
    if (y > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= s;
    _64 *= y;
    _64 *= sizeof(int64_t);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // E
    int64_t _66 = 0; // D
    _jump769:; // Begin body of loop
    int64_t _67 = 387;
    int64_t _68 = 0;
    _68 *= _63.d0;
    _68 += _66;
    _68 *= _63.d1;
    _68 += _65;
    _63.data[_68] = _67;
    _65++;
    if (_65 < y)
    goto _jump769;
    _65 = 0;
    _66++;
    if (_66 < s)
    goto _jump769;
    // End body of loop
    int64_t _69 = 0;
    _69 *= _60.d0;
    _69 += _62;
    _60.data[_69] = _63;
    _62++;
    if (_62 < m)
    goto _jump766;
    // End body of loop
    if (b >= 0)
    goto _jump770;
    fail_assertion("negative array index");
    _jump770:;
    if (b < _60.d0)
    goto _jump771;
    fail_assertion("index too large");
    _jump771:;
    int64_t _70 = 0;
    _70 *= _60.d0;
    _70 += b;
    _a2_int64_t _71 = _60.data[_70];
    _a2_rgba _72;
    if (!_59)
    goto _jump772;
    _a2__a2_rgba _73;
    // Computing bound for F
    _73.d0 = q;
    if (q > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing bound for G
    int64_t _74 = 464;
    _73.d1 = _74;
    if (_74 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= q;
    _75 *= _74;
    _75 *= sizeof(_a2_rgba);
    _73.data = jpl_alloc(_75);
    int64_t _76 = 0; // G
    int64_t _77 = 0; // F
    _jump775:; // Begin body of loop
    bool _78 = g >= _76;
    _a2_rgba _79;
    if (!_78)
    goto _jump776;
    bool _80 = true;
    _a2_rgba _81;
    if (!_80)
    goto _jump777;
    _a2_rgba _82;
    // Computing bound for H
    _82.d0 = g;
    if (g > 0) 
    goto _jump778;
    fail_assertion("non-positive loop bound");
    _jump778:;
    // Computing bound for I
    _82.d1 = m;
    if (m > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing total size of heap memory to allocate
    int64_t _83 = 1;
    _83 *= g;
    _83 *= m;
    _83 *= sizeof(rgba);
    _82.data = jpl_alloc(_83);
    int64_t _84 = 0; // I
    int64_t _85 = 0; // H
    _jump780:; // Begin body of loop
    rgba _86 = A();
    int64_t _87 = 0;
    _87 *= _82.d0;
    _87 += _85;
    _87 *= _82.d1;
    _87 += _84;
    _82.data[_87] = _86;
    _84++;
    if (_84 < m)
    goto _jump780;
    _84 = 0;
    _85++;
    if (_85 < g)
    goto _jump780;
    // End body of loop
    _81 = _82;
    goto _jump781;
    _jump777:;
    _a2_rgba _88;
    // Computing bound for H
    _88.d0 = _71.d1;
    if (_71.d1 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing bound for I
    _88.d1 = _76;
    if (_76 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _71.d1;
    _89 *= _76;
    _89 *= sizeof(rgba);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // I
    int64_t _91 = 0; // H
    _jump784:; // Begin body of loop
    rgba _92 = A();
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _91;
    _93 *= _88.d1;
    _93 += _90;
    _88.data[_93] = _92;
    _90++;
    if (_90 < _76)
    goto _jump784;
    _90 = 0;
    _91++;
    if (_91 < _71.d1)
    goto _jump784;
    // End body of loop
    _81 = _88;
    _jump781:;
    _79 = _81;
    goto _jump785;
    _jump776:;
    bool _94 = k != m;
    _a2_rgba _95;
    if (!_94)
    goto _jump786;
    _a2_rgba _96;
    // Computing bound for H
    _96.d0 = _77;
    if (_77 > 0) 
    goto _jump787;
    fail_assertion("non-positive loop bound");
    _jump787:;
    // Computing bound for I
    _96.d1 = q;
    if (q > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= _77;
    _97 *= q;
    _97 *= sizeof(rgba);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // I
    int64_t _99 = 0; // H
    _jump789:; // Begin body of loop
    rgba _100 = A();
    int64_t _101 = 0;
    _101 *= _96.d0;
    _101 += _99;
    _101 *= _96.d1;
    _101 += _98;
    _96.data[_101] = _100;
    _98++;
    if (_98 < q)
    goto _jump789;
    _98 = 0;
    _99++;
    if (_99 < _77)
    goto _jump789;
    // End body of loop
    _95 = _96;
    goto _jump790;
    _jump786:;
    _a2_rgba _102;
    // Computing bound for H
    _102.d0 = _71.d1;
    if (_71.d1 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for I
    _102.d1 = _77;
    if (_77 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= _71.d1;
    _103 *= _77;
    _103 *= sizeof(rgba);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // I
    int64_t _105 = 0; // H
    _jump793:; // Begin body of loop
    rgba _106 = A();
    int64_t _107 = 0;
    _107 *= _102.d0;
    _107 += _105;
    _107 *= _102.d1;
    _107 += _104;
    _102.data[_107] = _106;
    _104++;
    if (_104 < _77)
    goto _jump793;
    _104 = 0;
    _105++;
    if (_105 < _71.d1)
    goto _jump793;
    // End body of loop
    _95 = _102;
    _jump790:;
    _79 = _95;
    _jump785:;
    int64_t _108 = 0;
    _108 *= _73.d0;
    _108 += _77;
    _108 *= _73.d1;
    _108 += _76;
    _73.data[_108] = _79;
    _76++;
    if (_76 < _74)
    goto _jump775;
    _76 = 0;
    _77++;
    if (_77 < q)
    goto _jump775;
    // End body of loop
    if (y >= 0)
    goto _jump794;
    fail_assertion("negative array index");
    _jump794:;
    if (y < _73.d0)
    goto _jump795;
    fail_assertion("index too large");
    _jump795:;
    if (y >= 0)
    goto _jump796;
    fail_assertion("negative array index");
    _jump796:;
    if (y < _73.d1)
    goto _jump797;
    fail_assertion("index too large");
    _jump797:;
    int64_t _109 = 0;
    _109 *= _73.d0;
    _109 += y;
    _109 *= _73.d1;
    _109 += y;
    _a2_rgba _110 = _73.data[_109];
    _72 = _110;
    goto _jump798;
    _jump772:;
    _a3__a3__a2_rgba _111;
    // Computing bound for F
    _111.d0 = g;
    if (g > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    // Computing bound for G
    _111.d1 = _71.d1;
    if (_71.d1 > 0) 
    goto _jump800;
    fail_assertion("non-positive loop bound");
    _jump800:;
    // Computing bound for H
    _111.d2 = c;
    if (c > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= g;
    _112 *= _71.d1;
    _112 *= c;
    _112 *= sizeof(_a3__a2_rgba);
    _111.data = jpl_alloc(_112);
    int64_t _113 = 0; // H
    int64_t _114 = 0; // G
    int64_t _115 = 0; // F
    _jump802:; // Begin body of loop
    _a3__a2_rgba _116;
    // Computing bound for I
    _116.d0 = s;
    if (s > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    // Computing bound for J
    int64_t _117 = -_115;
    _116.d1 = _117;
    if (_117 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing bound for K
    _116.d2 = b;
    if (b > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= s;
    _118 *= _117;
    _118 *= b;
    _118 *= sizeof(_a2_rgba);
    _116.data = jpl_alloc(_118);
    int64_t _119 = 0; // K
    int64_t _120 = 0; // J
    int64_t _121 = 0; // I
    _jump806:; // Begin body of loop
    _a2_rgba _122;
    // Computing bound for L
    _122.d0 = v;
    if (v > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing bound for M
    _122.d1 = v;
    if (v > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= v;
    _123 *= v;
    _123 *= sizeof(rgba);
    _122.data = jpl_alloc(_123);
    int64_t _124 = 0; // M
    int64_t _125 = 0; // L
    _jump809:; // Begin body of loop
    rgba _126 = A();
    int64_t _127 = 0;
    _127 *= _122.d0;
    _127 += _125;
    _127 *= _122.d1;
    _127 += _124;
    _122.data[_127] = _126;
    _124++;
    if (_124 < v)
    goto _jump809;
    _124 = 0;
    _125++;
    if (_125 < v)
    goto _jump809;
    // End body of loop
    int64_t _128 = 0;
    _128 *= _116.d0;
    _128 += _121;
    _128 *= _116.d1;
    _128 += _120;
    _128 *= _116.d2;
    _128 += _119;
    _116.data[_128] = _122;
    _119++;
    if (_119 < b)
    goto _jump806;
    _119 = 0;
    _120++;
    if (_120 < _117)
    goto _jump806;
    _120 = 0;
    _121++;
    if (_121 < s)
    goto _jump806;
    // End body of loop
    int64_t _129 = 0;
    _129 *= _111.d0;
    _129 += _115;
    _129 *= _111.d1;
    _129 += _114;
    _129 *= _111.d2;
    _129 += _113;
    _111.data[_129] = _116;
    _113++;
    if (_113 < c)
    goto _jump802;
    _113 = 0;
    _114++;
    if (_114 < _71.d1)
    goto _jump802;
    _114 = 0;
    _115++;
    if (_115 < g)
    goto _jump802;
    // End body of loop
    if (y >= 0)
    goto _jump810;
    fail_assertion("negative array index");
    _jump810:;
    if (y < _111.d0)
    goto _jump811;
    fail_assertion("index too large");
    _jump811:;
    if (w >= 0)
    goto _jump812;
    fail_assertion("negative array index");
    _jump812:;
    if (w < _111.d1)
    goto _jump813;
    fail_assertion("index too large");
    _jump813:;
    if (d >= 0)
    goto _jump814;
    fail_assertion("negative array index");
    _jump814:;
    if (d < _111.d2)
    goto _jump815;
    fail_assertion("index too large");
    _jump815:;
    int64_t _130 = 0;
    _130 *= _111.d0;
    _130 += y;
    _130 *= _111.d1;
    _130 += w;
    _130 *= _111.d2;
    _130 += d;
    _a3__a2_rgba _131 = _111.data[_130];
    int64_t _132 = -j;
    if (k >= 0)
    goto _jump816;
    fail_assertion("negative array index");
    _jump816:;
    if (k < _131.d0)
    goto _jump817;
    fail_assertion("index too large");
    _jump817:;
    if (_132 >= 0)
    goto _jump818;
    fail_assertion("negative array index");
    _jump818:;
    if (_132 < _131.d1)
    goto _jump819;
    fail_assertion("index too large");
    _jump819:;
    if (b >= 0)
    goto _jump820;
    fail_assertion("negative array index");
    _jump820:;
    if (b < _131.d2)
    goto _jump821;
    fail_assertion("index too large");
    _jump821:;
    int64_t _133 = 0;
    _133 *= _131.d0;
    _133 += k;
    _133 *= _131.d1;
    _133 += _132;
    _133 *= _131.d2;
    _133 += b;
    _a2_rgba _134 = _131.data[_133];
    _72 = _134;
    _jump798:;
    if (u >= 0)
    goto _jump822;
    fail_assertion("negative array index");
    _jump822:;
    if (u < _72.d0)
    goto _jump823;
    fail_assertion("index too large");
    _jump823:;
    if (w >= 0)
    goto _jump824;
    fail_assertion("negative array index");
    _jump824:;
    if (w < _72.d1)
    goto _jump825;
    fail_assertion("index too large");
    _jump825:;
    int64_t _135 = 0;
    _135 *= _72.d0;
    _135 += u;
    _135 *= _72.d1;
    _135 += w;
    rgba _136 = _72.data[_135];
    return _136;
    bool _137 = false;
    if (0 != _137)
    goto _jump826;
    fail_assertion("J");
    _jump826:;
    double _138 = 91.0;
    double _139 = 48.0;
    double _140 = fmod(_138, _139);
    double _141 = 20.0;
    bool _142 = _140 <= _141;
    double _143;
    if (!_142)
    goto _jump827;
    double _144 = 76.0;
    _143 = _144;
    goto _jump828;
    _jump827:;
    rgba _145 = A();
    double _146 = _145.g;
    _143 = _146;
    _jump828:;
    rgba _147 = A();
    double _148 = _147.g;
    double _149 = -_148;
    bool _150 = _143 != _149;
    bool _151 = !_150;
    bool _152;
    if (!_151)
    goto _jump829;
    if (_71.d0 >= 0)
    goto _jump830;
    fail_assertion("negative array index");
    _jump830:;
    if (_71.d0 < o.d0)
    goto _jump831;
    fail_assertion("index too large");
    _jump831:;
    if (_71.d1 >= 0)
    goto _jump832;
    fail_assertion("negative array index");
    _jump832:;
    if (_71.d1 < o.d1)
    goto _jump833;
    fail_assertion("index too large");
    _jump833:;
    if (y >= 0)
    goto _jump834;
    fail_assertion("negative array index");
    _jump834:;
    if (y < o.d2)
    goto _jump835;
    fail_assertion("index too large");
    _jump835:;
    int64_t _153 = 0;
    _153 *= o.d0;
    _153 += _71.d0;
    _153 *= o.d1;
    _153 += _71.d1;
    _153 *= o.d2;
    _153 += y;
    bool _154 = o.data[_153];
    _152 = _154;
    goto _jump836;
    _jump829:;
    bool _155 = !_59;
    _a2_bool _156;
    if (!_155)
    goto _jump837;
    _a2_bool _157;
    // Computing bound for J
    _157.d0 = o.d0;
    if (o.d0 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing bound for K
    _157.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= o.d0;
    _158 *= o.d1;
    _158 *= sizeof(bool);
    _157.data = jpl_alloc(_158);
    int64_t _159 = 0; // K
    int64_t _160 = 0; // J
    _jump840:; // Begin body of loop
    bool _161 = false;
    int64_t _162 = 0;
    _162 *= _157.d0;
    _162 += _160;
    _162 *= _157.d1;
    _162 += _159;
    _157.data[_162] = _161;
    _159++;
    if (_159 < o.d1)
    goto _jump840;
    _159 = 0;
    _160++;
    if (_160 < o.d0)
    goto _jump840;
    // End body of loop
    _156 = _157;
    goto _jump841;
    _jump837:;
    bool _163 = false;
    bool _164 = !_163;
    _a2_bool _165;
    if (!_164)
    goto _jump842;
    _a2_bool _166;
    // Computing bound for J
    _166.d0 = b;
    if (b > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    // Computing bound for K
    _166.d1 = s;
    if (s > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= b;
    _167 *= s;
    _167 *= sizeof(bool);
    _166.data = jpl_alloc(_167);
    int64_t _168 = 0; // K
    int64_t _169 = 0; // J
    _jump845:; // Begin body of loop
    int64_t _170 = 0;
    _170 *= _166.d0;
    _170 += _169;
    _170 *= _166.d1;
    _170 += _168;
    _166.data[_170] = _59;
    _168++;
    if (_168 < s)
    goto _jump845;
    _168 = 0;
    _169++;
    if (_169 < b)
    goto _jump845;
    // End body of loop
    _165 = _166;
    goto _jump846;
    _jump842:;
    bool _171 = !_59;
    _a2_bool _172;
    if (!_171)
    goto _jump847;
    _a2_bool _173;
    // Computing bound for J
    _173.d0 = c;
    if (c > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing bound for K
    _173.d1 = f;
    if (f > 0) 
    goto _jump849;
    fail_assertion("non-positive loop bound");
    _jump849:;
    // Computing total size of heap memory to allocate
    int64_t _174 = 1;
    _174 *= c;
    _174 *= f;
    _174 *= sizeof(bool);
    _173.data = jpl_alloc(_174);
    int64_t _175 = 0; // K
    int64_t _176 = 0; // J
    _jump850:; // Begin body of loop
    bool _177 = false;
    int64_t _178 = 0;
    _178 *= _173.d0;
    _178 += _176;
    _178 *= _173.d1;
    _178 += _175;
    _173.data[_178] = _177;
    _175++;
    if (_175 < f)
    goto _jump850;
    _175 = 0;
    _176++;
    if (_176 < c)
    goto _jump850;
    // End body of loop
    _172 = _173;
    goto _jump851;
    _jump847:;
    _a2_bool _179;
    // Computing bound for J
    _179.d0 = s;
    if (s > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for K
    _179.d1 = q;
    if (q > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= s;
    _180 *= q;
    _180 *= sizeof(bool);
    _179.data = jpl_alloc(_180);
    int64_t _181 = 0; // K
    int64_t _182 = 0; // J
    _jump854:; // Begin body of loop
    int64_t _183 = 0;
    _183 *= _179.d0;
    _183 += _182;
    _183 *= _179.d1;
    _183 += _181;
    _179.data[_183] = _59;
    _181++;
    if (_181 < q)
    goto _jump854;
    _181 = 0;
    _182++;
    if (_182 < s)
    goto _jump854;
    // End body of loop
    _172 = _179;
    _jump851:;
    _165 = _172;
    _jump846:;
    _156 = _165;
    _jump841:;
    if (m >= 0)
    goto _jump855;
    fail_assertion("negative array index");
    _jump855:;
    if (m < _156.d0)
    goto _jump856;
    fail_assertion("index too large");
    _jump856:;
    if (j >= 0)
    goto _jump857;
    fail_assertion("negative array index");
    _jump857:;
    if (j < _156.d1)
    goto _jump858;
    fail_assertion("index too large");
    _jump858:;
    int64_t _184 = 0;
    _184 *= _156.d0;
    _184 += m;
    _184 *= _156.d1;
    _184 += j;
    bool _185 = _156.data[_184];
    _152 = _185;
    _jump836:;
    rgba _186;
    if (!_152)
    goto _jump859;
    _a2_rgba _187;
    // Computing bound for J
    _187.d0 = v;
    if (v > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    // Computing bound for K
    _187.d1 = o.d0;
    if (o.d0 > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    // Computing total size of heap memory to allocate
    int64_t _188 = 1;
    _188 *= v;
    _188 *= o.d0;
    _188 *= sizeof(rgba);
    _187.data = jpl_alloc(_188);
    int64_t _189 = 0; // K
    int64_t _190 = 0; // J
    _jump862:; // Begin body of loop
    int64_t _192 = 547;
    int64_t _193 = n();
    if (f >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (f < o.d0)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    if (_192 >= 0)
    goto _jump865;
    fail_assertion("negative array index");
    _jump865:;
    if (_192 < o.d1)
    goto _jump866;
    fail_assertion("index too large");
    _jump866:;
    if (_193 >= 0)
    goto _jump867;
    fail_assertion("negative array index");
    _jump867:;
    if (_193 < o.d2)
    goto _jump868;
    fail_assertion("index too large");
    _jump868:;
    int64_t _194 = 0;
    _194 *= o.d0;
    _194 += f;
    _194 *= o.d1;
    _194 += _192;
    _194 *= o.d2;
    _194 += _193;
    bool _195 = o.data[_194];
    bool _196 = !_195;
    bool _191 = _196;
    if (0 == _196)
    goto _jump869;
    bool _198 = false;
    bool _199 = !_198;
    bool _197 = _199;
    if (0 != _199)
    goto _jump870;
    bool _200 = !_59;
    _197 = _200;
    _jump870:;
    _191 = _197;
    _jump869:;
    rgba _201;
    if (!_191)
    goto _jump871;
    _a3_rgba _202;
    // Computing bound for L
    _202.d0 = m;
    if (m > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    // Computing bound for M
    int64_t _203;
    // Computing bound for L
    if (d > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    // Computing bound for M
    if (c > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing bound for N
    if (_189 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    _203 = 0;
    int64_t _204 = 0; // N
    int64_t _205 = 0; // M
    int64_t _206 = 0; // L
    _jump876:; // Begin body of loop
    _203 += _206;
    _204++;
    if (_204 < _189)
    goto _jump876;
    _204 = 0;
    _205++;
    if (_205 < c)
    goto _jump876;
    _205 = 0;
    _206++;
    if (_206 < d)
    goto _jump876;
    // End body of loop
    _202.d1 = _203;
    if (_203 > 0) 
    goto _jump877;
    fail_assertion("non-positive loop bound");
    _jump877:;
    // Computing bound for N
    _202.d2 = _189;
    if (_189 > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing total size of heap memory to allocate
    int64_t _207 = 1;
    _207 *= m;
    _207 *= _203;
    _207 *= _189;
    _207 *= sizeof(rgba);
    _202.data = jpl_alloc(_207);
    int64_t _208 = 0; // N
    int64_t _209 = 0; // M
    int64_t _210 = 0; // L
    _jump879:; // Begin body of loop
    rgba _211 = A();
    int64_t _212 = 0;
    _212 *= _202.d0;
    _212 += _210;
    _212 *= _202.d1;
    _212 += _209;
    _212 *= _202.d2;
    _212 += _208;
    _202.data[_212] = _211;
    _208++;
    if (_208 < _189)
    goto _jump879;
    _208 = 0;
    _209++;
    if (_209 < _203)
    goto _jump879;
    _209 = 0;
    _210++;
    if (_210 < m)
    goto _jump879;
    // End body of loop
    int64_t _213 = d - g;
    if (k >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (k < _202.d0)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    if (b >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (b < _202.d1)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    if (_213 >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (_213 < _202.d2)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    int64_t _214 = 0;
    _214 *= _202.d0;
    _214 += k;
    _214 *= _202.d1;
    _214 += b;
    _214 *= _202.d2;
    _214 += _213;
    rgba _215 = _202.data[_214];
    _201 = _215;
    goto _jump886;
    _jump871:;
    rgba _216;
    if (!_59)
    goto _jump887;
    double _217 = 43.0;
    bool _218 = false;
    double _219;
    if (!_218)
    goto _jump888;
    double _220 = 26.0;
    _219 = _220;
    goto _jump889;
    _jump888:;
    double _221 = 65.0;
    _219 = _221;
    _jump889:;
    double _222 = 0.0;
    double _223 = 42.0;
    double _224 = _222 / _223;
    rgba _225 = A();
    double _226 = _225.g;
    rgba _227 = { _217, _219, _224, _226 };
    _216 = _227;
    goto _jump890;
    _jump887:;
    rgba _228 = A();
    _216 = _228;
    _jump890:;
    _201 = _216;
    _jump886:;
    int64_t _229 = 0;
    _229 *= _187.d0;
    _229 += _190;
    _229 *= _187.d1;
    _229 += _189;
    _187.data[_229] = _201;
    _189++;
    if (_189 < o.d0)
    goto _jump862;
    _189 = 0;
    _190++;
    if (_190 < v)
    goto _jump862;
    // End body of loop
    if (q >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (q < _187.d0)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    if (i >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (i < _187.d1)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    int64_t _230 = 0;
    _230 *= _187.d0;
    _230 += q;
    _230 *= _187.d1;
    _230 += i;
    rgba _231 = _187.data[_230];
    _186 = _231;
    goto _jump895;
    _jump859:;
    _a3_bool _233;
    // Computing bound for J
    _233.d0 = v;
    if (v > 0) 
    goto _jump896;
    fail_assertion("non-positive loop bound");
    _jump896:;
    // Computing bound for K
    _233.d1 = s;
    if (s > 0) 
    goto _jump897;
    fail_assertion("non-positive loop bound");
    _jump897:;
    // Computing bound for L
    _233.d2 = _71.d1;
    if (_71.d1 > 0) 
    goto _jump898;
    fail_assertion("non-positive loop bound");
    _jump898:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= v;
    _234 *= s;
    _234 *= _71.d1;
    _234 *= sizeof(bool);
    _233.data = jpl_alloc(_234);
    int64_t _235 = 0; // L
    int64_t _236 = 0; // K
    int64_t _237 = 0; // J
    _jump899:; // Begin body of loop
    bool _238 = true;
    int64_t _239 = 0;
    _239 *= _233.d0;
    _239 += _237;
    _239 *= _233.d1;
    _239 += _236;
    _239 *= _233.d2;
    _239 += _235;
    _233.data[_239] = _238;
    _235++;
    if (_235 < _71.d1)
    goto _jump899;
    _235 = 0;
    _236++;
    if (_236 < s)
    goto _jump899;
    _236 = 0;
    _237++;
    if (_237 < v)
    goto _jump899;
    // End body of loop
    if (v >= 0)
    goto _jump900;
    fail_assertion("negative array index");
    _jump900:;
    if (v < _233.d0)
    goto _jump901;
    fail_assertion("index too large");
    _jump901:;
    if (m >= 0)
    goto _jump902;
    fail_assertion("negative array index");
    _jump902:;
    if (m < _233.d1)
    goto _jump903;
    fail_assertion("index too large");
    _jump903:;
    if (m >= 0)
    goto _jump904;
    fail_assertion("negative array index");
    _jump904:;
    if (m < _233.d2)
    goto _jump905;
    fail_assertion("index too large");
    _jump905:;
    int64_t _240 = 0;
    _240 *= _233.d0;
    _240 += v;
    _240 *= _233.d1;
    _240 += m;
    _240 *= _233.d2;
    _240 += m;
    bool _241 = _233.data[_240];
    bool _242 = !_241;
    _a2_bool _243;
    // Computing bound for J
    _243.d0 = d;
    if (d > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    // Computing bound for K
    _243.d1 = w;
    if (w > 0) 
    goto _jump907;
    fail_assertion("non-positive loop bound");
    _jump907:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= d;
    _244 *= w;
    _244 *= sizeof(bool);
    _243.data = jpl_alloc(_244);
    int64_t _245 = 0; // K
    int64_t _246 = 0; // J
    _jump908:; // Begin body of loop
    int64_t _247 = 0;
    _247 *= _243.d0;
    _247 += _246;
    _247 *= _243.d1;
    _247 += _245;
    _243.data[_247] = _59;
    _245++;
    if (_245 < w)
    goto _jump908;
    _245 = 0;
    _246++;
    if (_246 < d)
    goto _jump908;
    // End body of loop
    bool _248 = false;
    int64_t _249;
    if (!_248)
    goto _jump909;
    _249 = _71.d1;
    goto _jump910;
    _jump909:;
    _249 = _71.d0;
    _jump910:;
    if (_249 >= 0)
    goto _jump911;
    fail_assertion("negative array index");
    _jump911:;
    if (_249 < _243.d0)
    goto _jump912;
    fail_assertion("index too large");
    _jump912:;
    if (b >= 0)
    goto _jump913;
    fail_assertion("negative array index");
    _jump913:;
    if (b < _243.d1)
    goto _jump914;
    fail_assertion("index too large");
    _jump914:;
    int64_t _250 = 0;
    _250 *= _243.d0;
    _250 += _249;
    _250 *= _243.d1;
    _250 += b;
    bool _251 = _243.data[_250];
    bool _252 = _242 == _251;
    bool _232 = _252;
    if (0 != _252)
    goto _jump915;
    _a2__a1_bool _253;
    // Computing bound for J
    _253.d0 = u;
    if (u > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    // Computing bound for K
    _253.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= u;
    _254 *= o.d1;
    _254 *= sizeof(_a1_bool);
    _253.data = jpl_alloc(_254);
    int64_t _255 = 0; // K
    int64_t _256 = 0; // J
    _jump918:; // Begin body of loop
    int64_t _257 = 0;
    _257 *= _253.d0;
    _257 += _256;
    _257 *= _253.d1;
    _257 += _255;
    _253.data[_257] = l;
    _255++;
    if (_255 < o.d1)
    goto _jump918;
    _255 = 0;
    _256++;
    if (_256 < u)
    goto _jump918;
    // End body of loop
    int64_t _258 = n();
    if (_258 >= 0)
    goto _jump919;
    fail_assertion("negative array index");
    _jump919:;
    if (_258 < _71.d0)
    goto _jump920;
    fail_assertion("index too large");
    _jump920:;
    if (k >= 0)
    goto _jump921;
    fail_assertion("negative array index");
    _jump921:;
    if (k < _71.d1)
    goto _jump922;
    fail_assertion("index too large");
    _jump922:;
    int64_t _259 = 0;
    _259 *= _71.d0;
    _259 += _258;
    _259 *= _71.d1;
    _259 += k;
    int64_t _260 = _71.data[_259];
    if (o.d1 >= 0)
    goto _jump923;
    fail_assertion("negative array index");
    _jump923:;
    if (o.d1 < _253.d0)
    goto _jump924;
    fail_assertion("index too large");
    _jump924:;
    if (_260 >= 0)
    goto _jump925;
    fail_assertion("negative array index");
    _jump925:;
    if (_260 < _253.d1)
    goto _jump926;
    fail_assertion("index too large");
    _jump926:;
    int64_t _261 = 0;
    _261 *= _253.d0;
    _261 += o.d1;
    _261 *= _253.d1;
    _261 += _260;
    _a1_bool _262 = _253.data[_261];
    int64_t _263 = n();
    if (_263 >= 0)
    goto _jump927;
    fail_assertion("negative array index");
    _jump927:;
    if (_263 < _262.d0)
    goto _jump928;
    fail_assertion("index too large");
    _jump928:;
    int64_t _264 = 0;
    _264 *= _262.d0;
    _264 += _263;
    bool _265 = _262.data[_264];
    bool _266 = !_265;
    _232 = _266;
    _jump915:;
    rgba _267;
    if (!_232)
    goto _jump929;
    _a2_rgba _268;
    // Computing bound for J
    _268.d0 = o.d2;
    if (o.d2 > 0) 
    goto _jump930;
    fail_assertion("non-positive loop bound");
    _jump930:;
    // Computing bound for K
    _a2_int64_t _269;
    // Computing bound for J
    _269.d0 = d;
    if (d > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for K
    _269.d1 = f;
    if (f > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    // Computing total size of heap memory to allocate
    int64_t _270 = 1;
    _270 *= d;
    _270 *= f;
    _270 *= sizeof(int64_t);
    _269.data = jpl_alloc(_270);
    int64_t _271 = 0; // K
    int64_t _272 = 0; // J
    _jump933:; // Begin body of loop
    int64_t _273 = 0;
    _273 *= _269.d0;
    _273 += _272;
    _273 *= _269.d1;
    _273 += _271;
    _269.data[_273] = c;
    _271++;
    if (_271 < f)
    goto _jump933;
    _271 = 0;
    _272++;
    if (_272 < d)
    goto _jump933;
    // End body of loop
    if (k >= 0)
    goto _jump934;
    fail_assertion("negative array index");
    _jump934:;
    if (k < _269.d0)
    goto _jump935;
    fail_assertion("index too large");
    _jump935:;
    if (u >= 0)
    goto _jump936;
    fail_assertion("negative array index");
    _jump936:;
    if (u < _269.d1)
    goto _jump937;
    fail_assertion("index too large");
    _jump937:;
    int64_t _274 = 0;
    _274 *= _269.d0;
    _274 += k;
    _274 *= _269.d1;
    _274 += u;
    int64_t _275 = _269.data[_274];
    _268.d1 = _275;
    if (_275 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing total size of heap memory to allocate
    int64_t _276 = 1;
    _276 *= o.d2;
    _276 *= _275;
    _276 *= sizeof(rgba);
    _268.data = jpl_alloc(_276);
    int64_t _277 = 0; // K
    int64_t _278 = 0; // J
    _jump939:; // Begin body of loop
    _a1_double _279;
    // Computing bound for L
    _279.d0 = f;
    if (f > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    // Computing total size of heap memory to allocate
    int64_t _280 = 1;
    _280 *= f;
    _280 *= sizeof(double);
    _279.data = jpl_alloc(_280);
    int64_t _281 = 0; // L
    _jump941:; // Begin body of loop
    double _282 = 49.0;
    int64_t _283 = 0;
    _283 *= _279.d0;
    _283 += _281;
    _279.data[_283] = _282;
    _281++;
    if (_281 < f)
    goto _jump941;
    // End body of loop
    if (b >= 0)
    goto _jump942;
    fail_assertion("negative array index");
    _jump942:;
    if (b < _279.d0)
    goto _jump943;
    fail_assertion("index too large");
    _jump943:;
    int64_t _284 = 0;
    _284 *= _279.d0;
    _284 += b;
    double _285 = _279.data[_284];
    rgba _286 = A();
    double _287 = _286.a;
    bool _288 = true;
    double _289;
    if (!_288)
    goto _jump944;
    double _290 = 54.0;
    _289 = _290;
    goto _jump945;
    _jump944:;
    double _291 = 83.0;
    _289 = _291;
    _jump945:;
    double _292 = 53.0;
    rgba _293 = { _285, _287, _289, _292 };
    int64_t _294 = 0;
    _294 *= _268.d0;
    _294 += _278;
    _294 *= _268.d1;
    _294 += _277;
    _268.data[_294] = _293;
    _277++;
    if (_277 < _275)
    goto _jump939;
    _277 = 0;
    _278++;
    if (_278 < o.d2)
    goto _jump939;
    // End body of loop
    int64_t _295;
    // Computing bound for J
    if (d > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    // Computing bound for K
    if (s > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    _295 = 0;
    int64_t _296 = 0; // K
    int64_t _297 = 0; // J
    _jump948:; // Begin body of loop
    int64_t _298;
    // Computing bound for L
    if (i > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    _298 = 0;
    int64_t _299 = 0; // L
    _jump950:; // Begin body of loop
    _298 += c;
    _299++;
    if (_299 < i)
    goto _jump950;
    // End body of loop
    _295 += _298;
    _296++;
    if (_296 < s)
    goto _jump948;
    _296 = 0;
    _297++;
    if (_297 < d)
    goto _jump948;
    // End body of loop
    if (_295 >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (_295 < _268.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    if (y >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (y < _268.d1)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    int64_t _300 = 0;
    _300 *= _268.d0;
    _300 += _295;
    _300 *= _268.d1;
    _300 += y;
    rgba _301 = _268.data[_300];
    _267 = _301;
    goto _jump955;
    _jump929:;
    _a3_rgba _302;
    // Computing bound for J
    _302.d0 = d;
    if (d > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for K
    _302.d1 = s;
    if (s > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    // Computing bound for L
    _302.d2 = o.d2;
    if (o.d2 > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= d;
    _303 *= s;
    _303 *= o.d2;
    _303 *= sizeof(rgba);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // L
    int64_t _305 = 0; // K
    int64_t _306 = 0; // J
    _jump959:; // Begin body of loop
    rgba _307 = A();
    double _308 = _307.a;
    double _309 = 65.0;
    double _310 = -_309;
    bool _311 = _308 <= _310;
    rgba _312;
    if (!_311)
    goto _jump960;
    bool _313 = !_59;
    rgba _314;
    if (!_313)
    goto _jump961;
    bool _315 = false;
    rgba _316;
    if (!_315)
    goto _jump962;
    rgba _317 = A();
    _316 = _317;
    goto _jump963;
    _jump962:;
    rgba _318 = A();
    _316 = _318;
    _jump963:;
    _314 = _316;
    goto _jump964;
    _jump961:;
    rgba _319 = A();
    _314 = _319;
    _jump964:;
    _312 = _314;
    goto _jump965;
    _jump960:;
    _a2_rgba _320;
    // Computing bound for M
    _320.d0 = _305;
    if (_305 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing bound for N
    _320.d1 = i;
    if (i > 0) 
    goto _jump967;
    fail_assertion("non-positive loop bound");
    _jump967:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= _305;
    _321 *= i;
    _321 *= sizeof(rgba);
    _320.data = jpl_alloc(_321);
    int64_t _322 = 0; // N
    int64_t _323 = 0; // M
    _jump968:; // Begin body of loop
    rgba _324 = A();
    int64_t _325 = 0;
    _325 *= _320.d0;
    _325 += _323;
    _325 *= _320.d1;
    _325 += _322;
    _320.data[_325] = _324;
    _322++;
    if (_322 < i)
    goto _jump968;
    _322 = 0;
    _323++;
    if (_323 < _305)
    goto _jump968;
    // End body of loop
    int64_t _326 = n();
    if (_326 >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (_326 < _320.d0)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    if (s >= 0)
    goto _jump971;
    fail_assertion("negative array index");
    _jump971:;
    if (s < _320.d1)
    goto _jump972;
    fail_assertion("index too large");
    _jump972:;
    int64_t _327 = 0;
    _327 *= _320.d0;
    _327 += _326;
    _327 *= _320.d1;
    _327 += s;
    rgba _328 = _320.data[_327];
    _312 = _328;
    _jump965:;
    int64_t _329 = 0;
    _329 *= _302.d0;
    _329 += _306;
    _329 *= _302.d1;
    _329 += _305;
    _329 *= _302.d2;
    _329 += _304;
    _302.data[_329] = _312;
    _304++;
    if (_304 < o.d2)
    goto _jump959;
    _304 = 0;
    _305++;
    if (_305 < s)
    goto _jump959;
    _305 = 0;
    _306++;
    if (_306 < d)
    goto _jump959;
    // End body of loop
    if (_71.d1 >= 0)
    goto _jump973;
    fail_assertion("negative array index");
    _jump973:;
    if (_71.d1 < _302.d0)
    goto _jump974;
    fail_assertion("index too large");
    _jump974:;
    if (c >= 0)
    goto _jump975;
    fail_assertion("negative array index");
    _jump975:;
    if (c < _302.d1)
    goto _jump976;
    fail_assertion("index too large");
    _jump976:;
    if (v >= 0)
    goto _jump977;
    fail_assertion("negative array index");
    _jump977:;
    if (v < _302.d2)
    goto _jump978;
    fail_assertion("index too large");
    _jump978:;
    int64_t _330 = 0;
    _330 *= _302.d0;
    _330 += _71.d1;
    _330 *= _302.d1;
    _330 += c;
    _330 *= _302.d2;
    _330 += v;
    rgba _331 = _302.data[_330];
    _267 = _331;
    _jump955:;
    _186 = _267;
    _jump895:;
    return _186;
}

rgba B(_a2_rgba C) {
    _a3__a3__a2_rgba _0;
    // Computing bound for F
    _0.d0 = g;
    if (g > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing bound for G
    _0.d1 = k;
    if (k > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    // Computing bound for H
    _0.d2 = g;
    if (g > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= g;
    _1 *= k;
    _1 *= g;
    _1 *= sizeof(_a3__a2_rgba);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // H
    int64_t _3 = 0; // G
    int64_t _4 = 0; // F
    _jump982:; // Begin body of loop
    _a3__a2_rgba _5;
    // Computing bound for I
    _5.d0 = w;
    if (w > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for J
    _5.d1 = v;
    if (v > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing bound for K
    _5.d2 = u;
    if (u > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= w;
    _6 *= v;
    _6 *= u;
    _6 *= sizeof(_a2_rgba);
    _5.data = jpl_alloc(_6);
    int64_t _7 = 0; // K
    int64_t _8 = 0; // J
    int64_t _9 = 0; // I
    _jump986:; // Begin body of loop
    int64_t _10 = 0;
    _10 *= _5.d0;
    _10 += _9;
    _10 *= _5.d1;
    _10 += _8;
    _10 *= _5.d2;
    _10 += _7;
    _5.data[_10] = C;
    _7++;
    if (_7 < u)
    goto _jump986;
    _7 = 0;
    _8++;
    if (_8 < v)
    goto _jump986;
    _8 = 0;
    _9++;
    if (_9 < w)
    goto _jump986;
    // End body of loop
    int64_t _11 = 0;
    _11 *= _0.d0;
    _11 += _4;
    _11 *= _0.d1;
    _11 += _3;
    _11 *= _0.d2;
    _11 += _2;
    _0.data[_11] = _5;
    _2++;
    if (_2 < g)
    goto _jump982;
    _2 = 0;
    _3++;
    if (_3 < k)
    goto _jump982;
    _3 = 0;
    _4++;
    if (_4 < g)
    goto _jump982;
    // End body of loop
    if (d >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (d < _0.d0)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    if (k >= 0)
    goto _jump989;
    fail_assertion("negative array index");
    _jump989:;
    if (k < _0.d1)
    goto _jump990;
    fail_assertion("index too large");
    _jump990:;
    if (j >= 0)
    goto _jump991;
    fail_assertion("negative array index");
    _jump991:;
    if (j < _0.d2)
    goto _jump992;
    fail_assertion("index too large");
    _jump992:;
    int64_t _12 = 0;
    _12 *= _0.d0;
    _12 += d;
    _12 *= _0.d1;
    _12 += k;
    _12 *= _0.d2;
    _12 += j;
    _a3__a2_rgba _13 = _0.data[_12];
    bool _14 = c != d;
    int64_t _15;
    if (!_14)
    goto _jump993;
    int64_t _16 = m + y;
    _15 = _16;
    goto _jump994;
    _jump993:;
    _15 = y;
    _jump994:;
    int64_t _17 = -_15;
    double _18 = 25.0;
    double _19 = -_18;
    double _20;
    // Computing bound for F
    if (j > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for G
    if (d > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    _20 = 0;
    int64_t _21 = 0; // G
    int64_t _22 = 0; // F
    _jump997:; // Begin body of loop
    double _23 = 81.0;
    _20 += _23;
    _21++;
    if (_21 < d)
    goto _jump997;
    _21 = 0;
    _22++;
    if (_22 < j)
    goto _jump997;
    // End body of loop
    bool _24 = _19 != _20;
    bool _25;
    if (!_24)
    goto _jump998;
    bool _26 = m < q;
    bool _27;
    if (!_26)
    goto _jump999;
    if (k >= 0)
    goto _jump1000;
    fail_assertion("negative array index");
    _jump1000:;
    if (k < l.d0)
    goto _jump1001;
    fail_assertion("index too large");
    _jump1001:;
    int64_t _28 = 0;
    _28 *= l.d0;
    _28 += k;
    bool _29 = l.data[_28];
    _27 = _29;
    goto _jump1002;
    _jump999:;
    bool _30 = g <= y;
    _27 = _30;
    _jump1002:;
    _25 = _27;
    goto _jump1003;
    _jump998:;
    bool _31 = y != v;
    _25 = _31;
    _jump1003:;
    _a2_int64_t _32;
    if (!_25)
    goto _jump1004;
    bool _33 = true;
    _a2_int64_t _34;
    if (!_33)
    goto _jump1005;
    bool _35 = v > u;
    _a2_int64_t _36;
    if (!_35)
    goto _jump1006;
    _a2_int64_t _37;
    // Computing bound for F
    int64_t _38 = 678;
    _37.d0 = _38;
    if (_38 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for G
    _37.d1 = j;
    if (j > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing total size of heap memory to allocate
    int64_t _39 = 1;
    _39 *= _38;
    _39 *= j;
    _39 *= sizeof(int64_t);
    _37.data = jpl_alloc(_39);
    int64_t _40 = 0; // G
    int64_t _41 = 0; // F
    _jump1009:; // Begin body of loop
    int64_t _42 = 0;
    _42 *= _37.d0;
    _42 += _41;
    _42 *= _37.d1;
    _42 += _40;
    _37.data[_42] = y;
    _40++;
    if (_40 < j)
    goto _jump1009;
    _40 = 0;
    _41++;
    if (_41 < _38)
    goto _jump1009;
    // End body of loop
    _36 = _37;
    goto _jump1010;
    _jump1006:;
    _a2_int64_t _43;
    // Computing bound for F
    int64_t _44 = 485;
    _43.d0 = _44;
    if (_44 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    // Computing bound for G
    _43.d1 = c;
    if (c > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    // Computing total size of heap memory to allocate
    int64_t _45 = 1;
    _45 *= _44;
    _45 *= c;
    _45 *= sizeof(int64_t);
    _43.data = jpl_alloc(_45);
    int64_t _46 = 0; // G
    int64_t _47 = 0; // F
    _jump1013:; // Begin body of loop
    int64_t _48 = 0;
    _48 *= _43.d0;
    _48 += _47;
    _48 *= _43.d1;
    _48 += _46;
    _43.data[_48] = g;
    _46++;
    if (_46 < c)
    goto _jump1013;
    _46 = 0;
    _47++;
    if (_47 < _44)
    goto _jump1013;
    // End body of loop
    _36 = _43;
    _jump1010:;
    _34 = _36;
    goto _jump1014;
    _jump1005:;
    _a2_int64_t _49;
    // Computing bound for F
    int64_t _50;
    // Computing bound for F
    if (q > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing bound for G
    if (C.d1 > 0) 
    goto _jump1016;
    fail_assertion("non-positive loop bound");
    _jump1016:;
    _50 = 0;
    int64_t _51 = 0; // G
    int64_t _52 = 0; // F
    _jump1017:; // Begin body of loop
    _50 += d;
    _51++;
    if (_51 < C.d1)
    goto _jump1017;
    _51 = 0;
    _52++;
    if (_52 < q)
    goto _jump1017;
    // End body of loop
    _49.d0 = _50;
    if (_50 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    // Computing bound for G
    _49.d1 = i;
    if (i > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= _50;
    _53 *= i;
    _53 *= sizeof(int64_t);
    _49.data = jpl_alloc(_53);
    int64_t _54 = 0; // G
    int64_t _55 = 0; // F
    _jump1020:; // Begin body of loop
    int64_t _56 = c - q;
    int64_t _57 = 0;
    _57 *= _49.d0;
    _57 += _55;
    _57 *= _49.d1;
    _57 += _54;
    _49.data[_57] = _56;
    _54++;
    if (_54 < i)
    goto _jump1020;
    _54 = 0;
    _55++;
    if (_55 < _50)
    goto _jump1020;
    // End body of loop
    _34 = _49;
    _jump1014:;
    _32 = _34;
    goto _jump1021;
    _jump1004:;
    _a2_int64_t _58;
    // Computing bound for F
    _58.d0 = k;
    if (k > 0) 
    goto _jump1022;
    fail_assertion("non-positive loop bound");
    _jump1022:;
    // Computing bound for G
    int64_t _59 = m + j;
    _58.d1 = _59;
    if (_59 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= k;
    _60 *= _59;
    _60 *= sizeof(int64_t);
    _58.data = jpl_alloc(_60);
    int64_t _61 = 0; // G
    int64_t _62 = 0; // F
    _jump1024:; // Begin body of loop
    int64_t _63 = 0;
    _63 *= _58.d0;
    _63 += _62;
    _63 *= _58.d1;
    _63 += _61;
    _58.data[_63] = f;
    _61++;
    if (_61 < _59)
    goto _jump1024;
    _61 = 0;
    _62++;
    if (_62 < k)
    goto _jump1024;
    // End body of loop
    _32 = _58;
    _jump1021:;
    bool _64 = true;
    int64_t _65;
    if (!_64)
    goto _jump1025;
    _65 = f;
    goto _jump1026;
    _jump1025:;
    _65 = m;
    _jump1026:;
    if (w >= 0)
    goto _jump1027;
    fail_assertion("negative array index");
    _jump1027:;
    if (w < _32.d0)
    goto _jump1028;
    fail_assertion("index too large");
    _jump1028:;
    if (_65 >= 0)
    goto _jump1029;
    fail_assertion("negative array index");
    _jump1029:;
    if (_65 < _32.d1)
    goto _jump1030;
    fail_assertion("index too large");
    _jump1030:;
    int64_t _66 = 0;
    _66 *= _32.d0;
    _66 += w;
    _66 *= _32.d1;
    _66 += _65;
    int64_t _67 = _32.data[_66];
    if (_17 >= 0)
    goto _jump1031;
    fail_assertion("negative array index");
    _jump1031:;
    if (_17 < _13.d0)
    goto _jump1032;
    fail_assertion("index too large");
    _jump1032:;
    if (_67 >= 0)
    goto _jump1033;
    fail_assertion("negative array index");
    _jump1033:;
    if (_67 < _13.d1)
    goto _jump1034;
    fail_assertion("index too large");
    _jump1034:;
    if (w >= 0)
    goto _jump1035;
    fail_assertion("negative array index");
    _jump1035:;
    if (w < _13.d2)
    goto _jump1036;
    fail_assertion("index too large");
    _jump1036:;
    int64_t _68 = 0;
    _68 *= _13.d0;
    _68 += _17;
    _68 *= _13.d1;
    _68 += _67;
    _68 *= _13.d2;
    _68 += w;
    _a2_rgba _69 = _13.data[_68];
    rgba _70 = B(_69);
    return _70;
    bool _72 = true;
    bool _71 = _72;
    if (0 == _72)
    goto _jump1037;
    int64_t _74;
    // Computing bound for F
    if (c > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    _74 = 0;
    int64_t _75 = 0; // F
    _jump1039:; // Begin body of loop
    _74 += d;
    _75++;
    if (_75 < c)
    goto _jump1039;
    // End body of loop
    int64_t _76 = C.d0 % _74;
    if (j >= 0)
    goto _jump1040;
    fail_assertion("negative array index");
    _jump1040:;
    if (j < t.d0)
    goto _jump1041;
    fail_assertion("index too large");
    _jump1041:;
    if (c >= 0)
    goto _jump1042;
    fail_assertion("negative array index");
    _jump1042:;
    if (c < t.d1)
    goto _jump1043;
    fail_assertion("index too large");
    _jump1043:;
    if (m >= 0)
    goto _jump1044;
    fail_assertion("negative array index");
    _jump1044:;
    if (m < t.d2)
    goto _jump1045;
    fail_assertion("index too large");
    _jump1045:;
    int64_t _77 = 0;
    _77 *= t.d0;
    _77 += j;
    _77 *= t.d1;
    _77 += c;
    _77 *= t.d2;
    _77 += m;
    int64_t _78 = t.data[_77];
    bool _79 = _76 == _78;
    bool _73 = _79;
    if (0 == _79)
    goto _jump1046;
    int64_t _80 = 325;
    int64_t _81 = n();
    if (_80 >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (_80 < h.d0)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    if (_81 >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (_81 < h.d1)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    if (k >= 0)
    goto _jump1051;
    fail_assertion("negative array index");
    _jump1051:;
    if (k < h.d2)
    goto _jump1052;
    fail_assertion("index too large");
    _jump1052:;
    int64_t _82 = 0;
    _82 *= h.d0;
    _82 += _80;
    _82 *= h.d1;
    _82 += _81;
    _82 *= h.d2;
    _82 += k;
    bool _83 = h.data[_82];
    bool _84 = true;
    bool _85 = _83 == _84;
    bool _86;
    if (!_85)
    goto _jump1053;
    bool _87 = c < C.d1;
    bool _88 = !_87;
    _86 = _88;
    goto _jump1054;
    _jump1053:;
    bool _89 = false;
    bool _90 = !_89;
    _86 = _90;
    _jump1054:;
    r _91;
    if (!_86)
    goto _jump1055;
    _a2_bool _92;
    // Computing bound for F
    _92.d0 = C.d0;
    if (C.d0 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    // Computing bound for G
    _92.d1 = j;
    if (j > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= C.d0;
    _93 *= j;
    _93 *= sizeof(bool);
    _92.data = jpl_alloc(_93);
    int64_t _94 = 0; // G
    int64_t _95 = 0; // F
    _jump1058:; // Begin body of loop
    bool _96 = false;
    int64_t _97 = 0;
    _97 *= _92.d0;
    _97 += _95;
    _97 *= _92.d1;
    _97 += _94;
    _92.data[_97] = _96;
    _94++;
    if (_94 < j)
    goto _jump1058;
    _94 = 0;
    _95++;
    if (_95 < C.d0)
    goto _jump1058;
    // End body of loop
    if (i >= 0)
    goto _jump1059;
    fail_assertion("negative array index");
    _jump1059:;
    if (i < _92.d0)
    goto _jump1060;
    fail_assertion("index too large");
    _jump1060:;
    if (u >= 0)
    goto _jump1061;
    fail_assertion("negative array index");
    _jump1061:;
    if (u < _92.d1)
    goto _jump1062;
    fail_assertion("index too large");
    _jump1062:;
    int64_t _98 = 0;
    _98 *= _92.d0;
    _98 += i;
    _98 *= _92.d1;
    _98 += u;
    bool _99 = _92.data[_98];
    _a1__a2_double _100;
    // Computing bound for F
    _100.d0 = y;
    if (y > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= y;
    _101 *= sizeof(_a2_double);
    _100.data = jpl_alloc(_101);
    int64_t _102 = 0; // F
    _jump1064:; // Begin body of loop
    _a2_double _103;
    // Computing bound for G
    _103.d0 = v;
    if (v > 0) 
    goto _jump1065;
    fail_assertion("non-positive loop bound");
    _jump1065:;
    // Computing bound for H
    _103.d1 = f;
    if (f > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= v;
    _104 *= f;
    _104 *= sizeof(double);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // H
    int64_t _106 = 0; // G
    _jump1067:; // Begin body of loop
    double _107 = 97.0;
    int64_t _108 = 0;
    _108 *= _103.d0;
    _108 += _106;
    _108 *= _103.d1;
    _108 += _105;
    _103.data[_108] = _107;
    _105++;
    if (_105 < f)
    goto _jump1067;
    _105 = 0;
    _106++;
    if (_106 < v)
    goto _jump1067;
    // End body of loop
    int64_t _109 = 0;
    _109 *= _100.d0;
    _109 += _102;
    _100.data[_109] = _103;
    _102++;
    if (_102 < y)
    goto _jump1064;
    // End body of loop
    r _110 = { _99, _100 };
    _91 = _110;
    goto _jump1068;
    _jump1055:;
    bool _111 = false;
    bool _112 = !_111;
    _a1__a2_double _113;
    // Computing bound for F
    _113.d0 = c;
    if (c > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= c;
    _114 *= sizeof(_a2_double);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // F
    _jump1070:; // Begin body of loop
    _a2_double _116;
    // Computing bound for G
    _116.d0 = c;
    if (c > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing bound for H
    _116.d1 = y;
    if (y > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= c;
    _117 *= y;
    _117 *= sizeof(double);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // H
    int64_t _119 = 0; // G
    _jump1073:; // Begin body of loop
    double _120 = 6.0;
    int64_t _121 = 0;
    _121 *= _116.d0;
    _121 += _119;
    _121 *= _116.d1;
    _121 += _118;
    _116.data[_121] = _120;
    _118++;
    if (_118 < y)
    goto _jump1073;
    _118 = 0;
    _119++;
    if (_119 < c)
    goto _jump1073;
    // End body of loop
    int64_t _122 = 0;
    _122 *= _113.d0;
    _122 += _115;
    _113.data[_122] = _116;
    _115++;
    if (_115 < c)
    goto _jump1070;
    // End body of loop
    r _123 = { _112, _113 };
    _91 = _123;
    _jump1068:;
    bool _124 = _91.a;
    _73 = _124;
    _jump1046:;
    _71 = _73;
    _jump1037:;
    if (0 != _71)
    goto _jump1074;
    fail_assertion("F");
    _jump1074:;
    double _125;
    // Computing bound for F
    int64_t _126 = i + q;
    int64_t _127 = _126 * k;
    int64_t _128 = v / _127;
    if (_128 > 0) 
    goto _jump1075;
    fail_assertion("non-positive loop bound");
    _jump1075:;
    // Computing bound for G
    int64_t _129 = 684;
    if (_129 > 0) 
    goto _jump1076;
    fail_assertion("non-positive loop bound");
    _jump1076:;
    _125 = 0;
    int64_t _130 = 0; // G
    int64_t _131 = 0; // F
    _jump1077:; // Begin body of loop
    _a2_double _132;
    // Computing bound for H
    _132.d0 = u;
    if (u > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    // Computing bound for I
    _132.d1 = f;
    if (f > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= u;
    _133 *= f;
    _133 *= sizeof(double);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // I
    int64_t _135 = 0; // H
    _jump1080:; // Begin body of loop
    double _136 = 41.0;
    int64_t _137 = 0;
    _137 *= _132.d0;
    _137 += _135;
    _137 *= _132.d1;
    _137 += _134;
    _132.data[_137] = _136;
    _134++;
    if (_134 < f)
    goto _jump1080;
    _134 = 0;
    _135++;
    if (_135 < u)
    goto _jump1080;
    // End body of loop
    int64_t _138 = -C.d0;
    int64_t _139 = 273;
    if (_138 >= 0)
    goto _jump1081;
    fail_assertion("negative array index");
    _jump1081:;
    if (_138 < _132.d0)
    goto _jump1082;
    fail_assertion("index too large");
    _jump1082:;
    if (_139 >= 0)
    goto _jump1083;
    fail_assertion("negative array index");
    _jump1083:;
    if (_139 < _132.d1)
    goto _jump1084;
    fail_assertion("index too large");
    _jump1084:;
    int64_t _140 = 0;
    _140 *= _132.d0;
    _140 += _138;
    _140 *= _132.d1;
    _140 += _139;
    double _141 = _132.data[_140];
    double _142 = 68.0;
    double _143 = _141 / _142;
    _125 += _143;
    _130++;
    if (_130 < _129)
    goto _jump1077;
    _130 = 0;
    _131++;
    if (_131 < _128)
    goto _jump1077;
    // End body of loop
    double _144 = -_125;
    bool _147 = false;
    bool _148 = !_147;
    bool _146 = _148;
    if (0 != _148)
    goto _jump1085;
    bool _149 = false;
    bool _150 = !_149;
    _146 = _150;
    _jump1085:;
    bool _145 = _146;
    if (0 != _146)
    goto _jump1086;
    int64_t _151;
    // Computing bound for F
    if (v > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing bound for G
    if (w > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    _151 = 0;
    int64_t _152 = 0; // G
    int64_t _153 = 0; // F
    _jump1089:; // Begin body of loop
    _151 += k;
    _152++;
    if (_152 < w)
    goto _jump1089;
    _152 = 0;
    _153++;
    if (_153 < v)
    goto _jump1089;
    // End body of loop
    bool _154 = _151 >= d;
    _145 = _154;
    _jump1086:;
    rgba _155;
    if (!_145)
    goto _jump1090;
    rgba _156 = A();
    _155 = _156;
    goto _jump1091;
    _jump1090:;
    _a2_rgba _157;
    // Computing bound for F
    _157.d0 = f;
    if (f > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing bound for G
    int64_t _158 = 137;
    _157.d1 = _158;
    if (_158 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= f;
    _159 *= _158;
    _159 *= sizeof(rgba);
    _157.data = jpl_alloc(_159);
    int64_t _160 = 0; // G
    int64_t _161 = 0; // F
    _jump1094:; // Begin body of loop
    rgba _162 = B(C);
    int64_t _163 = 0;
    _163 *= _157.d0;
    _163 += _161;
    _163 *= _157.d1;
    _163 += _160;
    _157.data[_163] = _162;
    _160++;
    if (_160 < _158)
    goto _jump1094;
    _160 = 0;
    _161++;
    if (_161 < f)
    goto _jump1094;
    // End body of loop
    rgba _164 = B(_157);
    _155 = _164;
    _jump1091:;
    double _165 = _155.g;
    bool _166 = _144 == _165;
    _a1_bool _168;
    // Computing bound for F
    _168.d0 = d;
    if (d > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= d;
    _169 *= sizeof(bool);
    _168.data = jpl_alloc(_169);
    int64_t _170 = 0; // F
    _jump1096:; // Begin body of loop
    int64_t _171 = n();
    if (_171 >= 0)
    goto _jump1097;
    fail_assertion("negative array index");
    _jump1097:;
    if (_171 < l.d0)
    goto _jump1098;
    fail_assertion("index too large");
    _jump1098:;
    int64_t _172 = 0;
    _172 *= l.d0;
    _172 += _171;
    bool _173 = l.data[_172];
    int64_t _174 = 0;
    _174 *= _168.d0;
    _174 += _170;
    _168.data[_174] = _173;
    _170++;
    if (_170 < d)
    goto _jump1096;
    // End body of loop
    if (c >= 0)
    goto _jump1099;
    fail_assertion("negative array index");
    _jump1099:;
    if (c < _168.d0)
    goto _jump1100;
    fail_assertion("index too large");
    _jump1100:;
    int64_t _175 = 0;
    _175 *= _168.d0;
    _175 += c;
    bool _176 = _168.data[_175];
    bool _167 = _176;
    if (0 == _176)
    goto _jump1101;
    int64_t _178;
    // Computing bound for F
    int64_t _179 = -C.d1;
    if (_179 > 0) 
    goto _jump1102;
    fail_assertion("non-positive loop bound");
    _jump1102:;
    _178 = 0;
    int64_t _180 = 0; // F
    _jump1103:; // Begin body of loop
    _178 += w;
    _180++;
    if (_180 < _179)
    goto _jump1103;
    // End body of loop
    bool _181 = C.d1 > _178;
    bool _177 = _181;
    if (0 != _181)
    goto _jump1104;
    _a2_bool _182;
    // Computing bound for F
    _182.d0 = w;
    if (w > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing bound for G
    _182.d1 = c;
    if (c > 0) 
    goto _jump1106;
    fail_assertion("non-positive loop bound");
    _jump1106:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= w;
    _183 *= c;
    _183 *= sizeof(bool);
    _182.data = jpl_alloc(_183);
    int64_t _184 = 0; // G
    int64_t _185 = 0; // F
    _jump1107:; // Begin body of loop
    int64_t _186 = 848;
    if (_186 >= 0)
    goto _jump1108;
    fail_assertion("negative array index");
    _jump1108:;
    if (_186 < o.d0)
    goto _jump1109;
    fail_assertion("index too large");
    _jump1109:;
    if (_184 >= 0)
    goto _jump1110;
    fail_assertion("negative array index");
    _jump1110:;
    if (_184 < o.d1)
    goto _jump1111;
    fail_assertion("index too large");
    _jump1111:;
    if (u >= 0)
    goto _jump1112;
    fail_assertion("negative array index");
    _jump1112:;
    if (u < o.d2)
    goto _jump1113;
    fail_assertion("index too large");
    _jump1113:;
    int64_t _187 = 0;
    _187 *= o.d0;
    _187 += _186;
    _187 *= o.d1;
    _187 += _184;
    _187 *= o.d2;
    _187 += u;
    bool _188 = o.data[_187];
    int64_t _189 = 0;
    _189 *= _182.d0;
    _189 += _185;
    _189 *= _182.d1;
    _189 += _184;
    _182.data[_189] = _188;
    _184++;
    if (_184 < c)
    goto _jump1107;
    _184 = 0;
    _185++;
    if (_185 < w)
    goto _jump1107;
    // End body of loop
    if (u >= 0)
    goto _jump1114;
    fail_assertion("negative array index");
    _jump1114:;
    if (u < _182.d0)
    goto _jump1115;
    fail_assertion("index too large");
    _jump1115:;
    if (j >= 0)
    goto _jump1116;
    fail_assertion("negative array index");
    _jump1116:;
    if (j < _182.d1)
    goto _jump1117;
    fail_assertion("index too large");
    _jump1117:;
    int64_t _190 = 0;
    _190 *= _182.d0;
    _190 += u;
    _190 *= _182.d1;
    _190 += j;
    bool _191 = _182.data[_190];
    _177 = _191;
    _jump1104:;
    _167 = _177;
    _jump1101:;
    _a1_bool _192;
    _192.d0 = 2;
    _192.data = jpl_alloc(sizeof(bool) * 2);
    _192.data[0] = _166;
    _192.data[1] = _167;
    _a3_double _193;
    // Computing bound for G
    _193.d0 = i;
    if (i > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    // Computing bound for H
    _193.d1 = b;
    if (b > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing bound for I
    _193.d2 = f;
    if (f > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing total size of heap memory to allocate
    int64_t _194 = 1;
    _194 *= i;
    _194 *= b;
    _194 *= f;
    _194 *= sizeof(double);
    _193.data = jpl_alloc(_194);
    int64_t _195 = 0; // I
    int64_t _196 = 0; // H
    int64_t _197 = 0; // G
    _jump1121:; // Begin body of loop
    if (C.d1 >= 0)
    goto _jump1122;
    fail_assertion("negative array index");
    _jump1122:;
    if (C.d1 < o.d0)
    goto _jump1123;
    fail_assertion("index too large");
    _jump1123:;
    if (y >= 0)
    goto _jump1124;
    fail_assertion("negative array index");
    _jump1124:;
    if (y < o.d1)
    goto _jump1125;
    fail_assertion("index too large");
    _jump1125:;
    if (s >= 0)
    goto _jump1126;
    fail_assertion("negative array index");
    _jump1126:;
    if (s < o.d2)
    goto _jump1127;
    fail_assertion("index too large");
    _jump1127:;
    int64_t _198 = 0;
    _198 *= o.d0;
    _198 += C.d1;
    _198 *= o.d1;
    _198 += y;
    _198 *= o.d2;
    _198 += s;
    bool _199 = o.data[_198];
    double _200;
    if (!_199)
    goto _jump1128;
    double _201 = 13.0;
    double _202 = -_201;
    _200 = _202;
    goto _jump1129;
    _jump1128:;
    _a1_double _203;
    // Computing bound for J
    _203.d0 = q;
    if (q > 0) 
    goto _jump1130;
    fail_assertion("non-positive loop bound");
    _jump1130:;
    // Computing total size of heap memory to allocate
    int64_t _204 = 1;
    _204 *= q;
    _204 *= sizeof(double);
    _203.data = jpl_alloc(_204);
    int64_t _205 = 0; // J
    _jump1131:; // Begin body of loop
    double _206 = 42.0;
    int64_t _207 = 0;
    _207 *= _203.d0;
    _207 += _205;
    _203.data[_207] = _206;
    _205++;
    if (_205 < q)
    goto _jump1131;
    // End body of loop
    if (s >= 0)
    goto _jump1132;
    fail_assertion("negative array index");
    _jump1132:;
    if (s < _203.d0)
    goto _jump1133;
    fail_assertion("index too large");
    _jump1133:;
    int64_t _208 = 0;
    _208 *= _203.d0;
    _208 += s;
    double _209 = _203.data[_208];
    _200 = _209;
    _jump1129:;
    double _210 = -_200;
    int64_t _211 = 0;
    _211 *= _193.d0;
    _211 += _197;
    _211 *= _193.d1;
    _211 += _196;
    _211 *= _193.d2;
    _211 += _195;
    _193.data[_211] = _210;
    _195++;
    if (_195 < f)
    goto _jump1121;
    _195 = 0;
    _196++;
    if (_196 < b)
    goto _jump1121;
    _196 = 0;
    _197++;
    if (_197 < i)
    goto _jump1121;
    // End body of loop
    int64_t _212;
    // Computing bound for G
    int64_t _213 = 499;
    if (_213 > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    _212 = 0;
    int64_t _214 = 0; // G
    _jump1135:; // Begin body of loop
    _212 += _214;
    _214++;
    if (_214 < _213)
    goto _jump1135;
    // End body of loop
    if (c >= 0)
    goto _jump1136;
    fail_assertion("negative array index");
    _jump1136:;
    if (c < _193.d0)
    goto _jump1137;
    fail_assertion("index too large");
    _jump1137:;
    if (_212 >= 0)
    goto _jump1138;
    fail_assertion("negative array index");
    _jump1138:;
    if (_212 < _193.d1)
    goto _jump1139;
    fail_assertion("index too large");
    _jump1139:;
    if (s >= 0)
    goto _jump1140;
    fail_assertion("negative array index");
    _jump1140:;
    if (s < _193.d2)
    goto _jump1141;
    fail_assertion("index too large");
    _jump1141:;
    int64_t _215 = 0;
    _215 *= _193.d0;
    _215 += c;
    _215 *= _193.d1;
    _215 += _212;
    _215 *= _193.d2;
    _215 += s;
    double _216 = _193.data[_215];
    double _217 = 79.0;
    bool _219 = d <= b;
    bool _218 = _219;
    if (0 == _219)
    goto _jump1142;
    bool _220 = C.d1 == C.d0;
    _218 = _220;
    _jump1142:;
    bool _221 = !_218;
    bool _222;
    if (!_221)
    goto _jump1143;
    int64_t _223 = n();
    if (f >= 0)
    goto _jump1144;
    fail_assertion("negative array index");
    _jump1144:;
    if (f < o.d0)
    goto _jump1145;
    fail_assertion("index too large");
    _jump1145:;
    if (b >= 0)
    goto _jump1146;
    fail_assertion("negative array index");
    _jump1146:;
    if (b < o.d1)
    goto _jump1147;
    fail_assertion("index too large");
    _jump1147:;
    if (_223 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (_223 < o.d2)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    int64_t _224 = 0;
    _224 *= o.d0;
    _224 += f;
    _224 *= o.d1;
    _224 += b;
    _224 *= o.d2;
    _224 += _223;
    bool _225 = o.data[_224];
    bool _226 = !_225;
    _222 = _226;
    goto _jump1150;
    _jump1143:;
    bool _227 = false;
    _222 = _227;
    _jump1150:;
    double _228;
    if (!_222)
    goto _jump1151;
    _a3_double _229;
    // Computing bound for G
    _229.d0 = d;
    if (d > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    // Computing bound for H
    _229.d1 = i;
    if (i > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    // Computing bound for I
    int64_t _230 = n();
    _229.d2 = _230;
    if (_230 > 0) 
    goto _jump1154;
    fail_assertion("non-positive loop bound");
    _jump1154:;
    // Computing total size of heap memory to allocate
    int64_t _231 = 1;
    _231 *= d;
    _231 *= i;
    _231 *= _230;
    _231 *= sizeof(double);
    _229.data = jpl_alloc(_231);
    int64_t _232 = 0; // I
    int64_t _233 = 0; // H
    int64_t _234 = 0; // G
    _jump1155:; // Begin body of loop
    rgba _235 = A();
    double _236 = _235.g;
    int64_t _237 = 0;
    _237 *= _229.d0;
    _237 += _234;
    _237 *= _229.d1;
    _237 += _233;
    _237 *= _229.d2;
    _237 += _232;
    _229.data[_237] = _236;
    _232++;
    if (_232 < _230)
    goto _jump1155;
    _232 = 0;
    _233++;
    if (_233 < i)
    goto _jump1155;
    _233 = 0;
    _234++;
    if (_234 < d)
    goto _jump1155;
    // End body of loop
    int64_t _238;
    // Computing bound for G
    if (j > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    // Computing bound for H
    if (b > 0) 
    goto _jump1157;
    fail_assertion("non-positive loop bound");
    _jump1157:;
    // Computing bound for I
    if (d > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    _238 = 0;
    int64_t _239 = 0; // I
    int64_t _240 = 0; // H
    int64_t _241 = 0; // G
    _jump1159:; // Begin body of loop
    _a1_int64_t _242;
    // Computing bound for J
    _242.d0 = m;
    if (m > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= m;
    _243 *= sizeof(int64_t);
    _242.data = jpl_alloc(_243);
    int64_t _244 = 0; // J
    _jump1161:; // Begin body of loop
    int64_t _245 = 0;
    _245 *= _242.d0;
    _245 += _244;
    _242.data[_245] = j;
    _244++;
    if (_244 < m)
    goto _jump1161;
    // End body of loop
    if (y >= 0)
    goto _jump1162;
    fail_assertion("negative array index");
    _jump1162:;
    if (y < _242.d0)
    goto _jump1163;
    fail_assertion("index too large");
    _jump1163:;
    int64_t _246 = 0;
    _246 *= _242.d0;
    _246 += y;
    int64_t _247 = _242.data[_246];
    _238 += _247;
    _239++;
    if (_239 < d)
    goto _jump1159;
    _239 = 0;
    _240++;
    if (_240 < b)
    goto _jump1159;
    _240 = 0;
    _241++;
    if (_241 < j)
    goto _jump1159;
    // End body of loop
    int64_t _248 = -v;
    int64_t _249 = n();
    if (_238 >= 0)
    goto _jump1164;
    fail_assertion("negative array index");
    _jump1164:;
    if (_238 < _229.d0)
    goto _jump1165;
    fail_assertion("index too large");
    _jump1165:;
    if (_248 >= 0)
    goto _jump1166;
    fail_assertion("negative array index");
    _jump1166:;
    if (_248 < _229.d1)
    goto _jump1167;
    fail_assertion("index too large");
    _jump1167:;
    if (_249 >= 0)
    goto _jump1168;
    fail_assertion("negative array index");
    _jump1168:;
    if (_249 < _229.d2)
    goto _jump1169;
    fail_assertion("index too large");
    _jump1169:;
    int64_t _250 = 0;
    _250 *= _229.d0;
    _250 += _238;
    _250 *= _229.d1;
    _250 += _248;
    _250 *= _229.d2;
    _250 += _249;
    double _251 = _229.data[_250];
    _228 = _251;
    goto _jump1170;
    _jump1151:;
    bool _253 = true;
    bool _252 = _253;
    if (0 != _253)
    goto _jump1171;
    bool _254 = true;
    _252 = _254;
    _jump1171:;
    bool _255 = !_252;
    double _256;
    if (!_255)
    goto _jump1172;
    double _257 = 69.0;
    _256 = _257;
    goto _jump1173;
    _jump1172:;
    double _258 = 23.0;
    _256 = _258;
    _jump1173:;
    rgba _259 = A();
    double _260 = _259.r;
    double _261 = _256 - _260;
    double _262 = -_261;
    _228 = _262;
    _jump1170:;
    double _263 = 45.0;
    rgba _264 = { _216, _217, _228, _263 };
    return _264;
    if (c >= 0)
    goto _jump1174;
    fail_assertion("negative array index");
    _jump1174:;
    if (c < _192.d0)
    goto _jump1175;
    fail_assertion("index too large");
    _jump1175:;
    int64_t _265 = 0;
    _265 *= _192.d0;
    _265 += c;
    bool _266 = _192.data[_265];
    rgba _267 = A();
    return _267;
}

int64_t C(_a2__a1_int64_t D, bool G, _a1_void_t H) {
    bool _0 = false;
    bool _1 = D.d0 < D.d0;
    bool _2 = _0 != _1;
    bool _3 = !_2;
    _a1_rgba _4;
    if (!_3)
    goto _jump1176;
    rgba _5 = A();
    _a1_rgba _6;
    _6.d0 = 1;
    _6.data = jpl_alloc(sizeof(rgba) * 1);
    _6.data[0] = _5;
    if (H.d0 >= 0)
    goto _jump1177;
    fail_assertion("negative array index");
    _jump1177:;
    if (H.d0 < _6.d0)
    goto _jump1178;
    fail_assertion("index too large");
    _jump1178:;
    int64_t _7 = 0;
    _7 *= _6.d0;
    _7 += H.d0;
    rgba _8 = _6.data[_7];
    rgba _9 = A();
    bool _10 = !G;
    rgba _11;
    if (!_10)
    goto _jump1179;
    rgba _12 = A();
    _11 = _12;
    goto _jump1180;
    _jump1179:;
    rgba _13 = A();
    _11 = _13;
    _jump1180:;
    _a1_rgba _14;
    _14.d0 = 3;
    _14.data = jpl_alloc(sizeof(rgba) * 3);
    _14.data[0] = _8;
    _14.data[1] = _9;
    _14.data[2] = _11;
    _4 = _14;
    goto _jump1181;
    _jump1176:;
    _a1__a1_rgba _15;
    // Computing bound for J
    if (k >= 0)
    goto _jump1182;
    fail_assertion("negative array index");
    _jump1182:;
    if (k < a.d0)
    goto _jump1183;
    fail_assertion("index too large");
    _jump1183:;
    if (u >= 0)
    goto _jump1184;
    fail_assertion("negative array index");
    _jump1184:;
    if (u < a.d1)
    goto _jump1185;
    fail_assertion("index too large");
    _jump1185:;
    if (j >= 0)
    goto _jump1186;
    fail_assertion("negative array index");
    _jump1186:;
    if (j < a.d2)
    goto _jump1187;
    fail_assertion("index too large");
    _jump1187:;
    int64_t _16 = 0;
    _16 *= a.d0;
    _16 += k;
    _16 *= a.d1;
    _16 += u;
    _16 *= a.d2;
    _16 += j;
    int64_t _17 = a.data[_16];
    _15.d0 = _17;
    if (_17 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= _17;
    _18 *= sizeof(_a1_rgba);
    _15.data = jpl_alloc(_18);
    int64_t _19 = 0; // J
    _jump1189:; // Begin body of loop
    rgba _20 = A();
    _a1_rgba _21;
    _21.d0 = 1;
    _21.data = jpl_alloc(sizeof(rgba) * 1);
    _21.data[0] = _20;
    int64_t _22 = 0;
    _22 *= _15.d0;
    _22 += _19;
    _15.data[_22] = _21;
    _19++;
    if (_19 < _17)
    goto _jump1189;
    // End body of loop
    if (k >= 0)
    goto _jump1190;
    fail_assertion("negative array index");
    _jump1190:;
    if (k < _15.d0)
    goto _jump1191;
    fail_assertion("index too large");
    _jump1191:;
    int64_t _23 = 0;
    _23 *= _15.d0;
    _23 += k;
    _a1_rgba _24 = _15.data[_23];
    _4 = _24;
    _jump1181:;
    int64_t _25 = n();
    if (_25 >= 0)
    goto _jump1192;
    fail_assertion("negative array index");
    _jump1192:;
    if (_25 < _4.d0)
    goto _jump1193;
    fail_assertion("index too large");
    _jump1193:;
    int64_t _26 = 0;
    _26 *= _4.d0;
    _26 += _25;
    rgba _27 = _4.data[_26];
    double _28 = _27.g;
    double _29 = 54.0;
    _a2_bool _30;
    // Computing bound for J
    _30.d0 = d;
    if (d > 0) 
    goto _jump1194;
    fail_assertion("non-positive loop bound");
    _jump1194:;
    // Computing bound for K
    _30.d1 = j;
    if (j > 0) 
    goto _jump1195;
    fail_assertion("non-positive loop bound");
    _jump1195:;
    // Computing total size of heap memory to allocate
    int64_t _31 = 1;
    _31 *= d;
    _31 *= j;
    _31 *= sizeof(bool);
    _30.data = jpl_alloc(_31);
    int64_t _32 = 0; // K
    int64_t _33 = 0; // J
    _jump1196:; // Begin body of loop
    bool _34;
    if (!G)
    goto _jump1197;
    bool _35 = G == G;
    _34 = _35;
    goto _jump1198;
    _jump1197:;
    double _36 = 70.0;
    double _37 = 85.0;
    bool _38 = _36 != _37;
    _34 = _38;
    _jump1198:;
    int64_t _39 = 0;
    _39 *= _30.d0;
    _39 += _33;
    _39 *= _30.d1;
    _39 += _32;
    _30.data[_39] = _34;
    _32++;
    if (_32 < j)
    goto _jump1196;
    _32 = 0;
    _33++;
    if (_33 < d)
    goto _jump1196;
    // End body of loop
    int64_t _40;
    // Computing bound for J
    if (k > 0) 
    goto _jump1199;
    fail_assertion("non-positive loop bound");
    _jump1199:;
    _40 = 0;
    int64_t _41 = 0; // J
    _jump1200:; // Begin body of loop
    _40 += D.d0;
    _41++;
    if (_41 < k)
    goto _jump1200;
    // End body of loop
    if (_40 >= 0)
    goto _jump1201;
    fail_assertion("negative array index");
    _jump1201:;
    if (_40 < _30.d0)
    goto _jump1202;
    fail_assertion("index too large");
    _jump1202:;
    if (q >= 0)
    goto _jump1203;
    fail_assertion("negative array index");
    _jump1203:;
    if (q < _30.d1)
    goto _jump1204;
    fail_assertion("index too large");
    _jump1204:;
    int64_t _42 = 0;
    _42 *= _30.d0;
    _42 += _40;
    _42 *= _30.d1;
    _42 += q;
    bool _43 = _30.data[_42];
    double _44;
    if (!_43)
    goto _jump1205;
    double _45 = 71.0;
    double _46 = -_45;
    _44 = _46;
    goto _jump1206;
    _jump1205:;
    double _47;
    // Computing bound for J
    if (f > 0) 
    goto _jump1207;
    fail_assertion("non-positive loop bound");
    _jump1207:;
    _47 = 0;
    int64_t _48 = 0; // J
    _jump1208:; // Begin body of loop
    _a3__a2_void_t _49;
    // Computing bound for K
    _49.d0 = m;
    if (m > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing bound for L
    _49.d1 = c;
    if (c > 0) 
    goto _jump1210;
    fail_assertion("non-positive loop bound");
    _jump1210:;
    // Computing bound for M
    _49.d2 = d;
    if (d > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= m;
    _50 *= c;
    _50 *= d;
    _50 *= sizeof(_a2_void_t);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // M
    int64_t _52 = 0; // L
    int64_t _53 = 0; // K
    _jump1212:; // Begin body of loop
    _a2_void_t _54;
    // Computing bound for N
    _54.d0 = s;
    if (s > 0) 
    goto _jump1213;
    fail_assertion("non-positive loop bound");
    _jump1213:;
    // Computing bound for O
    _54.d1 = m;
    if (m > 0) 
    goto _jump1214;
    fail_assertion("non-positive loop bound");
    _jump1214:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= s;
    _55 *= m;
    _55 *= sizeof(void_t);
    _54.data = jpl_alloc(_55);
    int64_t _56 = 0; // O
    int64_t _57 = 0; // N
    _jump1215:; // Begin body of loop
    if (b >= 0)
    goto _jump1216;
    fail_assertion("negative array index");
    _jump1216:;
    if (b < H.d0)
    goto _jump1217;
    fail_assertion("index too large");
    _jump1217:;
    int64_t _58 = 0;
    _58 *= H.d0;
    _58 += b;
    void_t _59 = H.data[_58];
    int64_t _60 = 0;
    _60 *= _54.d0;
    _60 += _57;
    _60 *= _54.d1;
    _60 += _56;
    _54.data[_60] = _59;
    _56++;
    if (_56 < m)
    goto _jump1215;
    _56 = 0;
    _57++;
    if (_57 < s)
    goto _jump1215;
    // End body of loop
    int64_t _61 = 0;
    _61 *= _49.d0;
    _61 += _53;
    _61 *= _49.d1;
    _61 += _52;
    _61 *= _49.d2;
    _61 += _51;
    _49.data[_61] = _54;
    _51++;
    if (_51 < d)
    goto _jump1212;
    _51 = 0;
    _52++;
    if (_52 < c)
    goto _jump1212;
    _52 = 0;
    _53++;
    if (_53 < m)
    goto _jump1212;
    // End body of loop
    _a1__a3_int64_t _62;
    // Computing bound for K
    _62.d0 = _48;
    if (_48 > 0) 
    goto _jump1218;
    fail_assertion("non-positive loop bound");
    _jump1218:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= _48;
    _63 *= sizeof(_a3_int64_t);
    _62.data = jpl_alloc(_63);
    int64_t _64 = 0; // K
    _jump1219:; // Begin body of loop
    _a3_int64_t _65;
    // Computing bound for L
    _65.d0 = i;
    if (i > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing bound for M
    _65.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing bound for N
    _65.d2 = D.d0;
    if (D.d0 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= i;
    _66 *= H.d0;
    _66 *= D.d0;
    _66 *= sizeof(int64_t);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // N
    int64_t _68 = 0; // M
    int64_t _69 = 0; // L
    _jump1223:; // Begin body of loop
    int64_t _70 = 0;
    _70 *= _65.d0;
    _70 += _69;
    _70 *= _65.d1;
    _70 += _68;
    _70 *= _65.d2;
    _70 += _67;
    _65.data[_70] = w;
    _67++;
    if (_67 < D.d0)
    goto _jump1223;
    _67 = 0;
    _68++;
    if (_68 < H.d0)
    goto _jump1223;
    _68 = 0;
    _69++;
    if (_69 < i)
    goto _jump1223;
    // End body of loop
    int64_t _71 = 0;
    _71 *= _62.d0;
    _71 += _64;
    _62.data[_71] = _65;
    _64++;
    if (_64 < _48)
    goto _jump1219;
    // End body of loop
    if (D.d0 >= 0)
    goto _jump1224;
    fail_assertion("negative array index");
    _jump1224:;
    if (D.d0 < _62.d0)
    goto _jump1225;
    fail_assertion("index too large");
    _jump1225:;
    int64_t _72 = 0;
    _72 *= _62.d0;
    _72 += D.d0;
    _a3_int64_t _73 = _62.data[_72];
    double _74 = z(_49, G, _73);
    _47 += _74;
    _48++;
    if (_48 < f)
    goto _jump1208;
    // End body of loop
    _44 = _47;
    _jump1206:;
    double _75 = 97.0;
    double _76;
    // Computing bound for J
    if (f > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for K
    if (d > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing bound for L
    if (b > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    _76 = 0;
    int64_t _77 = 0; // L
    int64_t _78 = 0; // K
    int64_t _79 = 0; // J
    _jump1229:; // Begin body of loop
    double _80 = 74.0;
    double _81 = 34.0;
    double _82 = _80 * _81;
    _76 += _82;
    _77++;
    if (_77 < b)
    goto _jump1229;
    _77 = 0;
    _78++;
    if (_78 < d)
    goto _jump1229;
    _78 = 0;
    _79++;
    if (_79 < f)
    goto _jump1229;
    // End body of loop
    double _83 = 56.0;
    double _84 = 71.0;
    double _85 = _83 + _84;
    double _86;
    // Computing bound for J
    if (b > 0) 
    goto _jump1230;
    fail_assertion("non-positive loop bound");
    _jump1230:;
    // Computing bound for K
    int64_t _87;
    // Computing bound for J
    if (q > 0) 
    goto _jump1231;
    fail_assertion("non-positive loop bound");
    _jump1231:;
    _87 = 0;
    int64_t _88 = 0; // J
    _jump1232:; // Begin body of loop
    _87 += d;
    _88++;
    if (_88 < q)
    goto _jump1232;
    // End body of loop
    if (_87 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    _86 = 0;
    int64_t _89 = 0; // K
    int64_t _90 = 0; // J
    _jump1234:; // Begin body of loop
    double _91 = 24.0;
    _86 += _91;
    _89++;
    if (_89 < _87)
    goto _jump1234;
    _89 = 0;
    _90++;
    if (_90 < b)
    goto _jump1234;
    // End body of loop
    double _92 = _85 + _86;
    bool _93 = false;
    double _94;
    if (!_93)
    goto _jump1235;
    double _95 = 68.0;
    _94 = _95;
    goto _jump1236;
    _jump1235:;
    double _96;
    // Computing bound for J
    if (b > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    _96 = 0;
    int64_t _97 = 0; // J
    _jump1238:; // Begin body of loop
    double _98 = 13.0;
    _96 += _98;
    _97++;
    if (_97 < b)
    goto _jump1238;
    // End body of loop
    _94 = _96;
    _jump1236:;
    double _99 = -_94;
    rgba _100 = { _75, _76, _92, _99 };
    double _101 = _100.g;
    _a2_double _102;
    // Computing bound for J
    int64_t _103 = n();
    _102.d0 = _103;
    if (_103 > 0) 
    goto _jump1239;
    fail_assertion("non-positive loop bound");
    _jump1239:;
    // Computing bound for K
    _102.d1 = s;
    if (s > 0) 
    goto _jump1240;
    fail_assertion("non-positive loop bound");
    _jump1240:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= _103;
    _104 *= s;
    _104 *= sizeof(double);
    _102.data = jpl_alloc(_104);
    int64_t _105 = 0; // K
    int64_t _106 = 0; // J
    _jump1241:; // Begin body of loop
    double _107 = 94.0;
    double _108 = 81.0;
    double _109 = _107 - _108;
    _a2_double _110;
    // Computing bound for L
    _110.d0 = w;
    if (w > 0) 
    goto _jump1242;
    fail_assertion("non-positive loop bound");
    _jump1242:;
    // Computing bound for M
    _110.d1 = c;
    if (c > 0) 
    goto _jump1243;
    fail_assertion("non-positive loop bound");
    _jump1243:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= w;
    _111 *= c;
    _111 *= sizeof(double);
    _110.data = jpl_alloc(_111);
    int64_t _112 = 0; // M
    int64_t _113 = 0; // L
    _jump1244:; // Begin body of loop
    double _114 = 57.0;
    int64_t _115 = 0;
    _115 *= _110.d0;
    _115 += _113;
    _115 *= _110.d1;
    _115 += _112;
    _110.data[_115] = _114;
    _112++;
    if (_112 < c)
    goto _jump1244;
    _112 = 0;
    _113++;
    if (_113 < w)
    goto _jump1244;
    // End body of loop
    if (v >= 0)
    goto _jump1245;
    fail_assertion("negative array index");
    _jump1245:;
    if (v < _110.d0)
    goto _jump1246;
    fail_assertion("index too large");
    _jump1246:;
    if (u >= 0)
    goto _jump1247;
    fail_assertion("negative array index");
    _jump1247:;
    if (u < _110.d1)
    goto _jump1248;
    fail_assertion("index too large");
    _jump1248:;
    int64_t _116 = 0;
    _116 *= _110.d0;
    _116 += v;
    _116 *= _110.d1;
    _116 += u;
    double _117 = _110.data[_116];
    double _118 = _109 * _117;
    int64_t _119 = 0;
    _119 *= _102.d0;
    _119 += _106;
    _119 *= _102.d1;
    _119 += _105;
    _102.data[_119] = _118;
    _105++;
    if (_105 < s)
    goto _jump1241;
    _105 = 0;
    _106++;
    if (_106 < _103)
    goto _jump1241;
    // End body of loop
    if (w >= 0)
    goto _jump1249;
    fail_assertion("negative array index");
    _jump1249:;
    if (w < l.d0)
    goto _jump1250;
    fail_assertion("index too large");
    _jump1250:;
    int64_t _120 = 0;
    _120 *= l.d0;
    _120 += w;
    bool _121 = l.data[_120];
    _a2__a1_int64_t _122;
    if (!_121)
    goto _jump1251;
    _a2__a1_int64_t _123;
    // Computing bound for J
    _123.d0 = f;
    if (f > 0) 
    goto _jump1252;
    fail_assertion("non-positive loop bound");
    _jump1252:;
    // Computing bound for K
    _123.d1 = v;
    if (v > 0) 
    goto _jump1253;
    fail_assertion("non-positive loop bound");
    _jump1253:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= f;
    _124 *= v;
    _124 *= sizeof(_a1_int64_t);
    _123.data = jpl_alloc(_124);
    int64_t _125 = 0; // K
    int64_t _126 = 0; // J
    _jump1254:; // Begin body of loop
    int64_t _127 = 831;
    _a1_int64_t _128;
    _128.d0 = 1;
    _128.data = jpl_alloc(sizeof(int64_t) * 1);
    _128.data[0] = _127;
    int64_t _129 = 0;
    _129 *= _123.d0;
    _129 += _126;
    _129 *= _123.d1;
    _129 += _125;
    _123.data[_129] = _128;
    _125++;
    if (_125 < v)
    goto _jump1254;
    _125 = 0;
    _126++;
    if (_126 < f)
    goto _jump1254;
    // End body of loop
    _122 = _123;
    goto _jump1255;
    _jump1251:;
    _a3__a2__a1_int64_t _130;
    // Computing bound for J
    _130.d0 = g;
    if (g > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    // Computing bound for K
    _130.d1 = c;
    if (c > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    // Computing bound for L
    _130.d2 = D.d0;
    if (D.d0 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= g;
    _131 *= c;
    _131 *= D.d0;
    _131 *= sizeof(_a2__a1_int64_t);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // L
    int64_t _133 = 0; // K
    int64_t _134 = 0; // J
    _jump1259:; // Begin body of loop
    int64_t _135 = 0;
    _135 *= _130.d0;
    _135 += _134;
    _135 *= _130.d1;
    _135 += _133;
    _135 *= _130.d2;
    _135 += _132;
    _130.data[_135] = D;
    _132++;
    if (_132 < D.d0)
    goto _jump1259;
    _132 = 0;
    _133++;
    if (_133 < c)
    goto _jump1259;
    _133 = 0;
    _134++;
    if (_134 < g)
    goto _jump1259;
    // End body of loop
    int64_t _136 = 269;
    if (s >= 0)
    goto _jump1260;
    fail_assertion("negative array index");
    _jump1260:;
    if (s < _130.d0)
    goto _jump1261;
    fail_assertion("index too large");
    _jump1261:;
    if (_136 >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (_136 < _130.d1)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    if (c >= 0)
    goto _jump1264;
    fail_assertion("negative array index");
    _jump1264:;
    if (c < _130.d2)
    goto _jump1265;
    fail_assertion("index too large");
    _jump1265:;
    int64_t _137 = 0;
    _137 *= _130.d0;
    _137 += s;
    _137 *= _130.d1;
    _137 += _136;
    _137 *= _130.d2;
    _137 += c;
    _a2__a1_int64_t _138 = _130.data[_137];
    _122 = _138;
    _jump1255:;
    if (f >= 0)
    goto _jump1266;
    fail_assertion("negative array index");
    _jump1266:;
    if (f < l.d0)
    goto _jump1267;
    fail_assertion("index too large");
    _jump1267:;
    int64_t _139 = 0;
    _139 *= l.d0;
    _139 += f;
    bool _140 = l.data[_139];
    if (D.d0 >= 0)
    goto _jump1268;
    fail_assertion("negative array index");
    _jump1268:;
    if (D.d0 < H.d0)
    goto _jump1269;
    fail_assertion("index too large");
    _jump1269:;
    int64_t _141 = 0;
    _141 *= H.d0;
    _141 += D.d0;
    void_t _142 = H.data[_141];
    _a1_void_t _143;
    _143.d0 = 1;
    _143.data = jpl_alloc(sizeof(void_t) * 1);
    _143.data[0] = _142;
    int64_t _144 = C(_122, _140, _143);
    if (_144 >= 0)
    goto _jump1270;
    fail_assertion("negative array index");
    _jump1270:;
    if (_144 < _102.d0)
    goto _jump1271;
    fail_assertion("index too large");
    _jump1271:;
    if (k >= 0)
    goto _jump1272;
    fail_assertion("negative array index");
    _jump1272:;
    if (k < _102.d1)
    goto _jump1273;
    fail_assertion("index too large");
    _jump1273:;
    int64_t _145 = 0;
    _145 *= _102.d0;
    _145 += _144;
    _145 *= _102.d1;
    _145 += k;
    double _146 = _102.data[_145];
    double _147 = _101 / _146;
    rgba _148 = { _28, _29, _44, _147 };
    _a3__a2_void_t _149;
    // Computing bound for K
    _149.d0 = w;
    if (w > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    // Computing bound for L
    int64_t _150 = 698;
    int64_t _151 = -_150;
    _149.d1 = _151;
    if (_151 > 0) 
    goto _jump1275;
    fail_assertion("non-positive loop bound");
    _jump1275:;
    // Computing bound for M
    _149.d2 = c;
    if (c > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= w;
    _152 *= _151;
    _152 *= c;
    _152 *= sizeof(_a2_void_t);
    _149.data = jpl_alloc(_152);
    int64_t _153 = 0; // M
    int64_t _154 = 0; // L
    int64_t _155 = 0; // K
    _jump1277:; // Begin body of loop
    _a2_void_t _156;
    // Computing bound for N
    bool _157 = true;
    bool _158 = !_157;
    bool _159 = !_158;
    bool _160;
    if (!_159)
    goto _jump1278;
    bool _161 = true;
    bool _162 = !_161;
    bool _163 = !_162;
    _160 = _163;
    goto _jump1279;
    _jump1278:;
    _a3_bool _164;
    // Computing bound for N
    int64_t _165 = n();
    _164.d0 = _165;
    if (_165 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    // Computing bound for O
    _164.d1 = b;
    if (b > 0) 
    goto _jump1281;
    fail_assertion("non-positive loop bound");
    _jump1281:;
    // Computing bound for P
    _164.d2 = u;
    if (u > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= _165;
    _166 *= b;
    _166 *= u;
    _166 *= sizeof(bool);
    _164.data = jpl_alloc(_166);
    int64_t _167 = 0; // P
    int64_t _168 = 0; // O
    int64_t _169 = 0; // N
    _jump1283:; // Begin body of loop
    bool _170 = true;
    int64_t _171 = 0;
    _171 *= _164.d0;
    _171 += _169;
    _171 *= _164.d1;
    _171 += _168;
    _171 *= _164.d2;
    _171 += _167;
    _164.data[_171] = _170;
    _167++;
    if (_167 < u)
    goto _jump1283;
    _167 = 0;
    _168++;
    if (_168 < b)
    goto _jump1283;
    _168 = 0;
    _169++;
    if (_169 < _165)
    goto _jump1283;
    // End body of loop
    if (c >= 0)
    goto _jump1284;
    fail_assertion("negative array index");
    _jump1284:;
    if (c < _164.d0)
    goto _jump1285;
    fail_assertion("index too large");
    _jump1285:;
    if (c >= 0)
    goto _jump1286;
    fail_assertion("negative array index");
    _jump1286:;
    if (c < _164.d1)
    goto _jump1287;
    fail_assertion("index too large");
    _jump1287:;
    if (_153 >= 0)
    goto _jump1288;
    fail_assertion("negative array index");
    _jump1288:;
    if (_153 < _164.d2)
    goto _jump1289;
    fail_assertion("index too large");
    _jump1289:;
    int64_t _172 = 0;
    _172 *= _164.d0;
    _172 += c;
    _172 *= _164.d1;
    _172 += c;
    _172 *= _164.d2;
    _172 += _153;
    bool _173 = _164.data[_172];
    _160 = _173;
    _jump1279:;
    int64_t _174;
    if (!_160)
    goto _jump1290;
    _174 = b;
    goto _jump1291;
    _jump1290:;
    _a2_int64_t _175;
    // Computing bound for N
    _175.d0 = f;
    if (f > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing bound for O
    _175.d1 = j;
    if (j > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= f;
    _176 *= j;
    _176 *= sizeof(int64_t);
    _175.data = jpl_alloc(_176);
    int64_t _177 = 0; // O
    int64_t _178 = 0; // N
    _jump1294:; // Begin body of loop
    int64_t _179 = 0;
    _179 *= _175.d0;
    _179 += _178;
    _179 *= _175.d1;
    _179 += _177;
    _175.data[_179] = v;
    _177++;
    if (_177 < j)
    goto _jump1294;
    _177 = 0;
    _178++;
    if (_178 < f)
    goto _jump1294;
    // End body of loop
    if (s >= 0)
    goto _jump1295;
    fail_assertion("negative array index");
    _jump1295:;
    if (s < _175.d0)
    goto _jump1296;
    fail_assertion("index too large");
    _jump1296:;
    if (u >= 0)
    goto _jump1297;
    fail_assertion("negative array index");
    _jump1297:;
    if (u < _175.d1)
    goto _jump1298;
    fail_assertion("index too large");
    _jump1298:;
    int64_t _180 = 0;
    _180 *= _175.d0;
    _180 += s;
    _180 *= _175.d1;
    _180 += u;
    int64_t _181 = _175.data[_180];
    int64_t _182 = v % _181;
    _174 = _182;
    _jump1291:;
    _156.d0 = _174;
    if (_174 > 0) 
    goto _jump1299;
    fail_assertion("non-positive loop bound");
    _jump1299:;
    // Computing bound for O
    _156.d1 = d;
    if (d > 0) 
    goto _jump1300;
    fail_assertion("non-positive loop bound");
    _jump1300:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= _174;
    _183 *= d;
    _183 *= sizeof(void_t);
    _156.data = jpl_alloc(_183);
    int64_t _184 = 0; // O
    int64_t _185 = 0; // N
    _jump1301:; // Begin body of loop
    _a3_void_t _186;
    // Computing bound for P
    _186.d0 = j;
    if (j > 0) 
    goto _jump1302;
    fail_assertion("non-positive loop bound");
    _jump1302:;
    // Computing bound for Q
    _186.d1 = v;
    if (v > 0) 
    goto _jump1303;
    fail_assertion("non-positive loop bound");
    _jump1303:;
    // Computing bound for R
    _186.d2 = _154;
    if (_154 > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= j;
    _187 *= v;
    _187 *= _154;
    _187 *= sizeof(void_t);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // R
    int64_t _189 = 0; // Q
    int64_t _190 = 0; // P
    _jump1305:; // Begin body of loop
    if (j >= 0)
    goto _jump1306;
    fail_assertion("negative array index");
    _jump1306:;
    if (j < H.d0)
    goto _jump1307;
    fail_assertion("index too large");
    _jump1307:;
    int64_t _191 = 0;
    _191 *= H.d0;
    _191 += j;
    void_t _192 = H.data[_191];
    int64_t _193 = 0;
    _193 *= _186.d0;
    _193 += _190;
    _193 *= _186.d1;
    _193 += _189;
    _193 *= _186.d2;
    _193 += _188;
    _186.data[_193] = _192;
    _188++;
    if (_188 < _154)
    goto _jump1305;
    _188 = 0;
    _189++;
    if (_189 < v)
    goto _jump1305;
    _189 = 0;
    _190++;
    if (_190 < j)
    goto _jump1305;
    // End body of loop
    int64_t _194 = -s;
    if (k >= 0)
    goto _jump1308;
    fail_assertion("negative array index");
    _jump1308:;
    if (k < _186.d0)
    goto _jump1309;
    fail_assertion("index too large");
    _jump1309:;
    if (_194 >= 0)
    goto _jump1310;
    fail_assertion("negative array index");
    _jump1310:;
    if (_194 < _186.d1)
    goto _jump1311;
    fail_assertion("index too large");
    _jump1311:;
    if (d >= 0)
    goto _jump1312;
    fail_assertion("negative array index");
    _jump1312:;
    if (d < _186.d2)
    goto _jump1313;
    fail_assertion("index too large");
    _jump1313:;
    int64_t _195 = 0;
    _195 *= _186.d0;
    _195 += k;
    _195 *= _186.d1;
    _195 += _194;
    _195 *= _186.d2;
    _195 += d;
    void_t _196 = _186.data[_195];
    int64_t _197 = 0;
    _197 *= _156.d0;
    _197 += _185;
    _197 *= _156.d1;
    _197 += _184;
    _156.data[_197] = _196;
    _184++;
    if (_184 < d)
    goto _jump1301;
    _184 = 0;
    _185++;
    if (_185 < _174)
    goto _jump1301;
    // End body of loop
    int64_t _198 = 0;
    _198 *= _149.d0;
    _198 += _155;
    _198 *= _149.d1;
    _198 += _154;
    _198 *= _149.d2;
    _198 += _153;
    _149.data[_198] = _156;
    _153++;
    if (_153 < c)
    goto _jump1277;
    _153 = 0;
    _154++;
    if (_154 < _151)
    goto _jump1277;
    _154 = 0;
    _155++;
    if (_155 < w)
    goto _jump1277;
    // End body of loop
    bool _199 = !G;
    bool _200 = false;
    bool _201 = !_200;
    _a1__a1__a2__a3_int64_t _202;
    if (!_201)
    goto _jump1314;
    _a1__a2__a3_int64_t _203;
    _203.d0 = 2;
    _203.data = jpl_alloc(sizeof(_a2__a3_int64_t) * 2);
    _203.data[0] = e;
    _203.data[1] = e;
    _a1__a2__a3_int64_t _204;
    // Computing bound for K
    _204.d0 = d;
    if (d > 0) 
    goto _jump1315;
    fail_assertion("non-positive loop bound");
    _jump1315:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= d;
    _205 *= sizeof(_a2__a3_int64_t);
    _204.data = jpl_alloc(_205);
    int64_t _206 = 0; // K
    _jump1316:; // Begin body of loop
    int64_t _207 = 0;
    _207 *= _204.d0;
    _207 += _206;
    _204.data[_207] = p;
    _206++;
    if (_206 < d)
    goto _jump1316;
    // End body of loop
    _a1__a1__a2__a3_int64_t _208;
    _208.d0 = 2;
    _208.data = jpl_alloc(sizeof(_a1__a2__a3_int64_t) * 2);
    _208.data[0] = _203;
    _208.data[1] = _204;
    _202 = _208;
    goto _jump1317;
    _jump1314:;
    _a1__a1__a2__a3_int64_t _209;
    // Computing bound for K
    _209.d0 = H.d0;
    if (H.d0 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= H.d0;
    _210 *= sizeof(_a1__a2__a3_int64_t);
    _209.data = jpl_alloc(_210);
    int64_t _211 = 0; // K
    _jump1319:; // Begin body of loop
    _a1__a2__a3_int64_t _212;
    _212.d0 = 1;
    _212.data = jpl_alloc(sizeof(_a2__a3_int64_t) * 1);
    _212.data[0] = p;
    int64_t _213 = 0;
    _213 *= _209.d0;
    _213 += _211;
    _209.data[_213] = _212;
    _211++;
    if (_211 < H.d0)
    goto _jump1319;
    // End body of loop
    _202 = _209;
    _jump1317:;
    int64_t _214 = n();
    if (_214 >= 0)
    goto _jump1320;
    fail_assertion("negative array index");
    _jump1320:;
    if (_214 < _202.d0)
    goto _jump1321;
    fail_assertion("index too large");
    _jump1321:;
    int64_t _215 = 0;
    _215 *= _202.d0;
    _215 += _214;
    _a1__a2__a3_int64_t _216 = _202.data[_215];
    if (m >= 0)
    goto _jump1322;
    fail_assertion("negative array index");
    _jump1322:;
    if (m < _216.d0)
    goto _jump1323;
    fail_assertion("index too large");
    _jump1323:;
    int64_t _217 = 0;
    _217 *= _216.d0;
    _217 += m;
    _a2__a3_int64_t _218 = _216.data[_217];
    int64_t _219;
    // Computing bound for K
    int64_t _220 = 546;
    if (_220 > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing bound for L
    if (i > 0) 
    goto _jump1325;
    fail_assertion("non-positive loop bound");
    _jump1325:;
    // Computing bound for M
    if (D.d0 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    _219 = 0;
    int64_t _221 = 0; // M
    int64_t _222 = 0; // L
    int64_t _223 = 0; // K
    _jump1327:; // Begin body of loop
    _219 += g;
    _221++;
    if (_221 < D.d0)
    goto _jump1327;
    _221 = 0;
    _222++;
    if (_222 < i)
    goto _jump1327;
    _222 = 0;
    _223++;
    if (_223 < _220)
    goto _jump1327;
    // End body of loop
    if (k >= 0)
    goto _jump1328;
    fail_assertion("negative array index");
    _jump1328:;
    if (k < _218.d0)
    goto _jump1329;
    fail_assertion("index too large");
    _jump1329:;
    if (_219 >= 0)
    goto _jump1330;
    fail_assertion("negative array index");
    _jump1330:;
    if (_219 < _218.d1)
    goto _jump1331;
    fail_assertion("index too large");
    _jump1331:;
    int64_t _224 = 0;
    _224 *= _218.d0;
    _224 += k;
    _224 *= _218.d1;
    _224 += _219;
    _a3_int64_t _225 = _218.data[_224];
    double _226 = z(_149, _199, _225);
    _a3_int64_t _227;
    if (!G)
    goto _jump1332;
    _227 = a;
    goto _jump1333;
    _jump1332:;
    _227 = t;
    _jump1333:;
    int64_t _228 = n();
    if (_228 >= 0)
    goto _jump1334;
    fail_assertion("negative array index");
    _jump1334:;
    if (_228 < _227.d0)
    goto _jump1335;
    fail_assertion("index too large");
    _jump1335:;
    if (y >= 0)
    goto _jump1336;
    fail_assertion("negative array index");
    _jump1336:;
    if (y < _227.d1)
    goto _jump1337;
    fail_assertion("index too large");
    _jump1337:;
    if (w >= 0)
    goto _jump1338;
    fail_assertion("negative array index");
    _jump1338:;
    if (w < _227.d2)
    goto _jump1339;
    fail_assertion("index too large");
    _jump1339:;
    int64_t _229 = 0;
    _229 *= _227.d0;
    _229 += _228;
    _229 *= _227.d1;
    _229 += y;
    _229 *= _227.d2;
    _229 += w;
    int64_t _230 = _227.data[_229];
    int64_t _231 = H.d0 + _230;
    int64_t _232 = n();
    int64_t _233 = g * _232;
    int64_t _234 = _231 - _233;
    int64_t _235 = -_234;
    return _235;
    return D.d0;
    int64_t _236 = 495;
    return _236;
    return D.d0;
}

void jpl_main(struct args args) {
    int64_t _0 = 513;
    bool _1 = false;
    int64_t _2;
    if (!_1)
    goto _jump1;
    _a3_int64_t _3;
    // Computing bound for a
    int64_t _4 = 312;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for b
    int64_t _5 = 519;
    _3.d1 = _5;
    if (_5 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing bound for c
    int64_t _6;
    // Computing bound for a
    int64_t _7 = 615;
    if (_7 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    // Computing bound for b
    int64_t _8 = 216;
    if (_8 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    _6 = 0;
    int64_t _9 = 0; // b
    int64_t _10 = 0; // a
    _jump6:; // Begin body of loop
    int64_t _11 = 940;
    _6 += _11;
    _9++;
    if (_9 < _8)
    goto _jump6;
    _9 = 0;
    _10++;
    if (_10 < _7)
    goto _jump6;
    // End body of loop
    int64_t _12 = -_6;
    int64_t _13 = -_12;
    _3.d2 = _13;
    if (_13 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _4;
    _14 *= _5;
    _14 *= _13;
    _14 *= sizeof(int64_t);
    _3.data = jpl_alloc(_14);
    int64_t _15 = 0; // c
    int64_t _16 = 0; // b
    int64_t _17 = 0; // a
    _jump8:; // Begin body of loop
    int64_t _18;
    // Computing bound for d
    if (_16 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    _18 = 0;
    int64_t _19 = 0; // d
    _jump10:; // Begin body of loop
    _18 += _16;
    _19++;
    if (_19 < _16)
    goto _jump10;
    // End body of loop
    int64_t _20 = _17 / _18;
    int64_t _21 = 0;
    _21 *= _3.d0;
    _21 += _17;
    _21 *= _3.d1;
    _21 += _16;
    _21 *= _3.d2;
    _21 += _15;
    _3.data[_21] = _20;
    _15++;
    if (_15 < _13)
    goto _jump8;
    _15 = 0;
    _16++;
    if (_16 < _5)
    goto _jump8;
    _16 = 0;
    _17++;
    if (_17 < _4)
    goto _jump8;
    // End body of loop
    int64_t _22;
    // Computing bound for a
    _a2_int64_t _23;
    // Computing bound for a
    int64_t _24;
    // Computing bound for a
    int64_t _25 = 984;
    if (_25 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    _24 = 0;
    int64_t _26 = 0; // a
    _jump12:; // Begin body of loop
    int64_t _27 = 954;
    _24 += _27;
    _26++;
    if (_26 < _25)
    goto _jump12;
    // End body of loop
    _23.d0 = _24;
    if (_24 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    // Computing bound for b
    int64_t _28 = 850;
    _23.d1 = _28;
    if (_28 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _24;
    _29 *= _28;
    _29 *= sizeof(int64_t);
    _23.data = jpl_alloc(_29);
    int64_t _30 = 0; // b
    int64_t _31 = 0; // a
    _jump15:; // Begin body of loop
    int64_t _32 = 0;
    _32 *= _23.d0;
    _32 += _31;
    _32 *= _23.d1;
    _32 += _30;
    _23.data[_32] = _30;
    _30++;
    if (_30 < _28)
    goto _jump15;
    _30 = 0;
    _31++;
    if (_31 < _24)
    goto _jump15;
    // End body of loop
    int64_t _33 = 945;
    bool _34 = false;
    int64_t _35;
    if (!_34)
    goto _jump16;
    int64_t _36 = 945;
    _35 = _36;
    goto _jump17;
    _jump16:;
    int64_t _37 = 139;
    int64_t _38 = 113;
    int64_t _39 = _37 % _38;
    _35 = _39;
    _jump17:;
    if (_33 >= 0)
    goto _jump18;
    fail_assertion("negative array index");
    _jump18:;
    if (_33 < _23.d0)
    goto _jump19;
    fail_assertion("index too large");
    _jump19:;
    if (_35 >= 0)
    goto _jump20;
    fail_assertion("negative array index");
    _jump20:;
    if (_35 < _23.d1)
    goto _jump21;
    fail_assertion("index too large");
    _jump21:;
    int64_t _40 = 0;
    _40 *= _23.d0;
    _40 += _33;
    _40 *= _23.d1;
    _40 += _35;
    int64_t _41 = _23.data[_40];
    if (_41 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    _22 = 0;
    int64_t _42 = 0; // a
    _jump23:; // Begin body of loop
    bool _43 = false;
    int64_t _44;
    if (!_43)
    goto _jump24;
    _44 = _42;
    goto _jump25;
    _jump24:;
    _44 = _42;
    _jump25:;
    bool _45 = _42 <= _44;
    int64_t _46;
    if (!_45)
    goto _jump26;
    int64_t _47 = 976;
    _a1_int64_t _48;
    _48.d0 = 1;
    _48.data = jpl_alloc(sizeof(int64_t) * 1);
    _48.data[0] = _47;
    int64_t _49;
    // Computing bound for b
    if (_42 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _49 = 0;
    int64_t _50 = 0; // b
    _jump28:; // Begin body of loop
    _49 += _50;
    _50++;
    if (_50 < _42)
    goto _jump28;
    // End body of loop
    if (_49 >= 0)
    goto _jump29;
    fail_assertion("negative array index");
    _jump29:;
    if (_49 < _48.d0)
    goto _jump30;
    fail_assertion("index too large");
    _jump30:;
    int64_t _51 = 0;
    _51 *= _48.d0;
    _51 += _49;
    int64_t _52 = _48.data[_51];
    _46 = _52;
    goto _jump31;
    _jump26:;
    bool _53 = false;
    int64_t _54;
    if (!_53)
    goto _jump32;
    int64_t _55 = 602;
    int64_t _56 = -_55;
    _54 = _56;
    goto _jump33;
    _jump32:;
    int64_t _57 = 793;
    int64_t _58 = _42 / _57;
    _54 = _58;
    _jump33:;
    _46 = _54;
    _jump31:;
    _22 += _46;
    _42++;
    if (_42 < _41)
    goto _jump23;
    // End body of loop
    int64_t _59 = 144;
    int64_t _60 = -_59;
    int64_t _61 = 279;
    _a1_int64_t _62;
    _62.d0 = 2;
    _62.data = jpl_alloc(sizeof(int64_t) * 2);
    _62.data[0] = _60;
    _62.data[1] = _61;
    int64_t _63 = 313;
    if (_63 >= 0)
    goto _jump34;
    fail_assertion("negative array index");
    _jump34:;
    if (_63 < _62.d0)
    goto _jump35;
    fail_assertion("index too large");
    _jump35:;
    int64_t _64 = 0;
    _64 *= _62.d0;
    _64 += _63;
    int64_t _65 = _62.data[_64];
    int64_t _66 = 865;
    bool _67 = true;
    int64_t _68;
    if (!_67)
    goto _jump36;
    int64_t _69 = 613;
    _68 = _69;
    goto _jump37;
    _jump36:;
    int64_t _70 = 971;
    int64_t _71 = -_70;
    _68 = _71;
    _jump37:;
    int64_t _72 = _66 + _68;
    int64_t _73 = _65 + _72;
    int64_t _74;
    // Computing bound for a
    bool _76 = true;
    bool _77 = !_76;
    bool _75 = _77;
    if (0 == _77)
    goto _jump38;
    bool _78 = false;
    bool _79 = !_78;
    _75 = _79;
    _jump38:;
    int64_t _80;
    if (!_75)
    goto _jump39;
    int64_t _81 = 413;
    _80 = _81;
    goto _jump40;
    _jump39:;
    int64_t _82 = 315;
    int64_t _83 = -_82;
    _80 = _83;
    _jump40:;
    if (_80 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    // Computing bound for b
    int64_t _84 = 289;
    int64_t _85 = -_84;
    int64_t _86 = -_85;
    if (_86 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    _74 = 0;
    int64_t _87 = 0; // b
    int64_t _88 = 0; // a
    _jump43:; // Begin body of loop
    int64_t _89 = 750;
    int64_t _90 = 260;
    bool _91 = _89 <= _90;
    int64_t _92;
    if (!_91)
    goto _jump44;
    int64_t _93 = 367;
    _92 = _93;
    goto _jump45;
    _jump44:;
    int64_t _94 = _88 % _87;
    _92 = _94;
    _jump45:;
    int64_t _95 = _87 % _87;
    int64_t _96 = _92 * _95;
    _74 += _96;
    _87++;
    if (_87 < _86)
    goto _jump43;
    _87 = 0;
    _88++;
    if (_88 < _80)
    goto _jump43;
    // End body of loop
    if (_22 >= 0)
    goto _jump46;
    fail_assertion("negative array index");
    _jump46:;
    if (_22 < _3.d0)
    goto _jump47;
    fail_assertion("index too large");
    _jump47:;
    if (_73 >= 0)
    goto _jump48;
    fail_assertion("negative array index");
    _jump48:;
    if (_73 < _3.d1)
    goto _jump49;
    fail_assertion("index too large");
    _jump49:;
    if (_74 >= 0)
    goto _jump50;
    fail_assertion("negative array index");
    _jump50:;
    if (_74 < _3.d2)
    goto _jump51;
    fail_assertion("index too large");
    _jump51:;
    int64_t _97 = 0;
    _97 *= _3.d0;
    _97 += _22;
    _97 *= _3.d1;
    _97 += _73;
    _97 *= _3.d2;
    _97 += _74;
    int64_t _98 = _3.data[_97];
    _2 = _98;
    goto _jump52;
    _jump1:;
    _a2_int64_t _99;
    // Computing bound for a
    _a2_int64_t _100;
    // Computing bound for a
    int64_t _101 = 171;
    _100.d0 = _101;
    if (_101 > 0) 
    goto _jump53;
    fail_assertion("non-positive loop bound");
    _jump53:;
    // Computing bound for b
    bool _102 = true;
    int64_t _103;
    if (!_102)
    goto _jump54;
    int64_t _104 = 354;
    _103 = _104;
    goto _jump55;
    _jump54:;
    int64_t _105 = 795;
    _103 = _105;
    _jump55:;
    _100.d1 = _103;
    if (_103 > 0) 
    goto _jump56;
    fail_assertion("non-positive loop bound");
    _jump56:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= _101;
    _106 *= _103;
    _106 *= sizeof(int64_t);
    _100.data = jpl_alloc(_106);
    int64_t _107 = 0; // b
    int64_t _108 = 0; // a
    _jump57:; // Begin body of loop
    int64_t _109 = 217;
    int64_t _110 = _108 - _109;
    int64_t _111 = 0;
    _111 *= _100.d0;
    _111 += _108;
    _111 *= _100.d1;
    _111 += _107;
    _100.data[_111] = _110;
    _107++;
    if (_107 < _103)
    goto _jump57;
    _107 = 0;
    _108++;
    if (_108 < _101)
    goto _jump57;
    // End body of loop
    int64_t _112 = 942;
    int64_t _113 = -_112;
    int64_t _114;
    // Computing bound for a
    int64_t _115 = 876;
    if (_115 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    // Computing bound for b
    int64_t _116 = 45;
    if (_116 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    _114 = 0;
    int64_t _117 = 0; // b
    int64_t _118 = 0; // a
    _jump60:; // Begin body of loop
    _114 += _118;
    _117++;
    if (_117 < _116)
    goto _jump60;
    _117 = 0;
    _118++;
    if (_118 < _115)
    goto _jump60;
    // End body of loop
    if (_113 >= 0)
    goto _jump61;
    fail_assertion("negative array index");
    _jump61:;
    if (_113 < _100.d0)
    goto _jump62;
    fail_assertion("index too large");
    _jump62:;
    if (_114 >= 0)
    goto _jump63;
    fail_assertion("negative array index");
    _jump63:;
    if (_114 < _100.d1)
    goto _jump64;
    fail_assertion("index too large");
    _jump64:;
    int64_t _119 = 0;
    _119 *= _100.d0;
    _119 += _113;
    _119 *= _100.d1;
    _119 += _114;
    int64_t _120 = _100.data[_119];
    _99.d0 = _120;
    if (_120 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing bound for b
    int64_t _121;
    // Computing bound for a
    _a1_int64_t _122;
    // Computing bound for a
    int64_t _123 = 534;
    _122.d0 = _123;
    if (_123 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _123;
    _124 *= sizeof(int64_t);
    _122.data = jpl_alloc(_124);
    int64_t _125 = 0; // a
    _jump67:; // Begin body of loop
    int64_t _126 = 662;
    int64_t _127 = 0;
    _127 *= _122.d0;
    _127 += _125;
    _122.data[_127] = _126;
    _125++;
    if (_125 < _123)
    goto _jump67;
    // End body of loop
    int64_t _128 = 142;
    if (_128 >= 0)
    goto _jump68;
    fail_assertion("negative array index");
    _jump68:;
    if (_128 < _122.d0)
    goto _jump69;
    fail_assertion("index too large");
    _jump69:;
    int64_t _129 = 0;
    _129 *= _122.d0;
    _129 += _128;
    int64_t _130 = _122.data[_129];
    if (_130 > 0) 
    goto _jump70;
    fail_assertion("non-positive loop bound");
    _jump70:;
    // Computing bound for b
    int64_t _131 = 885;
    int64_t _132 = 466;
    bool _133 = _131 <= _132;
    int64_t _134;
    if (!_133)
    goto _jump71;
    int64_t _135 = 791;
    _134 = _135;
    goto _jump72;
    _jump71:;
    int64_t _136 = 833;
    int64_t _137 = -_136;
    _134 = _137;
    _jump72:;
    if (_134 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    _121 = 0;
    int64_t _138 = 0; // b
    int64_t _139 = 0; // a
    _jump74:; // Begin body of loop
    int64_t _140 = 876;
    _121 += _140;
    _138++;
    if (_138 < _134)
    goto _jump74;
    _138 = 0;
    _139++;
    if (_139 < _130)
    goto _jump74;
    // End body of loop
    _99.d1 = _121;
    if (_121 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= _120;
    _141 *= _121;
    _141 *= sizeof(int64_t);
    _99.data = jpl_alloc(_141);
    int64_t _142 = 0; // b
    int64_t _143 = 0; // a
    _jump76:; // Begin body of loop
    int64_t _144 = 0;
    _144 *= _99.d0;
    _144 += _143;
    _144 *= _99.d1;
    _144 += _142;
    _99.data[_144] = _142;
    _142++;
    if (_142 < _121)
    goto _jump76;
    _142 = 0;
    _143++;
    if (_143 < _120)
    goto _jump76;
    // End body of loop
    int64_t _145 = 678;
    double _146 = 65.0;
    double _147 = 84.0;
    bool _148 = _146 > _147;
    int64_t _149;
    if (!_148)
    goto _jump77;
    int64_t _150 = 830;
    int64_t _151 = -_150;
    int64_t _152 = 24;
    int64_t _153 = _151 * _152;
    int64_t _154 = 771;
    int64_t _155 = -_154;
    int64_t _156 = _153 - _155;
    _149 = _156;
    goto _jump78;
    _jump77:;
    int64_t _157 = 26;
    _149 = _157;
    _jump78:;
    if (_145 >= 0)
    goto _jump79;
    fail_assertion("negative array index");
    _jump79:;
    if (_145 < _99.d0)
    goto _jump80;
    fail_assertion("index too large");
    _jump80:;
    if (_149 >= 0)
    goto _jump81;
    fail_assertion("negative array index");
    _jump81:;
    if (_149 < _99.d1)
    goto _jump82;
    fail_assertion("index too large");
    _jump82:;
    int64_t _158 = 0;
    _158 *= _99.d0;
    _158 += _145;
    _158 *= _99.d1;
    _158 += _149;
    int64_t _159 = _99.data[_158];
    _2 = _159;
    _jump52:;
    bool _160 = _0 > _2;
    if (0 != _160)
    goto _jump83;
    fail_assertion("a");
    _jump83:;
    _a3_int64_t _161;
    // Computing bound for a
    bool _162 = true;
    bool _163 = !_162;
    _a2__a1_int64_t _164;
    if (!_163)
    goto _jump84;
    _a2__a1_int64_t _165;
    // Computing bound for a
    int64_t _166 = 165;
    _165.d0 = _166;
    if (_166 > 0) 
    goto _jump85;
    fail_assertion("non-positive loop bound");
    _jump85:;
    // Computing bound for b
    int64_t _167 = 797;
    int64_t _168 = -_167;
    _165.d1 = _168;
    if (_168 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    // Computing total size of heap memory to allocate
    int64_t _169 = 1;
    _169 *= _166;
    _169 *= _168;
    _169 *= sizeof(_a1_int64_t);
    _165.data = jpl_alloc(_169);
    int64_t _170 = 0; // b
    int64_t _171 = 0; // a
    _jump87:; // Begin body of loop
    _a1_int64_t _172;
    // Computing bound for c
    int64_t _173 = -_171;
    _172.d0 = _173;
    if (_173 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    // Computing total size of heap memory to allocate
    int64_t _174 = 1;
    _174 *= _173;
    _174 *= sizeof(int64_t);
    _172.data = jpl_alloc(_174);
    int64_t _175 = 0; // c
    _jump89:; // Begin body of loop
    int64_t _176 = 0;
    _176 *= _172.d0;
    _176 += _175;
    _172.data[_176] = _170;
    _175++;
    if (_175 < _173)
    goto _jump89;
    // End body of loop
    int64_t _177 = 0;
    _177 *= _165.d0;
    _177 += _171;
    _177 *= _165.d1;
    _177 += _170;
    _165.data[_177] = _172;
    _170++;
    if (_170 < _168)
    goto _jump87;
    _170 = 0;
    _171++;
    if (_171 < _166)
    goto _jump87;
    // End body of loop
    _164 = _165;
    goto _jump90;
    _jump84:;
    _a2__a1_int64_t _178;
    // Computing bound for a
    _a1_int64_t _179;
    // Computing bound for a
    int64_t _180 = 239;
    _179.d0 = _180;
    if (_180 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= _180;
    _181 *= sizeof(int64_t);
    _179.data = jpl_alloc(_181);
    int64_t _182 = 0; // a
    _jump92:; // Begin body of loop
    int64_t _183 = 444;
    int64_t _184 = 0;
    _184 *= _179.d0;
    _184 += _182;
    _179.data[_184] = _183;
    _182++;
    if (_182 < _180)
    goto _jump92;
    // End body of loop
    int64_t _185 = 860;
    if (_185 >= 0)
    goto _jump93;
    fail_assertion("negative array index");
    _jump93:;
    if (_185 < _179.d0)
    goto _jump94;
    fail_assertion("index too large");
    _jump94:;
    int64_t _186 = 0;
    _186 *= _179.d0;
    _186 += _185;
    int64_t _187 = _179.data[_186];
    _178.d0 = _187;
    if (_187 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    // Computing bound for b
    int64_t _188 = 801;
    _178.d1 = _188;
    if (_188 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing total size of heap memory to allocate
    int64_t _189 = 1;
    _189 *= _187;
    _189 *= _188;
    _189 *= sizeof(_a1_int64_t);
    _178.data = jpl_alloc(_189);
    int64_t _190 = 0; // b
    int64_t _191 = 0; // a
    _jump97:; // Begin body of loop
    bool _192 = true;
    bool _193;
    if (!_192)
    goto _jump98;
    bool _194 = false;
    _193 = _194;
    goto _jump99;
    _jump98:;
    bool _195 = false;
    _193 = _195;
    _jump99:;
    _a1_int64_t _196;
    if (!_193)
    goto _jump100;
    int64_t _197 = 898;
    _a1_int64_t _198;
    _198.d0 = 1;
    _198.data = jpl_alloc(sizeof(int64_t) * 1);
    _198.data[0] = _197;
    _196 = _198;
    goto _jump101;
    _jump100:;
    _a1_int64_t _199;
    // Computing bound for c
    _199.d0 = _190;
    if (_190 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= _190;
    _200 *= sizeof(int64_t);
    _199.data = jpl_alloc(_200);
    int64_t _201 = 0; // c
    _jump103:; // Begin body of loop
    int64_t _202 = 0;
    _202 *= _199.d0;
    _202 += _201;
    _199.data[_202] = _201;
    _201++;
    if (_201 < _190)
    goto _jump103;
    // End body of loop
    _196 = _199;
    _jump101:;
    int64_t _203 = 0;
    _203 *= _178.d0;
    _203 += _191;
    _203 *= _178.d1;
    _203 += _190;
    _178.data[_203] = _196;
    _190++;
    if (_190 < _188)
    goto _jump97;
    _190 = 0;
    _191++;
    if (_191 < _187)
    goto _jump97;
    // End body of loop
    _164 = _178;
    _jump90:;
    int64_t _204;
    // Computing bound for a
    int64_t _205 = 588;
    int64_t _206 = -_205;
    int64_t _207 = -_206;
    bool _208 = false;
    int64_t _209;
    if (!_208)
    goto _jump104;
    int64_t _210 = 672;
    _209 = _210;
    goto _jump105;
    _jump104:;
    int64_t _211 = 367;
    int64_t _212 = -_211;
    _209 = _212;
    _jump105:;
    int64_t _213 = _207 % _209;
    if (_213 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    _204 = 0;
    int64_t _214 = 0; // a
    _jump107:; // Begin body of loop
    int64_t _215 = 185;
    int64_t _216 = -_215;
    int64_t _217 = _216 - _214;
    int64_t _218 = -_217;
    _204 += _218;
    _214++;
    if (_214 < _213)
    goto _jump107;
    // End body of loop
    int64_t _219 = 976;
    int64_t _220 = 28;
    int64_t _221 = 811;
    int64_t _222 = _220 + _221;
    int64_t _223 = _219 + _222;
    if (_204 >= 0)
    goto _jump108;
    fail_assertion("negative array index");
    _jump108:;
    if (_204 < _164.d0)
    goto _jump109;
    fail_assertion("index too large");
    _jump109:;
    if (_223 >= 0)
    goto _jump110;
    fail_assertion("negative array index");
    _jump110:;
    if (_223 < _164.d1)
    goto _jump111;
    fail_assertion("index too large");
    _jump111:;
    int64_t _224 = 0;
    _224 *= _164.d0;
    _224 += _204;
    _224 *= _164.d1;
    _224 += _223;
    _a1_int64_t _225 = _164.data[_224];
    bool _227 = true;
    bool _226 = _227;
    if (0 == _227)
    goto _jump112;
    bool _228 = true;
    _226 = _228;
    _jump112:;
    bool _229 = true;
    bool _230 = _226 == _229;
    int64_t _231;
    if (!_230)
    goto _jump113;
    int64_t _232 = 653;
    _231 = _232;
    goto _jump114;
    _jump113:;
    bool _233 = false;
    bool _234;
    if (!_233)
    goto _jump115;
    bool _235 = true;
    bool _236 = !_235;
    _234 = _236;
    goto _jump116;
    _jump115:;
    bool _237 = false;
    bool _238 = !_237;
    bool _239 = !_238;
    _234 = _239;
    _jump116:;
    int64_t _240;
    if (!_234)
    goto _jump117;
    _a2_int64_t _241;
    // Computing bound for a
    int64_t _242 = 731;
    _241.d0 = _242;
    if (_242 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    // Computing bound for b
    int64_t _243 = 714;
    _241.d1 = _243;
    if (_243 > 0) 
    goto _jump119;
    fail_assertion("non-positive loop bound");
    _jump119:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= _242;
    _244 *= _243;
    _244 *= sizeof(int64_t);
    _241.data = jpl_alloc(_244);
    int64_t _245 = 0; // b
    int64_t _246 = 0; // a
    _jump120:; // Begin body of loop
    int64_t _247 = 592;
    int64_t _248 = 0;
    _248 *= _241.d0;
    _248 += _246;
    _248 *= _241.d1;
    _248 += _245;
    _241.data[_248] = _247;
    _245++;
    if (_245 < _243)
    goto _jump120;
    _245 = 0;
    _246++;
    if (_246 < _242)
    goto _jump120;
    // End body of loop
    int64_t _249;
    // Computing bound for a
    int64_t _250 = 333;
    if (_250 > 0) 
    goto _jump121;
    fail_assertion("non-positive loop bound");
    _jump121:;
    _249 = 0;
    int64_t _251 = 0; // a
    _jump122:; // Begin body of loop
    _249 += _251;
    _251++;
    if (_251 < _250)
    goto _jump122;
    // End body of loop
    int64_t _252;
    // Computing bound for a
    int64_t _253 = 825;
    int64_t _254 = -_253;
    if (_254 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    // Computing bound for b
    int64_t _255 = 27;
    int64_t _256 = 996;
    int64_t _257 = _255 % _256;
    if (_257 > 0) 
    goto _jump124;
    fail_assertion("non-positive loop bound");
    _jump124:;
    _252 = 0;
    int64_t _258 = 0; // b
    int64_t _259 = 0; // a
    _jump125:; // Begin body of loop
    bool _260 = true;
    int64_t _261;
    if (!_260)
    goto _jump126;
    _261 = _259;
    goto _jump127;
    _jump126:;
    _261 = _258;
    _jump127:;
    _252 += _261;
    _258++;
    if (_258 < _257)
    goto _jump125;
    _258 = 0;
    _259++;
    if (_259 < _254)
    goto _jump125;
    // End body of loop
    if (_249 >= 0)
    goto _jump128;
    fail_assertion("negative array index");
    _jump128:;
    if (_249 < _241.d0)
    goto _jump129;
    fail_assertion("index too large");
    _jump129:;
    if (_252 >= 0)
    goto _jump130;
    fail_assertion("negative array index");
    _jump130:;
    if (_252 < _241.d1)
    goto _jump131;
    fail_assertion("index too large");
    _jump131:;
    int64_t _262 = 0;
    _262 *= _241.d0;
    _262 += _249;
    _262 *= _241.d1;
    _262 += _252;
    int64_t _263 = _241.data[_262];
    _240 = _263;
    goto _jump132;
    _jump117:;
    int64_t _264 = 180;
    _240 = _264;
    _jump132:;
    _231 = _240;
    _jump114:;
    if (_231 >= 0)
    goto _jump133;
    fail_assertion("negative array index");
    _jump133:;
    if (_231 < _225.d0)
    goto _jump134;
    fail_assertion("index too large");
    _jump134:;
    int64_t _265 = 0;
    _265 *= _225.d0;
    _265 += _231;
    int64_t _266 = _225.data[_265];
    _161.d0 = _266;
    if (_266 > 0) 
    goto _jump135;
    fail_assertion("non-positive loop bound");
    _jump135:;
    // Computing bound for b
    int64_t _267;
    // Computing bound for a
    bool _268 = false;
    int64_t _269;
    if (!_268)
    goto _jump136;
    int64_t _270 = 439;
    int64_t _271 = -_270;
    _269 = _271;
    goto _jump137;
    _jump136:;
    int64_t _272 = 477;
    int64_t _273 = 612;
    int64_t _274 = _272 * _273;
    _269 = _274;
    _jump137:;
    int64_t _275 = -_269;
    int64_t _276 = -_275;
    int64_t _277 = -_276;
    if (_277 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    // Computing bound for b
    bool _278 = false;
    bool _279 = true;
    bool _280 = !_279;
    bool _281 = _278 != _280;
    int64_t _282;
    if (!_281)
    goto _jump139;
    int64_t _283 = 825;
    _282 = _283;
    goto _jump140;
    _jump139:;
    int64_t _284 = 420;
    _282 = _284;
    _jump140:;
    int64_t _285 = -_282;
    int64_t _286 = -_285;
    if (_286 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    // Computing bound for c
    int64_t _287 = 865;
    int64_t _288 = 905;
    int64_t _289 = _287 / _288;
    int64_t _290 = -_289;
    int64_t _291 = -_290;
    if (_291 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    _267 = 0;
    int64_t _292 = 0; // c
    int64_t _293 = 0; // b
    int64_t _294 = 0; // a
    _jump143:; // Begin body of loop
    _267 += _292;
    _292++;
    if (_292 < _291)
    goto _jump143;
    _292 = 0;
    _293++;
    if (_293 < _286)
    goto _jump143;
    _293 = 0;
    _294++;
    if (_294 < _277)
    goto _jump143;
    // End body of loop
    _161.d1 = _267;
    if (_267 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    // Computing bound for c
    int64_t _295 = 518;
    _161.d2 = _295;
    if (_295 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing total size of heap memory to allocate
    int64_t _296 = 1;
    _296 *= _266;
    _296 *= _267;
    _296 *= _295;
    _296 *= sizeof(int64_t);
    _161.data = jpl_alloc(_296);
    int64_t _297 = 0; // c
    int64_t _298 = 0; // b
    int64_t _299 = 0; // a
    _jump146:; // Begin body of loop
    int64_t _300 = 669;
    int64_t _301 = 0;
    _301 *= _161.d0;
    _301 += _299;
    _301 *= _161.d1;
    _301 += _298;
    _301 *= _161.d2;
    _301 += _297;
    _161.data[_301] = _300;
    _297++;
    if (_297 < _295)
    goto _jump146;
    _297 = 0;
    _298++;
    if (_298 < _267)
    goto _jump146;
    _298 = 0;
    _299++;
    if (_299 < _266)
    goto _jump146;
    // End body of loop
    _a2__a3_int64_t _302;
    // Computing bound for e
    _a3_bool _303;
    // Computing bound for e
    _303.d0 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump147;
    fail_assertion("non-positive loop bound");
    _jump147:;
    // Computing bound for f
    bool _304 = true;
    int64_t _305;
    if (!_304)
    goto _jump148;
    _305 = _161.d0;
    goto _jump149;
    _jump148:;
    int64_t _306 = 993;
    if (_161.d0 >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (_161.d0 < _161.d0)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    if (_161.d2 >= 0)
    goto _jump152;
    fail_assertion("negative array index");
    _jump152:;
    if (_161.d2 < _161.d1)
    goto _jump153;
    fail_assertion("index too large");
    _jump153:;
    if (_306 >= 0)
    goto _jump154;
    fail_assertion("negative array index");
    _jump154:;
    if (_306 < _161.d2)
    goto _jump155;
    fail_assertion("index too large");
    _jump155:;
    int64_t _307 = 0;
    _307 *= _161.d0;
    _307 += _161.d0;
    _307 *= _161.d1;
    _307 += _161.d2;
    _307 *= _161.d2;
    _307 += _306;
    int64_t _308 = _161.data[_307];
    _305 = _308;
    _jump149:;
    _303.d1 = _305;
    if (_305 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing bound for g
    _303.d2 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing total size of heap memory to allocate
    int64_t _309 = 1;
    _309 *= _161.d1;
    _309 *= _305;
    _309 *= _161.d0;
    _309 *= sizeof(bool);
    _303.data = jpl_alloc(_309);
    int64_t _310 = 0; // g
    int64_t _311 = 0; // f
    int64_t _312 = 0; // e
    _jump158:; // Begin body of loop
    bool _313 = false;
    int64_t _314 = 0;
    _314 *= _303.d0;
    _314 += _312;
    _314 *= _303.d1;
    _314 += _311;
    _314 *= _303.d2;
    _314 += _310;
    _303.data[_314] = _313;
    _310++;
    if (_310 < _161.d0)
    goto _jump158;
    _310 = 0;
    _311++;
    if (_311 < _305)
    goto _jump158;
    _311 = 0;
    _312++;
    if (_312 < _161.d1)
    goto _jump158;
    // End body of loop
    int64_t _315 = 669;
    int64_t _316 = -_161.d0;
    int64_t _317 = _315 + _316;
    if (_317 >= 0)
    goto _jump159;
    fail_assertion("negative array index");
    _jump159:;
    if (_317 < _303.d0)
    goto _jump160;
    fail_assertion("index too large");
    _jump160:;
    if (_161.d0 >= 0)
    goto _jump161;
    fail_assertion("negative array index");
    _jump161:;
    if (_161.d0 < _303.d1)
    goto _jump162;
    fail_assertion("index too large");
    _jump162:;
    if (_161.d1 >= 0)
    goto _jump163;
    fail_assertion("negative array index");
    _jump163:;
    if (_161.d1 < _303.d2)
    goto _jump164;
    fail_assertion("index too large");
    _jump164:;
    int64_t _318 = 0;
    _318 *= _303.d0;
    _318 += _317;
    _318 *= _303.d1;
    _318 += _161.d0;
    _318 *= _303.d2;
    _318 += _161.d1;
    bool _319 = _303.data[_318];
    int64_t _320;
    if (!_319)
    goto _jump165;
    bool _321 = true;
    int64_t _322;
    if (!_321)
    goto _jump166;
    _a1_int64_t _323;
    // Computing bound for e
    _323.d0 = _161.d2;
    if (_161.d2 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing total size of heap memory to allocate
    int64_t _324 = 1;
    _324 *= _161.d2;
    _324 *= sizeof(int64_t);
    _323.data = jpl_alloc(_324);
    int64_t _325 = 0; // e
    _jump168:; // Begin body of loop
    int64_t _326 = 0;
    _326 *= _323.d0;
    _326 += _325;
    _323.data[_326] = _325;
    _325++;
    if (_325 < _161.d2)
    goto _jump168;
    // End body of loop
    if (_161.d1 >= 0)
    goto _jump169;
    fail_assertion("negative array index");
    _jump169:;
    if (_161.d1 < _323.d0)
    goto _jump170;
    fail_assertion("index too large");
    _jump170:;
    int64_t _327 = 0;
    _327 *= _323.d0;
    _327 += _161.d1;
    int64_t _328 = _323.data[_327];
    int64_t _329 = _328 + _161.d0;
    _322 = _329;
    goto _jump171;
    _jump166:;
    int64_t _330 = 670;
    _322 = _330;
    _jump171:;
    int64_t _331;
    // Computing bound for e
    int64_t _332 = 441;
    int64_t _333 = _332 - _161.d2;
    int64_t _334 = -_333;
    if (_334 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    // Computing bound for f
    int64_t _335;
    // Computing bound for e
    if (_161.d1 > 0) 
    goto _jump173;
    fail_assertion("non-positive loop bound");
    _jump173:;
    // Computing bound for f
    if (_161.d0 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    // Computing bound for g
    int64_t _336 = _161.d1 - _161.d0;
    if (_336 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    _335 = 0;
    int64_t _337 = 0; // g
    int64_t _338 = 0; // f
    int64_t _339 = 0; // e
    _jump176:; // Begin body of loop
    _335 += _337;
    _337++;
    if (_337 < _336)
    goto _jump176;
    _337 = 0;
    _338++;
    if (_338 < _161.d0)
    goto _jump176;
    _338 = 0;
    _339++;
    if (_339 < _161.d1)
    goto _jump176;
    // End body of loop
    if (_335 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    _331 = 0;
    int64_t _340 = 0; // f
    int64_t _341 = 0; // e
    _jump178:; // Begin body of loop
    _331 += _161.d0;
    _340++;
    if (_340 < _335)
    goto _jump178;
    _340 = 0;
    _341++;
    if (_341 < _334)
    goto _jump178;
    // End body of loop
    int64_t _342 = -_331;
    if (_322 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_322 < _161.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    if (_161.d1 >= 0)
    goto _jump181;
    fail_assertion("negative array index");
    _jump181:;
    if (_161.d1 < _161.d1)
    goto _jump182;
    fail_assertion("index too large");
    _jump182:;
    if (_342 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (_342 < _161.d2)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    int64_t _343 = 0;
    _343 *= _161.d0;
    _343 += _322;
    _343 *= _161.d1;
    _343 += _161.d1;
    _343 *= _161.d2;
    _343 += _342;
    int64_t _344 = _161.data[_343];
    _320 = _344;
    goto _jump185;
    _jump165:;
    _320 = _161.d2;
    _jump185:;
    _302.d0 = _320;
    if (_320 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    // Computing bound for f
    _a2_int64_t _345;
    // Computing bound for e
    int64_t _346 = -_161.d2;
    bool _347 = _346 >= _161.d1;
    int64_t _348;
    if (!_347)
    goto _jump187;
    _348 = _161.d2;
    goto _jump188;
    _jump187:;
    _348 = _161.d0;
    _jump188:;
    _345.d0 = _348;
    if (_348 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing bound for f
    int64_t _349 = 792;
    _345.d1 = _349;
    if (_349 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing total size of heap memory to allocate
    int64_t _350 = 1;
    _350 *= _348;
    _350 *= _349;
    _350 *= sizeof(int64_t);
    _345.data = jpl_alloc(_350);
    int64_t _351 = 0; // f
    int64_t _352 = 0; // e
    _jump191:; // Begin body of loop
    int64_t _353 = 0;
    _353 *= _345.d0;
    _353 += _352;
    _353 *= _345.d1;
    _353 += _351;
    _345.data[_353] = _352;
    _351++;
    if (_351 < _349)
    goto _jump191;
    _351 = 0;
    _352++;
    if (_352 < _348)
    goto _jump191;
    // End body of loop
    bool _354 = false;
    int64_t _355;
    if (!_354)
    goto _jump192;
    _355 = _161.d0;
    goto _jump193;
    _jump192:;
    _355 = _161.d0;
    _jump193:;
    if (_161.d2 >= 0)
    goto _jump194;
    fail_assertion("negative array index");
    _jump194:;
    if (_161.d2 < _345.d0)
    goto _jump195;
    fail_assertion("index too large");
    _jump195:;
    if (_355 >= 0)
    goto _jump196;
    fail_assertion("negative array index");
    _jump196:;
    if (_355 < _345.d1)
    goto _jump197;
    fail_assertion("index too large");
    _jump197:;
    int64_t _356 = 0;
    _356 *= _345.d0;
    _356 += _161.d2;
    _356 *= _345.d1;
    _356 += _355;
    int64_t _357 = _345.data[_356];
    _302.d1 = _357;
    if (_357 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing total size of heap memory to allocate
    int64_t _358 = 1;
    _358 *= _320;
    _358 *= _357;
    _358 *= sizeof(_a3_int64_t);
    _302.data = jpl_alloc(_358);
    int64_t _359 = 0; // f
    int64_t _360 = 0; // e
    _jump199:; // Begin body of loop
    _a3_int64_t _361;
    // Computing bound for g
    _361.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing bound for h
    int64_t _362 = 83;
    _361.d1 = _362;
    if (_362 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing bound for i
    int64_t _363;
    // Computing bound for g
    int64_t _364 = 24;
    if (_364 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    // Computing bound for h
    int64_t _365 = 785;
    if (_365 > 0) 
    goto _jump203;
    fail_assertion("non-positive loop bound");
    _jump203:;
    _363 = 0;
    int64_t _366 = 0; // h
    int64_t _367 = 0; // g
    _jump204:; // Begin body of loop
    _363 += _359;
    _366++;
    if (_366 < _365)
    goto _jump204;
    _366 = 0;
    _367++;
    if (_367 < _364)
    goto _jump204;
    // End body of loop
    _361.d2 = _363;
    if (_363 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing total size of heap memory to allocate
    int64_t _368 = 1;
    _368 *= _161.d0;
    _368 *= _362;
    _368 *= _363;
    _368 *= sizeof(int64_t);
    _361.data = jpl_alloc(_368);
    int64_t _369 = 0; // i
    int64_t _370 = 0; // h
    int64_t _371 = 0; // g
    _jump206:; // Begin body of loop
    int64_t _372 = 0;
    _372 *= _361.d0;
    _372 += _371;
    _372 *= _361.d1;
    _372 += _370;
    _372 *= _361.d2;
    _372 += _369;
    _361.data[_372] = _360;
    _369++;
    if (_369 < _363)
    goto _jump206;
    _369 = 0;
    _370++;
    if (_370 < _362)
    goto _jump206;
    _370 = 0;
    _371++;
    if (_371 < _161.d0)
    goto _jump206;
    // End body of loop
    int64_t _373 = 0;
    _373 *= _302.d0;
    _373 += _360;
    _373 *= _302.d1;
    _373 += _359;
    _302.data[_373] = _361;
    _359++;
    if (_359 < _357)
    goto _jump199;
    _359 = 0;
    _360++;
    if (_360 < _320)
    goto _jump199;
    // End body of loop
    double _374;
    // Computing bound for h
    int64_t _375;
    // Computing bound for h
    if (_161.d2 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    _375 = 0;
    int64_t _376 = 0; // h
    _jump208:; // Begin body of loop
    _375 += _302.d1;
    _376++;
    if (_376 < _161.d2)
    goto _jump208;
    // End body of loop
    if (_375 > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    // Computing bound for i
    if (_302.d1 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for j
    if (_161.d0 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    _374 = 0;
    int64_t _377 = 0; // j
    int64_t _378 = 0; // i
    int64_t _379 = 0; // h
    _jump212:; // Begin body of loop
    double _380;
    // Computing bound for k
    if (_161.d1 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    _380 = 0;
    int64_t _381 = 0; // k
    _jump214:; // Begin body of loop
    double _382;
    // Computing bound for l
    if (_379 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing bound for m
    if (_379 > 0) 
    goto _jump216;
    fail_assertion("non-positive loop bound");
    _jump216:;
    _382 = 0;
    int64_t _383 = 0; // m
    int64_t _384 = 0; // l
    _jump217:; // Begin body of loop
    double _385 = 95.0;
    _382 += _385;
    _383++;
    if (_383 < _379)
    goto _jump217;
    _383 = 0;
    _384++;
    if (_384 < _379)
    goto _jump217;
    // End body of loop
    _380 += _382;
    _381++;
    if (_381 < _161.d1)
    goto _jump214;
    // End body of loop
    double _386 = -_380;
    double _387 = -_386;
    _374 += _387;
    _377++;
    if (_377 < _161.d0)
    goto _jump212;
    _377 = 0;
    _378++;
    if (_378 < _302.d1)
    goto _jump212;
    _378 = 0;
    _379++;
    if (_379 < _375)
    goto _jump212;
    // End body of loop
    bool _388 = false;
    bool _389 = !_388;
    double _390;
    if (!_389)
    goto _jump218;
    double _391 = 97.0;
    double _392 = -_391;
    _390 = _392;
    goto _jump219;
    _jump218:;
    double _393 = 69.0;
    double _394;
    // Computing bound for h
    if (_161.d2 > 0) 
    goto _jump220;
    fail_assertion("non-positive loop bound");
    _jump220:;
    // Computing bound for i
    int64_t _395 = 482;
    if (_395 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    _394 = 0;
    int64_t _396 = 0; // i
    int64_t _397 = 0; // h
    _jump222:; // Begin body of loop
    double _398 = 50.0;
    _394 += _398;
    _396++;
    if (_396 < _395)
    goto _jump222;
    _396 = 0;
    _397++;
    if (_397 < _161.d2)
    goto _jump222;
    // End body of loop
    _a1_double _399;
    // Computing bound for h
    _399.d0 = _161.d2;
    if (_161.d2 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing total size of heap memory to allocate
    int64_t _400 = 1;
    _400 *= _161.d2;
    _400 *= sizeof(double);
    _399.data = jpl_alloc(_400);
    int64_t _401 = 0; // h
    _jump224:; // Begin body of loop
    double _402 = 7.0;
    int64_t _403 = 0;
    _403 *= _399.d0;
    _403 += _401;
    _399.data[_403] = _402;
    _401++;
    if (_401 < _161.d2)
    goto _jump224;
    // End body of loop
    if (_161.d1 >= 0)
    goto _jump225;
    fail_assertion("negative array index");
    _jump225:;
    if (_161.d1 < _399.d0)
    goto _jump226;
    fail_assertion("index too large");
    _jump226:;
    int64_t _404 = 0;
    _404 *= _399.d0;
    _404 += _161.d1;
    double _405 = _399.data[_404];
    _a1_double _406;
    // Computing bound for h
    _406.d0 = _161.d2;
    if (_161.d2 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing total size of heap memory to allocate
    int64_t _407 = 1;
    _407 *= _161.d2;
    _407 *= sizeof(double);
    _406.data = jpl_alloc(_407);
    int64_t _408 = 0; // h
    _jump228:; // Begin body of loop
    double _409 = 44.0;
    int64_t _410 = 0;
    _410 *= _406.d0;
    _410 += _408;
    _406.data[_410] = _409;
    _408++;
    if (_408 < _161.d2)
    goto _jump228;
    // End body of loop
    int64_t _411 = -_161.d0;
    if (_411 >= 0)
    goto _jump229;
    fail_assertion("negative array index");
    _jump229:;
    if (_411 < _406.d0)
    goto _jump230;
    fail_assertion("index too large");
    _jump230:;
    int64_t _412 = 0;
    _412 *= _406.d0;
    _412 += _411;
    double _413 = _406.data[_412];
    rgba _414 = { _393, _394, _405, _413 };
    double _415 = _414.b;
    _390 = _415;
    _jump219:;
    bool _416 = _374 >= _390;
    _a3_bool _417;
    if (!_416)
    goto _jump231;
    int64_t _418 = 306;
    bool _419 = _161.d1 == _302.d1;
    int64_t _420;
    if (!_419)
    goto _jump232;
    int64_t _421 = 109;
    int64_t _422 = _421 / _302.d0;
    _420 = _422;
    goto _jump233;
    _jump232:;
    int64_t _423 = _161.d1 - _302.d0;
    _420 = _423;
    _jump233:;
    int64_t _424 = -_420;
    int64_t _425 = -_424;
    bool _426 = _418 > _425;
    _a3_bool _427;
    if (!_426)
    goto _jump234;
    _a3_bool _428;
    // Computing bound for h
    _428.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing bound for i
    _428.d1 = _302.d0;
    if (_302.d0 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing bound for j
    _a1_int64_t _429;
    _429.d0 = 1;
    _429.data = jpl_alloc(sizeof(int64_t) * 1);
    _429.data[0] = _302.d1;
    _a1_int64_t _430;
    // Computing bound for h
    _430.d0 = _302.d1;
    if (_302.d1 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing total size of heap memory to allocate
    int64_t _431 = 1;
    _431 *= _302.d1;
    _431 *= sizeof(int64_t);
    _430.data = jpl_alloc(_431);
    int64_t _432 = 0; // h
    _jump238:; // Begin body of loop
    int64_t _433 = 0;
    _433 *= _430.d0;
    _433 += _432;
    _430.data[_433] = _161.d2;
    _432++;
    if (_432 < _302.d1)
    goto _jump238;
    // End body of loop
    int64_t _434 = 997;
    _a1_int64_t _435;
    _435.d0 = 2;
    _435.data = jpl_alloc(sizeof(int64_t) * 2);
    _435.data[0] = _434;
    _435.data[1] = _302.d0;
    _a1__a1_int64_t _436;
    _436.d0 = 3;
    _436.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _436.data[0] = _429;
    _436.data[1] = _430;
    _436.data[2] = _435;
    if (_302.d0 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (_302.d0 < _436.d0)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    int64_t _437 = 0;
    _437 *= _436.d0;
    _437 += _302.d0;
    _a1_int64_t _438 = _436.data[_437];
    if (_161.d2 >= 0)
    goto _jump241;
    fail_assertion("negative array index");
    _jump241:;
    if (_161.d2 < _438.d0)
    goto _jump242;
    fail_assertion("index too large");
    _jump242:;
    int64_t _439 = 0;
    _439 *= _438.d0;
    _439 += _161.d2;
    int64_t _440 = _438.data[_439];
    _428.d2 = _440;
    if (_440 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    // Computing total size of heap memory to allocate
    int64_t _441 = 1;
    _441 *= _161.d0;
    _441 *= _302.d0;
    _441 *= _440;
    _441 *= sizeof(bool);
    _428.data = jpl_alloc(_441);
    int64_t _442 = 0; // j
    int64_t _443 = 0; // i
    int64_t _444 = 0; // h
    _jump244:; // Begin body of loop
    bool _445 = false;
    bool _446 = !_445;
    int64_t _447 = 0;
    _447 *= _428.d0;
    _447 += _444;
    _447 *= _428.d1;
    _447 += _443;
    _447 *= _428.d2;
    _447 += _442;
    _428.data[_447] = _446;
    _442++;
    if (_442 < _440)
    goto _jump244;
    _442 = 0;
    _443++;
    if (_443 < _302.d0)
    goto _jump244;
    _443 = 0;
    _444++;
    if (_444 < _161.d0)
    goto _jump244;
    // End body of loop
    _427 = _428;
    goto _jump245;
    _jump234:;
    _a3_bool _448;
    // Computing bound for h
    _448.d0 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing bound for i
    _a1_int64_t _449;
    // Computing bound for h
    _449.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    // Computing total size of heap memory to allocate
    int64_t _450 = 1;
    _450 *= _161.d0;
    _450 *= sizeof(int64_t);
    _449.data = jpl_alloc(_450);
    int64_t _451 = 0; // h
    _jump248:; // Begin body of loop
    int64_t _452 = -_161.d2;
    int64_t _453 = 0;
    _453 *= _449.d0;
    _453 += _451;
    _449.data[_453] = _452;
    _451++;
    if (_451 < _161.d0)
    goto _jump248;
    // End body of loop
    if (_161.d1 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (_161.d1 < _449.d0)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    int64_t _454 = 0;
    _454 *= _449.d0;
    _454 += _161.d1;
    int64_t _455 = _449.data[_454];
    _448.d1 = _455;
    if (_455 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing bound for j
    _448.d2 = _302.d0;
    if (_302.d0 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing total size of heap memory to allocate
    int64_t _456 = 1;
    _456 *= _161.d1;
    _456 *= _455;
    _456 *= _302.d0;
    _456 *= sizeof(bool);
    _448.data = jpl_alloc(_456);
    int64_t _457 = 0; // j
    int64_t _458 = 0; // i
    int64_t _459 = 0; // h
    _jump253:; // Begin body of loop
    bool _460 = true;
    int64_t _461 = 0;
    _461 *= _448.d0;
    _461 += _459;
    _461 *= _448.d1;
    _461 += _458;
    _461 *= _448.d2;
    _461 += _457;
    _448.data[_461] = _460;
    _457++;
    if (_457 < _302.d0)
    goto _jump253;
    _457 = 0;
    _458++;
    if (_458 < _455)
    goto _jump253;
    _458 = 0;
    _459++;
    if (_459 < _161.d1)
    goto _jump253;
    // End body of loop
    _427 = _448;
    _jump245:;
    _417 = _427;
    goto _jump254;
    _jump231:;
    _a3_bool _462;
    // Computing bound for h
    _462.d0 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    // Computing bound for i
    int64_t _463;
    // Computing bound for h
    int64_t _464;
    // Computing bound for h
    int64_t _465;
    // Computing bound for h
    if (_161.d1 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing bound for i
    if (_161.d1 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing bound for j
    if (_161.d1 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    _465 = 0;
    int64_t _466 = 0; // j
    int64_t _467 = 0; // i
    int64_t _468 = 0; // h
    _jump259:; // Begin body of loop
    _465 += _302.d0;
    _466++;
    if (_466 < _161.d1)
    goto _jump259;
    _466 = 0;
    _467++;
    if (_467 < _161.d1)
    goto _jump259;
    _467 = 0;
    _468++;
    if (_468 < _161.d1)
    goto _jump259;
    // End body of loop
    int64_t _469 = _161.d1 - _465;
    if (_469 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    // Computing bound for i
    if (_302.d0 > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    _464 = 0;
    int64_t _470 = 0; // i
    int64_t _471 = 0; // h
    _jump262:; // Begin body of loop
    _464 += _302.d0;
    _470++;
    if (_470 < _302.d0)
    goto _jump262;
    _470 = 0;
    _471++;
    if (_471 < _469)
    goto _jump262;
    // End body of loop
    int64_t _472 = -_464;
    if (_472 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    _463 = 0;
    int64_t _473 = 0; // h
    _jump264:; // Begin body of loop
    _463 += _302.d0;
    _473++;
    if (_473 < _472)
    goto _jump264;
    // End body of loop
    _462.d1 = _463;
    if (_463 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing bound for j
    _462.d2 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing total size of heap memory to allocate
    int64_t _474 = 1;
    _474 *= _161.d1;
    _474 *= _463;
    _474 *= _161.d0;
    _474 *= sizeof(bool);
    _462.data = jpl_alloc(_474);
    int64_t _475 = 0; // j
    int64_t _476 = 0; // i
    int64_t _477 = 0; // h
    _jump267:; // Begin body of loop
    int64_t _478 = 622;
    int64_t _479 = _478 - _302.d0;
    bool _480 = _475 == _479;
    bool _481;
    if (!_480)
    goto _jump268;
    int64_t _482 = 191;
    bool _483 = _482 >= _302.d1;
    bool _484 = !_483;
    _481 = _484;
    goto _jump269;
    _jump268:;
    bool _485 = true;
    _481 = _485;
    _jump269:;
    bool _486 = !_481;
    bool _487;
    if (!_486)
    goto _jump270;
    bool _488 = _302.d0 > _161.d2;
    bool _489 = !_488;
    bool _490 = false;
    bool _491 = true;
    _a1_bool _492;
    _492.d0 = 3;
    _492.data = jpl_alloc(sizeof(bool) * 3);
    _492.data[0] = _489;
    _492.data[1] = _490;
    _492.data[2] = _491;
    int64_t _493 = _475 % _161.d1;
    int64_t _494 = _493 / _476;
    int64_t _495 = _494 % _161.d1;
    if (_495 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_495 < _492.d0)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    int64_t _496 = 0;
    _496 *= _492.d0;
    _496 += _495;
    bool _497 = _492.data[_496];
    _487 = _497;
    goto _jump273;
    _jump270:;
    bool _498 = _302.d0 <= _475;
    bool _499 = !_498;
    bool _500;
    if (!_499)
    goto _jump274;
    bool _501 = true;
    bool _502 = !_501;
    _500 = _502;
    goto _jump275;
    _jump274:;
    int64_t _503;
    // Computing bound for k
    if (_161.d0 > 0) 
    goto _jump276;
    fail_assertion("non-positive loop bound");
    _jump276:;
    _503 = 0;
    int64_t _504 = 0; // k
    _jump277:; // Begin body of loop
    int64_t _505 = 141;
    _503 += _505;
    _504++;
    if (_504 < _161.d0)
    goto _jump277;
    // End body of loop
    bool _506 = _503 != _161.d2;
    _500 = _506;
    _jump275:;
    bool _507 = !_500;
    _487 = _507;
    _jump273:;
    int64_t _508 = 0;
    _508 *= _462.d0;
    _508 += _477;
    _508 *= _462.d1;
    _508 += _476;
    _508 *= _462.d2;
    _508 += _475;
    _462.data[_508] = _487;
    _475++;
    if (_475 < _161.d0)
    goto _jump267;
    _475 = 0;
    _476++;
    if (_476 < _463)
    goto _jump267;
    _476 = 0;
    _477++;
    if (_477 < _161.d1)
    goto _jump267;
    // End body of loop
    _417 = _462;
    _jump254:;
    _a1_bool _509;
    // Computing bound for l
    _509.d0 = _417.d1;
    if (_417.d1 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing total size of heap memory to allocate
    int64_t _510 = 1;
    _510 *= _417.d1;
    _510 *= sizeof(bool);
    _509.data = jpl_alloc(_510);
    int64_t _511 = 0; // l
    _jump279:; // Begin body of loop
    bool _512 = false;
    int64_t _513 = 0;
    _513 *= _509.d0;
    _513 += _511;
    _509.data[_513] = _512;
    _511++;
    if (_511 < _417.d1)
    goto _jump279;
    // End body of loop
    if (_417.d0 >= 0)
    goto _jump280;
    fail_assertion("negative array index");
    _jump280:;
    if (_417.d0 < _161.d0)
    goto _jump281;
    fail_assertion("index too large");
    _jump281:;
    if (_161.d0 >= 0)
    goto _jump282;
    fail_assertion("negative array index");
    _jump282:;
    if (_161.d0 < _161.d1)
    goto _jump283;
    fail_assertion("index too large");
    _jump283:;
    if (_417.d2 >= 0)
    goto _jump284;
    fail_assertion("negative array index");
    _jump284:;
    if (_417.d2 < _161.d2)
    goto _jump285;
    fail_assertion("index too large");
    _jump285:;
    int64_t _514 = 0;
    _514 *= _161.d0;
    _514 += _417.d0;
    _514 *= _161.d1;
    _514 += _161.d0;
    _514 *= _161.d2;
    _514 += _417.d2;
    int64_t _515 = _161.data[_514];
    if (_515 >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (_515 < _509.d0)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    int64_t _516 = 0;
    _516 *= _509.d0;
    _516 += _515;
    bool _517 = _509.data[_516];
    bool _518;
    if (!_517)
    goto _jump288;
    double _519 = 47.0;
    double _520 = -_519;
    double _521 = 38.0;
    double _522 = -_521;
    bool _523 = _520 != _522;
    _518 = _523;
    goto _jump289;
    _jump288:;
    bool _524 = true;
    _518 = _524;
    _jump289:;
    double _525;
    if (!_518)
    goto _jump290;
    double _526 = 36.0;
    _a1_double _527;
    _527.d0 = 1;
    _527.data = jpl_alloc(sizeof(double) * 1);
    _527.data[0] = _526;
    int64_t _528 = _161.d1 % _417.d0;
    if (_528 >= 0)
    goto _jump291;
    fail_assertion("negative array index");
    _jump291:;
    if (_528 < _527.d0)
    goto _jump292;
    fail_assertion("index too large");
    _jump292:;
    int64_t _529 = 0;
    _529 *= _527.d0;
    _529 += _528;
    double _530 = _527.data[_529];
    _525 = _530;
    goto _jump293;
    _jump290:;
    bool _531 = _161.d0 >= _302.d0;
    double _532;
    if (!_531)
    goto _jump294;
    double _533 = 35.0;
    double _534 = -_533;
    _532 = _534;
    goto _jump295;
    _jump294:;
    double _535 = 34.0;
    double _536 = 41.0;
    double _537 = _535 - _536;
    _532 = _537;
    _jump295:;
    _a3_double _538;
    // Computing bound for l
    _538.d0 = _161.d2;
    if (_161.d2 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing bound for m
    _538.d1 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump297;
    fail_assertion("non-positive loop bound");
    _jump297:;
    // Computing bound for n
    _538.d2 = _302.d0;
    if (_302.d0 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing total size of heap memory to allocate
    int64_t _539 = 1;
    _539 *= _161.d2;
    _539 *= _161.d1;
    _539 *= _302.d0;
    _539 *= sizeof(double);
    _538.data = jpl_alloc(_539);
    int64_t _540 = 0; // n
    int64_t _541 = 0; // m
    int64_t _542 = 0; // l
    _jump299:; // Begin body of loop
    double _543 = 95.0;
    int64_t _544 = 0;
    _544 *= _538.d0;
    _544 += _542;
    _544 *= _538.d1;
    _544 += _541;
    _544 *= _538.d2;
    _544 += _540;
    _538.data[_544] = _543;
    _540++;
    if (_540 < _302.d0)
    goto _jump299;
    _540 = 0;
    _541++;
    if (_541 < _161.d1)
    goto _jump299;
    _541 = 0;
    _542++;
    if (_542 < _161.d2)
    goto _jump299;
    // End body of loop
    if (_302.d0 >= 0)
    goto _jump300;
    fail_assertion("negative array index");
    _jump300:;
    if (_302.d0 < _538.d0)
    goto _jump301;
    fail_assertion("index too large");
    _jump301:;
    if (_417.d1 >= 0)
    goto _jump302;
    fail_assertion("negative array index");
    _jump302:;
    if (_417.d1 < _538.d1)
    goto _jump303;
    fail_assertion("index too large");
    _jump303:;
    if (_161.d0 >= 0)
    goto _jump304;
    fail_assertion("negative array index");
    _jump304:;
    if (_161.d0 < _538.d2)
    goto _jump305;
    fail_assertion("index too large");
    _jump305:;
    int64_t _545 = 0;
    _545 *= _538.d0;
    _545 += _302.d0;
    _545 *= _538.d1;
    _545 += _417.d1;
    _545 *= _538.d2;
    _545 += _161.d0;
    double _546 = _538.data[_545];
    double _547 = _532 + _546;
    _525 = _547;
    _jump293:;
    double _548;
    // Computing bound for l
    int64_t _549 = -_161.d1;
    if (_549 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for m
    if (_417.d1 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    _548 = 0;
    int64_t _550 = 0; // m
    int64_t _551 = 0; // l
    _jump308:; // Begin body of loop
    double _552 = 14.0;
    _548 += _552;
    _550++;
    if (_550 < _417.d1)
    goto _jump308;
    _550 = 0;
    _551++;
    if (_551 < _549)
    goto _jump308;
    // End body of loop
    double _553 = 73.0;
    bool _554 = false;
    double _555;
    if (!_554)
    goto _jump309;
    bool _556 = false;
    double _557;
    if (!_556)
    goto _jump310;
    double _558 = 99.0;
    _557 = _558;
    goto _jump311;
    _jump310:;
    double _559 = 32.0;
    _557 = _559;
    _jump311:;
    _555 = _557;
    goto _jump312;
    _jump309:;
    double _560 = 5.0;
    _555 = _560;
    _jump312:;
    double _561 = 0.0;
    double _562 = 65.0;
    double _563 = 50.0;
    double _564 = 43.0;
    rgba _565 = { _561, _562, _563, _564 };
    double _566 = _565.r;
    rgba _567 = { _548, _553, _555, _566 };
    double _568 = _567.a;
    bool _569 = _525 > _568;
    bool _570;
    if (!_569)
    goto _jump313;
    bool _571 = false;
    bool _572 = !_571;
    _570 = _572;
    goto _jump314;
    _jump313:;
    double _575 = 7.0;
    double _576;
    // Computing bound for l
    if (_302.d0 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    _576 = 0;
    int64_t _577 = 0; // l
    _jump316:; // Begin body of loop
    double _578 = 92.0;
    _576 += _578;
    _577++;
    if (_577 < _302.d0)
    goto _jump316;
    // End body of loop
    bool _579 = _575 == _576;
    bool _574 = _579;
    if (0 == _579)
    goto _jump317;
    bool _581 = false;
    bool _580 = _581;
    if (0 == _581)
    goto _jump318;
    bool _582 = false;
    _580 = _582;
    _jump318:;
    _574 = _580;
    _jump317:;
    bool _584 = false;
    bool _583 = _584;
    if (0 == _584)
    goto _jump319;
    if (_417.d1 >= 0)
    goto _jump320;
    fail_assertion("negative array index");
    _jump320:;
    if (_417.d1 < _417.d0)
    goto _jump321;
    fail_assertion("index too large");
    _jump321:;
    if (_417.d1 >= 0)
    goto _jump322;
    fail_assertion("negative array index");
    _jump322:;
    if (_417.d1 < _417.d1)
    goto _jump323;
    fail_assertion("index too large");
    _jump323:;
    if (_161.d1 >= 0)
    goto _jump324;
    fail_assertion("negative array index");
    _jump324:;
    if (_161.d1 < _417.d2)
    goto _jump325;
    fail_assertion("index too large");
    _jump325:;
    int64_t _586 = 0;
    _586 *= _417.d0;
    _586 += _417.d1;
    _586 *= _417.d1;
    _586 += _417.d1;
    _586 *= _417.d2;
    _586 += _161.d1;
    bool _587 = _417.data[_586];
    bool _585 = _587;
    if (0 == _587)
    goto _jump326;
    bool _588 = true;
    _585 = _588;
    _jump326:;
    _583 = _585;
    _jump319:;
    bool _589 = _574 == _583;
    bool _573 = _589;
    if (0 == _589)
    goto _jump327;
    bool _590 = true;
    bool _591;
    if (!_590)
    goto _jump328;
    _a2_int64_t _592;
    // Computing bound for l
    _592.d0 = _417.d1;
    if (_417.d1 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for m
    _592.d1 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing total size of heap memory to allocate
    int64_t _593 = 1;
    _593 *= _417.d1;
    _593 *= _161.d1;
    _593 *= sizeof(int64_t);
    _592.data = jpl_alloc(_593);
    int64_t _594 = 0; // m
    int64_t _595 = 0; // l
    _jump331:; // Begin body of loop
    int64_t _596 = 0;
    _596 *= _592.d0;
    _596 += _595;
    _596 *= _592.d1;
    _596 += _594;
    _592.data[_596] = _302.d0;
    _594++;
    if (_594 < _161.d1)
    goto _jump331;
    _594 = 0;
    _595++;
    if (_595 < _417.d1)
    goto _jump331;
    // End body of loop
    int64_t _597 = 90;
    int64_t _598 = -_597;
    if (_417.d2 >= 0)
    goto _jump332;
    fail_assertion("negative array index");
    _jump332:;
    if (_417.d2 < _592.d0)
    goto _jump333;
    fail_assertion("index too large");
    _jump333:;
    if (_598 >= 0)
    goto _jump334;
    fail_assertion("negative array index");
    _jump334:;
    if (_598 < _592.d1)
    goto _jump335;
    fail_assertion("index too large");
    _jump335:;
    int64_t _599 = 0;
    _599 *= _592.d0;
    _599 += _417.d2;
    _599 *= _592.d1;
    _599 += _598;
    int64_t _600 = _592.data[_599];
    bool _601 = _161.d1 == _600;
    _591 = _601;
    goto _jump336;
    _jump328:;
    bool _602 = _161.d0 == _417.d0;
    bool _603 = true;
    bool _604 = _602 != _603;
    bool _605 = !_604;
    _591 = _605;
    _jump336:;
    _573 = _591;
    _jump327:;
    _570 = _573;
    _jump314:;
    _a1_bool _606;
    if (!_570)
    goto _jump337;
    _a1_bool _607;
    // Computing bound for l
    _607.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing total size of heap memory to allocate
    int64_t _608 = 1;
    _608 *= _161.d0;
    _608 *= sizeof(bool);
    _607.data = jpl_alloc(_608);
    int64_t _609 = 0; // l
    _jump339:; // Begin body of loop
    double _610 = 71.0;
    double _611 = 56.0;
    _a2_double _612;
    // Computing bound for m
    _612.d0 = _417.d2;
    if (_417.d2 > 0) 
    goto _jump340;
    fail_assertion("non-positive loop bound");
    _jump340:;
    // Computing bound for n
    _612.d1 = _417.d1;
    if (_417.d1 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    // Computing total size of heap memory to allocate
    int64_t _613 = 1;
    _613 *= _417.d2;
    _613 *= _417.d1;
    _613 *= sizeof(double);
    _612.data = jpl_alloc(_613);
    int64_t _614 = 0; // n
    int64_t _615 = 0; // m
    _jump342:; // Begin body of loop
    double _616 = 37.0;
    int64_t _617 = 0;
    _617 *= _612.d0;
    _617 += _615;
    _617 *= _612.d1;
    _617 += _614;
    _612.data[_617] = _616;
    _614++;
    if (_614 < _417.d1)
    goto _jump342;
    _614 = 0;
    _615++;
    if (_615 < _417.d2)
    goto _jump342;
    // End body of loop
    int64_t _618 = _161.d1 / _609;
    if (_161.d0 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (_161.d0 < _612.d0)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (_618 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (_618 < _612.d1)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _619 = 0;
    _619 *= _612.d0;
    _619 += _161.d0;
    _619 *= _612.d1;
    _619 += _618;
    double _620 = _612.data[_619];
    double _621 = -_620;
    double _622 = _611 * _621;
    bool _623 = _610 != _622;
    int64_t _624 = 0;
    _624 *= _607.d0;
    _624 += _609;
    _607.data[_624] = _623;
    _609++;
    if (_609 < _161.d0)
    goto _jump339;
    // End body of loop
    _606 = _607;
    goto _jump347;
    _jump337:;
    bool _625 = true;
    bool _626 = !_625;
    bool _627 = !_626;
    bool _628;
    if (!_627)
    goto _jump348;
    bool _629 = false;
    _628 = _629;
    goto _jump349;
    _jump348:;
    int64_t _630 = -_417.d0;
    if (_161.d0 >= 0)
    goto _jump350;
    fail_assertion("negative array index");
    _jump350:;
    if (_161.d0 < _161.d0)
    goto _jump351;
    fail_assertion("index too large");
    _jump351:;
    if (_417.d2 >= 0)
    goto _jump352;
    fail_assertion("negative array index");
    _jump352:;
    if (_417.d2 < _161.d1)
    goto _jump353;
    fail_assertion("index too large");
    _jump353:;
    if (_417.d1 >= 0)
    goto _jump354;
    fail_assertion("negative array index");
    _jump354:;
    if (_417.d1 < _161.d2)
    goto _jump355;
    fail_assertion("index too large");
    _jump355:;
    int64_t _631 = 0;
    _631 *= _161.d0;
    _631 += _161.d0;
    _631 *= _161.d1;
    _631 += _417.d2;
    _631 *= _161.d2;
    _631 += _417.d1;
    int64_t _632 = _161.data[_631];
    bool _633 = _630 >= _632;
    _628 = _633;
    _jump349:;
    bool _634 = !_628;
    bool _635;
    if (!_634)
    goto _jump356;
    int64_t _636 = -_417.d1;
    bool _637 = _636 < _161.d1;
    _635 = _637;
    goto _jump357;
    _jump356:;
    bool _638 = true;
    bool _639 = !_638;
    _a1_bool _640;
    _640.d0 = 1;
    _640.data = jpl_alloc(sizeof(bool) * 1);
    _640.data[0] = _639;
    if (_161.d0 >= 0)
    goto _jump358;
    fail_assertion("negative array index");
    _jump358:;
    if (_161.d0 < _640.d0)
    goto _jump359;
    fail_assertion("index too large");
    _jump359:;
    int64_t _641 = 0;
    _641 *= _640.d0;
    _641 += _161.d0;
    bool _642 = _640.data[_641];
    bool _643;
    if (!_642)
    goto _jump360;
    bool _644 = true;
    _643 = _644;
    goto _jump361;
    _jump360:;
    bool _646 = false;
    bool _645 = _646;
    if (0 != _646)
    goto _jump362;
    bool _648 = false;
    bool _647 = _648;
    if (0 == _648)
    goto _jump363;
    bool _649 = false;
    _647 = _649;
    _jump363:;
    _645 = _647;
    _jump362:;
    _643 = _645;
    _jump361:;
    _635 = _643;
    _jump357:;
    _a1_bool _650;
    if (!_635)
    goto _jump364;
    bool _652 = false;
    int64_t _653;
    if (!_652)
    goto _jump365;
    _653 = _417.d0;
    goto _jump366;
    _jump365:;
    _653 = _161.d2;
    _jump366:;
    int64_t _654;
    // Computing bound for l
    if (_161.d0 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing bound for m
    if (_417.d2 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    _654 = 0;
    int64_t _655 = 0; // m
    int64_t _656 = 0; // l
    _jump369:; // Begin body of loop
    _654 += _302.d1;
    _655++;
    if (_655 < _417.d2)
    goto _jump369;
    _655 = 0;
    _656++;
    if (_656 < _161.d0)
    goto _jump369;
    // End body of loop
    bool _657 = _653 == _654;
    bool _651 = _657;
    if (0 == _657)
    goto _jump370;
    bool _658 = _161.d1 <= _417.d1;
    _651 = _658;
    _jump370:;
    bool _659 = !_651;
    _a1_bool _660;
    if (!_659)
    goto _jump371;
    _a1_bool _661;
    // Computing bound for l
    bool _662 = false;
    bool _663 = !_662;
    bool _664 = !_663;
    int64_t _665;
    if (!_664)
    goto _jump372;
    int64_t _666 = 467;
    _665 = _666;
    goto _jump373;
    _jump372:;
    bool _667 = true;
    int64_t _668;
    if (!_667)
    goto _jump374;
    _668 = _417.d2;
    goto _jump375;
    _jump374:;
    _668 = _417.d1;
    _jump375:;
    _665 = _668;
    _jump373:;
    _661.d0 = _665;
    if (_665 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing total size of heap memory to allocate
    int64_t _669 = 1;
    _669 *= _665;
    _669 *= sizeof(bool);
    _661.data = jpl_alloc(_669);
    int64_t _670 = 0; // l
    _jump377:; // Begin body of loop
    int64_t _671;
    // Computing bound for m
    if (_161.d1 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing bound for n
    if (_302.d0 > 0) 
    goto _jump379;
    fail_assertion("non-positive loop bound");
    _jump379:;
    _671 = 0;
    int64_t _672 = 0; // n
    int64_t _673 = 0; // m
    _jump380:; // Begin body of loop
    _671 += _670;
    _672++;
    if (_672 < _302.d0)
    goto _jump380;
    _672 = 0;
    _673++;
    if (_673 < _161.d1)
    goto _jump380;
    // End body of loop
    int64_t _674 = _671 % _417.d0;
    bool _675 = _674 < _670;
    int64_t _676 = 0;
    _676 *= _661.d0;
    _676 += _670;
    _661.data[_676] = _675;
    _670++;
    if (_670 < _665)
    goto _jump377;
    // End body of loop
    _660 = _661;
    goto _jump381;
    _jump371:;
    _a1_bool _677;
    // Computing bound for l
    int64_t _678;
    // Computing bound for l
    int64_t _679 = 181;
    if (_679 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for m
    if (_417.d1 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing bound for n
    if (_161.d2 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    _678 = 0;
    int64_t _680 = 0; // n
    int64_t _681 = 0; // m
    int64_t _682 = 0; // l
    _jump385:; // Begin body of loop
    _678 += _417.d0;
    _680++;
    if (_680 < _161.d2)
    goto _jump385;
    _680 = 0;
    _681++;
    if (_681 < _417.d1)
    goto _jump385;
    _681 = 0;
    _682++;
    if (_682 < _679)
    goto _jump385;
    // End body of loop
    _677.d0 = _678;
    if (_678 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing total size of heap memory to allocate
    int64_t _683 = 1;
    _683 *= _678;
    _683 *= sizeof(bool);
    _677.data = jpl_alloc(_683);
    int64_t _684 = 0; // l
    _jump387:; // Begin body of loop
    bool _686 = true;
    bool _685 = _686;
    if (0 == _686)
    goto _jump388;
    bool _687 = true;
    bool _688 = !_687;
    bool _689;
    if (!_688)
    goto _jump389;
    bool _690 = true;
    _689 = _690;
    goto _jump390;
    _jump389:;
    bool _691 = _302.d1 >= _417.d2;
    _689 = _691;
    _jump390:;
    _685 = _689;
    _jump388:;
    int64_t _692 = 0;
    _692 *= _677.d0;
    _692 += _684;
    _677.data[_692] = _685;
    _684++;
    if (_684 < _678)
    goto _jump387;
    // End body of loop
    _660 = _677;
    _jump381:;
    _650 = _660;
    goto _jump391;
    _jump364:;
    _a1_bool _693;
    // Computing bound for l
    _693.d0 = _302.d1;
    if (_302.d1 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing total size of heap memory to allocate
    int64_t _694 = 1;
    _694 *= _302.d1;
    _694 *= sizeof(bool);
    _693.data = jpl_alloc(_694);
    int64_t _695 = 0; // l
    _jump393:; // Begin body of loop
    bool _697 = true;
    bool _698;
    if (!_697)
    goto _jump394;
    bool _699 = false;
    bool _700 = !_699;
    bool _701 = !_700;
    _698 = _701;
    goto _jump395;
    _jump394:;
    bool _702 = _417.d1 < _302.d1;
    int64_t _703 = 20;
    bool _704 = _417.d0 < _703;
    bool _705 = _702 != _704;
    _698 = _705;
    _jump395:;
    bool _696 = _698;
    if (0 != _698)
    goto _jump396;
    int64_t _706;
    // Computing bound for m
    if (_417.d1 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing bound for n
    if (_161.d2 > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    // Computing bound for o
    if (_302.d1 > 0) 
    goto _jump399;
    fail_assertion("non-positive loop bound");
    _jump399:;
    _706 = 0;
    int64_t _707 = 0; // o
    int64_t _708 = 0; // n
    int64_t _709 = 0; // m
    _jump400:; // Begin body of loop
    _706 += _707;
    _707++;
    if (_707 < _302.d1)
    goto _jump400;
    _707 = 0;
    _708++;
    if (_708 < _161.d2)
    goto _jump400;
    _708 = 0;
    _709++;
    if (_709 < _417.d1)
    goto _jump400;
    // End body of loop
    if (_706 >= 0)
    goto _jump401;
    fail_assertion("negative array index");
    _jump401:;
    if (_706 < _417.d0)
    goto _jump402;
    fail_assertion("index too large");
    _jump402:;
    if (_302.d0 >= 0)
    goto _jump403;
    fail_assertion("negative array index");
    _jump403:;
    if (_302.d0 < _417.d1)
    goto _jump404;
    fail_assertion("index too large");
    _jump404:;
    if (_161.d2 >= 0)
    goto _jump405;
    fail_assertion("negative array index");
    _jump405:;
    if (_161.d2 < _417.d2)
    goto _jump406;
    fail_assertion("index too large");
    _jump406:;
    int64_t _710 = 0;
    _710 *= _417.d0;
    _710 += _706;
    _710 *= _417.d1;
    _710 += _302.d0;
    _710 *= _417.d2;
    _710 += _161.d2;
    bool _711 = _417.data[_710];
    int64_t _712 = -_417.d0;
    bool _713 = _712 != _417.d1;
    bool _714 = _711 == _713;
    _696 = _714;
    _jump396:;
    int64_t _715 = 0;
    _715 *= _693.d0;
    _715 += _695;
    _693.data[_715] = _696;
    _695++;
    if (_695 < _302.d1)
    goto _jump393;
    // End body of loop
    _650 = _693;
    _jump391:;
    _606 = _650;
    _jump347:;
    double _716 = get_time();
    double _717 = get_time();
    print_time(_717 - _716);
    int64_t _718 = 139;
    show("(IntType)", &_302.d1);
    _a1__a2_rgba _719;
    // Computing bound for s
    _719.d0 = _302.d1;
    if (_302.d1 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    // Computing total size of heap memory to allocate
    int64_t _720 = 1;
    _720 *= _302.d1;
    _720 *= sizeof(_a2_rgba);
    _719.data = jpl_alloc(_720);
    int64_t _721 = 0; // s
    _jump432:; // Begin body of loop
    _a2_rgba _722;
    // Computing bound for t
    _722.d0 = _417.d0;
    if (_417.d0 > 0) 
    goto _jump433;
    fail_assertion("non-positive loop bound");
    _jump433:;
    // Computing bound for u
    _722.d1 = _302.d1;
    if (_302.d1 > 0) 
    goto _jump434;
    fail_assertion("non-positive loop bound");
    _jump434:;
    // Computing total size of heap memory to allocate
    int64_t _723 = 1;
    _723 *= _417.d0;
    _723 *= _302.d1;
    _723 *= sizeof(rgba);
    _722.data = jpl_alloc(_723);
    int64_t _724 = 0; // u
    int64_t _725 = 0; // t
    _jump435:; // Begin body of loop
    _a2_double _726;
    // Computing bound for v
    _726.d0 = _718;
    if (_718 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing bound for w
    _726.d1 = _161.d2;
    if (_161.d2 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _727 = 1;
    _727 *= _718;
    _727 *= _161.d2;
    _727 *= sizeof(double);
    _726.data = jpl_alloc(_727);
    int64_t _728 = 0; // w
    int64_t _729 = 0; // v
    _jump438:; // Begin body of loop
    double _730 = 61.0;
    int64_t _731 = 0;
    _731 *= _726.d0;
    _731 += _729;
    _731 *= _726.d1;
    _731 += _728;
    _726.data[_731] = _730;
    _728++;
    if (_728 < _161.d2)
    goto _jump438;
    _728 = 0;
    _729++;
    if (_729 < _718)
    goto _jump438;
    // End body of loop
    int64_t _732 = _417.d2 / _417.d2;
    int64_t _733 = _732 * _417.d1;
    _a1_int64_t _734;
    _734.d0 = 2;
    _734.data = jpl_alloc(sizeof(int64_t) * 2);
    _734.data[0] = _721;
    _734.data[1] = _724;
    if (_417.d0 >= 0)
    goto _jump439;
    fail_assertion("negative array index");
    _jump439:;
    if (_417.d0 < _734.d0)
    goto _jump440;
    fail_assertion("index too large");
    _jump440:;
    int64_t _735 = 0;
    _735 *= _734.d0;
    _735 += _417.d0;
    int64_t _736 = _734.data[_735];
    if (_733 >= 0)
    goto _jump441;
    fail_assertion("negative array index");
    _jump441:;
    if (_733 < _726.d0)
    goto _jump442;
    fail_assertion("index too large");
    _jump442:;
    if (_736 >= 0)
    goto _jump443;
    fail_assertion("negative array index");
    _jump443:;
    if (_736 < _726.d1)
    goto _jump444;
    fail_assertion("index too large");
    _jump444:;
    int64_t _737 = 0;
    _737 *= _726.d0;
    _737 += _733;
    _737 *= _726.d1;
    _737 += _736;
    double _738 = _726.data[_737];
    double _739 = 82.0;
    double _740 = -_739;
    double _741 = 33.0;
    double _742 = _740 / _741;
    double _743;
    // Computing bound for v
    if (_161.d2 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    // Computing bound for w
    if (_161.d2 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing bound for x
    if (_721 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    _743 = 0;
    int64_t _744 = 0; // x
    int64_t _745 = 0; // w
    int64_t _746 = 0; // v
    _jump448:; // Begin body of loop
    double _747 = 36.0;
    _743 += _747;
    _744++;
    if (_744 < _721)
    goto _jump448;
    _744 = 0;
    _745++;
    if (_745 < _161.d2)
    goto _jump448;
    _745 = 0;
    _746++;
    if (_746 < _161.d2)
    goto _jump448;
    // End body of loop
    double _748 = 31.0;
    rgba _749 = { _738, _742, _743, _748 };
    int64_t _750 = 0;
    _750 *= _722.d0;
    _750 += _725;
    _750 *= _722.d1;
    _750 += _724;
    _722.data[_750] = _749;
    _724++;
    if (_724 < _302.d1)
    goto _jump435;
    _724 = 0;
    _725++;
    if (_725 < _417.d0)
    goto _jump435;
    // End body of loop
    int64_t _751 = 0;
    _751 *= _719.d0;
    _751 += _721;
    _719.data[_751] = _722;
    _721++;
    if (_721 < _302.d1)
    goto _jump432;
    // End body of loop
    int64_t _752 = -_417.d2;
    if (_752 >= 0)
    goto _jump449;
    fail_assertion("negative array index");
    _jump449:;
    if (_752 < _719.d0)
    goto _jump450;
    fail_assertion("index too large");
    _jump450:;
    int64_t _753 = 0;
    _753 *= _719.d0;
    _753 += _752;
    _a2_rgba _754 = _719.data[_753];
    write_image(_754, "s.png");
    if (_417.d0 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (_417.d0 < _302.d0)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    if (_417.d0 >= 0)
    goto _jump453;
    fail_assertion("negative array index");
    _jump453:;
    if (_417.d0 < _302.d1)
    goto _jump454;
    fail_assertion("index too large");
    _jump454:;
    int64_t _755 = 0;
    _755 *= _302.d0;
    _755 += _417.d0;
    _755 *= _302.d1;
    _755 += _417.d0;
    _a3_int64_t _756 = _302.data[_755];
    _a3_r _757;
    // Computing bound for x
    _a3__a3_int64_t _758;
    // Computing bound for x
    int64_t _759 = _417.d1 * _417.d0;
    _758.d0 = _759;
    if (_759 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for y
    _758.d1 = _756.d1;
    if (_756.d1 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing bound for z
    int64_t _760 = 260;
    _758.d2 = _760;
    if (_760 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    // Computing total size of heap memory to allocate
    int64_t _761 = 1;
    _761 *= _759;
    _761 *= _756.d1;
    _761 *= _760;
    _761 *= sizeof(_a3_int64_t);
    _758.data = jpl_alloc(_761);
    int64_t _762 = 0; // z
    int64_t _763 = 0; // y
    int64_t _764 = 0; // x
    _jump458:; // Begin body of loop
    _a3_int64_t _765;
    // Computing bound for A
    int64_t _766 = 633;
    _765.d0 = _766;
    if (_766 > 0) 
    goto _jump459;
    fail_assertion("non-positive loop bound");
    _jump459:;
    // Computing bound for B
    _765.d1 = _718;
    if (_718 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing bound for C
    _765.d2 = _606.d0;
    if (_606.d0 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing total size of heap memory to allocate
    int64_t _767 = 1;
    _767 *= _766;
    _767 *= _718;
    _767 *= _606.d0;
    _767 *= sizeof(int64_t);
    _765.data = jpl_alloc(_767);
    int64_t _768 = 0; // C
    int64_t _769 = 0; // B
    int64_t _770 = 0; // A
    _jump462:; // Begin body of loop
    int64_t _771 = 0;
    _771 *= _765.d0;
    _771 += _770;
    _771 *= _765.d1;
    _771 += _769;
    _771 *= _765.d2;
    _771 += _768;
    _765.data[_771] = _417.d0;
    _768++;
    if (_768 < _606.d0)
    goto _jump462;
    _768 = 0;
    _769++;
    if (_769 < _718)
    goto _jump462;
    _769 = 0;
    _770++;
    if (_770 < _766)
    goto _jump462;
    // End body of loop
    int64_t _772 = 0;
    _772 *= _758.d0;
    _772 += _764;
    _772 *= _758.d1;
    _772 += _763;
    _772 *= _758.d2;
    _772 += _762;
    _758.data[_772] = _765;
    _762++;
    if (_762 < _760)
    goto _jump458;
    _762 = 0;
    _763++;
    if (_763 < _756.d1)
    goto _jump458;
    _763 = 0;
    _764++;
    if (_764 < _759)
    goto _jump458;
    // End body of loop
    if (_161.d2 >= 0)
    goto _jump463;
    fail_assertion("negative array index");
    _jump463:;
    if (_161.d2 < _758.d0)
    goto _jump464;
    fail_assertion("index too large");
    _jump464:;
    if (_756.d2 >= 0)
    goto _jump465;
    fail_assertion("negative array index");
    _jump465:;
    if (_756.d2 < _758.d1)
    goto _jump466;
    fail_assertion("index too large");
    _jump466:;
    if (_756.d1 >= 0)
    goto _jump467;
    fail_assertion("negative array index");
    _jump467:;
    if (_756.d1 < _758.d2)
    goto _jump468;
    fail_assertion("index too large");
    _jump468:;
    int64_t _773 = 0;
    _773 *= _758.d0;
    _773 += _161.d2;
    _773 *= _758.d1;
    _773 += _756.d2;
    _773 *= _758.d2;
    _773 += _756.d1;
    _a3_int64_t _774 = _758.data[_773];
    bool _776 = _417.d2 < _606.d0;
    bool _775 = _776;
    if (0 != _776)
    goto _jump469;
    bool _777 = true;
    bool _778 = !_777;
    _775 = _778;
    _jump469:;
    int64_t _779;
    if (!_775)
    goto _jump470;
    int64_t _780 = 125;
    _779 = _780;
    goto _jump471;
    _jump470:;
    _779 = _718;
    _jump471:;
    _a2_int64_t _781;
    // Computing bound for x
    _781.d0 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for y
    int64_t _782 = 559;
    int64_t _783 = n();
    if (_782 >= 0)
    goto _jump473;
    fail_assertion("negative array index");
    _jump473:;
    if (_782 < _756.d0)
    goto _jump474;
    fail_assertion("index too large");
    _jump474:;
    if (_783 >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (_783 < _756.d1)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    if (_417.d1 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_417.d1 < _756.d2)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    int64_t _784 = 0;
    _784 *= _756.d0;
    _784 += _782;
    _784 *= _756.d1;
    _784 += _783;
    _784 *= _756.d2;
    _784 += _417.d1;
    int64_t _785 = _756.data[_784];
    _781.d1 = _785;
    if (_785 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing total size of heap memory to allocate
    int64_t _786 = 1;
    _786 *= _161.d1;
    _786 *= _785;
    _786 *= sizeof(int64_t);
    _781.data = jpl_alloc(_786);
    int64_t _787 = 0; // y
    int64_t _788 = 0; // x
    _jump480:; // Begin body of loop
    int64_t _789 = 0;
    _789 *= _781.d0;
    _789 += _788;
    _789 *= _781.d1;
    _789 += _787;
    _781.data[_789] = _756.d2;
    _787++;
    if (_787 < _785)
    goto _jump480;
    _787 = 0;
    _788++;
    if (_788 < _161.d1)
    goto _jump480;
    // End body of loop
    if (_302.d0 >= 0)
    goto _jump481;
    fail_assertion("negative array index");
    _jump481:;
    if (_302.d0 < _781.d0)
    goto _jump482;
    fail_assertion("index too large");
    _jump482:;
    if (_756.d0 >= 0)
    goto _jump483;
    fail_assertion("negative array index");
    _jump483:;
    if (_756.d0 < _781.d1)
    goto _jump484;
    fail_assertion("index too large");
    _jump484:;
    int64_t _790 = 0;
    _790 *= _781.d0;
    _790 += _302.d0;
    _790 *= _781.d1;
    _790 += _756.d0;
    int64_t _791 = _781.data[_790];
    if (_779 >= 0)
    goto _jump485;
    fail_assertion("negative array index");
    _jump485:;
    if (_779 < _774.d0)
    goto _jump486;
    fail_assertion("index too large");
    _jump486:;
    if (_417.d0 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_417.d0 < _774.d1)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (_791 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_791 < _774.d2)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _792 = 0;
    _792 *= _774.d0;
    _792 += _779;
    _792 *= _774.d1;
    _792 += _417.d0;
    _792 *= _774.d2;
    _792 += _791;
    int64_t _793 = _774.data[_792];
    _757.d0 = _793;
    if (_793 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for y
    bool _794 = false;
    bool _796 = false;
    bool _795 = _796;
    if (0 != _796)
    goto _jump492;
    bool _797 = true;
    _795 = _797;
    _jump492:;
    bool _798 = _794 == _795;
    int64_t _799;
    if (!_798)
    goto _jump493;
    _a1_int64_t _800;
    _800.d0 = 3;
    _800.data = jpl_alloc(sizeof(int64_t) * 3);
    _800.data[0] = _606.d0;
    _800.data[1] = _756.d2;
    _800.data[2] = _756.d2;
    int64_t _801 = 188;
    if (_801 >= 0)
    goto _jump494;
    fail_assertion("negative array index");
    _jump494:;
    if (_801 < _800.d0)
    goto _jump495;
    fail_assertion("index too large");
    _jump495:;
    int64_t _802 = 0;
    _802 *= _800.d0;
    _802 += _801;
    int64_t _803 = _800.data[_802];
    _799 = _803;
    goto _jump496;
    _jump493:;
    _799 = _417.d1;
    _jump496:;
    _757.d1 = _799;
    if (_799 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing bound for z
    int64_t _804;
    // Computing bound for x
    _a1_int64_t _805;
    // Computing bound for x
    _805.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing total size of heap memory to allocate
    int64_t _806 = 1;
    _806 *= _161.d0;
    _806 *= sizeof(int64_t);
    _805.data = jpl_alloc(_806);
    int64_t _807 = 0; // x
    _jump499:; // Begin body of loop
    int64_t _808 = 0;
    _808 *= _805.d0;
    _808 += _807;
    _805.data[_808] = _756.d1;
    _807++;
    if (_807 < _161.d0)
    goto _jump499;
    // End body of loop
    if (_161.d1 >= 0)
    goto _jump500;
    fail_assertion("negative array index");
    _jump500:;
    if (_161.d1 < _805.d0)
    goto _jump501;
    fail_assertion("index too large");
    _jump501:;
    int64_t _809 = 0;
    _809 *= _805.d0;
    _809 += _161.d1;
    int64_t _810 = _805.data[_809];
    if (_810 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    _804 = 0;
    int64_t _811 = 0; // x
    _jump503:; // Begin body of loop
    _804 += _417.d1;
    _811++;
    if (_811 < _810)
    goto _jump503;
    // End body of loop
    bool _812 = false;
    bool _813 = !_812;
    _a1_int64_t _814;
    if (!_813)
    goto _jump504;
    _a1_int64_t _815;
    _815.d0 = 1;
    _815.data = jpl_alloc(sizeof(int64_t) * 1);
    _815.data[0] = _161.d0;
    _814 = _815;
    goto _jump505;
    _jump504:;
    _a1_int64_t _816;
    _816.d0 = 3;
    _816.data = jpl_alloc(sizeof(int64_t) * 3);
    _816.data[0] = _417.d0;
    _816.data[1] = _756.d2;
    _816.data[2] = _417.d0;
    _814 = _816;
    _jump505:;
    if (_302.d0 >= 0)
    goto _jump506;
    fail_assertion("negative array index");
    _jump506:;
    if (_302.d0 < _814.d0)
    goto _jump507;
    fail_assertion("index too large");
    _jump507:;
    int64_t _817 = 0;
    _817 *= _814.d0;
    _817 += _302.d0;
    int64_t _818 = _814.data[_817];
    if (_804 >= 0)
    goto _jump508;
    fail_assertion("negative array index");
    _jump508:;
    if (_804 < _756.d0)
    goto _jump509;
    fail_assertion("index too large");
    _jump509:;
    if (_161.d2 >= 0)
    goto _jump510;
    fail_assertion("negative array index");
    _jump510:;
    if (_161.d2 < _756.d1)
    goto _jump511;
    fail_assertion("index too large");
    _jump511:;
    if (_818 >= 0)
    goto _jump512;
    fail_assertion("negative array index");
    _jump512:;
    if (_818 < _756.d2)
    goto _jump513;
    fail_assertion("index too large");
    _jump513:;
    int64_t _819 = 0;
    _819 *= _756.d0;
    _819 += _804;
    _819 *= _756.d1;
    _819 += _161.d2;
    _819 *= _756.d2;
    _819 += _818;
    int64_t _820 = _756.data[_819];
    _757.d2 = _820;
    if (_820 > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing total size of heap memory to allocate
    int64_t _821 = 1;
    _821 *= _793;
    _821 *= _799;
    _821 *= _820;
    _821 *= sizeof(r);
    _757.data = jpl_alloc(_821);
    int64_t _822 = 0; // z
    int64_t _823 = 0; // y
    int64_t _824 = 0; // x
    _jump515:; // Begin body of loop
    double _825 = 13.0;
    double _826;
    // Computing bound for A
    if (_823 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for B
    if (_161.d1 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for C
    if (_161.d2 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    _826 = 0;
    int64_t _827 = 0; // C
    int64_t _828 = 0; // B
    int64_t _829 = 0; // A
    _jump519:; // Begin body of loop
    double _830 = 19.0;
    _826 += _830;
    _827++;
    if (_827 < _161.d2)
    goto _jump519;
    _827 = 0;
    _828++;
    if (_828 < _161.d1)
    goto _jump519;
    _828 = 0;
    _829++;
    if (_829 < _823)
    goto _jump519;
    // End body of loop
    double _831 = _825 * _826;
    double _832 = 48.0;
    bool _833 = _831 != _832;
    _a1__a2_double _834;
    // Computing bound for A
    _834.d0 = _822;
    if (_822 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing total size of heap memory to allocate
    int64_t _835 = 1;
    _835 *= _822;
    _835 *= sizeof(_a2_double);
    _834.data = jpl_alloc(_835);
    int64_t _836 = 0; // A
    _jump521:; // Begin body of loop
    _a2_double _837;
    // Computing bound for B
    _837.d0 = _417.d2;
    if (_417.d2 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for C
    _837.d1 = _606.d0;
    if (_606.d0 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing total size of heap memory to allocate
    int64_t _838 = 1;
    _838 *= _417.d2;
    _838 *= _606.d0;
    _838 *= sizeof(double);
    _837.data = jpl_alloc(_838);
    int64_t _839 = 0; // C
    int64_t _840 = 0; // B
    _jump524:; // Begin body of loop
    double _841 = 6.0;
    int64_t _842 = 0;
    _842 *= _837.d0;
    _842 += _840;
    _842 *= _837.d1;
    _842 += _839;
    _837.data[_842] = _841;
    _839++;
    if (_839 < _606.d0)
    goto _jump524;
    _839 = 0;
    _840++;
    if (_840 < _417.d2)
    goto _jump524;
    // End body of loop
    int64_t _843 = 0;
    _843 *= _834.d0;
    _843 += _836;
    _834.data[_843] = _837;
    _836++;
    if (_836 < _822)
    goto _jump521;
    // End body of loop
    r _844 = { _833, _834 };
    int64_t _845 = 0;
    _845 *= _757.d0;
    _845 += _824;
    _845 *= _757.d1;
    _845 += _823;
    _845 *= _757.d2;
    _845 += _822;
    _757.data[_845] = _844;
    _822++;
    if (_822 < _820)
    goto _jump515;
    _822 = 0;
    _823++;
    if (_823 < _799)
    goto _jump515;
    _823 = 0;
    _824++;
    if (_824 < _793)
    goto _jump515;
    // End body of loop
    if (_302.d1 >= 0)
    goto _jump525;
    fail_assertion("negative array index");
    _jump525:;
    if (_302.d1 < _757.d0)
    goto _jump526;
    fail_assertion("index too large");
    _jump526:;
    if (_161.d2 >= 0)
    goto _jump527;
    fail_assertion("negative array index");
    _jump527:;
    if (_161.d2 < _757.d1)
    goto _jump528;
    fail_assertion("index too large");
    _jump528:;
    if (_417.d2 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (_417.d2 < _757.d2)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    int64_t _846 = 0;
    _846 *= _757.d0;
    _846 += _302.d1;
    _846 *= _757.d1;
    _846 += _161.d2;
    _846 *= _757.d2;
    _846 += _417.d2;
    r _847 = _757.data[_846];
    bool _848 = _847.a;
    if (0 != _848)
    goto _jump531;
    fail_assertion("x");
    _jump531:;
    _a1__a3_int64_t _849;
    // Computing bound for x
    _849.d0 = _756.d2;
    if (_756.d2 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing total size of heap memory to allocate
    int64_t _850 = 1;
    _850 *= _756.d2;
    _850 *= sizeof(_a3_int64_t);
    _849.data = jpl_alloc(_850);
    int64_t _851 = 0; // x
    _jump533:; // Begin body of loop
    int64_t _852 = 0;
    _852 *= _849.d0;
    _852 += _851;
    _849.data[_852] = _756;
    _851++;
    if (_851 < _756.d2)
    goto _jump533;
    // End body of loop
    _a1__a1__a3_int64_t _853;
    _853.d0 = 1;
    _853.data = jpl_alloc(sizeof(_a1__a3_int64_t) * 1);
    _853.data[0] = _849;
    double _854;
    // Computing bound for x
    int64_t _855 = n();
    if (_855 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing bound for y
    if (_302.d0 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    _854 = 0;
    int64_t _856 = 0; // y
    int64_t _857 = 0; // x
    _jump536:; // Begin body of loop
    double _858 = 5.0;
    double _859 = -_858;
    _854 += _859;
    _856++;
    if (_856 < _302.d0)
    goto _jump536;
    _856 = 0;
    _857++;
    if (_857 < _855)
    goto _jump536;
    // End body of loop
    double _860 = 47.0;
    bool _861 = _854 != _860;
    _a1__a1__a3_int64_t _862;
    if (!_861)
    goto _jump537;
    bool _863 = false;
    _a1__a1__a3_int64_t _864;
    if (!_863)
    goto _jump538;
    _a1__a1__a3_int64_t _865;
    // Computing bound for x
    _865.d0 = _606.d0;
    if (_606.d0 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    // Computing total size of heap memory to allocate
    int64_t _866 = 1;
    _866 *= _606.d0;
    _866 *= sizeof(_a1__a3_int64_t);
    _865.data = jpl_alloc(_866);
    int64_t _867 = 0; // x
    _jump540:; // Begin body of loop
    _a1__a3_int64_t _868;
    _868.d0 = 1;
    _868.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _868.data[0] = _756;
    int64_t _869 = 0;
    _869 *= _865.d0;
    _869 += _867;
    _865.data[_869] = _868;
    _867++;
    if (_867 < _606.d0)
    goto _jump540;
    // End body of loop
    _864 = _865;
    goto _jump541;
    _jump538:;
    _a1__a3_int64_t _870;
    // Computing bound for x
    _870.d0 = _161.d1;
    if (_161.d1 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    // Computing total size of heap memory to allocate
    int64_t _871 = 1;
    _871 *= _161.d1;
    _871 *= sizeof(_a3_int64_t);
    _870.data = jpl_alloc(_871);
    int64_t _872 = 0; // x
    _jump543:; // Begin body of loop
    int64_t _873 = 0;
    _873 *= _870.d0;
    _873 += _872;
    _870.data[_873] = _756;
    _872++;
    if (_872 < _161.d1)
    goto _jump543;
    // End body of loop
    _a1__a1__a3_int64_t _874;
    _874.d0 = 1;
    _874.data = jpl_alloc(sizeof(_a1__a3_int64_t) * 1);
    _874.data[0] = _870;
    _864 = _874;
    _jump541:;
    _862 = _864;
    goto _jump544;
    _jump537:;
    _a1__a1__a3_int64_t _875;
    // Computing bound for x
    _875.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing total size of heap memory to allocate
    int64_t _876 = 1;
    _876 *= _161.d0;
    _876 *= sizeof(_a1__a3_int64_t);
    _875.data = jpl_alloc(_876);
    int64_t _877 = 0; // x
    _jump546:; // Begin body of loop
    _a1__a3_int64_t _878;
    // Computing bound for y
    _878.d0 = _756.d0;
    if (_756.d0 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    // Computing total size of heap memory to allocate
    int64_t _879 = 1;
    _879 *= _756.d0;
    _879 *= sizeof(_a3_int64_t);
    _878.data = jpl_alloc(_879);
    int64_t _880 = 0; // y
    _jump548:; // Begin body of loop
    int64_t _881 = 0;
    _881 *= _878.d0;
    _881 += _880;
    _878.data[_881] = _756;
    _880++;
    if (_880 < _756.d0)
    goto _jump548;
    // End body of loop
    int64_t _882 = 0;
    _882 *= _875.d0;
    _882 += _877;
    _875.data[_882] = _878;
    _877++;
    if (_877 < _161.d0)
    goto _jump546;
    // End body of loop
    _862 = _875;
    _jump544:;
    double _883 = 37.0;
    double _884 = 58.0;
    bool _885 = _883 != _884;
    _a1__a1__a3_int64_t _886;
    if (!_885)
    goto _jump549;
    bool _887 = _417.d2 <= _417.d1;
    _a1__a3_int64_t _888;
    if (!_887)
    goto _jump550;
    _a1__a3_int64_t _889;
    // Computing bound for x
    _889.d0 = _756.d1;
    if (_756.d1 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing total size of heap memory to allocate
    int64_t _890 = 1;
    _890 *= _756.d1;
    _890 *= sizeof(_a3_int64_t);
    _889.data = jpl_alloc(_890);
    int64_t _891 = 0; // x
    _jump552:; // Begin body of loop
    int64_t _892 = 0;
    _892 *= _889.d0;
    _892 += _891;
    _889.data[_892] = _756;
    _891++;
    if (_891 < _756.d1)
    goto _jump552;
    // End body of loop
    _888 = _889;
    goto _jump553;
    _jump550:;
    _a1__a3_int64_t _893;
    _893.d0 = 3;
    _893.data = jpl_alloc(sizeof(_a3_int64_t) * 3);
    _893.data[0] = _161;
    _893.data[1] = _756;
    _893.data[2] = _161;
    _888 = _893;
    _jump553:;
    _a1__a1__a3_int64_t _894;
    _894.d0 = 1;
    _894.data = jpl_alloc(sizeof(_a1__a3_int64_t) * 1);
    _894.data[0] = _888;
    _886 = _894;
    goto _jump554;
    _jump549:;
    bool _896 = false;
    bool _895 = _896;
    if (0 == _896)
    goto _jump555;
    if (_606.d0 >= 0)
    goto _jump556;
    fail_assertion("negative array index");
    _jump556:;
    if (_606.d0 < _417.d0)
    goto _jump557;
    fail_assertion("index too large");
    _jump557:;
    if (_161.d2 >= 0)
    goto _jump558;
    fail_assertion("negative array index");
    _jump558:;
    if (_161.d2 < _417.d1)
    goto _jump559;
    fail_assertion("index too large");
    _jump559:;
    if (_302.d1 >= 0)
    goto _jump560;
    fail_assertion("negative array index");
    _jump560:;
    if (_302.d1 < _417.d2)
    goto _jump561;
    fail_assertion("index too large");
    _jump561:;
    int64_t _897 = 0;
    _897 *= _417.d0;
    _897 += _606.d0;
    _897 *= _417.d1;
    _897 += _161.d2;
    _897 *= _417.d2;
    _897 += _302.d1;
    bool _898 = _417.data[_897];
    _895 = _898;
    _jump555:;
    _a1__a1__a3_int64_t _899;
    if (!_895)
    goto _jump562;
    _a1__a3_int64_t _900;
    // Computing bound for x
    _900.d0 = _756.d2;
    if (_756.d2 > 0) 
    goto _jump563;
    fail_assertion("non-positive loop bound");
    _jump563:;
    // Computing total size of heap memory to allocate
    int64_t _901 = 1;
    _901 *= _756.d2;
    _901 *= sizeof(_a3_int64_t);
    _900.data = jpl_alloc(_901);
    int64_t _902 = 0; // x
    _jump564:; // Begin body of loop
    int64_t _903 = 0;
    _903 *= _900.d0;
    _903 += _902;
    _900.data[_903] = _756;
    _902++;
    if (_902 < _756.d2)
    goto _jump564;
    // End body of loop
    _a1__a3_int64_t _904;
    _904.d0 = 3;
    _904.data = jpl_alloc(sizeof(_a3_int64_t) * 3);
    _904.data[0] = _756;
    _904.data[1] = _756;
    _904.data[2] = _161;
    _a1__a1__a3_int64_t _905;
    _905.d0 = 2;
    _905.data = jpl_alloc(sizeof(_a1__a3_int64_t) * 2);
    _905.data[0] = _900;
    _905.data[1] = _904;
    _899 = _905;
    goto _jump565;
    _jump562:;
    _a1__a3_int64_t _906;
    // Computing bound for x
    _906.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump566;
    fail_assertion("non-positive loop bound");
    _jump566:;
    // Computing total size of heap memory to allocate
    int64_t _907 = 1;
    _907 *= _161.d0;
    _907 *= sizeof(_a3_int64_t);
    _906.data = jpl_alloc(_907);
    int64_t _908 = 0; // x
    _jump567:; // Begin body of loop
    int64_t _909 = 0;
    _909 *= _906.d0;
    _909 += _908;
    _906.data[_909] = _161;
    _908++;
    if (_908 < _161.d0)
    goto _jump567;
    // End body of loop
    _a1__a3_int64_t _910;
    _910.d0 = 1;
    _910.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _910.data[0] = _161;
    _a1__a3_int64_t _911;
    _911.d0 = 1;
    _911.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _911.data[0] = _756;
    _a1__a1__a3_int64_t _912;
    _912.d0 = 3;
    _912.data = jpl_alloc(sizeof(_a1__a3_int64_t) * 3);
    _912.data[0] = _906;
    _912.data[1] = _910;
    _912.data[2] = _911;
    _899 = _912;
    _jump565:;
    _886 = _899;
    _jump554:;
    _a1__a1__a1__a3_int64_t _913;
    _913.d0 = 3;
    _913.data = jpl_alloc(sizeof(_a1__a1__a3_int64_t) * 3);
    _913.data[0] = _853;
    _913.data[1] = _862;
    _913.data[2] = _886;
    if (_302.d1 >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (_302.d1 < _913.d0)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    int64_t _914 = 0;
    _914 *= _913.d0;
    _914 += _302.d1;
    _a1__a1__a3_int64_t _915 = _913.data[_914];
    if (_756.d2 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (_756.d2 < _915.d0)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    int64_t _916 = 0;
    _916 *= _915.d0;
    _916 += _756.d2;
    _a1__a3_int64_t _917 = _915.data[_916];
    _a1_int64_t _918;
    // Computing bound for D
    int64_t _919 = n();
    _918.d0 = _919;
    if (_919 > 0) 
    goto _jump1340;
    fail_assertion("non-positive loop bound");
    _jump1340:;
    // Computing total size of heap memory to allocate
    int64_t _920 = 1;
    _920 *= _919;
    _920 *= sizeof(int64_t);
    _918.data = jpl_alloc(_920);
    int64_t _921 = 0; // D
    _jump1341:; // Begin body of loop
    int64_t _922 = 0;
    _922 *= _918.d0;
    _922 += _921;
    _918.data[_922] = _917.d0;
    _921++;
    if (_921 < _919)
    goto _jump1341;
    // End body of loop
    double _923 = get_time();
    _a2__a1__a3_int64_t _924;
    // Computing bound for K
    int64_t _925;
    // Computing bound for K
    if (_161.d1 > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    // Computing bound for L
    if (_756.d2 > 0) 
    goto _jump1343;
    fail_assertion("non-positive loop bound");
    _jump1343:;
    _925 = 0;
    int64_t _926 = 0; // L
    int64_t _927 = 0; // K
    _jump1344:; // Begin body of loop
    bool _928 = _926 >= _302.d1;
    int64_t _929;
    if (!_928)
    goto _jump1345;
    int64_t _930 = 965;
    _929 = _930;
    goto _jump1346;
    _jump1345:;
    _929 = _161.d1;
    _jump1346:;
    _925 += _929;
    _926++;
    if (_926 < _756.d2)
    goto _jump1344;
    _926 = 0;
    _927++;
    if (_927 < _161.d1)
    goto _jump1344;
    // End body of loop
    int64_t _931 = -_925;
    _924.d0 = _931;
    if (_931 > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing bound for L
    int64_t _932 = 20;
    _924.d1 = _932;
    if (_932 > 0) 
    goto _jump1348;
    fail_assertion("non-positive loop bound");
    _jump1348:;
    // Computing total size of heap memory to allocate
    int64_t _933 = 1;
    _933 *= _931;
    _933 *= _932;
    _933 *= sizeof(_a1__a3_int64_t);
    _924.data = jpl_alloc(_933);
    int64_t _934 = 0; // L
    int64_t _935 = 0; // K
    _jump1349:; // Begin body of loop
    int64_t _936 = 0;
    _936 *= _924.d0;
    _936 += _935;
    _936 *= _924.d1;
    _936 += _934;
    _924.data[_936] = _917;
    _934++;
    if (_934 < _932)
    goto _jump1349;
    _934 = 0;
    _935++;
    if (_935 < _931)
    goto _jump1349;
    // End body of loop
    if (_756.d2 >= 0)
    goto _jump1350;
    fail_assertion("negative array index");
    _jump1350:;
    if (_756.d2 < _924.d0)
    goto _jump1351;
    fail_assertion("index too large");
    _jump1351:;
    if (_161.d1 >= 0)
    goto _jump1352;
    fail_assertion("negative array index");
    _jump1352:;
    if (_161.d1 < _924.d1)
    goto _jump1353;
    fail_assertion("index too large");
    _jump1353:;
    int64_t _937 = 0;
    _937 *= _924.d0;
    _937 += _756.d2;
    _937 *= _924.d1;
    _937 += _161.d1;
    _a1__a3_int64_t _938 = _924.data[_937];
    double _939 = get_time();
    print_time(_939 - _923);
}

