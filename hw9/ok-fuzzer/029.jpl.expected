
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3__a3_int64_t *data;
} _a1__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a3__a3_int64_t *data;
} _a1__a1__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
    double a;
} h;

typedef struct {
    bool a;
    h b;
    int64_t c;
} i;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  i *data;
} _a3_i;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_i *data;
} _a2__a3_i;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_i *data;
} _a2__a2__a3_i;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  _a3_i *data;
} _a1__a3_i;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_bool *data;
} _a2__a2__a3_bool;

typedef struct {
  int64_t d0;
  _a2__a3_bool *data;
} _a1__a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  h *data;
} _a2_h;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_h *data;
} _a3__a2_h;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_h *data;
} _a2__a3__a2_h;

typedef struct {
  int64_t d0;
  _a3__a2_h *data;
} _a1__a3__a2_h;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a3_int64_t *data;
} _a2__a3__a3_int64_t;

typedef struct {
    bool a;
} o;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2__a1_int64_t *data;
} _a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  i *data;
} _a1_i;

typedef struct {
  int64_t d0;
  o *data;
} _a1_o;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  h *data;
} _a3_h;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_rgba *data;
} _a3__a3_rgba;

typedef struct {
  int64_t d0;
  _a3_rgba *data;
} _a1__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a3_rgba *data;
} _a3__a1__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  o *data;
} _a3_o;

typedef struct {
  int64_t d0;
  int64_t d1;
  o *data;
} _a2_o;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_o *data;
} _a2__a2_o;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a3_void_t *data;
} _a2__a1__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a2__a2_int64_t *data;
} _a1__a2__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a2_int64_t *data;
} _a3__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_o *data;
} _a3__a1_o;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_i *data;
} _a3__a1_i;

typedef struct {
  int64_t d0;
  _a1_i *data;
} _a1__a1_i;

void_t j(_a3_i k, _a2_rgba o, _a3_bool r) {
    bool _0 = c != r.d1;
    int64_t _1;
    if (!_0)
    goto _jump181;
    _1 = k.d0;
    goto _jump182;
    _jump181:;
    _1 = d;
    _jump182:;
    int64_t _2 = -_1;
    bool _3 = o.d1 < _2;
    bool _4;
    if (!_3)
    goto _jump183;
    int64_t _6;
    // Computing bound for v
    if (c > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing bound for w
    if (k.d0 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing bound for x
    if (o.d0 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    _6 = 0;
    int64_t _7 = 0; // x
    int64_t _8 = 0; // w
    int64_t _9 = 0; // v
    _jump187:; // Begin body of loop
    _6 += r.d1;
    _7++;
    if (_7 < o.d0)
    goto _jump187;
    _7 = 0;
    _8++;
    if (_8 < k.d0)
    goto _jump187;
    _8 = 0;
    _9++;
    if (_9 < c)
    goto _jump187;
    // End body of loop
    if (_6 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_6 < a.d0)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    if (o.d1 >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (o.d1 < a.d1)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    if (r.d1 >= 0)
    goto _jump192;
    fail_assertion("negative array index");
    _jump192:;
    if (r.d1 < a.d2)
    goto _jump193;
    fail_assertion("index too large");
    _jump193:;
    int64_t _10 = 0;
    _10 *= a.d0;
    _10 += _6;
    _10 *= a.d1;
    _10 += o.d1;
    _10 *= a.d2;
    _10 += r.d1;
    int64_t _11 = a.data[_10];
    bool _12 = o.d1 == _11;
    bool _5 = _12;
    if (0 == _12)
    goto _jump194;
    bool _13 = d != k.d2;
    bool _14 = !_13;
    _5 = _14;
    _jump194:;
    _4 = _5;
    goto _jump195;
    _jump183:;
    bool _15 = true;
    bool _16;
    if (!_15)
    goto _jump196;
    bool _17 = false;
    _16 = _17;
    goto _jump197;
    _jump196:;
    bool _18 = k.d1 > r.d0;
    int64_t _19 = 523;
    if (_19 >= 0)
    goto _jump198;
    fail_assertion("negative array index");
    _jump198:;
    if (_19 < r.d0)
    goto _jump199;
    fail_assertion("index too large");
    _jump199:;
    if (k.d2 >= 0)
    goto _jump200;
    fail_assertion("negative array index");
    _jump200:;
    if (k.d2 < r.d1)
    goto _jump201;
    fail_assertion("index too large");
    _jump201:;
    if (o.d1 >= 0)
    goto _jump202;
    fail_assertion("negative array index");
    _jump202:;
    if (o.d1 < r.d2)
    goto _jump203;
    fail_assertion("index too large");
    _jump203:;
    int64_t _20 = 0;
    _20 *= r.d0;
    _20 += _19;
    _20 *= r.d1;
    _20 += k.d2;
    _20 *= r.d2;
    _20 += o.d1;
    bool _21 = r.data[_20];
    bool _22 = _18 != _21;
    _16 = _22;
    _jump197:;
    bool _24 = false;
    bool _23 = _24;
    if (0 != _24)
    goto _jump204;
    bool _25 = d != r.d0;
    bool _26 = !_25;
    _23 = _26;
    _jump204:;
    bool _27 = _16 != _23;
    _4 = _27;
    _jump195:;
    _a3_i _28;
    if (!_4)
    goto _jump205;
    bool _29 = true;
    bool _30 = !_29;
    bool _31;
    if (!_30)
    goto _jump206;
    bool _32 = false;
    _31 = _32;
    goto _jump207;
    _jump206:;
    bool _33 = false;
    bool _34 = !_33;
    _31 = _34;
    _jump207:;
    _a2__a3_i _35;
    if (!_31)
    goto _jump208;
    _a2__a2__a3_i _36;
    // Computing bound for v
    _36.d0 = d;
    if (d > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    // Computing bound for w
    _36.d1 = c;
    if (c > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= d;
    _37 *= c;
    _37 *= sizeof(_a2__a3_i);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // w
    int64_t _39 = 0; // v
    _jump211:; // Begin body of loop
    _a2__a3_i _40;
    // Computing bound for x
    _40.d0 = _38;
    if (_38 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for y
    _40.d1 = g;
    if (g > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= _38;
    _41 *= g;
    _41 *= sizeof(_a3_i);
    _40.data = jpl_alloc(_41);
    int64_t _42 = 0; // y
    int64_t _43 = 0; // x
    _jump214:; // Begin body of loop
    int64_t _44 = 0;
    _44 *= _40.d0;
    _44 += _43;
    _44 *= _40.d1;
    _44 += _42;
    _40.data[_44] = k;
    _42++;
    if (_42 < g)
    goto _jump214;
    _42 = 0;
    _43++;
    if (_43 < _38)
    goto _jump214;
    // End body of loop
    int64_t _45 = 0;
    _45 *= _36.d0;
    _45 += _39;
    _45 *= _36.d1;
    _45 += _38;
    _36.data[_45] = _40;
    _38++;
    if (_38 < c)
    goto _jump211;
    _38 = 0;
    _39++;
    if (_39 < d)
    goto _jump211;
    // End body of loop
    if (o.d1 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (o.d1 < _36.d0)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    if (b >= 0)
    goto _jump217;
    fail_assertion("negative array index");
    _jump217:;
    if (b < _36.d1)
    goto _jump218;
    fail_assertion("index too large");
    _jump218:;
    int64_t _46 = 0;
    _46 *= _36.d0;
    _46 += o.d1;
    _46 *= _36.d1;
    _46 += b;
    _a2__a3_i _47 = _36.data[_46];
    _35 = _47;
    goto _jump219;
    _jump208:;
    _a2_bool _48;
    // Computing bound for v
    _48.d0 = r.d1;
    if (r.d1 > 0) 
    goto _jump220;
    fail_assertion("non-positive loop bound");
    _jump220:;
    // Computing bound for w
    _48.d1 = r.d2;
    if (r.d2 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= r.d1;
    _49 *= r.d2;
    _49 *= sizeof(bool);
    _48.data = jpl_alloc(_49);
    int64_t _50 = 0; // w
    int64_t _51 = 0; // v
    _jump222:; // Begin body of loop
    bool _52 = false;
    int64_t _53 = 0;
    _53 *= _48.d0;
    _53 += _51;
    _53 *= _48.d1;
    _53 += _50;
    _48.data[_53] = _52;
    _50++;
    if (_50 < r.d2)
    goto _jump222;
    _50 = 0;
    _51++;
    if (_51 < r.d1)
    goto _jump222;
    // End body of loop
    int64_t _54;
    // Computing bound for v
    if (b > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    _54 = 0;
    int64_t _55 = 0; // v
    _jump224:; // Begin body of loop
    _54 += k.d0;
    _55++;
    if (_55 < b)
    goto _jump224;
    // End body of loop
    if (c >= 0)
    goto _jump225;
    fail_assertion("negative array index");
    _jump225:;
    if (c < _48.d0)
    goto _jump226;
    fail_assertion("index too large");
    _jump226:;
    if (_54 >= 0)
    goto _jump227;
    fail_assertion("negative array index");
    _jump227:;
    if (_54 < _48.d1)
    goto _jump228;
    fail_assertion("index too large");
    _jump228:;
    int64_t _56 = 0;
    _56 *= _48.d0;
    _56 += c;
    _56 *= _48.d1;
    _56 += _54;
    bool _57 = _48.data[_56];
    _a2__a3_i _58;
    if (!_57)
    goto _jump229;
    _a2__a3_i _59;
    // Computing bound for v
    _59.d0 = b;
    if (b > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for w
    int64_t _60 = -b;
    _59.d1 = _60;
    if (_60 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= b;
    _61 *= _60;
    _61 *= sizeof(_a3_i);
    _59.data = jpl_alloc(_61);
    int64_t _62 = 0; // w
    int64_t _63 = 0; // v
    _jump232:; // Begin body of loop
    int64_t _64 = 0;
    _64 *= _59.d0;
    _64 += _63;
    _64 *= _59.d1;
    _64 += _62;
    _59.data[_64] = k;
    _62++;
    if (_62 < _60)
    goto _jump232;
    _62 = 0;
    _63++;
    if (_63 < b)
    goto _jump232;
    // End body of loop
    _58 = _59;
    goto _jump233;
    _jump229:;
    _a2__a3_i _65;
    // Computing bound for v
    _65.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing bound for w
    _65.d1 = c;
    if (c > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= k.d0;
    _66 *= c;
    _66 *= sizeof(_a3_i);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // w
    int64_t _68 = 0; // v
    _jump236:; // Begin body of loop
    int64_t _69 = 0;
    _69 *= _65.d0;
    _69 += _68;
    _69 *= _65.d1;
    _69 += _67;
    _65.data[_69] = k;
    _67++;
    if (_67 < c)
    goto _jump236;
    _67 = 0;
    _68++;
    if (_68 < k.d0)
    goto _jump236;
    // End body of loop
    _58 = _65;
    _jump233:;
    _35 = _58;
    _jump219:;
    if (k.d2 >= 0)
    goto _jump237;
    fail_assertion("negative array index");
    _jump237:;
    if (k.d2 < _35.d0)
    goto _jump238;
    fail_assertion("index too large");
    _jump238:;
    if (r.d0 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (r.d0 < _35.d1)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    int64_t _70 = 0;
    _70 *= _35.d0;
    _70 += k.d2;
    _70 *= _35.d1;
    _70 += r.d0;
    _a3_i _71 = _35.data[_70];
    _28 = _71;
    goto _jump241;
    _jump205:;
    _a1__a3_i _72;
    // Computing bound for v
    _72.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump242;
    fail_assertion("non-positive loop bound");
    _jump242:;
    // Computing total size of heap memory to allocate
    int64_t _73 = 1;
    _73 *= r.d0;
    _73 *= sizeof(_a3_i);
    _72.data = jpl_alloc(_73);
    int64_t _74 = 0; // v
    _jump243:; // Begin body of loop
    int64_t _75 = 0;
    _75 *= _72.d0;
    _75 += _74;
    _72.data[_75] = k;
    _74++;
    if (_74 < r.d0)
    goto _jump243;
    // End body of loop
    if (k.d1 >= 0)
    goto _jump244;
    fail_assertion("negative array index");
    _jump244:;
    if (k.d1 < _72.d0)
    goto _jump245;
    fail_assertion("index too large");
    _jump245:;
    int64_t _76 = 0;
    _76 *= _72.d0;
    _76 += k.d1;
    _a3_i _77 = _72.data[_76];
    _28 = _77;
    _jump241:;
    _a2_rgba _78;
    // Computing bound for v
    _78.d0 = g;
    if (g > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing bound for w
    _78.d1 = r.d0;
    if (r.d0 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= g;
    _79 *= r.d0;
    _79 *= sizeof(rgba);
    _78.data = jpl_alloc(_79);
    int64_t _80 = 0; // w
    int64_t _81 = 0; // v
    _jump248:; // Begin body of loop
    _a1_double _82;
    // Computing bound for x
    _82.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    // Computing total size of heap memory to allocate
    int64_t _83 = 1;
    _83 *= k.d1;
    _83 *= sizeof(double);
    _82.data = jpl_alloc(_83);
    int64_t _84 = 0; // x
    _jump250:; // Begin body of loop
    double _85;
    // Computing bound for y
    if (r.d2 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    _85 = 0;
    int64_t _86 = 0; // y
    _jump252:; // Begin body of loop
    double _87 = 53.0;
    _85 += _87;
    _86++;
    if (_86 < r.d2)
    goto _jump252;
    // End body of loop
    double _88 = -_85;
    int64_t _89 = 0;
    _89 *= _82.d0;
    _89 += _84;
    _82.data[_89] = _88;
    _84++;
    if (_84 < k.d1)
    goto _jump250;
    // End body of loop
    int64_t _90 = _81 - _81;
    if (_90 >= 0)
    goto _jump253;
    fail_assertion("negative array index");
    _jump253:;
    if (_90 < _82.d0)
    goto _jump254;
    fail_assertion("index too large");
    _jump254:;
    int64_t _91 = 0;
    _91 *= _82.d0;
    _91 += _90;
    double _92 = _82.data[_91];
    bool _93 = false;
    double _94;
    if (!_93)
    goto _jump255;
    double _95;
    // Computing bound for x
    int64_t _96 = -d;
    if (_96 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    _95 = 0;
    int64_t _97 = 0; // x
    _jump257:; // Begin body of loop
    double _98;
    // Computing bound for y
    int64_t _99 = 81;
    int64_t _100 = _99 - r.d0;
    if (_100 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    // Computing bound for z
    if (k.d1 > 0) 
    goto _jump259;
    fail_assertion("non-positive loop bound");
    _jump259:;
    // Computing bound for A
    if (k.d2 > 0) 
    goto _jump260;
    fail_assertion("non-positive loop bound");
    _jump260:;
    _98 = 0;
    int64_t _101 = 0; // A
    int64_t _102 = 0; // z
    int64_t _103 = 0; // y
    _jump261:; // Begin body of loop
    double _104 = 94.0;
    double _105 = -_104;
    _98 += _105;
    _101++;
    if (_101 < k.d2)
    goto _jump261;
    _101 = 0;
    _102++;
    if (_102 < k.d1)
    goto _jump261;
    _102 = 0;
    _103++;
    if (_103 < _100)
    goto _jump261;
    // End body of loop
    _95 += _98;
    _97++;
    if (_97 < _96)
    goto _jump257;
    // End body of loop
    _94 = _95;
    goto _jump262;
    _jump255:;
    double _106 = 15.0;
    _94 = _106;
    _jump262:;
    _a1_double _107;
    // Computing bound for x
    _107.d0 = o.d1;
    if (o.d1 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= o.d1;
    _108 *= sizeof(double);
    _107.data = jpl_alloc(_108);
    int64_t _109 = 0; // x
    _jump264:; // Begin body of loop
    double _110 = 3.0;
    int64_t _111 = 0;
    _111 *= _107.d0;
    _111 += _109;
    _107.data[_111] = _110;
    _109++;
    if (_109 < o.d1)
    goto _jump264;
    // End body of loop
    int64_t _112 = 967;
    int64_t _113 = _81 - _112;
    if (_113 >= 0)
    goto _jump265;
    fail_assertion("negative array index");
    _jump265:;
    if (_113 < _107.d0)
    goto _jump266;
    fail_assertion("index too large");
    _jump266:;
    int64_t _114 = 0;
    _114 *= _107.d0;
    _114 += _113;
    double _115 = _107.data[_114];
    _a3_double _116;
    // Computing bound for x
    _116.d0 = b;
    if (b > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    // Computing bound for y
    _116.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for z
    _116.d2 = b;
    if (b > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= b;
    _117 *= o.d1;
    _117 *= b;
    _117 *= sizeof(double);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // z
    int64_t _119 = 0; // y
    int64_t _120 = 0; // x
    _jump270:; // Begin body of loop
    double _121 = 96.0;
    int64_t _122 = 0;
    _122 *= _116.d0;
    _122 += _120;
    _122 *= _116.d1;
    _122 += _119;
    _122 *= _116.d2;
    _122 += _118;
    _116.data[_122] = _121;
    _118++;
    if (_118 < b)
    goto _jump270;
    _118 = 0;
    _119++;
    if (_119 < o.d1)
    goto _jump270;
    _119 = 0;
    _120++;
    if (_120 < b)
    goto _jump270;
    // End body of loop
    int64_t _123 = -o.d1;
    if (_123 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_123 < _116.d0)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    if (k.d2 >= 0)
    goto _jump273;
    fail_assertion("negative array index");
    _jump273:;
    if (k.d2 < _116.d1)
    goto _jump274;
    fail_assertion("index too large");
    _jump274:;
    if (c >= 0)
    goto _jump275;
    fail_assertion("negative array index");
    _jump275:;
    if (c < _116.d2)
    goto _jump276;
    fail_assertion("index too large");
    _jump276:;
    int64_t _124 = 0;
    _124 *= _116.d0;
    _124 += _123;
    _124 *= _116.d1;
    _124 += k.d2;
    _124 *= _116.d2;
    _124 += c;
    double _125 = _116.data[_124];
    double _126;
    // Computing bound for x
    if (k.d1 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    _126 = 0;
    int64_t _127 = 0; // x
    _jump278:; // Begin body of loop
    double _128 = 39.0;
    _126 += _128;
    _127++;
    if (_127 < k.d1)
    goto _jump278;
    // End body of loop
    double _129 = 15.0;
    rgba _130 = { _115, _125, _126, _129 };
    double _131 = _130.b;
    double _132 = 66.0;
    double _133 = -_132;
    h _134 = { _133 };
    double _135 = _134.a;
    double _136;
    // Computing bound for x
    if (g > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing bound for y
    if (_81 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    _136 = 0;
    int64_t _137 = 0; // y
    int64_t _138 = 0; // x
    _jump281:; // Begin body of loop
    double _139 = 28.0;
    h _140 = { _139 };
    double _141 = _140.a;
    _136 += _141;
    _137++;
    if (_137 < _81)
    goto _jump281;
    _137 = 0;
    _138++;
    if (_138 < g)
    goto _jump281;
    // End body of loop
    double _142 = _135 / _136;
    rgba _143 = { _92, _94, _131, _142 };
    int64_t _144 = 0;
    _144 *= _78.d0;
    _144 += _81;
    _144 *= _78.d1;
    _144 += _80;
    _78.data[_144] = _143;
    _80++;
    if (_80 < r.d0)
    goto _jump248;
    _80 = 0;
    _81++;
    if (_81 < g)
    goto _jump248;
    // End body of loop
    _a2__a3_bool _145;
    // Computing bound for v
    _145.d0 = o.d1;
    if (o.d1 > 0) 
    goto _jump282;
    fail_assertion("non-positive loop bound");
    _jump282:;
    // Computing bound for w
    int64_t _146 = -g;
    _145.d1 = _146;
    if (_146 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= o.d1;
    _147 *= _146;
    _147 *= sizeof(_a3_bool);
    _145.data = jpl_alloc(_147);
    int64_t _148 = 0; // w
    int64_t _149 = 0; // v
    _jump284:; // Begin body of loop
    _a3_bool _150;
    // Computing bound for x
    _150.d0 = d;
    if (d > 0) 
    goto _jump285;
    fail_assertion("non-positive loop bound");
    _jump285:;
    // Computing bound for y
    _150.d1 = c;
    if (c > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing bound for z
    _150.d2 = _148;
    if (_148 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= d;
    _151 *= c;
    _151 *= _148;
    _151 *= sizeof(bool);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // z
    int64_t _153 = 0; // y
    int64_t _154 = 0; // x
    _jump288:; // Begin body of loop
    bool _155 = _154 == d;
    int64_t _156 = 0;
    _156 *= _150.d0;
    _156 += _154;
    _156 *= _150.d1;
    _156 += _153;
    _156 *= _150.d2;
    _156 += _152;
    _150.data[_156] = _155;
    _152++;
    if (_152 < _148)
    goto _jump288;
    _152 = 0;
    _153++;
    if (_153 < c)
    goto _jump288;
    _153 = 0;
    _154++;
    if (_154 < d)
    goto _jump288;
    // End body of loop
    int64_t _157 = 0;
    _157 *= _145.d0;
    _157 += _149;
    _157 *= _145.d1;
    _157 += _148;
    _145.data[_157] = _150;
    _148++;
    if (_148 < _146)
    goto _jump284;
    _148 = 0;
    _149++;
    if (_149 < o.d1)
    goto _jump284;
    // End body of loop
    _a2__a2__a3_bool _158;
    // Computing bound for v
    _158.d0 = r.d1;
    if (r.d1 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    // Computing bound for w
    _158.d1 = k.d2;
    if (k.d2 > 0) 
    goto _jump290;
    fail_assertion("non-positive loop bound");
    _jump290:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= r.d1;
    _159 *= k.d2;
    _159 *= sizeof(_a2__a3_bool);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // w
    int64_t _161 = 0; // v
    _jump291:; // Begin body of loop
    _a2__a3_bool _162;
    // Computing bound for x
    _162.d0 = _160;
    if (_160 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing bound for y
    _162.d1 = _161;
    if (_161 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= _160;
    _163 *= _161;
    _163 *= sizeof(_a3_bool);
    _162.data = jpl_alloc(_163);
    int64_t _164 = 0; // y
    int64_t _165 = 0; // x
    _jump294:; // Begin body of loop
    int64_t _166 = 0;
    _166 *= _162.d0;
    _166 += _165;
    _166 *= _162.d1;
    _166 += _164;
    _162.data[_166] = r;
    _164++;
    if (_164 < _161)
    goto _jump294;
    _164 = 0;
    _165++;
    if (_165 < _160)
    goto _jump294;
    // End body of loop
    int64_t _167 = 0;
    _167 *= _158.d0;
    _167 += _161;
    _167 *= _158.d1;
    _167 += _160;
    _158.data[_167] = _162;
    _160++;
    if (_160 < k.d2)
    goto _jump291;
    _160 = 0;
    _161++;
    if (_161 < r.d1)
    goto _jump291;
    // End body of loop
    bool _169 = false;
    bool _168 = _169;
    if (0 != _169)
    goto _jump295;
    bool _170 = true;
    _168 = _170;
    _jump295:;
    int64_t _171;
    if (!_168)
    goto _jump296;
    _171 = r.d0;
    goto _jump297;
    _jump296:;
    _171 = g;
    _jump297:;
    if (o.d0 >= 0)
    goto _jump298;
    fail_assertion("negative array index");
    _jump298:;
    if (o.d0 < _158.d0)
    goto _jump299;
    fail_assertion("index too large");
    _jump299:;
    if (_171 >= 0)
    goto _jump300;
    fail_assertion("negative array index");
    _jump300:;
    if (_171 < _158.d1)
    goto _jump301;
    fail_assertion("index too large");
    _jump301:;
    int64_t _172 = 0;
    _172 *= _158.d0;
    _172 += o.d0;
    _172 *= _158.d1;
    _172 += _171;
    _a2__a3_bool _173 = _158.data[_172];
    _a1__a2__a3_bool _174;
    _174.d0 = 2;
    _174.data = jpl_alloc(sizeof(_a2__a3_bool) * 2);
    _174.data[0] = _145;
    _174.data[1] = _173;
    if (r.d1 >= 0)
    goto _jump302;
    fail_assertion("negative array index");
    _jump302:;
    if (r.d1 < _174.d0)
    goto _jump303;
    fail_assertion("index too large");
    _jump303:;
    int64_t _175 = 0;
    _175 *= _174.d0;
    _175 += r.d1;
    _a2__a3_bool _176 = _174.data[_175];
    if (r.d2 >= 0)
    goto _jump304;
    fail_assertion("negative array index");
    _jump304:;
    if (r.d2 < _176.d0)
    goto _jump305;
    fail_assertion("index too large");
    _jump305:;
    if (o.d1 >= 0)
    goto _jump306;
    fail_assertion("negative array index");
    _jump306:;
    if (o.d1 < _176.d1)
    goto _jump307;
    fail_assertion("index too large");
    _jump307:;
    int64_t _177 = 0;
    _177 *= _176.d0;
    _177 += r.d2;
    _177 *= _176.d1;
    _177 += o.d1;
    _a3_bool _178 = _176.data[_177];
    void_t _179 = j(_28, _78, _178);
    return _179;
    _a3_void_t _180;
    // Computing bound for v
    double _181;
    // Computing bound for v
    if (r.d0 > 0) 
    goto _jump308;
    fail_assertion("non-positive loop bound");
    _jump308:;
    // Computing bound for w
    if (k.d0 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    _181 = 0;
    int64_t _182 = 0; // w
    int64_t _183 = 0; // v
    _jump310:; // Begin body of loop
    double _184 = 76.0;
    _181 += _184;
    _182++;
    if (_182 < k.d0)
    goto _jump310;
    _182 = 0;
    _183++;
    if (_183 < r.d0)
    goto _jump310;
    // End body of loop
    double _185 = 35.0;
    bool _186 = _181 >= _185;
    i _187;
    if (!_186)
    goto _jump311;
    _a1__a3_i _188;
    _188.d0 = 1;
    _188.data = jpl_alloc(sizeof(_a3_i) * 1);
    _188.data[0] = k;
    if (r.d1 >= 0)
    goto _jump312;
    fail_assertion("negative array index");
    _jump312:;
    if (r.d1 < _188.d0)
    goto _jump313;
    fail_assertion("index too large");
    _jump313:;
    int64_t _189 = 0;
    _189 *= _188.d0;
    _189 += r.d1;
    _a3_i _190 = _188.data[_189];
    if (o.d0 >= 0)
    goto _jump314;
    fail_assertion("negative array index");
    _jump314:;
    if (o.d0 < _190.d0)
    goto _jump315;
    fail_assertion("index too large");
    _jump315:;
    if (r.d2 >= 0)
    goto _jump316;
    fail_assertion("negative array index");
    _jump316:;
    if (r.d2 < _190.d1)
    goto _jump317;
    fail_assertion("index too large");
    _jump317:;
    if (o.d1 >= 0)
    goto _jump318;
    fail_assertion("negative array index");
    _jump318:;
    if (o.d1 < _190.d2)
    goto _jump319;
    fail_assertion("index too large");
    _jump319:;
    int64_t _191 = 0;
    _191 *= _190.d0;
    _191 += o.d0;
    _191 *= _190.d1;
    _191 += r.d2;
    _191 *= _190.d2;
    _191 += o.d1;
    i _192 = _190.data[_191];
    _187 = _192;
    goto _jump320;
    _jump311:;
    bool _194 = false;
    bool _193 = _194;
    if (0 == _194)
    goto _jump321;
    bool _195 = false;
    _193 = _195;
    _jump321:;
    bool _196;
    if (!_193)
    goto _jump322;
    bool _197 = false;
    _196 = _197;
    goto _jump323;
    _jump322:;
    bool _198 = false;
    bool _199;
    if (!_198)
    goto _jump324;
    bool _200 = false;
    _199 = _200;
    goto _jump325;
    _jump324:;
    bool _201 = true;
    _199 = _201;
    _jump325:;
    _196 = _199;
    _jump323:;
    i _202;
    if (!_196)
    goto _jump326;
    int64_t _203;
    // Computing bound for v
    if (r.d0 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing bound for w
    if (k.d0 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    // Computing bound for x
    if (o.d0 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    _203 = 0;
    int64_t _204 = 0; // x
    int64_t _205 = 0; // w
    int64_t _206 = 0; // v
    _jump330:; // Begin body of loop
    _203 += k.d2;
    _204++;
    if (_204 < o.d0)
    goto _jump330;
    _204 = 0;
    _205++;
    if (_205 < k.d0)
    goto _jump330;
    _205 = 0;
    _206++;
    if (_206 < r.d0)
    goto _jump330;
    // End body of loop
    int64_t _207 = 993;
    if (_203 >= 0)
    goto _jump331;
    fail_assertion("negative array index");
    _jump331:;
    if (_203 < k.d0)
    goto _jump332;
    fail_assertion("index too large");
    _jump332:;
    if (_207 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (_207 < k.d1)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    if (k.d2 >= 0)
    goto _jump335;
    fail_assertion("negative array index");
    _jump335:;
    if (k.d2 < k.d2)
    goto _jump336;
    fail_assertion("index too large");
    _jump336:;
    int64_t _208 = 0;
    _208 *= k.d0;
    _208 += _203;
    _208 *= k.d1;
    _208 += _207;
    _208 *= k.d2;
    _208 += k.d2;
    i _209 = k.data[_208];
    _202 = _209;
    goto _jump337;
    _jump326:;
    int64_t _210 = 929;
    int64_t _211;
    // Computing bound for v
    if (o.d0 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    _211 = 0;
    int64_t _212 = 0; // v
    _jump339:; // Begin body of loop
    _211 += k.d0;
    _212++;
    if (_212 < o.d0)
    goto _jump339;
    // End body of loop
    if (r.d1 >= 0)
    goto _jump340;
    fail_assertion("negative array index");
    _jump340:;
    if (r.d1 < k.d0)
    goto _jump341;
    fail_assertion("index too large");
    _jump341:;
    if (_210 >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (_210 < k.d1)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    if (_211 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (_211 < k.d2)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    int64_t _213 = 0;
    _213 *= k.d0;
    _213 += r.d1;
    _213 *= k.d1;
    _213 += _210;
    _213 *= k.d2;
    _213 += _211;
    i _214 = k.data[_213];
    _202 = _214;
    _jump337:;
    _187 = _202;
    _jump320:;
    int64_t _215 = _187.c;
    _180.d0 = _215;
    if (_215 > 0) 
    goto _jump346;
    fail_assertion("non-positive loop bound");
    _jump346:;
    // Computing bound for w
    int64_t _216 = 176;
    if (_216 >= 0)
    goto _jump347;
    fail_assertion("negative array index");
    _jump347:;
    if (_216 < k.d0)
    goto _jump348;
    fail_assertion("index too large");
    _jump348:;
    if (d >= 0)
    goto _jump349;
    fail_assertion("negative array index");
    _jump349:;
    if (d < k.d1)
    goto _jump350;
    fail_assertion("index too large");
    _jump350:;
    if (k.d0 >= 0)
    goto _jump351;
    fail_assertion("negative array index");
    _jump351:;
    if (k.d0 < k.d2)
    goto _jump352;
    fail_assertion("index too large");
    _jump352:;
    int64_t _217 = 0;
    _217 *= k.d0;
    _217 += _216;
    _217 *= k.d1;
    _217 += d;
    _217 *= k.d2;
    _217 += k.d0;
    i _218 = k.data[_217];
    bool _219 = _218.a;
    int64_t _220;
    if (!_219)
    goto _jump353;
    _220 = o.d1;
    goto _jump354;
    _jump353:;
    _220 = k.d2;
    _jump354:;
    int64_t _221 = -_220;
    int64_t _222 = -_221;
    _180.d1 = _222;
    if (_222 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing bound for x
    _180.d2 = g;
    if (g > 0) 
    goto _jump356;
    fail_assertion("non-positive loop bound");
    _jump356:;
    // Computing total size of heap memory to allocate
    int64_t _223 = 1;
    _223 *= _215;
    _223 *= _222;
    _223 *= g;
    _223 *= sizeof(void_t);
    _180.data = jpl_alloc(_223);
    int64_t _224 = 0; // x
    int64_t _225 = 0; // w
    int64_t _226 = 0; // v
    _jump357:; // Begin body of loop
    _a3_i _227;
    // Computing bound for y
    _a2_int64_t _228;
    // Computing bound for y
    int64_t _229 = 429;
    _228.d0 = _229;
    if (_229 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    // Computing bound for z
    bool _230 = false;
    int64_t _231;
    if (!_230)
    goto _jump359;
    _231 = k.d0;
    goto _jump360;
    _jump359:;
    _231 = _226;
    _jump360:;
    _228.d1 = _231;
    if (_231 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= _229;
    _232 *= _231;
    _232 *= sizeof(int64_t);
    _228.data = jpl_alloc(_232);
    int64_t _233 = 0; // z
    int64_t _234 = 0; // y
    _jump362:; // Begin body of loop
    int64_t _235 = 104;
    int64_t _236 = r.d2 + _235;
    int64_t _237 = 0;
    _237 *= _228.d0;
    _237 += _234;
    _237 *= _228.d1;
    _237 += _233;
    _228.data[_237] = _236;
    _233++;
    if (_233 < _231)
    goto _jump362;
    _233 = 0;
    _234++;
    if (_234 < _229)
    goto _jump362;
    // End body of loop
    if (g >= 0)
    goto _jump363;
    fail_assertion("negative array index");
    _jump363:;
    if (g < _228.d0)
    goto _jump364;
    fail_assertion("index too large");
    _jump364:;
    if (g >= 0)
    goto _jump365;
    fail_assertion("negative array index");
    _jump365:;
    if (g < _228.d1)
    goto _jump366;
    fail_assertion("index too large");
    _jump366:;
    int64_t _238 = 0;
    _238 *= _228.d0;
    _238 += g;
    _238 *= _228.d1;
    _238 += g;
    int64_t _239 = _228.data[_238];
    _227.d0 = _239;
    if (_239 > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing bound for z
    int64_t _240 = 579;
    int64_t _241 = _240 + k.d0;
    _227.d1 = _241;
    if (_241 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    // Computing bound for A
    _a2_int64_t _242;
    // Computing bound for y
    _242.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    // Computing bound for z
    _242.d1 = k.d1;
    if (k.d1 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= r.d0;
    _243 *= k.d1;
    _243 *= sizeof(int64_t);
    _242.data = jpl_alloc(_243);
    int64_t _244 = 0; // z
    int64_t _245 = 0; // y
    _jump371:; // Begin body of loop
    int64_t _246 = 0;
    _246 *= _242.d0;
    _246 += _245;
    _246 *= _242.d1;
    _246 += _244;
    _242.data[_246] = k.d0;
    _244++;
    if (_244 < k.d1)
    goto _jump371;
    _244 = 0;
    _245++;
    if (_245 < r.d0)
    goto _jump371;
    // End body of loop
    if (d >= 0)
    goto _jump372;
    fail_assertion("negative array index");
    _jump372:;
    if (d < _242.d0)
    goto _jump373;
    fail_assertion("index too large");
    _jump373:;
    if (r.d0 >= 0)
    goto _jump374;
    fail_assertion("negative array index");
    _jump374:;
    if (r.d0 < _242.d1)
    goto _jump375;
    fail_assertion("index too large");
    _jump375:;
    int64_t _247 = 0;
    _247 *= _242.d0;
    _247 += d;
    _247 *= _242.d1;
    _247 += r.d0;
    int64_t _248 = _242.data[_247];
    _227.d2 = _248;
    if (_248 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing total size of heap memory to allocate
    int64_t _249 = 1;
    _249 *= _239;
    _249 *= _241;
    _249 *= _248;
    _249 *= sizeof(i);
    _227.data = jpl_alloc(_249);
    int64_t _250 = 0; // A
    int64_t _251 = 0; // z
    int64_t _252 = 0; // y
    _jump377:; // Begin body of loop
    bool _253 = k.d2 <= c;
    bool _254 = !_253;
    double _255 = 95.0;
    h _256 = { _255 };
    int64_t _257;
    // Computing bound for B
    if (o.d0 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    _257 = 0;
    int64_t _258 = 0; // B
    _jump379:; // Begin body of loop
    _257 += _225;
    _258++;
    if (_258 < o.d0)
    goto _jump379;
    // End body of loop
    i _259 = { _254, _256, _257 };
    int64_t _260 = 0;
    _260 *= _227.d0;
    _260 += _252;
    _260 *= _227.d1;
    _260 += _251;
    _260 *= _227.d2;
    _260 += _250;
    _227.data[_260] = _259;
    _250++;
    if (_250 < _248)
    goto _jump377;
    _250 = 0;
    _251++;
    if (_251 < _241)
    goto _jump377;
    _251 = 0;
    _252++;
    if (_252 < _239)
    goto _jump377;
    // End body of loop
    bool _261 = true;
    _a2_rgba _262;
    if (!_261)
    goto _jump380;
    _262 = o;
    goto _jump381;
    _jump380:;
    _a1__a2_rgba _263;
    // Computing bound for y
    _263.d0 = r.d2;
    if (r.d2 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= r.d2;
    _264 *= sizeof(_a2_rgba);
    _263.data = jpl_alloc(_264);
    int64_t _265 = 0; // y
    _jump383:; // Begin body of loop
    int64_t _266 = 0;
    _266 *= _263.d0;
    _266 += _265;
    _263.data[_266] = o;
    _265++;
    if (_265 < r.d2)
    goto _jump383;
    // End body of loop
    if (c >= 0)
    goto _jump384;
    fail_assertion("negative array index");
    _jump384:;
    if (c < _263.d0)
    goto _jump385;
    fail_assertion("index too large");
    _jump385:;
    int64_t _267 = 0;
    _267 *= _263.d0;
    _267 += c;
    _a2_rgba _268 = _263.data[_267];
    _262 = _268;
    _jump381:;
    double _269 = 2.0;
    double _270 = 76.0;
    bool _271 = _269 == _270;
    bool _272;
    if (!_271)
    goto _jump386;
    bool _273 = true;
    _272 = _273;
    goto _jump387;
    _jump386:;
    bool _274 = false;
    bool _275 = !_274;
    bool _276 = !_275;
    _272 = _276;
    _jump387:;
    _a3_bool _277;
    if (!_272)
    goto _jump388;
    _a3_bool _278;
    // Computing bound for y
    _278.d0 = c;
    if (c > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    // Computing bound for z
    _278.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for A
    _278.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing total size of heap memory to allocate
    int64_t _279 = 1;
    _279 *= c;
    _279 *= o.d1;
    _279 *= o.d0;
    _279 *= sizeof(bool);
    _278.data = jpl_alloc(_279);
    int64_t _280 = 0; // A
    int64_t _281 = 0; // z
    int64_t _282 = 0; // y
    _jump392:; // Begin body of loop
    _a2_bool _283;
    // Computing bound for B
    _283.d0 = _280;
    if (_280 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing bound for C
    _283.d1 = b;
    if (b > 0) 
    goto _jump394;
    fail_assertion("non-positive loop bound");
    _jump394:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _280;
    _284 *= b;
    _284 *= sizeof(bool);
    _283.data = jpl_alloc(_284);
    int64_t _285 = 0; // C
    int64_t _286 = 0; // B
    _jump395:; // Begin body of loop
    bool _287 = true;
    int64_t _288 = 0;
    _288 *= _283.d0;
    _288 += _286;
    _288 *= _283.d1;
    _288 += _285;
    _283.data[_288] = _287;
    _285++;
    if (_285 < b)
    goto _jump395;
    _285 = 0;
    _286++;
    if (_286 < _280)
    goto _jump395;
    // End body of loop
    if (_282 >= 0)
    goto _jump396;
    fail_assertion("negative array index");
    _jump396:;
    if (_282 < _283.d0)
    goto _jump397;
    fail_assertion("index too large");
    _jump397:;
    if (_281 >= 0)
    goto _jump398;
    fail_assertion("negative array index");
    _jump398:;
    if (_281 < _283.d1)
    goto _jump399;
    fail_assertion("index too large");
    _jump399:;
    int64_t _289 = 0;
    _289 *= _283.d0;
    _289 += _282;
    _289 *= _283.d1;
    _289 += _281;
    bool _290 = _283.data[_289];
    int64_t _291 = 0;
    _291 *= _278.d0;
    _291 += _282;
    _291 *= _278.d1;
    _291 += _281;
    _291 *= _278.d2;
    _291 += _280;
    _278.data[_291] = _290;
    _280++;
    if (_280 < o.d0)
    goto _jump392;
    _280 = 0;
    _281++;
    if (_281 < o.d1)
    goto _jump392;
    _281 = 0;
    _282++;
    if (_282 < c)
    goto _jump392;
    // End body of loop
    _277 = _278;
    goto _jump400;
    _jump388:;
    bool _293 = false;
    bool _292 = _293;
    if (0 != _293)
    goto _jump401;
    bool _294 = false;
    _292 = _294;
    _jump401:;
    bool _295 = true;
    bool _296 = !_295;
    bool _297 = _292 != _296;
    _a3_bool _298;
    if (!_297)
    goto _jump402;
    _a1__a3_bool _299;
    _299.d0 = 2;
    _299.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _299.data[0] = r;
    _299.data[1] = r;
    if (c >= 0)
    goto _jump403;
    fail_assertion("negative array index");
    _jump403:;
    if (c < _299.d0)
    goto _jump404;
    fail_assertion("index too large");
    _jump404:;
    int64_t _300 = 0;
    _300 *= _299.d0;
    _300 += c;
    _a3_bool _301 = _299.data[_300];
    _298 = _301;
    goto _jump405;
    _jump402:;
    _a3__a3_bool _302;
    // Computing bound for y
    _302.d0 = o.d1;
    if (o.d1 > 0) 
    goto _jump406;
    fail_assertion("non-positive loop bound");
    _jump406:;
    // Computing bound for z
    _302.d1 = _225;
    if (_225 > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    // Computing bound for A
    int64_t _303 = 360;
    _302.d2 = _303;
    if (_303 > 0) 
    goto _jump408;
    fail_assertion("non-positive loop bound");
    _jump408:;
    // Computing total size of heap memory to allocate
    int64_t _304 = 1;
    _304 *= o.d1;
    _304 *= _225;
    _304 *= _303;
    _304 *= sizeof(_a3_bool);
    _302.data = jpl_alloc(_304);
    int64_t _305 = 0; // A
    int64_t _306 = 0; // z
    int64_t _307 = 0; // y
    _jump409:; // Begin body of loop
    int64_t _308 = 0;
    _308 *= _302.d0;
    _308 += _307;
    _308 *= _302.d1;
    _308 += _306;
    _308 *= _302.d2;
    _308 += _305;
    _302.data[_308] = r;
    _305++;
    if (_305 < _303)
    goto _jump409;
    _305 = 0;
    _306++;
    if (_306 < _225)
    goto _jump409;
    _306 = 0;
    _307++;
    if (_307 < o.d1)
    goto _jump409;
    // End body of loop
    int64_t _309;
    // Computing bound for y
    if (b > 0) 
    goto _jump410;
    fail_assertion("non-positive loop bound");
    _jump410:;
    _309 = 0;
    int64_t _310 = 0; // y
    _jump411:; // Begin body of loop
    _309 += r.d0;
    _310++;
    if (_310 < b)
    goto _jump411;
    // End body of loop
    if (o.d0 >= 0)
    goto _jump412;
    fail_assertion("negative array index");
    _jump412:;
    if (o.d0 < _302.d0)
    goto _jump413;
    fail_assertion("index too large");
    _jump413:;
    if (r.d0 >= 0)
    goto _jump414;
    fail_assertion("negative array index");
    _jump414:;
    if (r.d0 < _302.d1)
    goto _jump415;
    fail_assertion("index too large");
    _jump415:;
    if (_309 >= 0)
    goto _jump416;
    fail_assertion("negative array index");
    _jump416:;
    if (_309 < _302.d2)
    goto _jump417;
    fail_assertion("index too large");
    _jump417:;
    int64_t _311 = 0;
    _311 *= _302.d0;
    _311 += o.d0;
    _311 *= _302.d1;
    _311 += r.d0;
    _311 *= _302.d2;
    _311 += _309;
    _a3_bool _312 = _302.data[_311];
    _298 = _312;
    _jump405:;
    _277 = _298;
    _jump400:;
    void_t _313 = j(_227, _262, _277);
    int64_t _314 = 0;
    _314 *= _180.d0;
    _314 += _226;
    _314 *= _180.d1;
    _314 += _225;
    _314 *= _180.d2;
    _314 += _224;
    _180.data[_314] = _313;
    _224++;
    if (_224 < g)
    goto _jump357;
    _224 = 0;
    _225++;
    if (_225 < _222)
    goto _jump357;
    _225 = 0;
    _226++;
    if (_226 < _215)
    goto _jump357;
    // End body of loop
    int64_t _315;
    // Computing bound for v
    if (r.d2 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing bound for w
    int64_t _316;
    // Computing bound for v
    if (o.d0 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    // Computing bound for w
    _a1_bool _317;
    // Computing bound for v
    int64_t _318 = 449;
    _317.d0 = _318;
    if (_318 > 0) 
    goto _jump420;
    fail_assertion("non-positive loop bound");
    _jump420:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= _318;
    _319 *= sizeof(bool);
    _317.data = jpl_alloc(_319);
    int64_t _320 = 0; // v
    _jump421:; // Begin body of loop
    bool _322 = false;
    bool _321 = _322;
    if (0 == _322)
    goto _jump422;
    bool _323 = true;
    _321 = _323;
    _jump422:;
    int64_t _324 = 0;
    _324 *= _317.d0;
    _324 += _320;
    _317.data[_324] = _321;
    _320++;
    if (_320 < _318)
    goto _jump421;
    // End body of loop
    if (c >= 0)
    goto _jump423;
    fail_assertion("negative array index");
    _jump423:;
    if (c < _317.d0)
    goto _jump424;
    fail_assertion("index too large");
    _jump424:;
    int64_t _325 = 0;
    _325 *= _317.d0;
    _325 += c;
    bool _326 = _317.data[_325];
    int64_t _327;
    if (!_326)
    goto _jump425;
    int64_t _328;
    // Computing bound for v
    if (r.d1 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    // Computing bound for w
    int64_t _329 = -r.d1;
    if (_329 > 0) 
    goto _jump427;
    fail_assertion("non-positive loop bound");
    _jump427:;
    _328 = 0;
    int64_t _330 = 0; // w
    int64_t _331 = 0; // v
    _jump428:; // Begin body of loop
    _328 += k.d0;
    _330++;
    if (_330 < _329)
    goto _jump428;
    _330 = 0;
    _331++;
    if (_331 < r.d1)
    goto _jump428;
    // End body of loop
    _327 = _328;
    goto _jump429;
    _jump425:;
    int64_t _332 = 943;
    _327 = _332;
    _jump429:;
    if (_327 > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing bound for x
    if (o.d0 > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    _316 = 0;
    int64_t _333 = 0; // x
    int64_t _334 = 0; // w
    int64_t _335 = 0; // v
    _jump432:; // Begin body of loop
    _316 += _333;
    _333++;
    if (_333 < o.d0)
    goto _jump432;
    _333 = 0;
    _334++;
    if (_334 < _327)
    goto _jump432;
    _334 = 0;
    _335++;
    if (_335 < o.d0)
    goto _jump432;
    // End body of loop
    if (_316 > 0) 
    goto _jump433;
    fail_assertion("non-positive loop bound");
    _jump433:;
    _315 = 0;
    int64_t _336 = 0; // w
    int64_t _337 = 0; // v
    _jump434:; // Begin body of loop
    _315 += r.d2;
    _336++;
    if (_336 < _316)
    goto _jump434;
    _336 = 0;
    _337++;
    if (_337 < r.d2)
    goto _jump434;
    // End body of loop
    _a3_double _338;
    // Computing bound for v
    int64_t _339 = -r.d1;
    _338.d0 = _339;
    if (_339 > 0) 
    goto _jump435;
    fail_assertion("non-positive loop bound");
    _jump435:;
    // Computing bound for w
    _338.d1 = d;
    if (d > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    // Computing bound for x
    _338.d2 = c;
    if (c > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _340 = 1;
    _340 *= _339;
    _340 *= d;
    _340 *= c;
    _340 *= sizeof(double);
    _338.data = jpl_alloc(_340);
    int64_t _341 = 0; // x
    int64_t _342 = 0; // w
    int64_t _343 = 0; // v
    _jump438:; // Begin body of loop
    double _344 = 21.0;
    double _345 = -_344;
    int64_t _346 = 0;
    _346 *= _338.d0;
    _346 += _343;
    _346 *= _338.d1;
    _346 += _342;
    _346 *= _338.d2;
    _346 += _341;
    _338.data[_346] = _345;
    _341++;
    if (_341 < c)
    goto _jump438;
    _341 = 0;
    _342++;
    if (_342 < d)
    goto _jump438;
    _342 = 0;
    _343++;
    if (_343 < _339)
    goto _jump438;
    // End body of loop
    if (k.d0 >= 0)
    goto _jump439;
    fail_assertion("negative array index");
    _jump439:;
    if (k.d0 < _338.d0)
    goto _jump440;
    fail_assertion("index too large");
    _jump440:;
    if (r.d2 >= 0)
    goto _jump441;
    fail_assertion("negative array index");
    _jump441:;
    if (r.d2 < _338.d1)
    goto _jump442;
    fail_assertion("index too large");
    _jump442:;
    if (b >= 0)
    goto _jump443;
    fail_assertion("negative array index");
    _jump443:;
    if (b < _338.d2)
    goto _jump444;
    fail_assertion("index too large");
    _jump444:;
    int64_t _347 = 0;
    _347 *= _338.d0;
    _347 += k.d0;
    _347 *= _338.d1;
    _347 += r.d2;
    _347 *= _338.d2;
    _347 += b;
    double _348 = _338.data[_347];
    double _349 = 94.0;
    h _350 = { _349 };
    double _351 = _350.a;
    bool _352 = _348 > _351;
    double _353;
    // Computing bound for v
    if (k.d2 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    _353 = 0;
    int64_t _354 = 0; // v
    _jump446:; // Begin body of loop
    double _355 = 32.0;
    double _356 = -_355;
    double _357 = -_356;
    _353 += _357;
    _354++;
    if (_354 < k.d2)
    goto _jump446;
    // End body of loop
    h _358 = { _353 };
    i _359 = { _352, _358, d };
    int64_t _360 = _359.c;
    if (b >= 0)
    goto _jump447;
    fail_assertion("negative array index");
    _jump447:;
    if (b < _180.d0)
    goto _jump448;
    fail_assertion("index too large");
    _jump448:;
    if (_315 >= 0)
    goto _jump449;
    fail_assertion("negative array index");
    _jump449:;
    if (_315 < _180.d1)
    goto _jump450;
    fail_assertion("index too large");
    _jump450:;
    if (_360 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (_360 < _180.d2)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    int64_t _361 = 0;
    _361 *= _180.d0;
    _361 += b;
    _361 *= _180.d1;
    _361 += _315;
    _361 *= _180.d2;
    _361 += _360;
    void_t _362 = _180.data[_361];
    return _362;
    int64_t _363 = -k.d0;
    bool _364 = o.d1 > _363;
    bool _365 = !_364;
    bool _366 = !_365;
    bool _367 = !_366;
    bool _368 = !_367;
    bool _369 = !_368;
    if (0 != _369)
    goto _jump453;
    fail_assertion("v");
    _jump453:;
    _a3_bool _370;
    // Computing bound for v
    _370.d0 = k.d1;
    if (k.d1 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing bound for w
    int64_t _371 = g % d;
    _370.d1 = _371;
    if (_371 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for x
    _370.d2 = k.d1;
    if (k.d1 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing total size of heap memory to allocate
    int64_t _372 = 1;
    _372 *= k.d1;
    _372 *= _371;
    _372 *= k.d1;
    _372 *= sizeof(bool);
    _370.data = jpl_alloc(_372);
    int64_t _373 = 0; // x
    int64_t _374 = 0; // w
    int64_t _375 = 0; // v
    _jump457:; // Begin body of loop
    bool _377 = r.d2 == r.d1;
    bool _376 = _377;
    if (0 != _377)
    goto _jump458;
    int64_t _378 = 705;
    int64_t _379 = r.d2 % _378;
    bool _380 = _379 <= c;
    bool _381 = false;
    bool _382 = !_381;
    bool _383 = _380 == _382;
    _376 = _383;
    _jump458:;
    bool _384;
    if (!_376)
    goto _jump459;
    bool _385 = _375 == b;
    _384 = _385;
    goto _jump460;
    _jump459:;
    int64_t _386 = k.d2 + r.d0;
    bool _387 = _386 < _375;
    _384 = _387;
    _jump460:;
    bool _388 = !_384;
    int64_t _389 = 0;
    _389 *= _370.d0;
    _389 += _375;
    _389 *= _370.d1;
    _389 += _374;
    _389 *= _370.d2;
    _389 += _373;
    _370.data[_389] = _388;
    _373++;
    if (_373 < k.d1)
    goto _jump457;
    _373 = 0;
    _374++;
    if (_374 < _371)
    goto _jump457;
    _374 = 0;
    _375++;
    if (_375 < k.d1)
    goto _jump457;
    // End body of loop
    _a3_void_t _390;
    // Computing bound for B
    _390.d0 = d;
    if (d > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for C
    _390.d1 = _370.d0;
    if (_370.d0 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing bound for D
    _390.d2 = _370.d1;
    if (_370.d1 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= d;
    _391 *= _370.d0;
    _391 *= _370.d1;
    _391 *= sizeof(void_t);
    _390.data = jpl_alloc(_391);
    int64_t _392 = 0; // D
    int64_t _393 = 0; // C
    int64_t _394 = 0; // B
    _jump464:; // Begin body of loop
    _a3_void_t _395;
    // Computing bound for E
    _395.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump465;
    fail_assertion("non-positive loop bound");
    _jump465:;
    // Computing bound for F
    int64_t _396;
    // Computing bound for E
    if (_370.d0 > 0) 
    goto _jump466;
    fail_assertion("non-positive loop bound");
    _jump466:;
    // Computing bound for F
    int64_t _397 = 337;
    if (_397 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing bound for G
    if (b > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    _396 = 0;
    int64_t _398 = 0; // G
    int64_t _399 = 0; // F
    int64_t _400 = 0; // E
    _jump469:; // Begin body of loop
    _396 += _393;
    _398++;
    if (_398 < b)
    goto _jump469;
    _398 = 0;
    _399++;
    if (_399 < _397)
    goto _jump469;
    _399 = 0;
    _400++;
    if (_400 < _370.d0)
    goto _jump469;
    // End body of loop
    _395.d1 = _396;
    if (_396 > 0) 
    goto _jump470;
    fail_assertion("non-positive loop bound");
    _jump470:;
    // Computing bound for G
    _395.d2 = r.d0;
    if (r.d0 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing total size of heap memory to allocate
    int64_t _401 = 1;
    _401 *= r.d0;
    _401 *= _396;
    _401 *= r.d0;
    _401 *= sizeof(void_t);
    _395.data = jpl_alloc(_401);
    int64_t _402 = 0; // G
    int64_t _403 = 0; // F
    int64_t _404 = 0; // E
    _jump472:; // Begin body of loop
    _a2_rgba _405;
    // Computing bound for H
    _405.d0 = _403;
    if (_403 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for I
    _405.d1 = _370.d0;
    if (_370.d0 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _403;
    _406 *= _370.d0;
    _406 *= sizeof(rgba);
    _405.data = jpl_alloc(_406);
    int64_t _407 = 0; // I
    int64_t _408 = 0; // H
    _jump475:; // Begin body of loop
    if (c >= 0)
    goto _jump476;
    fail_assertion("negative array index");
    _jump476:;
    if (c < o.d0)
    goto _jump477;
    fail_assertion("index too large");
    _jump477:;
    if (r.d2 >= 0)
    goto _jump478;
    fail_assertion("negative array index");
    _jump478:;
    if (r.d2 < o.d1)
    goto _jump479;
    fail_assertion("index too large");
    _jump479:;
    int64_t _409 = 0;
    _409 *= o.d0;
    _409 += c;
    _409 *= o.d1;
    _409 += r.d2;
    rgba _410 = o.data[_409];
    int64_t _411 = 0;
    _411 *= _405.d0;
    _411 += _408;
    _411 *= _405.d1;
    _411 += _407;
    _405.data[_411] = _410;
    _407++;
    if (_407 < _370.d0)
    goto _jump475;
    _407 = 0;
    _408++;
    if (_408 < _403)
    goto _jump475;
    // End body of loop
    _a3_bool _412;
    // Computing bound for H
    _412.d0 = k.d2;
    if (k.d2 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for I
    _412.d1 = _370.d2;
    if (_370.d2 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    // Computing bound for J
    _412.d2 = c;
    if (c > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing total size of heap memory to allocate
    int64_t _413 = 1;
    _413 *= k.d2;
    _413 *= _370.d2;
    _413 *= c;
    _413 *= sizeof(bool);
    _412.data = jpl_alloc(_413);
    int64_t _414 = 0; // J
    int64_t _415 = 0; // I
    int64_t _416 = 0; // H
    _jump483:; // Begin body of loop
    bool _417 = false;
    int64_t _418 = 0;
    _418 *= _412.d0;
    _418 += _416;
    _418 *= _412.d1;
    _418 += _415;
    _418 *= _412.d2;
    _418 += _414;
    _412.data[_418] = _417;
    _414++;
    if (_414 < c)
    goto _jump483;
    _414 = 0;
    _415++;
    if (_415 < _370.d2)
    goto _jump483;
    _415 = 0;
    _416++;
    if (_416 < k.d2)
    goto _jump483;
    // End body of loop
    void_t _419 = j(k, _405, _412);
    int64_t _420 = 0;
    _420 *= _395.d0;
    _420 += _404;
    _420 *= _395.d1;
    _420 += _403;
    _420 *= _395.d2;
    _420 += _402;
    _395.data[_420] = _419;
    _402++;
    if (_402 < r.d0)
    goto _jump472;
    _402 = 0;
    _403++;
    if (_403 < _396)
    goto _jump472;
    _403 = 0;
    _404++;
    if (_404 < r.d0)
    goto _jump472;
    // End body of loop
    if (_393 >= 0)
    goto _jump484;
    fail_assertion("negative array index");
    _jump484:;
    if (_393 < _395.d0)
    goto _jump485;
    fail_assertion("index too large");
    _jump485:;
    if (d >= 0)
    goto _jump486;
    fail_assertion("negative array index");
    _jump486:;
    if (d < _395.d1)
    goto _jump487;
    fail_assertion("index too large");
    _jump487:;
    if (_394 >= 0)
    goto _jump488;
    fail_assertion("negative array index");
    _jump488:;
    if (_394 < _395.d2)
    goto _jump489;
    fail_assertion("index too large");
    _jump489:;
    int64_t _421 = 0;
    _421 *= _395.d0;
    _421 += _393;
    _421 *= _395.d1;
    _421 += d;
    _421 *= _395.d2;
    _421 += _394;
    void_t _422 = _395.data[_421];
    int64_t _423 = 0;
    _423 *= _390.d0;
    _423 += _394;
    _423 *= _390.d1;
    _423 += _393;
    _423 *= _390.d2;
    _423 += _392;
    _390.data[_423] = _422;
    _392++;
    if (_392 < _370.d1)
    goto _jump464;
    _392 = 0;
    _393++;
    if (_393 < _370.d0)
    goto _jump464;
    _393 = 0;
    _394++;
    if (_394 < d)
    goto _jump464;
    // End body of loop
    int64_t _424;
    // Computing bound for B
    if (r.d0 > 0) 
    goto _jump490;
    fail_assertion("non-positive loop bound");
    _jump490:;
    // Computing bound for C
    if (r.d1 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    _424 = 0;
    int64_t _425 = 0; // C
    int64_t _426 = 0; // B
    _jump492:; // Begin body of loop
    _424 += o.d0;
    _425++;
    if (_425 < r.d1)
    goto _jump492;
    _425 = 0;
    _426++;
    if (_426 < r.d0)
    goto _jump492;
    // End body of loop
    _a2_int64_t _427;
    // Computing bound for B
    _427.d0 = b;
    if (b > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for C
    _427.d1 = k.d1;
    if (k.d1 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= b;
    _428 *= k.d1;
    _428 *= sizeof(int64_t);
    _427.data = jpl_alloc(_428);
    int64_t _429 = 0; // C
    int64_t _430 = 0; // B
    _jump495:; // Begin body of loop
    int64_t _431 = 0;
    _431 *= _427.d0;
    _431 += _430;
    _431 *= _427.d1;
    _431 += _429;
    _427.data[_431] = b;
    _429++;
    if (_429 < k.d1)
    goto _jump495;
    _429 = 0;
    _430++;
    if (_430 < b)
    goto _jump495;
    // End body of loop
    if (c >= 0)
    goto _jump496;
    fail_assertion("negative array index");
    _jump496:;
    if (c < _427.d0)
    goto _jump497;
    fail_assertion("index too large");
    _jump497:;
    if (o.d1 >= 0)
    goto _jump498;
    fail_assertion("negative array index");
    _jump498:;
    if (o.d1 < _427.d1)
    goto _jump499;
    fail_assertion("index too large");
    _jump499:;
    int64_t _432 = 0;
    _432 *= _427.d0;
    _432 += c;
    _432 *= _427.d1;
    _432 += o.d1;
    int64_t _433 = _427.data[_432];
    if (_424 >= 0)
    goto _jump500;
    fail_assertion("negative array index");
    _jump500:;
    if (_424 < _390.d0)
    goto _jump501;
    fail_assertion("index too large");
    _jump501:;
    if (_433 >= 0)
    goto _jump502;
    fail_assertion("negative array index");
    _jump502:;
    if (_433 < _390.d1)
    goto _jump503;
    fail_assertion("index too large");
    _jump503:;
    if (r.d2 >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (r.d2 < _390.d2)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    int64_t _434 = 0;
    _434 *= _390.d0;
    _434 += _424;
    _434 *= _390.d1;
    _434 += _433;
    _434 *= _390.d2;
    _434 += r.d2;
    void_t _435 = _390.data[_434];
    return _435;
}

double n(_a3_rgba o, h s, _a2_h t) {
    bool _0 = false;
    bool _1 = !_0;
    bool _2 = !_1;
    _a3__a3_int64_t _3;
    if (!_2)
    goto _jump509;
    _a3__a3_int64_t _4;
    // Computing bound for w
    _4.d0 = m;
    if (m > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing bound for x
    _4.d1 = g;
    if (g > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    // Computing bound for y
    _4.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump512;
    fail_assertion("non-positive loop bound");
    _jump512:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= m;
    _5 *= g;
    _5 *= o.d1;
    _5 *= sizeof(_a3_int64_t);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // y
    int64_t _7 = 0; // x
    int64_t _8 = 0; // w
    _jump513:; // Begin body of loop
    _a3_int64_t _9;
    // Computing bound for z
    _9.d0 = d;
    if (d > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing bound for A
    _9.d1 = d;
    if (d > 0) 
    goto _jump515;
    fail_assertion("non-positive loop bound");
    _jump515:;
    // Computing bound for B
    _9.d2 = b;
    if (b > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= d;
    _10 *= d;
    _10 *= b;
    _10 *= sizeof(int64_t);
    _9.data = jpl_alloc(_10);
    int64_t _11 = 0; // B
    int64_t _12 = 0; // A
    int64_t _13 = 0; // z
    _jump517:; // Begin body of loop
    int64_t _14 = 0;
    _14 *= _9.d0;
    _14 += _13;
    _14 *= _9.d1;
    _14 += _12;
    _14 *= _9.d2;
    _14 += _11;
    _9.data[_14] = _12;
    _11++;
    if (_11 < b)
    goto _jump517;
    _11 = 0;
    _12++;
    if (_12 < d)
    goto _jump517;
    _12 = 0;
    _13++;
    if (_13 < d)
    goto _jump517;
    // End body of loop
    int64_t _15 = 0;
    _15 *= _4.d0;
    _15 += _8;
    _15 *= _4.d1;
    _15 += _7;
    _15 *= _4.d2;
    _15 += _6;
    _4.data[_15] = _9;
    _6++;
    if (_6 < o.d1)
    goto _jump513;
    _6 = 0;
    _7++;
    if (_7 < g)
    goto _jump513;
    _7 = 0;
    _8++;
    if (_8 < m)
    goto _jump513;
    // End body of loop
    _3 = _4;
    goto _jump518;
    _jump509:;
    _a3__a3_int64_t _16;
    // Computing bound for w
    _16.d0 = o.d2;
    if (o.d2 > 0) 
    goto _jump519;
    fail_assertion("non-positive loop bound");
    _jump519:;
    // Computing bound for x
    int64_t _17 = 995;
    int64_t _18 = _17 % m;
    _16.d1 = _18;
    if (_18 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing bound for y
    _16.d2 = t.d0;
    if (t.d0 > 0) 
    goto _jump521;
    fail_assertion("non-positive loop bound");
    _jump521:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= o.d2;
    _19 *= _18;
    _19 *= t.d0;
    _19 *= sizeof(_a3_int64_t);
    _16.data = jpl_alloc(_19);
    int64_t _20 = 0; // y
    int64_t _21 = 0; // x
    int64_t _22 = 0; // w
    _jump522:; // Begin body of loop
    _a3_int64_t _23;
    // Computing bound for z
    _23.d0 = t.d1;
    if (t.d1 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing bound for A
    int64_t _24 = 808;
    _23.d1 = _24;
    if (_24 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing bound for B
    _23.d2 = d;
    if (d > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= t.d1;
    _25 *= _24;
    _25 *= d;
    _25 *= sizeof(int64_t);
    _23.data = jpl_alloc(_25);
    int64_t _26 = 0; // B
    int64_t _27 = 0; // A
    int64_t _28 = 0; // z
    _jump526:; // Begin body of loop
    int64_t _29 = 0;
    _29 *= _23.d0;
    _29 += _28;
    _29 *= _23.d1;
    _29 += _27;
    _29 *= _23.d2;
    _29 += _26;
    _23.data[_29] = l;
    _26++;
    if (_26 < d)
    goto _jump526;
    _26 = 0;
    _27++;
    if (_27 < _24)
    goto _jump526;
    _27 = 0;
    _28++;
    if (_28 < t.d1)
    goto _jump526;
    // End body of loop
    int64_t _30 = 0;
    _30 *= _16.d0;
    _30 += _22;
    _30 *= _16.d1;
    _30 += _21;
    _30 *= _16.d2;
    _30 += _20;
    _16.data[_30] = _23;
    _20++;
    if (_20 < t.d0)
    goto _jump522;
    _20 = 0;
    _21++;
    if (_21 < _18)
    goto _jump522;
    _21 = 0;
    _22++;
    if (_22 < o.d2)
    goto _jump522;
    // End body of loop
    _3 = _16;
    _jump518:;
    _a3__a3_int64_t _31;
    // Computing bound for w
    int64_t _32 = -g;
    _31.d0 = _32;
    if (_32 > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing bound for x
    _31.d1 = o.d0;
    if (o.d0 > 0) 
    goto _jump528;
    fail_assertion("non-positive loop bound");
    _jump528:;
    // Computing bound for y
    _31.d2 = l;
    if (l > 0) 
    goto _jump529;
    fail_assertion("non-positive loop bound");
    _jump529:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= _32;
    _33 *= o.d0;
    _33 *= l;
    _33 *= sizeof(_a3_int64_t);
    _31.data = jpl_alloc(_33);
    int64_t _34 = 0; // y
    int64_t _35 = 0; // x
    int64_t _36 = 0; // w
    _jump530:; // Begin body of loop
    int64_t _37 = 0;
    _37 *= _31.d0;
    _37 += _36;
    _37 *= _31.d1;
    _37 += _35;
    _37 *= _31.d2;
    _37 += _34;
    _31.data[_37] = a;
    _34++;
    if (_34 < l)
    goto _jump530;
    _34 = 0;
    _35++;
    if (_35 < o.d0)
    goto _jump530;
    _35 = 0;
    _36++;
    if (_36 < _32)
    goto _jump530;
    // End body of loop
    _a1__a3__a3_int64_t _38;
    _38.d0 = 2;
    _38.data = jpl_alloc(sizeof(_a3__a3_int64_t) * 2);
    _38.data[0] = _3;
    _38.data[1] = _31;
    int64_t _39 = c % g;
    if (_39 >= 0)
    goto _jump531;
    fail_assertion("negative array index");
    _jump531:;
    if (_39 < _38.d0)
    goto _jump532;
    fail_assertion("index too large");
    _jump532:;
    int64_t _40 = 0;
    _40 *= _38.d0;
    _40 += _39;
    _a3__a3_int64_t _41 = _38.data[_40];
    bool _42 = true;
    double _43;
    // Computing bound for w
    if (t.d0 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing bound for x
    if (t.d0 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    _43 = 0;
    int64_t _44 = 0; // x
    int64_t _45 = 0; // w
    _jump535:; // Begin body of loop
    double _46 = 10.0;
    _43 += _46;
    _44++;
    if (_44 < t.d0)
    goto _jump535;
    _44 = 0;
    _45++;
    if (_45 < t.d0)
    goto _jump535;
    // End body of loop
    h _47 = { _43 };
    i _48 = { _42, _47, t.d0 };
    bool _49 = _48.a;
    int64_t _50;
    if (!_49)
    goto _jump536;
    _50 = m;
    goto _jump537;
    _jump536:;
    _50 = t.d1;
    _jump537:;
    int64_t _51 = 952;
    int64_t _52 = d + _51;
    if (_50 >= 0)
    goto _jump538;
    fail_assertion("negative array index");
    _jump538:;
    if (_50 < _41.d0)
    goto _jump539;
    fail_assertion("index too large");
    _jump539:;
    if (m >= 0)
    goto _jump540;
    fail_assertion("negative array index");
    _jump540:;
    if (m < _41.d1)
    goto _jump541;
    fail_assertion("index too large");
    _jump541:;
    if (_52 >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (_52 < _41.d2)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    int64_t _53 = 0;
    _53 *= _41.d0;
    _53 += _50;
    _53 *= _41.d1;
    _53 += m;
    _53 *= _41.d2;
    _53 += _52;
    _a3_int64_t _54 = _41.data[_53];
    if (m >= 0)
    goto _jump544;
    fail_assertion("negative array index");
    _jump544:;
    if (m < _54.d0)
    goto _jump545;
    fail_assertion("index too large");
    _jump545:;
    if (c >= 0)
    goto _jump546;
    fail_assertion("negative array index");
    _jump546:;
    if (c < _54.d1)
    goto _jump547;
    fail_assertion("index too large");
    _jump547:;
    if (o.d1 >= 0)
    goto _jump548;
    fail_assertion("negative array index");
    _jump548:;
    if (o.d1 < _54.d2)
    goto _jump549;
    fail_assertion("index too large");
    _jump549:;
    int64_t _55 = 0;
    _55 *= _54.d0;
    _55 += m;
    _55 *= _54.d1;
    _55 += c;
    _55 *= _54.d2;
    _55 += o.d1;
    int64_t _56 = _54.data[_55];
    _a2__a3__a2_h _57;
    // Computing bound for x
    _57.d0 = o.d2;
    if (o.d2 > 0) 
    goto _jump550;
    fail_assertion("non-positive loop bound");
    _jump550:;
    // Computing bound for y
    _57.d1 = g;
    if (g > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= o.d2;
    _58 *= g;
    _58 *= sizeof(_a3__a2_h);
    _57.data = jpl_alloc(_58);
    int64_t _59 = 0; // y
    int64_t _60 = 0; // x
    _jump552:; // Begin body of loop
    _a3__a2_h _61;
    // Computing bound for z
    _61.d0 = l;
    if (l > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for A
    _61.d1 = o.d2;
    if (o.d2 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for B
    _61.d2 = c;
    if (c > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing total size of heap memory to allocate
    int64_t _62 = 1;
    _62 *= l;
    _62 *= o.d2;
    _62 *= c;
    _62 *= sizeof(_a2_h);
    _61.data = jpl_alloc(_62);
    int64_t _63 = 0; // B
    int64_t _64 = 0; // A
    int64_t _65 = 0; // z
    _jump556:; // Begin body of loop
    int64_t _66 = 0;
    _66 *= _61.d0;
    _66 += _65;
    _66 *= _61.d1;
    _66 += _64;
    _66 *= _61.d2;
    _66 += _63;
    _61.data[_66] = t;
    _63++;
    if (_63 < c)
    goto _jump556;
    _63 = 0;
    _64++;
    if (_64 < o.d2)
    goto _jump556;
    _64 = 0;
    _65++;
    if (_65 < l)
    goto _jump556;
    // End body of loop
    int64_t _67 = 0;
    _67 *= _57.d0;
    _67 += _60;
    _67 *= _57.d1;
    _67 += _59;
    _57.data[_67] = _61;
    _59++;
    if (_59 < g)
    goto _jump552;
    _59 = 0;
    _60++;
    if (_60 < o.d2)
    goto _jump552;
    // End body of loop
    if (m >= 0)
    goto _jump557;
    fail_assertion("negative array index");
    _jump557:;
    if (m < _57.d0)
    goto _jump558;
    fail_assertion("index too large");
    _jump558:;
    if (d >= 0)
    goto _jump559;
    fail_assertion("negative array index");
    _jump559:;
    if (d < _57.d1)
    goto _jump560;
    fail_assertion("index too large");
    _jump560:;
    int64_t _68 = 0;
    _68 *= _57.d0;
    _68 += m;
    _68 *= _57.d1;
    _68 += d;
    _a3__a2_h _69 = _57.data[_68];
    _a1__a3__a2_h _70;
    _70.d0 = 1;
    _70.data = jpl_alloc(sizeof(_a3__a2_h) * 1);
    _70.data[0] = _69;
    int64_t _71 = 221;
    int64_t _72 = 358;
    if (_71 >= 0)
    goto _jump561;
    fail_assertion("negative array index");
    _jump561:;
    if (_71 < o.d0)
    goto _jump562;
    fail_assertion("index too large");
    _jump562:;
    if (l >= 0)
    goto _jump563;
    fail_assertion("negative array index");
    _jump563:;
    if (l < o.d1)
    goto _jump564;
    fail_assertion("index too large");
    _jump564:;
    if (_72 >= 0)
    goto _jump565;
    fail_assertion("negative array index");
    _jump565:;
    if (_72 < o.d2)
    goto _jump566;
    fail_assertion("index too large");
    _jump566:;
    int64_t _73 = 0;
    _73 *= o.d0;
    _73 += _71;
    _73 *= o.d1;
    _73 += l;
    _73 *= o.d2;
    _73 += _72;
    rgba _74 = o.data[_73];
    double _75 = _74.b;
    double _76 = s.a;
    bool _77 = _75 > _76;
    double _78 = s.a;
    double _79 = s.a;
    double _80 = _78 * _79;
    h _81 = { _80 };
    int64_t _82 = t.d1 - o.d1;
    i _83 = { _77, _81, _82 };
    int64_t _84 = _83.c;
    if (_84 >= 0)
    goto _jump567;
    fail_assertion("negative array index");
    _jump567:;
    if (_84 < _70.d0)
    goto _jump568;
    fail_assertion("index too large");
    _jump568:;
    int64_t _85 = 0;
    _85 *= _70.d0;
    _85 += _84;
    _a3__a2_h _86 = _70.data[_85];
    int64_t _87 = 699;
    if (_87 >= 0)
    goto _jump569;
    fail_assertion("negative array index");
    _jump569:;
    if (_87 < _86.d0)
    goto _jump570;
    fail_assertion("index too large");
    _jump570:;
    if (d >= 0)
    goto _jump571;
    fail_assertion("negative array index");
    _jump571:;
    if (d < _86.d1)
    goto _jump572;
    fail_assertion("index too large");
    _jump572:;
    if (m >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (m < _86.d2)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    int64_t _88 = 0;
    _88 *= _86.d0;
    _88 += _87;
    _88 *= _86.d1;
    _88 += d;
    _88 *= _86.d2;
    _88 += m;
    _a2_h _89 = _86.data[_88];
    bool _90 = false;
    _a2_h _91;
    if (!_90)
    goto _jump575;
    _91 = _89;
    goto _jump576;
    _jump575:;
    bool _92 = true;
    bool _93;
    if (!_92)
    goto _jump577;
    int64_t _94;
    // Computing bound for A
    if (_89.d1 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing bound for B
    int64_t _95 = -c;
    if (_95 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for C
    bool _96 = false;
    int64_t _97;
    if (!_96)
    goto _jump580;
    _97 = o.d1;
    goto _jump581;
    _jump580:;
    _97 = _56;
    _jump581:;
    if (_97 > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    _94 = 0;
    int64_t _98 = 0; // C
    int64_t _99 = 0; // B
    int64_t _100 = 0; // A
    _jump583:; // Begin body of loop
    _94 += d;
    _98++;
    if (_98 < _97)
    goto _jump583;
    _98 = 0;
    _99++;
    if (_99 < _95)
    goto _jump583;
    _99 = 0;
    _100++;
    if (_100 < _89.d1)
    goto _jump583;
    // End body of loop
    int64_t _101 = -_94;
    bool _102 = _56 <= _101;
    _93 = _102;
    goto _jump584;
    _jump577:;
    bool _103 = true;
    _93 = _103;
    _jump584:;
    _a2_h _104;
    if (!_93)
    goto _jump585;
    _104 = _89;
    goto _jump586;
    _jump585:;
    _104 = _89;
    _jump586:;
    _91 = _104;
    _jump576:;
    bool _105 = d >= o.d0;
    _a3_bool _106;
    if (!_105)
    goto _jump587;
    bool _107 = d < m;
    _a3_bool _108;
    if (!_107)
    goto _jump588;
    _a3_bool _109;
    // Computing bound for E
    _109.d0 = g;
    if (g > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing bound for F
    _109.d1 = g;
    if (g > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing bound for G
    int64_t _110 = -o.d1;
    _109.d2 = _110;
    if (_110 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= g;
    _111 *= g;
    _111 *= _110;
    _111 *= sizeof(bool);
    _109.data = jpl_alloc(_111);
    int64_t _112 = 0; // G
    int64_t _113 = 0; // F
    int64_t _114 = 0; // E
    _jump592:; // Begin body of loop
    bool _115 = o.d1 == t.d1;
    int64_t _116 = 0;
    _116 *= _109.d0;
    _116 += _114;
    _116 *= _109.d1;
    _116 += _113;
    _116 *= _109.d2;
    _116 += _112;
    _109.data[_116] = _115;
    _112++;
    if (_112 < _110)
    goto _jump592;
    _112 = 0;
    _113++;
    if (_113 < g)
    goto _jump592;
    _113 = 0;
    _114++;
    if (_114 < g)
    goto _jump592;
    // End body of loop
    _108 = _109;
    goto _jump593;
    _jump588:;
    _a3_bool _117;
    // Computing bound for E
    _117.d0 = t.d1;
    if (t.d1 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for F
    _117.d1 = _91.d0;
    if (_91.d0 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing bound for G
    _117.d2 = _56;
    if (_56 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= t.d1;
    _118 *= _91.d0;
    _118 *= _56;
    _118 *= sizeof(bool);
    _117.data = jpl_alloc(_118);
    int64_t _119 = 0; // G
    int64_t _120 = 0; // F
    int64_t _121 = 0; // E
    _jump597:; // Begin body of loop
    bool _122 = o.d0 == t.d1;
    int64_t _123 = 0;
    _123 *= _117.d0;
    _123 += _121;
    _123 *= _117.d1;
    _123 += _120;
    _123 *= _117.d2;
    _123 += _119;
    _117.data[_123] = _122;
    _119++;
    if (_119 < _56)
    goto _jump597;
    _119 = 0;
    _120++;
    if (_120 < _91.d0)
    goto _jump597;
    _120 = 0;
    _121++;
    if (_121 < t.d1)
    goto _jump597;
    // End body of loop
    _108 = _117;
    _jump593:;
    _106 = _108;
    goto _jump598;
    _jump587:;
    bool _124 = _89.d1 > _56;
    bool _125 = !_124;
    bool _126;
    if (!_125)
    goto _jump599;
    bool _127 = true;
    bool _128 = !_127;
    _126 = _128;
    goto _jump600;
    _jump599:;
    bool _129 = b == t.d1;
    _126 = _129;
    _jump600:;
    _a3_bool _130;
    if (!_126)
    goto _jump601;
    _a3_bool _131;
    // Computing bound for E
    bool _132 = true;
    bool _133 = !_132;
    int64_t _134;
    if (!_133)
    goto _jump602;
    _134 = b;
    goto _jump603;
    _jump602:;
    _134 = l;
    _jump603:;
    _131.d0 = _134;
    if (_134 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    // Computing bound for F
    _131.d1 = _91.d1;
    if (_91.d1 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for G
    _131.d2 = m;
    if (m > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= _134;
    _135 *= _91.d1;
    _135 *= m;
    _135 *= sizeof(bool);
    _131.data = jpl_alloc(_135);
    int64_t _136 = 0; // G
    int64_t _137 = 0; // F
    int64_t _138 = 0; // E
    _jump607:; // Begin body of loop
    bool _139 = false;
    bool _140 = !_139;
    bool _141 = false;
    bool _142 = _140 != _141;
    int64_t _143 = 0;
    _143 *= _131.d0;
    _143 += _138;
    _143 *= _131.d1;
    _143 += _137;
    _143 *= _131.d2;
    _143 += _136;
    _131.data[_143] = _142;
    _136++;
    if (_136 < m)
    goto _jump607;
    _136 = 0;
    _137++;
    if (_137 < _91.d1)
    goto _jump607;
    _137 = 0;
    _138++;
    if (_138 < _134)
    goto _jump607;
    // End body of loop
    _130 = _131;
    goto _jump608;
    _jump601:;
    _a3_bool _144;
    // Computing bound for E
    _144.d0 = o.d0;
    if (o.d0 > 0) 
    goto _jump609;
    fail_assertion("non-positive loop bound");
    _jump609:;
    // Computing bound for F
    _144.d1 = o.d2;
    if (o.d2 > 0) 
    goto _jump610;
    fail_assertion("non-positive loop bound");
    _jump610:;
    // Computing bound for G
    int64_t _145 = 395;
    _144.d2 = _145;
    if (_145 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= o.d0;
    _146 *= o.d2;
    _146 *= _145;
    _146 *= sizeof(bool);
    _144.data = jpl_alloc(_146);
    int64_t _147 = 0; // G
    int64_t _148 = 0; // F
    int64_t _149 = 0; // E
    _jump612:; // Begin body of loop
    bool _150 = t.d0 > o.d0;
    int64_t _151 = 0;
    _151 *= _144.d0;
    _151 += _149;
    _151 *= _144.d1;
    _151 += _148;
    _151 *= _144.d2;
    _151 += _147;
    _144.data[_151] = _150;
    _147++;
    if (_147 < _145)
    goto _jump612;
    _147 = 0;
    _148++;
    if (_148 < o.d2)
    goto _jump612;
    _148 = 0;
    _149++;
    if (_149 < o.d0)
    goto _jump612;
    // End body of loop
    _130 = _144;
    _jump608:;
    _106 = _130;
    _jump598:;
    int64_t _152 = -m;
    if (_152 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (_152 < _106.d0)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    if (m >= 0)
    goto _jump615;
    fail_assertion("negative array index");
    _jump615:;
    if (m < _106.d1)
    goto _jump616;
    fail_assertion("index too large");
    _jump616:;
    if (t.d1 >= 0)
    goto _jump617;
    fail_assertion("negative array index");
    _jump617:;
    if (t.d1 < _106.d2)
    goto _jump618;
    fail_assertion("index too large");
    _jump618:;
    int64_t _153 = 0;
    _153 *= _106.d0;
    _153 += _152;
    _153 *= _106.d1;
    _153 += m;
    _153 *= _106.d2;
    _153 += t.d1;
    bool _154 = _106.data[_153];
    _a3_int64_t _155;
    if (!_154)
    goto _jump619;
    double _156 = 45.0;
    double _157 = -_156;
    double _158 = -_157;
    double _159 = -_158;
    double _160;
    // Computing bound for E
    if (_56 > 0) 
    goto _jump620;
    fail_assertion("non-positive loop bound");
    _jump620:;
    // Computing bound for F
    if (o.d1 > 0) 
    goto _jump621;
    fail_assertion("non-positive loop bound");
    _jump621:;
    _160 = 0;
    int64_t _161 = 0; // F
    int64_t _162 = 0; // E
    _jump622:; // Begin body of loop
    bool _163 = false;
    double _164;
    if (!_163)
    goto _jump623;
    double _165 = 95.0;
    double _166 = -_165;
    _164 = _166;
    goto _jump624;
    _jump623:;
    bool _167 = true;
    double _168;
    if (!_167)
    goto _jump625;
    double _169 = 47.0;
    _168 = _169;
    goto _jump626;
    _jump625:;
    double _170 = 50.0;
    _168 = _170;
    _jump626:;
    _164 = _168;
    _jump624:;
    _160 += _164;
    _161++;
    if (_161 < o.d1)
    goto _jump622;
    _161 = 0;
    _162++;
    if (_162 < _56)
    goto _jump622;
    // End body of loop
    bool _171 = _159 >= _160;
    bool _172;
    if (!_171)
    goto _jump627;
    bool _174 = false;
    bool _173 = _174;
    if (0 != _174)
    goto _jump628;
    bool _175 = true;
    _173 = _175;
    _jump628:;
    bool _176;
    if (!_173)
    goto _jump629;
    bool _177 = false;
    _176 = _177;
    goto _jump630;
    _jump629:;
    bool _178 = o.d2 > t.d1;
    _176 = _178;
    _jump630:;
    _a1_bool _179;
    if (!_176)
    goto _jump631;
    bool _180 = m != g;
    bool _181 = false;
    _a1_bool _182;
    _182.d0 = 2;
    _182.data = jpl_alloc(sizeof(bool) * 2);
    _182.data[0] = _180;
    _182.data[1] = _181;
    _179 = _182;
    goto _jump632;
    _jump631:;
    bool _183 = true;
    _a1_bool _184;
    _184.d0 = 1;
    _184.data = jpl_alloc(sizeof(bool) * 1);
    _184.data[0] = _183;
    _179 = _184;
    _jump632:;
    if (_56 >= 0)
    goto _jump633;
    fail_assertion("negative array index");
    _jump633:;
    if (_56 < _179.d0)
    goto _jump634;
    fail_assertion("index too large");
    _jump634:;
    int64_t _185 = 0;
    _185 *= _179.d0;
    _185 += _56;
    bool _186 = _179.data[_185];
    _172 = _186;
    goto _jump635;
    _jump627:;
    bool _187 = true;
    bool _188;
    if (!_187)
    goto _jump636;
    bool _189 = _89.d1 == _56;
    _188 = _189;
    goto _jump637;
    _jump636:;
    bool _190 = true;
    _188 = _190;
    _jump637:;
    bool _191 = !_188;
    _172 = _191;
    _jump635:;
    _a3_int64_t _192;
    if (!_172)
    goto _jump638;
    bool _193 = false;
    _a3_int64_t _194;
    if (!_193)
    goto _jump639;
    _194 = a;
    goto _jump640;
    _jump639:;
    _a3_int64_t _195;
    // Computing bound for E
    _195.d0 = g;
    if (g > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing bound for F
    _195.d1 = c;
    if (c > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing bound for G
    _195.d2 = _56;
    if (_56 > 0) 
    goto _jump643;
    fail_assertion("non-positive loop bound");
    _jump643:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= g;
    _196 *= c;
    _196 *= _56;
    _196 *= sizeof(int64_t);
    _195.data = jpl_alloc(_196);
    int64_t _197 = 0; // G
    int64_t _198 = 0; // F
    int64_t _199 = 0; // E
    _jump644:; // Begin body of loop
    int64_t _200 = 0;
    _200 *= _195.d0;
    _200 += _199;
    _200 *= _195.d1;
    _200 += _198;
    _200 *= _195.d2;
    _200 += _197;
    _195.data[_200] = m;
    _197++;
    if (_197 < _56)
    goto _jump644;
    _197 = 0;
    _198++;
    if (_198 < c)
    goto _jump644;
    _198 = 0;
    _199++;
    if (_199 < g)
    goto _jump644;
    // End body of loop
    _194 = _195;
    _jump640:;
    _192 = _194;
    goto _jump645;
    _jump638:;
    _a1__a3__a3_int64_t _201;
    // Computing bound for E
    _201.d0 = _56;
    if (_56 > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _56;
    _202 *= sizeof(_a3__a3_int64_t);
    _201.data = jpl_alloc(_202);
    int64_t _203 = 0; // E
    _jump647:; // Begin body of loop
    _a3__a3_int64_t _204;
    // Computing bound for F
    _204.d0 = _56;
    if (_56 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing bound for G
    _204.d1 = c;
    if (c > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    // Computing bound for H
    _204.d2 = t.d0;
    if (t.d0 > 0) 
    goto _jump650;
    fail_assertion("non-positive loop bound");
    _jump650:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= _56;
    _205 *= c;
    _205 *= t.d0;
    _205 *= sizeof(_a3_int64_t);
    _204.data = jpl_alloc(_205);
    int64_t _206 = 0; // H
    int64_t _207 = 0; // G
    int64_t _208 = 0; // F
    _jump651:; // Begin body of loop
    int64_t _209 = 0;
    _209 *= _204.d0;
    _209 += _208;
    _209 *= _204.d1;
    _209 += _207;
    _209 *= _204.d2;
    _209 += _206;
    _204.data[_209] = a;
    _206++;
    if (_206 < t.d0)
    goto _jump651;
    _206 = 0;
    _207++;
    if (_207 < c)
    goto _jump651;
    _207 = 0;
    _208++;
    if (_208 < _56)
    goto _jump651;
    // End body of loop
    int64_t _210 = 0;
    _210 *= _201.d0;
    _210 += _203;
    _201.data[_210] = _204;
    _203++;
    if (_203 < _56)
    goto _jump647;
    // End body of loop
    if (o.d0 >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (o.d0 < _201.d0)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    int64_t _211 = 0;
    _211 *= _201.d0;
    _211 += o.d0;
    _a3__a3_int64_t _212 = _201.data[_211];
    _a3__a2_int64_t _213;
    // Computing bound for E
    _213.d0 = _56;
    if (_56 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing bound for F
    _213.d1 = b;
    if (b > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for G
    int64_t _214 = l * _56;
    _213.d2 = _214;
    if (_214 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing total size of heap memory to allocate
    int64_t _215 = 1;
    _215 *= _56;
    _215 *= b;
    _215 *= _214;
    _215 *= sizeof(_a2_int64_t);
    _213.data = jpl_alloc(_215);
    int64_t _216 = 0; // G
    int64_t _217 = 0; // F
    int64_t _218 = 0; // E
    _jump657:; // Begin body of loop
    int64_t _219 = 0;
    _219 *= _213.d0;
    _219 += _218;
    _219 *= _213.d1;
    _219 += _217;
    _219 *= _213.d2;
    _219 += _216;
    _213.data[_219] = k;
    _216++;
    if (_216 < _214)
    goto _jump657;
    _216 = 0;
    _217++;
    if (_217 < b)
    goto _jump657;
    _217 = 0;
    _218++;
    if (_218 < _56)
    goto _jump657;
    // End body of loop
    _a2_int64_t _220;
    // Computing bound for E
    _220.d0 = _89.d0;
    if (_89.d0 > 0) 
    goto _jump658;
    fail_assertion("non-positive loop bound");
    _jump658:;
    // Computing bound for F
    _220.d1 = g;
    if (g > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing total size of heap memory to allocate
    int64_t _221 = 1;
    _221 *= _89.d0;
    _221 *= g;
    _221 *= sizeof(int64_t);
    _220.data = jpl_alloc(_221);
    int64_t _222 = 0; // F
    int64_t _223 = 0; // E
    _jump660:; // Begin body of loop
    int64_t _224 = 0;
    _224 *= _220.d0;
    _224 += _223;
    _224 *= _220.d1;
    _224 += _222;
    _220.data[_224] = _222;
    _222++;
    if (_222 < g)
    goto _jump660;
    _222 = 0;
    _223++;
    if (_223 < _89.d0)
    goto _jump660;
    // End body of loop
    int64_t _225 = -d;
    if (_89.d1 >= 0)
    goto _jump661;
    fail_assertion("negative array index");
    _jump661:;
    if (_89.d1 < _220.d0)
    goto _jump662;
    fail_assertion("index too large");
    _jump662:;
    if (_225 >= 0)
    goto _jump663;
    fail_assertion("negative array index");
    _jump663:;
    if (_225 < _220.d1)
    goto _jump664;
    fail_assertion("index too large");
    _jump664:;
    int64_t _226 = 0;
    _226 *= _220.d0;
    _226 += _89.d1;
    _226 *= _220.d1;
    _226 += _225;
    int64_t _227 = _220.data[_226];
    if (o.d2 >= 0)
    goto _jump665;
    fail_assertion("negative array index");
    _jump665:;
    if (o.d2 < _213.d0)
    goto _jump666;
    fail_assertion("index too large");
    _jump666:;
    if (_227 >= 0)
    goto _jump667;
    fail_assertion("negative array index");
    _jump667:;
    if (_227 < _213.d1)
    goto _jump668;
    fail_assertion("index too large");
    _jump668:;
    if (_56 >= 0)
    goto _jump669;
    fail_assertion("negative array index");
    _jump669:;
    if (_56 < _213.d2)
    goto _jump670;
    fail_assertion("index too large");
    _jump670:;
    int64_t _228 = 0;
    _228 *= _213.d0;
    _228 += o.d2;
    _228 *= _213.d1;
    _228 += _227;
    _228 *= _213.d2;
    _228 += _56;
    _a2_int64_t _229 = _213.data[_228];
    if (g >= 0)
    goto _jump671;
    fail_assertion("negative array index");
    _jump671:;
    if (g < _229.d0)
    goto _jump672;
    fail_assertion("index too large");
    _jump672:;
    if (_56 >= 0)
    goto _jump673;
    fail_assertion("negative array index");
    _jump673:;
    if (_56 < _229.d1)
    goto _jump674;
    fail_assertion("index too large");
    _jump674:;
    int64_t _230 = 0;
    _230 *= _229.d0;
    _230 += g;
    _230 *= _229.d1;
    _230 += _56;
    int64_t _231 = _229.data[_230];
    int64_t _232 = b % _56;
    if (_56 >= 0)
    goto _jump675;
    fail_assertion("negative array index");
    _jump675:;
    if (_56 < _212.d0)
    goto _jump676;
    fail_assertion("index too large");
    _jump676:;
    if (_231 >= 0)
    goto _jump677;
    fail_assertion("negative array index");
    _jump677:;
    if (_231 < _212.d1)
    goto _jump678;
    fail_assertion("index too large");
    _jump678:;
    if (_232 >= 0)
    goto _jump679;
    fail_assertion("negative array index");
    _jump679:;
    if (_232 < _212.d2)
    goto _jump680;
    fail_assertion("index too large");
    _jump680:;
    int64_t _233 = 0;
    _233 *= _212.d0;
    _233 += _56;
    _233 *= _212.d1;
    _233 += _231;
    _233 *= _212.d2;
    _233 += _232;
    _a3_int64_t _234 = _212.data[_233];
    _192 = _234;
    _jump645:;
    _155 = _192;
    goto _jump681;
    _jump619:;
    bool _235 = false;
    _a2_h _236;
    // Computing bound for E
    _236.d0 = l;
    if (l > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing bound for F
    _236.d1 = _56;
    if (_56 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing total size of heap memory to allocate
    int64_t _237 = 1;
    _237 *= l;
    _237 *= _56;
    _237 *= sizeof(h);
    _236.data = jpl_alloc(_237);
    int64_t _238 = 0; // F
    int64_t _239 = 0; // E
    _jump684:; // Begin body of loop
    int64_t _240 = 0;
    _240 *= _236.d0;
    _240 += _239;
    _240 *= _236.d1;
    _240 += _238;
    _236.data[_240] = s;
    _238++;
    if (_238 < _56)
    goto _jump684;
    _238 = 0;
    _239++;
    if (_239 < l)
    goto _jump684;
    // End body of loop
    double _241 = n(o, s, _236);
    double _242 = s.a;
    bool _243 = _241 > _242;
    bool _244 = _235 != _243;
    _a3__a3_int64_t _245;
    if (!_244)
    goto _jump685;
    _a3__a3_int64_t _246;
    // Computing bound for E
    _246.d0 = l;
    if (l > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    // Computing bound for F
    _246.d1 = _56;
    if (_56 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing bound for G
    _246.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= l;
    _247 *= _56;
    _247 *= o.d1;
    _247 *= sizeof(_a3_int64_t);
    _246.data = jpl_alloc(_247);
    int64_t _248 = 0; // G
    int64_t _249 = 0; // F
    int64_t _250 = 0; // E
    _jump689:; // Begin body of loop
    _a3_int64_t _251;
    // Computing bound for H
    _251.d0 = d;
    if (d > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    // Computing bound for I
    _251.d1 = t.d1;
    if (t.d1 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for J
    _251.d2 = d;
    if (d > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing total size of heap memory to allocate
    int64_t _252 = 1;
    _252 *= d;
    _252 *= t.d1;
    _252 *= d;
    _252 *= sizeof(int64_t);
    _251.data = jpl_alloc(_252);
    int64_t _253 = 0; // J
    int64_t _254 = 0; // I
    int64_t _255 = 0; // H
    _jump693:; // Begin body of loop
    _a3_int64_t _256;
    // Computing bound for K
    _256.d0 = c;
    if (c > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    // Computing bound for L
    _256.d1 = t.d0;
    if (t.d0 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for M
    _256.d2 = l;
    if (l > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing total size of heap memory to allocate
    int64_t _257 = 1;
    _257 *= c;
    _257 *= t.d0;
    _257 *= l;
    _257 *= sizeof(int64_t);
    _256.data = jpl_alloc(_257);
    int64_t _258 = 0; // M
    int64_t _259 = 0; // L
    int64_t _260 = 0; // K
    _jump697:; // Begin body of loop
    int64_t _261 = 0;
    _261 *= _256.d0;
    _261 += _260;
    _261 *= _256.d1;
    _261 += _259;
    _261 *= _256.d2;
    _261 += _258;
    _256.data[_261] = _91.d1;
    _258++;
    if (_258 < l)
    goto _jump697;
    _258 = 0;
    _259++;
    if (_259 < t.d0)
    goto _jump697;
    _259 = 0;
    _260++;
    if (_260 < c)
    goto _jump697;
    // End body of loop
    if (d >= 0)
    goto _jump698;
    fail_assertion("negative array index");
    _jump698:;
    if (d < _256.d0)
    goto _jump699;
    fail_assertion("index too large");
    _jump699:;
    if (d >= 0)
    goto _jump700;
    fail_assertion("negative array index");
    _jump700:;
    if (d < _256.d1)
    goto _jump701;
    fail_assertion("index too large");
    _jump701:;
    if (_253 >= 0)
    goto _jump702;
    fail_assertion("negative array index");
    _jump702:;
    if (_253 < _256.d2)
    goto _jump703;
    fail_assertion("index too large");
    _jump703:;
    int64_t _262 = 0;
    _262 *= _256.d0;
    _262 += d;
    _262 *= _256.d1;
    _262 += d;
    _262 *= _256.d2;
    _262 += _253;
    int64_t _263 = _256.data[_262];
    int64_t _264 = 0;
    _264 *= _251.d0;
    _264 += _255;
    _264 *= _251.d1;
    _264 += _254;
    _264 *= _251.d2;
    _264 += _253;
    _251.data[_264] = _263;
    _253++;
    if (_253 < d)
    goto _jump693;
    _253 = 0;
    _254++;
    if (_254 < t.d1)
    goto _jump693;
    _254 = 0;
    _255++;
    if (_255 < d)
    goto _jump693;
    // End body of loop
    int64_t _265 = 0;
    _265 *= _246.d0;
    _265 += _250;
    _265 *= _246.d1;
    _265 += _249;
    _265 *= _246.d2;
    _265 += _248;
    _246.data[_265] = _251;
    _248++;
    if (_248 < o.d1)
    goto _jump689;
    _248 = 0;
    _249++;
    if (_249 < _56)
    goto _jump689;
    _249 = 0;
    _250++;
    if (_250 < l)
    goto _jump689;
    // End body of loop
    _245 = _246;
    goto _jump704;
    _jump685:;
    _a2__a3__a3_int64_t _266;
    // Computing bound for E
    _266.d0 = o.d2;
    if (o.d2 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing bound for F
    int64_t _267 = 572;
    _266.d1 = _267;
    if (_267 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    // Computing total size of heap memory to allocate
    int64_t _268 = 1;
    _268 *= o.d2;
    _268 *= _267;
    _268 *= sizeof(_a3__a3_int64_t);
    _266.data = jpl_alloc(_268);
    int64_t _269 = 0; // F
    int64_t _270 = 0; // E
    _jump707:; // Begin body of loop
    bool _271 = false;
    _a3__a3_int64_t _272;
    if (!_271)
    goto _jump708;
    _a3__a3_int64_t _273;
    // Computing bound for G
    _273.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump709;
    fail_assertion("non-positive loop bound");
    _jump709:;
    // Computing bound for H
    _273.d1 = l;
    if (l > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    // Computing bound for I
    _273.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= t.d0;
    _274 *= l;
    _274 *= o.d0;
    _274 *= sizeof(_a3_int64_t);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // I
    int64_t _276 = 0; // H
    int64_t _277 = 0; // G
    _jump712:; // Begin body of loop
    int64_t _278 = 0;
    _278 *= _273.d0;
    _278 += _277;
    _278 *= _273.d1;
    _278 += _276;
    _278 *= _273.d2;
    _278 += _275;
    _273.data[_278] = a;
    _275++;
    if (_275 < o.d0)
    goto _jump712;
    _275 = 0;
    _276++;
    if (_276 < l)
    goto _jump712;
    _276 = 0;
    _277++;
    if (_277 < t.d0)
    goto _jump712;
    // End body of loop
    _272 = _273;
    goto _jump713;
    _jump708:;
    _a3__a3_int64_t _279;
    // Computing bound for G
    _279.d0 = l;
    if (l > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for H
    _279.d1 = c;
    if (c > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    // Computing bound for I
    _279.d2 = _269;
    if (_269 > 0) 
    goto _jump716;
    fail_assertion("non-positive loop bound");
    _jump716:;
    // Computing total size of heap memory to allocate
    int64_t _280 = 1;
    _280 *= l;
    _280 *= c;
    _280 *= _269;
    _280 *= sizeof(_a3_int64_t);
    _279.data = jpl_alloc(_280);
    int64_t _281 = 0; // I
    int64_t _282 = 0; // H
    int64_t _283 = 0; // G
    _jump717:; // Begin body of loop
    int64_t _284 = 0;
    _284 *= _279.d0;
    _284 += _283;
    _284 *= _279.d1;
    _284 += _282;
    _284 *= _279.d2;
    _284 += _281;
    _279.data[_284] = a;
    _281++;
    if (_281 < _269)
    goto _jump717;
    _281 = 0;
    _282++;
    if (_282 < c)
    goto _jump717;
    _282 = 0;
    _283++;
    if (_283 < l)
    goto _jump717;
    // End body of loop
    _272 = _279;
    _jump713:;
    int64_t _285 = 0;
    _285 *= _266.d0;
    _285 += _270;
    _285 *= _266.d1;
    _285 += _269;
    _266.data[_285] = _272;
    _269++;
    if (_269 < _267)
    goto _jump707;
    _269 = 0;
    _270++;
    if (_270 < o.d2)
    goto _jump707;
    // End body of loop
    _a2_int64_t _286;
    // Computing bound for E
    _286.d0 = m;
    if (m > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for F
    _286.d1 = d;
    if (d > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= m;
    _287 *= d;
    _287 *= sizeof(int64_t);
    _286.data = jpl_alloc(_287);
    int64_t _288 = 0; // F
    int64_t _289 = 0; // E
    _jump720:; // Begin body of loop
    int64_t _290 = -b;
    int64_t _291 = 0;
    _291 *= _286.d0;
    _291 += _289;
    _291 *= _286.d1;
    _291 += _288;
    _286.data[_291] = _290;
    _288++;
    if (_288 < d)
    goto _jump720;
    _288 = 0;
    _289++;
    if (_289 < m)
    goto _jump720;
    // End body of loop
    if (t.d0 >= 0)
    goto _jump721;
    fail_assertion("negative array index");
    _jump721:;
    if (t.d0 < _286.d0)
    goto _jump722;
    fail_assertion("index too large");
    _jump722:;
    if (t.d1 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (t.d1 < _286.d1)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    int64_t _292 = 0;
    _292 *= _286.d0;
    _292 += t.d0;
    _292 *= _286.d1;
    _292 += t.d1;
    int64_t _293 = _286.data[_292];
    if (_293 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_293 < _266.d0)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    if (_56 >= 0)
    goto _jump727;
    fail_assertion("negative array index");
    _jump727:;
    if (_56 < _266.d1)
    goto _jump728;
    fail_assertion("index too large");
    _jump728:;
    int64_t _294 = 0;
    _294 *= _266.d0;
    _294 += _293;
    _294 *= _266.d1;
    _294 += _56;
    _a3__a3_int64_t _295 = _266.data[_294];
    _245 = _295;
    _jump704:;
    if (c >= 0)
    goto _jump729;
    fail_assertion("negative array index");
    _jump729:;
    if (c < _245.d0)
    goto _jump730;
    fail_assertion("index too large");
    _jump730:;
    if (b >= 0)
    goto _jump731;
    fail_assertion("negative array index");
    _jump731:;
    if (b < _245.d1)
    goto _jump732;
    fail_assertion("index too large");
    _jump732:;
    if (g >= 0)
    goto _jump733;
    fail_assertion("negative array index");
    _jump733:;
    if (g < _245.d2)
    goto _jump734;
    fail_assertion("index too large");
    _jump734:;
    int64_t _296 = 0;
    _296 *= _245.d0;
    _296 += c;
    _296 *= _245.d1;
    _296 += b;
    _296 *= _245.d2;
    _296 += g;
    _a3_int64_t _297 = _245.data[_296];
    _155 = _297;
    _jump681:;
    double _298 = 48.0;
    return _298;
}

rgba p(o q, int64_t r, rgba s) {
    _a3_double _0;
    // Computing bound for t
    _0.d0 = m;
    if (m > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing bound for u
    _0.d1 = c;
    if (c > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for v
    bool _1 = q.a;
    int64_t _2;
    if (!_1)
    goto _jump737;
    if (g >= 0)
    goto _jump738;
    fail_assertion("negative array index");
    _jump738:;
    if (g < f.d0)
    goto _jump739;
    fail_assertion("index too large");
    _jump739:;
    int64_t _3 = 0;
    _3 *= f.d0;
    _3 += g;
    int64_t _4 = f.data[_3];
    int64_t _5 = c - _4;
    _2 = _5;
    goto _jump740;
    _jump737:;
    int64_t _6 = 601;
    int64_t _7 = r + _6;
    int64_t _8 = _7 / m;
    _2 = _8;
    _jump740:;
    bool _9 = m != _2;
    double _10 = s.a;
    double _11 = 65.0;
    double _12 = _10 + _11;
    double _13 = -_12;
    h _14 = { _13 };
    bool _15 = false;
    double _16 = 56.0;
    double _17 = -_16;
    h _18 = { _17 };
    i _19 = { _15, _18, d };
    int64_t _20 = _19.c;
    i _21 = { _9, _14, _20 };
    int64_t _22 = _21.c;
    _0.d2 = _22;
    if (_22 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= m;
    _23 *= c;
    _23 *= _22;
    _23 *= sizeof(double);
    _0.data = jpl_alloc(_23);
    int64_t _24 = 0; // v
    int64_t _25 = 0; // u
    int64_t _26 = 0; // t
    _jump742:; // Begin body of loop
    double _27 = 44.0;
    double _28;
    // Computing bound for w
    if (g > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing bound for x
    if (l > 0) 
    goto _jump744;
    fail_assertion("non-positive loop bound");
    _jump744:;
    _28 = 0;
    int64_t _29 = 0; // x
    int64_t _30 = 0; // w
    _jump745:; // Begin body of loop
    double _31 = s.g;
    _28 += _31;
    _29++;
    if (_29 < l)
    goto _jump745;
    _29 = 0;
    _30++;
    if (_30 < g)
    goto _jump745;
    // End body of loop
    double _32 = _27 - _28;
    int64_t _33 = 0;
    _33 *= _0.d0;
    _33 += _26;
    _33 *= _0.d1;
    _33 += _25;
    _33 *= _0.d2;
    _33 += _24;
    _0.data[_33] = _32;
    _24++;
    if (_24 < _22)
    goto _jump742;
    _24 = 0;
    _25++;
    if (_25 < c)
    goto _jump742;
    _25 = 0;
    _26++;
    if (_26 < m)
    goto _jump742;
    // End body of loop
    _a3_rgba _34;
    // Computing bound for u
    _34.d0 = d;
    if (d > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing bound for v
    _34.d1 = d;
    if (d > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    // Computing bound for w
    int64_t _36 = 865;
    if (_36 >= 0)
    goto _jump748;
    fail_assertion("negative array index");
    _jump748:;
    if (_36 < e.d0)
    goto _jump749;
    fail_assertion("index too large");
    _jump749:;
    int64_t _37 = 0;
    _37 *= e.d0;
    _37 += _36;
    int64_t _38 = e.data[_37];
    bool _39 = c == _38;
    bool _35 = _39;
    if (0 != _39)
    goto _jump750;
    bool _41 = q.a;
    bool _40 = _41;
    if (0 != _41)
    goto _jump751;
    bool _42 = true;
    bool _43;
    if (!_42)
    goto _jump752;
    bool _44 = true;
    _43 = _44;
    goto _jump753;
    _jump752:;
    bool _45 = true;
    _43 = _45;
    _jump753:;
    _40 = _43;
    _jump751:;
    _35 = _40;
    _jump750:;
    _a3_double _46;
    // Computing bound for u
    _46.d0 = m;
    if (m > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    // Computing bound for v
    _46.d1 = d;
    if (d > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    // Computing bound for w
    int64_t _47 = 297;
    _46.d2 = _47;
    if (_47 > 0) 
    goto _jump756;
    fail_assertion("non-positive loop bound");
    _jump756:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= m;
    _48 *= d;
    _48 *= _47;
    _48 *= sizeof(double);
    _46.data = jpl_alloc(_48);
    int64_t _49 = 0; // w
    int64_t _50 = 0; // v
    int64_t _51 = 0; // u
    _jump757:; // Begin body of loop
    double _52 = 56.0;
    int64_t _53 = 0;
    _53 *= _46.d0;
    _53 += _51;
    _53 *= _46.d1;
    _53 += _50;
    _53 *= _46.d2;
    _53 += _49;
    _46.data[_53] = _52;
    _49++;
    if (_49 < _47)
    goto _jump757;
    _49 = 0;
    _50++;
    if (_50 < d)
    goto _jump757;
    _50 = 0;
    _51++;
    if (_51 < m)
    goto _jump757;
    // End body of loop
    if (r >= 0)
    goto _jump758;
    fail_assertion("negative array index");
    _jump758:;
    if (r < _46.d0)
    goto _jump759;
    fail_assertion("index too large");
    _jump759:;
    if (g >= 0)
    goto _jump760;
    fail_assertion("negative array index");
    _jump760:;
    if (g < _46.d1)
    goto _jump761;
    fail_assertion("index too large");
    _jump761:;
    if (l >= 0)
    goto _jump762;
    fail_assertion("negative array index");
    _jump762:;
    if (l < _46.d2)
    goto _jump763;
    fail_assertion("index too large");
    _jump763:;
    int64_t _54 = 0;
    _54 *= _46.d0;
    _54 += r;
    _54 *= _46.d1;
    _54 += g;
    _54 *= _46.d2;
    _54 += l;
    double _55 = _46.data[_54];
    h _56 = { _55 };
    bool _57 = m <= l;
    _a2_int64_t _58;
    if (!_57)
    goto _jump764;
    _a2_int64_t _59;
    // Computing bound for u
    _59.d0 = c;
    if (c > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    // Computing bound for v
    _59.d1 = g;
    if (g > 0) 
    goto _jump766;
    fail_assertion("non-positive loop bound");
    _jump766:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= c;
    _60 *= g;
    _60 *= sizeof(int64_t);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // v
    int64_t _62 = 0; // u
    _jump767:; // Begin body of loop
    int64_t _63 = 717;
    int64_t _64 = 0;
    _64 *= _59.d0;
    _64 += _62;
    _64 *= _59.d1;
    _64 += _61;
    _59.data[_64] = _63;
    _61++;
    if (_61 < g)
    goto _jump767;
    _61 = 0;
    _62++;
    if (_62 < c)
    goto _jump767;
    // End body of loop
    _58 = _59;
    goto _jump768;
    _jump764:;
    _a2_int64_t _65;
    // Computing bound for u
    _65.d0 = m;
    if (m > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    // Computing bound for v
    _65.d1 = m;
    if (m > 0) 
    goto _jump770;
    fail_assertion("non-positive loop bound");
    _jump770:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= m;
    _66 *= m;
    _66 *= sizeof(int64_t);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // v
    int64_t _68 = 0; // u
    _jump771:; // Begin body of loop
    int64_t _69 = 738;
    int64_t _70 = 0;
    _70 *= _65.d0;
    _70 += _68;
    _70 *= _65.d1;
    _70 += _67;
    _65.data[_70] = _69;
    _67++;
    if (_67 < m)
    goto _jump771;
    _67 = 0;
    _68++;
    if (_68 < m)
    goto _jump771;
    // End body of loop
    _58 = _65;
    _jump768:;
    if (m >= 0)
    goto _jump772;
    fail_assertion("negative array index");
    _jump772:;
    if (m < a.d0)
    goto _jump773;
    fail_assertion("index too large");
    _jump773:;
    if (r >= 0)
    goto _jump774;
    fail_assertion("negative array index");
    _jump774:;
    if (r < a.d1)
    goto _jump775;
    fail_assertion("index too large");
    _jump775:;
    if (g >= 0)
    goto _jump776;
    fail_assertion("negative array index");
    _jump776:;
    if (g < a.d2)
    goto _jump777;
    fail_assertion("index too large");
    _jump777:;
    int64_t _71 = 0;
    _71 *= a.d0;
    _71 += m;
    _71 *= a.d1;
    _71 += r;
    _71 *= a.d2;
    _71 += g;
    int64_t _72 = a.data[_71];
    int64_t _73 = -_72;
    if (m >= 0)
    goto _jump778;
    fail_assertion("negative array index");
    _jump778:;
    if (m < _58.d0)
    goto _jump779;
    fail_assertion("index too large");
    _jump779:;
    if (_73 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_73 < _58.d1)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _74 = 0;
    _74 *= _58.d0;
    _74 += m;
    _74 *= _58.d1;
    _74 += _73;
    int64_t _75 = _58.data[_74];
    i _76 = { _35, _56, _75 };
    int64_t _77 = _76.c;
    int64_t _78 = _77 - d;
    _34.d2 = _78;
    if (_78 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= d;
    _79 *= d;
    _79 *= _78;
    _79 *= sizeof(rgba);
    _34.data = jpl_alloc(_79);
    int64_t _80 = 0; // w
    int64_t _81 = 0; // v
    int64_t _82 = 0; // u
    _jump783:; // Begin body of loop
    bool _83 = g >= c;
    o _84 = { _83 };
    bool _85 = q.a;
    bool _86;
    if (!_85)
    goto _jump784;
    bool _87 = c <= c;
    _86 = _87;
    goto _jump785;
    _jump784:;
    bool _88 = q.a;
    _86 = _88;
    _jump785:;
    bool _89 = !_86;
    bool _90 = !_89;
    rgba _91;
    if (!_90)
    goto _jump786;
    _a3_rgba _92;
    // Computing bound for x
    bool _93 = true;
    int64_t _94;
    if (!_93)
    goto _jump787;
    _94 = m;
    goto _jump788;
    _jump787:;
    _94 = g;
    _jump788:;
    if (c >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (c < e.d0)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    int64_t _95 = 0;
    _95 *= e.d0;
    _95 += c;
    int64_t _96 = e.data[_95];
    int64_t _97 = _94 - _96;
    _92.d0 = _97;
    if (_97 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for y
    _a3_int64_t _98;
    // Computing bound for x
    _98.d0 = d;
    if (d > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing bound for y
    _98.d1 = b;
    if (b > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    // Computing bound for z
    int64_t _99 = 840;
    _98.d2 = _99;
    if (_99 > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= d;
    _100 *= b;
    _100 *= _99;
    _100 *= sizeof(int64_t);
    _98.data = jpl_alloc(_100);
    int64_t _101 = 0; // z
    int64_t _102 = 0; // y
    int64_t _103 = 0; // x
    _jump795:; // Begin body of loop
    int64_t _104 = 0;
    _104 *= _98.d0;
    _104 += _103;
    _104 *= _98.d1;
    _104 += _102;
    _104 *= _98.d2;
    _104 += _101;
    _98.data[_104] = c;
    _101++;
    if (_101 < _99)
    goto _jump795;
    _101 = 0;
    _102++;
    if (_102 < b)
    goto _jump795;
    _102 = 0;
    _103++;
    if (_103 < d)
    goto _jump795;
    // End body of loop
    if (g >= 0)
    goto _jump796;
    fail_assertion("negative array index");
    _jump796:;
    if (g < _98.d0)
    goto _jump797;
    fail_assertion("index too large");
    _jump797:;
    if (c >= 0)
    goto _jump798;
    fail_assertion("negative array index");
    _jump798:;
    if (c < _98.d1)
    goto _jump799;
    fail_assertion("index too large");
    _jump799:;
    if (_80 >= 0)
    goto _jump800;
    fail_assertion("negative array index");
    _jump800:;
    if (_80 < _98.d2)
    goto _jump801;
    fail_assertion("index too large");
    _jump801:;
    int64_t _105 = 0;
    _105 *= _98.d0;
    _105 += g;
    _105 *= _98.d1;
    _105 += c;
    _105 *= _98.d2;
    _105 += _80;
    int64_t _106 = _98.data[_105];
    _92.d1 = _106;
    if (_106 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing bound for z
    _92.d2 = _81;
    if (_81 > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= _97;
    _107 *= _106;
    _107 *= _81;
    _107 *= sizeof(rgba);
    _92.data = jpl_alloc(_107);
    int64_t _108 = 0; // z
    int64_t _109 = 0; // y
    int64_t _110 = 0; // x
    _jump804:; // Begin body of loop
    _a3_rgba _111;
    // Computing bound for A
    _111.d0 = _109;
    if (_109 > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing bound for B
    _111.d1 = _81;
    if (_81 > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    // Computing bound for C
    _111.d2 = r;
    if (r > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _109;
    _112 *= _81;
    _112 *= r;
    _112 *= sizeof(rgba);
    _111.data = jpl_alloc(_112);
    int64_t _113 = 0; // C
    int64_t _114 = 0; // B
    int64_t _115 = 0; // A
    _jump808:; // Begin body of loop
    int64_t _116 = 0;
    _116 *= _111.d0;
    _116 += _115;
    _116 *= _111.d1;
    _116 += _114;
    _116 *= _111.d2;
    _116 += _113;
    _111.data[_116] = s;
    _113++;
    if (_113 < r)
    goto _jump808;
    _113 = 0;
    _114++;
    if (_114 < _81)
    goto _jump808;
    _114 = 0;
    _115++;
    if (_115 < _109)
    goto _jump808;
    // End body of loop
    int64_t _117 = -_82;
    if (d >= 0)
    goto _jump809;
    fail_assertion("negative array index");
    _jump809:;
    if (d < _111.d0)
    goto _jump810;
    fail_assertion("index too large");
    _jump810:;
    if (_117 >= 0)
    goto _jump811;
    fail_assertion("negative array index");
    _jump811:;
    if (_117 < _111.d1)
    goto _jump812;
    fail_assertion("index too large");
    _jump812:;
    if (_110 >= 0)
    goto _jump813;
    fail_assertion("negative array index");
    _jump813:;
    if (_110 < _111.d2)
    goto _jump814;
    fail_assertion("index too large");
    _jump814:;
    int64_t _118 = 0;
    _118 *= _111.d0;
    _118 += d;
    _118 *= _111.d1;
    _118 += _117;
    _118 *= _111.d2;
    _118 += _110;
    rgba _119 = _111.data[_118];
    int64_t _120 = 0;
    _120 *= _92.d0;
    _120 += _110;
    _120 *= _92.d1;
    _120 += _109;
    _120 *= _92.d2;
    _120 += _108;
    _92.data[_120] = _119;
    _108++;
    if (_108 < _81)
    goto _jump804;
    _108 = 0;
    _109++;
    if (_109 < _106)
    goto _jump804;
    _109 = 0;
    _110++;
    if (_110 < _97)
    goto _jump804;
    // End body of loop
    int64_t _121;
    // Computing bound for x
    int64_t _122 = _82 / r;
    if (_122 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (_122 < e.d0)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    int64_t _123 = 0;
    _123 *= e.d0;
    _123 += _122;
    int64_t _124 = e.data[_123];
    if (_124 > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for y
    int64_t _125;
    // Computing bound for x
    int64_t _126 = 95;
    if (_126 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for y
    int64_t _127 = -_82;
    if (_127 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    // Computing bound for z
    int64_t _128;
    // Computing bound for x
    if (g > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    _128 = 0;
    int64_t _129 = 0; // x
    _jump821:; // Begin body of loop
    int64_t _130 = 952;
    _128 += _130;
    _129++;
    if (_129 < g)
    goto _jump821;
    // End body of loop
    if (_128 > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    _125 = 0;
    int64_t _131 = 0; // z
    int64_t _132 = 0; // y
    int64_t _133 = 0; // x
    _jump823:; // Begin body of loop
    _125 += d;
    _131++;
    if (_131 < _128)
    goto _jump823;
    _131 = 0;
    _132++;
    if (_132 < _127)
    goto _jump823;
    _132 = 0;
    _133++;
    if (_133 < _126)
    goto _jump823;
    // End body of loop
    if (_125 > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    _121 = 0;
    int64_t _134 = 0; // y
    int64_t _135 = 0; // x
    _jump825:; // Begin body of loop
    _121 += l;
    _134++;
    if (_134 < _125)
    goto _jump825;
    _134 = 0;
    _135++;
    if (_135 < _124)
    goto _jump825;
    // End body of loop
    if (l >= 0)
    goto _jump826;
    fail_assertion("negative array index");
    _jump826:;
    if (l < _92.d0)
    goto _jump827;
    fail_assertion("index too large");
    _jump827:;
    if (c >= 0)
    goto _jump828;
    fail_assertion("negative array index");
    _jump828:;
    if (c < _92.d1)
    goto _jump829;
    fail_assertion("index too large");
    _jump829:;
    if (_121 >= 0)
    goto _jump830;
    fail_assertion("negative array index");
    _jump830:;
    if (_121 < _92.d2)
    goto _jump831;
    fail_assertion("index too large");
    _jump831:;
    int64_t _136 = 0;
    _136 *= _92.d0;
    _136 += l;
    _136 *= _92.d1;
    _136 += c;
    _136 *= _92.d2;
    _136 += _121;
    rgba _137 = _92.data[_136];
    _91 = _137;
    goto _jump832;
    _jump786:;
    _91 = s;
    _jump832:;
    rgba _138 = p(_84, _80, _91);
    int64_t _139 = 0;
    _139 *= _34.d0;
    _139 += _82;
    _139 *= _34.d1;
    _139 += _81;
    _139 *= _34.d2;
    _139 += _80;
    _34.data[_139] = _138;
    _80++;
    if (_80 < _78)
    goto _jump783;
    _80 = 0;
    _81++;
    if (_81 < d)
    goto _jump783;
    _81 = 0;
    _82++;
    if (_82 < d)
    goto _jump783;
    // End body of loop
    _a2_double _140;
    // Computing bound for y
    int64_t _141 = 430;
    int64_t _142 = _141 - _34.d1;
    _140.d0 = _142;
    if (_142 > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for z
    _140.d1 = _34.d2;
    if (_34.d2 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= _142;
    _143 *= _34.d2;
    _143 *= sizeof(double);
    _140.data = jpl_alloc(_143);
    int64_t _144 = 0; // z
    int64_t _145 = 0; // y
    _jump835:; // Begin body of loop
    double _146;
    // Computing bound for A
    if (l > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for B
    if (g > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for C
    int64_t _147;
    // Computing bound for A
    int64_t _148 = 391;
    if (_148 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    _147 = 0;
    int64_t _149 = 0; // A
    _jump839:; // Begin body of loop
    int64_t _150 = 277;
    _147 += _150;
    _149++;
    if (_149 < _148)
    goto _jump839;
    // End body of loop
    if (_147 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    _146 = 0;
    int64_t _151 = 0; // C
    int64_t _152 = 0; // B
    int64_t _153 = 0; // A
    _jump841:; // Begin body of loop
    double _154 = 54.0;
    _146 += _154;
    _151++;
    if (_151 < _147)
    goto _jump841;
    _151 = 0;
    _152++;
    if (_152 < g)
    goto _jump841;
    _152 = 0;
    _153++;
    if (_153 < l)
    goto _jump841;
    // End body of loop
    int64_t _155 = 0;
    _155 *= _140.d0;
    _155 += _145;
    _155 *= _140.d1;
    _155 += _144;
    _140.data[_155] = _146;
    _144++;
    if (_144 < _34.d2)
    goto _jump835;
    _144 = 0;
    _145++;
    if (_145 < _142)
    goto _jump835;
    // End body of loop
    if (b >= 0)
    goto _jump842;
    fail_assertion("negative array index");
    _jump842:;
    if (b < _140.d0)
    goto _jump843;
    fail_assertion("index too large");
    _jump843:;
    if (_34.d2 >= 0)
    goto _jump844;
    fail_assertion("negative array index");
    _jump844:;
    if (_34.d2 < _140.d1)
    goto _jump845;
    fail_assertion("index too large");
    _jump845:;
    int64_t _156 = 0;
    _156 *= _140.d0;
    _156 += b;
    _156 *= _140.d1;
    _156 += _34.d2;
    double _157 = _140.data[_156];
    double _158 = -_157;
    _a3_bool _159;
    // Computing bound for y
    int64_t _160;
    // Computing bound for y
    if (_34.d0 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    _160 = 0;
    int64_t _161 = 0; // y
    _jump847:; // Begin body of loop
    int64_t _162 = 218;
    _160 += _162;
    _161++;
    if (_161 < _34.d0)
    goto _jump847;
    // End body of loop
    _159.d0 = _160;
    if (_160 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing bound for z
    int64_t _163 = 589;
    if (_163 >= 0)
    goto _jump849;
    fail_assertion("negative array index");
    _jump849:;
    if (_163 < k.d0)
    goto _jump850;
    fail_assertion("index too large");
    _jump850:;
    if (_34.d0 >= 0)
    goto _jump851;
    fail_assertion("negative array index");
    _jump851:;
    if (_34.d0 < k.d1)
    goto _jump852;
    fail_assertion("index too large");
    _jump852:;
    int64_t _164 = 0;
    _164 *= k.d0;
    _164 += _163;
    _164 *= k.d1;
    _164 += _34.d0;
    int64_t _165 = k.data[_164];
    _159.d1 = _165;
    if (_165 > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing bound for A
    _159.d2 = g;
    if (g > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= _160;
    _166 *= _165;
    _166 *= g;
    _166 *= sizeof(bool);
    _159.data = jpl_alloc(_166);
    int64_t _167 = 0; // A
    int64_t _168 = 0; // z
    int64_t _169 = 0; // y
    _jump855:; // Begin body of loop
    bool _170 = false;
    int64_t _171 = 0;
    _171 *= _159.d0;
    _171 += _169;
    _171 *= _159.d1;
    _171 += _168;
    _171 *= _159.d2;
    _171 += _167;
    _159.data[_171] = _170;
    _167++;
    if (_167 < g)
    goto _jump855;
    _167 = 0;
    _168++;
    if (_168 < _165)
    goto _jump855;
    _168 = 0;
    _169++;
    if (_169 < _160)
    goto _jump855;
    // End body of loop
    int64_t _172;
    // Computing bound for y
    if (g > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    _172 = 0;
    int64_t _173 = 0; // y
    _jump857:; // Begin body of loop
    int64_t _174;
    // Computing bound for z
    if (c > 0) 
    goto _jump858;
    fail_assertion("non-positive loop bound");
    _jump858:;
    // Computing bound for A
    if (g > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    _174 = 0;
    int64_t _175 = 0; // A
    int64_t _176 = 0; // z
    _jump860:; // Begin body of loop
    _174 += _173;
    _175++;
    if (_175 < g)
    goto _jump860;
    _175 = 0;
    _176++;
    if (_176 < c)
    goto _jump860;
    // End body of loop
    _172 += _174;
    _173++;
    if (_173 < g)
    goto _jump857;
    // End body of loop
    if (m >= 0)
    goto _jump861;
    fail_assertion("negative array index");
    _jump861:;
    if (m < _159.d0)
    goto _jump862;
    fail_assertion("index too large");
    _jump862:;
    if (b >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (b < _159.d1)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    if (_172 >= 0)
    goto _jump865;
    fail_assertion("negative array index");
    _jump865:;
    if (_172 < _159.d2)
    goto _jump866;
    fail_assertion("index too large");
    _jump866:;
    int64_t _177 = 0;
    _177 *= _159.d0;
    _177 += m;
    _177 *= _159.d1;
    _177 += b;
    _177 *= _159.d2;
    _177 += _172;
    bool _178 = _159.data[_177];
    h _179;
    if (!_178)
    goto _jump867;
    bool _180 = l > c;
    h _181;
    if (!_180)
    goto _jump868;
    double _182;
    // Computing bound for y
    int64_t _183 = 364;
    if (_183 > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    _182 = 0;
    int64_t _184 = 0; // y
    _jump870:; // Begin body of loop
    double _185 = 20.0;
    _182 += _185;
    _184++;
    if (_184 < _183)
    goto _jump870;
    // End body of loop
    h _186 = { _182 };
    _181 = _186;
    goto _jump871;
    _jump868:;
    double _187 = 30.0;
    h _188 = { _187 };
    _181 = _188;
    _jump871:;
    _179 = _181;
    goto _jump872;
    _jump867:;
    double _189 = 6.0;
    h _190 = { _189 };
    _179 = _190;
    _jump872:;
    double _191 = _179.a;
    bool _192 = _158 != _191;
    _a1_int64_t _193;
    if (!_192)
    goto _jump873;
    double _194 = 77.0;
    double _195 = 3.0;
    double _196 = fmod(_194, _195);
    h _197 = { _196 };
    double _198 = _197.a;
    _a3_double _199;
    // Computing bound for y
    int64_t _200 = b / r;
    _199.d0 = _200;
    if (_200 > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing bound for z
    _199.d1 = _34.d0;
    if (_34.d0 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for A
    int64_t _201 = -_34.d2;
    _199.d2 = _201;
    if (_201 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _200;
    _202 *= _34.d0;
    _202 *= _201;
    _202 *= sizeof(double);
    _199.data = jpl_alloc(_202);
    int64_t _203 = 0; // A
    int64_t _204 = 0; // z
    int64_t _205 = 0; // y
    _jump877:; // Begin body of loop
    if (d >= 0)
    goto _jump878;
    fail_assertion("negative array index");
    _jump878:;
    if (d < _0.d0)
    goto _jump879;
    fail_assertion("index too large");
    _jump879:;
    if (r >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (r < _0.d1)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    if (_34.d1 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_34.d1 < _0.d2)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    int64_t _206 = 0;
    _206 *= _0.d0;
    _206 += d;
    _206 *= _0.d1;
    _206 += r;
    _206 *= _0.d2;
    _206 += _34.d1;
    double _207 = _0.data[_206];
    int64_t _208 = 0;
    _208 *= _199.d0;
    _208 += _205;
    _208 *= _199.d1;
    _208 += _204;
    _208 *= _199.d2;
    _208 += _203;
    _199.data[_208] = _207;
    _203++;
    if (_203 < _201)
    goto _jump877;
    _203 = 0;
    _204++;
    if (_204 < _34.d0)
    goto _jump877;
    _204 = 0;
    _205++;
    if (_205 < _200)
    goto _jump877;
    // End body of loop
    if (b >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (b < _199.d0)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    if (r >= 0)
    goto _jump886;
    fail_assertion("negative array index");
    _jump886:;
    if (r < _199.d1)
    goto _jump887;
    fail_assertion("index too large");
    _jump887:;
    if (c >= 0)
    goto _jump888;
    fail_assertion("negative array index");
    _jump888:;
    if (c < _199.d2)
    goto _jump889;
    fail_assertion("index too large");
    _jump889:;
    int64_t _209 = 0;
    _209 *= _199.d0;
    _209 += b;
    _209 *= _199.d1;
    _209 += r;
    _209 *= _199.d2;
    _209 += c;
    double _210 = _199.data[_209];
    double _211 = _198 / _210;
    double _212 = 77.0;
    bool _213 = _211 == _212;
    _a1_int64_t _214;
    if (!_213)
    goto _jump890;
    bool _215 = false;
    bool _216 = true;
    double _217;
    if (!_216)
    goto _jump891;
    double _218 = 64.0;
    _217 = _218;
    goto _jump892;
    _jump891:;
    double _219 = 49.0;
    _217 = _219;
    _jump892:;
    h _220 = { _217 };
    i _221 = { _215, _220, g };
    bool _222 = _221.a;
    _a1_int64_t _223;
    if (!_222)
    goto _jump893;
    _a2_bool _224;
    // Computing bound for y
    _224.d0 = r;
    if (r > 0) 
    goto _jump894;
    fail_assertion("non-positive loop bound");
    _jump894:;
    // Computing bound for z
    _224.d1 = b;
    if (b > 0) 
    goto _jump895;
    fail_assertion("non-positive loop bound");
    _jump895:;
    // Computing total size of heap memory to allocate
    int64_t _225 = 1;
    _225 *= r;
    _225 *= b;
    _225 *= sizeof(bool);
    _224.data = jpl_alloc(_225);
    int64_t _226 = 0; // z
    int64_t _227 = 0; // y
    _jump896:; // Begin body of loop
    bool _228 = true;
    int64_t _229 = 0;
    _229 *= _224.d0;
    _229 += _227;
    _229 *= _224.d1;
    _229 += _226;
    _224.data[_229] = _228;
    _226++;
    if (_226 < b)
    goto _jump896;
    _226 = 0;
    _227++;
    if (_227 < r)
    goto _jump896;
    // End body of loop
    if (_34.d0 >= 0)
    goto _jump897;
    fail_assertion("negative array index");
    _jump897:;
    if (_34.d0 < a.d0)
    goto _jump898;
    fail_assertion("index too large");
    _jump898:;
    if (_34.d2 >= 0)
    goto _jump899;
    fail_assertion("negative array index");
    _jump899:;
    if (_34.d2 < a.d1)
    goto _jump900;
    fail_assertion("index too large");
    _jump900:;
    if (l >= 0)
    goto _jump901;
    fail_assertion("negative array index");
    _jump901:;
    if (l < a.d2)
    goto _jump902;
    fail_assertion("index too large");
    _jump902:;
    int64_t _230 = 0;
    _230 *= a.d0;
    _230 += _34.d0;
    _230 *= a.d1;
    _230 += _34.d2;
    _230 *= a.d2;
    _230 += l;
    int64_t _231 = a.data[_230];
    if (_231 >= 0)
    goto _jump903;
    fail_assertion("negative array index");
    _jump903:;
    if (_231 < _224.d0)
    goto _jump904;
    fail_assertion("index too large");
    _jump904:;
    if (r >= 0)
    goto _jump905;
    fail_assertion("negative array index");
    _jump905:;
    if (r < _224.d1)
    goto _jump906;
    fail_assertion("index too large");
    _jump906:;
    int64_t _232 = 0;
    _232 *= _224.d0;
    _232 += _231;
    _232 *= _224.d1;
    _232 += r;
    bool _233 = _224.data[_232];
    _a3__a1_int64_t _234;
    if (!_233)
    goto _jump907;
    _a3__a1_int64_t _235;
    // Computing bound for y
    _235.d0 = _34.d1;
    if (_34.d1 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing bound for z
    _235.d1 = _34.d2;
    if (_34.d2 > 0) 
    goto _jump909;
    fail_assertion("non-positive loop bound");
    _jump909:;
    // Computing bound for A
    _235.d2 = m;
    if (m > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing total size of heap memory to allocate
    int64_t _236 = 1;
    _236 *= _34.d1;
    _236 *= _34.d2;
    _236 *= m;
    _236 *= sizeof(_a1_int64_t);
    _235.data = jpl_alloc(_236);
    int64_t _237 = 0; // A
    int64_t _238 = 0; // z
    int64_t _239 = 0; // y
    _jump911:; // Begin body of loop
    _a1_int64_t _240;
    // Computing bound for B
    _240.d0 = c;
    if (c > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    // Computing total size of heap memory to allocate
    int64_t _241 = 1;
    _241 *= c;
    _241 *= sizeof(int64_t);
    _240.data = jpl_alloc(_241);
    int64_t _242 = 0; // B
    _jump913:; // Begin body of loop
    int64_t _243 = 849;
    int64_t _244 = 0;
    _244 *= _240.d0;
    _244 += _242;
    _240.data[_244] = _243;
    _242++;
    if (_242 < c)
    goto _jump913;
    // End body of loop
    int64_t _245 = 0;
    _245 *= _235.d0;
    _245 += _239;
    _245 *= _235.d1;
    _245 += _238;
    _245 *= _235.d2;
    _245 += _237;
    _235.data[_245] = _240;
    _237++;
    if (_237 < m)
    goto _jump911;
    _237 = 0;
    _238++;
    if (_238 < _34.d2)
    goto _jump911;
    _238 = 0;
    _239++;
    if (_239 < _34.d1)
    goto _jump911;
    // End body of loop
    _234 = _235;
    goto _jump914;
    _jump907:;
    _a3__a1_int64_t _246;
    // Computing bound for y
    _246.d0 = b;
    if (b > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing bound for z
    int64_t _247;
    // Computing bound for y
    if (d > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    _247 = 0;
    int64_t _248 = 0; // y
    _jump917:; // Begin body of loop
    _247 += l;
    _248++;
    if (_248 < d)
    goto _jump917;
    // End body of loop
    _246.d1 = _247;
    if (_247 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing bound for A
    _246.d2 = _34.d2;
    if (_34.d2 > 0) 
    goto _jump919;
    fail_assertion("non-positive loop bound");
    _jump919:;
    // Computing total size of heap memory to allocate
    int64_t _249 = 1;
    _249 *= b;
    _249 *= _247;
    _249 *= _34.d2;
    _249 *= sizeof(_a1_int64_t);
    _246.data = jpl_alloc(_249);
    int64_t _250 = 0; // A
    int64_t _251 = 0; // z
    int64_t _252 = 0; // y
    _jump920:; // Begin body of loop
    _a1_int64_t _253;
    _253.d0 = 2;
    _253.data = jpl_alloc(sizeof(int64_t) * 2);
    _253.data[0] = r;
    _253.data[1] = _34.d0;
    int64_t _254 = 0;
    _254 *= _246.d0;
    _254 += _252;
    _254 *= _246.d1;
    _254 += _251;
    _254 *= _246.d2;
    _254 += _250;
    _246.data[_254] = _253;
    _250++;
    if (_250 < _34.d2)
    goto _jump920;
    _250 = 0;
    _251++;
    if (_251 < _247)
    goto _jump920;
    _251 = 0;
    _252++;
    if (_252 < b)
    goto _jump920;
    // End body of loop
    _234 = _246;
    _jump914:;
    int64_t _255 = 914;
    int64_t _256 = _34.d2 * _255;
    _a1_bool _257;
    // Computing bound for y
    _257.d0 = m;
    if (m > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing total size of heap memory to allocate
    int64_t _258 = 1;
    _258 *= m;
    _258 *= sizeof(bool);
    _257.data = jpl_alloc(_258);
    int64_t _259 = 0; // y
    _jump922:; // Begin body of loop
    bool _260 = true;
    int64_t _261 = 0;
    _261 *= _257.d0;
    _261 += _259;
    _257.data[_261] = _260;
    _259++;
    if (_259 < m)
    goto _jump922;
    // End body of loop
    int64_t _262 = 122;
    if (_262 >= 0)
    goto _jump923;
    fail_assertion("negative array index");
    _jump923:;
    if (_262 < _257.d0)
    goto _jump924;
    fail_assertion("index too large");
    _jump924:;
    int64_t _263 = 0;
    _263 *= _257.d0;
    _263 += _262;
    bool _264 = _257.data[_263];
    int64_t _265;
    if (!_264)
    goto _jump925;
    _265 = g;
    goto _jump926;
    _jump925:;
    _265 = _34.d0;
    _jump926:;
    int64_t _266;
    // Computing bound for y
    int64_t _267 = 10;
    if (_267 > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    _266 = 0;
    int64_t _268 = 0; // y
    _jump928:; // Begin body of loop
    _266 += _34.d2;
    _268++;
    if (_268 < _267)
    goto _jump928;
    // End body of loop
    int64_t _269 = -_266;
    int64_t _270 = -_269;
    if (_256 >= 0)
    goto _jump929;
    fail_assertion("negative array index");
    _jump929:;
    if (_256 < _234.d0)
    goto _jump930;
    fail_assertion("index too large");
    _jump930:;
    if (_265 >= 0)
    goto _jump931;
    fail_assertion("negative array index");
    _jump931:;
    if (_265 < _234.d1)
    goto _jump932;
    fail_assertion("index too large");
    _jump932:;
    if (_270 >= 0)
    goto _jump933;
    fail_assertion("negative array index");
    _jump933:;
    if (_270 < _234.d2)
    goto _jump934;
    fail_assertion("index too large");
    _jump934:;
    int64_t _271 = 0;
    _271 *= _234.d0;
    _271 += _256;
    _271 *= _234.d1;
    _271 += _265;
    _271 *= _234.d2;
    _271 += _270;
    _a1_int64_t _272 = _234.data[_271];
    _223 = _272;
    goto _jump935;
    _jump893:;
    _a2__a1_int64_t _273;
    // Computing bound for y
    _273.d0 = _34.d0;
    if (_34.d0 > 0) 
    goto _jump936;
    fail_assertion("non-positive loop bound");
    _jump936:;
    // Computing bound for z
    _273.d1 = m;
    if (m > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= _34.d0;
    _274 *= m;
    _274 *= sizeof(_a1_int64_t);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // z
    int64_t _276 = 0; // y
    _jump938:; // Begin body of loop
    if (c >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (c < k.d0)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    if (d >= 0)
    goto _jump941;
    fail_assertion("negative array index");
    _jump941:;
    if (d < k.d1)
    goto _jump942;
    fail_assertion("index too large");
    _jump942:;
    int64_t _277 = 0;
    _277 *= k.d0;
    _277 += c;
    _277 *= k.d1;
    _277 += d;
    int64_t _278 = k.data[_277];
    _a1_int64_t _279;
    _279.d0 = 3;
    _279.data = jpl_alloc(sizeof(int64_t) * 3);
    _279.data[0] = g;
    _279.data[1] = _278;
    _279.data[2] = _34.d2;
    int64_t _280 = 0;
    _280 *= _273.d0;
    _280 += _276;
    _280 *= _273.d1;
    _280 += _275;
    _273.data[_280] = _279;
    _275++;
    if (_275 < m)
    goto _jump938;
    _275 = 0;
    _276++;
    if (_276 < _34.d0)
    goto _jump938;
    // End body of loop
    if (_34.d1 >= 0)
    goto _jump943;
    fail_assertion("negative array index");
    _jump943:;
    if (_34.d1 < _273.d0)
    goto _jump944;
    fail_assertion("index too large");
    _jump944:;
    if (c >= 0)
    goto _jump945;
    fail_assertion("negative array index");
    _jump945:;
    if (c < _273.d1)
    goto _jump946;
    fail_assertion("index too large");
    _jump946:;
    int64_t _281 = 0;
    _281 *= _273.d0;
    _281 += _34.d1;
    _281 *= _273.d1;
    _281 += c;
    _a1_int64_t _282 = _273.data[_281];
    _223 = _282;
    _jump935:;
    _214 = _223;
    goto _jump947;
    _jump890:;
    _214 = e;
    _jump947:;
    _193 = _214;
    goto _jump948;
    _jump873:;
    bool _283 = true;
    _a2__a1_int64_t _284;
    if (!_283)
    goto _jump949;
    bool _285 = d == l;
    _a2__a1_int64_t _286;
    if (!_285)
    goto _jump950;
    bool _287 = false;
    _a2__a1_int64_t _288;
    if (!_287)
    goto _jump951;
    _a2__a1_int64_t _289;
    // Computing bound for y
    _289.d0 = d;
    if (d > 0) 
    goto _jump952;
    fail_assertion("non-positive loop bound");
    _jump952:;
    // Computing bound for z
    _289.d1 = _34.d1;
    if (_34.d1 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    // Computing total size of heap memory to allocate
    int64_t _290 = 1;
    _290 *= d;
    _290 *= _34.d1;
    _290 *= sizeof(_a1_int64_t);
    _289.data = jpl_alloc(_290);
    int64_t _291 = 0; // z
    int64_t _292 = 0; // y
    _jump954:; // Begin body of loop
    int64_t _293 = 820;
    _a1_int64_t _294;
    _294.d0 = 3;
    _294.data = jpl_alloc(sizeof(int64_t) * 3);
    _294.data[0] = _293;
    _294.data[1] = g;
    _294.data[2] = c;
    int64_t _295 = 0;
    _295 *= _289.d0;
    _295 += _292;
    _295 *= _289.d1;
    _295 += _291;
    _289.data[_295] = _294;
    _291++;
    if (_291 < _34.d1)
    goto _jump954;
    _291 = 0;
    _292++;
    if (_292 < d)
    goto _jump954;
    // End body of loop
    _288 = _289;
    goto _jump955;
    _jump951:;
    _a2__a1_int64_t _296;
    // Computing bound for y
    _296.d0 = b;
    if (b > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for z
    bool _297 = false;
    int64_t _298;
    if (!_297)
    goto _jump957;
    _298 = _34.d2;
    goto _jump958;
    _jump957:;
    _298 = l;
    _jump958:;
    _296.d1 = _298;
    if (_298 > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= b;
    _299 *= _298;
    _299 *= sizeof(_a1_int64_t);
    _296.data = jpl_alloc(_299);
    int64_t _300 = 0; // z
    int64_t _301 = 0; // y
    _jump960:; // Begin body of loop
    _a1_int64_t _302;
    // Computing bound for A
    _302.d0 = _34.d2;
    if (_34.d2 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= _34.d2;
    _303 *= sizeof(int64_t);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // A
    _jump962:; // Begin body of loop
    int64_t _305 = 0;
    _305 *= _302.d0;
    _305 += _304;
    _302.data[_305] = c;
    _304++;
    if (_304 < _34.d2)
    goto _jump962;
    // End body of loop
    int64_t _306 = 0;
    _306 *= _296.d0;
    _306 += _301;
    _306 *= _296.d1;
    _306 += _300;
    _296.data[_306] = _302;
    _300++;
    if (_300 < _298)
    goto _jump960;
    _300 = 0;
    _301++;
    if (_301 < b)
    goto _jump960;
    // End body of loop
    _288 = _296;
    _jump955:;
    _286 = _288;
    goto _jump963;
    _jump950:;
    double _307 = 82.0;
    double _308 = 98.0;
    bool _309 = _307 <= _308;
    _a2__a1_int64_t _310;
    if (!_309)
    goto _jump964;
    _a2__a1_int64_t _311;
    // Computing bound for y
    int64_t _312 = 544;
    int64_t _313 = -_312;
    _311.d0 = _313;
    if (_313 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing bound for z
    _311.d1 = d;
    if (d > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing total size of heap memory to allocate
    int64_t _314 = 1;
    _314 *= _313;
    _314 *= d;
    _314 *= sizeof(_a1_int64_t);
    _311.data = jpl_alloc(_314);
    int64_t _315 = 0; // z
    int64_t _316 = 0; // y
    _jump967:; // Begin body of loop
    _a1_int64_t _317;
    _317.d0 = 1;
    _317.data = jpl_alloc(sizeof(int64_t) * 1);
    _317.data[0] = g;
    int64_t _318 = 0;
    _318 *= _311.d0;
    _318 += _316;
    _318 *= _311.d1;
    _318 += _315;
    _311.data[_318] = _317;
    _315++;
    if (_315 < d)
    goto _jump967;
    _315 = 0;
    _316++;
    if (_316 < _313)
    goto _jump967;
    // End body of loop
    _310 = _311;
    goto _jump968;
    _jump964:;
    _a2__a1_int64_t _319;
    // Computing bound for y
    _319.d0 = r;
    if (r > 0) 
    goto _jump969;
    fail_assertion("non-positive loop bound");
    _jump969:;
    // Computing bound for z
    _319.d1 = c;
    if (c > 0) 
    goto _jump970;
    fail_assertion("non-positive loop bound");
    _jump970:;
    // Computing total size of heap memory to allocate
    int64_t _320 = 1;
    _320 *= r;
    _320 *= c;
    _320 *= sizeof(_a1_int64_t);
    _319.data = jpl_alloc(_320);
    int64_t _321 = 0; // z
    int64_t _322 = 0; // y
    _jump971:; // Begin body of loop
    _a1_int64_t _323;
    _323.d0 = 3;
    _323.data = jpl_alloc(sizeof(int64_t) * 3);
    _323.data[0] = g;
    _323.data[1] = _322;
    _323.data[2] = r;
    int64_t _324 = 0;
    _324 *= _319.d0;
    _324 += _322;
    _324 *= _319.d1;
    _324 += _321;
    _319.data[_324] = _323;
    _321++;
    if (_321 < c)
    goto _jump971;
    _321 = 0;
    _322++;
    if (_322 < r)
    goto _jump971;
    // End body of loop
    _310 = _319;
    _jump968:;
    _286 = _310;
    _jump963:;
    _284 = _286;
    goto _jump972;
    _jump949:;
    _a2__a1_int64_t _325;
    // Computing bound for y
    int64_t _326 = 489;
    int64_t _327 = -_326;
    _325.d0 = _327;
    if (_327 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for z
    int64_t _328 = -_34.d2;
    _325.d1 = _328;
    if (_328 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _327;
    _329 *= _328;
    _329 *= sizeof(_a1_int64_t);
    _325.data = jpl_alloc(_329);
    int64_t _330 = 0; // z
    int64_t _331 = 0; // y
    _jump975:; // Begin body of loop
    int64_t _332 = 0;
    _332 *= _325.d0;
    _332 += _331;
    _332 *= _325.d1;
    _332 += _330;
    _325.data[_332] = f;
    _330++;
    if (_330 < _328)
    goto _jump975;
    _330 = 0;
    _331++;
    if (_331 < _327)
    goto _jump975;
    // End body of loop
    _a2__a1_int64_t _333;
    // Computing bound for y
    int64_t _334 = -c;
    _333.d0 = _334;
    if (_334 > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    // Computing bound for z
    _333.d1 = _34.d0;
    if (_34.d0 > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing total size of heap memory to allocate
    int64_t _335 = 1;
    _335 *= _334;
    _335 *= _34.d0;
    _335 *= sizeof(_a1_int64_t);
    _333.data = jpl_alloc(_335);
    int64_t _336 = 0; // z
    int64_t _337 = 0; // y
    _jump978:; // Begin body of loop
    int64_t _338 = 0;
    _338 *= _333.d0;
    _338 += _337;
    _338 *= _333.d1;
    _338 += _336;
    _333.data[_338] = f;
    _336++;
    if (_336 < _34.d0)
    goto _jump978;
    _336 = 0;
    _337++;
    if (_337 < _334)
    goto _jump978;
    // End body of loop
    _a1__a2__a1_int64_t _339;
    _339.d0 = 2;
    _339.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 2);
    _339.data[0] = _325;
    _339.data[1] = _333;
    if (d >= 0)
    goto _jump979;
    fail_assertion("negative array index");
    _jump979:;
    if (d < _339.d0)
    goto _jump980;
    fail_assertion("index too large");
    _jump980:;
    int64_t _340 = 0;
    _340 *= _339.d0;
    _340 += d;
    _a2__a1_int64_t _341 = _339.data[_340];
    _284 = _341;
    _jump972:;
    bool _342 = q.a;
    _a2_int64_t _343;
    if (!_342)
    goto _jump981;
    int64_t _344 = 630;
    bool _345 = g < _344;
    _a2_int64_t _346;
    if (!_345)
    goto _jump982;
    _a2_int64_t _347;
    // Computing bound for y
    _347.d0 = g;
    if (g > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for z
    int64_t _348 = -_34.d0;
    _347.d1 = _348;
    if (_348 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= g;
    _349 *= _348;
    _349 *= sizeof(int64_t);
    _347.data = jpl_alloc(_349);
    int64_t _350 = 0; // z
    int64_t _351 = 0; // y
    _jump985:; // Begin body of loop
    int64_t _352;
    // Computing bound for A
    if (b > 0) 
    goto _jump986;
    fail_assertion("non-positive loop bound");
    _jump986:;
    // Computing bound for B
    if (_34.d1 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    _352 = 0;
    int64_t _353 = 0; // B
    int64_t _354 = 0; // A
    _jump988:; // Begin body of loop
    _352 += d;
    _353++;
    if (_353 < _34.d1)
    goto _jump988;
    _353 = 0;
    _354++;
    if (_354 < b)
    goto _jump988;
    // End body of loop
    int64_t _355 = 0;
    _355 *= _347.d0;
    _355 += _351;
    _355 *= _347.d1;
    _355 += _350;
    _347.data[_355] = _352;
    _350++;
    if (_350 < _348)
    goto _jump985;
    _350 = 0;
    _351++;
    if (_351 < g)
    goto _jump985;
    // End body of loop
    _346 = _347;
    goto _jump989;
    _jump982:;
    _346 = k;
    _jump989:;
    _343 = _346;
    goto _jump990;
    _jump981:;
    _a2_int64_t _356;
    // Computing bound for y
    _356.d0 = c;
    if (c > 0) 
    goto _jump991;
    fail_assertion("non-positive loop bound");
    _jump991:;
    // Computing bound for z
    _356.d1 = c;
    if (c > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    // Computing total size of heap memory to allocate
    int64_t _357 = 1;
    _357 *= c;
    _357 *= c;
    _357 *= sizeof(int64_t);
    _356.data = jpl_alloc(_357);
    int64_t _358 = 0; // z
    int64_t _359 = 0; // y
    _jump993:; // Begin body of loop
    int64_t _360 = 0;
    _360 *= _356.d0;
    _360 += _359;
    _360 *= _356.d1;
    _360 += _358;
    _356.data[_360] = _34.d0;
    _358++;
    if (_358 < c)
    goto _jump993;
    _358 = 0;
    _359++;
    if (_359 < c)
    goto _jump993;
    // End body of loop
    _343 = _356;
    _jump990:;
    int64_t _361;
    // Computing bound for y
    if (m > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    // Computing bound for z
    int64_t _362;
    // Computing bound for y
    if (g > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for z
    if (_34.d0 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing bound for A
    if (_34.d2 > 0) 
    goto _jump997;
    fail_assertion("non-positive loop bound");
    _jump997:;
    _362 = 0;
    int64_t _363 = 0; // A
    int64_t _364 = 0; // z
    int64_t _365 = 0; // y
    _jump998:; // Begin body of loop
    _362 += _364;
    _363++;
    if (_363 < _34.d2)
    goto _jump998;
    _363 = 0;
    _364++;
    if (_364 < _34.d0)
    goto _jump998;
    _364 = 0;
    _365++;
    if (_365 < g)
    goto _jump998;
    // End body of loop
    if (_362 > 0) 
    goto _jump999;
    fail_assertion("non-positive loop bound");
    _jump999:;
    // Computing bound for A
    _a2_int64_t _366;
    // Computing bound for y
    _366.d0 = _34.d1;
    if (_34.d1 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for z
    _366.d1 = g;
    if (g > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    // Computing total size of heap memory to allocate
    int64_t _367 = 1;
    _367 *= _34.d1;
    _367 *= g;
    _367 *= sizeof(int64_t);
    _366.data = jpl_alloc(_367);
    int64_t _368 = 0; // z
    int64_t _369 = 0; // y
    _jump1002:; // Begin body of loop
    int64_t _370 = 0;
    _370 *= _366.d0;
    _370 += _369;
    _370 *= _366.d1;
    _370 += _368;
    _366.data[_370] = g;
    _368++;
    if (_368 < g)
    goto _jump1002;
    _368 = 0;
    _369++;
    if (_369 < _34.d1)
    goto _jump1002;
    // End body of loop
    int64_t _371 = 410;
    if (_371 >= 0)
    goto _jump1003;
    fail_assertion("negative array index");
    _jump1003:;
    if (_371 < _366.d0)
    goto _jump1004;
    fail_assertion("index too large");
    _jump1004:;
    if (l >= 0)
    goto _jump1005;
    fail_assertion("negative array index");
    _jump1005:;
    if (l < _366.d1)
    goto _jump1006;
    fail_assertion("index too large");
    _jump1006:;
    int64_t _372 = 0;
    _372 *= _366.d0;
    _372 += _371;
    _372 *= _366.d1;
    _372 += l;
    int64_t _373 = _366.data[_372];
    if (_373 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    _361 = 0;
    int64_t _374 = 0; // A
    int64_t _375 = 0; // z
    int64_t _376 = 0; // y
    _jump1008:; // Begin body of loop
    _361 += l;
    _374++;
    if (_374 < _373)
    goto _jump1008;
    _374 = 0;
    _375++;
    if (_375 < _362)
    goto _jump1008;
    _375 = 0;
    _376++;
    if (_376 < m)
    goto _jump1008;
    // End body of loop
    int64_t _377 = d - _361;
    if (r >= 0)
    goto _jump1009;
    fail_assertion("negative array index");
    _jump1009:;
    if (r < _343.d0)
    goto _jump1010;
    fail_assertion("index too large");
    _jump1010:;
    if (_377 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (_377 < _343.d1)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    int64_t _378 = 0;
    _378 *= _343.d0;
    _378 += r;
    _378 *= _343.d1;
    _378 += _377;
    int64_t _379 = _343.data[_378];
    if (d >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (d < _284.d0)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    if (_379 >= 0)
    goto _jump1015;
    fail_assertion("negative array index");
    _jump1015:;
    if (_379 < _284.d1)
    goto _jump1016;
    fail_assertion("index too large");
    _jump1016:;
    int64_t _380 = 0;
    _380 *= _284.d0;
    _380 += d;
    _380 *= _284.d1;
    _380 += _379;
    _a1_int64_t _381 = _284.data[_380];
    _193 = _381;
    _jump948:;
    double _382 = s.b;
    bool _383 = true;
    bool _384 = !_383;
    bool _385 = true;
    bool _386 = _384 == _385;
    _a1_double _387;
    if (!_386)
    goto _jump1017;
    _a1_double _388;
    // Computing bound for A
    _388.d0 = _34.d1;
    if (_34.d1 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _34.d1;
    _389 *= sizeof(double);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // A
    _jump1019:; // Begin body of loop
    if (d >= 0)
    goto _jump1020;
    fail_assertion("negative array index");
    _jump1020:;
    if (d < _0.d0)
    goto _jump1021;
    fail_assertion("index too large");
    _jump1021:;
    if (_390 >= 0)
    goto _jump1022;
    fail_assertion("negative array index");
    _jump1022:;
    if (_390 < _0.d1)
    goto _jump1023;
    fail_assertion("index too large");
    _jump1023:;
    if (_193.d0 >= 0)
    goto _jump1024;
    fail_assertion("negative array index");
    _jump1024:;
    if (_193.d0 < _0.d2)
    goto _jump1025;
    fail_assertion("index too large");
    _jump1025:;
    int64_t _391 = 0;
    _391 *= _0.d0;
    _391 += d;
    _391 *= _0.d1;
    _391 += _390;
    _391 *= _0.d2;
    _391 += _193.d0;
    double _392 = _0.data[_391];
    int64_t _393 = 0;
    _393 *= _388.d0;
    _393 += _390;
    _388.data[_393] = _392;
    _390++;
    if (_390 < _34.d1)
    goto _jump1019;
    // End body of loop
    _387 = _388;
    goto _jump1026;
    _jump1017:;
    _a1_double _394;
    // Computing bound for A
    _394.d0 = r;
    if (r > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    // Computing total size of heap memory to allocate
    int64_t _395 = 1;
    _395 *= r;
    _395 *= sizeof(double);
    _394.data = jpl_alloc(_395);
    int64_t _396 = 0; // A
    _jump1028:; // Begin body of loop
    double _397 = s.b;
    int64_t _398 = 0;
    _398 *= _394.d0;
    _398 += _396;
    _394.data[_398] = _397;
    _396++;
    if (_396 < r)
    goto _jump1028;
    // End body of loop
    _387 = _394;
    _jump1026:;
    if (r >= 0)
    goto _jump1029;
    fail_assertion("negative array index");
    _jump1029:;
    if (r < _387.d0)
    goto _jump1030;
    fail_assertion("index too large");
    _jump1030:;
    int64_t _399 = 0;
    _399 *= _387.d0;
    _399 += r;
    double _400 = _387.data[_399];
    bool _401 = _382 <= _400;
    i _402;
    if (!_401)
    goto _jump1031;
    _a1_i _403;
    // Computing bound for A
    int64_t _404;
    // Computing bound for A
    int64_t _405;
    // Computing bound for A
    if (b > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    _405 = 0;
    int64_t _406 = 0; // A
    _jump1033:; // Begin body of loop
    _405 += m;
    _406++;
    if (_406 < b)
    goto _jump1033;
    // End body of loop
    if (_405 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing bound for B
    if (_34.d2 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    _404 = 0;
    int64_t _407 = 0; // B
    int64_t _408 = 0; // A
    _jump1036:; // Begin body of loop
    _404 += _193.d0;
    _407++;
    if (_407 < _34.d2)
    goto _jump1036;
    _407 = 0;
    _408++;
    if (_408 < _405)
    goto _jump1036;
    // End body of loop
    int64_t _409 = g * _404;
    _403.d0 = _409;
    if (_409 > 0) 
    goto _jump1037;
    fail_assertion("non-positive loop bound");
    _jump1037:;
    // Computing total size of heap memory to allocate
    int64_t _410 = 1;
    _410 *= _409;
    _410 *= sizeof(i);
    _403.data = jpl_alloc(_410);
    int64_t _411 = 0; // A
    _jump1038:; // Begin body of loop
    bool _412 = q.a;
    double _413 = 92.0;
    h _414 = { _413 };
    int64_t _415 = 992;
    i _416 = { _412, _414, _415 };
    int64_t _417 = 0;
    _417 *= _403.d0;
    _417 += _411;
    _403.data[_417] = _416;
    _411++;
    if (_411 < _409)
    goto _jump1038;
    // End body of loop
    if (b >= 0)
    goto _jump1039;
    fail_assertion("negative array index");
    _jump1039:;
    if (b < _403.d0)
    goto _jump1040;
    fail_assertion("index too large");
    _jump1040:;
    int64_t _418 = 0;
    _418 *= _403.d0;
    _418 += b;
    i _419 = _403.data[_418];
    _402 = _419;
    goto _jump1041;
    _jump1031:;
    bool _421 = false;
    int64_t _422;
    if (!_421)
    goto _jump1042;
    _422 = _34.d2;
    goto _jump1043;
    _jump1042:;
    int64_t _423 = 895;
    int64_t _424 = -_423;
    _422 = _424;
    _jump1043:;
    bool _425 = _422 >= b;
    bool _420 = _425;
    if (0 == _425)
    goto _jump1044;
    _a1_o _426;
    // Computing bound for A
    _426.d0 = _34.d2;
    if (_34.d2 > 0) 
    goto _jump1045;
    fail_assertion("non-positive loop bound");
    _jump1045:;
    // Computing total size of heap memory to allocate
    int64_t _427 = 1;
    _427 *= _34.d2;
    _427 *= sizeof(o);
    _426.data = jpl_alloc(_427);
    int64_t _428 = 0; // A
    _jump1046:; // Begin body of loop
    int64_t _429 = 0;
    _429 *= _426.d0;
    _429 += _428;
    _426.data[_429] = q;
    _428++;
    if (_428 < _34.d2)
    goto _jump1046;
    // End body of loop
    int64_t _430 = 781;
    int64_t _431 = _430 + _34.d0;
    if (_431 >= 0)
    goto _jump1047;
    fail_assertion("negative array index");
    _jump1047:;
    if (_431 < _426.d0)
    goto _jump1048;
    fail_assertion("index too large");
    _jump1048:;
    int64_t _432 = 0;
    _432 *= _426.d0;
    _432 += _431;
    o _433 = _426.data[_432];
    bool _434 = _433.a;
    _420 = _434;
    _jump1044:;
    _a3_h _435;
    // Computing bound for A
    int64_t _436 = -b;
    _435.d0 = _436;
    if (_436 > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing bound for B
    _435.d1 = _193.d0;
    if (_193.d0 > 0) 
    goto _jump1050;
    fail_assertion("non-positive loop bound");
    _jump1050:;
    // Computing bound for C
    int64_t _437;
    // Computing bound for A
    int64_t _438 = _34.d1 % _34.d0;
    if (_438 > 0) 
    goto _jump1051;
    fail_assertion("non-positive loop bound");
    _jump1051:;
    _437 = 0;
    int64_t _439 = 0; // A
    _jump1052:; // Begin body of loop
    int64_t _440 = -r;
    _437 += _440;
    _439++;
    if (_439 < _438)
    goto _jump1052;
    // End body of loop
    _435.d2 = _437;
    if (_437 > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing total size of heap memory to allocate
    int64_t _441 = 1;
    _441 *= _436;
    _441 *= _193.d0;
    _441 *= _437;
    _441 *= sizeof(h);
    _435.data = jpl_alloc(_441);
    int64_t _442 = 0; // C
    int64_t _443 = 0; // B
    int64_t _444 = 0; // A
    _jump1054:; // Begin body of loop
    double _445 = s.g;
    h _446 = { _445 };
    int64_t _447 = 0;
    _447 *= _435.d0;
    _447 += _444;
    _447 *= _435.d1;
    _447 += _443;
    _447 *= _435.d2;
    _447 += _442;
    _435.data[_447] = _446;
    _442++;
    if (_442 < _437)
    goto _jump1054;
    _442 = 0;
    _443++;
    if (_443 < _193.d0)
    goto _jump1054;
    _443 = 0;
    _444++;
    if (_444 < _436)
    goto _jump1054;
    // End body of loop
    int64_t _448;
    // Computing bound for A
    int64_t _449 = d / l;
    int64_t _450 = _449 + _34.d0;
    if (_450 > 0) 
    goto _jump1055;
    fail_assertion("non-positive loop bound");
    _jump1055:;
    // Computing bound for B
    if (b > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    // Computing bound for C
    int64_t _451 = _34.d1 * _34.d2;
    if (_451 > 0) 
    goto _jump1057;
    fail_assertion("non-positive loop bound");
    _jump1057:;
    _448 = 0;
    int64_t _452 = 0; // C
    int64_t _453 = 0; // B
    int64_t _454 = 0; // A
    _jump1058:; // Begin body of loop
    _448 += r;
    _452++;
    if (_452 < _451)
    goto _jump1058;
    _452 = 0;
    _453++;
    if (_453 < b)
    goto _jump1058;
    _453 = 0;
    _454++;
    if (_454 < _450)
    goto _jump1058;
    // End body of loop
    if (_193.d0 >= 0)
    goto _jump1059;
    fail_assertion("negative array index");
    _jump1059:;
    if (_193.d0 < _435.d0)
    goto _jump1060;
    fail_assertion("index too large");
    _jump1060:;
    if (_448 >= 0)
    goto _jump1061;
    fail_assertion("negative array index");
    _jump1061:;
    if (_448 < _435.d1)
    goto _jump1062;
    fail_assertion("index too large");
    _jump1062:;
    if (l >= 0)
    goto _jump1063;
    fail_assertion("negative array index");
    _jump1063:;
    if (l < _435.d2)
    goto _jump1064;
    fail_assertion("index too large");
    _jump1064:;
    int64_t _455 = 0;
    _455 *= _435.d0;
    _455 += _193.d0;
    _455 *= _435.d1;
    _455 += _448;
    _455 *= _435.d2;
    _455 += l;
    h _456 = _435.data[_455];
    i _457 = { _420, _456, d };
    _402 = _457;
    _jump1041:;
    bool _458 = _402.a;
    if (0 != _458)
    goto _jump1065;
    fail_assertion("A");
    _jump1065:;
    bool _459 = false;
    bool _460 = false;
    o _461 = { _460 };
    bool _462 = _461.a;
    o _463 = { _462 };
    bool _464 = _463.a;
    _a3_rgba _465;
    if (!_464)
    goto _jump1066;
    bool _466 = _459;
    if (0 == _459)
    goto _jump1067;
    bool _467 = q.a;
    _466 = _467;
    _jump1067:;
    _a3__a3_rgba _468;
    if (!_466)
    goto _jump1068;
    _a3__a3_rgba _469;
    // Computing bound for C
    int64_t _470 = -d;
    _469.d0 = _470;
    if (_470 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing bound for D
    _a3_int64_t _471;
    // Computing bound for C
    _471.d0 = _193.d0;
    if (_193.d0 > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing bound for D
    _471.d1 = c;
    if (c > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing bound for E
    _471.d2 = _193.d0;
    if (_193.d0 > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _193.d0;
    _472 *= c;
    _472 *= _193.d0;
    _472 *= sizeof(int64_t);
    _471.data = jpl_alloc(_472);
    int64_t _473 = 0; // E
    int64_t _474 = 0; // D
    int64_t _475 = 0; // C
    _jump1073:; // Begin body of loop
    int64_t _476 = 0;
    _476 *= _471.d0;
    _476 += _475;
    _476 *= _471.d1;
    _476 += _474;
    _476 *= _471.d2;
    _476 += _473;
    _471.data[_476] = b;
    _473++;
    if (_473 < _193.d0)
    goto _jump1073;
    _473 = 0;
    _474++;
    if (_474 < c)
    goto _jump1073;
    _474 = 0;
    _475++;
    if (_475 < _193.d0)
    goto _jump1073;
    // End body of loop
    int64_t _477;
    // Computing bound for C
    if (l > 0) 
    goto _jump1074;
    fail_assertion("non-positive loop bound");
    _jump1074:;
    _477 = 0;
    int64_t _478 = 0; // C
    _jump1075:; // Begin body of loop
    _477 += _193.d0;
    _478++;
    if (_478 < l)
    goto _jump1075;
    // End body of loop
    int64_t _479 = m - g;
    if (c >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (c < _471.d0)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    if (_477 >= 0)
    goto _jump1078;
    fail_assertion("negative array index");
    _jump1078:;
    if (_477 < _471.d1)
    goto _jump1079;
    fail_assertion("index too large");
    _jump1079:;
    if (_479 >= 0)
    goto _jump1080;
    fail_assertion("negative array index");
    _jump1080:;
    if (_479 < _471.d2)
    goto _jump1081;
    fail_assertion("index too large");
    _jump1081:;
    int64_t _480 = 0;
    _480 *= _471.d0;
    _480 += c;
    _480 *= _471.d1;
    _480 += _477;
    _480 *= _471.d2;
    _480 += _479;
    int64_t _481 = _471.data[_480];
    _469.d1 = _481;
    if (_481 > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    // Computing bound for E
    int64_t _482 = 258;
    _469.d2 = _482;
    if (_482 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing total size of heap memory to allocate
    int64_t _483 = 1;
    _483 *= _470;
    _483 *= _481;
    _483 *= _482;
    _483 *= sizeof(_a3_rgba);
    _469.data = jpl_alloc(_483);
    int64_t _484 = 0; // E
    int64_t _485 = 0; // D
    int64_t _486 = 0; // C
    _jump1084:; // Begin body of loop
    _a3_rgba _487;
    // Computing bound for F
    _487.d0 = _34.d0;
    if (_34.d0 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing bound for G
    _487.d1 = m;
    if (m > 0) 
    goto _jump1086;
    fail_assertion("non-positive loop bound");
    _jump1086:;
    // Computing bound for H
    _487.d2 = _193.d0;
    if (_193.d0 > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing total size of heap memory to allocate
    int64_t _488 = 1;
    _488 *= _34.d0;
    _488 *= m;
    _488 *= _193.d0;
    _488 *= sizeof(rgba);
    _487.data = jpl_alloc(_488);
    int64_t _489 = 0; // H
    int64_t _490 = 0; // G
    int64_t _491 = 0; // F
    _jump1088:; // Begin body of loop
    int64_t _492 = 0;
    _492 *= _487.d0;
    _492 += _491;
    _492 *= _487.d1;
    _492 += _490;
    _492 *= _487.d2;
    _492 += _489;
    _487.data[_492] = s;
    _489++;
    if (_489 < _193.d0)
    goto _jump1088;
    _489 = 0;
    _490++;
    if (_490 < m)
    goto _jump1088;
    _490 = 0;
    _491++;
    if (_491 < _34.d0)
    goto _jump1088;
    // End body of loop
    int64_t _493 = 0;
    _493 *= _469.d0;
    _493 += _486;
    _493 *= _469.d1;
    _493 += _485;
    _493 *= _469.d2;
    _493 += _484;
    _469.data[_493] = _487;
    _484++;
    if (_484 < _482)
    goto _jump1084;
    _484 = 0;
    _485++;
    if (_485 < _481)
    goto _jump1084;
    _485 = 0;
    _486++;
    if (_486 < _470)
    goto _jump1084;
    // End body of loop
    _468 = _469;
    goto _jump1089;
    _jump1068:;
    bool _495 = true;
    bool _494 = _495;
    if (0 == _495)
    goto _jump1090;
    bool _496 = true;
    _494 = _496;
    _jump1090:;
    bool _497;
    if (!_494)
    goto _jump1091;
    bool _498 = false;
    _497 = _498;
    goto _jump1092;
    _jump1091:;
    bool _499 = !_459;
    _497 = _499;
    _jump1092:;
    _a3__a3_rgba _500;
    if (!_497)
    goto _jump1093;
    _a3__a3_rgba _501;
    // Computing bound for C
    _501.d0 = b;
    if (b > 0) 
    goto _jump1094;
    fail_assertion("non-positive loop bound");
    _jump1094:;
    // Computing bound for D
    int64_t _502 = -_34.d0;
    _501.d1 = _502;
    if (_502 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    // Computing bound for E
    _501.d2 = c;
    if (c > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    // Computing total size of heap memory to allocate
    int64_t _503 = 1;
    _503 *= b;
    _503 *= _502;
    _503 *= c;
    _503 *= sizeof(_a3_rgba);
    _501.data = jpl_alloc(_503);
    int64_t _504 = 0; // E
    int64_t _505 = 0; // D
    int64_t _506 = 0; // C
    _jump1097:; // Begin body of loop
    int64_t _507 = 0;
    _507 *= _501.d0;
    _507 += _506;
    _507 *= _501.d1;
    _507 += _505;
    _507 *= _501.d2;
    _507 += _504;
    _501.data[_507] = _34;
    _504++;
    if (_504 < c)
    goto _jump1097;
    _504 = 0;
    _505++;
    if (_505 < _502)
    goto _jump1097;
    _505 = 0;
    _506++;
    if (_506 < b)
    goto _jump1097;
    // End body of loop
    _500 = _501;
    goto _jump1098;
    _jump1093:;
    _a3__a3_rgba _508;
    // Computing bound for C
    _508.d0 = r;
    if (r > 0) 
    goto _jump1099;
    fail_assertion("non-positive loop bound");
    _jump1099:;
    // Computing bound for D
    int64_t _509 = g % _193.d0;
    _508.d1 = _509;
    if (_509 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing bound for E
    _508.d2 = m;
    if (m > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing total size of heap memory to allocate
    int64_t _510 = 1;
    _510 *= r;
    _510 *= _509;
    _510 *= m;
    _510 *= sizeof(_a3_rgba);
    _508.data = jpl_alloc(_510);
    int64_t _511 = 0; // E
    int64_t _512 = 0; // D
    int64_t _513 = 0; // C
    _jump1102:; // Begin body of loop
    int64_t _514 = 0;
    _514 *= _508.d0;
    _514 += _513;
    _514 *= _508.d1;
    _514 += _512;
    _514 *= _508.d2;
    _514 += _511;
    _508.data[_514] = _34;
    _511++;
    if (_511 < m)
    goto _jump1102;
    _511 = 0;
    _512++;
    if (_512 < _509)
    goto _jump1102;
    _512 = 0;
    _513++;
    if (_513 < r)
    goto _jump1102;
    // End body of loop
    _500 = _508;
    _jump1098:;
    _468 = _500;
    _jump1089:;
    int64_t _515 = -m;
    if (m >= 0)
    goto _jump1103;
    fail_assertion("negative array index");
    _jump1103:;
    if (m < _468.d0)
    goto _jump1104;
    fail_assertion("index too large");
    _jump1104:;
    if (_34.d1 >= 0)
    goto _jump1105;
    fail_assertion("negative array index");
    _jump1105:;
    if (_34.d1 < _468.d1)
    goto _jump1106;
    fail_assertion("index too large");
    _jump1106:;
    if (_515 >= 0)
    goto _jump1107;
    fail_assertion("negative array index");
    _jump1107:;
    if (_515 < _468.d2)
    goto _jump1108;
    fail_assertion("index too large");
    _jump1108:;
    int64_t _516 = 0;
    _516 *= _468.d0;
    _516 += m;
    _516 *= _468.d1;
    _516 += _34.d1;
    _516 *= _468.d2;
    _516 += _515;
    _a3_rgba _517 = _468.data[_516];
    _465 = _517;
    goto _jump1109;
    _jump1066:;
    _a3__a1__a3_rgba _518;
    // Computing bound for C
    _518.d0 = _34.d0;
    if (_34.d0 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for D
    _518.d1 = r;
    if (r > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for E
    int64_t _519 = d - d;
    int64_t _520 = -_519;
    _518.d2 = _520;
    if (_520 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing total size of heap memory to allocate
    int64_t _521 = 1;
    _521 *= _34.d0;
    _521 *= r;
    _521 *= _520;
    _521 *= sizeof(_a1__a3_rgba);
    _518.data = jpl_alloc(_521);
    int64_t _522 = 0; // E
    int64_t _523 = 0; // D
    int64_t _524 = 0; // C
    _jump1113:; // Begin body of loop
    _a1__a3_rgba _525;
    // Computing bound for F
    _525.d0 = _193.d0;
    if (_193.d0 > 0) 
    goto _jump1114;
    fail_assertion("non-positive loop bound");
    _jump1114:;
    // Computing total size of heap memory to allocate
    int64_t _526 = 1;
    _526 *= _193.d0;
    _526 *= sizeof(_a3_rgba);
    _525.data = jpl_alloc(_526);
    int64_t _527 = 0; // F
    _jump1115:; // Begin body of loop
    int64_t _528 = 0;
    _528 *= _525.d0;
    _528 += _527;
    _525.data[_528] = _34;
    _527++;
    if (_527 < _193.d0)
    goto _jump1115;
    // End body of loop
    int64_t _529 = 0;
    _529 *= _518.d0;
    _529 += _524;
    _529 *= _518.d1;
    _529 += _523;
    _529 *= _518.d2;
    _529 += _522;
    _518.data[_529] = _525;
    _522++;
    if (_522 < _520)
    goto _jump1113;
    _522 = 0;
    _523++;
    if (_523 < r)
    goto _jump1113;
    _523 = 0;
    _524++;
    if (_524 < _34.d0)
    goto _jump1113;
    // End body of loop
    int64_t _530 = 783;
    if (_530 >= 0)
    goto _jump1116;
    fail_assertion("negative array index");
    _jump1116:;
    if (_530 < _518.d0)
    goto _jump1117;
    fail_assertion("index too large");
    _jump1117:;
    if (c >= 0)
    goto _jump1118;
    fail_assertion("negative array index");
    _jump1118:;
    if (c < _518.d1)
    goto _jump1119;
    fail_assertion("index too large");
    _jump1119:;
    if (_193.d0 >= 0)
    goto _jump1120;
    fail_assertion("negative array index");
    _jump1120:;
    if (_193.d0 < _518.d2)
    goto _jump1121;
    fail_assertion("index too large");
    _jump1121:;
    int64_t _531 = 0;
    _531 *= _518.d0;
    _531 += _530;
    _531 *= _518.d1;
    _531 += c;
    _531 *= _518.d2;
    _531 += _193.d0;
    _a1__a3_rgba _532 = _518.data[_531];
    int64_t _533 = 734;
    if (_533 >= 0)
    goto _jump1122;
    fail_assertion("negative array index");
    _jump1122:;
    if (_533 < _532.d0)
    goto _jump1123;
    fail_assertion("index too large");
    _jump1123:;
    int64_t _534 = 0;
    _534 *= _532.d0;
    _534 += _533;
    _a3_rgba _535 = _532.data[_534];
    _465 = _535;
    _jump1109:;
    int64_t _536 = 681;
    int64_t _537;
    // Computing bound for C
    if (m > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    _537 = 0;
    int64_t _538 = 0; // C
    _jump1125:; // Begin body of loop
    bool _539 = q.a;
    bool _540;
    if (!_539)
    goto _jump1126;
    bool _541 = !_459;
    _540 = _541;
    goto _jump1127;
    _jump1126:;
    bool _542 = l < m;
    _540 = _542;
    _jump1127:;
    double _543;
    // Computing bound for D
    if (d > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    // Computing bound for E
    if (_538 > 0) 
    goto _jump1129;
    fail_assertion("non-positive loop bound");
    _jump1129:;
    // Computing bound for F
    if (_34.d2 > 0) 
    goto _jump1130;
    fail_assertion("non-positive loop bound");
    _jump1130:;
    _543 = 0;
    int64_t _544 = 0; // F
    int64_t _545 = 0; // E
    int64_t _546 = 0; // D
    _jump1131:; // Begin body of loop
    double _547 = 66.0;
    _543 += _547;
    _544++;
    if (_544 < _34.d2)
    goto _jump1131;
    _544 = 0;
    _545++;
    if (_545 < _538)
    goto _jump1131;
    _545 = 0;
    _546++;
    if (_546 < d)
    goto _jump1131;
    // End body of loop
    h _548 = { _543 };
    i _549 = { _540, _548, m };
    int64_t _550 = _549.c;
    _537 += _550;
    _538++;
    if (_538 < m)
    goto _jump1125;
    // End body of loop
    int64_t _551 = c + _537;
    if (_34.d1 >= 0)
    goto _jump1132;
    fail_assertion("negative array index");
    _jump1132:;
    if (_34.d1 < _465.d0)
    goto _jump1133;
    fail_assertion("index too large");
    _jump1133:;
    if (_536 >= 0)
    goto _jump1134;
    fail_assertion("negative array index");
    _jump1134:;
    if (_536 < _465.d1)
    goto _jump1135;
    fail_assertion("index too large");
    _jump1135:;
    if (_551 >= 0)
    goto _jump1136;
    fail_assertion("negative array index");
    _jump1136:;
    if (_551 < _465.d2)
    goto _jump1137;
    fail_assertion("index too large");
    _jump1137:;
    int64_t _552 = 0;
    _552 *= _465.d0;
    _552 += _34.d1;
    _552 *= _465.d1;
    _552 += _536;
    _552 *= _465.d2;
    _552 += _551;
    rgba _553 = _465.data[_552];
    return _553;
}

int64_t q(o r, void_t s, _a1_o t) {
    _a2__a1_int64_t _0;
    // Computing bound for v
    int64_t _1 = -t.d0;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing bound for w
    int64_t _2 = 140;
    _0.d1 = _2;
    if (_2 > 0) 
    goto _jump1139;
    fail_assertion("non-positive loop bound");
    _jump1139:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= _1;
    _3 *= _2;
    _3 *= sizeof(_a1_int64_t);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // w
    int64_t _5 = 0; // v
    _jump1140:; // Begin body of loop
    int64_t _6 = 0;
    _6 *= _0.d0;
    _6 += _5;
    _6 *= _0.d1;
    _6 += _4;
    _0.data[_6] = e;
    _4++;
    if (_4 < _2)
    goto _jump1140;
    _4 = 0;
    _5++;
    if (_5 < _1)
    goto _jump1140;
    // End body of loop
    return _0.d0;
    _a3_bool _7;
    // Computing bound for y
    _7.d0 = t.d0;
    if (t.d0 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    // Computing bound for z
    _7.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    // Computing bound for A
    int64_t _8;
    // Computing bound for y
    if (m > 0) 
    goto _jump1143;
    fail_assertion("non-positive loop bound");
    _jump1143:;
    // Computing bound for z
    bool _9 = g >= l;
    _a3_o _10;
    if (!_9)
    goto _jump1144;
    _a3_o _11;
    // Computing bound for y
    _11.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing bound for z
    _11.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing bound for A
    _11.d2 = d;
    if (d > 0) 
    goto _jump1147;
    fail_assertion("non-positive loop bound");
    _jump1147:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _0.d1;
    _12 *= _0.d1;
    _12 *= d;
    _12 *= sizeof(o);
    _11.data = jpl_alloc(_12);
    int64_t _13 = 0; // A
    int64_t _14 = 0; // z
    int64_t _15 = 0; // y
    _jump1148:; // Begin body of loop
    int64_t _16 = 0;
    _16 *= _11.d0;
    _16 += _15;
    _16 *= _11.d1;
    _16 += _14;
    _16 *= _11.d2;
    _16 += _13;
    _11.data[_16] = r;
    _13++;
    if (_13 < d)
    goto _jump1148;
    _13 = 0;
    _14++;
    if (_14 < _0.d1)
    goto _jump1148;
    _14 = 0;
    _15++;
    if (_15 < _0.d1)
    goto _jump1148;
    // End body of loop
    _10 = _11;
    goto _jump1149;
    _jump1144:;
    _a3_o _17;
    // Computing bound for y
    _17.d0 = c;
    if (c > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    // Computing bound for z
    _17.d1 = b;
    if (b > 0) 
    goto _jump1151;
    fail_assertion("non-positive loop bound");
    _jump1151:;
    // Computing bound for A
    _17.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= c;
    _18 *= b;
    _18 *= _0.d1;
    _18 *= sizeof(o);
    _17.data = jpl_alloc(_18);
    int64_t _19 = 0; // A
    int64_t _20 = 0; // z
    int64_t _21 = 0; // y
    _jump1153:; // Begin body of loop
    int64_t _22 = 0;
    _22 *= _17.d0;
    _22 += _21;
    _22 *= _17.d1;
    _22 += _20;
    _22 *= _17.d2;
    _22 += _19;
    _17.data[_22] = r;
    _19++;
    if (_19 < _0.d1)
    goto _jump1153;
    _19 = 0;
    _20++;
    if (_20 < b)
    goto _jump1153;
    _20 = 0;
    _21++;
    if (_21 < c)
    goto _jump1153;
    // End body of loop
    _10 = _17;
    _jump1149:;
    if (c >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (c < _10.d0)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    if (_0.d1 >= 0)
    goto _jump1156;
    fail_assertion("negative array index");
    _jump1156:;
    if (_0.d1 < _10.d1)
    goto _jump1157;
    fail_assertion("index too large");
    _jump1157:;
    if (t.d0 >= 0)
    goto _jump1158;
    fail_assertion("negative array index");
    _jump1158:;
    if (t.d0 < _10.d2)
    goto _jump1159;
    fail_assertion("index too large");
    _jump1159:;
    int64_t _23 = 0;
    _23 *= _10.d0;
    _23 += c;
    _23 *= _10.d1;
    _23 += _0.d1;
    _23 *= _10.d2;
    _23 += t.d0;
    o _24 = _10.data[_23];
    bool _25 = _24.a;
    int64_t _26;
    if (!_25)
    goto _jump1160;
    int64_t _27 = 589;
    int64_t _28 = _27 - t.d0;
    if (_28 >= 0)
    goto _jump1161;
    fail_assertion("negative array index");
    _jump1161:;
    if (_28 < e.d0)
    goto _jump1162;
    fail_assertion("index too large");
    _jump1162:;
    int64_t _29 = 0;
    _29 *= e.d0;
    _29 += _28;
    int64_t _30 = e.data[_29];
    _26 = _30;
    goto _jump1163;
    _jump1160:;
    int64_t _31;
    // Computing bound for y
    if (t.d0 > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    _31 = 0;
    int64_t _32 = 0; // y
    _jump1165:; // Begin body of loop
    _31 += _32;
    _32++;
    if (_32 < t.d0)
    goto _jump1165;
    // End body of loop
    int64_t _33 = -_31;
    _26 = _33;
    _jump1163:;
    if (_26 > 0) 
    goto _jump1166;
    fail_assertion("non-positive loop bound");
    _jump1166:;
    _8 = 0;
    int64_t _34 = 0; // z
    int64_t _35 = 0; // y
    _jump1167:; // Begin body of loop
    _8 += m;
    _34++;
    if (_34 < _26)
    goto _jump1167;
    _34 = 0;
    _35++;
    if (_35 < m)
    goto _jump1167;
    // End body of loop
    _7.d2 = _8;
    if (_8 > 0) 
    goto _jump1168;
    fail_assertion("non-positive loop bound");
    _jump1168:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= t.d0;
    _36 *= _0.d0;
    _36 *= _8;
    _36 *= sizeof(bool);
    _7.data = jpl_alloc(_36);
    int64_t _37 = 0; // A
    int64_t _38 = 0; // z
    int64_t _39 = 0; // y
    _jump1169:; // Begin body of loop
    bool _40 = false;
    int64_t _41 = 0;
    _41 *= _7.d0;
    _41 += _39;
    _41 *= _7.d1;
    _41 += _38;
    _41 *= _7.d2;
    _41 += _37;
    _7.data[_41] = _40;
    _37++;
    if (_37 < _8)
    goto _jump1169;
    _37 = 0;
    _38++;
    if (_38 < _0.d0)
    goto _jump1169;
    _38 = 0;
    _39++;
    if (_39 < t.d0)
    goto _jump1169;
    // End body of loop
    int64_t _42;
    // Computing bound for C
    if (_0.d0 > 0) 
    goto _jump1170;
    fail_assertion("non-positive loop bound");
    _jump1170:;
    // Computing bound for D
    if (m > 0) 
    goto _jump1171;
    fail_assertion("non-positive loop bound");
    _jump1171:;
    // Computing bound for E
    if (_0.d0 > 0) 
    goto _jump1172;
    fail_assertion("non-positive loop bound");
    _jump1172:;
    _42 = 0;
    int64_t _43 = 0; // E
    int64_t _44 = 0; // D
    int64_t _45 = 0; // C
    _jump1173:; // Begin body of loop
    _42 += _45;
    _43++;
    if (_43 < _0.d0)
    goto _jump1173;
    _43 = 0;
    _44++;
    if (_44 < m)
    goto _jump1173;
    _44 = 0;
    _45++;
    if (_45 < _0.d0)
    goto _jump1173;
    // End body of loop
    bool _46 = _42 < l;
    int64_t _47 = 536;
    return b;
    return _7.d2;
}

_a2_double C(_a1_rgba D, _a2__a2_o E, _a1__a3_void_t H) {
    bool _0 = true;
    _a2_bool _1;
    if (!_0)
    goto _jump1452;
    bool _2 = t < t;
    bool _3 = !_2;
    _a2_bool _4;
    if (!_3)
    goto _jump1453;
    bool _6 = H.d0 > E.d0;
    bool _5 = _6;
    if (0 == _6)
    goto _jump1454;
    bool _7 = t > E.d1;
    bool _8;
    if (!_7)
    goto _jump1455;
    bool _9 = true;
    _8 = _9;
    goto _jump1456;
    _jump1455:;
    bool _10 = true;
    _8 = _10;
    _jump1456:;
    _5 = _8;
    _jump1454:;
    _a2_bool _11;
    if (!_5)
    goto _jump1457;
    _a2_bool _12;
    // Computing bound for J
    _12.d0 = c;
    if (c > 0) 
    goto _jump1458;
    fail_assertion("non-positive loop bound");
    _jump1458:;
    // Computing bound for K
    _12.d1 = z;
    if (z > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= c;
    _13 *= z;
    _13 *= sizeof(bool);
    _12.data = jpl_alloc(_13);
    int64_t _14 = 0; // K
    int64_t _15 = 0; // J
    _jump1460:; // Begin body of loop
    bool _16 = true;
    int64_t _17 = 0;
    _17 *= _12.d0;
    _17 += _15;
    _17 *= _12.d1;
    _17 += _14;
    _12.data[_17] = _16;
    _14++;
    if (_14 < z)
    goto _jump1460;
    _14 = 0;
    _15++;
    if (_15 < c)
    goto _jump1460;
    // End body of loop
    _11 = _12;
    goto _jump1461;
    _jump1457:;
    _a3__a2_bool _18;
    // Computing bound for J
    int64_t _19 = -y;
    _18.d0 = _19;
    if (_19 > 0) 
    goto _jump1462;
    fail_assertion("non-positive loop bound");
    _jump1462:;
    // Computing bound for K
    _18.d1 = A;
    if (A > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing bound for L
    _18.d2 = w;
    if (w > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _19;
    _20 *= A;
    _20 *= w;
    _20 *= sizeof(_a2_bool);
    _18.data = jpl_alloc(_20);
    int64_t _21 = 0; // L
    int64_t _22 = 0; // K
    int64_t _23 = 0; // J
    _jump1465:; // Begin body of loop
    _a2_bool _24;
    // Computing bound for M
    _24.d0 = d;
    if (d > 0) 
    goto _jump1466;
    fail_assertion("non-positive loop bound");
    _jump1466:;
    // Computing bound for N
    _24.d1 = _21;
    if (_21 > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= d;
    _25 *= _21;
    _25 *= sizeof(bool);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // N
    int64_t _27 = 0; // M
    _jump1468:; // Begin body of loop
    bool _28 = false;
    int64_t _29 = 0;
    _29 *= _24.d0;
    _29 += _27;
    _29 *= _24.d1;
    _29 += _26;
    _24.data[_29] = _28;
    _26++;
    if (_26 < _21)
    goto _jump1468;
    _26 = 0;
    _27++;
    if (_27 < d)
    goto _jump1468;
    // End body of loop
    int64_t _30 = 0;
    _30 *= _18.d0;
    _30 += _23;
    _30 *= _18.d1;
    _30 += _22;
    _30 *= _18.d2;
    _30 += _21;
    _18.data[_30] = _24;
    _21++;
    if (_21 < w)
    goto _jump1465;
    _21 = 0;
    _22++;
    if (_22 < A)
    goto _jump1465;
    _22 = 0;
    _23++;
    if (_23 < _19)
    goto _jump1465;
    // End body of loop
    if (y >= 0)
    goto _jump1469;
    fail_assertion("negative array index");
    _jump1469:;
    if (y < _18.d0)
    goto _jump1470;
    fail_assertion("index too large");
    _jump1470:;
    if (g >= 0)
    goto _jump1471;
    fail_assertion("negative array index");
    _jump1471:;
    if (g < _18.d1)
    goto _jump1472;
    fail_assertion("index too large");
    _jump1472:;
    if (y >= 0)
    goto _jump1473;
    fail_assertion("negative array index");
    _jump1473:;
    if (y < _18.d2)
    goto _jump1474;
    fail_assertion("index too large");
    _jump1474:;
    int64_t _31 = 0;
    _31 *= _18.d0;
    _31 += y;
    _31 *= _18.d1;
    _31 += g;
    _31 *= _18.d2;
    _31 += y;
    _a2_bool _32 = _18.data[_31];
    _11 = _32;
    _jump1461:;
    _4 = _11;
    goto _jump1475;
    _jump1453:;
    _a2_bool _33;
    // Computing bound for J
    _33.d0 = E.d0;
    if (E.d0 > 0) 
    goto _jump1476;
    fail_assertion("non-positive loop bound");
    _jump1476:;
    // Computing bound for K
    _33.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= E.d0;
    _34 *= H.d0;
    _34 *= sizeof(bool);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // K
    int64_t _36 = 0; // J
    _jump1478:; // Begin body of loop
    bool _37 = false;
    int64_t _38 = 0;
    _38 *= _33.d0;
    _38 += _36;
    _38 *= _33.d1;
    _38 += _35;
    _33.data[_38] = _37;
    _35++;
    if (_35 < H.d0)
    goto _jump1478;
    _35 = 0;
    _36++;
    if (_36 < E.d0)
    goto _jump1478;
    // End body of loop
    _4 = _33;
    _jump1475:;
    _1 = _4;
    goto _jump1479;
    _jump1452:;
    _a3__a2_bool _39;
    // Computing bound for J
    int64_t _40 = -c;
    _39.d0 = _40;
    if (_40 > 0) 
    goto _jump1480;
    fail_assertion("non-positive loop bound");
    _jump1480:;
    // Computing bound for K
    int64_t _41;
    // Computing bound for J
    int64_t _42 = 193;
    if (_42 > 0) 
    goto _jump1481;
    fail_assertion("non-positive loop bound");
    _jump1481:;
    // Computing bound for K
    if (H.d0 > 0) 
    goto _jump1482;
    fail_assertion("non-positive loop bound");
    _jump1482:;
    // Computing bound for L
    if (E.d0 > 0) 
    goto _jump1483;
    fail_assertion("non-positive loop bound");
    _jump1483:;
    _41 = 0;
    int64_t _43 = 0; // L
    int64_t _44 = 0; // K
    int64_t _45 = 0; // J
    _jump1484:; // Begin body of loop
    _41 += b;
    _43++;
    if (_43 < E.d0)
    goto _jump1484;
    _43 = 0;
    _44++;
    if (_44 < H.d0)
    goto _jump1484;
    _44 = 0;
    _45++;
    if (_45 < _42)
    goto _jump1484;
    // End body of loop
    _39.d1 = _41;
    if (_41 > 0) 
    goto _jump1485;
    fail_assertion("non-positive loop bound");
    _jump1485:;
    // Computing bound for L
    _39.d2 = c;
    if (c > 0) 
    goto _jump1486;
    fail_assertion("non-positive loop bound");
    _jump1486:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= _40;
    _46 *= _41;
    _46 *= c;
    _46 *= sizeof(_a2_bool);
    _39.data = jpl_alloc(_46);
    int64_t _47 = 0; // L
    int64_t _48 = 0; // K
    int64_t _49 = 0; // J
    _jump1487:; // Begin body of loop
    _a2_bool _50;
    // Computing bound for M
    _50.d0 = b;
    if (b > 0) 
    goto _jump1488;
    fail_assertion("non-positive loop bound");
    _jump1488:;
    // Computing bound for N
    _a1_int64_t _51;
    // Computing bound for M
    _51.d0 = H.d0;
    if (H.d0 > 0) 
    goto _jump1489;
    fail_assertion("non-positive loop bound");
    _jump1489:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= H.d0;
    _52 *= sizeof(int64_t);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // M
    _jump1490:; // Begin body of loop
    int64_t _54 = 0;
    _54 *= _51.d0;
    _54 += _53;
    _51.data[_54] = d;
    _53++;
    if (_53 < H.d0)
    goto _jump1490;
    // End body of loop
    if (A >= 0)
    goto _jump1491;
    fail_assertion("negative array index");
    _jump1491:;
    if (A < _51.d0)
    goto _jump1492;
    fail_assertion("index too large");
    _jump1492:;
    int64_t _55 = 0;
    _55 *= _51.d0;
    _55 += A;
    int64_t _56 = _51.data[_55];
    _50.d1 = _56;
    if (_56 > 0) 
    goto _jump1493;
    fail_assertion("non-positive loop bound");
    _jump1493:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= b;
    _57 *= _56;
    _57 *= sizeof(bool);
    _50.data = jpl_alloc(_57);
    int64_t _58 = 0; // N
    int64_t _59 = 0; // M
    _jump1494:; // Begin body of loop
    bool _60 = false;
    int64_t _61 = 0;
    _61 *= _50.d0;
    _61 += _59;
    _61 *= _50.d1;
    _61 += _58;
    _50.data[_61] = _60;
    _58++;
    if (_58 < _56)
    goto _jump1494;
    _58 = 0;
    _59++;
    if (_59 < b)
    goto _jump1494;
    // End body of loop
    int64_t _62 = 0;
    _62 *= _39.d0;
    _62 += _49;
    _62 *= _39.d1;
    _62 += _48;
    _62 *= _39.d2;
    _62 += _47;
    _39.data[_62] = _50;
    _47++;
    if (_47 < c)
    goto _jump1487;
    _47 = 0;
    _48++;
    if (_48 < _41)
    goto _jump1487;
    _48 = 0;
    _49++;
    if (_49 < _40)
    goto _jump1487;
    // End body of loop
    int64_t _63 = 78;
    if (_63 >= 0)
    goto _jump1495;
    fail_assertion("negative array index");
    _jump1495:;
    if (_63 < _39.d0)
    goto _jump1496;
    fail_assertion("index too large");
    _jump1496:;
    if (z >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (z < _39.d1)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    if (H.d0 >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (H.d0 < _39.d2)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    int64_t _64 = 0;
    _64 *= _39.d0;
    _64 += _63;
    _64 *= _39.d1;
    _64 += z;
    _64 *= _39.d2;
    _64 += H.d0;
    _a2_bool _65 = _39.data[_64];
    _1 = _65;
    _jump1479:;
    if (z >= 0)
    goto _jump1501;
    fail_assertion("negative array index");
    _jump1501:;
    if (z < _1.d0)
    goto _jump1502;
    fail_assertion("index too large");
    _jump1502:;
    if (d >= 0)
    goto _jump1503;
    fail_assertion("negative array index");
    _jump1503:;
    if (d < _1.d1)
    goto _jump1504;
    fail_assertion("index too large");
    _jump1504:;
    int64_t _66 = 0;
    _66 *= _1.d0;
    _66 += z;
    _66 *= _1.d1;
    _66 += d;
    bool _67 = _1.data[_66];
    if (0 != _67)
    goto _jump1505;
    fail_assertion("J");
    _jump1505:;
    bool _68 = false;
    bool _69 = !_68;
    o _70 = { _69 };
    bool _71 = _70.a;
    bool _72 = !_71;
    _a2_bool _73;
    // Computing bound for J
    _73.d0 = g;
    if (g > 0) 
    goto _jump1506;
    fail_assertion("non-positive loop bound");
    _jump1506:;
    // Computing bound for K
    _73.d1 = l;
    if (l > 0) 
    goto _jump1507;
    fail_assertion("non-positive loop bound");
    _jump1507:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= g;
    _74 *= l;
    _74 *= sizeof(bool);
    _73.data = jpl_alloc(_74);
    int64_t _75 = 0; // K
    int64_t _76 = 0; // J
    _jump1508:; // Begin body of loop
    bool _77 = u <= g;
    int64_t _78 = 0;
    _78 *= _73.d0;
    _78 += _76;
    _78 *= _73.d1;
    _78 += _75;
    _73.data[_78] = _77;
    _75++;
    if (_75 < l)
    goto _jump1508;
    _75 = 0;
    _76++;
    if (_76 < g)
    goto _jump1508;
    // End body of loop
    if (g >= 0)
    goto _jump1509;
    fail_assertion("negative array index");
    _jump1509:;
    if (g < _73.d0)
    goto _jump1510;
    fail_assertion("index too large");
    _jump1510:;
    if (z >= 0)
    goto _jump1511;
    fail_assertion("negative array index");
    _jump1511:;
    if (z < _73.d1)
    goto _jump1512;
    fail_assertion("index too large");
    _jump1512:;
    int64_t _79 = 0;
    _79 *= _73.d0;
    _79 += g;
    _79 *= _73.d1;
    _79 += z;
    bool _80 = _73.data[_79];
    bool _81;
    if (!_80)
    goto _jump1513;
    _a1_bool _83;
    // Computing bound for J
    _83.d0 = w;
    if (w > 0) 
    goto _jump1514;
    fail_assertion("non-positive loop bound");
    _jump1514:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= w;
    _84 *= sizeof(bool);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // J
    _jump1515:; // Begin body of loop
    bool _86 = false;
    int64_t _87 = 0;
    _87 *= _83.d0;
    _87 += _85;
    _83.data[_87] = _86;
    _85++;
    if (_85 < w)
    goto _jump1515;
    // End body of loop
    if (m >= 0)
    goto _jump1516;
    fail_assertion("negative array index");
    _jump1516:;
    if (m < _83.d0)
    goto _jump1517;
    fail_assertion("index too large");
    _jump1517:;
    int64_t _88 = 0;
    _88 *= _83.d0;
    _88 += m;
    bool _89 = _83.data[_88];
    bool _82 = _89;
    if (0 != _89)
    goto _jump1518;
    bool _90 = b >= d;
    _82 = _90;
    _jump1518:;
    _81 = _82;
    goto _jump1519;
    _jump1513:;
    bool _91 = false;
    double _92 = 14.0;
    h _93 = { _92 };
    i _94 = { _91, _93, H.d0 };
    bool _95 = _94.a;
    _81 = _95;
    _jump1519:;
    bool _96 = _72 != _81;
    _a1_rgba _97;
    if (!_96)
    goto _jump1520;
    _97 = D;
    goto _jump1521;
    _jump1520:;
    _a1_rgba _98;
    // Computing bound for J
    _98.d0 = E.d0;
    if (E.d0 > 0) 
    goto _jump1522;
    fail_assertion("non-positive loop bound");
    _jump1522:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= E.d0;
    _99 *= sizeof(rgba);
    _98.data = jpl_alloc(_99);
    int64_t _100 = 0; // J
    _jump1523:; // Begin body of loop
    bool _101 = false;
    rgba _102;
    if (!_101)
    goto _jump1524;
    if (g >= 0)
    goto _jump1525;
    fail_assertion("negative array index");
    _jump1525:;
    if (g < B.d0)
    goto _jump1526;
    fail_assertion("index too large");
    _jump1526:;
    if (c >= 0)
    goto _jump1527;
    fail_assertion("negative array index");
    _jump1527:;
    if (c < B.d1)
    goto _jump1528;
    fail_assertion("index too large");
    _jump1528:;
    int64_t _103 = 0;
    _103 *= B.d0;
    _103 += g;
    _103 *= B.d1;
    _103 += c;
    rgba _104 = B.data[_103];
    _102 = _104;
    goto _jump1529;
    _jump1524:;
    int64_t _105 = 692;
    if (_105 >= 0)
    goto _jump1530;
    fail_assertion("negative array index");
    _jump1530:;
    if (_105 < B.d0)
    goto _jump1531;
    fail_assertion("index too large");
    _jump1531:;
    if (A >= 0)
    goto _jump1532;
    fail_assertion("negative array index");
    _jump1532:;
    if (A < B.d1)
    goto _jump1533;
    fail_assertion("index too large");
    _jump1533:;
    int64_t _106 = 0;
    _106 *= B.d0;
    _106 += _105;
    _106 *= B.d1;
    _106 += A;
    rgba _107 = B.data[_106];
    _102 = _107;
    _jump1529:;
    double _108 = _102.g;
    double _109 = 60.0;
    double _110 = 70.0;
    double _111 = _109 - _110;
    h _112 = { _111 };
    double _113 = _112.a;
    double _114;
    // Computing bound for K
    if (H.d0 > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    _114 = 0;
    int64_t _115 = 0; // K
    _jump1535:; // Begin body of loop
    double _116 = 25.0;
    _114 += _116;
    _115++;
    if (_115 < H.d0)
    goto _jump1535;
    // End body of loop
    double _117 = 36.0;
    rgba _118 = { _108, _113, _114, _117 };
    int64_t _119 = 0;
    _119 *= _98.d0;
    _119 += _100;
    _98.data[_119] = _118;
    _100++;
    if (_100 < E.d0)
    goto _jump1523;
    // End body of loop
    _97 = _98;
    _jump1521:;
    _a1_bool _120;
    // Computing bound for J
    _120.d0 = d;
    if (d > 0) 
    goto _jump1536;
    fail_assertion("non-positive loop bound");
    _jump1536:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= d;
    _121 *= sizeof(bool);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // J
    _jump1537:; // Begin body of loop
    bool _123 = w <= H.d0;
    int64_t _124 = 0;
    _124 *= _120.d0;
    _124 += _122;
    _120.data[_124] = _123;
    _122++;
    if (_122 < d)
    goto _jump1537;
    // End body of loop
    if (E.d1 >= 0)
    goto _jump1538;
    fail_assertion("negative array index");
    _jump1538:;
    if (E.d1 < _120.d0)
    goto _jump1539;
    fail_assertion("index too large");
    _jump1539:;
    int64_t _125 = 0;
    _125 *= _120.d0;
    _125 += E.d1;
    bool _126 = _120.data[_125];
    bool _127 = t >= y;
    bool _128 = _126 != _127;
    bool _129 = !_128;
    _a1__a3_void_t _130;
    if (!_129)
    goto _jump1540;
    _a1__a3_void_t _131;
    // Computing bound for J
    _131.d0 = b;
    if (b > 0) 
    goto _jump1541;
    fail_assertion("non-positive loop bound");
    _jump1541:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= b;
    _132 *= sizeof(_a3_void_t);
    _131.data = jpl_alloc(_132);
    int64_t _133 = 0; // J
    _jump1542:; // Begin body of loop
    bool _134 = true;
    o _135 = { _134 };
    bool _136 = _135.a;
    _a1__a3_void_t _137;
    if (!_136)
    goto _jump1543;
    _137 = H;
    goto _jump1544;
    _jump1543:;
    _137 = H;
    _jump1544:;
    if (g >= 0)
    goto _jump1545;
    fail_assertion("negative array index");
    _jump1545:;
    if (g < _137.d0)
    goto _jump1546;
    fail_assertion("index too large");
    _jump1546:;
    int64_t _138 = 0;
    _138 *= _137.d0;
    _138 += g;
    _a3_void_t _139 = _137.data[_138];
    int64_t _140 = 0;
    _140 *= _131.d0;
    _140 += _133;
    _131.data[_140] = _139;
    _133++;
    if (_133 < b)
    goto _jump1542;
    // End body of loop
    _130 = _131;
    goto _jump1547;
    _jump1540:;
    bool _141 = H.d0 > E.d1;
    _a1__a3_void_t _142;
    if (!_141)
    goto _jump1548;
    _a1__a3_void_t _143;
    // Computing bound for J
    _143.d0 = w;
    if (w > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    // Computing total size of heap memory to allocate
    int64_t _144 = 1;
    _144 *= w;
    _144 *= sizeof(_a3_void_t);
    _143.data = jpl_alloc(_144);
    int64_t _145 = 0; // J
    _jump1550:; // Begin body of loop
    _a2__a1__a3_void_t _146;
    // Computing bound for K
    _146.d0 = u;
    if (u > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    // Computing bound for L
    _146.d1 = d;
    if (d > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= u;
    _147 *= d;
    _147 *= sizeof(_a1__a3_void_t);
    _146.data = jpl_alloc(_147);
    int64_t _148 = 0; // L
    int64_t _149 = 0; // K
    _jump1553:; // Begin body of loop
    int64_t _150 = 0;
    _150 *= _146.d0;
    _150 += _149;
    _150 *= _146.d1;
    _150 += _148;
    _146.data[_150] = H;
    _148++;
    if (_148 < d)
    goto _jump1553;
    _148 = 0;
    _149++;
    if (_149 < u)
    goto _jump1553;
    // End body of loop
    if (_145 >= 0)
    goto _jump1554;
    fail_assertion("negative array index");
    _jump1554:;
    if (_145 < f.d0)
    goto _jump1555;
    fail_assertion("index too large");
    _jump1555:;
    int64_t _151 = 0;
    _151 *= f.d0;
    _151 += _145;
    int64_t _152 = f.data[_151];
    if (_152 >= 0)
    goto _jump1556;
    fail_assertion("negative array index");
    _jump1556:;
    if (_152 < _146.d0)
    goto _jump1557;
    fail_assertion("index too large");
    _jump1557:;
    if (c >= 0)
    goto _jump1558;
    fail_assertion("negative array index");
    _jump1558:;
    if (c < _146.d1)
    goto _jump1559;
    fail_assertion("index too large");
    _jump1559:;
    int64_t _153 = 0;
    _153 *= _146.d0;
    _153 += _152;
    _153 *= _146.d1;
    _153 += c;
    _a1__a3_void_t _154 = _146.data[_153];
    int64_t _155 = A - E.d1;
    if (_155 >= 0)
    goto _jump1560;
    fail_assertion("negative array index");
    _jump1560:;
    if (_155 < _154.d0)
    goto _jump1561;
    fail_assertion("index too large");
    _jump1561:;
    int64_t _156 = 0;
    _156 *= _154.d0;
    _156 += _155;
    _a3_void_t _157 = _154.data[_156];
    int64_t _158 = 0;
    _158 *= _143.d0;
    _158 += _145;
    _143.data[_158] = _157;
    _145++;
    if (_145 < w)
    goto _jump1550;
    // End body of loop
    _142 = _143;
    goto _jump1562;
    _jump1548:;
    _a1__a3_void_t _159;
    // Computing bound for J
    _159.d0 = u;
    if (u > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= u;
    _160 *= sizeof(_a3_void_t);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // J
    _jump1564:; // Begin body of loop
    _a2__a3_void_t _162;
    // Computing bound for K
    int64_t _163 = -m;
    _162.d0 = _163;
    if (_163 > 0) 
    goto _jump1565;
    fail_assertion("non-positive loop bound");
    _jump1565:;
    // Computing bound for L
    _162.d1 = m;
    if (m > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= _163;
    _164 *= m;
    _164 *= sizeof(_a3_void_t);
    _162.data = jpl_alloc(_164);
    int64_t _165 = 0; // L
    int64_t _166 = 0; // K
    _jump1567:; // Begin body of loop
    if (z >= 0)
    goto _jump1568;
    fail_assertion("negative array index");
    _jump1568:;
    if (z < H.d0)
    goto _jump1569;
    fail_assertion("index too large");
    _jump1569:;
    int64_t _167 = 0;
    _167 *= H.d0;
    _167 += z;
    _a3_void_t _168 = H.data[_167];
    int64_t _169 = 0;
    _169 *= _162.d0;
    _169 += _166;
    _169 *= _162.d1;
    _169 += _165;
    _162.data[_169] = _168;
    _165++;
    if (_165 < m)
    goto _jump1567;
    _165 = 0;
    _166++;
    if (_166 < _163)
    goto _jump1567;
    // End body of loop
    if (l >= 0)
    goto _jump1570;
    fail_assertion("negative array index");
    _jump1570:;
    if (l < _162.d0)
    goto _jump1571;
    fail_assertion("index too large");
    _jump1571:;
    if (b >= 0)
    goto _jump1572;
    fail_assertion("negative array index");
    _jump1572:;
    if (b < _162.d1)
    goto _jump1573;
    fail_assertion("index too large");
    _jump1573:;
    int64_t _170 = 0;
    _170 *= _162.d0;
    _170 += l;
    _170 *= _162.d1;
    _170 += b;
    _a3_void_t _171 = _162.data[_170];
    int64_t _172 = 0;
    _172 *= _159.d0;
    _172 += _161;
    _159.data[_172] = _171;
    _161++;
    if (_161 < u)
    goto _jump1564;
    // End body of loop
    _142 = _159;
    _jump1562:;
    _130 = _142;
    _jump1547:;
    _a2_double _173 = C(_97, E, _130);
    bool _174 = false;
    bool _175 = !_174;
    _a2_double _176;
    if (!_175)
    goto _jump1574;
    _176 = _173;
    goto _jump1575;
    _jump1574:;
    _176 = _173;
    _jump1575:;
    if (w >= 0)
    goto _jump1576;
    fail_assertion("negative array index");
    _jump1576:;
    if (w < _176.d0)
    goto _jump1577;
    fail_assertion("index too large");
    _jump1577:;
    if (_173.d0 >= 0)
    goto _jump1578;
    fail_assertion("negative array index");
    _jump1578:;
    if (_173.d0 < _176.d1)
    goto _jump1579;
    fail_assertion("index too large");
    _jump1579:;
    int64_t _177 = 0;
    _177 *= _176.d0;
    _177 += w;
    _177 *= _176.d1;
    _177 += _173.d0;
    double _178 = _176.data[_177];
    double _179 = 5.0;
    bool _180 = _178 > _179;
    o _181 = { _180 };
    bool _182 = _181.a;
    _a3_int64_t _183;
    if (!_182)
    goto _jump1580;
    double _184 = 23.0;
    double _185;
    // Computing bound for R
    _a2_int64_t _186;
    // Computing bound for R
    _186.d0 = _173.d1;
    if (_173.d1 > 0) 
    goto _jump1581;
    fail_assertion("non-positive loop bound");
    _jump1581:;
    // Computing bound for S
    _186.d1 = g;
    if (g > 0) 
    goto _jump1582;
    fail_assertion("non-positive loop bound");
    _jump1582:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= _173.d1;
    _187 *= g;
    _187 *= sizeof(int64_t);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // S
    int64_t _189 = 0; // R
    _jump1583:; // Begin body of loop
    int64_t _190 = 0;
    _190 *= _186.d0;
    _190 += _189;
    _190 *= _186.d1;
    _190 += _188;
    _186.data[_190] = s;
    _188++;
    if (_188 < g)
    goto _jump1583;
    _188 = 0;
    _189++;
    if (_189 < _173.d1)
    goto _jump1583;
    // End body of loop
    int64_t _191 = 576;
    int64_t _192 = u % _191;
    if (_192 >= 0)
    goto _jump1584;
    fail_assertion("negative array index");
    _jump1584:;
    if (_192 < _186.d0)
    goto _jump1585;
    fail_assertion("index too large");
    _jump1585:;
    if (d >= 0)
    goto _jump1586;
    fail_assertion("negative array index");
    _jump1586:;
    if (d < _186.d1)
    goto _jump1587;
    fail_assertion("index too large");
    _jump1587:;
    int64_t _193 = 0;
    _193 *= _186.d0;
    _193 += _192;
    _193 *= _186.d1;
    _193 += d;
    int64_t _194 = _186.data[_193];
    if (_194 > 0) 
    goto _jump1588;
    fail_assertion("non-positive loop bound");
    _jump1588:;
    // Computing bound for S
    int64_t _195;
    // Computing bound for R
    if (u > 0) 
    goto _jump1589;
    fail_assertion("non-positive loop bound");
    _jump1589:;
    // Computing bound for S
    if (A > 0) 
    goto _jump1590;
    fail_assertion("non-positive loop bound");
    _jump1590:;
    _195 = 0;
    int64_t _196 = 0; // S
    int64_t _197 = 0; // R
    _jump1591:; // Begin body of loop
    if (_197 >= 0)
    goto _jump1592;
    fail_assertion("negative array index");
    _jump1592:;
    if (_197 < a.d0)
    goto _jump1593;
    fail_assertion("index too large");
    _jump1593:;
    if (t >= 0)
    goto _jump1594;
    fail_assertion("negative array index");
    _jump1594:;
    if (t < a.d1)
    goto _jump1595;
    fail_assertion("index too large");
    _jump1595:;
    if (E.d1 >= 0)
    goto _jump1596;
    fail_assertion("negative array index");
    _jump1596:;
    if (E.d1 < a.d2)
    goto _jump1597;
    fail_assertion("index too large");
    _jump1597:;
    int64_t _198 = 0;
    _198 *= a.d0;
    _198 += _197;
    _198 *= a.d1;
    _198 += t;
    _198 *= a.d2;
    _198 += E.d1;
    int64_t _199 = a.data[_198];
    _195 += _199;
    _196++;
    if (_196 < A)
    goto _jump1591;
    _196 = 0;
    _197++;
    if (_197 < u)
    goto _jump1591;
    // End body of loop
    if (_195 > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    _185 = 0;
    int64_t _200 = 0; // S
    int64_t _201 = 0; // R
    _jump1599:; // Begin body of loop
    double _202;
    // Computing bound for T
    if (B.d0 > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    _202 = 0;
    int64_t _203 = 0; // T
    _jump1601:; // Begin body of loop
    double _204 = 11.0;
    _202 += _204;
    _203++;
    if (_203 < B.d0)
    goto _jump1601;
    // End body of loop
    double _205 = -_202;
    _185 += _205;
    _200++;
    if (_200 < _195)
    goto _jump1599;
    _200 = 0;
    _201++;
    if (_201 < _194)
    goto _jump1599;
    // End body of loop
    bool _206 = _184 <= _185;
    bool _207;
    if (!_206)
    goto _jump1602;
    bool _208 = false;
    o _209 = { _208 };
    int64_t _210;
    // Computing bound for R
    if (H.d0 > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    _210 = 0;
    int64_t _211 = 0; // R
    _jump1604:; // Begin body of loop
    _210 += u;
    _211++;
    if (_211 < H.d0)
    goto _jump1604;
    // End body of loop
    if (d >= 0)
    goto _jump1605;
    fail_assertion("negative array index");
    _jump1605:;
    if (d < v.d0)
    goto _jump1606;
    fail_assertion("index too large");
    _jump1606:;
    int64_t _212 = 0;
    _212 *= v.d0;
    _212 += d;
    rgba _213 = v.data[_212];
    rgba _214 = p(_209, _210, _213);
    double _215 = _214.g;
    double _216;
    // Computing bound for R
    int64_t _217 = 335;
    _a1_int64_t _218;
    _218.d0 = 1;
    _218.data = jpl_alloc(sizeof(int64_t) * 1);
    _218.data[0] = _217;
    if (H.d0 >= 0)
    goto _jump1607;
    fail_assertion("negative array index");
    _jump1607:;
    if (H.d0 < _218.d0)
    goto _jump1608;
    fail_assertion("index too large");
    _jump1608:;
    int64_t _219 = 0;
    _219 *= _218.d0;
    _219 += H.d0;
    int64_t _220 = _218.data[_219];
    if (_220 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    _216 = 0;
    int64_t _221 = 0; // R
    _jump1610:; // Begin body of loop
    double _222 = 16.0;
    _216 += _222;
    _221++;
    if (_221 < _220)
    goto _jump1610;
    // End body of loop
    bool _223 = _215 > _216;
    _207 = _223;
    goto _jump1611;
    _jump1602:;
    bool _224 = false;
    bool _225 = !_224;
    _207 = _225;
    _jump1611:;
    _a3_int64_t _226;
    if (!_207)
    goto _jump1612;
    _a3_int64_t _227;
    // Computing bound for R
    _227.d0 = A;
    if (A > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for S
    bool _228 = false;
    double _229 = 48.0;
    double _230 = 17.0;
    double _231 = _229 + _230;
    h _232 = { _231 };
    i _233 = { _228, _232, _173.d1 };
    int64_t _234 = _233.c;
    _227.d1 = _234;
    if (_234 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for T
    int64_t _235;
    // Computing bound for R
    int64_t _236;
    // Computing bound for R
    if (t > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    // Computing bound for S
    if (u > 0) 
    goto _jump1616;
    fail_assertion("non-positive loop bound");
    _jump1616:;
    _236 = 0;
    int64_t _237 = 0; // S
    int64_t _238 = 0; // R
    _jump1617:; // Begin body of loop
    _236 += c;
    _237++;
    if (_237 < u)
    goto _jump1617;
    _237 = 0;
    _238++;
    if (_238 < t)
    goto _jump1617;
    // End body of loop
    if (_236 > 0) 
    goto _jump1618;
    fail_assertion("non-positive loop bound");
    _jump1618:;
    // Computing bound for S
    int64_t _239 = -u;
    if (_239 > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    // Computing bound for T
    if (g > 0) 
    goto _jump1620;
    fail_assertion("non-positive loop bound");
    _jump1620:;
    _235 = 0;
    int64_t _240 = 0; // T
    int64_t _241 = 0; // S
    int64_t _242 = 0; // R
    _jump1621:; // Begin body of loop
    int64_t _243 = -u;
    _235 += _243;
    _240++;
    if (_240 < g)
    goto _jump1621;
    _240 = 0;
    _241++;
    if (_241 < _239)
    goto _jump1621;
    _241 = 0;
    _242++;
    if (_242 < _236)
    goto _jump1621;
    // End body of loop
    _227.d2 = _235;
    if (_235 > 0) 
    goto _jump1622;
    fail_assertion("non-positive loop bound");
    _jump1622:;
    // Computing total size of heap memory to allocate
    int64_t _244 = 1;
    _244 *= A;
    _244 *= _234;
    _244 *= _235;
    _244 *= sizeof(int64_t);
    _227.data = jpl_alloc(_244);
    int64_t _245 = 0; // T
    int64_t _246 = 0; // S
    int64_t _247 = 0; // R
    _jump1623:; // Begin body of loop
    int64_t _248 = 0;
    _248 *= _227.d0;
    _248 += _247;
    _248 *= _227.d1;
    _248 += _246;
    _248 *= _227.d2;
    _248 += _245;
    _227.data[_248] = m;
    _245++;
    if (_245 < _235)
    goto _jump1623;
    _245 = 0;
    _246++;
    if (_246 < _234)
    goto _jump1623;
    _246 = 0;
    _247++;
    if (_247 < A)
    goto _jump1623;
    // End body of loop
    _226 = _227;
    goto _jump1624;
    _jump1612:;
    _226 = x;
    _jump1624:;
    _183 = _226;
    goto _jump1625;
    _jump1580:;
    _183 = r;
    _jump1625:;
    _a2_bool _250;
    // Computing bound for V
    int64_t _251 = _183.d0 + _173.d0;
    _250.d0 = _251;
    if (_251 > 0) 
    goto _jump1626;
    fail_assertion("non-positive loop bound");
    _jump1626:;
    // Computing bound for W
    _250.d1 = E.d1;
    if (E.d1 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing total size of heap memory to allocate
    int64_t _252 = 1;
    _252 *= _251;
    _252 *= E.d1;
    _252 *= sizeof(bool);
    _250.data = jpl_alloc(_252);
    int64_t _253 = 0; // W
    int64_t _254 = 0; // V
    _jump1628:; // Begin body of loop
    bool _255 = false;
    bool _256 = !_255;
    int64_t _257 = 0;
    _257 *= _250.d0;
    _257 += _254;
    _257 *= _250.d1;
    _257 += _253;
    _250.data[_257] = _256;
    _253++;
    if (_253 < E.d1)
    goto _jump1628;
    _253 = 0;
    _254++;
    if (_254 < _251)
    goto _jump1628;
    // End body of loop
    int64_t _258;
    // Computing bound for V
    if (H.d0 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing bound for W
    int64_t _259 = 13;
    if (_259 > 0) 
    goto _jump1630;
    fail_assertion("non-positive loop bound");
    _jump1630:;
    _258 = 0;
    int64_t _260 = 0; // W
    int64_t _261 = 0; // V
    _jump1631:; // Begin body of loop
    _258 += B.d0;
    _260++;
    if (_260 < _259)
    goto _jump1631;
    _260 = 0;
    _261++;
    if (_261 < H.d0)
    goto _jump1631;
    // End body of loop
    bool _262 = false;
    int64_t _263;
    if (!_262)
    goto _jump1632;
    _263 = H.d0;
    goto _jump1633;
    _jump1632:;
    _263 = g;
    _jump1633:;
    if (_258 >= 0)
    goto _jump1634;
    fail_assertion("negative array index");
    _jump1634:;
    if (_258 < _250.d0)
    goto _jump1635;
    fail_assertion("index too large");
    _jump1635:;
    if (_263 >= 0)
    goto _jump1636;
    fail_assertion("negative array index");
    _jump1636:;
    if (_263 < _250.d1)
    goto _jump1637;
    fail_assertion("index too large");
    _jump1637:;
    int64_t _264 = 0;
    _264 *= _250.d0;
    _264 += _258;
    _264 *= _250.d1;
    _264 += _263;
    bool _265 = _250.data[_264];
    i _266;
    if (!_265)
    goto _jump1638;
    bool _268 = true;
    bool _267 = _268;
    if (0 == _268)
    goto _jump1639;
    bool _269 = true;
    _267 = _269;
    _jump1639:;
    double _270 = 37.0;
    h _271 = { _270 };
    i _272 = { _267, _271, _183.d0 };
    _266 = _272;
    goto _jump1640;
    _jump1638:;
    bool _273 = false;
    double _274;
    // Computing bound for V
    if (A > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    _274 = 0;
    int64_t _275 = 0; // V
    _jump1642:; // Begin body of loop
    double _276 = 90.0;
    _274 += _276;
    _275++;
    if (_275 < A)
    goto _jump1642;
    // End body of loop
    h _277 = { _274 };
    i _278 = { _273, _277, z };
    _266 = _278;
    _jump1640:;
    bool _279 = _266.a;
    bool _249 = _279;
    if (0 != _279)
    goto _jump1643;
    bool _280 = true;
    _249 = _280;
    _jump1643:;
    _a2_double _281;
    if (!_249)
    goto _jump1644;
    _a2_double _282;
    // Computing bound for V
    int64_t _283;
    // Computing bound for V
    if (A > 0) 
    goto _jump1645;
    fail_assertion("non-positive loop bound");
    _jump1645:;
    _283 = 0;
    int64_t _284 = 0; // V
    _jump1646:; // Begin body of loop
    _283 += B.d0;
    _284++;
    if (_284 < A)
    goto _jump1646;
    // End body of loop
    _282.d0 = _283;
    if (_283 > 0) 
    goto _jump1647;
    fail_assertion("non-positive loop bound");
    _jump1647:;
    // Computing bound for W
    _282.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    // Computing total size of heap memory to allocate
    int64_t _285 = 1;
    _285 *= _283;
    _285 *= H.d0;
    _285 *= sizeof(double);
    _282.data = jpl_alloc(_285);
    int64_t _286 = 0; // W
    int64_t _287 = 0; // V
    _jump1649:; // Begin body of loop
    double _288 = 13.0;
    int64_t _289 = 0;
    _289 *= _282.d0;
    _289 += _287;
    _289 *= _282.d1;
    _289 += _286;
    _282.data[_289] = _288;
    _286++;
    if (_286 < H.d0)
    goto _jump1649;
    _286 = 0;
    _287++;
    if (_287 < _283)
    goto _jump1649;
    // End body of loop
    _281 = _282;
    goto _jump1650;
    _jump1644:;
    _281 = _173;
    _jump1650:;
    return _281;
}

i E() {
    _a1_int64_t _0;
    // Computing bound for F
    _a3__a1_int64_t _1;
    // Computing bound for F
    _1.d0 = t;
    if (t > 0) 
    goto _jump1731;
    fail_assertion("non-positive loop bound");
    _jump1731:;
    // Computing bound for G
    _1.d1 = A;
    if (A > 0) 
    goto _jump1732;
    fail_assertion("non-positive loop bound");
    _jump1732:;
    // Computing bound for H
    _1.d2 = b;
    if (b > 0) 
    goto _jump1733;
    fail_assertion("non-positive loop bound");
    _jump1733:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= t;
    _2 *= A;
    _2 *= b;
    _2 *= sizeof(_a1_int64_t);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // H
    int64_t _4 = 0; // G
    int64_t _5 = 0; // F
    _jump1734:; // Begin body of loop
    int64_t _6 = 0;
    _6 *= _1.d0;
    _6 += _5;
    _6 *= _1.d1;
    _6 += _4;
    _6 *= _1.d2;
    _6 += _3;
    _1.data[_6] = e;
    _3++;
    if (_3 < b)
    goto _jump1734;
    _3 = 0;
    _4++;
    if (_4 < A)
    goto _jump1734;
    _4 = 0;
    _5++;
    if (_5 < t)
    goto _jump1734;
    // End body of loop
    int64_t _7;
    // Computing bound for F
    bool _9 = true;
    bool _8 = _9;
    if (0 == _9)
    goto _jump1735;
    i _10 = E();
    bool _11 = _10.a;
    _8 = _11;
    _jump1735:;
    int64_t _12;
    if (!_8)
    goto _jump1736;
    _12 = m;
    goto _jump1737;
    _jump1736:;
    _12 = u;
    _jump1737:;
    if (_12 > 0) 
    goto _jump1738;
    fail_assertion("non-positive loop bound");
    _jump1738:;
    // Computing bound for G
    if (s > 0) 
    goto _jump1739;
    fail_assertion("non-positive loop bound");
    _jump1739:;
    // Computing bound for H
    if (t > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    _7 = 0;
    int64_t _13 = 0; // H
    int64_t _14 = 0; // G
    int64_t _15 = 0; // F
    _jump1741:; // Begin body of loop
    int64_t _16 = m % l;
    _7 += _16;
    _13++;
    if (_13 < t)
    goto _jump1741;
    _13 = 0;
    _14++;
    if (_14 < s)
    goto _jump1741;
    _14 = 0;
    _15++;
    if (_15 < _12)
    goto _jump1741;
    // End body of loop
    if (_7 >= 0)
    goto _jump1742;
    fail_assertion("negative array index");
    _jump1742:;
    if (_7 < _1.d0)
    goto _jump1743;
    fail_assertion("index too large");
    _jump1743:;
    if (d >= 0)
    goto _jump1744;
    fail_assertion("negative array index");
    _jump1744:;
    if (d < _1.d1)
    goto _jump1745;
    fail_assertion("index too large");
    _jump1745:;
    if (z >= 0)
    goto _jump1746;
    fail_assertion("negative array index");
    _jump1746:;
    if (z < _1.d2)
    goto _jump1747;
    fail_assertion("index too large");
    _jump1747:;
    int64_t _17 = 0;
    _17 *= _1.d0;
    _17 += _7;
    _17 *= _1.d1;
    _17 += d;
    _17 *= _1.d2;
    _17 += z;
    _a1_int64_t _18 = _1.data[_17];
    if (d >= 0)
    goto _jump1748;
    fail_assertion("negative array index");
    _jump1748:;
    if (d < _18.d0)
    goto _jump1749;
    fail_assertion("index too large");
    _jump1749:;
    int64_t _19 = 0;
    _19 *= _18.d0;
    _19 += d;
    int64_t _20 = _18.data[_19];
    _0.d0 = _20;
    if (_20 > 0) 
    goto _jump1750;
    fail_assertion("non-positive loop bound");
    _jump1750:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= _20;
    _21 *= sizeof(int64_t);
    _0.data = jpl_alloc(_21);
    int64_t _22 = 0; // F
    _jump1751:; // Begin body of loop
    int64_t _23 = 0;
    _23 *= _0.d0;
    _23 += _22;
    _0.data[_23] = u;
    _22++;
    if (_22 < _20)
    goto _jump1751;
    // End body of loop
    _a1_int64_t _24;
    // Computing bound for J
    _24.d0 = y;
    if (y > 0) 
    goto _jump1752;
    fail_assertion("non-positive loop bound");
    _jump1752:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= y;
    _25 *= sizeof(int64_t);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // J
    _jump1753:; // Begin body of loop
    int64_t _27 = 0;
    _27 *= _24.d0;
    _27 += _26;
    _24.data[_27] = _26;
    _26++;
    if (_26 < y)
    goto _jump1753;
    // End body of loop
    _a1__a1_int64_t _28;
    _28.d0 = 2;
    _28.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _28.data[0] = _0;
    _28.data[1] = _24;
    int64_t _29 = -m;
    _a3__a1__a2_int64_t _30;
    // Computing bound for M
    _30.d0 = y;
    if (y > 0) 
    goto _jump1754;
    fail_assertion("non-positive loop bound");
    _jump1754:;
    // Computing bound for N
    _30.d1 = t;
    if (t > 0) 
    goto _jump1755;
    fail_assertion("non-positive loop bound");
    _jump1755:;
    // Computing bound for O
    int64_t _31 = -y;
    _30.d2 = _31;
    if (_31 > 0) 
    goto _jump1756;
    fail_assertion("non-positive loop bound");
    _jump1756:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= y;
    _32 *= t;
    _32 *= _31;
    _32 *= sizeof(_a1__a2_int64_t);
    _30.data = jpl_alloc(_32);
    int64_t _33 = 0; // O
    int64_t _34 = 0; // N
    int64_t _35 = 0; // M
    _jump1757:; // Begin body of loop
    i _36 = E();
    bool _37 = _36.a;
    i _38 = E();
    bool _39 = _38.a;
    bool _40 = _37 != _39;
    _a1__a2_int64_t _41;
    if (!_40)
    goto _jump1758;
    bool _42 = true;
    _a2_int64_t _43;
    if (!_42)
    goto _jump1759;
    _a2_int64_t _44;
    // Computing bound for P
    _44.d0 = s;
    if (s > 0) 
    goto _jump1760;
    fail_assertion("non-positive loop bound");
    _jump1760:;
    // Computing bound for Q
    _44.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1761;
    fail_assertion("non-positive loop bound");
    _jump1761:;
    // Computing total size of heap memory to allocate
    int64_t _45 = 1;
    _45 *= s;
    _45 *= _0.d0;
    _45 *= sizeof(int64_t);
    _44.data = jpl_alloc(_45);
    int64_t _46 = 0; // Q
    int64_t _47 = 0; // P
    _jump1762:; // Begin body of loop
    int64_t _48 = 0;
    _48 *= _44.d0;
    _48 += _47;
    _48 *= _44.d1;
    _48 += _46;
    _44.data[_48] = y;
    _46++;
    if (_46 < _0.d0)
    goto _jump1762;
    _46 = 0;
    _47++;
    if (_47 < s)
    goto _jump1762;
    // End body of loop
    _43 = _44;
    goto _jump1763;
    _jump1759:;
    _a2_int64_t _49;
    // Computing bound for P
    _49.d0 = _29;
    if (_29 > 0) 
    goto _jump1764;
    fail_assertion("non-positive loop bound");
    _jump1764:;
    // Computing bound for Q
    _49.d1 = b;
    if (b > 0) 
    goto _jump1765;
    fail_assertion("non-positive loop bound");
    _jump1765:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _29;
    _50 *= b;
    _50 *= sizeof(int64_t);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // Q
    int64_t _52 = 0; // P
    _jump1766:; // Begin body of loop
    int64_t _53 = 0;
    _53 *= _49.d0;
    _53 += _52;
    _53 *= _49.d1;
    _53 += _51;
    _49.data[_53] = _35;
    _51++;
    if (_51 < b)
    goto _jump1766;
    _51 = 0;
    _52++;
    if (_52 < _29)
    goto _jump1766;
    // End body of loop
    _43 = _49;
    _jump1763:;
    _a1__a2_int64_t _54;
    _54.d0 = 3;
    _54.data = jpl_alloc(sizeof(_a2_int64_t) * 3);
    _54.data[0] = _43;
    _54.data[1] = k;
    _54.data[2] = k;
    _41 = _54;
    goto _jump1767;
    _jump1758:;
    i _56 = E();
    bool _57 = _56.a;
    bool _55 = _57;
    if (0 == _57)
    goto _jump1768;
    bool _58 = false;
    _55 = _58;
    _jump1768:;
    _a1__a2_int64_t _59;
    if (!_55)
    goto _jump1769;
    _a1__a2_int64_t _60;
    // Computing bound for P
    int64_t _61 = 318;
    if (l >= 0)
    goto _jump1770;
    fail_assertion("negative array index");
    _jump1770:;
    if (l < a.d0)
    goto _jump1771;
    fail_assertion("index too large");
    _jump1771:;
    if (_61 >= 0)
    goto _jump1772;
    fail_assertion("negative array index");
    _jump1772:;
    if (_61 < a.d1)
    goto _jump1773;
    fail_assertion("index too large");
    _jump1773:;
    if (_29 >= 0)
    goto _jump1774;
    fail_assertion("negative array index");
    _jump1774:;
    if (_29 < a.d2)
    goto _jump1775;
    fail_assertion("index too large");
    _jump1775:;
    int64_t _62 = 0;
    _62 *= a.d0;
    _62 += l;
    _62 *= a.d1;
    _62 += _61;
    _62 *= a.d2;
    _62 += _29;
    int64_t _63 = a.data[_62];
    _60.d0 = _63;
    if (_63 > 0) 
    goto _jump1776;
    fail_assertion("non-positive loop bound");
    _jump1776:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= _63;
    _64 *= sizeof(_a2_int64_t);
    _60.data = jpl_alloc(_64);
    int64_t _65 = 0; // P
    _jump1777:; // Begin body of loop
    int64_t _66 = 0;
    _66 *= _60.d0;
    _66 += _65;
    _60.data[_66] = k;
    _65++;
    if (_65 < _63)
    goto _jump1777;
    // End body of loop
    _59 = _60;
    goto _jump1778;
    _jump1769:;
    _a1__a2_int64_t _67;
    // Computing bound for P
    _67.d0 = d;
    if (d > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= d;
    _68 *= sizeof(_a2_int64_t);
    _67.data = jpl_alloc(_68);
    int64_t _69 = 0; // P
    _jump1780:; // Begin body of loop
    int64_t _70 = 0;
    _70 *= _67.d0;
    _70 += _69;
    _67.data[_70] = k;
    _69++;
    if (_69 < d)
    goto _jump1780;
    // End body of loop
    _59 = _67;
    _jump1778:;
    _41 = _59;
    _jump1767:;
    int64_t _71 = 0;
    _71 *= _30.d0;
    _71 += _35;
    _71 *= _30.d1;
    _71 += _34;
    _71 *= _30.d2;
    _71 += _33;
    _30.data[_71] = _41;
    _33++;
    if (_33 < _31)
    goto _jump1757;
    _33 = 0;
    _34++;
    if (_34 < t)
    goto _jump1757;
    _34 = 0;
    _35++;
    if (_35 < y)
    goto _jump1757;
    // End body of loop
    bool _72 = y > g;
    o _73 = { _72 };
    _a3_i _74;
    // Computing bound for M
    _74.d0 = s;
    if (s > 0) 
    goto _jump1781;
    fail_assertion("non-positive loop bound");
    _jump1781:;
    // Computing bound for N
    _74.d1 = l;
    if (l > 0) 
    goto _jump1782;
    fail_assertion("non-positive loop bound");
    _jump1782:;
    // Computing bound for O
    _74.d2 = d;
    if (d > 0) 
    goto _jump1783;
    fail_assertion("non-positive loop bound");
    _jump1783:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= s;
    _75 *= l;
    _75 *= d;
    _75 *= sizeof(i);
    _74.data = jpl_alloc(_75);
    int64_t _76 = 0; // O
    int64_t _77 = 0; // N
    int64_t _78 = 0; // M
    _jump1784:; // Begin body of loop
    i _79 = E();
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += _78;
    _80 *= _74.d1;
    _80 += _77;
    _80 *= _74.d2;
    _80 += _76;
    _74.data[_80] = _79;
    _76++;
    if (_76 < d)
    goto _jump1784;
    _76 = 0;
    _77++;
    if (_77 < l)
    goto _jump1784;
    _77 = 0;
    _78++;
    if (_78 < s)
    goto _jump1784;
    // End body of loop
    bool _81 = false;
    _a2__a2_rgba _82;
    if (!_81)
    goto _jump1785;
    _a2__a2_rgba _83;
    // Computing bound for M
    _83.d0 = s;
    if (s > 0) 
    goto _jump1786;
    fail_assertion("non-positive loop bound");
    _jump1786:;
    // Computing bound for N
    _83.d1 = u;
    if (u > 0) 
    goto _jump1787;
    fail_assertion("non-positive loop bound");
    _jump1787:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= s;
    _84 *= u;
    _84 *= sizeof(_a2_rgba);
    _83.data = jpl_alloc(_84);
    int64_t _85 = 0; // N
    int64_t _86 = 0; // M
    _jump1788:; // Begin body of loop
    int64_t _87 = 0;
    _87 *= _83.d0;
    _87 += _86;
    _87 *= _83.d1;
    _87 += _85;
    _83.data[_87] = B;
    _85++;
    if (_85 < u)
    goto _jump1788;
    _85 = 0;
    _86++;
    if (_86 < s)
    goto _jump1788;
    // End body of loop
    _82 = _83;
    goto _jump1789;
    _jump1785:;
    _a2__a2_rgba _88;
    // Computing bound for M
    _88.d0 = s;
    if (s > 0) 
    goto _jump1790;
    fail_assertion("non-positive loop bound");
    _jump1790:;
    // Computing bound for N
    _88.d1 = l;
    if (l > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= s;
    _89 *= l;
    _89 *= sizeof(_a2_rgba);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // N
    int64_t _91 = 0; // M
    _jump1792:; // Begin body of loop
    int64_t _92 = 0;
    _92 *= _88.d0;
    _92 += _91;
    _92 *= _88.d1;
    _92 += _90;
    _88.data[_92] = B;
    _90++;
    if (_90 < l)
    goto _jump1792;
    _90 = 0;
    _91++;
    if (_91 < s)
    goto _jump1792;
    // End body of loop
    _82 = _88;
    _jump1789:;
    int64_t _93;
    // Computing bound for M
    if (_29 > 0) 
    goto _jump1793;
    fail_assertion("non-positive loop bound");
    _jump1793:;
    _93 = 0;
    int64_t _94 = 0; // M
    _jump1794:; // Begin body of loop
    _93 += g;
    _94++;
    if (_94 < _29)
    goto _jump1794;
    // End body of loop
    if (_93 >= 0)
    goto _jump1795;
    fail_assertion("negative array index");
    _jump1795:;
    if (_93 < _82.d0)
    goto _jump1796;
    fail_assertion("index too large");
    _jump1796:;
    if (l >= 0)
    goto _jump1797;
    fail_assertion("negative array index");
    _jump1797:;
    if (l < _82.d1)
    goto _jump1798;
    fail_assertion("index too large");
    _jump1798:;
    int64_t _95 = 0;
    _95 *= _82.d0;
    _95 += _93;
    _95 *= _82.d1;
    _95 += l;
    _a2_rgba _96 = _82.data[_95];
    _a3__a3_bool _97;
    // Computing bound for M
    _97.d0 = w;
    if (w > 0) 
    goto _jump1799;
    fail_assertion("non-positive loop bound");
    _jump1799:;
    // Computing bound for N
    _97.d1 = y;
    if (y > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for O
    _97.d2 = c;
    if (c > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing total size of heap memory to allocate
    int64_t _98 = 1;
    _98 *= w;
    _98 *= y;
    _98 *= c;
    _98 *= sizeof(_a3_bool);
    _97.data = jpl_alloc(_98);
    int64_t _99 = 0; // O
    int64_t _100 = 0; // N
    int64_t _101 = 0; // M
    _jump1802:; // Begin body of loop
    _a3_bool _102;
    // Computing bound for P
    _102.d0 = w;
    if (w > 0) 
    goto _jump1803;
    fail_assertion("non-positive loop bound");
    _jump1803:;
    // Computing bound for Q
    _102.d1 = D;
    if (D > 0) 
    goto _jump1804;
    fail_assertion("non-positive loop bound");
    _jump1804:;
    // Computing bound for R
    _102.d2 = g;
    if (g > 0) 
    goto _jump1805;
    fail_assertion("non-positive loop bound");
    _jump1805:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= w;
    _103 *= D;
    _103 *= g;
    _103 *= sizeof(bool);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // R
    int64_t _105 = 0; // Q
    int64_t _106 = 0; // P
    _jump1806:; // Begin body of loop
    bool _107 = true;
    int64_t _108 = 0;
    _108 *= _102.d0;
    _108 += _106;
    _108 *= _102.d1;
    _108 += _105;
    _108 *= _102.d2;
    _108 += _104;
    _102.data[_108] = _107;
    _104++;
    if (_104 < g)
    goto _jump1806;
    _104 = 0;
    _105++;
    if (_105 < D)
    goto _jump1806;
    _105 = 0;
    _106++;
    if (_106 < w)
    goto _jump1806;
    // End body of loop
    int64_t _109 = 0;
    _109 *= _97.d0;
    _109 += _101;
    _109 *= _97.d1;
    _109 += _100;
    _109 *= _97.d2;
    _109 += _99;
    _97.data[_109] = _102;
    _99++;
    if (_99 < c)
    goto _jump1802;
    _99 = 0;
    _100++;
    if (_100 < y)
    goto _jump1802;
    _100 = 0;
    _101++;
    if (_101 < w)
    goto _jump1802;
    // End body of loop
    if (A >= 0)
    goto _jump1807;
    fail_assertion("negative array index");
    _jump1807:;
    if (A < _97.d0)
    goto _jump1808;
    fail_assertion("index too large");
    _jump1808:;
    if (c >= 0)
    goto _jump1809;
    fail_assertion("negative array index");
    _jump1809:;
    if (c < _97.d1)
    goto _jump1810;
    fail_assertion("index too large");
    _jump1810:;
    if (b >= 0)
    goto _jump1811;
    fail_assertion("negative array index");
    _jump1811:;
    if (b < _97.d2)
    goto _jump1812;
    fail_assertion("index too large");
    _jump1812:;
    int64_t _110 = 0;
    _110 *= _97.d0;
    _110 += A;
    _110 *= _97.d1;
    _110 += c;
    _110 *= _97.d2;
    _110 += b;
    _a3_bool _111 = _97.data[_110];
    void_t _112 = j(_74, _96, _111);
    _a3__a1_o _113;
    // Computing bound for M
    _113.d0 = b;
    if (b > 0) 
    goto _jump1813;
    fail_assertion("non-positive loop bound");
    _jump1813:;
    // Computing bound for N
    i _114 = E();
    bool _115 = _114.a;
    int64_t _116;
    if (!_115)
    goto _jump1814;
    _116 = _29;
    goto _jump1815;
    _jump1814:;
    _116 = d;
    _jump1815:;
    _113.d1 = _116;
    if (_116 > 0) 
    goto _jump1816;
    fail_assertion("non-positive loop bound");
    _jump1816:;
    // Computing bound for O
    _113.d2 = z;
    if (z > 0) 
    goto _jump1817;
    fail_assertion("non-positive loop bound");
    _jump1817:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= b;
    _117 *= _116;
    _117 *= z;
    _117 *= sizeof(_a1_o);
    _113.data = jpl_alloc(_117);
    int64_t _118 = 0; // O
    int64_t _119 = 0; // N
    int64_t _120 = 0; // M
    _jump1818:; // Begin body of loop
    _a1_o _121;
    // Computing bound for P
    _121.d0 = d;
    if (d > 0) 
    goto _jump1819;
    fail_assertion("non-positive loop bound");
    _jump1819:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= d;
    _122 *= sizeof(o);
    _121.data = jpl_alloc(_122);
    int64_t _123 = 0; // P
    _jump1820:; // Begin body of loop
    bool _124 = true;
    o _125 = { _124 };
    int64_t _126 = 0;
    _126 *= _121.d0;
    _126 += _123;
    _121.data[_126] = _125;
    _123++;
    if (_123 < d)
    goto _jump1820;
    // End body of loop
    int64_t _127 = 0;
    _127 *= _113.d0;
    _127 += _120;
    _127 *= _113.d1;
    _127 += _119;
    _127 *= _113.d2;
    _127 += _118;
    _113.data[_127] = _121;
    _118++;
    if (_118 < z)
    goto _jump1818;
    _118 = 0;
    _119++;
    if (_119 < _116)
    goto _jump1818;
    _119 = 0;
    _120++;
    if (_120 < b)
    goto _jump1818;
    // End body of loop
    int64_t _128 = -u;
    bool _129 = g != _0.d0;
    double _130 = 70.0;
    h _131 = { _130 };
    i _132 = { _129, _131, w };
    int64_t _133 = _132.c;
    if (_128 >= 0)
    goto _jump1821;
    fail_assertion("negative array index");
    _jump1821:;
    if (_128 < _113.d0)
    goto _jump1822;
    fail_assertion("index too large");
    _jump1822:;
    if (_133 >= 0)
    goto _jump1823;
    fail_assertion("negative array index");
    _jump1823:;
    if (_133 < _113.d1)
    goto _jump1824;
    fail_assertion("index too large");
    _jump1824:;
    if (_29 >= 0)
    goto _jump1825;
    fail_assertion("negative array index");
    _jump1825:;
    if (_29 < _113.d2)
    goto _jump1826;
    fail_assertion("index too large");
    _jump1826:;
    int64_t _134 = 0;
    _134 *= _113.d0;
    _134 += _128;
    _134 *= _113.d1;
    _134 += _133;
    _134 *= _113.d2;
    _134 += _29;
    _a1_o _135 = _113.data[_134];
    int64_t _136 = q(_73, _112, _135);
    if (_0.d0 >= 0)
    goto _jump1827;
    fail_assertion("negative array index");
    _jump1827:;
    if (_0.d0 < _30.d0)
    goto _jump1828;
    fail_assertion("index too large");
    _jump1828:;
    if (_136 >= 0)
    goto _jump1829;
    fail_assertion("negative array index");
    _jump1829:;
    if (_136 < _30.d1)
    goto _jump1830;
    fail_assertion("index too large");
    _jump1830:;
    if (_28.d0 >= 0)
    goto _jump1831;
    fail_assertion("negative array index");
    _jump1831:;
    if (_28.d0 < _30.d2)
    goto _jump1832;
    fail_assertion("index too large");
    _jump1832:;
    int64_t _137 = 0;
    _137 *= _30.d0;
    _137 += _0.d0;
    _137 *= _30.d1;
    _137 += _136;
    _137 *= _30.d2;
    _137 += _28.d0;
    _a1__a2_int64_t _138 = _30.data[_137];
    if (w >= 0)
    goto _jump1833;
    fail_assertion("negative array index");
    _jump1833:;
    if (w < _138.d0)
    goto _jump1834;
    fail_assertion("index too large");
    _jump1834:;
    int64_t _139 = 0;
    _139 *= _138.d0;
    _139 += w;
    _a2_int64_t _140 = _138.data[_139];
    i _142 = E();
    bool _143 = _142.a;
    bool _144 = !_143;
    bool _141 = _144;
    if (0 != _144)
    goto _jump1835;
    i _145 = E();
    bool _146 = _145.a;
    _141 = _146;
    _jump1835:;
    _a1_i _147;
    if (!_141)
    goto _jump1836;
    _a1_i _148;
    // Computing bound for P
    _148.d0 = m;
    if (m > 0) 
    goto _jump1837;
    fail_assertion("non-positive loop bound");
    _jump1837:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= m;
    _149 *= sizeof(i);
    _148.data = jpl_alloc(_149);
    int64_t _150 = 0; // P
    _jump1838:; // Begin body of loop
    i _151 = E();
    int64_t _152 = 0;
    _152 *= _148.d0;
    _152 += _150;
    _148.data[_152] = _151;
    _150++;
    if (_150 < m)
    goto _jump1838;
    // End body of loop
    _147 = _148;
    goto _jump1839;
    _jump1836:;
    _a1_i _153;
    // Computing bound for P
    int64_t _154 = t * A;
    int64_t _155 = _154 % _29;
    _153.d0 = _155;
    if (_155 > 0) 
    goto _jump1840;
    fail_assertion("non-positive loop bound");
    _jump1840:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= _155;
    _156 *= sizeof(i);
    _153.data = jpl_alloc(_156);
    int64_t _157 = 0; // P
    _jump1841:; // Begin body of loop
    i _158 = E();
    int64_t _159 = 0;
    _159 *= _153.d0;
    _159 += _157;
    _153.data[_159] = _158;
    _157++;
    if (_157 < _155)
    goto _jump1841;
    // End body of loop
    _147 = _153;
    _jump1839:;
    bool _160 = true;
    double _161 = 88.0;
    h _162 = { _161 };
    i _163 = { _160, _162, A };
    i _164 = E();
    _a1_i _165;
    _165.d0 = 2;
    _165.data = jpl_alloc(sizeof(i) * 2);
    _165.data[0] = _163;
    _165.data[1] = _164;
    _a3__a1_i _166;
    // Computing bound for P
    _166.d0 = _140.d1;
    if (_140.d1 > 0) 
    goto _jump1842;
    fail_assertion("non-positive loop bound");
    _jump1842:;
    // Computing bound for Q
    _166.d1 = y;
    if (y > 0) 
    goto _jump1843;
    fail_assertion("non-positive loop bound");
    _jump1843:;
    // Computing bound for R
    _166.d2 = c;
    if (c > 0) 
    goto _jump1844;
    fail_assertion("non-positive loop bound");
    _jump1844:;
    // Computing total size of heap memory to allocate
    int64_t _167 = 1;
    _167 *= _140.d1;
    _167 *= y;
    _167 *= c;
    _167 *= sizeof(_a1_i);
    _166.data = jpl_alloc(_167);
    int64_t _168 = 0; // R
    int64_t _169 = 0; // Q
    int64_t _170 = 0; // P
    _jump1845:; // Begin body of loop
    i _171 = E();
    i _172 = E();
    _a1_i _173;
    _173.d0 = 2;
    _173.data = jpl_alloc(sizeof(i) * 2);
    _173.data[0] = _171;
    _173.data[1] = _172;
    int64_t _174 = 0;
    _174 *= _166.d0;
    _174 += _170;
    _174 *= _166.d1;
    _174 += _169;
    _174 *= _166.d2;
    _174 += _168;
    _166.data[_174] = _173;
    _168++;
    if (_168 < c)
    goto _jump1845;
    _168 = 0;
    _169++;
    if (_169 < y)
    goto _jump1845;
    _169 = 0;
    _170++;
    if (_170 < _140.d1)
    goto _jump1845;
    // End body of loop
    int64_t _175 = 860;
    if (b >= 0)
    goto _jump1846;
    fail_assertion("negative array index");
    _jump1846:;
    if (b < _166.d0)
    goto _jump1847;
    fail_assertion("index too large");
    _jump1847:;
    if (g >= 0)
    goto _jump1848;
    fail_assertion("negative array index");
    _jump1848:;
    if (g < _166.d1)
    goto _jump1849;
    fail_assertion("index too large");
    _jump1849:;
    if (_175 >= 0)
    goto _jump1850;
    fail_assertion("negative array index");
    _jump1850:;
    if (_175 < _166.d2)
    goto _jump1851;
    fail_assertion("index too large");
    _jump1851:;
    int64_t _176 = 0;
    _176 *= _166.d0;
    _176 += b;
    _176 *= _166.d1;
    _176 += g;
    _176 *= _166.d2;
    _176 += _175;
    _a1_i _177 = _166.data[_176];
    _a1__a1_i _178;
    _178.d0 = 3;
    _178.data = jpl_alloc(sizeof(_a1_i) * 3);
    _178.data[0] = _147;
    _178.data[1] = _165;
    _178.data[2] = _177;
    int64_t _179 = -d;
    int64_t _180 = t + _29;
    _a1_int64_t _181;
    _181.d0 = 2;
    _181.data = jpl_alloc(sizeof(int64_t) * 2);
    _181.data[0] = _179;
    _181.data[1] = _180;
    if (D >= 0)
    goto _jump1852;
    fail_assertion("negative array index");
    _jump1852:;
    if (D < _181.d0)
    goto _jump1853;
    fail_assertion("index too large");
    _jump1853:;
    int64_t _182 = 0;
    _182 *= _181.d0;
    _182 += D;
    int64_t _183 = _181.data[_182];
    if (_183 >= 0)
    goto _jump1854;
    fail_assertion("negative array index");
    _jump1854:;
    if (_183 < _178.d0)
    goto _jump1855;
    fail_assertion("index too large");
    _jump1855:;
    int64_t _184 = 0;
    _184 *= _178.d0;
    _184 += _183;
    _a1_i _185 = _178.data[_184];
    int64_t _186;
    // Computing bound for P
    if (D > 0) 
    goto _jump1856;
    fail_assertion("non-positive loop bound");
    _jump1856:;
    _186 = 0;
    int64_t _187 = 0; // P
    _jump1857:; // Begin body of loop
    _186 += m;
    _187++;
    if (_187 < D)
    goto _jump1857;
    // End body of loop
    if (_186 >= 0)
    goto _jump1858;
    fail_assertion("negative array index");
    _jump1858:;
    if (_186 < _185.d0)
    goto _jump1859;
    fail_assertion("index too large");
    _jump1859:;
    int64_t _188 = 0;
    _188 *= _185.d0;
    _188 += _186;
    i _189 = _185.data[_188];
    return _189;
}

void jpl_main(struct args args) {
    _a1__a1__a3__a3_int64_t _0;
    // Computing bound for a
    int64_t _1 = 499;
    int64_t _2 = 970;
    bool _3 = _1 >= _2;
    int64_t _4;
    if (!_3)
    goto _jump1;
    int64_t _5 = 593;
    int64_t _6 = -_5;
    int64_t _7 = -_6;
    _4 = _7;
    goto _jump2;
    _jump1:;
    bool _9 = false;
    bool _8 = _9;
    if (0 == _9)
    goto _jump3;
    bool _10 = false;
    _8 = _10;
    _jump3:;
    int64_t _11;
    if (!_8)
    goto _jump4;
    int64_t _12 = 780;
    int64_t _13 = 431;
    int64_t _14 = _12 - _13;
    _11 = _14;
    goto _jump5;
    _jump4:;
    int64_t _15 = 550;
    int64_t _16 = -_15;
    _11 = _16;
    _jump5:;
    _4 = _11;
    _jump2:;
    _0.d0 = _4;
    if (_4 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    // Computing total size of heap memory to allocate
    int64_t _17 = 1;
    _17 *= _4;
    _17 *= sizeof(_a1__a3__a3_int64_t);
    _0.data = jpl_alloc(_17);
    int64_t _18 = 0; // a
    _jump7:; // Begin body of loop
    _a3__a3_int64_t _19;
    // Computing bound for b
    int64_t _20 = 299;
    _19.d0 = _20;
    if (_20 > 0) 
    goto _jump8;
    fail_assertion("non-positive loop bound");
    _jump8:;
    // Computing bound for c
    int64_t _21;
    // Computing bound for b
    if (_18 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    _21 = 0;
    int64_t _22 = 0; // b
    _jump10:; // Begin body of loop
    int64_t _23 = 631;
    _21 += _23;
    _22++;
    if (_22 < _18)
    goto _jump10;
    // End body of loop
    _19.d1 = _21;
    if (_21 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for d
    _19.d2 = _18;
    if (_18 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= _20;
    _24 *= _21;
    _24 *= _18;
    _24 *= sizeof(_a3_int64_t);
    _19.data = jpl_alloc(_24);
    int64_t _25 = 0; // d
    int64_t _26 = 0; // c
    int64_t _27 = 0; // b
    _jump13:; // Begin body of loop
    _a3_int64_t _28;
    // Computing bound for e
    int64_t _29 = 506;
    _28.d0 = _29;
    if (_29 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing bound for f
    int64_t _30 = 64;
    _28.d1 = _30;
    if (_30 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    // Computing bound for g
    int64_t _31 = 445;
    _28.d2 = _31;
    if (_31 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _29;
    _32 *= _30;
    _32 *= _31;
    _32 *= sizeof(int64_t);
    _28.data = jpl_alloc(_32);
    int64_t _33 = 0; // g
    int64_t _34 = 0; // f
    int64_t _35 = 0; // e
    _jump17:; // Begin body of loop
    int64_t _36 = 0;
    _36 *= _28.d0;
    _36 += _35;
    _36 *= _28.d1;
    _36 += _34;
    _36 *= _28.d2;
    _36 += _33;
    _28.data[_36] = _34;
    _33++;
    if (_33 < _31)
    goto _jump17;
    _33 = 0;
    _34++;
    if (_34 < _30)
    goto _jump17;
    _34 = 0;
    _35++;
    if (_35 < _29)
    goto _jump17;
    // End body of loop
    int64_t _37 = 0;
    _37 *= _19.d0;
    _37 += _27;
    _37 *= _19.d1;
    _37 += _26;
    _37 *= _19.d2;
    _37 += _25;
    _19.data[_37] = _28;
    _25++;
    if (_25 < _18)
    goto _jump13;
    _25 = 0;
    _26++;
    if (_26 < _21)
    goto _jump13;
    _26 = 0;
    _27++;
    if (_27 < _20)
    goto _jump13;
    // End body of loop
    _a1__a3__a3_int64_t _38;
    _38.d0 = 1;
    _38.data = jpl_alloc(sizeof(_a3__a3_int64_t) * 1);
    _38.data[0] = _19;
    int64_t _39 = 0;
    _39 *= _0.d0;
    _39 += _18;
    _0.data[_39] = _38;
    _18++;
    if (_18 < _4)
    goto _jump7;
    // End body of loop
    _a2_int64_t _40;
    // Computing bound for a
    int64_t _41 = 170;
    _40.d0 = _41;
    if (_41 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    // Computing bound for b
    int64_t _42;
    // Computing bound for a
    int64_t _43 = 33;
    if (_43 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    // Computing bound for b
    int64_t _44 = 43;
    int64_t _45 = -_44;
    if (_45 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _42 = 0;
    int64_t _46 = 0; // b
    int64_t _47 = 0; // a
    _jump21:; // Begin body of loop
    int64_t _48 = -_47;
    _42 += _48;
    _46++;
    if (_46 < _45)
    goto _jump21;
    _46 = 0;
    _47++;
    if (_47 < _43)
    goto _jump21;
    // End body of loop
    _40.d1 = _42;
    if (_42 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= _41;
    _49 *= _42;
    _49 *= sizeof(int64_t);
    _40.data = jpl_alloc(_49);
    int64_t _50 = 0; // b
    int64_t _51 = 0; // a
    _jump23:; // Begin body of loop
    int64_t _52 = 106;
    bool _53 = _52 <= _50;
    int64_t _54;
    if (!_53)
    goto _jump24;
    _54 = _50;
    goto _jump25;
    _jump24:;
    int64_t _55;
    // Computing bound for c
    if (_51 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for d
    if (_51 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    _55 = 0;
    int64_t _56 = 0; // d
    int64_t _57 = 0; // c
    _jump28:; // Begin body of loop
    _55 += _57;
    _56++;
    if (_56 < _51)
    goto _jump28;
    _56 = 0;
    _57++;
    if (_57 < _51)
    goto _jump28;
    // End body of loop
    _54 = _55;
    _jump25:;
    int64_t _58 = 0;
    _58 *= _40.d0;
    _58 += _51;
    _58 *= _40.d1;
    _58 += _50;
    _40.data[_58] = _54;
    _50++;
    if (_50 < _42)
    goto _jump23;
    _50 = 0;
    _51++;
    if (_51 < _41)
    goto _jump23;
    // End body of loop
    bool _59 = false;
    bool _60 = true;
    bool _61 = _59 != _60;
    int64_t _62;
    if (!_61)
    goto _jump29;
    int64_t _63 = 587;
    _62 = _63;
    goto _jump30;
    _jump29:;
    _a1_int64_t _64;
    // Computing bound for a
    int64_t _65 = 875;
    _64.d0 = _65;
    if (_65 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= _65;
    _66 *= sizeof(int64_t);
    _64.data = jpl_alloc(_66);
    int64_t _67 = 0; // a
    _jump32:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _64.d0;
    _68 += _67;
    _64.data[_68] = _67;
    _67++;
    if (_67 < _65)
    goto _jump32;
    // End body of loop
    int64_t _69 = 603;
    int64_t _70 = -_69;
    if (_70 >= 0)
    goto _jump33;
    fail_assertion("negative array index");
    _jump33:;
    if (_70 < _64.d0)
    goto _jump34;
    fail_assertion("index too large");
    _jump34:;
    int64_t _71 = 0;
    _71 *= _64.d0;
    _71 += _70;
    int64_t _72 = _64.data[_71];
    _62 = _72;
    _jump30:;
    _a2_int64_t _73;
    // Computing bound for a
    int64_t _74 = 552;
    int64_t _75 = -_74;
    _73.d0 = _75;
    if (_75 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for b
    int64_t _76 = 509;
    _73.d1 = _76;
    if (_76 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= _75;
    _77 *= _76;
    _77 *= sizeof(int64_t);
    _73.data = jpl_alloc(_77);
    int64_t _78 = 0; // b
    int64_t _79 = 0; // a
    _jump37:; // Begin body of loop
    int64_t _80 = 0;
    _80 *= _73.d0;
    _80 += _79;
    _80 *= _73.d1;
    _80 += _78;
    _73.data[_80] = _79;
    _78++;
    if (_78 < _76)
    goto _jump37;
    _78 = 0;
    _79++;
    if (_79 < _75)
    goto _jump37;
    // End body of loop
    int64_t _81;
    // Computing bound for a
    int64_t _82 = 746;
    int64_t _83 = 152;
    int64_t _84 = _82 + _83;
    if (_84 > 0) 
    goto _jump38;
    fail_assertion("non-positive loop bound");
    _jump38:;
    // Computing bound for b
    int64_t _85 = 612;
    int64_t _86 = -_85;
    if (_86 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    _81 = 0;
    int64_t _87 = 0; // b
    int64_t _88 = 0; // a
    _jump40:; // Begin body of loop
    int64_t _89 = 298;
    _81 += _89;
    _87++;
    if (_87 < _86)
    goto _jump40;
    _87 = 0;
    _88++;
    if (_88 < _84)
    goto _jump40;
    // End body of loop
    int64_t _90;
    // Computing bound for a
    int64_t _91 = 239;
    if (_91 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    // Computing bound for b
    int64_t _92 = 20;
    if (_92 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    _90 = 0;
    int64_t _93 = 0; // b
    int64_t _94 = 0; // a
    _jump43:; // Begin body of loop
    int64_t _95 = 610;
    _90 += _95;
    _93++;
    if (_93 < _92)
    goto _jump43;
    _93 = 0;
    _94++;
    if (_94 < _91)
    goto _jump43;
    // End body of loop
    int64_t _96 = 314;
    int64_t _97 = _90 + _96;
    if (_81 >= 0)
    goto _jump44;
    fail_assertion("negative array index");
    _jump44:;
    if (_81 < _73.d0)
    goto _jump45;
    fail_assertion("index too large");
    _jump45:;
    if (_97 >= 0)
    goto _jump46;
    fail_assertion("negative array index");
    _jump46:;
    if (_97 < _73.d1)
    goto _jump47;
    fail_assertion("index too large");
    _jump47:;
    int64_t _98 = 0;
    _98 *= _73.d0;
    _98 += _81;
    _98 *= _73.d1;
    _98 += _97;
    int64_t _99 = _73.data[_98];
    if (_62 >= 0)
    goto _jump48;
    fail_assertion("negative array index");
    _jump48:;
    if (_62 < _40.d0)
    goto _jump49;
    fail_assertion("index too large");
    _jump49:;
    if (_99 >= 0)
    goto _jump50;
    fail_assertion("negative array index");
    _jump50:;
    if (_99 < _40.d1)
    goto _jump51;
    fail_assertion("index too large");
    _jump51:;
    int64_t _100 = 0;
    _100 *= _40.d0;
    _100 += _62;
    _100 *= _40.d1;
    _100 += _99;
    int64_t _101 = _40.data[_100];
    if (_101 >= 0)
    goto _jump52;
    fail_assertion("negative array index");
    _jump52:;
    if (_101 < _0.d0)
    goto _jump53;
    fail_assertion("index too large");
    _jump53:;
    int64_t _102 = 0;
    _102 *= _0.d0;
    _102 += _101;
    _a1__a3__a3_int64_t _103 = _0.data[_102];
    double _104 = 35.0;
    double _105 = 24.0;
    bool _106 = _104 >= _105;
    int64_t _107;
    if (!_106)
    goto _jump54;
    bool _108 = true;
    int64_t _109;
    if (!_108)
    goto _jump55;
    int64_t _110 = 814;
    _109 = _110;
    goto _jump56;
    _jump55:;
    int64_t _111 = 811;
    _109 = _111;
    _jump56:;
    int64_t _112 = -_109;
    int64_t _113 = 286;
    int64_t _114 = _112 / _113;
    int64_t _115 = -_114;
    _107 = _115;
    goto _jump57;
    _jump54:;
    int64_t _116;
    // Computing bound for a
    _a2_int64_t _117;
    // Computing bound for a
    int64_t _118 = 375;
    int64_t _119 = 632;
    int64_t _120 = _118 - _119;
    _117.d0 = _120;
    if (_120 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    // Computing bound for b
    int64_t _121 = 267;
    _117.d1 = _121;
    if (_121 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _120;
    _122 *= _121;
    _122 *= sizeof(int64_t);
    _117.data = jpl_alloc(_122);
    int64_t _123 = 0; // b
    int64_t _124 = 0; // a
    _jump60:; // Begin body of loop
    int64_t _125 = 791;
    int64_t _126 = 0;
    _126 *= _117.d0;
    _126 += _124;
    _126 *= _117.d1;
    _126 += _123;
    _117.data[_126] = _125;
    _123++;
    if (_123 < _121)
    goto _jump60;
    _123 = 0;
    _124++;
    if (_124 < _120)
    goto _jump60;
    // End body of loop
    bool _127 = false;
    int64_t _128;
    if (!_127)
    goto _jump61;
    int64_t _129 = 812;
    _128 = _129;
    goto _jump62;
    _jump61:;
    int64_t _130 = 300;
    _128 = _130;
    _jump62:;
    int64_t _131;
    // Computing bound for a
    int64_t _132;
    // Computing bound for a
    int64_t _133 = 588;
    if (_133 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing bound for b
    int64_t _134 = 136;
    if (_134 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing bound for c
    int64_t _135 = 664;
    if (_135 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    _132 = 0;
    int64_t _136 = 0; // c
    int64_t _137 = 0; // b
    int64_t _138 = 0; // a
    _jump66:; // Begin body of loop
    _132 += _136;
    _136++;
    if (_136 < _135)
    goto _jump66;
    _136 = 0;
    _137++;
    if (_137 < _134)
    goto _jump66;
    _137 = 0;
    _138++;
    if (_138 < _133)
    goto _jump66;
    // End body of loop
    if (_132 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    // Computing bound for b
    int64_t _139 = 300;
    if (_139 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    // Computing bound for c
    int64_t _140 = 595;
    if (_140 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    _131 = 0;
    int64_t _141 = 0; // c
    int64_t _142 = 0; // b
    int64_t _143 = 0; // a
    _jump70:; // Begin body of loop
    _131 += _142;
    _141++;
    if (_141 < _140)
    goto _jump70;
    _141 = 0;
    _142++;
    if (_142 < _139)
    goto _jump70;
    _142 = 0;
    _143++;
    if (_143 < _132)
    goto _jump70;
    // End body of loop
    if (_128 >= 0)
    goto _jump71;
    fail_assertion("negative array index");
    _jump71:;
    if (_128 < _117.d0)
    goto _jump72;
    fail_assertion("index too large");
    _jump72:;
    if (_131 >= 0)
    goto _jump73;
    fail_assertion("negative array index");
    _jump73:;
    if (_131 < _117.d1)
    goto _jump74;
    fail_assertion("index too large");
    _jump74:;
    int64_t _144 = 0;
    _144 *= _117.d0;
    _144 += _128;
    _144 *= _117.d1;
    _144 += _131;
    int64_t _145 = _117.data[_144];
    if (_145 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for b
    int64_t _146 = 638;
    int64_t _147 = 482;
    int64_t _148 = -_147;
    bool _149 = _146 <= _148;
    int64_t _150;
    if (!_149)
    goto _jump76;
    int64_t _151 = 260;
    _150 = _151;
    goto _jump77;
    _jump76:;
    int64_t _152;
    // Computing bound for a
    int64_t _153 = 22;
    if (_153 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing bound for b
    int64_t _154 = 74;
    if (_154 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing bound for c
    int64_t _155 = 650;
    if (_155 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    _152 = 0;
    int64_t _156 = 0; // c
    int64_t _157 = 0; // b
    int64_t _158 = 0; // a
    _jump81:; // Begin body of loop
    int64_t _159 = 832;
    _152 += _159;
    _156++;
    if (_156 < _155)
    goto _jump81;
    _156 = 0;
    _157++;
    if (_157 < _154)
    goto _jump81;
    _157 = 0;
    _158++;
    if (_158 < _153)
    goto _jump81;
    // End body of loop
    _150 = _152;
    _jump77:;
    if (_150 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    _116 = 0;
    int64_t _160 = 0; // b
    int64_t _161 = 0; // a
    _jump83:; // Begin body of loop
    _116 += _160;
    _160++;
    if (_160 < _150)
    goto _jump83;
    _160 = 0;
    _161++;
    if (_161 < _145)
    goto _jump83;
    // End body of loop
    _107 = _116;
    _jump57:;
    if (_107 >= 0)
    goto _jump84;
    fail_assertion("negative array index");
    _jump84:;
    if (_107 < _103.d0)
    goto _jump85;
    fail_assertion("index too large");
    _jump85:;
    int64_t _162 = 0;
    _162 *= _103.d0;
    _162 += _107;
    _a3__a3_int64_t _163 = _103.data[_162];
    int64_t _164;
    // Computing bound for a
    int64_t _165;
    // Computing bound for a
    int64_t _166;
    // Computing bound for a
    int64_t _167 = 160;
    if (_167 > 0) 
    goto _jump86;
    fail_assertion("non-positive loop bound");
    _jump86:;
    _166 = 0;
    int64_t _168 = 0; // a
    _jump87:; // Begin body of loop
    int64_t _169 = 326;
    _166 += _169;
    _168++;
    if (_168 < _167)
    goto _jump87;
    // End body of loop
    if (_166 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    _165 = 0;
    int64_t _170 = 0; // a
    _jump89:; // Begin body of loop
    _165 += _170;
    _170++;
    if (_170 < _166)
    goto _jump89;
    // End body of loop
    if (_165 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing bound for b
    int64_t _171 = 428;
    if (_171 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for c
    int64_t _172 = 349;
    int64_t _173 = -_172;
    int64_t _174 = -_173;
    int64_t _175 = 622;
    int64_t _176 = 689;
    int64_t _177 = _175 + _176;
    int64_t _178 = -_177;
    int64_t _179 = _174 - _178;
    if (_179 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    _164 = 0;
    int64_t _180 = 0; // c
    int64_t _181 = 0; // b
    int64_t _182 = 0; // a
    _jump93:; // Begin body of loop
    int64_t _183 = 869;
    _164 += _183;
    _180++;
    if (_180 < _179)
    goto _jump93;
    _180 = 0;
    _181++;
    if (_181 < _171)
    goto _jump93;
    _181 = 0;
    _182++;
    if (_182 < _165)
    goto _jump93;
    // End body of loop
    int64_t _184 = 480;
    int64_t _185 = _164 / _184;
    int64_t _186 = 937;
    int64_t _187 = 595;
    int64_t _188 = _186 - _187;
    bool _189 = true;
    int64_t _190;
    if (!_189)
    goto _jump94;
    int64_t _191 = 860;
    _190 = _191;
    goto _jump95;
    _jump94:;
    int64_t _192 = 990;
    int64_t _193 = 11;
    int64_t _194 = _192 + _193;
    _190 = _194;
    _jump95:;
    bool _195 = _188 < _190;
    int64_t _196;
    if (!_195)
    goto _jump96;
    int64_t _197 = 471;
    _196 = _197;
    goto _jump97;
    _jump96:;
    int64_t _198 = 987;
    int64_t _199 = 615;
    int64_t _200 = _198 / _199;
    _196 = _200;
    _jump97:;
    int64_t _201 = -_196;
    int64_t _202 = _185 * _201;
    bool _203 = true;
    int64_t _204;
    if (!_203)
    goto _jump98;
    bool _205 = false;
    bool _206;
    if (!_205)
    goto _jump99;
    bool _207 = false;
    _206 = _207;
    goto _jump100;
    _jump99:;
    bool _208 = true;
    _206 = _208;
    _jump100:;
    bool _209 = !_206;
    int64_t _210;
    if (!_209)
    goto _jump101;
    int64_t _211;
    // Computing bound for a
    bool _212 = false;
    int64_t _213;
    if (!_212)
    goto _jump102;
    int64_t _214 = 222;
    _213 = _214;
    goto _jump103;
    _jump102:;
    int64_t _215 = 507;
    _213 = _215;
    _jump103:;
    int64_t _216 = -_213;
    if (_216 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    // Computing bound for b
    int64_t _217 = 875;
    int64_t _218 = 495;
    int64_t _219 = _217 * _218;
    if (_219 > 0) 
    goto _jump105;
    fail_assertion("non-positive loop bound");
    _jump105:;
    // Computing bound for c
    int64_t _220 = 13;
    int64_t _221 = 491;
    int64_t _222 = _220 + _221;
    if (_222 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    _211 = 0;
    int64_t _223 = 0; // c
    int64_t _224 = 0; // b
    int64_t _225 = 0; // a
    _jump107:; // Begin body of loop
    int64_t _226 = -_225;
    int64_t _227 = _224 + _226;
    _211 += _227;
    _223++;
    if (_223 < _222)
    goto _jump107;
    _223 = 0;
    _224++;
    if (_224 < _219)
    goto _jump107;
    _224 = 0;
    _225++;
    if (_225 < _216)
    goto _jump107;
    // End body of loop
    _210 = _211;
    goto _jump108;
    _jump101:;
    int64_t _228 = 742;
    int64_t _229 = 356;
    int64_t _230 = -_229;
    int64_t _231 = _228 + _230;
    int64_t _232 = -_231;
    _210 = _232;
    _jump108:;
    _204 = _210;
    goto _jump109;
    _jump98:;
    int64_t _233;
    // Computing bound for a
    int64_t _234 = 426;
    if (_234 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing bound for b
    int64_t _235 = 811;
    int64_t _236 = 223;
    int64_t _237 = 99;
    int64_t _238 = _236 / _237;
    int64_t _239 = -_238;
    int64_t _240 = _235 + _239;
    if (_240 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing bound for c
    int64_t _241 = 155;
    int64_t _242 = -_241;
    int64_t _243 = 29;
    int64_t _244 = 854;
    int64_t _245 = _243 + _244;
    int64_t _246 = _242 / _245;
    if (_246 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    _233 = 0;
    int64_t _247 = 0; // c
    int64_t _248 = 0; // b
    int64_t _249 = 0; // a
    _jump113:; // Begin body of loop
    _233 += _247;
    _247++;
    if (_247 < _246)
    goto _jump113;
    _247 = 0;
    _248++;
    if (_248 < _240)
    goto _jump113;
    _248 = 0;
    _249++;
    if (_249 < _234)
    goto _jump113;
    // End body of loop
    _204 = _233;
    _jump109:;
    int64_t _250 = 144;
    int64_t _251 = _204 % _250;
    bool _252 = true;
    int64_t _253;
    if (!_252)
    goto _jump114;
    int64_t _254 = 937;
    int64_t _255 = 669;
    int64_t _256 = 748;
    int64_t _257 = 392;
    int64_t _258 = _256 * _257;
    bool _259 = _255 >= _258;
    int64_t _260;
    if (!_259)
    goto _jump115;
    _a2_int64_t _261;
    // Computing bound for a
    int64_t _262 = 460;
    _261.d0 = _262;
    if (_262 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    // Computing bound for b
    int64_t _263 = 39;
    _261.d1 = _263;
    if (_263 > 0) 
    goto _jump117;
    fail_assertion("non-positive loop bound");
    _jump117:;
    // Computing total size of heap memory to allocate
    int64_t _264 = 1;
    _264 *= _262;
    _264 *= _263;
    _264 *= sizeof(int64_t);
    _261.data = jpl_alloc(_264);
    int64_t _265 = 0; // b
    int64_t _266 = 0; // a
    _jump118:; // Begin body of loop
    int64_t _267 = 603;
    int64_t _268 = _266 % _267;
    int64_t _269 = 0;
    _269 *= _261.d0;
    _269 += _266;
    _269 *= _261.d1;
    _269 += _265;
    _261.data[_269] = _268;
    _265++;
    if (_265 < _263)
    goto _jump118;
    _265 = 0;
    _266++;
    if (_266 < _262)
    goto _jump118;
    // End body of loop
    bool _270 = true;
    int64_t _271;
    if (!_270)
    goto _jump119;
    int64_t _272 = 454;
    _271 = _272;
    goto _jump120;
    _jump119:;
    bool _273 = false;
    int64_t _274;
    if (!_273)
    goto _jump121;
    int64_t _275 = 414;
    _274 = _275;
    goto _jump122;
    _jump121:;
    int64_t _276 = 406;
    _274 = _276;
    _jump122:;
    _271 = _274;
    _jump120:;
    int64_t _277 = 505;
    if (_271 >= 0)
    goto _jump123;
    fail_assertion("negative array index");
    _jump123:;
    if (_271 < _261.d0)
    goto _jump124;
    fail_assertion("index too large");
    _jump124:;
    if (_277 >= 0)
    goto _jump125;
    fail_assertion("negative array index");
    _jump125:;
    if (_277 < _261.d1)
    goto _jump126;
    fail_assertion("index too large");
    _jump126:;
    int64_t _278 = 0;
    _278 *= _261.d0;
    _278 += _271;
    _278 *= _261.d1;
    _278 += _277;
    int64_t _279 = _261.data[_278];
    _260 = _279;
    goto _jump127;
    _jump115:;
    int64_t _280 = 382;
    _260 = _280;
    _jump127:;
    int64_t _281 = _254 % _260;
    _253 = _281;
    goto _jump128;
    _jump114:;
    int64_t _282 = 745;
    _253 = _282;
    _jump128:;
    if (_202 >= 0)
    goto _jump129;
    fail_assertion("negative array index");
    _jump129:;
    if (_202 < _163.d0)
    goto _jump130;
    fail_assertion("index too large");
    _jump130:;
    if (_251 >= 0)
    goto _jump131;
    fail_assertion("negative array index");
    _jump131:;
    if (_251 < _163.d1)
    goto _jump132;
    fail_assertion("index too large");
    _jump132:;
    if (_253 >= 0)
    goto _jump133;
    fail_assertion("negative array index");
    _jump133:;
    if (_253 < _163.d2)
    goto _jump134;
    fail_assertion("index too large");
    _jump134:;
    int64_t _283 = 0;
    _283 *= _163.d0;
    _283 += _202;
    _283 *= _163.d1;
    _283 += _251;
    _283 *= _163.d2;
    _283 += _253;
    _a3_int64_t _284 = _163.data[_283];
    show("(ArrayType (IntType) 3)", &_284);
    int64_t _285 = 568;
    int64_t _286 = -_285;
    int64_t _287 = _284.d1 + _284.d0;
    int64_t _288 = -_287;
    _a1_int64_t _289;
    _289.d0 = 3;
    _289.data = jpl_alloc(sizeof(int64_t) * 3);
    _289.data[0] = _284.d2;
    _289.data[1] = _286;
    _289.data[2] = _288;
    double _290 = get_time();
    double _292 = 86.0;
    double _293 = 32.0;
    bool _294 = _292 != _293;
    bool _291 = _294;
    if (0 == _294)
    goto _jump135;
    int64_t _296 = 588;
    bool _297 = _296 <= _284.d2;
    bool _295 = _297;
    if (0 == _297)
    goto _jump136;
    bool _298 = false;
    _295 = _298;
    _jump136:;
    bool _299 = !_295;
    _291 = _299;
    _jump135:;
    bool _300;
    if (!_291)
    goto _jump137;
    bool _301 = false;
    bool _302 = !_301;
    bool _303 = false;
    bool _304 = !_303;
    bool _305 = _302 != _304;
    bool _306 = false;
    bool _307 = true;
    bool _309 = false;
    bool _308 = _309;
    if (0 == _309)
    goto _jump138;
    bool _310 = false;
    _308 = _310;
    _jump138:;
    bool _311 = _307 != _308;
    bool _312 = _306 == _311;
    bool _313 = _305 == _312;
    _300 = _313;
    goto _jump139;
    _jump137:;
    double _314;
    // Computing bound for f
    if (_284.d0 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing bound for g
    int64_t _315 = 65;
    if (_315 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    _314 = 0;
    int64_t _316 = 0; // g
    int64_t _317 = 0; // f
    _jump142:; // Begin body of loop
    _a3_double _318;
    // Computing bound for h
    _318.d0 = _284.d0;
    if (_284.d0 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing bound for i
    _318.d1 = _316;
    if (_316 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    // Computing bound for j
    _318.d2 = _284.d0;
    if (_284.d0 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing total size of heap memory to allocate
    int64_t _319 = 1;
    _319 *= _284.d0;
    _319 *= _316;
    _319 *= _284.d0;
    _319 *= sizeof(double);
    _318.data = jpl_alloc(_319);
    int64_t _320 = 0; // j
    int64_t _321 = 0; // i
    int64_t _322 = 0; // h
    _jump146:; // Begin body of loop
    double _323 = 98.0;
    int64_t _324 = 0;
    _324 *= _318.d0;
    _324 += _322;
    _324 *= _318.d1;
    _324 += _321;
    _324 *= _318.d2;
    _324 += _320;
    _318.data[_324] = _323;
    _320++;
    if (_320 < _284.d0)
    goto _jump146;
    _320 = 0;
    _321++;
    if (_321 < _316)
    goto _jump146;
    _321 = 0;
    _322++;
    if (_322 < _284.d0)
    goto _jump146;
    // End body of loop
    int64_t _325 = _284.d0 % _316;
    if (_316 >= 0)
    goto _jump147;
    fail_assertion("negative array index");
    _jump147:;
    if (_316 < _318.d0)
    goto _jump148;
    fail_assertion("index too large");
    _jump148:;
    if (_284.d2 >= 0)
    goto _jump149;
    fail_assertion("negative array index");
    _jump149:;
    if (_284.d2 < _318.d1)
    goto _jump150;
    fail_assertion("index too large");
    _jump150:;
    if (_325 >= 0)
    goto _jump151;
    fail_assertion("negative array index");
    _jump151:;
    if (_325 < _318.d2)
    goto _jump152;
    fail_assertion("index too large");
    _jump152:;
    int64_t _326 = 0;
    _326 *= _318.d0;
    _326 += _316;
    _326 *= _318.d1;
    _326 += _284.d2;
    _326 *= _318.d2;
    _326 += _325;
    double _327 = _318.data[_326];
    _314 += _327;
    _316++;
    if (_316 < _315)
    goto _jump142;
    _316 = 0;
    _317++;
    if (_317 < _284.d0)
    goto _jump142;
    // End body of loop
    _a3_double _328;
    // Computing bound for f
    _328.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing bound for g
    _328.d1 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for h
    int64_t _329 = 402;
    _328.d2 = _329;
    if (_329 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= _284.d2;
    _330 *= _284.d1;
    _330 *= _329;
    _330 *= sizeof(double);
    _328.data = jpl_alloc(_330);
    int64_t _331 = 0; // h
    int64_t _332 = 0; // g
    int64_t _333 = 0; // f
    _jump156:; // Begin body of loop
    double _334 = 32.0;
    int64_t _335 = 0;
    _335 *= _328.d0;
    _335 += _333;
    _335 *= _328.d1;
    _335 += _332;
    _335 *= _328.d2;
    _335 += _331;
    _328.data[_335] = _334;
    _331++;
    if (_331 < _329)
    goto _jump156;
    _331 = 0;
    _332++;
    if (_332 < _284.d1)
    goto _jump156;
    _332 = 0;
    _333++;
    if (_333 < _284.d2)
    goto _jump156;
    // End body of loop
    int64_t _336 = 830;
    if (_336 >= 0)
    goto _jump157;
    fail_assertion("negative array index");
    _jump157:;
    if (_336 < _328.d0)
    goto _jump158;
    fail_assertion("index too large");
    _jump158:;
    if (_284.d0 >= 0)
    goto _jump159;
    fail_assertion("negative array index");
    _jump159:;
    if (_284.d0 < _328.d1)
    goto _jump160;
    fail_assertion("index too large");
    _jump160:;
    if (_284.d1 >= 0)
    goto _jump161;
    fail_assertion("negative array index");
    _jump161:;
    if (_284.d1 < _328.d2)
    goto _jump162;
    fail_assertion("index too large");
    _jump162:;
    int64_t _337 = 0;
    _337 *= _328.d0;
    _337 += _336;
    _337 *= _328.d1;
    _337 += _284.d0;
    _337 *= _328.d2;
    _337 += _284.d1;
    double _338 = _328.data[_337];
    double _339 = -_338;
    bool _340 = _314 >= _339;
    _300 = _340;
    _jump139:;
    _a1_int64_t _341;
    if (!_300)
    goto _jump163;
    _341 = _289;
    goto _jump164;
    _jump163:;
    _a1_int64_t _342;
    // Computing bound for f
    _342.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    // Computing total size of heap memory to allocate
    int64_t _343 = 1;
    _343 *= _284.d2;
    _343 *= sizeof(int64_t);
    _342.data = jpl_alloc(_343);
    int64_t _344 = 0; // f
    _jump166:; // Begin body of loop
    _a1_int64_t _345;
    // Computing bound for g
    bool _346 = _284.d0 == _284.d2;
    int64_t _347;
    if (!_346)
    goto _jump167;
    _347 = _344;
    goto _jump168;
    _jump167:;
    bool _348 = false;
    int64_t _349;
    if (!_348)
    goto _jump169;
    _349 = _344;
    goto _jump170;
    _jump169:;
    _349 = _284.d0;
    _jump170:;
    _347 = _349;
    _jump168:;
    _345.d0 = _347;
    if (_347 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing total size of heap memory to allocate
    int64_t _350 = 1;
    _350 *= _347;
    _350 *= sizeof(int64_t);
    _345.data = jpl_alloc(_350);
    int64_t _351 = 0; // g
    _jump172:; // Begin body of loop
    int64_t _352 = 70;
    int64_t _353 = 0;
    _353 *= _345.d0;
    _353 += _351;
    _345.data[_353] = _352;
    _351++;
    if (_351 < _347)
    goto _jump172;
    // End body of loop
    _a1_int64_t _354;
    // Computing bound for g
    _354.d0 = _284.d0;
    if (_284.d0 > 0) 
    goto _jump173;
    fail_assertion("non-positive loop bound");
    _jump173:;
    // Computing total size of heap memory to allocate
    int64_t _355 = 1;
    _355 *= _284.d0;
    _355 *= sizeof(int64_t);
    _354.data = jpl_alloc(_355);
    int64_t _356 = 0; // g
    _jump174:; // Begin body of loop
    int64_t _357 = 0;
    _357 *= _354.d0;
    _357 += _356;
    _354.data[_357] = _284.d2;
    _356++;
    if (_356 < _284.d0)
    goto _jump174;
    // End body of loop
    if (_284.d1 >= 0)
    goto _jump175;
    fail_assertion("negative array index");
    _jump175:;
    if (_284.d1 < _354.d0)
    goto _jump176;
    fail_assertion("index too large");
    _jump176:;
    int64_t _358 = 0;
    _358 *= _354.d0;
    _358 += _284.d1;
    int64_t _359 = _354.data[_358];
    if (_359 >= 0)
    goto _jump177;
    fail_assertion("negative array index");
    _jump177:;
    if (_359 < _289.d0)
    goto _jump178;
    fail_assertion("index too large");
    _jump178:;
    int64_t _360 = 0;
    _360 *= _289.d0;
    _360 += _359;
    int64_t _361 = _289.data[_360];
    if (_361 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_361 < _345.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    int64_t _362 = 0;
    _362 *= _345.d0;
    _362 += _361;
    int64_t _363 = _345.data[_362];
    int64_t _364 = 0;
    _364 *= _342.d0;
    _364 += _344;
    _342.data[_364] = _363;
    _344++;
    if (_344 < _284.d2)
    goto _jump166;
    // End body of loop
    _341 = _342;
    _jump164:;
    double _365 = get_time();
    print_time(_365 - _290);
    _a2_int64_t _366;
    // Computing bound for k
    _366.d0 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for l
    _366.d1 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing total size of heap memory to allocate
    int64_t _367 = 1;
    _367 *= _284.d1;
    _367 *= _284.d1;
    _367 *= sizeof(int64_t);
    _366.data = jpl_alloc(_367);
    int64_t _368 = 0; // l
    int64_t _369 = 0; // k
    _jump508:; // Begin body of loop
    int64_t _370 = _368 - _284.d1;
    int64_t _371 = 0;
    _371 *= _366.d0;
    _371 += _369;
    _371 *= _366.d1;
    _371 += _368;
    _366.data[_371] = _370;
    _368++;
    if (_368 < _284.d1)
    goto _jump508;
    _368 = 0;
    _369++;
    if (_369 < _284.d1)
    goto _jump508;
    // End body of loop
    show("(IntType)", &_366.d1);
    int64_t _372 = -_341.d0;
    int64_t _373 = -_372;
    int64_t _374 = _284.d0 * _373;
    show("(IntType)", &_374);
    bool _375 = false;
    _a3_bool _376;
    if (!_375)
    goto _jump1174;
    _a3_bool _377;
    // Computing bound for r
    bool _378 = true;
    _a2_int64_t _379;
    if (!_378)
    goto _jump1175;
    _379 = _366;
    goto _jump1176;
    _jump1175:;
    _379 = _366;
    _jump1176:;
    int64_t _380 = 191;
    if (_284.d0 >= 0)
    goto _jump1177;
    fail_assertion("negative array index");
    _jump1177:;
    if (_284.d0 < _379.d0)
    goto _jump1178;
    fail_assertion("index too large");
    _jump1178:;
    if (_380 >= 0)
    goto _jump1179;
    fail_assertion("negative array index");
    _jump1179:;
    if (_380 < _379.d1)
    goto _jump1180;
    fail_assertion("index too large");
    _jump1180:;
    int64_t _381 = 0;
    _381 *= _379.d0;
    _381 += _284.d0;
    _381 *= _379.d1;
    _381 += _380;
    int64_t _382 = _379.data[_381];
    _377.d0 = _382;
    if (_382 > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    // Computing bound for s
    int64_t _383 = 415;
    _377.d1 = _383;
    if (_383 > 0) 
    goto _jump1182;
    fail_assertion("non-positive loop bound");
    _jump1182:;
    // Computing bound for t
    _377.d2 = _366.d1;
    if (_366.d1 > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    // Computing total size of heap memory to allocate
    int64_t _384 = 1;
    _384 *= _382;
    _384 *= _383;
    _384 *= _366.d1;
    _384 *= sizeof(bool);
    _377.data = jpl_alloc(_384);
    int64_t _385 = 0; // t
    int64_t _386 = 0; // s
    int64_t _387 = 0; // r
    _jump1184:; // Begin body of loop
    bool _388 = true;
    bool _389;
    if (!_388)
    goto _jump1185;
    bool _390 = false;
    bool _391 = !_390;
    _389 = _391;
    goto _jump1186;
    _jump1185:;
    bool _392 = false;
    _389 = _392;
    _jump1186:;
    bool _393 = false;
    bool _394 = _389 == _393;
    int64_t _395 = 0;
    _395 *= _377.d0;
    _395 += _387;
    _395 *= _377.d1;
    _395 += _386;
    _395 *= _377.d2;
    _395 += _385;
    _377.data[_395] = _394;
    _385++;
    if (_385 < _366.d1)
    goto _jump1184;
    _385 = 0;
    _386++;
    if (_386 < _383)
    goto _jump1184;
    _386 = 0;
    _387++;
    if (_387 < _382)
    goto _jump1184;
    // End body of loop
    _376 = _377;
    goto _jump1187;
    _jump1174:;
    int64_t _396 = _284.d0 / _366.d0;
    int64_t _397 = -_396;
    int64_t _398 = -_284.d2;
    bool _399 = _397 == _398;
    _a3_bool _400;
    if (!_399)
    goto _jump1188;
    bool _401 = false;
    _a3_bool _402;
    if (!_401)
    goto _jump1189;
    _a3_bool _403;
    // Computing bound for r
    int64_t _404 = 533;
    _403.d0 = _404;
    if (_404 > 0) 
    goto _jump1190;
    fail_assertion("non-positive loop bound");
    _jump1190:;
    // Computing bound for s
    _403.d1 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing bound for t
    _403.d2 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    // Computing total size of heap memory to allocate
    int64_t _405 = 1;
    _405 *= _404;
    _405 *= _341.d0;
    _405 *= _284.d2;
    _405 *= sizeof(bool);
    _403.data = jpl_alloc(_405);
    int64_t _406 = 0; // t
    int64_t _407 = 0; // s
    int64_t _408 = 0; // r
    _jump1193:; // Begin body of loop
    bool _409 = true;
    int64_t _410 = 0;
    _410 *= _403.d0;
    _410 += _408;
    _410 *= _403.d1;
    _410 += _407;
    _410 *= _403.d2;
    _410 += _406;
    _403.data[_410] = _409;
    _406++;
    if (_406 < _284.d2)
    goto _jump1193;
    _406 = 0;
    _407++;
    if (_407 < _341.d0)
    goto _jump1193;
    _407 = 0;
    _408++;
    if (_408 < _404)
    goto _jump1193;
    // End body of loop
    _402 = _403;
    goto _jump1194;
    _jump1189:;
    double _411 = 50.0;
    double _412 = 28.0;
    bool _413 = _411 <= _412;
    _a3_bool _414;
    if (!_413)
    goto _jump1195;
    _a3_bool _415;
    // Computing bound for r
    int64_t _416 = 708;
    _415.d0 = _416;
    if (_416 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for s
    _415.d1 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing bound for t
    _415.d2 = _366.d1;
    if (_366.d1 > 0) 
    goto _jump1198;
    fail_assertion("non-positive loop bound");
    _jump1198:;
    // Computing total size of heap memory to allocate
    int64_t _417 = 1;
    _417 *= _416;
    _417 *= _284.d2;
    _417 *= _366.d1;
    _417 *= sizeof(bool);
    _415.data = jpl_alloc(_417);
    int64_t _418 = 0; // t
    int64_t _419 = 0; // s
    int64_t _420 = 0; // r
    _jump1199:; // Begin body of loop
    bool _421 = true;
    int64_t _422 = 0;
    _422 *= _415.d0;
    _422 += _420;
    _422 *= _415.d1;
    _422 += _419;
    _422 *= _415.d2;
    _422 += _418;
    _415.data[_422] = _421;
    _418++;
    if (_418 < _366.d1)
    goto _jump1199;
    _418 = 0;
    _419++;
    if (_419 < _284.d2)
    goto _jump1199;
    _419 = 0;
    _420++;
    if (_420 < _416)
    goto _jump1199;
    // End body of loop
    _414 = _415;
    goto _jump1200;
    _jump1195:;
    _a3_bool _423;
    // Computing bound for r
    _423.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1201;
    fail_assertion("non-positive loop bound");
    _jump1201:;
    // Computing bound for s
    int64_t _424 = 642;
    _423.d1 = _424;
    if (_424 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    // Computing bound for t
    int64_t _425 = 461;
    _423.d2 = _425;
    if (_425 > 0) 
    goto _jump1203;
    fail_assertion("non-positive loop bound");
    _jump1203:;
    // Computing total size of heap memory to allocate
    int64_t _426 = 1;
    _426 *= _284.d2;
    _426 *= _424;
    _426 *= _425;
    _426 *= sizeof(bool);
    _423.data = jpl_alloc(_426);
    int64_t _427 = 0; // t
    int64_t _428 = 0; // s
    int64_t _429 = 0; // r
    _jump1204:; // Begin body of loop
    bool _430 = true;
    int64_t _431 = 0;
    _431 *= _423.d0;
    _431 += _429;
    _431 *= _423.d1;
    _431 += _428;
    _431 *= _423.d2;
    _431 += _427;
    _423.data[_431] = _430;
    _427++;
    if (_427 < _425)
    goto _jump1204;
    _427 = 0;
    _428++;
    if (_428 < _424)
    goto _jump1204;
    _428 = 0;
    _429++;
    if (_429 < _284.d2)
    goto _jump1204;
    // End body of loop
    _414 = _423;
    _jump1200:;
    _402 = _414;
    _jump1194:;
    _400 = _402;
    goto _jump1205;
    _jump1188:;
    int64_t _432;
    // Computing bound for r
    int64_t _433 = 886;
    if (_433 > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    // Computing bound for s
    if (_366.d1 > 0) 
    goto _jump1207;
    fail_assertion("non-positive loop bound");
    _jump1207:;
    _432 = 0;
    int64_t _434 = 0; // s
    int64_t _435 = 0; // r
    _jump1208:; // Begin body of loop
    _432 += _341.d0;
    _434++;
    if (_434 < _366.d1)
    goto _jump1208;
    _434 = 0;
    _435++;
    if (_435 < _433)
    goto _jump1208;
    // End body of loop
    bool _436 = _432 <= _341.d0;
    _a3_bool _437;
    if (!_436)
    goto _jump1209;
    _a3_bool _438;
    // Computing bound for r
    _438.d0 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1210;
    fail_assertion("non-positive loop bound");
    _jump1210:;
    // Computing bound for s
    _438.d1 = _284.d0;
    if (_284.d0 > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing bound for t
    _438.d2 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= _366.d0;
    _439 *= _284.d0;
    _439 *= _284.d1;
    _439 *= sizeof(bool);
    _438.data = jpl_alloc(_439);
    int64_t _440 = 0; // t
    int64_t _441 = 0; // s
    int64_t _442 = 0; // r
    _jump1213:; // Begin body of loop
    int64_t _443 = 103;
    bool _444 = _440 >= _443;
    int64_t _445 = 0;
    _445 *= _438.d0;
    _445 += _442;
    _445 *= _438.d1;
    _445 += _441;
    _445 *= _438.d2;
    _445 += _440;
    _438.data[_445] = _444;
    _440++;
    if (_440 < _284.d1)
    goto _jump1213;
    _440 = 0;
    _441++;
    if (_441 < _284.d0)
    goto _jump1213;
    _441 = 0;
    _442++;
    if (_442 < _366.d0)
    goto _jump1213;
    // End body of loop
    _437 = _438;
    goto _jump1214;
    _jump1209:;
    _a3_bool _446;
    // Computing bound for r
    _446.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    // Computing bound for s
    int64_t _447;
    // Computing bound for r
    int64_t _448 = 461;
    if (_448 > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing bound for s
    if (_284.d2 > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    _447 = 0;
    int64_t _449 = 0; // s
    int64_t _450 = 0; // r
    _jump1218:; // Begin body of loop
    _447 += _284.d2;
    _449++;
    if (_449 < _284.d2)
    goto _jump1218;
    _449 = 0;
    _450++;
    if (_450 < _448)
    goto _jump1218;
    // End body of loop
    _446.d1 = _447;
    if (_447 > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    // Computing bound for t
    _446.d2 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing total size of heap memory to allocate
    int64_t _451 = 1;
    _451 *= _284.d2;
    _451 *= _447;
    _451 *= _366.d0;
    _451 *= sizeof(bool);
    _446.data = jpl_alloc(_451);
    int64_t _452 = 0; // t
    int64_t _453 = 0; // s
    int64_t _454 = 0; // r
    _jump1221:; // Begin body of loop
    bool _455 = false;
    int64_t _456 = 0;
    _456 *= _446.d0;
    _456 += _454;
    _456 *= _446.d1;
    _456 += _453;
    _456 *= _446.d2;
    _456 += _452;
    _446.data[_456] = _455;
    _452++;
    if (_452 < _366.d0)
    goto _jump1221;
    _452 = 0;
    _453++;
    if (_453 < _447)
    goto _jump1221;
    _453 = 0;
    _454++;
    if (_454 < _284.d2)
    goto _jump1221;
    // End body of loop
    _437 = _446;
    _jump1214:;
    _400 = _437;
    _jump1205:;
    _376 = _400;
    _jump1187:;
    _a2_o _457;
    // Computing bound for r
    _457.d0 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for s
    _457.d1 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing total size of heap memory to allocate
    int64_t _458 = 1;
    _458 *= _366.d0;
    _458 *= _366.d0;
    _458 *= sizeof(o);
    _457.data = jpl_alloc(_458);
    int64_t _459 = 0; // s
    int64_t _460 = 0; // r
    _jump1224:; // Begin body of loop
    bool _461 = true;
    o _462 = { _461 };
    int64_t _463 = 0;
    _463 *= _457.d0;
    _463 += _460;
    _463 *= _457.d1;
    _463 += _459;
    _457.data[_463] = _462;
    _459++;
    if (_459 < _366.d0)
    goto _jump1224;
    _459 = 0;
    _460++;
    if (_460 < _366.d0)
    goto _jump1224;
    // End body of loop
    int64_t _464;
    // Computing bound for r
    int64_t _465 = 453;
    if (_465 > 0) 
    goto _jump1225;
    fail_assertion("non-positive loop bound");
    _jump1225:;
    // Computing bound for s
    if (_284.d0 > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing bound for t
    if (_366.d1 >= 0)
    goto _jump1227;
    fail_assertion("negative array index");
    _jump1227:;
    if (_366.d1 < _289.d0)
    goto _jump1228;
    fail_assertion("index too large");
    _jump1228:;
    int64_t _466 = 0;
    _466 *= _289.d0;
    _466 += _366.d1;
    int64_t _467 = _289.data[_466];
    if (_467 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    _464 = 0;
    int64_t _468 = 0; // t
    int64_t _469 = 0; // s
    int64_t _470 = 0; // r
    _jump1230:; // Begin body of loop
    _464 += _366.d1;
    _468++;
    if (_468 < _467)
    goto _jump1230;
    _468 = 0;
    _469++;
    if (_469 < _284.d0)
    goto _jump1230;
    _469 = 0;
    _470++;
    if (_470 < _465)
    goto _jump1230;
    // End body of loop
    if (_366.d0 >= 0)
    goto _jump1231;
    fail_assertion("negative array index");
    _jump1231:;
    if (_366.d0 < _457.d0)
    goto _jump1232;
    fail_assertion("index too large");
    _jump1232:;
    if (_464 >= 0)
    goto _jump1233;
    fail_assertion("negative array index");
    _jump1233:;
    if (_464 < _457.d1)
    goto _jump1234;
    fail_assertion("index too large");
    _jump1234:;
    int64_t _471 = 0;
    _471 *= _457.d0;
    _471 += _366.d0;
    _471 *= _457.d1;
    _471 += _464;
    o _472 = _457.data[_471];
    bool _473 = _472.a;
    int64_t _474;
    if (!_473)
    goto _jump1235;
    _a2_int64_t _475;
    // Computing bound for r
    int64_t _476 = 1000;
    _475.d0 = _476;
    if (_476 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing bound for s
    _475.d1 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    // Computing total size of heap memory to allocate
    int64_t _477 = 1;
    _477 *= _476;
    _477 *= _341.d0;
    _477 *= sizeof(int64_t);
    _475.data = jpl_alloc(_477);
    int64_t _478 = 0; // s
    int64_t _479 = 0; // r
    _jump1238:; // Begin body of loop
    int64_t _480 = 0;
    _480 *= _475.d0;
    _480 += _479;
    _480 *= _475.d1;
    _480 += _478;
    _475.data[_480] = _341.d0;
    _478++;
    if (_478 < _341.d0)
    goto _jump1238;
    _478 = 0;
    _479++;
    if (_479 < _476)
    goto _jump1238;
    // End body of loop
    int64_t _481;
    // Computing bound for r
    if (_284.d2 > 0) 
    goto _jump1239;
    fail_assertion("non-positive loop bound");
    _jump1239:;
    // Computing bound for s
    int64_t _482;
    // Computing bound for r
    if (_366.d1 > 0) 
    goto _jump1240;
    fail_assertion("non-positive loop bound");
    _jump1240:;
    // Computing bound for s
    bool _483 = true;
    int64_t _484;
    if (!_483)
    goto _jump1241;
    _484 = _366.d1;
    goto _jump1242;
    _jump1241:;
    _484 = _341.d0;
    _jump1242:;
    if (_484 > 0) 
    goto _jump1243;
    fail_assertion("non-positive loop bound");
    _jump1243:;
    _482 = 0;
    int64_t _485 = 0; // s
    int64_t _486 = 0; // r
    _jump1244:; // Begin body of loop
    bool _487 = false;
    int64_t _488;
    if (!_487)
    goto _jump1245;
    _488 = _366.d0;
    goto _jump1246;
    _jump1245:;
    _488 = _284.d2;
    _jump1246:;
    _482 += _488;
    _485++;
    if (_485 < _484)
    goto _jump1244;
    _485 = 0;
    _486++;
    if (_486 < _366.d1)
    goto _jump1244;
    // End body of loop
    if (_482 > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    _481 = 0;
    int64_t _489 = 0; // s
    int64_t _490 = 0; // r
    _jump1248:; // Begin body of loop
    _481 += _490;
    _489++;
    if (_489 < _482)
    goto _jump1248;
    _489 = 0;
    _490++;
    if (_490 < _284.d2)
    goto _jump1248;
    // End body of loop
    if (_481 >= 0)
    goto _jump1249;
    fail_assertion("negative array index");
    _jump1249:;
    if (_481 < _475.d0)
    goto _jump1250;
    fail_assertion("index too large");
    _jump1250:;
    if (_284.d2 >= 0)
    goto _jump1251;
    fail_assertion("negative array index");
    _jump1251:;
    if (_284.d2 < _475.d1)
    goto _jump1252;
    fail_assertion("index too large");
    _jump1252:;
    int64_t _491 = 0;
    _491 *= _475.d0;
    _491 += _481;
    _491 *= _475.d1;
    _491 += _284.d2;
    int64_t _492 = _475.data[_491];
    _474 = _492;
    goto _jump1253;
    _jump1235:;
    int64_t _493 = -_341.d0;
    int64_t _494 = -_493;
    _474 = _494;
    _jump1253:;
    bool _495 = false;
    bool _496 = true;
    bool _497 = _495 != _496;
    bool _498 = !_497;
    bool _499 = !_498;
    int64_t _500;
    if (!_499)
    goto _jump1254;
    _500 = _341.d0;
    goto _jump1255;
    _jump1254:;
    _500 = _366.d1;
    _jump1255:;
    int64_t _501;
    // Computing bound for r
    int64_t _502 = _366.d1 + _341.d0;
    if (_502 > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    _501 = 0;
    int64_t _503 = 0; // r
    _jump1257:; // Begin body of loop
    int64_t _504 = 34;
    _501 += _504;
    _503++;
    if (_503 < _502)
    goto _jump1257;
    // End body of loop
    if (_284.d0 >= 0)
    goto _jump1258;
    fail_assertion("negative array index");
    _jump1258:;
    if (_284.d0 < _366.d0)
    goto _jump1259;
    fail_assertion("index too large");
    _jump1259:;
    if (_284.d0 >= 0)
    goto _jump1260;
    fail_assertion("negative array index");
    _jump1260:;
    if (_284.d0 < _366.d1)
    goto _jump1261;
    fail_assertion("index too large");
    _jump1261:;
    int64_t _505 = 0;
    _505 *= _366.d0;
    _505 += _284.d0;
    _505 *= _366.d1;
    _505 += _284.d0;
    int64_t _506 = _366.data[_505];
    int64_t _507;
    // Computing bound for r
    if (_366.d1 > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    _507 = 0;
    int64_t _508 = 0; // r
    _jump1263:; // Begin body of loop
    int64_t _509 = 968;
    _507 += _509;
    _508++;
    if (_508 < _366.d1)
    goto _jump1263;
    // End body of loop
    if (_506 >= 0)
    goto _jump1264;
    fail_assertion("negative array index");
    _jump1264:;
    if (_506 < _366.d0)
    goto _jump1265;
    fail_assertion("index too large");
    _jump1265:;
    if (_507 >= 0)
    goto _jump1266;
    fail_assertion("negative array index");
    _jump1266:;
    if (_507 < _366.d1)
    goto _jump1267;
    fail_assertion("index too large");
    _jump1267:;
    int64_t _510 = 0;
    _510 *= _366.d0;
    _510 += _506;
    _510 *= _366.d1;
    _510 += _507;
    int64_t _511 = _366.data[_510];
    if (_284.d2 >= 0)
    goto _jump1268;
    fail_assertion("negative array index");
    _jump1268:;
    if (_284.d2 < _284.d0)
    goto _jump1269;
    fail_assertion("index too large");
    _jump1269:;
    if (_501 >= 0)
    goto _jump1270;
    fail_assertion("negative array index");
    _jump1270:;
    if (_501 < _284.d1)
    goto _jump1271;
    fail_assertion("index too large");
    _jump1271:;
    if (_511 >= 0)
    goto _jump1272;
    fail_assertion("negative array index");
    _jump1272:;
    if (_511 < _284.d2)
    goto _jump1273;
    fail_assertion("index too large");
    _jump1273:;
    int64_t _512 = 0;
    _512 *= _284.d0;
    _512 += _284.d2;
    _512 *= _284.d1;
    _512 += _501;
    _512 *= _284.d2;
    _512 += _511;
    int64_t _513 = _284.data[_512];
    int64_t _514 = -_513;
    int64_t _515 = _514 * _366.d0;
    if (_474 >= 0)
    goto _jump1274;
    fail_assertion("negative array index");
    _jump1274:;
    if (_474 < _376.d0)
    goto _jump1275;
    fail_assertion("index too large");
    _jump1275:;
    if (_500 >= 0)
    goto _jump1276;
    fail_assertion("negative array index");
    _jump1276:;
    if (_500 < _376.d1)
    goto _jump1277;
    fail_assertion("index too large");
    _jump1277:;
    if (_515 >= 0)
    goto _jump1278;
    fail_assertion("negative array index");
    _jump1278:;
    if (_515 < _376.d2)
    goto _jump1279;
    fail_assertion("index too large");
    _jump1279:;
    int64_t _516 = 0;
    _516 *= _376.d0;
    _516 += _474;
    _516 *= _376.d1;
    _516 += _500;
    _516 *= _376.d2;
    _516 += _515;
    bool _517 = _376.data[_516];
    _a3_int64_t _518;
    if (!_517)
    goto _jump1280;
    _a1__a3_int64_t _519;
    // Computing bound for r
    int64_t _520 = -_284.d0;
    _519.d0 = _520;
    if (_520 > 0) 
    goto _jump1281;
    fail_assertion("non-positive loop bound");
    _jump1281:;
    // Computing total size of heap memory to allocate
    int64_t _521 = 1;
    _521 *= _520;
    _521 *= sizeof(_a3_int64_t);
    _519.data = jpl_alloc(_521);
    int64_t _522 = 0; // r
    _jump1282:; // Begin body of loop
    _a2__a3_int64_t _523;
    // Computing bound for s
    int64_t _524 = 285;
    _523.d0 = _524;
    if (_524 > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing bound for t
    _523.d1 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing total size of heap memory to allocate
    int64_t _525 = 1;
    _525 *= _524;
    _525 *= _284.d2;
    _525 *= sizeof(_a3_int64_t);
    _523.data = jpl_alloc(_525);
    int64_t _526 = 0; // t
    int64_t _527 = 0; // s
    _jump1285:; // Begin body of loop
    int64_t _528 = 0;
    _528 *= _523.d0;
    _528 += _527;
    _528 *= _523.d1;
    _528 += _526;
    _523.data[_528] = _284;
    _526++;
    if (_526 < _284.d2)
    goto _jump1285;
    _526 = 0;
    _527++;
    if (_527 < _524)
    goto _jump1285;
    // End body of loop
    _a1_int64_t _529;
    _529.d0 = 2;
    _529.data = jpl_alloc(sizeof(int64_t) * 2);
    _529.data[0] = _522;
    _529.data[1] = _341.d0;
    if (_522 >= 0)
    goto _jump1286;
    fail_assertion("negative array index");
    _jump1286:;
    if (_522 < _529.d0)
    goto _jump1287;
    fail_assertion("index too large");
    _jump1287:;
    int64_t _530 = 0;
    _530 *= _529.d0;
    _530 += _522;
    int64_t _531 = _529.data[_530];
    bool _532 = true;
    int64_t _533;
    if (!_532)
    goto _jump1288;
    _533 = _284.d1;
    goto _jump1289;
    _jump1288:;
    int64_t _534 = _341.d0 - _284.d2;
    _533 = _534;
    _jump1289:;
    if (_531 >= 0)
    goto _jump1290;
    fail_assertion("negative array index");
    _jump1290:;
    if (_531 < _523.d0)
    goto _jump1291;
    fail_assertion("index too large");
    _jump1291:;
    if (_533 >= 0)
    goto _jump1292;
    fail_assertion("negative array index");
    _jump1292:;
    if (_533 < _523.d1)
    goto _jump1293;
    fail_assertion("index too large");
    _jump1293:;
    int64_t _535 = 0;
    _535 *= _523.d0;
    _535 += _531;
    _535 *= _523.d1;
    _535 += _533;
    _a3_int64_t _536 = _523.data[_535];
    int64_t _537 = 0;
    _537 *= _519.d0;
    _537 += _522;
    _519.data[_537] = _536;
    _522++;
    if (_522 < _520)
    goto _jump1282;
    // End body of loop
    int64_t _538 = 388;
    if (_538 >= 0)
    goto _jump1294;
    fail_assertion("negative array index");
    _jump1294:;
    if (_538 < _519.d0)
    goto _jump1295;
    fail_assertion("index too large");
    _jump1295:;
    int64_t _539 = 0;
    _539 *= _519.d0;
    _539 += _538;
    _a3_int64_t _540 = _519.data[_539];
    _518 = _540;
    goto _jump1296;
    _jump1280:;
    _a3_int64_t _541;
    // Computing bound for r
    int64_t _542 = 271;
    int64_t _543 = -_542;
    _541.d0 = _543;
    if (_543 > 0) 
    goto _jump1297;
    fail_assertion("non-positive loop bound");
    _jump1297:;
    // Computing bound for s
    int64_t _544 = 649;
    _541.d1 = _544;
    if (_544 > 0) 
    goto _jump1298;
    fail_assertion("non-positive loop bound");
    _jump1298:;
    // Computing bound for t
    bool _545 = true;
    double _546 = 59.0;
    h _547 = { _546 };
    double _548 = _547.a;
    h _549 = { _548 };
    _a2_int64_t _550;
    // Computing bound for r
    _550.d0 = _366.d1;
    if (_366.d1 > 0) 
    goto _jump1299;
    fail_assertion("non-positive loop bound");
    _jump1299:;
    // Computing bound for s
    _550.d1 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1300;
    fail_assertion("non-positive loop bound");
    _jump1300:;
    // Computing total size of heap memory to allocate
    int64_t _551 = 1;
    _551 *= _366.d1;
    _551 *= _366.d0;
    _551 *= sizeof(int64_t);
    _550.data = jpl_alloc(_551);
    int64_t _552 = 0; // s
    int64_t _553 = 0; // r
    _jump1301:; // Begin body of loop
    int64_t _554 = 819;
    if (_554 >= 0)
    goto _jump1302;
    fail_assertion("negative array index");
    _jump1302:;
    if (_554 < _366.d0)
    goto _jump1303;
    fail_assertion("index too large");
    _jump1303:;
    if (_366.d0 >= 0)
    goto _jump1304;
    fail_assertion("negative array index");
    _jump1304:;
    if (_366.d0 < _366.d1)
    goto _jump1305;
    fail_assertion("index too large");
    _jump1305:;
    int64_t _555 = 0;
    _555 *= _366.d0;
    _555 += _554;
    _555 *= _366.d1;
    _555 += _366.d0;
    int64_t _556 = _366.data[_555];
    int64_t _557 = 0;
    _557 *= _550.d0;
    _557 += _553;
    _557 *= _550.d1;
    _557 += _552;
    _550.data[_557] = _556;
    _552++;
    if (_552 < _366.d0)
    goto _jump1301;
    _552 = 0;
    _553++;
    if (_553 < _366.d1)
    goto _jump1301;
    // End body of loop
    int64_t _558 = 53;
    if (_558 >= 0)
    goto _jump1306;
    fail_assertion("negative array index");
    _jump1306:;
    if (_558 < _550.d0)
    goto _jump1307;
    fail_assertion("index too large");
    _jump1307:;
    if (_284.d1 >= 0)
    goto _jump1308;
    fail_assertion("negative array index");
    _jump1308:;
    if (_284.d1 < _550.d1)
    goto _jump1309;
    fail_assertion("index too large");
    _jump1309:;
    int64_t _559 = 0;
    _559 *= _550.d0;
    _559 += _558;
    _559 *= _550.d1;
    _559 += _284.d1;
    int64_t _560 = _550.data[_559];
    i _561 = { _545, _549, _560 };
    int64_t _562 = _561.c;
    _541.d2 = _562;
    if (_562 > 0) 
    goto _jump1310;
    fail_assertion("non-positive loop bound");
    _jump1310:;
    // Computing total size of heap memory to allocate
    int64_t _563 = 1;
    _563 *= _543;
    _563 *= _544;
    _563 *= _562;
    _563 *= sizeof(int64_t);
    _541.data = jpl_alloc(_563);
    int64_t _564 = 0; // t
    int64_t _565 = 0; // s
    int64_t _566 = 0; // r
    _jump1311:; // Begin body of loop
    bool _567 = _341.d0 == _284.d2;
    _a1__a2_int64_t _568;
    if (!_567)
    goto _jump1312;
    _a1__a2_int64_t _569;
    // Computing bound for u
    _569.d0 = _565;
    if (_565 > 0) 
    goto _jump1313;
    fail_assertion("non-positive loop bound");
    _jump1313:;
    // Computing total size of heap memory to allocate
    int64_t _570 = 1;
    _570 *= _565;
    _570 *= sizeof(_a2_int64_t);
    _569.data = jpl_alloc(_570);
    int64_t _571 = 0; // u
    _jump1314:; // Begin body of loop
    int64_t _572 = 0;
    _572 *= _569.d0;
    _572 += _571;
    _569.data[_572] = _366;
    _571++;
    if (_571 < _565)
    goto _jump1314;
    // End body of loop
    _568 = _569;
    goto _jump1315;
    _jump1312:;
    _a2_int64_t _573;
    // Computing bound for u
    _573.d0 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    // Computing bound for v
    _573.d1 = _284.d0;
    if (_284.d0 > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    // Computing total size of heap memory to allocate
    int64_t _574 = 1;
    _574 *= _366.d0;
    _574 *= _284.d0;
    _574 *= sizeof(int64_t);
    _573.data = jpl_alloc(_574);
    int64_t _575 = 0; // v
    int64_t _576 = 0; // u
    _jump1318:; // Begin body of loop
    int64_t _577 = 0;
    _577 *= _573.d0;
    _577 += _576;
    _577 *= _573.d1;
    _577 += _575;
    _573.data[_577] = _366.d1;
    _575++;
    if (_575 < _284.d0)
    goto _jump1318;
    _575 = 0;
    _576++;
    if (_576 < _366.d0)
    goto _jump1318;
    // End body of loop
    _a1__a2_int64_t _578;
    _578.d0 = 2;
    _578.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _578.data[0] = _573;
    _578.data[1] = _366;
    _568 = _578;
    _jump1315:;
    if (_284.d2 >= 0)
    goto _jump1319;
    fail_assertion("negative array index");
    _jump1319:;
    if (_284.d2 < _568.d0)
    goto _jump1320;
    fail_assertion("index too large");
    _jump1320:;
    int64_t _579 = 0;
    _579 *= _568.d0;
    _579 += _284.d2;
    _a2_int64_t _580 = _568.data[_579];
    int64_t _581 = 881;
    if (_284.d1 >= 0)
    goto _jump1321;
    fail_assertion("negative array index");
    _jump1321:;
    if (_284.d1 < _580.d0)
    goto _jump1322;
    fail_assertion("index too large");
    _jump1322:;
    if (_581 >= 0)
    goto _jump1323;
    fail_assertion("negative array index");
    _jump1323:;
    if (_581 < _580.d1)
    goto _jump1324;
    fail_assertion("index too large");
    _jump1324:;
    int64_t _582 = 0;
    _582 *= _580.d0;
    _582 += _284.d1;
    _582 *= _580.d1;
    _582 += _581;
    int64_t _583 = _580.data[_582];
    int64_t _584 = 0;
    _584 *= _541.d0;
    _584 += _566;
    _584 *= _541.d1;
    _584 += _565;
    _584 *= _541.d2;
    _584 += _564;
    _541.data[_584] = _583;
    _564++;
    if (_564 < _562)
    goto _jump1311;
    _564 = 0;
    _565++;
    if (_565 < _544)
    goto _jump1311;
    _565 = 0;
    _566++;
    if (_566 < _543)
    goto _jump1311;
    // End body of loop
    _518 = _541;
    _jump1296:;
    double _585 = 71.0;
    double _586 = -_585;
    double _587;
    // Computing bound for v
    if (_518.d1 > 0) 
    goto _jump1325;
    fail_assertion("non-positive loop bound");
    _jump1325:;
    // Computing bound for w
    int64_t _588;
    // Computing bound for v
    if (_366.d0 > 0) 
    goto _jump1326;
    fail_assertion("non-positive loop bound");
    _jump1326:;
    // Computing bound for w
    if (_518.d1 > 0) 
    goto _jump1327;
    fail_assertion("non-positive loop bound");
    _jump1327:;
    // Computing bound for x
    int64_t _589 = 728;
    if (_589 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    _588 = 0;
    int64_t _590 = 0; // x
    int64_t _591 = 0; // w
    int64_t _592 = 0; // v
    _jump1329:; // Begin body of loop
    _588 += _284.d0;
    _590++;
    if (_590 < _589)
    goto _jump1329;
    _590 = 0;
    _591++;
    if (_591 < _518.d1)
    goto _jump1329;
    _591 = 0;
    _592++;
    if (_592 < _366.d0)
    goto _jump1329;
    // End body of loop
    if (_588 > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    _587 = 0;
    int64_t _593 = 0; // w
    int64_t _594 = 0; // v
    _jump1331:; // Begin body of loop
    double _595 = 74.0;
    double _596 = -_595;
    _587 += _596;
    _593++;
    if (_593 < _588)
    goto _jump1331;
    _593 = 0;
    _594++;
    if (_594 < _518.d1)
    goto _jump1331;
    // End body of loop
    double _597 = -_587;
    bool _598 = _586 < _597;
    o _599 = { _598 };
    double _600 = 29.0;
    h _601 = { _600 };
    double _602 = _601.a;
    double _603 = 57.0;
    double _604;
    // Computing bound for v
    int64_t _605;
    // Computing bound for v
    if (_366.d0 > 0) 
    goto _jump1332;
    fail_assertion("non-positive loop bound");
    _jump1332:;
    _605 = 0;
    int64_t _606 = 0; // v
    _jump1333:; // Begin body of loop
    _605 += _341.d0;
    _606++;
    if (_606 < _366.d0)
    goto _jump1333;
    // End body of loop
    if (_605 > 0) 
    goto _jump1334;
    fail_assertion("non-positive loop bound");
    _jump1334:;
    _604 = 0;
    int64_t _607 = 0; // v
    _jump1335:; // Begin body of loop
    double _608 = 93.0;
    _604 += _608;
    _607++;
    if (_607 < _605)
    goto _jump1335;
    // End body of loop
    double _609 = 1.0;
    double _610 = -_609;
    rgba _611 = { _602, _603, _604, _610 };
    rgba _612 = p(_599, _284.d2, _611);
    bool _613 = true;
    rgba _614;
    if (!_613)
    goto _jump1336;
    _a2_bool _615;
    // Computing bound for v
    _615.d0 = _366.d1;
    if (_366.d1 > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    // Computing bound for w
    _615.d1 = _518.d0;
    if (_518.d0 > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing total size of heap memory to allocate
    int64_t _616 = 1;
    _616 *= _366.d1;
    _616 *= _518.d0;
    _616 *= sizeof(bool);
    _615.data = jpl_alloc(_616);
    int64_t _617 = 0; // w
    int64_t _618 = 0; // v
    _jump1339:; // Begin body of loop
    bool _619 = true;
    int64_t _620 = 0;
    _620 *= _615.d0;
    _620 += _618;
    _620 *= _615.d1;
    _620 += _617;
    _615.data[_620] = _619;
    _617++;
    if (_617 < _518.d0)
    goto _jump1339;
    _617 = 0;
    _618++;
    if (_618 < _366.d1)
    goto _jump1339;
    // End body of loop
    int64_t _621 = _518.d2 / _518.d1;
    int64_t _622 = -_621;
    int64_t _623;
    // Computing bound for v
    if (_284.d0 > 0) 
    goto _jump1340;
    fail_assertion("non-positive loop bound");
    _jump1340:;
    // Computing bound for w
    if (_518.d2 > 0) 
    goto _jump1341;
    fail_assertion("non-positive loop bound");
    _jump1341:;
    _623 = 0;
    int64_t _624 = 0; // w
    int64_t _625 = 0; // v
    _jump1342:; // Begin body of loop
    _623 += _518.d0;
    _624++;
    if (_624 < _518.d2)
    goto _jump1342;
    _624 = 0;
    _625++;
    if (_625 < _284.d0)
    goto _jump1342;
    // End body of loop
    if (_622 >= 0)
    goto _jump1343;
    fail_assertion("negative array index");
    _jump1343:;
    if (_622 < _615.d0)
    goto _jump1344;
    fail_assertion("index too large");
    _jump1344:;
    if (_623 >= 0)
    goto _jump1345;
    fail_assertion("negative array index");
    _jump1345:;
    if (_623 < _615.d1)
    goto _jump1346;
    fail_assertion("index too large");
    _jump1346:;
    int64_t _626 = 0;
    _626 *= _615.d0;
    _626 += _622;
    _626 *= _615.d1;
    _626 += _623;
    bool _627 = _615.data[_626];
    o _628;
    if (!_627)
    goto _jump1347;
    bool _629 = true;
    o _630;
    if (!_629)
    goto _jump1348;
    bool _631 = true;
    o _632 = { _631 };
    _630 = _632;
    goto _jump1349;
    _jump1348:;
    bool _633 = true;
    o _634 = { _633 };
    _630 = _634;
    _jump1349:;
    _628 = _630;
    goto _jump1350;
    _jump1347:;
    bool _635 = _284.d0 >= _341.d0;
    bool _636;
    if (!_635)
    goto _jump1351;
    bool _637 = true;
    _636 = _637;
    goto _jump1352;
    _jump1351:;
    bool _639 = false;
    bool _638 = _639;
    if (0 != _639)
    goto _jump1353;
    bool _640 = true;
    _638 = _640;
    _jump1353:;
    _636 = _638;
    _jump1352:;
    o _641 = { _636 };
    _628 = _641;
    _jump1350:;
    _a2_double _642;
    // Computing bound for v
    _642.d0 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1354;
    fail_assertion("non-positive loop bound");
    _jump1354:;
    // Computing bound for w
    _642.d1 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump1355;
    fail_assertion("non-positive loop bound");
    _jump1355:;
    // Computing total size of heap memory to allocate
    int64_t _643 = 1;
    _643 *= _366.d0;
    _643 *= _284.d1;
    _643 *= sizeof(double);
    _642.data = jpl_alloc(_643);
    int64_t _644 = 0; // w
    int64_t _645 = 0; // v
    _jump1356:; // Begin body of loop
    double _646 = 69.0;
    double _647 = -_646;
    int64_t _648 = 0;
    _648 *= _642.d0;
    _648 += _645;
    _648 *= _642.d1;
    _648 += _644;
    _642.data[_648] = _647;
    _644++;
    if (_644 < _284.d1)
    goto _jump1356;
    _644 = 0;
    _645++;
    if (_645 < _366.d0)
    goto _jump1356;
    // End body of loop
    int64_t _649 = _366.d0 + _341.d0;
    int64_t _650 = -_649;
    if (_650 >= 0)
    goto _jump1357;
    fail_assertion("negative array index");
    _jump1357:;
    if (_650 < _642.d0)
    goto _jump1358;
    fail_assertion("index too large");
    _jump1358:;
    if (_366.d1 >= 0)
    goto _jump1359;
    fail_assertion("negative array index");
    _jump1359:;
    if (_366.d1 < _642.d1)
    goto _jump1360;
    fail_assertion("index too large");
    _jump1360:;
    int64_t _651 = 0;
    _651 *= _642.d0;
    _651 += _650;
    _651 *= _642.d1;
    _651 += _366.d1;
    double _652 = _642.data[_651];
    double _653;
    // Computing bound for v
    if (_518.d2 > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing bound for w
    if (_284.d1 > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    _653 = 0;
    int64_t _654 = 0; // w
    int64_t _655 = 0; // v
    _jump1363:; // Begin body of loop
    double _656 = 54.0;
    double _657 = -_656;
    double _658 = -_657;
    _653 += _658;
    _654++;
    if (_654 < _284.d1)
    goto _jump1363;
    _654 = 0;
    _655++;
    if (_655 < _518.d2)
    goto _jump1363;
    // End body of loop
    _a1_double _659;
    // Computing bound for v
    _659.d0 = _284.d0;
    if (_284.d0 > 0) 
    goto _jump1364;
    fail_assertion("non-positive loop bound");
    _jump1364:;
    // Computing total size of heap memory to allocate
    int64_t _660 = 1;
    _660 *= _284.d0;
    _660 *= sizeof(double);
    _659.data = jpl_alloc(_660);
    int64_t _661 = 0; // v
    _jump1365:; // Begin body of loop
    double _662 = 83.0;
    int64_t _663 = 0;
    _663 *= _659.d0;
    _663 += _661;
    _659.data[_663] = _662;
    _661++;
    if (_661 < _284.d0)
    goto _jump1365;
    // End body of loop
    if (_341.d0 >= 0)
    goto _jump1366;
    fail_assertion("negative array index");
    _jump1366:;
    if (_341.d0 < _659.d0)
    goto _jump1367;
    fail_assertion("index too large");
    _jump1367:;
    int64_t _664 = 0;
    _664 *= _659.d0;
    _664 += _341.d0;
    double _665 = _659.data[_664];
    _a2_double _666;
    // Computing bound for v
    _666.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1368;
    fail_assertion("non-positive loop bound");
    _jump1368:;
    // Computing bound for w
    int64_t _667 = 805;
    int64_t _668 = _341.d0 - _667;
    _666.d1 = _668;
    if (_668 > 0) 
    goto _jump1369;
    fail_assertion("non-positive loop bound");
    _jump1369:;
    // Computing total size of heap memory to allocate
    int64_t _669 = 1;
    _669 *= _284.d2;
    _669 *= _668;
    _669 *= sizeof(double);
    _666.data = jpl_alloc(_669);
    int64_t _670 = 0; // w
    int64_t _671 = 0; // v
    _jump1370:; // Begin body of loop
    double _672 = 17.0;
    double _673 = 91.0;
    double _674 = _672 - _673;
    int64_t _675 = 0;
    _675 *= _666.d0;
    _675 += _671;
    _675 *= _666.d1;
    _675 += _670;
    _666.data[_675] = _674;
    _670++;
    if (_670 < _668)
    goto _jump1370;
    _670 = 0;
    _671++;
    if (_671 < _284.d2)
    goto _jump1370;
    // End body of loop
    if (_284.d1 >= 0)
    goto _jump1371;
    fail_assertion("negative array index");
    _jump1371:;
    if (_284.d1 < _666.d0)
    goto _jump1372;
    fail_assertion("index too large");
    _jump1372:;
    if (_284.d1 >= 0)
    goto _jump1373;
    fail_assertion("negative array index");
    _jump1373:;
    if (_284.d1 < _666.d1)
    goto _jump1374;
    fail_assertion("index too large");
    _jump1374:;
    int64_t _676 = 0;
    _676 *= _666.d0;
    _676 += _284.d1;
    _676 *= _666.d1;
    _676 += _284.d1;
    double _677 = _666.data[_676];
    rgba _678 = { _652, _653, _665, _677 };
    rgba _679 = p(_628, _341.d0, _678);
    _614 = _679;
    goto _jump1375;
    _jump1336:;
    double _680 = 30.0;
    h _681 = { _680 };
    double _682 = _681.a;
    double _683 = 29.0;
    double _684 = -_683;
    bool _685 = _682 < _684;
    double _686;
    if (!_685)
    goto _jump1376;
    double _687;
    // Computing bound for v
    if (_366.d0 > 0) 
    goto _jump1377;
    fail_assertion("non-positive loop bound");
    _jump1377:;
    // Computing bound for w
    if (_341.d0 > 0) 
    goto _jump1378;
    fail_assertion("non-positive loop bound");
    _jump1378:;
    // Computing bound for x
    if (_284.d0 > 0) 
    goto _jump1379;
    fail_assertion("non-positive loop bound");
    _jump1379:;
    _687 = 0;
    int64_t _688 = 0; // x
    int64_t _689 = 0; // w
    int64_t _690 = 0; // v
    _jump1380:; // Begin body of loop
    double _691 = 9.0;
    _687 += _691;
    _688++;
    if (_688 < _284.d0)
    goto _jump1380;
    _688 = 0;
    _689++;
    if (_689 < _341.d0)
    goto _jump1380;
    _689 = 0;
    _690++;
    if (_690 < _366.d0)
    goto _jump1380;
    // End body of loop
    _686 = _687;
    goto _jump1381;
    _jump1376:;
    double _692 = 32.0;
    _686 = _692;
    _jump1381:;
    double _693;
    // Computing bound for v
    if (_284.d2 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    _693 = 0;
    int64_t _694 = 0; // v
    _jump1383:; // Begin body of loop
    _a1_double _695;
    // Computing bound for w
    if (_284.d1 >= 0)
    goto _jump1384;
    fail_assertion("negative array index");
    _jump1384:;
    if (_284.d1 < _289.d0)
    goto _jump1385;
    fail_assertion("index too large");
    _jump1385:;
    int64_t _696 = 0;
    _696 *= _289.d0;
    _696 += _284.d1;
    int64_t _697 = _289.data[_696];
    _695.d0 = _697;
    if (_697 > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing total size of heap memory to allocate
    int64_t _698 = 1;
    _698 *= _697;
    _698 *= sizeof(double);
    _695.data = jpl_alloc(_698);
    int64_t _699 = 0; // w
    _jump1387:; // Begin body of loop
    double _700 = 65.0;
    int64_t _701 = 0;
    _701 *= _695.d0;
    _701 += _699;
    _695.data[_701] = _700;
    _699++;
    if (_699 < _697)
    goto _jump1387;
    // End body of loop
    int64_t _702 = _284.d2 / _284.d1;
    int64_t _703;
    // Computing bound for w
    if (_284.d2 > 0) 
    goto _jump1388;
    fail_assertion("non-positive loop bound");
    _jump1388:;
    // Computing bound for x
    if (_284.d1 > 0) 
    goto _jump1389;
    fail_assertion("non-positive loop bound");
    _jump1389:;
    _703 = 0;
    int64_t _704 = 0; // x
    int64_t _705 = 0; // w
    _jump1390:; // Begin body of loop
    _703 += _518.d2;
    _704++;
    if (_704 < _284.d1)
    goto _jump1390;
    _704 = 0;
    _705++;
    if (_705 < _284.d2)
    goto _jump1390;
    // End body of loop
    int64_t _706 = _702 * _703;
    if (_706 >= 0)
    goto _jump1391;
    fail_assertion("negative array index");
    _jump1391:;
    if (_706 < _695.d0)
    goto _jump1392;
    fail_assertion("index too large");
    _jump1392:;
    int64_t _707 = 0;
    _707 *= _695.d0;
    _707 += _706;
    double _708 = _695.data[_707];
    _693 += _708;
    _694++;
    if (_694 < _284.d2)
    goto _jump1383;
    // End body of loop
    double _709 = 8.0;
    h _710 = { _709 };
    double _711 = _710.a;
    double _712 = -_711;
    double _713;
    // Computing bound for v
    if (_284.d2 > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    // Computing bound for w
    if (_518.d1 > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    _713 = 0;
    int64_t _714 = 0; // w
    int64_t _715 = 0; // v
    _jump1395:; // Begin body of loop
    double _716 = 75.0;
    _713 += _716;
    _714++;
    if (_714 < _518.d1)
    goto _jump1395;
    _714 = 0;
    _715++;
    if (_715 < _284.d2)
    goto _jump1395;
    // End body of loop
    h _717 = { _713 };
    double _718 = _717.a;
    double _719 = _712 - _718;
    double _720 = 25.0;
    rgba _721 = { _686, _693, _719, _720 };
    _614 = _721;
    _jump1375:;
    _a1_o _722;
    // Computing bound for v
    _722.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1396;
    fail_assertion("non-positive loop bound");
    _jump1396:;
    // Computing total size of heap memory to allocate
    int64_t _723 = 1;
    _723 *= _284.d2;
    _723 *= sizeof(o);
    _722.data = jpl_alloc(_723);
    int64_t _724 = 0; // v
    _jump1397:; // Begin body of loop
    _a1_o _725;
    // Computing bound for w
    _725.d0 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump1398;
    fail_assertion("non-positive loop bound");
    _jump1398:;
    // Computing total size of heap memory to allocate
    int64_t _726 = 1;
    _726 *= _284.d1;
    _726 *= sizeof(o);
    _725.data = jpl_alloc(_726);
    int64_t _727 = 0; // w
    _jump1399:; // Begin body of loop
    bool _728 = true;
    o _729 = { _728 };
    int64_t _730 = 0;
    _730 *= _725.d0;
    _730 += _727;
    _725.data[_730] = _729;
    _727++;
    if (_727 < _284.d1)
    goto _jump1399;
    // End body of loop
    int64_t _731 = 888;
    int64_t _732 = -_731;
    if (_732 >= 0)
    goto _jump1400;
    fail_assertion("negative array index");
    _jump1400:;
    if (_732 < _725.d0)
    goto _jump1401;
    fail_assertion("index too large");
    _jump1401:;
    int64_t _733 = 0;
    _733 *= _725.d0;
    _733 += _732;
    o _734 = _725.data[_733];
    int64_t _735 = 0;
    _735 *= _722.d0;
    _735 += _724;
    _722.data[_735] = _734;
    _724++;
    if (_724 < _284.d2)
    goto _jump1397;
    // End body of loop
    if (_518.d1 >= 0)
    goto _jump1402;
    fail_assertion("negative array index");
    _jump1402:;
    if (_518.d1 < _722.d0)
    goto _jump1403;
    fail_assertion("index too large");
    _jump1403:;
    int64_t _736 = 0;
    _736 *= _722.d0;
    _736 += _518.d1;
    o _737 = _722.data[_736];
    double _738 = 64.0;
    h _739 = { _738 };
    double _740 = _739.a;
    double _741 = 55.0;
    double _742;
    // Computing bound for v
    int64_t _743 = -_518.d2;
    if (_743 > 0) 
    goto _jump1404;
    fail_assertion("non-positive loop bound");
    _jump1404:;
    // Computing bound for w
    if (_366.d1 > 0) 
    goto _jump1405;
    fail_assertion("non-positive loop bound");
    _jump1405:;
    _742 = 0;
    int64_t _744 = 0; // w
    int64_t _745 = 0; // v
    _jump1406:; // Begin body of loop
    double _746;
    // Computing bound for x
    int64_t _747 = 85;
    int64_t _748 = _745 % _747;
    if (_748 > 0) 
    goto _jump1407;
    fail_assertion("non-positive loop bound");
    _jump1407:;
    _746 = 0;
    int64_t _749 = 0; // x
    _jump1408:; // Begin body of loop
    double _750 = 77.0;
    _746 += _750;
    _749++;
    if (_749 < _748)
    goto _jump1408;
    // End body of loop
    _742 += _746;
    _744++;
    if (_744 < _366.d1)
    goto _jump1406;
    _744 = 0;
    _745++;
    if (_745 < _743)
    goto _jump1406;
    // End body of loop
    double _751 = -_742;
    _a3_double _752;
    // Computing bound for v
    _752.d0 = _518.d1;
    if (_518.d1 > 0) 
    goto _jump1409;
    fail_assertion("non-positive loop bound");
    _jump1409:;
    // Computing bound for w
    int64_t _753 = -_284.d0;
    _752.d1 = _753;
    if (_753 > 0) 
    goto _jump1410;
    fail_assertion("non-positive loop bound");
    _jump1410:;
    // Computing bound for x
    int64_t _754;
    // Computing bound for v
    if (_366.d1 > 0) 
    goto _jump1411;
    fail_assertion("non-positive loop bound");
    _jump1411:;
    _754 = 0;
    int64_t _755 = 0; // v
    _jump1412:; // Begin body of loop
    _754 += _518.d1;
    _755++;
    if (_755 < _366.d1)
    goto _jump1412;
    // End body of loop
    _752.d2 = _754;
    if (_754 > 0) 
    goto _jump1413;
    fail_assertion("non-positive loop bound");
    _jump1413:;
    // Computing total size of heap memory to allocate
    int64_t _756 = 1;
    _756 *= _518.d1;
    _756 *= _753;
    _756 *= _754;
    _756 *= sizeof(double);
    _752.data = jpl_alloc(_756);
    int64_t _757 = 0; // x
    int64_t _758 = 0; // w
    int64_t _759 = 0; // v
    _jump1414:; // Begin body of loop
    double _760 = 85.0;
    double _761 = -_760;
    int64_t _762 = 0;
    _762 *= _752.d0;
    _762 += _759;
    _762 *= _752.d1;
    _762 += _758;
    _762 *= _752.d2;
    _762 += _757;
    _752.data[_762] = _761;
    _757++;
    if (_757 < _754)
    goto _jump1414;
    _757 = 0;
    _758++;
    if (_758 < _753)
    goto _jump1414;
    _758 = 0;
    _759++;
    if (_759 < _518.d1)
    goto _jump1414;
    // End body of loop
    int64_t _763 = _518.d0 % _284.d2;
    if (_763 >= 0)
    goto _jump1415;
    fail_assertion("negative array index");
    _jump1415:;
    if (_763 < _752.d0)
    goto _jump1416;
    fail_assertion("index too large");
    _jump1416:;
    if (_284.d0 >= 0)
    goto _jump1417;
    fail_assertion("negative array index");
    _jump1417:;
    if (_284.d0 < _752.d1)
    goto _jump1418;
    fail_assertion("index too large");
    _jump1418:;
    if (_518.d0 >= 0)
    goto _jump1419;
    fail_assertion("negative array index");
    _jump1419:;
    if (_518.d0 < _752.d2)
    goto _jump1420;
    fail_assertion("index too large");
    _jump1420:;
    int64_t _764 = 0;
    _764 *= _752.d0;
    _764 += _763;
    _764 *= _752.d1;
    _764 += _284.d0;
    _764 *= _752.d2;
    _764 += _518.d0;
    double _765 = _752.data[_764];
    double _766 = 74.0;
    double _767 = _765 / _766;
    rgba _768 = { _740, _741, _751, _767 };
    rgba _769 = p(_737, _341.d0, _768);
    _a1_rgba _770;
    _770.d0 = 3;
    _770.data = jpl_alloc(sizeof(rgba) * 3);
    _770.data[0] = _612;
    _770.data[1] = _614;
    _770.data[2] = _769;
    bool _773 = _366.d0 != _518.d0;
    double _774;
    // Computing bound for x
    if (_770.d0 > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    _774 = 0;
    int64_t _775 = 0; // x
    _jump1422:; // Begin body of loop
    double _776 = 19.0;
    _774 += _776;
    _775++;
    if (_775 < _770.d0)
    goto _jump1422;
    // End body of loop
    h _777 = { _774 };
    i _778 = { _773, _777, _341.d0 };
    bool _779 = _778.a;
    bool _772 = _779;
    if (0 != _779)
    goto _jump1423;
    bool _782 = false;
    bool _781 = _782;
    if (0 != _782)
    goto _jump1424;
    bool _783 = false;
    _781 = _783;
    _jump1424:;
    bool _780 = _781;
    if (0 == _781)
    goto _jump1425;
    bool _784 = false;
    _780 = _784;
    _jump1425:;
    bool _785 = false;
    bool _786;
    if (!_785)
    goto _jump1426;
    bool _787 = _518.d1 < _518.d2;
    _786 = _787;
    goto _jump1427;
    _jump1426:;
    bool _789 = false;
    bool _788 = _789;
    if (0 != _789)
    goto _jump1428;
    bool _790 = false;
    _788 = _790;
    _jump1428:;
    _786 = _788;
    _jump1427:;
    _a1_bool _791;
    _791.d0 = 2;
    _791.data = jpl_alloc(sizeof(bool) * 2);
    _791.data[0] = _780;
    _791.data[1] = _786;
    if (_366.d1 >= 0)
    goto _jump1429;
    fail_assertion("negative array index");
    _jump1429:;
    if (_366.d1 < _791.d0)
    goto _jump1430;
    fail_assertion("index too large");
    _jump1430:;
    int64_t _792 = 0;
    _792 *= _791.d0;
    _792 += _366.d1;
    bool _793 = _791.data[_792];
    _772 = _793;
    _jump1423:;
    bool _771 = _772;
    if (0 == _772)
    goto _jump1431;
    bool _794 = false;
    bool _795 = !_794;
    _771 = _795;
    _jump1431:;
    _a3_int64_t _796;
    if (!_771)
    goto _jump1432;
    _a3_int64_t _797;
    // Computing bound for x
    _797.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing bound for y
    _797.d1 = _518.d2;
    if (_518.d2 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing bound for z
    _797.d2 = _366.d0;
    if (_366.d0 > 0) 
    goto _jump1435;
    fail_assertion("non-positive loop bound");
    _jump1435:;
    // Computing total size of heap memory to allocate
    int64_t _798 = 1;
    _798 *= _284.d2;
    _798 *= _518.d2;
    _798 *= _366.d0;
    _798 *= sizeof(int64_t);
    _797.data = jpl_alloc(_798);
    int64_t _799 = 0; // z
    int64_t _800 = 0; // y
    int64_t _801 = 0; // x
    _jump1436:; // Begin body of loop
    int64_t _802 = 0;
    _802 *= _797.d0;
    _802 += _801;
    _802 *= _797.d1;
    _802 += _800;
    _802 *= _797.d2;
    _802 += _799;
    _797.data[_802] = _799;
    _799++;
    if (_799 < _366.d0)
    goto _jump1436;
    _799 = 0;
    _800++;
    if (_800 < _518.d2)
    goto _jump1436;
    _800 = 0;
    _801++;
    if (_801 < _284.d2)
    goto _jump1436;
    // End body of loop
    _a1__a3_int64_t _803;
    _803.d0 = 2;
    _803.data = jpl_alloc(sizeof(_a3_int64_t) * 2);
    _803.data[0] = _284;
    _803.data[1] = _797;
    bool _804 = _284.d0 <= _284.d0;
    double _805 = 56.0;
    double _806;
    // Computing bound for x
    if (_518.d0 > 0) 
    goto _jump1437;
    fail_assertion("non-positive loop bound");
    _jump1437:;
    // Computing bound for y
    if (_518.d0 > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    // Computing bound for z
    int64_t _807 = 756;
    if (_807 > 0) 
    goto _jump1439;
    fail_assertion("non-positive loop bound");
    _jump1439:;
    _806 = 0;
    int64_t _808 = 0; // z
    int64_t _809 = 0; // y
    int64_t _810 = 0; // x
    _jump1440:; // Begin body of loop
    double _811 = 94.0;
    _806 += _811;
    _808++;
    if (_808 < _807)
    goto _jump1440;
    _808 = 0;
    _809++;
    if (_809 < _518.d0)
    goto _jump1440;
    _809 = 0;
    _810++;
    if (_810 < _518.d0)
    goto _jump1440;
    // End body of loop
    double _812 = _805 * _806;
    h _813 = { _812 };
    bool _814 = true;
    bool _815 = !_814;
    bool _816 = !_815;
    int64_t _817;
    if (!_816)
    goto _jump1441;
    if (_284.d0 >= 0)
    goto _jump1442;
    fail_assertion("negative array index");
    _jump1442:;
    if (_284.d0 < _289.d0)
    goto _jump1443;
    fail_assertion("index too large");
    _jump1443:;
    int64_t _818 = 0;
    _818 *= _289.d0;
    _818 += _284.d0;
    int64_t _819 = _289.data[_818];
    _817 = _819;
    goto _jump1444;
    _jump1441:;
    int64_t _820;
    // Computing bound for x
    if (_341.d0 > 0) 
    goto _jump1445;
    fail_assertion("non-positive loop bound");
    _jump1445:;
    // Computing bound for y
    int64_t _821 = 543;
    if (_821 > 0) 
    goto _jump1446;
    fail_assertion("non-positive loop bound");
    _jump1446:;
    // Computing bound for z
    if (_518.d1 > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    _820 = 0;
    int64_t _822 = 0; // z
    int64_t _823 = 0; // y
    int64_t _824 = 0; // x
    _jump1448:; // Begin body of loop
    _820 += _822;
    _822++;
    if (_822 < _518.d1)
    goto _jump1448;
    _822 = 0;
    _823++;
    if (_823 < _821)
    goto _jump1448;
    _823 = 0;
    _824++;
    if (_824 < _341.d0)
    goto _jump1448;
    // End body of loop
    _817 = _820;
    _jump1444:;
    i _825 = { _804, _813, _817 };
    int64_t _826 = _825.c;
    if (_826 >= 0)
    goto _jump1449;
    fail_assertion("negative array index");
    _jump1449:;
    if (_826 < _803.d0)
    goto _jump1450;
    fail_assertion("index too large");
    _jump1450:;
    int64_t _827 = 0;
    _827 *= _803.d0;
    _827 += _826;
    _a3_int64_t _828 = _803.data[_827];
    _796 = _828;
    goto _jump1451;
    _jump1432:;
    _796 = _284;
    _jump1451:;
    _a2_rgba _829 = read_image("B.png");
    _a2_bool _830;
    // Computing bound for D
    _830.d0 = _341.d0;
    if (_341.d0 > 0) 
    goto _jump1651;
    fail_assertion("non-positive loop bound");
    _jump1651:;
    // Computing bound for E
    _830.d1 = _796.d0;
    if (_796.d0 > 0) 
    goto _jump1652;
    fail_assertion("non-positive loop bound");
    _jump1652:;
    // Computing total size of heap memory to allocate
    int64_t _831 = 1;
    _831 *= _341.d0;
    _831 *= _796.d0;
    _831 *= sizeof(bool);
    _830.data = jpl_alloc(_831);
    int64_t _832 = 0; // E
    int64_t _833 = 0; // D
    _jump1653:; // Begin body of loop
    bool _834 = true;
    int64_t _835 = 0;
    _835 *= _830.d0;
    _835 += _833;
    _835 *= _830.d1;
    _835 += _832;
    _830.data[_835] = _834;
    _832++;
    if (_832 < _796.d0)
    goto _jump1653;
    _832 = 0;
    _833++;
    if (_833 < _341.d0)
    goto _jump1653;
    // End body of loop
    if (_341.d0 >= 0)
    goto _jump1654;
    fail_assertion("negative array index");
    _jump1654:;
    if (_341.d0 < _830.d0)
    goto _jump1655;
    fail_assertion("index too large");
    _jump1655:;
    if (_284.d2 >= 0)
    goto _jump1656;
    fail_assertion("negative array index");
    _jump1656:;
    if (_284.d2 < _830.d1)
    goto _jump1657;
    fail_assertion("index too large");
    _jump1657:;
    int64_t _836 = 0;
    _836 *= _830.d0;
    _836 += _341.d0;
    _836 *= _830.d1;
    _836 += _284.d2;
    bool _837 = _830.data[_836];
    bool _838 = !_837;
    bool _839;
    if (!_838)
    goto _jump1658;
    bool _840 = true;
    _839 = _840;
    goto _jump1659;
    _jump1658:;
    _a2_bool _841;
    // Computing bound for D
    _841.d0 = _796.d0;
    if (_796.d0 > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing bound for E
    int64_t _842;
    // Computing bound for D
    if (_796.d2 > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing bound for E
    if (_284.d2 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    _842 = 0;
    int64_t _843 = 0; // E
    int64_t _844 = 0; // D
    _jump1663:; // Begin body of loop
    _842 += _341.d0;
    _843++;
    if (_843 < _284.d2)
    goto _jump1663;
    _843 = 0;
    _844++;
    if (_844 < _796.d2)
    goto _jump1663;
    // End body of loop
    _841.d1 = _842;
    if (_842 > 0) 
    goto _jump1664;
    fail_assertion("non-positive loop bound");
    _jump1664:;
    // Computing total size of heap memory to allocate
    int64_t _845 = 1;
    _845 *= _796.d0;
    _845 *= _842;
    _845 *= sizeof(bool);
    _841.data = jpl_alloc(_845);
    int64_t _846 = 0; // E
    int64_t _847 = 0; // D
    _jump1665:; // Begin body of loop
    bool _848 = _284.d0 == _796.d0;
    int64_t _849 = 0;
    _849 *= _841.d0;
    _849 += _847;
    _849 *= _841.d1;
    _849 += _846;
    _841.data[_849] = _848;
    _846++;
    if (_846 < _842)
    goto _jump1665;
    _846 = 0;
    _847++;
    if (_847 < _796.d0)
    goto _jump1665;
    // End body of loop
    if (_518.d2 >= 0)
    goto _jump1666;
    fail_assertion("negative array index");
    _jump1666:;
    if (_518.d2 < _841.d0)
    goto _jump1667;
    fail_assertion("index too large");
    _jump1667:;
    if (_284.d0 >= 0)
    goto _jump1668;
    fail_assertion("negative array index");
    _jump1668:;
    if (_284.d0 < _841.d1)
    goto _jump1669;
    fail_assertion("index too large");
    _jump1669:;
    int64_t _850 = 0;
    _850 *= _841.d0;
    _850 += _518.d2;
    _850 *= _841.d1;
    _850 += _284.d0;
    bool _851 = _841.data[_850];
    _839 = _851;
    _jump1659:;
    _a2_rgba _852;
    if (!_839)
    goto _jump1670;
    _a2_rgba _853;
    // Computing bound for D
    _853.d0 = _284.d2;
    if (_284.d2 > 0) 
    goto _jump1671;
    fail_assertion("non-positive loop bound");
    _jump1671:;
    // Computing bound for E
    _853.d1 = _796.d2;
    if (_796.d2 > 0) 
    goto _jump1672;
    fail_assertion("non-positive loop bound");
    _jump1672:;
    // Computing total size of heap memory to allocate
    int64_t _854 = 1;
    _854 *= _284.d2;
    _854 *= _796.d2;
    _854 *= sizeof(rgba);
    _853.data = jpl_alloc(_854);
    int64_t _855 = 0; // E
    int64_t _856 = 0; // D
    _jump1673:; // Begin body of loop
    bool _857 = true;
    o _858 = { _857 };
    if (_518.d1 >= 0)
    goto _jump1674;
    fail_assertion("negative array index");
    _jump1674:;
    if (_518.d1 < _770.d0)
    goto _jump1675;
    fail_assertion("index too large");
    _jump1675:;
    int64_t _859 = 0;
    _859 *= _770.d0;
    _859 += _518.d1;
    rgba _860 = _770.data[_859];
    rgba _861 = p(_858, _856, _860);
    int64_t _862 = 0;
    _862 *= _853.d0;
    _862 += _856;
    _862 *= _853.d1;
    _862 += _855;
    _853.data[_862] = _861;
    _855++;
    if (_855 < _796.d2)
    goto _jump1673;
    _855 = 0;
    _856++;
    if (_856 < _284.d2)
    goto _jump1673;
    // End body of loop
    _852 = _853;
    goto _jump1676;
    _jump1670:;
    bool _863 = false;
    _a1__a2_rgba _864;
    if (!_863)
    goto _jump1677;
    _a1__a2_rgba _865;
    _865.d0 = 3;
    _865.data = jpl_alloc(sizeof(_a2_rgba) * 3);
    _865.data[0] = _829;
    _865.data[1] = _829;
    _865.data[2] = _829;
    _864 = _865;
    goto _jump1678;
    _jump1677:;
    _a1__a2_rgba _866;
    // Computing bound for D
    _866.d0 = _770.d0;
    if (_770.d0 > 0) 
    goto _jump1679;
    fail_assertion("non-positive loop bound");
    _jump1679:;
    // Computing total size of heap memory to allocate
    int64_t _867 = 1;
    _867 *= _770.d0;
    _867 *= sizeof(_a2_rgba);
    _866.data = jpl_alloc(_867);
    int64_t _868 = 0; // D
    _jump1680:; // Begin body of loop
    int64_t _869 = 0;
    _869 *= _866.d0;
    _869 += _868;
    _866.data[_869] = _829;
    _868++;
    if (_868 < _770.d0)
    goto _jump1680;
    // End body of loop
    _864 = _866;
    _jump1678:;
    bool _870 = _518.d1 == _770.d0;
    _a3_int64_t _871;
    if (!_870)
    goto _jump1681;
    _871 = _518;
    goto _jump1682;
    _jump1681:;
    _871 = _796;
    _jump1682:;
    _a1_int64_t _872;
    _872.d0 = 2;
    _872.data = jpl_alloc(sizeof(int64_t) * 2);
    _872.data[0] = _796.d2;
    _872.data[1] = _518.d1;
    int64_t _873 = _770.d0 - _796.d1;
    if (_873 >= 0)
    goto _jump1683;
    fail_assertion("negative array index");
    _jump1683:;
    if (_873 < _872.d0)
    goto _jump1684;
    fail_assertion("index too large");
    _jump1684:;
    int64_t _874 = 0;
    _874 *= _872.d0;
    _874 += _873;
    int64_t _875 = _872.data[_874];
    if (_284.d2 >= 0)
    goto _jump1685;
    fail_assertion("negative array index");
    _jump1685:;
    if (_284.d2 < _871.d0)
    goto _jump1686;
    fail_assertion("index too large");
    _jump1686:;
    if (_875 >= 0)
    goto _jump1687;
    fail_assertion("negative array index");
    _jump1687:;
    if (_875 < _871.d1)
    goto _jump1688;
    fail_assertion("index too large");
    _jump1688:;
    if (_796.d0 >= 0)
    goto _jump1689;
    fail_assertion("negative array index");
    _jump1689:;
    if (_796.d0 < _871.d2)
    goto _jump1690;
    fail_assertion("index too large");
    _jump1690:;
    int64_t _876 = 0;
    _876 *= _871.d0;
    _876 += _284.d2;
    _876 *= _871.d1;
    _876 += _875;
    _876 *= _871.d2;
    _876 += _796.d0;
    int64_t _877 = _871.data[_876];
    if (_877 >= 0)
    goto _jump1691;
    fail_assertion("negative array index");
    _jump1691:;
    if (_877 < _864.d0)
    goto _jump1692;
    fail_assertion("index too large");
    _jump1692:;
    int64_t _878 = 0;
    _878 *= _864.d0;
    _878 += _877;
    _a2_rgba _879 = _864.data[_878];
    _852 = _879;
    _jump1676:;
    _a1__a2_rgba _880;
    _880.d0 = 1;
    _880.data = jpl_alloc(sizeof(_a2_rgba) * 1);
    _880.data[0] = _852;
    int64_t _881 = _518.d0 * _518.d1;
    if (_881 >= 0)
    goto _jump1693;
    fail_assertion("negative array index");
    _jump1693:;
    if (_881 < _880.d0)
    goto _jump1694;
    fail_assertion("index too large");
    _jump1694:;
    int64_t _882 = 0;
    _882 *= _880.d0;
    _882 += _881;
    _a2_rgba _883 = _880.data[_882];
    write_image(_883, "D.png");
    int64_t _884;
    // Computing bound for D
    if (_796.d1 > 0) 
    goto _jump1695;
    fail_assertion("non-positive loop bound");
    _jump1695:;
    // Computing bound for E
    bool _887 = false;
    bool _886 = _887;
    if (0 != _887)
    goto _jump1696;
    bool _888 = _284.d0 == _796.d0;
    _886 = _888;
    _jump1696:;
    bool _890 = false;
    bool _889 = _890;
    if (0 != _890)
    goto _jump1697;
    bool _891 = false;
    _889 = _891;
    _jump1697:;
    bool _892 = _886 != _889;
    bool _885 = _892;
    if (0 != _892)
    goto _jump1698;
    bool _893 = _284.d2 < _284.d2;
    bool _894;
    if (!_893)
    goto _jump1699;
    bool _895 = false;
    _894 = _895;
    goto _jump1700;
    _jump1699:;
    bool _896 = false;
    o _897 = { _896 };
    bool _898 = _897.a;
    _894 = _898;
    _jump1700:;
    _885 = _894;
    _jump1698:;
    _a2_int64_t _899;
    if (!_885)
    goto _jump1701;
    _a2__a2_int64_t _900;
    // Computing bound for D
    _900.d0 = _518.d0;
    if (_518.d0 > 0) 
    goto _jump1702;
    fail_assertion("non-positive loop bound");
    _jump1702:;
    // Computing bound for E
    _900.d1 = _796.d2;
    if (_796.d2 > 0) 
    goto _jump1703;
    fail_assertion("non-positive loop bound");
    _jump1703:;
    // Computing total size of heap memory to allocate
    int64_t _901 = 1;
    _901 *= _518.d0;
    _901 *= _796.d2;
    _901 *= sizeof(_a2_int64_t);
    _900.data = jpl_alloc(_901);
    int64_t _902 = 0; // E
    int64_t _903 = 0; // D
    _jump1704:; // Begin body of loop
    int64_t _904 = 0;
    _904 *= _900.d0;
    _904 += _903;
    _904 *= _900.d1;
    _904 += _902;
    _900.data[_904] = _366;
    _902++;
    if (_902 < _796.d2)
    goto _jump1704;
    _902 = 0;
    _903++;
    if (_903 < _518.d0)
    goto _jump1704;
    // End body of loop
    _a1__a2__a2_int64_t _905;
    _905.d0 = 1;
    _905.data = jpl_alloc(sizeof(_a2__a2_int64_t) * 1);
    _905.data[0] = _900;
    if (_518.d0 >= 0)
    goto _jump1705;
    fail_assertion("negative array index");
    _jump1705:;
    if (_518.d0 < _905.d0)
    goto _jump1706;
    fail_assertion("index too large");
    _jump1706:;
    int64_t _906 = 0;
    _906 *= _905.d0;
    _906 += _518.d0;
    _a2__a2_int64_t _907 = _905.data[_906];
    bool _908 = _284.d1 <= _366.d1;
    int64_t _909;
    if (!_908)
    goto _jump1707;
    _909 = _284.d2;
    goto _jump1708;
    _jump1707:;
    _909 = _284.d2;
    _jump1708:;
    if (_909 >= 0)
    goto _jump1709;
    fail_assertion("negative array index");
    _jump1709:;
    if (_909 < _907.d0)
    goto _jump1710;
    fail_assertion("index too large");
    _jump1710:;
    if (_518.d0 >= 0)
    goto _jump1711;
    fail_assertion("negative array index");
    _jump1711:;
    if (_518.d0 < _907.d1)
    goto _jump1712;
    fail_assertion("index too large");
    _jump1712:;
    int64_t _910 = 0;
    _910 *= _907.d0;
    _910 += _909;
    _910 *= _907.d1;
    _910 += _518.d0;
    _a2_int64_t _911 = _907.data[_910];
    _899 = _911;
    goto _jump1713;
    _jump1701:;
    _a2_int64_t _912;
    // Computing bound for D
    _912.d0 = _284.d1;
    if (_284.d1 > 0) 
    goto _jump1714;
    fail_assertion("non-positive loop bound");
    _jump1714:;
    // Computing bound for E
    int64_t _913;
    // Computing bound for D
    int64_t _914;
    // Computing bound for D
    if (_796.d0 > 0) 
    goto _jump1715;
    fail_assertion("non-positive loop bound");
    _jump1715:;
    // Computing bound for E
    if (_284.d0 > 0) 
    goto _jump1716;
    fail_assertion("non-positive loop bound");
    _jump1716:;
    // Computing bound for F
    int64_t _915;
    // Computing bound for D
    if (_518.d2 > 0) 
    goto _jump1717;
    fail_assertion("non-positive loop bound");
    _jump1717:;
    _915 = 0;
    int64_t _916 = 0; // D
    _jump1718:; // Begin body of loop
    _915 += _518.d2;
    _916++;
    if (_916 < _518.d2)
    goto _jump1718;
    // End body of loop
    if (_915 > 0) 
    goto _jump1719;
    fail_assertion("non-positive loop bound");
    _jump1719:;
    _914 = 0;
    int64_t _917 = 0; // F
    int64_t _918 = 0; // E
    int64_t _919 = 0; // D
    _jump1720:; // Begin body of loop
    _914 += _796.d0;
    _917++;
    if (_917 < _915)
    goto _jump1720;
    _917 = 0;
    _918++;
    if (_918 < _284.d0)
    goto _jump1720;
    _918 = 0;
    _919++;
    if (_919 < _796.d0)
    goto _jump1720;
    // End body of loop
    if (_914 > 0) 
    goto _jump1721;
    fail_assertion("non-positive loop bound");
    _jump1721:;
    _913 = 0;
    int64_t _920 = 0; // D
    _jump1722:; // Begin body of loop
    _913 += _518.d1;
    _920++;
    if (_920 < _914)
    goto _jump1722;
    // End body of loop
    _912.d1 = _913;
    if (_913 > 0) 
    goto _jump1723;
    fail_assertion("non-positive loop bound");
    _jump1723:;
    // Computing total size of heap memory to allocate
    int64_t _921 = 1;
    _921 *= _284.d1;
    _921 *= _913;
    _921 *= sizeof(int64_t);
    _912.data = jpl_alloc(_921);
    int64_t _922 = 0; // E
    int64_t _923 = 0; // D
    _jump1724:; // Begin body of loop
    int64_t _924 = 0;
    _924 *= _912.d0;
    _924 += _923;
    _924 *= _912.d1;
    _924 += _922;
    _912.data[_924] = _366.d0;
    _922++;
    if (_922 < _913)
    goto _jump1724;
    _922 = 0;
    _923++;
    if (_923 < _284.d1)
    goto _jump1724;
    // End body of loop
    _899 = _912;
    _jump1713:;
    if (_770.d0 >= 0)
    goto _jump1725;
    fail_assertion("negative array index");
    _jump1725:;
    if (_770.d0 < _899.d0)
    goto _jump1726;
    fail_assertion("index too large");
    _jump1726:;
    if (_518.d2 >= 0)
    goto _jump1727;
    fail_assertion("negative array index");
    _jump1727:;
    if (_518.d2 < _899.d1)
    goto _jump1728;
    fail_assertion("index too large");
    _jump1728:;
    int64_t _925 = 0;
    _925 *= _899.d0;
    _925 += _770.d0;
    _925 *= _899.d1;
    _925 += _518.d2;
    int64_t _926 = _899.data[_925];
    if (_926 > 0) 
    goto _jump1729;
    fail_assertion("non-positive loop bound");
    _jump1729:;
    _884 = 0;
    int64_t _927 = 0; // E
    int64_t _928 = 0; // D
    _jump1730:; // Begin body of loop
    _884 += _284.d2;
    _927++;
    if (_927 < _926)
    goto _jump1730;
    _927 = 0;
    _928++;
    if (_928 < _796.d1)
    goto _jump1730;
    // End body of loop
    write_image(_829, "E.png");
    print("F");
}

