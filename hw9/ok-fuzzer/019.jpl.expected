
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
    double a;
    int64_t b;
} a;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_int64_t *data;
} _a3__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  a *data;
} _a1_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_int64_t *data;
} _a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2__a1_int64_t *data;
} _a3__a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2__a2__a1_int64_t *data;
} _a1__a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2__a2__a1_int64_t *data;
} _a3__a3__a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  a *data;
} _a3_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
    rgba a;
    bool b;
    _a1_double c;
} s;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_double *data;
} _a2__a1_double;

typedef struct {
  int64_t d0;
  s *data;
} _a1_s;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_s *data;
} _a3__a1_s;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_s *data;
} _a3__a3__a1_s;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a1_s *data;
} _a2__a3__a1_s;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3__a1_s *data;
} _a2__a2__a3__a1_s;

typedef struct {
  int64_t d0;
  int64_t d1;
  s *data;
} _a2_s;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3__a3_int64_t *data;
} _a1__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

int64_t v() {
    bool _0 = false;
    bool _1 = !_0;
    if (0 != _1)
    goto _jump825;
    fail_assertion("w");
    _jump825:;
    return d;
    if (0 != e)
    goto _jump826;
    fail_assertion("z");
    _jump826:;
    if (r >= 0)
    goto _jump827;
    fail_assertion("negative array index");
    _jump827:;
    if (r < m.d0)
    goto _jump828;
    fail_assertion("index too large");
    _jump828:;
    if (l >= 0)
    goto _jump829;
    fail_assertion("negative array index");
    _jump829:;
    if (l < m.d1)
    goto _jump830;
    fail_assertion("index too large");
    _jump830:;
    if (p >= 0)
    goto _jump831;
    fail_assertion("negative array index");
    _jump831:;
    if (p < m.d2)
    goto _jump832;
    fail_assertion("index too large");
    _jump832:;
    int64_t _2 = 0;
    _2 *= m.d0;
    _2 += r;
    _2 *= m.d1;
    _2 += l;
    _2 *= m.d2;
    _2 += p;
    int64_t _3 = m.data[_2];
    return _3;
}

double z(_a3_void_t A) {
    _a2__a2_rgba _0;
    // Computing bound for E
    _0.d0 = y;
    if (y > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing bound for F
    _0.d1 = g;
    if (g > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= y;
    _1 *= g;
    _1 *= sizeof(_a2_rgba);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // F
    int64_t _3 = 0; // E
    _jump837:; // Begin body of loop
    int64_t _4 = 0;
    _4 *= _0.d0;
    _4 += _3;
    _4 *= _0.d1;
    _4 += _2;
    _0.data[_4] = t;
    _2++;
    if (_2 < g)
    goto _jump837;
    _2 = 0;
    _3++;
    if (_3 < y)
    goto _jump837;
    // End body of loop
    bool _5 = e;
    if (0 == e)
    goto _jump838;
    int64_t _6 = 829;
    bool _7 = y == _6;
    _5 = _7;
    _jump838:;
    bool _8 = true;
    s _9;
    if (!_8)
    goto _jump839;
    if (o >= 0)
    goto _jump840;
    fail_assertion("negative array index");
    _jump840:;
    if (o < u.d0)
    goto _jump841;
    fail_assertion("index too large");
    _jump841:;
    if (l >= 0)
    goto _jump842;
    fail_assertion("negative array index");
    _jump842:;
    if (l < u.d1)
    goto _jump843;
    fail_assertion("index too large");
    _jump843:;
    int64_t _10 = 0;
    _10 *= u.d0;
    _10 += o;
    _10 *= u.d1;
    _10 += l;
    rgba _11 = u.data[_10];
    _a1_double _12;
    // Computing bound for M
    _12.d0 = l;
    if (l > 0) 
    goto _jump844;
    fail_assertion("non-positive loop bound");
    _jump844:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= l;
    _13 *= sizeof(double);
    _12.data = jpl_alloc(_13);
    int64_t _14 = 0; // M
    _jump845:; // Begin body of loop
    int64_t _15 = 0;
    _15 *= _12.d0;
    _15 += _14;
    _12.data[_15] = i;
    _14++;
    if (_14 < l)
    goto _jump845;
    // End body of loop
    s _16 = { _11, j, _12 };
    rgba _17 = _16.a;
    bool _18 = A.d0 < x;
    double _19;
    if (!_18)
    goto _jump846;
    _19 = i;
    goto _jump847;
    _jump846:;
    double _20 = 31.0;
    _19 = _20;
    _jump847:;
    double _21;
    // Computing bound for M
    if (m.d1 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    _21 = 0;
    int64_t _22 = 0; // M
    _jump849:; // Begin body of loop
    double _23 = 7.0;
    _21 += _23;
    _22++;
    if (_22 < m.d1)
    goto _jump849;
    // End body of loop
    double _24 = -_21;
    bool _25 = _19 == _24;
    _a2_double _26;
    // Computing bound for M
    _26.d0 = m.d1;
    if (m.d1 > 0) 
    goto _jump850;
    fail_assertion("non-positive loop bound");
    _jump850:;
    // Computing bound for N
    _26.d1 = r;
    if (r > 0) 
    goto _jump851;
    fail_assertion("non-positive loop bound");
    _jump851:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= m.d1;
    _27 *= r;
    _27 *= sizeof(double);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // N
    int64_t _29 = 0; // M
    _jump852:; // Begin body of loop
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += _29;
    _30 *= _26.d1;
    _30 += _28;
    _26.data[_30] = i;
    _28++;
    if (_28 < r)
    goto _jump852;
    _28 = 0;
    _29++;
    if (_29 < m.d1)
    goto _jump852;
    // End body of loop
    int64_t _31 = -o;
    if (_31 >= 0)
    goto _jump853;
    fail_assertion("negative array index");
    _jump853:;
    if (_31 < _26.d0)
    goto _jump854;
    fail_assertion("index too large");
    _jump854:;
    if (o >= 0)
    goto _jump855;
    fail_assertion("negative array index");
    _jump855:;
    if (o < _26.d1)
    goto _jump856;
    fail_assertion("index too large");
    _jump856:;
    int64_t _32 = 0;
    _32 *= _26.d0;
    _32 += _31;
    _32 *= _26.d1;
    _32 += o;
    double _33 = _26.data[_32];
    _a1_double _34;
    _34.d0 = 2;
    _34.data = jpl_alloc(sizeof(double) * 2);
    _34.data[0] = _33;
    _34.data[1] = i;
    s _35 = { _17, _25, _34 };
    _9 = _35;
    goto _jump857;
    _jump839:;
    bool _36 = true;
    _a3_void_t _37;
    if (!_36)
    goto _jump858;
    _37 = A;
    goto _jump859;
    _jump858:;
    _37 = A;
    _jump859:;
    double _38 = z(_37);
    bool _39 = true;
    double _40;
    if (!_39)
    goto _jump860;
    double _41 = z(A);
    _40 = _41;
    goto _jump861;
    _jump860:;
    _40 = i;
    _jump861:;
    bool _42 = false;
    double _43;
    if (!_42)
    goto _jump862;
    double _44 = 2.0;
    _43 = _44;
    goto _jump863;
    _jump862:;
    _43 = i;
    _jump863:;
    double _45 = -_43;
    rgba _46 = { _38, i, _40, _45 };
    _a2__a1_double _47;
    // Computing bound for M
    if (A.d1 >= 0)
    goto _jump864;
    fail_assertion("negative array index");
    _jump864:;
    if (A.d1 < w.d0)
    goto _jump865;
    fail_assertion("index too large");
    _jump865:;
    int64_t _48 = 0;
    _48 *= w.d0;
    _48 += A.d1;
    int64_t _49 = w.data[_48];
    _47.d0 = _49;
    if (_49 > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    // Computing bound for N
    _47.d1 = p;
    if (p > 0) 
    goto _jump867;
    fail_assertion("non-positive loop bound");
    _jump867:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _49;
    _50 *= p;
    _50 *= sizeof(_a1_double);
    _47.data = jpl_alloc(_50);
    int64_t _51 = 0; // N
    int64_t _52 = 0; // M
    _jump868:; // Begin body of loop
    _a1_double _53;
    // Computing bound for O
    _53.d0 = h;
    if (h > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= h;
    _54 *= sizeof(double);
    _53.data = jpl_alloc(_54);
    int64_t _55 = 0; // O
    _jump870:; // Begin body of loop
    int64_t _56 = 0;
    _56 *= _53.d0;
    _56 += _55;
    _53.data[_56] = i;
    _55++;
    if (_55 < h)
    goto _jump870;
    // End body of loop
    int64_t _57 = 0;
    _57 *= _47.d0;
    _57 += _52;
    _57 *= _47.d1;
    _57 += _51;
    _47.data[_57] = _53;
    _51++;
    if (_51 < p)
    goto _jump868;
    _51 = 0;
    _52++;
    if (_52 < _49)
    goto _jump868;
    // End body of loop
    int64_t _58 = v();
    if (_58 >= 0)
    goto _jump871;
    fail_assertion("negative array index");
    _jump871:;
    if (_58 < _47.d0)
    goto _jump872;
    fail_assertion("index too large");
    _jump872:;
    if (A.d0 >= 0)
    goto _jump873;
    fail_assertion("negative array index");
    _jump873:;
    if (A.d0 < _47.d1)
    goto _jump874;
    fail_assertion("index too large");
    _jump874:;
    int64_t _59 = 0;
    _59 *= _47.d0;
    _59 += _58;
    _59 *= _47.d1;
    _59 += A.d0;
    _a1_double _60 = _47.data[_59];
    s _61 = { _46, _5, _60 };
    _9 = _61;
    _jump857:;
    rgba _62 = _9.a;
    double _63 = _62.a;
    _a2_int64_t _64;
    // Computing bound for N
    _64.d0 = m.d2;
    if (m.d2 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for O
    _64.d1 = m.d1;
    if (m.d1 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= m.d2;
    _65 *= m.d1;
    _65 *= sizeof(int64_t);
    _64.data = jpl_alloc(_65);
    int64_t _66 = 0; // O
    int64_t _67 = 0; // N
    _jump877:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _64.d0;
    _68 += _67;
    _68 *= _64.d1;
    _68 += _66;
    _64.data[_68] = h;
    _66++;
    if (_66 < m.d1)
    goto _jump877;
    _66 = 0;
    _67++;
    if (_67 < m.d2)
    goto _jump877;
    // End body of loop
    double _69 = 60.0;
    return _69;
}

rgba B(_a3__a1_s C, bool G, rgba H) {
    double _0;
    // Computing bound for N
    int64_t _1 = v();
    if (_1 > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing bound for O
    if (y > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    _0 = 0;
    int64_t _2 = 0; // O
    int64_t _3 = 0; // N
    _jump880:; // Begin body of loop
    _a1_double _4;
    // Computing bound for P
    _4.d0 = n;
    if (n > 0) 
    goto _jump881;
    fail_assertion("non-positive loop bound");
    _jump881:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= n;
    _5 *= sizeof(double);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // P
    _jump882:; // Begin body of loop
    int64_t _7 = 0;
    _7 *= _4.d0;
    _7 += _6;
    _4.data[_7] = i;
    _6++;
    if (_6 < n)
    goto _jump882;
    // End body of loop
    s _8 = { H, e, _4 };
    bool _9 = _8.b;
    a _10;
    if (!_9)
    goto _jump883;
    _a1_a _11;
    // Computing bound for P
    _11.d0 = A;
    if (A > 0) 
    goto _jump884;
    fail_assertion("non-positive loop bound");
    _jump884:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= A;
    _12 *= sizeof(a);
    _11.data = jpl_alloc(_12);
    int64_t _13 = 0; // P
    _jump885:; // Begin body of loop
    double _14 = 45.0;
    a _15 = { _14, C.d1 };
    int64_t _16 = 0;
    _16 *= _11.d0;
    _16 += _13;
    _11.data[_16] = _15;
    _13++;
    if (_13 < A)
    goto _jump885;
    // End body of loop
    if (_2 >= 0)
    goto _jump886;
    fail_assertion("negative array index");
    _jump886:;
    if (_2 < _11.d0)
    goto _jump887;
    fail_assertion("index too large");
    _jump887:;
    int64_t _17 = 0;
    _17 *= _11.d0;
    _17 += _2;
    a _18 = _11.data[_17];
    _10 = _18;
    goto _jump888;
    _jump883:;
    _a1_bool _19;
    // Computing bound for P
    _19.d0 = C.d2;
    if (C.d2 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= C.d2;
    _20 *= sizeof(bool);
    _19.data = jpl_alloc(_20);
    int64_t _21 = 0; // P
    _jump890:; // Begin body of loop
    bool _22 = true;
    int64_t _23 = 0;
    _23 *= _19.d0;
    _23 += _21;
    _19.data[_23] = _22;
    _21++;
    if (_21 < C.d2)
    goto _jump890;
    // End body of loop
    int64_t _24 = C.d1 - _2;
    if (_24 >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (_24 < _19.d0)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    int64_t _25 = 0;
    _25 *= _19.d0;
    _25 += _24;
    bool _26 = _19.data[_25];
    a _27;
    if (!_26)
    goto _jump893;
    int64_t _28 = 698;
    a _29 = { i, _28 };
    _27 = _29;
    goto _jump894;
    _jump893:;
    bool _30 = true;
    double _31;
    if (!_30)
    goto _jump895;
    double _32 = 92.0;
    _31 = _32;
    goto _jump896;
    _jump895:;
    double _33 = 3.0;
    _31 = _33;
    _jump896:;
    a _34 = { _31, C.d2 };
    _27 = _34;
    _jump894:;
    _10 = _27;
    _jump888:;
    double _35 = _10.a;
    _0 += _35;
    _2++;
    if (_2 < y)
    goto _jump880;
    _2 = 0;
    _3++;
    if (_3 < _1)
    goto _jump880;
    // End body of loop
    int64_t _36;
    if (!j)
    goto _jump897;
    _36 = y;
    goto _jump898;
    _jump897:;
    _36 = q.d0;
    _jump898:;
    int64_t _37 = q.d0 / _36;
    bool _38 = c < _37;
    double _39;
    if (!_38)
    goto _jump899;
    double _40;
    // Computing bound for N
    if (n > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    _40 = 0;
    int64_t _41 = 0; // N
    _jump901:; // Begin body of loop
    double _42 = 90.0;
    double _43 = -_42;
    a _44 = { _43, y };
    double _45 = _44.a;
    _40 += _45;
    _41++;
    if (_41 < n)
    goto _jump901;
    // End body of loop
    _39 = _40;
    goto _jump902;
    _jump899:;
    bool _46 = false;
    double _47;
    if (!_46)
    goto _jump903;
    double _48 = 77.0;
    _47 = _48;
    goto _jump904;
    _jump903:;
    _a1_a _49;
    // Computing bound for N
    _49.d0 = C.d2;
    if (C.d2 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= C.d2;
    _50 *= sizeof(a);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // N
    _jump906:; // Begin body of loop
    double _52 = 13.0;
    a _53 = { _52, C.d2 };
    int64_t _54 = 0;
    _54 *= _49.d0;
    _54 += _51;
    _49.data[_54] = _53;
    _51++;
    if (_51 < C.d2)
    goto _jump906;
    // End body of loop
    int64_t _55 = v();
    if (_55 >= 0)
    goto _jump907;
    fail_assertion("negative array index");
    _jump907:;
    if (_55 < _49.d0)
    goto _jump908;
    fail_assertion("index too large");
    _jump908:;
    int64_t _56 = 0;
    _56 *= _49.d0;
    _56 += _55;
    a _57 = _49.data[_56];
    double _58 = _57.a;
    _47 = _58;
    _jump904:;
    _39 = _47;
    _jump902:;
    bool _59 = true;
    bool _60;
    if (!_59)
    goto _jump909;
    bool _61 = G;
    if (0 != G)
    goto _jump910;
    _61 = j;
    _jump910:;
    bool _62 = !_61;
    _60 = _62;
    goto _jump911;
    _jump909:;
    bool _63 = j;
    if (0 == j)
    goto _jump912;
    bool _64;
    if (!j)
    goto _jump913;
    bool _65 = j;
    if (0 == j)
    goto _jump914;
    _65 = G;
    _jump914:;
    _64 = _65;
    goto _jump915;
    _jump913:;
    bool _67 = true;
    bool _66 = _67;
    if (0 == _67)
    goto _jump916;
    bool _68 = true;
    _66 = _68;
    _jump916:;
    _64 = _66;
    _jump915:;
    _63 = _64;
    _jump912:;
    _60 = _63;
    _jump911:;
    a _69;
    if (!_60)
    goto _jump917;
    bool _71 = true;
    bool _70 = _71;
    if (0 != _71)
    goto _jump918;
    bool _72 = false;
    _70 = _72;
    _jump918:;
    a _73;
    if (!_70)
    goto _jump919;
    bool _74 = false;
    a _75;
    if (!_74)
    goto _jump920;
    double _76 = 64.0;
    a _77 = { _76, g };
    _75 = _77;
    goto _jump921;
    _jump920:;
    int64_t _78;
    if (!G)
    goto _jump922;
    _78 = p;
    goto _jump923;
    _jump922:;
    _78 = x;
    _jump923:;
    a _79 = { i, _78 };
    _75 = _79;
    _jump921:;
    _73 = _75;
    goto _jump924;
    _jump919:;
    double _80 = 41.0;
    double _81 = -_80;
    double _82 = -_81;
    a _83 = { _82, x };
    _73 = _83;
    _jump924:;
    _69 = _73;
    goto _jump925;
    _jump917:;
    bool _84 = c >= r;
    _a2_bool _85;
    if (!_84)
    goto _jump926;
    _a2_bool _86;
    // Computing bound for N
    _86.d0 = d;
    if (d > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    // Computing bound for O
    _86.d1 = d;
    if (d > 0) 
    goto _jump928;
    fail_assertion("non-positive loop bound");
    _jump928:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= d;
    _87 *= d;
    _87 *= sizeof(bool);
    _86.data = jpl_alloc(_87);
    int64_t _88 = 0; // O
    int64_t _89 = 0; // N
    _jump929:; // Begin body of loop
    int64_t _90 = 0;
    _90 *= _86.d0;
    _90 += _89;
    _90 *= _86.d1;
    _90 += _88;
    _86.data[_90] = e;
    _88++;
    if (_88 < d)
    goto _jump929;
    _88 = 0;
    _89++;
    if (_89 < d)
    goto _jump929;
    // End body of loop
    _85 = _86;
    goto _jump930;
    _jump926:;
    _a2_bool _91;
    // Computing bound for N
    _91.d0 = C.d2;
    if (C.d2 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for O
    _91.d1 = d;
    if (d > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= C.d2;
    _92 *= d;
    _92 *= sizeof(bool);
    _91.data = jpl_alloc(_92);
    int64_t _93 = 0; // O
    int64_t _94 = 0; // N
    _jump933:; // Begin body of loop
    int64_t _95 = 0;
    _95 *= _91.d0;
    _95 += _94;
    _95 *= _91.d1;
    _95 += _93;
    _91.data[_95] = e;
    _93++;
    if (_93 < d)
    goto _jump933;
    _93 = 0;
    _94++;
    if (_94 < C.d2)
    goto _jump933;
    // End body of loop
    _85 = _91;
    _jump930:;
    int64_t _96;
    // Computing bound for N
    if (r >= 0)
    goto _jump934;
    fail_assertion("negative array index");
    _jump934:;
    if (r < m.d0)
    goto _jump935;
    fail_assertion("index too large");
    _jump935:;
    if (C.d1 >= 0)
    goto _jump936;
    fail_assertion("negative array index");
    _jump936:;
    if (C.d1 < m.d1)
    goto _jump937;
    fail_assertion("index too large");
    _jump937:;
    if (o >= 0)
    goto _jump938;
    fail_assertion("negative array index");
    _jump938:;
    if (o < m.d2)
    goto _jump939;
    fail_assertion("index too large");
    _jump939:;
    int64_t _97 = 0;
    _97 *= m.d0;
    _97 += r;
    _97 *= m.d1;
    _97 += C.d1;
    _97 *= m.d2;
    _97 += o;
    int64_t _98 = m.data[_97];
    if (_98 > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    _96 = 0;
    int64_t _99 = 0; // N
    _jump941:; // Begin body of loop
    int64_t _100 = l + o;
    _96 += _100;
    _99++;
    if (_99 < _98)
    goto _jump941;
    // End body of loop
    if (d >= 0)
    goto _jump942;
    fail_assertion("negative array index");
    _jump942:;
    if (d < _85.d0)
    goto _jump943;
    fail_assertion("index too large");
    _jump943:;
    if (_96 >= 0)
    goto _jump944;
    fail_assertion("negative array index");
    _jump944:;
    if (_96 < _85.d1)
    goto _jump945;
    fail_assertion("index too large");
    _jump945:;
    int64_t _101 = 0;
    _101 *= _85.d0;
    _101 += d;
    _101 *= _85.d1;
    _101 += _96;
    bool _102 = _85.data[_101];
    a _103;
    if (!_102)
    goto _jump946;
    _a3_a _104;
    // Computing bound for N
    int64_t _105 = -C.d1;
    _104.d0 = _105;
    if (_105 > 0) 
    goto _jump947;
    fail_assertion("non-positive loop bound");
    _jump947:;
    // Computing bound for O
    _104.d1 = l;
    if (l > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing bound for P
    _104.d2 = n;
    if (n > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= _105;
    _106 *= l;
    _106 *= n;
    _106 *= sizeof(a);
    _104.data = jpl_alloc(_106);
    int64_t _107 = 0; // P
    int64_t _108 = 0; // O
    int64_t _109 = 0; // N
    _jump950:; // Begin body of loop
    double _110 = 33.0;
    a _111 = { _110, A };
    int64_t _112 = 0;
    _112 *= _104.d0;
    _112 += _109;
    _112 *= _104.d1;
    _112 += _108;
    _112 *= _104.d2;
    _112 += _107;
    _104.data[_112] = _111;
    _107++;
    if (_107 < n)
    goto _jump950;
    _107 = 0;
    _108++;
    if (_108 < l)
    goto _jump950;
    _108 = 0;
    _109++;
    if (_109 < _105)
    goto _jump950;
    // End body of loop
    if (n >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (n < _104.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    if (d >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (d < _104.d1)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    if (y >= 0)
    goto _jump955;
    fail_assertion("negative array index");
    _jump955:;
    if (y < _104.d2)
    goto _jump956;
    fail_assertion("index too large");
    _jump956:;
    int64_t _113 = 0;
    _113 *= _104.d0;
    _113 += n;
    _113 *= _104.d1;
    _113 += d;
    _113 *= _104.d2;
    _113 += y;
    a _114 = _104.data[_113];
    _103 = _114;
    goto _jump957;
    _jump946:;
    double _115 = 69.0;
    a _116 = { _115, h };
    _103 = _116;
    _jump957:;
    _69 = _103;
    _jump925:;
    double _117 = _69.a;
    a _118 = { i, p };
    double _119 = _118.a;
    rgba _120 = { _0, _39, _117, _119 };
    return _120;
    bool _121 = y <= d;
    _a3__a1_s _122;
    if (!_121)
    goto _jump958;
    _a3__a3__a1_s _123;
    // Computing bound for N
    _123.d0 = o;
    if (o > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing bound for O
    _123.d1 = y;
    if (y > 0) 
    goto _jump960;
    fail_assertion("non-positive loop bound");
    _jump960:;
    // Computing bound for P
    _123.d2 = n;
    if (n > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= o;
    _124 *= y;
    _124 *= n;
    _124 *= sizeof(_a3__a1_s);
    _123.data = jpl_alloc(_124);
    int64_t _125 = 0; // P
    int64_t _126 = 0; // O
    int64_t _127 = 0; // N
    _jump962:; // Begin body of loop
    int64_t _128 = 0;
    _128 *= _123.d0;
    _128 += _127;
    _128 *= _123.d1;
    _128 += _126;
    _128 *= _123.d2;
    _128 += _125;
    _123.data[_128] = C;
    _125++;
    if (_125 < n)
    goto _jump962;
    _125 = 0;
    _126++;
    if (_126 < y)
    goto _jump962;
    _126 = 0;
    _127++;
    if (_127 < o)
    goto _jump962;
    // End body of loop
    if (h >= 0)
    goto _jump963;
    fail_assertion("negative array index");
    _jump963:;
    if (h < _123.d0)
    goto _jump964;
    fail_assertion("index too large");
    _jump964:;
    if (C.d1 >= 0)
    goto _jump965;
    fail_assertion("negative array index");
    _jump965:;
    if (C.d1 < _123.d1)
    goto _jump966;
    fail_assertion("index too large");
    _jump966:;
    if (A >= 0)
    goto _jump967;
    fail_assertion("negative array index");
    _jump967:;
    if (A < _123.d2)
    goto _jump968;
    fail_assertion("index too large");
    _jump968:;
    int64_t _129 = 0;
    _129 *= _123.d0;
    _129 += h;
    _129 *= _123.d1;
    _129 += C.d1;
    _129 *= _123.d2;
    _129 += A;
    _a3__a1_s _130 = _123.data[_129];
    _122 = _130;
    goto _jump969;
    _jump958:;
    _a3__a1_s _131;
    if (!G)
    goto _jump970;
    _a2__a2__a3__a1_s _132;
    // Computing bound for N
    a _133 = { i, c };
    int64_t _134 = _133.b;
    _132.d0 = _134;
    if (_134 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    // Computing bound for O
    _132.d1 = x;
    if (x > 0) 
    goto _jump972;
    fail_assertion("non-positive loop bound");
    _jump972:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= _134;
    _135 *= x;
    _135 *= sizeof(_a2__a3__a1_s);
    _132.data = jpl_alloc(_135);
    int64_t _136 = 0; // O
    int64_t _137 = 0; // N
    _jump973:; // Begin body of loop
    _a2__a3__a1_s _138;
    // Computing bound for P
    int64_t _139;
    // Computing bound for P
    if (y > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for Q
    if (A > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing bound for R
    if (_136 > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    _139 = 0;
    int64_t _140 = 0; // R
    int64_t _141 = 0; // Q
    int64_t _142 = 0; // P
    _jump977:; // Begin body of loop
    _139 += y;
    _140++;
    if (_140 < _136)
    goto _jump977;
    _140 = 0;
    _141++;
    if (_141 < A)
    goto _jump977;
    _141 = 0;
    _142++;
    if (_142 < y)
    goto _jump977;
    // End body of loop
    _138.d0 = _139;
    if (_139 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for Q
    _138.d1 = _137;
    if (_137 > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= _139;
    _143 *= _137;
    _143 *= sizeof(_a3__a1_s);
    _138.data = jpl_alloc(_143);
    int64_t _144 = 0; // Q
    int64_t _145 = 0; // P
    _jump980:; // Begin body of loop
    int64_t _146 = 0;
    _146 *= _138.d0;
    _146 += _145;
    _146 *= _138.d1;
    _146 += _144;
    _138.data[_146] = C;
    _144++;
    if (_144 < _137)
    goto _jump980;
    _144 = 0;
    _145++;
    if (_145 < _139)
    goto _jump980;
    // End body of loop
    int64_t _147 = 0;
    _147 *= _132.d0;
    _147 += _137;
    _147 *= _132.d1;
    _147 += _136;
    _132.data[_147] = _138;
    _136++;
    if (_136 < x)
    goto _jump973;
    _136 = 0;
    _137++;
    if (_137 < _134)
    goto _jump973;
    // End body of loop
    if (n >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (n < _132.d0)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    if (l >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (l < _132.d1)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    int64_t _148 = 0;
    _148 *= _132.d0;
    _148 += n;
    _148 *= _132.d1;
    _148 += l;
    _a2__a3__a1_s _149 = _132.data[_148];
    int64_t _150 = 503;
    if (c >= 0)
    goto _jump985;
    fail_assertion("negative array index");
    _jump985:;
    if (c < _149.d0)
    goto _jump986;
    fail_assertion("index too large");
    _jump986:;
    if (_150 >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (_150 < _149.d1)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    int64_t _151 = 0;
    _151 *= _149.d0;
    _151 += c;
    _151 *= _149.d1;
    _151 += _150;
    _a3__a1_s _152 = _149.data[_151];
    _131 = _152;
    goto _jump989;
    _jump970:;
    _131 = C;
    _jump989:;
    _122 = _131;
    _jump969:;
    bool _153 = c >= x;
    bool _154;
    if (!_153)
    goto _jump990;
    bool _155 = !j;
    _154 = _155;
    goto _jump991;
    _jump990:;
    _154 = G;
    _jump991:;
    _a1_s _156;
    if (!_154)
    goto _jump992;
    if (C.d1 >= 0)
    goto _jump993;
    fail_assertion("negative array index");
    _jump993:;
    if (C.d1 < C.d0)
    goto _jump994;
    fail_assertion("index too large");
    _jump994:;
    if (C.d0 >= 0)
    goto _jump995;
    fail_assertion("negative array index");
    _jump995:;
    if (C.d0 < C.d1)
    goto _jump996;
    fail_assertion("index too large");
    _jump996:;
    if (p >= 0)
    goto _jump997;
    fail_assertion("negative array index");
    _jump997:;
    if (p < C.d2)
    goto _jump998;
    fail_assertion("index too large");
    _jump998:;
    int64_t _157 = 0;
    _157 *= C.d0;
    _157 += C.d1;
    _157 *= C.d1;
    _157 += C.d0;
    _157 *= C.d2;
    _157 += p;
    _a1_s _158 = C.data[_157];
    _156 = _158;
    goto _jump999;
    _jump992:;
    int64_t _159 = -C.d1;
    if (r >= 0)
    goto _jump1000;
    fail_assertion("negative array index");
    _jump1000:;
    if (r < _122.d0)
    goto _jump1001;
    fail_assertion("index too large");
    _jump1001:;
    if (o >= 0)
    goto _jump1002;
    fail_assertion("negative array index");
    _jump1002:;
    if (o < _122.d1)
    goto _jump1003;
    fail_assertion("index too large");
    _jump1003:;
    if (_159 >= 0)
    goto _jump1004;
    fail_assertion("negative array index");
    _jump1004:;
    if (_159 < _122.d2)
    goto _jump1005;
    fail_assertion("index too large");
    _jump1005:;
    int64_t _160 = 0;
    _160 *= _122.d0;
    _160 += r;
    _160 *= _122.d1;
    _160 += o;
    _160 *= _122.d2;
    _160 += _159;
    _a1_s _161 = _122.data[_160];
    _156 = _161;
    _jump999:;
    int64_t _162 = A * l;
    if (_162 >= 0)
    goto _jump1006;
    fail_assertion("negative array index");
    _jump1006:;
    if (_162 < _156.d0)
    goto _jump1007;
    fail_assertion("index too large");
    _jump1007:;
    int64_t _163 = 0;
    _163 *= _156.d0;
    _163 += _162;
    s _164 = _156.data[_163];
    rgba _165 = _164.a;
    _a2_s _166;
    // Computing bound for R
    int64_t _167;
    if (!j)
    goto _jump1008;
    _167 = A;
    goto _jump1009;
    _jump1008:;
    _167 = g;
    _jump1009:;
    _166.d0 = _167;
    if (_167 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for S
    bool _168 = q.d0 >= C.d2;
    int64_t _169;
    if (!_168)
    goto _jump1011;
    _169 = g;
    goto _jump1012;
    _jump1011:;
    _169 = y;
    _jump1012:;
    _166.d1 = _169;
    if (_169 > 0) 
    goto _jump1013;
    fail_assertion("non-positive loop bound");
    _jump1013:;
    // Computing total size of heap memory to allocate
    int64_t _170 = 1;
    _170 *= _167;
    _170 *= _169;
    _170 *= sizeof(s);
    _166.data = jpl_alloc(_170);
    int64_t _171 = 0; // S
    int64_t _172 = 0; // R
    _jump1014:; // Begin body of loop
    bool _173 = true;
    bool _174 = !_173;
    _a1_double _175;
    // Computing bound for T
    _175.d0 = q.d0;
    if (q.d0 > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= q.d0;
    _176 *= sizeof(double);
    _175.data = jpl_alloc(_176);
    int64_t _177 = 0; // T
    _jump1016:; // Begin body of loop
    double _178 = 70.0;
    int64_t _179 = 0;
    _179 *= _175.d0;
    _179 += _177;
    _175.data[_179] = _178;
    _177++;
    if (_177 < q.d0)
    goto _jump1016;
    // End body of loop
    s _180 = { H, _174, _175 };
    int64_t _181 = 0;
    _181 *= _166.d0;
    _181 += _172;
    _181 *= _166.d1;
    _181 += _171;
    _166.data[_181] = _180;
    _171++;
    if (_171 < _169)
    goto _jump1014;
    _171 = 0;
    _172++;
    if (_172 < _167)
    goto _jump1014;
    // End body of loop
    if (c >= 0)
    goto _jump1017;
    fail_assertion("negative array index");
    _jump1017:;
    if (c < _166.d0)
    goto _jump1018;
    fail_assertion("index too large");
    _jump1018:;
    if (n >= 0)
    goto _jump1019;
    fail_assertion("negative array index");
    _jump1019:;
    if (n < _166.d1)
    goto _jump1020;
    fail_assertion("index too large");
    _jump1020:;
    int64_t _182 = 0;
    _182 *= _166.d0;
    _182 += c;
    _182 *= _166.d1;
    _182 += n;
    s _183 = _166.data[_182];
    bool _184 = _183.b;
    double _185 = 7.0;
    bool _186 = false;
    double _187;
    if (!_186)
    goto _jump1021;
    double _188 = -i;
    _187 = _188;
    goto _jump1022;
    _jump1021:;
    a _189 = { i, d };
    double _190 = _189.a;
    _187 = _190;
    _jump1022:;
    bool _191 = _185 != _187;
    _a1_double _192;
    if (!_191)
    goto _jump1023;
    double _193 = i - i;
    double _194 = -_193;
    double _195 = 56.0;
    _a1_double _196;
    _196.d0 = 2;
    _196.data = jpl_alloc(sizeof(double) * 2);
    _196.data[0] = _194;
    _196.data[1] = _195;
    _192 = _196;
    goto _jump1024;
    _jump1023:;
    bool _197 = true;
    _a1_double _198;
    if (!_197)
    goto _jump1025;
    double _199 = H.a;
    double _200 = 25.0;
    _a1_double _201;
    _201.d0 = 3;
    _201.data = jpl_alloc(sizeof(double) * 3);
    _201.data[0] = _199;
    _201.data[1] = i;
    _201.data[2] = _200;
    _198 = _201;
    goto _jump1026;
    _jump1025:;
    bool _202 = false;
    _a1_double _203;
    if (!_202)
    goto _jump1027;
    _a1_double _204;
    // Computing bound for R
    _204.d0 = A;
    if (A > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing total size of heap memory to allocate
    int64_t _205 = 1;
    _205 *= A;
    _205 *= sizeof(double);
    _204.data = jpl_alloc(_205);
    int64_t _206 = 0; // R
    _jump1029:; // Begin body of loop
    int64_t _207 = 0;
    _207 *= _204.d0;
    _207 += _206;
    _204.data[_207] = i;
    _206++;
    if (_206 < A)
    goto _jump1029;
    // End body of loop
    _203 = _204;
    goto _jump1030;
    _jump1027:;
    _a1_double _208;
    // Computing bound for R
    _208.d0 = y;
    if (y > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    // Computing total size of heap memory to allocate
    int64_t _209 = 1;
    _209 *= y;
    _209 *= sizeof(double);
    _208.data = jpl_alloc(_209);
    int64_t _210 = 0; // R
    _jump1032:; // Begin body of loop
    double _211;
    if (!G)
    goto _jump1033;
    double _212 = 60.0;
    _211 = _212;
    goto _jump1034;
    _jump1033:;
    _211 = i;
    _jump1034:;
    int64_t _213 = 0;
    _213 *= _208.d0;
    _213 += _210;
    _208.data[_213] = _211;
    _210++;
    if (_210 < y)
    goto _jump1032;
    // End body of loop
    _203 = _208;
    _jump1030:;
    _198 = _203;
    _jump1026:;
    _192 = _198;
    _jump1024:;
    s _214 = { _165, _184, _192 };
    rgba _215 = _214.a;
    return _215;
}

double C() {
    _a3__a3_int64_t _0;
    if (!e)
    goto _jump1035;
    _a1__a3__a3_int64_t _1;
    // Computing bound for D
    _1.d0 = n;
    if (n > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= n;
    _2 *= sizeof(_a3__a3_int64_t);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // D
    _jump1037:; // Begin body of loop
    _a3__a3_int64_t _4;
    // Computing bound for E
    _4.d0 = _3;
    if (_3 > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    // Computing bound for F
    _4.d1 = o;
    if (o > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    // Computing bound for G
    _4.d2 = y;
    if (y > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _3;
    _5 *= o;
    _5 *= y;
    _5 *= sizeof(_a3_int64_t);
    _4.data = jpl_alloc(_5);
    int64_t _6 = 0; // G
    int64_t _7 = 0; // F
    int64_t _8 = 0; // E
    _jump1041:; // Begin body of loop
    int64_t _9 = 0;
    _9 *= _4.d0;
    _9 += _8;
    _9 *= _4.d1;
    _9 += _7;
    _9 *= _4.d2;
    _9 += _6;
    _4.data[_9] = m;
    _6++;
    if (_6 < y)
    goto _jump1041;
    _6 = 0;
    _7++;
    if (_7 < o)
    goto _jump1041;
    _7 = 0;
    _8++;
    if (_8 < _3)
    goto _jump1041;
    // End body of loop
    int64_t _10 = 0;
    _10 *= _1.d0;
    _10 += _3;
    _1.data[_10] = _4;
    _3++;
    if (_3 < n)
    goto _jump1037;
    // End body of loop
    if (p >= 0)
    goto _jump1042;
    fail_assertion("negative array index");
    _jump1042:;
    if (p < _1.d0)
    goto _jump1043;
    fail_assertion("index too large");
    _jump1043:;
    int64_t _11 = 0;
    _11 *= _1.d0;
    _11 += p;
    _a3__a3_int64_t _12 = _1.data[_11];
    _0 = _12;
    goto _jump1044;
    _jump1035:;
    bool _14 = x != l;
    bool _13 = _14;
    if (0 != _14)
    goto _jump1045;
    bool _15 = true;
    bool _16 = !_15;
    _13 = _16;
    _jump1045:;
    _a3__a3_int64_t _17;
    if (!_13)
    goto _jump1046;
    _a3__a3_int64_t _18;
    // Computing bound for D
    _18.d0 = d;
    if (d > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing bound for E
    _18.d1 = o;
    if (o > 0) 
    goto _jump1048;
    fail_assertion("non-positive loop bound");
    _jump1048:;
    // Computing bound for F
    _18.d2 = c;
    if (c > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= d;
    _19 *= o;
    _19 *= c;
    _19 *= sizeof(_a3_int64_t);
    _18.data = jpl_alloc(_19);
    int64_t _20 = 0; // F
    int64_t _21 = 0; // E
    int64_t _22 = 0; // D
    _jump1050:; // Begin body of loop
    int64_t _23 = 0;
    _23 *= _18.d0;
    _23 += _22;
    _23 *= _18.d1;
    _23 += _21;
    _23 *= _18.d2;
    _23 += _20;
    _18.data[_23] = m;
    _20++;
    if (_20 < c)
    goto _jump1050;
    _20 = 0;
    _21++;
    if (_21 < o)
    goto _jump1050;
    _21 = 0;
    _22++;
    if (_22 < d)
    goto _jump1050;
    // End body of loop
    _17 = _18;
    goto _jump1051;
    _jump1046:;
    _a3__a3_int64_t _24;
    // Computing bound for D
    _24.d0 = A;
    if (A > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    // Computing bound for E
    _24.d1 = y;
    if (y > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing bound for F
    _24.d2 = g;
    if (g > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= A;
    _25 *= y;
    _25 *= g;
    _25 *= sizeof(_a3_int64_t);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // F
    int64_t _27 = 0; // E
    int64_t _28 = 0; // D
    _jump1055:; // Begin body of loop
    int64_t _29 = 0;
    _29 *= _24.d0;
    _29 += _28;
    _29 *= _24.d1;
    _29 += _27;
    _29 *= _24.d2;
    _29 += _26;
    _24.data[_29] = m;
    _26++;
    if (_26 < g)
    goto _jump1055;
    _26 = 0;
    _27++;
    if (_27 < y)
    goto _jump1055;
    _27 = 0;
    _28++;
    if (_28 < A)
    goto _jump1055;
    // End body of loop
    _17 = _24;
    _jump1051:;
    _0 = _17;
    _jump1044:;
    bool _31;
    if (!e)
    goto _jump1056;
    _31 = e;
    goto _jump1057;
    _jump1056:;
    bool _32 = false;
    _31 = _32;
    _jump1057:;
    bool _33;
    if (!_31)
    goto _jump1058;
    bool _34 = false;
    _33 = _34;
    goto _jump1059;
    _jump1058:;
    bool _35 = true;
    bool _36 = !_35;
    _33 = _36;
    _jump1059:;
    bool _30 = _33;
    if (0 == _33)
    goto _jump1060;
    int64_t _37 = 114;
    bool _38 = h != _37;
    bool _39;
    if (!_38)
    goto _jump1061;
    _39 = j;
    goto _jump1062;
    _jump1061:;
    int64_t _40 = 776;
    bool _41 = _40 > d;
    _39 = _41;
    _jump1062:;
    _30 = _39;
    _jump1060:;
    int64_t _42;
    if (!_30)
    goto _jump1063;
    _42 = n;
    goto _jump1064;
    _jump1063:;
    _42 = g;
    _jump1064:;
    if (o >= 0)
    goto _jump1065;
    fail_assertion("negative array index");
    _jump1065:;
    if (o < _0.d0)
    goto _jump1066;
    fail_assertion("index too large");
    _jump1066:;
    if (d >= 0)
    goto _jump1067;
    fail_assertion("negative array index");
    _jump1067:;
    if (d < _0.d1)
    goto _jump1068;
    fail_assertion("index too large");
    _jump1068:;
    if (_42 >= 0)
    goto _jump1069;
    fail_assertion("negative array index");
    _jump1069:;
    if (_42 < _0.d2)
    goto _jump1070;
    fail_assertion("index too large");
    _jump1070:;
    int64_t _43 = 0;
    _43 *= _0.d0;
    _43 += o;
    _43 *= _0.d1;
    _43 += d;
    _43 *= _0.d2;
    _43 += _42;
    _a3_int64_t _44 = _0.data[_43];
    _a3_int64_t _45;
    if (!j)
    goto _jump1071;
    _a3_int64_t _46;
    // Computing bound for D
    _46.d0 = A;
    if (A > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    // Computing bound for E
    _46.d1 = A;
    if (A > 0) 
    goto _jump1073;
    fail_assertion("non-positive loop bound");
    _jump1073:;
    // Computing bound for F
    _46.d2 = A;
    if (A > 0) 
    goto _jump1074;
    fail_assertion("non-positive loop bound");
    _jump1074:;
    // Computing total size of heap memory to allocate
    int64_t _47 = 1;
    _47 *= A;
    _47 *= A;
    _47 *= A;
    _47 *= sizeof(int64_t);
    _46.data = jpl_alloc(_47);
    int64_t _48 = 0; // F
    int64_t _49 = 0; // E
    int64_t _50 = 0; // D
    _jump1075:; // Begin body of loop
    int64_t _51 = v();
    int64_t _52 = 0;
    _52 *= _46.d0;
    _52 += _50;
    _52 *= _46.d1;
    _52 += _49;
    _52 *= _46.d2;
    _52 += _48;
    _46.data[_52] = _51;
    _48++;
    if (_48 < A)
    goto _jump1075;
    _48 = 0;
    _49++;
    if (_49 < A)
    goto _jump1075;
    _49 = 0;
    _50++;
    if (_50 < A)
    goto _jump1075;
    // End body of loop
    _45 = _46;
    goto _jump1076;
    _jump1071:;
    bool _53 = e;
    if (0 != e)
    goto _jump1077;
    _53 = e;
    _jump1077:;
    _a3__a3_int64_t _54;
    if (!_53)
    goto _jump1078;
    bool _55 = p < y;
    _a3__a3_int64_t _56;
    if (!_55)
    goto _jump1079;
    _a3__a3_int64_t _57;
    // Computing bound for D
    _57.d0 = p;
    if (p > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    // Computing bound for E
    _57.d1 = h;
    if (h > 0) 
    goto _jump1081;
    fail_assertion("non-positive loop bound");
    _jump1081:;
    // Computing bound for F
    _57.d2 = g;
    if (g > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= p;
    _58 *= h;
    _58 *= g;
    _58 *= sizeof(_a3_int64_t);
    _57.data = jpl_alloc(_58);
    int64_t _59 = 0; // F
    int64_t _60 = 0; // E
    int64_t _61 = 0; // D
    _jump1083:; // Begin body of loop
    int64_t _62 = 0;
    _62 *= _57.d0;
    _62 += _61;
    _62 *= _57.d1;
    _62 += _60;
    _62 *= _57.d2;
    _62 += _59;
    _57.data[_62] = m;
    _59++;
    if (_59 < g)
    goto _jump1083;
    _59 = 0;
    _60++;
    if (_60 < h)
    goto _jump1083;
    _60 = 0;
    _61++;
    if (_61 < p)
    goto _jump1083;
    // End body of loop
    _56 = _57;
    goto _jump1084;
    _jump1079:;
    _a3__a3_int64_t _63;
    // Computing bound for D
    int64_t _64 = 981;
    _63.d0 = _64;
    if (_64 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing bound for E
    _63.d1 = o;
    if (o > 0) 
    goto _jump1086;
    fail_assertion("non-positive loop bound");
    _jump1086:;
    // Computing bound for F
    _63.d2 = l;
    if (l > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= _64;
    _65 *= o;
    _65 *= l;
    _65 *= sizeof(_a3_int64_t);
    _63.data = jpl_alloc(_65);
    int64_t _66 = 0; // F
    int64_t _67 = 0; // E
    int64_t _68 = 0; // D
    _jump1088:; // Begin body of loop
    int64_t _69 = 0;
    _69 *= _63.d0;
    _69 += _68;
    _69 *= _63.d1;
    _69 += _67;
    _69 *= _63.d2;
    _69 += _66;
    _63.data[_69] = m;
    _66++;
    if (_66 < l)
    goto _jump1088;
    _66 = 0;
    _67++;
    if (_67 < o)
    goto _jump1088;
    _67 = 0;
    _68++;
    if (_68 < _64)
    goto _jump1088;
    // End body of loop
    _56 = _63;
    _jump1084:;
    _54 = _56;
    goto _jump1089;
    _jump1078:;
    _a3__a3_int64_t _70;
    // Computing bound for D
    _70.d0 = d;
    if (d > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for E
    _70.d1 = h;
    if (h > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    // Computing bound for F
    _70.d2 = g;
    if (g > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= d;
    _71 *= h;
    _71 *= g;
    _71 *= sizeof(_a3_int64_t);
    _70.data = jpl_alloc(_71);
    int64_t _72 = 0; // F
    int64_t _73 = 0; // E
    int64_t _74 = 0; // D
    _jump1093:; // Begin body of loop
    int64_t _75 = 0;
    _75 *= _70.d0;
    _75 += _74;
    _75 *= _70.d1;
    _75 += _73;
    _75 *= _70.d2;
    _75 += _72;
    _70.data[_75] = m;
    _72++;
    if (_72 < g)
    goto _jump1093;
    _72 = 0;
    _73++;
    if (_73 < h)
    goto _jump1093;
    _73 = 0;
    _74++;
    if (_74 < d)
    goto _jump1093;
    // End body of loop
    _54 = _70;
    _jump1089:;
    bool _76 = true;
    _a3_int64_t _77;
    if (!_76)
    goto _jump1094;
    _77 = m;
    goto _jump1095;
    _jump1094:;
    _77 = m;
    _jump1095:;
    int64_t _78 = v();
    int64_t _79 = 531;
    if (_78 >= 0)
    goto _jump1096;
    fail_assertion("negative array index");
    _jump1096:;
    if (_78 < _77.d0)
    goto _jump1097;
    fail_assertion("index too large");
    _jump1097:;
    if (g >= 0)
    goto _jump1098;
    fail_assertion("negative array index");
    _jump1098:;
    if (g < _77.d1)
    goto _jump1099;
    fail_assertion("index too large");
    _jump1099:;
    if (_79 >= 0)
    goto _jump1100;
    fail_assertion("negative array index");
    _jump1100:;
    if (_79 < _77.d2)
    goto _jump1101;
    fail_assertion("index too large");
    _jump1101:;
    int64_t _80 = 0;
    _80 *= _77.d0;
    _80 += _78;
    _80 *= _77.d1;
    _80 += g;
    _80 *= _77.d2;
    _80 += _79;
    int64_t _81 = _77.data[_80];
    if (_81 >= 0)
    goto _jump1102;
    fail_assertion("negative array index");
    _jump1102:;
    if (_81 < _54.d0)
    goto _jump1103;
    fail_assertion("index too large");
    _jump1103:;
    if (h >= 0)
    goto _jump1104;
    fail_assertion("negative array index");
    _jump1104:;
    if (h < _54.d1)
    goto _jump1105;
    fail_assertion("index too large");
    _jump1105:;
    if (h >= 0)
    goto _jump1106;
    fail_assertion("negative array index");
    _jump1106:;
    if (h < _54.d2)
    goto _jump1107;
    fail_assertion("index too large");
    _jump1107:;
    int64_t _82 = 0;
    _82 *= _54.d0;
    _82 += _81;
    _82 *= _54.d1;
    _82 += h;
    _82 *= _54.d2;
    _82 += h;
    _a3_int64_t _83 = _54.data[_82];
    _45 = _83;
    _jump1076:;
    _a1__a3_int64_t _84;
    _84.d0 = 2;
    _84.data = jpl_alloc(sizeof(_a3_int64_t) * 2);
    _84.data[0] = _44;
    _84.data[1] = _45;
    if (h >= 0)
    goto _jump1108;
    fail_assertion("negative array index");
    _jump1108:;
    if (h < k.d0)
    goto _jump1109;
    fail_assertion("index too large");
    _jump1109:;
    int64_t _85 = 0;
    _85 *= k.d0;
    _85 += h;
    int64_t _86 = k.data[_85];
    if (_86 >= 0)
    goto _jump1110;
    fail_assertion("negative array index");
    _jump1110:;
    if (_86 < _84.d0)
    goto _jump1111;
    fail_assertion("index too large");
    _jump1111:;
    int64_t _87 = 0;
    _87 *= _84.d0;
    _87 += _86;
    _a3_int64_t _88 = _84.data[_87];
    _a2_int64_t _90;
    // Computing bound for H
    _90.d0 = _88.d0;
    if (_88.d0 > 0) 
    goto _jump1112;
    fail_assertion("non-positive loop bound");
    _jump1112:;
    // Computing bound for I
    _90.d1 = h;
    if (h > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= _88.d0;
    _91 *= h;
    _91 *= sizeof(int64_t);
    _90.data = jpl_alloc(_91);
    int64_t _92 = 0; // I
    int64_t _93 = 0; // H
    _jump1114:; // Begin body of loop
    int64_t _94 = 0;
    _94 *= _90.d0;
    _94 += _93;
    _94 *= _90.d1;
    _94 += _92;
    _90.data[_94] = d;
    _92++;
    if (_92 < h)
    goto _jump1114;
    _92 = 0;
    _93++;
    if (_93 < _88.d0)
    goto _jump1114;
    // End body of loop
    if (_88.d1 >= 0)
    goto _jump1115;
    fail_assertion("negative array index");
    _jump1115:;
    if (_88.d1 < _90.d0)
    goto _jump1116;
    fail_assertion("index too large");
    _jump1116:;
    if (A >= 0)
    goto _jump1117;
    fail_assertion("negative array index");
    _jump1117:;
    if (A < _90.d1)
    goto _jump1118;
    fail_assertion("index too large");
    _jump1118:;
    int64_t _95 = 0;
    _95 *= _90.d0;
    _95 += _88.d1;
    _95 *= _90.d1;
    _95 += A;
    int64_t _96 = _90.data[_95];
    bool _97 = _96 <= p;
    bool _89 = _97;
    if (0 == _97)
    goto _jump1119;
    int64_t _98;
    // Computing bound for H
    if (h > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing bound for I
    if (h > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    _98 = 0;
    int64_t _99 = 0; // I
    int64_t _100 = 0; // H
    _jump1122:; // Begin body of loop
    _98 += y;
    _99++;
    if (_99 < h)
    goto _jump1122;
    _99 = 0;
    _100++;
    if (_100 < h)
    goto _jump1122;
    // End body of loop
    bool _101 = c != _98;
    _89 = _101;
    _jump1119:;
    bool _102 = !_89;
    if (0 != _102)
    goto _jump1123;
    fail_assertion("H");
    _jump1123:;
    _a3_double _103;
    // Computing bound for H
    _103.d0 = p;
    if (p > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing bound for I
    _103.d1 = _88.d1;
    if (_88.d1 > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    // Computing bound for J
    _103.d2 = g;
    if (g > 0) 
    goto _jump1126;
    fail_assertion("non-positive loop bound");
    _jump1126:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= p;
    _104 *= _88.d1;
    _104 *= g;
    _104 *= sizeof(double);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // J
    int64_t _106 = 0; // I
    int64_t _107 = 0; // H
    _jump1127:; // Begin body of loop
    double _108 = C();
    rgba _109 = { i, i, _108, i };
    _a1_rgba _110;
    _110.d0 = 1;
    _110.data = jpl_alloc(sizeof(rgba) * 1);
    _110.data[0] = _109;
    if (n >= 0)
    goto _jump1128;
    fail_assertion("negative array index");
    _jump1128:;
    if (n < _110.d0)
    goto _jump1129;
    fail_assertion("index too large");
    _jump1129:;
    int64_t _111 = 0;
    _111 *= _110.d0;
    _111 += n;
    rgba _112 = _110.data[_111];
    bool _114 = g == l;
    bool _113 = _114;
    if (0 != _114)
    goto _jump1130;
    bool _115 = true;
    _113 = _115;
    _jump1130:;
    _a1_double _116;
    // Computing bound for K
    _116.d0 = d;
    if (d > 0) 
    goto _jump1131;
    fail_assertion("non-positive loop bound");
    _jump1131:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= d;
    _117 *= sizeof(double);
    _116.data = jpl_alloc(_117);
    int64_t _118 = 0; // K
    _jump1132:; // Begin body of loop
    double _119 = C();
    double _120 = 54.0;
    double _121 = fmod(_119, _120);
    int64_t _122 = 0;
    _122 *= _116.d0;
    _122 += _118;
    _116.data[_122] = _121;
    _118++;
    if (_118 < d)
    goto _jump1132;
    // End body of loop
    s _123 = { _112, _113, _116 };
    rgba _124 = _123.a;
    double _125 = _124.r;
    int64_t _126 = 0;
    _126 *= _103.d0;
    _126 += _107;
    _126 *= _103.d1;
    _126 += _106;
    _126 *= _103.d2;
    _126 += _105;
    _103.data[_126] = _125;
    _105++;
    if (_105 < g)
    goto _jump1127;
    _105 = 0;
    _106++;
    if (_106 < _88.d1)
    goto _jump1127;
    _106 = 0;
    _107++;
    if (_107 < p)
    goto _jump1127;
    // End body of loop
    _a2__a1_double _127;
    // Computing bound for L
    _127.d0 = _103.d0;
    if (_103.d0 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    // Computing bound for M
    _127.d1 = d;
    if (d > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _103.d0;
    _128 *= d;
    _128 *= sizeof(_a1_double);
    _127.data = jpl_alloc(_128);
    int64_t _129 = 0; // M
    int64_t _130 = 0; // L
    _jump1135:; // Begin body of loop
    bool _131 = e;
    if (0 == e)
    goto _jump1136;
    bool _132 = false;
    _131 = _132;
    _jump1136:;
    bool _133 = !_131;
    s _134;
    if (!_133)
    goto _jump1137;
    double _135 = C();
    double _136 = -i;
    double _137 = 31.0;
    rgba _138 = { i, _135, _136, _137 };
    bool _139 = !e;
    bool _140 = false;
    bool _141 = !_140;
    _a1_double _142;
    if (!_141)
    goto _jump1138;
    double _143 = C();
    _a1_double _144;
    _144.d0 = 1;
    _144.data = jpl_alloc(sizeof(double) * 1);
    _144.data[0] = _143;
    _142 = _144;
    goto _jump1139;
    _jump1138:;
    _a1_double _145;
    // Computing bound for N
    _145.d0 = _88.d1;
    if (_88.d1 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _88.d1;
    _146 *= sizeof(double);
    _145.data = jpl_alloc(_146);
    int64_t _147 = 0; // N
    _jump1141:; // Begin body of loop
    int64_t _148 = 0;
    _148 *= _145.d0;
    _148 += _147;
    _145.data[_148] = i;
    _147++;
    if (_147 < _88.d1)
    goto _jump1141;
    // End body of loop
    _142 = _145;
    _jump1139:;
    s _149 = { _138, _139, _142 };
    _134 = _149;
    goto _jump1142;
    _jump1137:;
    bool _150 = true;
    double _151;
    if (!_150)
    goto _jump1143;
    _151 = i;
    goto _jump1144;
    _jump1143:;
    double _152 = C();
    _151 = _152;
    _jump1144:;
    double _153 = 25.0;
    double _154 = 28.0;
    double _155 = -_154;
    if (_88.d2 >= 0)
    goto _jump1145;
    fail_assertion("negative array index");
    _jump1145:;
    if (_88.d2 < _103.d0)
    goto _jump1146;
    fail_assertion("index too large");
    _jump1146:;
    if (x >= 0)
    goto _jump1147;
    fail_assertion("negative array index");
    _jump1147:;
    if (x < _103.d1)
    goto _jump1148;
    fail_assertion("index too large");
    _jump1148:;
    if (_103.d2 >= 0)
    goto _jump1149;
    fail_assertion("negative array index");
    _jump1149:;
    if (_103.d2 < _103.d2)
    goto _jump1150;
    fail_assertion("index too large");
    _jump1150:;
    int64_t _156 = 0;
    _156 *= _103.d0;
    _156 += _88.d2;
    _156 *= _103.d1;
    _156 += x;
    _156 *= _103.d2;
    _156 += _103.d2;
    double _157 = _103.data[_156];
    rgba _158 = { _151, _153, _155, _157 };
    bool _159 = true;
    bool _160 = !_159;
    double _161 = 73.0;
    double _162 = -_161;
    double _163;
    // Computing bound for N
    if (_103.d2 > 0) 
    goto _jump1151;
    fail_assertion("non-positive loop bound");
    _jump1151:;
    // Computing bound for O
    if (o > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    _163 = 0;
    int64_t _164 = 0; // O
    int64_t _165 = 0; // N
    _jump1153:; // Begin body of loop
    _163 += i;
    _164++;
    if (_164 < o)
    goto _jump1153;
    _164 = 0;
    _165++;
    if (_165 < _103.d2)
    goto _jump1153;
    // End body of loop
    _a1_double _166;
    _166.d0 = 3;
    _166.data = jpl_alloc(sizeof(double) * 3);
    _166.data[0] = _162;
    _166.data[1] = i;
    _166.data[2] = _163;
    s _167 = { _158, _160, _166 };
    _134 = _167;
    _jump1142:;
    _a1_double _168 = _134.c;
    int64_t _169 = 0;
    _169 *= _127.d0;
    _169 += _130;
    _169 *= _127.d1;
    _169 += _129;
    _127.data[_169] = _168;
    _129++;
    if (_129 < d)
    goto _jump1135;
    _129 = 0;
    _130++;
    if (_130 < _103.d0)
    goto _jump1135;
    // End body of loop
    bool _170 = _103.d1 == l;
    _a1_int64_t _171;
    if (!_170)
    goto _jump1154;
    _171 = q;
    goto _jump1155;
    _jump1154:;
    _a1_int64_t _172;
    // Computing bound for L
    _172.d0 = _88.d1;
    if (_88.d1 > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= _88.d1;
    _173 *= sizeof(int64_t);
    _172.data = jpl_alloc(_173);
    int64_t _174 = 0; // L
    _jump1157:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _172.d0;
    _175 += _174;
    _172.data[_175] = _88.d1;
    _174++;
    if (_174 < _88.d1)
    goto _jump1157;
    // End body of loop
    _171 = _172;
    _jump1155:;
    if (y >= 0)
    goto _jump1158;
    fail_assertion("negative array index");
    _jump1158:;
    if (y < _171.d0)
    goto _jump1159;
    fail_assertion("index too large");
    _jump1159:;
    int64_t _176 = 0;
    _176 *= _171.d0;
    _176 += y;
    int64_t _177 = _171.data[_176];
    if (_177 >= 0)
    goto _jump1160;
    fail_assertion("negative array index");
    _jump1160:;
    if (_177 < _127.d0)
    goto _jump1161;
    fail_assertion("index too large");
    _jump1161:;
    if (_103.d0 >= 0)
    goto _jump1162;
    fail_assertion("negative array index");
    _jump1162:;
    if (_103.d0 < _127.d1)
    goto _jump1163;
    fail_assertion("index too large");
    _jump1163:;
    int64_t _178 = 0;
    _178 *= _127.d0;
    _178 += _177;
    _178 *= _127.d1;
    _178 += _103.d0;
    _a1_double _179 = _127.data[_178];
    double _180;
    // Computing bound for P
    if (o > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    _180 = 0;
    int64_t _181 = 0; // P
    _jump1165:; // Begin body of loop
    bool _182 = e;
    if (0 != e)
    goto _jump1166;
    bool _183 = false;
    _182 = _183;
    _jump1166:;
    double _184;
    if (!_182)
    goto _jump1167;
    bool _186 = true;
    bool _185 = _186;
    if (0 == _186)
    goto _jump1168;
    bool _187;
    if (!e)
    goto _jump1169;
    bool _188 = false;
    _187 = _188;
    goto _jump1170;
    _jump1169:;
    bool _189 = true;
    _187 = _189;
    _jump1170:;
    _185 = _187;
    _jump1168:;
    double _190;
    if (!_185)
    goto _jump1171;
    double _191;
    // Computing bound for Q
    if (_88.d0 > 0) 
    goto _jump1172;
    fail_assertion("non-positive loop bound");
    _jump1172:;
    // Computing bound for R
    int64_t _192 = 994;
    if (_192 > 0) 
    goto _jump1173;
    fail_assertion("non-positive loop bound");
    _jump1173:;
    // Computing bound for S
    int64_t _193;
    // Computing bound for Q
    if (_103.d2 > 0) 
    goto _jump1174;
    fail_assertion("non-positive loop bound");
    _jump1174:;
    // Computing bound for R
    if (_88.d2 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    // Computing bound for S
    int64_t _194 = 132;
    if (_194 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    _193 = 0;
    int64_t _195 = 0; // S
    int64_t _196 = 0; // R
    int64_t _197 = 0; // Q
    _jump1177:; // Begin body of loop
    _193 += h;
    _195++;
    if (_195 < _194)
    goto _jump1177;
    _195 = 0;
    _196++;
    if (_196 < _88.d2)
    goto _jump1177;
    _196 = 0;
    _197++;
    if (_197 < _103.d2)
    goto _jump1177;
    // End body of loop
    if (_193 > 0) 
    goto _jump1178;
    fail_assertion("non-positive loop bound");
    _jump1178:;
    _191 = 0;
    int64_t _198 = 0; // S
    int64_t _199 = 0; // R
    int64_t _200 = 0; // Q
    _jump1179:; // Begin body of loop
    double _201 = 46.0;
    _191 += _201;
    _198++;
    if (_198 < _193)
    goto _jump1179;
    _198 = 0;
    _199++;
    if (_199 < _192)
    goto _jump1179;
    _199 = 0;
    _200++;
    if (_200 < _88.d0)
    goto _jump1179;
    // End body of loop
    _190 = _191;
    goto _jump1180;
    _jump1171:;
    _190 = i;
    _jump1180:;
    _184 = _190;
    goto _jump1181;
    _jump1167:;
    _184 = i;
    _jump1181:;
    _180 += _184;
    _181++;
    if (_181 < o)
    goto _jump1165;
    // End body of loop
    double _202;
    // Computing bound for P
    int64_t _203 = v();
    int64_t _204 = -r;
    int64_t _205 = _203 + _204;
    if (_205 > 0) 
    goto _jump1182;
    fail_assertion("non-positive loop bound");
    _jump1182:;
    // Computing bound for Q
    if (_103.d0 > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    _202 = 0;
    int64_t _206 = 0; // Q
    int64_t _207 = 0; // P
    _jump1184:; // Begin body of loop
    double _208 = 59.0;
    _202 += _208;
    _206++;
    if (_206 < _103.d0)
    goto _jump1184;
    _206 = 0;
    _207++;
    if (_207 < _205)
    goto _jump1184;
    // End body of loop
    double _209 = -_202;
    double _210 = 46.0;
    double _211;
    // Computing bound for P
    if (g > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing bound for Q
    if (_88.d0 > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    // Computing bound for R
    if (l > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    _211 = 0;
    int64_t _212 = 0; // R
    int64_t _213 = 0; // Q
    int64_t _214 = 0; // P
    _jump1188:; // Begin body of loop
    _211 += i;
    _212++;
    if (_212 < l)
    goto _jump1188;
    _212 = 0;
    _213++;
    if (_213 < _88.d0)
    goto _jump1188;
    _213 = 0;
    _214++;
    if (_214 < g)
    goto _jump1188;
    // End body of loop
    double _215 = _211 - i;
    rgba _216 = { _180, _209, _210, _215 };
    double _217 = _216.g;
    return _217;
}

void jpl_main(struct args args) {
    int64_t _1 = 99;
    int64_t _2 = 538;
    int64_t _3 = -_2;
    int64_t _4 = -_3;
    bool _5 = _1 >= _4;
    bool _6;
    if (!_5)
    goto _jump1;
    double _7 = 12.0;
    double _8 = 21.0;
    double _9 = -_8;
    double _10 = _7 - _9;
    double _11 = 74.0;
    double _12 = -_11;
    bool _13 = _10 < _12;
    _6 = _13;
    goto _jump2;
    _jump1:;
    bool _15 = false;
    bool _16 = true;
    bool _17 = _15 == _16;
    bool _14 = _17;
    if (0 == _17)
    goto _jump3;
    bool _19 = false;
    bool _18 = _19;
    if (0 == _19)
    goto _jump4;
    bool _20 = false;
    _18 = _20;
    _jump4:;
    _14 = _18;
    _jump3:;
    bool _21 = !_14;
    _6 = _21;
    _jump2:;
    bool _0 = _6;
    if (0 == _6)
    goto _jump5;
    bool _23 = false;
    bool _22 = _23;
    if (0 != _23)
    goto _jump6;
    bool _25 = false;
    bool _26 = false;
    _a1_bool _27;
    _27.d0 = 2;
    _27.data = jpl_alloc(sizeof(bool) * 2);
    _27.data[0] = _25;
    _27.data[1] = _26;
    int64_t _28 = 79;
    int64_t _29 = 229;
    int64_t _30 = _28 + _29;
    if (_30 >= 0)
    goto _jump7;
    fail_assertion("negative array index");
    _jump7:;
    if (_30 < _27.d0)
    goto _jump8;
    fail_assertion("index too large");
    _jump8:;
    int64_t _31 = 0;
    _31 *= _27.d0;
    _31 += _30;
    bool _32 = _27.data[_31];
    bool _24 = _32;
    if (0 != _32)
    goto _jump9;
    bool _33 = false;
    _24 = _33;
    _jump9:;
    _22 = _24;
    _jump6:;
    bool _34;
    if (!_22)
    goto _jump10;
    int64_t _35 = 198;
    int64_t _36 = -_35;
    int64_t _37 = 331;
    int64_t _38 = _36 / _37;
    bool _39 = false;
    bool _40 = !_39;
    int64_t _41;
    if (!_40)
    goto _jump11;
    int64_t _42 = 325;
    _41 = _42;
    goto _jump12;
    _jump11:;
    int64_t _43 = 807;
    _41 = _43;
    _jump12:;
    bool _44 = _38 == _41;
    bool _45 = !_44;
    _34 = _45;
    goto _jump13;
    _jump10:;
    _a2_bool _46;
    // Computing bound for b
    int64_t _47 = 590;
    int64_t _48 = -_47;
    _46.d0 = _48;
    if (_48 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing bound for c
    int64_t _49 = 14;
    int64_t _50 = -_49;
    _46.d1 = _50;
    if (_50 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    // Computing total size of heap memory to allocate
    int64_t _51 = 1;
    _51 *= _48;
    _51 *= _50;
    _51 *= sizeof(bool);
    _46.data = jpl_alloc(_51);
    int64_t _52 = 0; // c
    int64_t _53 = 0; // b
    _jump16:; // Begin body of loop
    bool _54 = true;
    int64_t _55 = 0;
    _55 *= _46.d0;
    _55 += _53;
    _55 *= _46.d1;
    _55 += _52;
    _46.data[_55] = _54;
    _52++;
    if (_52 < _50)
    goto _jump16;
    _52 = 0;
    _53++;
    if (_53 < _48)
    goto _jump16;
    // End body of loop
    bool _56 = false;
    bool _57 = !_56;
    int64_t _58;
    if (!_57)
    goto _jump17;
    int64_t _59 = 342;
    _58 = _59;
    goto _jump18;
    _jump17:;
    int64_t _60 = 332;
    _58 = _60;
    _jump18:;
    int64_t _61 = 779;
    if (_58 >= 0)
    goto _jump19;
    fail_assertion("negative array index");
    _jump19:;
    if (_58 < _46.d0)
    goto _jump20;
    fail_assertion("index too large");
    _jump20:;
    if (_61 >= 0)
    goto _jump21;
    fail_assertion("negative array index");
    _jump21:;
    if (_61 < _46.d1)
    goto _jump22;
    fail_assertion("index too large");
    _jump22:;
    int64_t _62 = 0;
    _62 *= _46.d0;
    _62 += _58;
    _62 *= _46.d1;
    _62 += _61;
    bool _63 = _46.data[_62];
    _34 = _63;
    _jump13:;
    _0 = _34;
    _jump5:;
    _a2_rgba _64;
    if (!_0)
    goto _jump23;
    _a2_rgba _65;
    // Computing bound for b
    int64_t _66;
    // Computing bound for b
    int64_t _67;
    // Computing bound for b
    int64_t _68 = 618;
    if (_68 > 0) 
    goto _jump24;
    fail_assertion("non-positive loop bound");
    _jump24:;
    _67 = 0;
    int64_t _69 = 0; // b
    _jump25:; // Begin body of loop
    int64_t _70;
    // Computing bound for c
    int64_t _71;
    // Computing bound for c
    int64_t _72 = 109;
    if (_72 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    _71 = 0;
    int64_t _73 = 0; // c
    _jump27:; // Begin body of loop
    _71 += _73;
    _73++;
    if (_73 < _72)
    goto _jump27;
    // End body of loop
    if (_71 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    // Computing bound for d
    if (_69 > 0) 
    goto _jump29;
    fail_assertion("non-positive loop bound");
    _jump29:;
    _70 = 0;
    int64_t _74 = 0; // d
    int64_t _75 = 0; // c
    _jump30:; // Begin body of loop
    _70 += _75;
    _74++;
    if (_74 < _69)
    goto _jump30;
    _74 = 0;
    _75++;
    if (_75 < _71)
    goto _jump30;
    // End body of loop
    _67 += _70;
    _69++;
    if (_69 < _68)
    goto _jump25;
    // End body of loop
    if (_67 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    _66 = 0;
    int64_t _76 = 0; // b
    _jump32:; // Begin body of loop
    double _77 = 34.0;
    double _78 = -_77;
    int64_t _79 = 156;
    int64_t _80 = -_79;
    a _81 = { _78, _80 };
    int64_t _82 = _81.b;
    _66 += _82;
    _76++;
    if (_76 < _67)
    goto _jump32;
    // End body of loop
    double _84 = 28.0;
    double _85 = 85.0;
    bool _86 = _84 != _85;
    bool _83 = _86;
    if (0 == _86)
    goto _jump33;
    bool _87 = false;
    _83 = _87;
    _jump33:;
    bool _88;
    if (!_83)
    goto _jump34;
    bool _90 = true;
    bool _91 = !_90;
    bool _89 = _91;
    if (0 == _91)
    goto _jump35;
    bool _92 = false;
    bool _93 = !_92;
    _89 = _93;
    _jump35:;
    _88 = _89;
    goto _jump36;
    _jump34:;
    bool _94 = true;
    bool _95 = !_94;
    _88 = _95;
    _jump36:;
    int64_t _96;
    if (!_88)
    goto _jump37;
    int64_t _97 = 120;
    _96 = _97;
    goto _jump38;
    _jump37:;
    int64_t _98 = 334;
    _96 = _98;
    _jump38:;
    int64_t _99 = _66 * _96;
    _65.d0 = _99;
    if (_99 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    // Computing bound for c
    int64_t _100 = 721;
    _65.d1 = _100;
    if (_100 > 0) 
    goto _jump40;
    fail_assertion("non-positive loop bound");
    _jump40:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _99;
    _101 *= _100;
    _101 *= sizeof(rgba);
    _65.data = jpl_alloc(_101);
    int64_t _102 = 0; // c
    int64_t _103 = 0; // b
    _jump41:; // Begin body of loop
    _a3_double _104;
    // Computing bound for d
    int64_t _105 = 196;
    _104.d0 = _105;
    if (_105 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    // Computing bound for e
    int64_t _106 = 589;
    _104.d1 = _106;
    if (_106 > 0) 
    goto _jump43;
    fail_assertion("non-positive loop bound");
    _jump43:;
    // Computing bound for f
    _104.d2 = _103;
    if (_103 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= _105;
    _107 *= _106;
    _107 *= _103;
    _107 *= sizeof(double);
    _104.data = jpl_alloc(_107);
    int64_t _108 = 0; // f
    int64_t _109 = 0; // e
    int64_t _110 = 0; // d
    _jump45:; // Begin body of loop
    bool _111 = _110 != _109;
    double _112;
    if (!_111)
    goto _jump46;
    double _113;
    // Computing bound for g
    int64_t _114 = 550;
    if (_114 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    _113 = 0;
    int64_t _115 = 0; // g
    _jump48:; // Begin body of loop
    double _116 = 55.0;
    _113 += _116;
    _115++;
    if (_115 < _114)
    goto _jump48;
    // End body of loop
    _112 = _113;
    goto _jump49;
    _jump46:;
    double _117 = 26.0;
    _112 = _117;
    _jump49:;
    int64_t _118 = 0;
    _118 *= _104.d0;
    _118 += _110;
    _118 *= _104.d1;
    _118 += _109;
    _118 *= _104.d2;
    _118 += _108;
    _104.data[_118] = _112;
    _108++;
    if (_108 < _103)
    goto _jump45;
    _108 = 0;
    _109++;
    if (_109 < _106)
    goto _jump45;
    _109 = 0;
    _110++;
    if (_110 < _105)
    goto _jump45;
    // End body of loop
    int64_t _119;
    // Computing bound for d
    if (_102 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    _119 = 0;
    int64_t _120 = 0; // d
    _jump51:; // Begin body of loop
    int64_t _121;
    // Computing bound for e
    int64_t _122 = 734;
    if (_122 > 0) 
    goto _jump52;
    fail_assertion("non-positive loop bound");
    _jump52:;
    // Computing bound for f
    if (_102 > 0) 
    goto _jump53;
    fail_assertion("non-positive loop bound");
    _jump53:;
    _121 = 0;
    int64_t _123 = 0; // f
    int64_t _124 = 0; // e
    _jump54:; // Begin body of loop
    int64_t _125 = 249;
    _121 += _125;
    _123++;
    if (_123 < _102)
    goto _jump54;
    _123 = 0;
    _124++;
    if (_124 < _122)
    goto _jump54;
    // End body of loop
    _119 += _121;
    _120++;
    if (_120 < _102)
    goto _jump51;
    // End body of loop
    int64_t _126 = _119 + _103;
    int64_t _127 = -_102;
    int64_t _128 = -_102;
    int64_t _129 = _127 % _128;
    if (_126 >= 0)
    goto _jump55;
    fail_assertion("negative array index");
    _jump55:;
    if (_126 < _104.d0)
    goto _jump56;
    fail_assertion("index too large");
    _jump56:;
    if (_129 >= 0)
    goto _jump57;
    fail_assertion("negative array index");
    _jump57:;
    if (_129 < _104.d1)
    goto _jump58;
    fail_assertion("index too large");
    _jump58:;
    if (_103 >= 0)
    goto _jump59;
    fail_assertion("negative array index");
    _jump59:;
    if (_103 < _104.d2)
    goto _jump60;
    fail_assertion("index too large");
    _jump60:;
    int64_t _130 = 0;
    _130 *= _104.d0;
    _130 += _126;
    _130 *= _104.d1;
    _130 += _129;
    _130 *= _104.d2;
    _130 += _103;
    double _131 = _104.data[_130];
    double _132;
    // Computing bound for d
    int64_t _133;
    // Computing bound for d
    int64_t _134 = 275;
    if (_134 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    _133 = 0;
    int64_t _135 = 0; // d
    _jump62:; // Begin body of loop
    _133 += _103;
    _135++;
    if (_135 < _134)
    goto _jump62;
    // End body of loop
    if (_133 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    _132 = 0;
    int64_t _136 = 0; // d
    _jump64:; // Begin body of loop
    double _137 = 33.0;
    double _138 = 64.0;
    double _139 = _137 + _138;
    _132 += _139;
    _136++;
    if (_136 < _133)
    goto _jump64;
    // End body of loop
    _a2_double _140;
    // Computing bound for d
    _140.d0 = _103;
    if (_103 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing bound for e
    int64_t _141 = 77;
    _140.d1 = _141;
    if (_141 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= _103;
    _142 *= _141;
    _142 *= sizeof(double);
    _140.data = jpl_alloc(_142);
    int64_t _143 = 0; // e
    int64_t _144 = 0; // d
    _jump67:; // Begin body of loop
    double _145 = 27.0;
    int64_t _146 = 0;
    _146 *= _140.d0;
    _146 += _144;
    _146 *= _140.d1;
    _146 += _143;
    _140.data[_146] = _145;
    _143++;
    if (_143 < _141)
    goto _jump67;
    _143 = 0;
    _144++;
    if (_144 < _103)
    goto _jump67;
    // End body of loop
    if (_103 >= 0)
    goto _jump68;
    fail_assertion("negative array index");
    _jump68:;
    if (_103 < _140.d0)
    goto _jump69;
    fail_assertion("index too large");
    _jump69:;
    if (_102 >= 0)
    goto _jump70;
    fail_assertion("negative array index");
    _jump70:;
    if (_102 < _140.d1)
    goto _jump71;
    fail_assertion("index too large");
    _jump71:;
    int64_t _147 = 0;
    _147 *= _140.d0;
    _147 += _103;
    _147 *= _140.d1;
    _147 += _102;
    double _148 = _140.data[_147];
    _a1_double _149;
    _149.d0 = 2;
    _149.data = jpl_alloc(sizeof(double) * 2);
    _149.data[0] = _132;
    _149.data[1] = _148;
    int64_t _150;
    // Computing bound for d
    int64_t _151;
    // Computing bound for d
    int64_t _152 = -_103;
    if (_152 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing bound for e
    if (_103 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    // Computing bound for f
    if (_103 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    _151 = 0;
    int64_t _153 = 0; // f
    int64_t _154 = 0; // e
    int64_t _155 = 0; // d
    _jump75:; // Begin body of loop
    _151 += _155;
    _153++;
    if (_153 < _103)
    goto _jump75;
    _153 = 0;
    _154++;
    if (_154 < _103)
    goto _jump75;
    _154 = 0;
    _155++;
    if (_155 < _152)
    goto _jump75;
    // End body of loop
    if (_151 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    _150 = 0;
    int64_t _156 = 0; // d
    _jump77:; // Begin body of loop
    int64_t _157 = -_102;
    _150 += _157;
    _156++;
    if (_156 < _151)
    goto _jump77;
    // End body of loop
    if (_150 >= 0)
    goto _jump78;
    fail_assertion("negative array index");
    _jump78:;
    if (_150 < _149.d0)
    goto _jump79;
    fail_assertion("index too large");
    _jump79:;
    int64_t _158 = 0;
    _158 *= _149.d0;
    _158 += _150;
    double _159 = _149.data[_158];
    _a3_double _160;
    // Computing bound for d
    int64_t _161 = 580;
    int64_t _162 = -_161;
    _160.d0 = _162;
    if (_162 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    // Computing bound for e
    bool _163 = true;
    int64_t _164;
    if (!_163)
    goto _jump81;
    _164 = _102;
    goto _jump82;
    _jump81:;
    _164 = _102;
    _jump82:;
    _160.d1 = _164;
    if (_164 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    // Computing bound for f
    _a2_int64_t _165;
    // Computing bound for d
    int64_t _166 = 183;
    _165.d0 = _166;
    if (_166 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    // Computing bound for e
    int64_t _167 = 878;
    _165.d1 = _167;
    if (_167 > 0) 
    goto _jump85;
    fail_assertion("non-positive loop bound");
    _jump85:;
    // Computing total size of heap memory to allocate
    int64_t _168 = 1;
    _168 *= _166;
    _168 *= _167;
    _168 *= sizeof(int64_t);
    _165.data = jpl_alloc(_168);
    int64_t _169 = 0; // e
    int64_t _170 = 0; // d
    _jump86:; // Begin body of loop
    int64_t _171 = 664;
    int64_t _172 = 0;
    _172 *= _165.d0;
    _172 += _170;
    _172 *= _165.d1;
    _172 += _169;
    _165.data[_172] = _171;
    _169++;
    if (_169 < _167)
    goto _jump86;
    _169 = 0;
    _170++;
    if (_170 < _166)
    goto _jump86;
    // End body of loop
    int64_t _173 = 167;
    int64_t _174 = 749;
    if (_173 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_173 < _165.d0)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    if (_174 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (_174 < _165.d1)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    int64_t _175 = 0;
    _175 *= _165.d0;
    _175 += _173;
    _175 *= _165.d1;
    _175 += _174;
    int64_t _176 = _165.data[_175];
    _160.d2 = _176;
    if (_176 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _162;
    _177 *= _164;
    _177 *= _176;
    _177 *= sizeof(double);
    _160.data = jpl_alloc(_177);
    int64_t _178 = 0; // f
    int64_t _179 = 0; // e
    int64_t _180 = 0; // d
    _jump92:; // Begin body of loop
    bool _181 = true;
    double _182;
    if (!_181)
    goto _jump93;
    double _183 = 3.0;
    _182 = _183;
    goto _jump94;
    _jump93:;
    double _184 = 68.0;
    _182 = _184;
    _jump94:;
    int64_t _185 = 0;
    _185 *= _160.d0;
    _185 += _180;
    _185 *= _160.d1;
    _185 += _179;
    _185 *= _160.d2;
    _185 += _178;
    _160.data[_185] = _182;
    _178++;
    if (_178 < _176)
    goto _jump92;
    _178 = 0;
    _179++;
    if (_179 < _164)
    goto _jump92;
    _179 = 0;
    _180++;
    if (_180 < _162)
    goto _jump92;
    // End body of loop
    double _186 = 9.0;
    double _187 = -_186;
    bool _188 = true;
    int64_t _189;
    if (!_188)
    goto _jump95;
    int64_t _190 = 645;
    _189 = _190;
    goto _jump96;
    _jump95:;
    _189 = _103;
    _jump96:;
    a _191 = { _187, _189 };
    int64_t _192 = _191.b;
    int64_t _193 = 56;
    _a1_int64_t _194;
    // Computing bound for d
    int64_t _195 = 504;
    _194.d0 = _195;
    if (_195 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= _195;
    _196 *= sizeof(int64_t);
    _194.data = jpl_alloc(_196);
    int64_t _197 = 0; // d
    _jump98:; // Begin body of loop
    int64_t _198 = _197 % _197;
    int64_t _199 = 0;
    _199 *= _194.d0;
    _199 += _197;
    _194.data[_199] = _198;
    _197++;
    if (_197 < _195)
    goto _jump98;
    // End body of loop
    if (_103 >= 0)
    goto _jump99;
    fail_assertion("negative array index");
    _jump99:;
    if (_103 < _194.d0)
    goto _jump100;
    fail_assertion("index too large");
    _jump100:;
    int64_t _200 = 0;
    _200 *= _194.d0;
    _200 += _103;
    int64_t _201 = _194.data[_200];
    if (_192 >= 0)
    goto _jump101;
    fail_assertion("negative array index");
    _jump101:;
    if (_192 < _160.d0)
    goto _jump102;
    fail_assertion("index too large");
    _jump102:;
    if (_193 >= 0)
    goto _jump103;
    fail_assertion("negative array index");
    _jump103:;
    if (_193 < _160.d1)
    goto _jump104;
    fail_assertion("index too large");
    _jump104:;
    if (_201 >= 0)
    goto _jump105;
    fail_assertion("negative array index");
    _jump105:;
    if (_201 < _160.d2)
    goto _jump106;
    fail_assertion("index too large");
    _jump106:;
    int64_t _202 = 0;
    _202 *= _160.d0;
    _202 += _192;
    _202 *= _160.d1;
    _202 += _193;
    _202 *= _160.d2;
    _202 += _201;
    double _203 = _160.data[_202];
    double _204 = 31.0;
    rgba _205 = { _131, _159, _203, _204 };
    int64_t _206 = 0;
    _206 *= _65.d0;
    _206 += _103;
    _206 *= _65.d1;
    _206 += _102;
    _65.data[_206] = _205;
    _102++;
    if (_102 < _100)
    goto _jump41;
    _102 = 0;
    _103++;
    if (_103 < _99)
    goto _jump41;
    // End body of loop
    _64 = _65;
    goto _jump107;
    _jump23:;
    _a2_rgba _207;
    // Computing bound for b
    int64_t _208 = 99;
    _207.d0 = _208;
    if (_208 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    // Computing bound for c
    bool _209 = false;
    bool _210 = !_209;
    bool _211;
    if (!_210)
    goto _jump109;
    bool _212 = false;
    bool _213 = !_212;
    _211 = _213;
    goto _jump110;
    _jump109:;
    bool _214 = false;
    bool _215;
    if (!_214)
    goto _jump111;
    bool _216 = true;
    bool _217;
    if (!_216)
    goto _jump112;
    bool _218 = true;
    _217 = _218;
    goto _jump113;
    _jump112:;
    bool _219 = false;
    _217 = _219;
    _jump113:;
    _215 = _217;
    goto _jump114;
    _jump111:;
    bool _220 = false;
    _215 = _220;
    _jump114:;
    _211 = _215;
    _jump110:;
    int64_t _221 = 578;
    int64_t _222 = 147;
    int64_t _223 = -_222;
    bool _224 = _221 <= _223;
    bool _225 = false;
    bool _226 = _224 == _225;
    bool _227 = _211 == _226;
    int64_t _228;
    if (!_227)
    goto _jump115;
    bool _229 = false;
    int64_t _230;
    if (!_229)
    goto _jump116;
    int64_t _231 = 966;
    _230 = _231;
    goto _jump117;
    _jump116:;
    int64_t _232 = 983;
    int64_t _233 = 811;
    int64_t _234 = -_233;
    bool _235 = _232 < _234;
    int64_t _236;
    if (!_235)
    goto _jump118;
    int64_t _237 = 402;
    int64_t _238 = -_237;
    int64_t _239 = 81;
    int64_t _240 = _238 / _239;
    _236 = _240;
    goto _jump119;
    _jump118:;
    int64_t _241 = 863;
    _236 = _241;
    _jump119:;
    _230 = _236;
    _jump117:;
    _228 = _230;
    goto _jump120;
    _jump115:;
    int64_t _242 = 490;
    double _243 = 19.0;
    int64_t _244 = 841;
    a _245 = { _243, _244 };
    int64_t _246 = _245.b;
    int64_t _247 = _242 + _246;
    int64_t _248 = 993;
    int64_t _249 = _247 / _248;
    _228 = _249;
    _jump120:;
    _207.d1 = _228;
    if (_228 > 0) 
    goto _jump121;
    fail_assertion("non-positive loop bound");
    _jump121:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= _208;
    _250 *= _228;
    _250 *= sizeof(rgba);
    _207.data = jpl_alloc(_250);
    int64_t _251 = 0; // c
    int64_t _252 = 0; // b
    _jump122:; // Begin body of loop
    int64_t _253 = 309;
    bool _254 = _252 < _253;
    double _255;
    if (!_254)
    goto _jump123;
    double _256 = 63.0;
    double _257 = 82.0;
    a _258 = { _257, _251 };
    double _259 = _258.a;
    double _260 = _256 / _259;
    _255 = _260;
    goto _jump124;
    _jump123:;
    double _261 = 52.0;
    double _262 = -_261;
    _255 = _262;
    _jump124:;
    bool _263 = false;
    bool _264;
    if (!_263)
    goto _jump125;
    int64_t _265;
    // Computing bound for d
    int64_t _266 = 368;
    if (_266 > 0) 
    goto _jump126;
    fail_assertion("non-positive loop bound");
    _jump126:;
    // Computing bound for e
    int64_t _267 = 688;
    if (_267 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    _265 = 0;
    int64_t _268 = 0; // e
    int64_t _269 = 0; // d
    _jump128:; // Begin body of loop
    _265 += _251;
    _268++;
    if (_268 < _267)
    goto _jump128;
    _268 = 0;
    _269++;
    if (_269 < _266)
    goto _jump128;
    // End body of loop
    int64_t _270 = 513;
    int64_t _271 = -_270;
    bool _272 = _265 == _271;
    _264 = _272;
    goto _jump129;
    _jump125:;
    _a1_bool _273;
    // Computing bound for d
    int64_t _274 = 154;
    _273.d0 = _274;
    if (_274 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing total size of heap memory to allocate
    int64_t _275 = 1;
    _275 *= _274;
    _275 *= sizeof(bool);
    _273.data = jpl_alloc(_275);
    int64_t _276 = 0; // d
    _jump131:; // Begin body of loop
    bool _277 = true;
    int64_t _278 = 0;
    _278 *= _273.d0;
    _278 += _276;
    _273.data[_278] = _277;
    _276++;
    if (_276 < _274)
    goto _jump131;
    // End body of loop
    int64_t _279;
    // Computing bound for d
    if (_251 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    // Computing bound for e
    if (_251 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    _279 = 0;
    int64_t _280 = 0; // e
    int64_t _281 = 0; // d
    _jump134:; // Begin body of loop
    _279 += _280;
    _280++;
    if (_280 < _251)
    goto _jump134;
    _280 = 0;
    _281++;
    if (_281 < _251)
    goto _jump134;
    // End body of loop
    if (_279 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_279 < _273.d0)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    int64_t _282 = 0;
    _282 *= _273.d0;
    _282 += _279;
    bool _283 = _273.data[_282];
    _264 = _283;
    _jump129:;
    double _284;
    if (!_264)
    goto _jump137;
    double _285 = 40.0;
    double _286 = 67.0;
    bool _287 = _285 < _286;
    double _288;
    if (!_287)
    goto _jump138;
    double _289 = 88.0;
    a _290 = { _289, _251 };
    double _291 = _290.a;
    _288 = _291;
    goto _jump139;
    _jump138:;
    double _292 = 16.0;
    a _293 = { _292, _251 };
    double _294 = _293.a;
    _288 = _294;
    _jump139:;
    _284 = _288;
    goto _jump140;
    _jump137:;
    double _295;
    // Computing bound for d
    if (_252 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    _295 = 0;
    int64_t _296 = 0; // d
    _jump142:; // Begin body of loop
    double _297 = 84.0;
    _295 += _297;
    _296++;
    if (_296 < _252)
    goto _jump142;
    // End body of loop
    double _298;
    // Computing bound for d
    int64_t _299 = 498;
    if (_299 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing bound for e
    if (_251 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    _298 = 0;
    int64_t _300 = 0; // e
    int64_t _301 = 0; // d
    _jump145:; // Begin body of loop
    double _302 = 39.0;
    _298 += _302;
    _300++;
    if (_300 < _251)
    goto _jump145;
    _300 = 0;
    _301++;
    if (_301 < _299)
    goto _jump145;
    // End body of loop
    double _303 = _295 / _298;
    _284 = _303;
    _jump140:;
    double _304;
    // Computing bound for d
    int64_t _305 = -_252;
    if (_305 > 0) 
    goto _jump146;
    fail_assertion("non-positive loop bound");
    _jump146:;
    // Computing bound for e
    int64_t _306 = 167;
    if (_306 > 0) 
    goto _jump147;
    fail_assertion("non-positive loop bound");
    _jump147:;
    // Computing bound for f
    int64_t _307 = 317;
    if (_307 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    _304 = 0;
    int64_t _308 = 0; // f
    int64_t _309 = 0; // e
    int64_t _310 = 0; // d
    _jump149:; // Begin body of loop
    double _311 = 55.0;
    double _312 = -_311;
    _304 += _312;
    _308++;
    if (_308 < _307)
    goto _jump149;
    _308 = 0;
    _309++;
    if (_309 < _306)
    goto _jump149;
    _309 = 0;
    _310++;
    if (_310 < _305)
    goto _jump149;
    // End body of loop
    double _313 = 51.0;
    _a1_double _314;
    _314.d0 = 2;
    _314.data = jpl_alloc(sizeof(double) * 2);
    _314.data[0] = _304;
    _314.data[1] = _313;
    if (_251 >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (_251 < _314.d0)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    int64_t _315 = 0;
    _315 *= _314.d0;
    _315 += _251;
    double _316 = _314.data[_315];
    double _317;
    // Computing bound for d
    if (_252 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing bound for e
    if (_251 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    // Computing bound for f
    if (_251 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    _317 = 0;
    int64_t _318 = 0; // f
    int64_t _319 = 0; // e
    int64_t _320 = 0; // d
    _jump155:; // Begin body of loop
    double _321 = 32.0;
    double _322 = 19.0;
    double _323 = -_322;
    double _324 = 21.0;
    double _325 = -_324;
    double _326;
    // Computing bound for g
    if (_318 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing bound for h
    if (_320 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    _326 = 0;
    int64_t _327 = 0; // h
    int64_t _328 = 0; // g
    _jump158:; // Begin body of loop
    double _329 = 97.0;
    _326 += _329;
    _327++;
    if (_327 < _320)
    goto _jump158;
    _327 = 0;
    _328++;
    if (_328 < _318)
    goto _jump158;
    // End body of loop
    rgba _330 = { _321, _323, _325, _326 };
    double _331 = _330.g;
    _317 += _331;
    _318++;
    if (_318 < _251)
    goto _jump155;
    _318 = 0;
    _319++;
    if (_319 < _251)
    goto _jump155;
    _319 = 0;
    _320++;
    if (_320 < _252)
    goto _jump155;
    // End body of loop
    rgba _332 = { _255, _284, _316, _317 };
    int64_t _333 = 0;
    _333 *= _207.d0;
    _333 += _252;
    _333 *= _207.d1;
    _333 += _251;
    _207.data[_333] = _332;
    _251++;
    if (_251 < _228)
    goto _jump122;
    _251 = 0;
    _252++;
    if (_252 < _208)
    goto _jump122;
    // End body of loop
    _64 = _207;
    _jump107:;
    write_image(_64, "b.png");
    bool _336 = false;
    bool _337 = !_336;
    bool _338 = !_337;
    bool _339 = !_338;
    bool _335 = _339;
    if (0 == _339)
    goto _jump159;
    double _340 = 23.0;
    int64_t _341 = 574;
    a _342 = { _340, _341 };
    double _343 = _342.a;
    double _344 = 5.0;
    bool _345 = _343 == _344;
    bool _346;
    if (!_345)
    goto _jump160;
    bool _347 = true;
    bool _348 = !_347;
    _346 = _348;
    goto _jump161;
    _jump160:;
    double _349 = 54.0;
    double _350 = 82.0;
    bool _351 = _349 >= _350;
    bool _352 = !_351;
    _346 = _352;
    _jump161:;
    _335 = _346;
    _jump159:;
    bool _353;
    if (!_335)
    goto _jump162;
    bool _354 = true;
    int64_t _355 = 248;
    int64_t _356 = 316;
    bool _357 = _355 >= _356;
    bool _358 = !_357;
    bool _359 = _354 == _358;
    _a1_bool _360;
    if (!_359)
    goto _jump163;
    _a1_bool _361;
    // Computing bound for b
    int64_t _362 = 881;
    int64_t _363 = -_362;
    int64_t _364 = 195;
    int64_t _365 = _363 + _364;
    _361.d0 = _365;
    if (_365 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing total size of heap memory to allocate
    int64_t _366 = 1;
    _366 *= _365;
    _366 *= sizeof(bool);
    _361.data = jpl_alloc(_366);
    int64_t _367 = 0; // b
    _jump165:; // Begin body of loop
    bool _368 = false;
    bool _369 = !_368;
    bool _370 = !_369;
    int64_t _371 = 0;
    _371 *= _361.d0;
    _371 += _367;
    _361.data[_371] = _370;
    _367++;
    if (_367 < _365)
    goto _jump165;
    // End body of loop
    _360 = _361;
    goto _jump166;
    _jump163:;
    _a1_bool _372;
    // Computing bound for b
    int64_t _373;
    // Computing bound for b
    int64_t _374 = 424;
    if (_374 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing bound for c
    int64_t _375 = 703;
    if (_375 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    // Computing bound for d
    int64_t _376 = 514;
    if (_376 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    _373 = 0;
    int64_t _377 = 0; // d
    int64_t _378 = 0; // c
    int64_t _379 = 0; // b
    _jump170:; // Begin body of loop
    int64_t _380;
    // Computing bound for e
    if (_378 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing bound for f
    if (_377 > 0) 
    goto _jump172;
    fail_assertion("non-positive loop bound");
    _jump172:;
    _380 = 0;
    int64_t _381 = 0; // f
    int64_t _382 = 0; // e
    _jump173:; // Begin body of loop
    _380 += _377;
    _381++;
    if (_381 < _377)
    goto _jump173;
    _381 = 0;
    _382++;
    if (_382 < _378)
    goto _jump173;
    // End body of loop
    _373 += _380;
    _377++;
    if (_377 < _376)
    goto _jump170;
    _377 = 0;
    _378++;
    if (_378 < _375)
    goto _jump170;
    _378 = 0;
    _379++;
    if (_379 < _374)
    goto _jump170;
    // End body of loop
    _372.d0 = _373;
    if (_373 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    // Computing total size of heap memory to allocate
    int64_t _383 = 1;
    _383 *= _373;
    _383 *= sizeof(bool);
    _372.data = jpl_alloc(_383);
    int64_t _384 = 0; // b
    _jump175:; // Begin body of loop
    bool _385 = false;
    int64_t _386 = 0;
    _386 *= _372.d0;
    _386 += _384;
    _372.data[_386] = _385;
    _384++;
    if (_384 < _373)
    goto _jump175;
    // End body of loop
    _360 = _372;
    _jump166:;
    int64_t _387 = 255;
    int64_t _388 = -_387;
    if (_388 >= 0)
    goto _jump176;
    fail_assertion("negative array index");
    _jump176:;
    if (_388 < _360.d0)
    goto _jump177;
    fail_assertion("index too large");
    _jump177:;
    int64_t _389 = 0;
    _389 *= _360.d0;
    _389 += _388;
    bool _390 = _360.data[_389];
    _353 = _390;
    goto _jump178;
    _jump162:;
    bool _391 = false;
    _353 = _391;
    _jump178:;
    bool _334 = _353;
    if (0 != _353)
    goto _jump179;
    int64_t _392 = 126;
    _a3_int64_t _393;
    // Computing bound for b
    int64_t _394 = 690;
    _393.d0 = _394;
    if (_394 > 0) 
    goto _jump180;
    fail_assertion("non-positive loop bound");
    _jump180:;
    // Computing bound for c
    int64_t _395 = 22;
    int64_t _396 = -_395;
    int64_t _397 = -_396;
    _393.d1 = _397;
    if (_397 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing bound for d
    int64_t _398 = 97;
    int64_t _399 = 457;
    int64_t _400 = -_399;
    int64_t _401 = _398 / _400;
    _393.d2 = _401;
    if (_401 > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing total size of heap memory to allocate
    int64_t _402 = 1;
    _402 *= _394;
    _402 *= _397;
    _402 *= _401;
    _402 *= sizeof(int64_t);
    _393.data = jpl_alloc(_402);
    int64_t _403 = 0; // d
    int64_t _404 = 0; // c
    int64_t _405 = 0; // b
    _jump183:; // Begin body of loop
    int64_t _406;
    // Computing bound for e
    if (_404 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing bound for f
    if (_404 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing bound for g
    int64_t _407 = 128;
    if (_407 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    _406 = 0;
    int64_t _408 = 0; // g
    int64_t _409 = 0; // f
    int64_t _410 = 0; // e
    _jump187:; // Begin body of loop
    _406 += _408;
    _408++;
    if (_408 < _407)
    goto _jump187;
    _408 = 0;
    _409++;
    if (_409 < _404)
    goto _jump187;
    _409 = 0;
    _410++;
    if (_410 < _404)
    goto _jump187;
    // End body of loop
    int64_t _411 = -_406;
    int64_t _412 = 0;
    _412 *= _393.d0;
    _412 += _405;
    _412 *= _393.d1;
    _412 += _404;
    _412 *= _393.d2;
    _412 += _403;
    _393.data[_412] = _411;
    _403++;
    if (_403 < _401)
    goto _jump183;
    _403 = 0;
    _404++;
    if (_404 < _397)
    goto _jump183;
    _404 = 0;
    _405++;
    if (_405 < _394)
    goto _jump183;
    // End body of loop
    int64_t _413 = 861;
    int64_t _414 = 439;
    int64_t _415 = 266;
    if (_413 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (_413 < _393.d0)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    if (_414 >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (_414 < _393.d1)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    if (_415 >= 0)
    goto _jump192;
    fail_assertion("negative array index");
    _jump192:;
    if (_415 < _393.d2)
    goto _jump193;
    fail_assertion("index too large");
    _jump193:;
    int64_t _416 = 0;
    _416 *= _393.d0;
    _416 += _413;
    _416 *= _393.d1;
    _416 += _414;
    _416 *= _393.d2;
    _416 += _415;
    int64_t _417 = _393.data[_416];
    bool _418 = _392 != _417;
    bool _419;
    if (!_418)
    goto _jump194;
    bool _421 = true;
    bool _420 = _421;
    if (0 == _421)
    goto _jump195;
    bool _422 = false;
    bool _423 = !_422;
    _420 = _423;
    _jump195:;
    _419 = _420;
    goto _jump196;
    _jump194:;
    double _424 = 63.0;
    double _425 = -_424;
    double _426 = 21.0;
    double _427 = -_426;
    _a1_double _428;
    _428.d0 = 1;
    _428.data = jpl_alloc(sizeof(double) * 1);
    _428.data[0] = _427;
    int64_t _429 = 331;
    if (_429 >= 0)
    goto _jump197;
    fail_assertion("negative array index");
    _jump197:;
    if (_429 < _428.d0)
    goto _jump198;
    fail_assertion("index too large");
    _jump198:;
    int64_t _430 = 0;
    _430 *= _428.d0;
    _430 += _429;
    double _431 = _428.data[_430];
    double _432 = -_431;
    bool _433 = _425 < _432;
    _419 = _433;
    _jump196:;
    _334 = _419;
    _jump179:;
    if (0 != _334)
    goto _jump199;
    fail_assertion("b");
    _jump199:;
    _a3__a2__a1_int64_t _434;
    // Computing bound for b
    bool _435 = true;
    a _436;
    if (!_435)
    goto _jump200;
    _a1_a _437;
    // Computing bound for b
    int64_t _438 = 128;
    _437.d0 = _438;
    if (_438 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing total size of heap memory to allocate
    int64_t _439 = 1;
    _439 *= _438;
    _439 *= sizeof(a);
    _437.data = jpl_alloc(_439);
    int64_t _440 = 0; // b
    _jump202:; // Begin body of loop
    double _441 = 21.0;
    a _442 = { _441, _440 };
    int64_t _443 = 0;
    _443 *= _437.d0;
    _443 += _440;
    _437.data[_443] = _442;
    _440++;
    if (_440 < _438)
    goto _jump202;
    // End body of loop
    bool _444 = false;
    int64_t _445;
    if (!_444)
    goto _jump203;
    int64_t _446 = 884;
    int64_t _447 = -_446;
    _445 = _447;
    goto _jump204;
    _jump203:;
    int64_t _448 = 349;
    int64_t _449 = -_448;
    _445 = _449;
    _jump204:;
    if (_445 >= 0)
    goto _jump205;
    fail_assertion("negative array index");
    _jump205:;
    if (_445 < _437.d0)
    goto _jump206;
    fail_assertion("index too large");
    _jump206:;
    int64_t _450 = 0;
    _450 *= _437.d0;
    _450 += _445;
    a _451 = _437.data[_450];
    _436 = _451;
    goto _jump207;
    _jump200:;
    bool _452 = false;
    double _453;
    if (!_452)
    goto _jump208;
    double _454 = 45.0;
    _453 = _454;
    goto _jump209;
    _jump208:;
    double _455 = 43.0;
    _453 = _455;
    _jump209:;
    double _456 = -_453;
    int64_t _457 = 3;
    int64_t _458 = -_457;
    a _459 = { _456, _458 };
    _436 = _459;
    _jump207:;
    int64_t _460 = _436.b;
    _434.d0 = _460;
    if (_460 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for c
    int64_t _461 = 985;
    _434.d1 = _461;
    if (_461 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for d
    double _462 = 89.0;
    double _463 = -_462;
    int64_t _464 = 883;
    int64_t _465 = 537;
    int64_t _466 = _464 + _465;
    a _467 = { _463, _466 };
    double _468 = _467.a;
    int64_t _469;
    // Computing bound for b
    int64_t _470 = 747;
    if (_470 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for c
    bool _471 = false;
    int64_t _472;
    if (!_471)
    goto _jump213;
    int64_t _473 = 61;
    _472 = _473;
    goto _jump214;
    _jump213:;
    int64_t _474 = 600;
    _472 = _474;
    _jump214:;
    if (_472 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    _469 = 0;
    int64_t _475 = 0; // c
    int64_t _476 = 0; // b
    _jump216:; // Begin body of loop
    int64_t _477 = 382;
    _469 += _477;
    _475++;
    if (_475 < _472)
    goto _jump216;
    _475 = 0;
    _476++;
    if (_476 < _470)
    goto _jump216;
    // End body of loop
    int64_t _478 = -_469;
    a _479 = { _468, _478 };
    int64_t _480 = _479.b;
    _434.d2 = _480;
    if (_480 > 0) 
    goto _jump217;
    fail_assertion("non-positive loop bound");
    _jump217:;
    // Computing total size of heap memory to allocate
    int64_t _481 = 1;
    _481 *= _460;
    _481 *= _461;
    _481 *= _480;
    _481 *= sizeof(_a2__a1_int64_t);
    _434.data = jpl_alloc(_481);
    int64_t _482 = 0; // d
    int64_t _483 = 0; // c
    int64_t _484 = 0; // b
    _jump218:; // Begin body of loop
    _a2__a1_int64_t _485;
    // Computing bound for e
    int64_t _486 = _483 + _484;
    _485.d0 = _486;
    if (_486 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing bound for f
    bool _487 = false;
    int64_t _488;
    if (!_487)
    goto _jump220;
    int64_t _489 = 83;
    int64_t _490 = -_489;
    _488 = _490;
    goto _jump221;
    _jump220:;
    int64_t _491 = 111;
    _488 = _491;
    _jump221:;
    bool _492 = _484 == _482;
    _a2_int64_t _493;
    if (!_492)
    goto _jump222;
    _a2_int64_t _494;
    // Computing bound for e
    _494.d0 = _484;
    if (_484 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing bound for f
    _494.d1 = _484;
    if (_484 > 0) 
    goto _jump224;
    fail_assertion("non-positive loop bound");
    _jump224:;
    // Computing total size of heap memory to allocate
    int64_t _495 = 1;
    _495 *= _484;
    _495 *= _484;
    _495 *= sizeof(int64_t);
    _494.data = jpl_alloc(_495);
    int64_t _496 = 0; // f
    int64_t _497 = 0; // e
    _jump225:; // Begin body of loop
    int64_t _498 = 0;
    _498 *= _494.d0;
    _498 += _497;
    _498 *= _494.d1;
    _498 += _496;
    _494.data[_498] = _496;
    _496++;
    if (_496 < _484)
    goto _jump225;
    _496 = 0;
    _497++;
    if (_497 < _484)
    goto _jump225;
    // End body of loop
    _493 = _494;
    goto _jump226;
    _jump222:;
    _a2_int64_t _499;
    // Computing bound for e
    int64_t _500 = 306;
    _499.d0 = _500;
    if (_500 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing bound for f
    int64_t _501 = 348;
    _499.d1 = _501;
    if (_501 > 0) 
    goto _jump228;
    fail_assertion("non-positive loop bound");
    _jump228:;
    // Computing total size of heap memory to allocate
    int64_t _502 = 1;
    _502 *= _500;
    _502 *= _501;
    _502 *= sizeof(int64_t);
    _499.data = jpl_alloc(_502);
    int64_t _503 = 0; // f
    int64_t _504 = 0; // e
    _jump229:; // Begin body of loop
    int64_t _505 = 0;
    _505 *= _499.d0;
    _505 += _504;
    _505 *= _499.d1;
    _505 += _503;
    _499.data[_505] = _482;
    _503++;
    if (_503 < _501)
    goto _jump229;
    _503 = 0;
    _504++;
    if (_504 < _500)
    goto _jump229;
    // End body of loop
    _493 = _499;
    _jump226:;
    int64_t _506 = 5;
    int64_t _507 = -_506;
    if (_507 >= 0)
    goto _jump230;
    fail_assertion("negative array index");
    _jump230:;
    if (_507 < _493.d0)
    goto _jump231;
    fail_assertion("index too large");
    _jump231:;
    if (_484 >= 0)
    goto _jump232;
    fail_assertion("negative array index");
    _jump232:;
    if (_484 < _493.d1)
    goto _jump233;
    fail_assertion("index too large");
    _jump233:;
    int64_t _508 = 0;
    _508 *= _493.d0;
    _508 += _507;
    _508 *= _493.d1;
    _508 += _484;
    int64_t _509 = _493.data[_508];
    int64_t _510 = _488 - _509;
    _485.d1 = _510;
    if (_510 > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= _486;
    _511 *= _510;
    _511 *= sizeof(_a1_int64_t);
    _485.data = jpl_alloc(_511);
    int64_t _512 = 0; // f
    int64_t _513 = 0; // e
    _jump235:; // Begin body of loop
    _a1_int64_t _514;
    // Computing bound for g
    _514.d0 = _482;
    if (_482 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing total size of heap memory to allocate
    int64_t _515 = 1;
    _515 *= _482;
    _515 *= sizeof(int64_t);
    _514.data = jpl_alloc(_515);
    int64_t _516 = 0; // g
    _jump237:; // Begin body of loop
    int64_t _517 = 0;
    _517 *= _514.d0;
    _517 += _516;
    _514.data[_517] = _483;
    _516++;
    if (_516 < _482)
    goto _jump237;
    // End body of loop
    int64_t _518 = 0;
    _518 *= _485.d0;
    _518 += _513;
    _518 *= _485.d1;
    _518 += _512;
    _485.data[_518] = _514;
    _512++;
    if (_512 < _510)
    goto _jump235;
    _512 = 0;
    _513++;
    if (_513 < _486)
    goto _jump235;
    // End body of loop
    int64_t _519 = 0;
    _519 *= _434.d0;
    _519 += _484;
    _519 *= _434.d1;
    _519 += _483;
    _519 *= _434.d2;
    _519 += _482;
    _434.data[_519] = _485;
    _482++;
    if (_482 < _480)
    goto _jump218;
    _482 = 0;
    _483++;
    if (_483 < _461)
    goto _jump218;
    _483 = 0;
    _484++;
    if (_484 < _460)
    goto _jump218;
    // End body of loop
    bool _520 = false;
    bool _521 = !_520;
    bool _522 = !_521;
    int64_t _523;
    if (!_522)
    goto _jump238;
    int64_t _524 = 558;
    _523 = _524;
    goto _jump239;
    _jump238:;
    int64_t _525 = 491;
    _523 = _525;
    _jump239:;
    int64_t _526 = -_523;
    int64_t _527;
    // Computing bound for b
    int64_t _528;
    // Computing bound for b
    int64_t _529 = 769;
    if (_529 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    _528 = 0;
    int64_t _530 = 0; // b
    _jump241:; // Begin body of loop
    _528 += _530;
    _530++;
    if (_530 < _529)
    goto _jump241;
    // End body of loop
    bool _531 = false;
    int64_t _532;
    if (!_531)
    goto _jump242;
    int64_t _533 = 612;
    _532 = _533;
    goto _jump243;
    _jump242:;
    double _534 = 19.0;
    int64_t _535 = 230;
    a _536 = { _534, _535 };
    int64_t _537 = _536.b;
    _532 = _537;
    _jump243:;
    int64_t _538 = _528 / _532;
    if (_538 > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing bound for c
    int64_t _539 = 402;
    int64_t _540 = -_539;
    if (_540 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing bound for d
    _a3_int64_t _541;
    // Computing bound for b
    int64_t _542;
    // Computing bound for b
    int64_t _543 = 159;
    if (_543 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing bound for c
    int64_t _544 = 723;
    if (_544 > 0) 
    goto _jump247;
    fail_assertion("non-positive loop bound");
    _jump247:;
    _542 = 0;
    int64_t _545 = 0; // c
    int64_t _546 = 0; // b
    _jump248:; // Begin body of loop
    int64_t _547 = 651;
    _542 += _547;
    _545++;
    if (_545 < _544)
    goto _jump248;
    _545 = 0;
    _546++;
    if (_546 < _543)
    goto _jump248;
    // End body of loop
    int64_t _548 = 494;
    int64_t _549 = _542 % _548;
    _541.d0 = _549;
    if (_549 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    // Computing bound for c
    int64_t _550 = 449;
    int64_t _551 = 868;
    int64_t _552 = _550 % _551;
    _541.d1 = _552;
    if (_552 > 0) 
    goto _jump250;
    fail_assertion("non-positive loop bound");
    _jump250:;
    // Computing bound for d
    int64_t _553 = 209;
    _541.d2 = _553;
    if (_553 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing total size of heap memory to allocate
    int64_t _554 = 1;
    _554 *= _549;
    _554 *= _552;
    _554 *= _553;
    _554 *= sizeof(int64_t);
    _541.data = jpl_alloc(_554);
    int64_t _555 = 0; // d
    int64_t _556 = 0; // c
    int64_t _557 = 0; // b
    _jump252:; // Begin body of loop
    int64_t _558 = 760;
    int64_t _559 = 0;
    _559 *= _541.d0;
    _559 += _557;
    _559 *= _541.d1;
    _559 += _556;
    _559 *= _541.d2;
    _559 += _555;
    _541.data[_559] = _558;
    _555++;
    if (_555 < _553)
    goto _jump252;
    _555 = 0;
    _556++;
    if (_556 < _552)
    goto _jump252;
    _556 = 0;
    _557++;
    if (_557 < _549)
    goto _jump252;
    // End body of loop
    _a1_int64_t _560;
    // Computing bound for b
    int64_t _561 = 555;
    _560.d0 = _561;
    if (_561 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    // Computing total size of heap memory to allocate
    int64_t _562 = 1;
    _562 *= _561;
    _562 *= sizeof(int64_t);
    _560.data = jpl_alloc(_562);
    int64_t _563 = 0; // b
    _jump254:; // Begin body of loop
    int64_t _564 = 0;
    _564 *= _560.d0;
    _564 += _563;
    _560.data[_564] = _563;
    _563++;
    if (_563 < _561)
    goto _jump254;
    // End body of loop
    int64_t _565 = 37;
    if (_565 >= 0)
    goto _jump255;
    fail_assertion("negative array index");
    _jump255:;
    if (_565 < _560.d0)
    goto _jump256;
    fail_assertion("index too large");
    _jump256:;
    int64_t _566 = 0;
    _566 *= _560.d0;
    _566 += _565;
    int64_t _567 = _560.data[_566];
    int64_t _568 = -_567;
    int64_t _569 = 138;
    int64_t _570 = -_569;
    int64_t _571 = 42;
    int64_t _572 = _570 * _571;
    int64_t _573 = 78;
    int64_t _574 = 491;
    int64_t _575 = 479;
    int64_t _576 = _574 / _575;
    int64_t _577 = _573 * _576;
    if (_568 >= 0)
    goto _jump257;
    fail_assertion("negative array index");
    _jump257:;
    if (_568 < _541.d0)
    goto _jump258;
    fail_assertion("index too large");
    _jump258:;
    if (_572 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_572 < _541.d1)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    if (_577 >= 0)
    goto _jump261;
    fail_assertion("negative array index");
    _jump261:;
    if (_577 < _541.d2)
    goto _jump262;
    fail_assertion("index too large");
    _jump262:;
    int64_t _578 = 0;
    _578 *= _541.d0;
    _578 += _568;
    _578 *= _541.d1;
    _578 += _572;
    _578 *= _541.d2;
    _578 += _577;
    int64_t _579 = _541.data[_578];
    if (_579 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    _527 = 0;
    int64_t _580 = 0; // d
    int64_t _581 = 0; // c
    int64_t _582 = 0; // b
    _jump264:; // Begin body of loop
    _a3_bool _583;
    // Computing bound for e
    _583.d0 = _581;
    if (_581 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing bound for f
    int64_t _584 = 699;
    _583.d1 = _584;
    if (_584 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing bound for g
    int64_t _585;
    // Computing bound for e
    if (_581 > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    _585 = 0;
    int64_t _586 = 0; // e
    _jump268:; // Begin body of loop
    _585 += _586;
    _586++;
    if (_586 < _581)
    goto _jump268;
    // End body of loop
    _583.d2 = _585;
    if (_585 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    // Computing total size of heap memory to allocate
    int64_t _587 = 1;
    _587 *= _581;
    _587 *= _584;
    _587 *= _585;
    _587 *= sizeof(bool);
    _583.data = jpl_alloc(_587);
    int64_t _588 = 0; // g
    int64_t _589 = 0; // f
    int64_t _590 = 0; // e
    _jump270:; // Begin body of loop
    double _591 = 67.0;
    double _592 = 37.0;
    bool _593 = _591 >= _592;
    int64_t _594 = 0;
    _594 *= _583.d0;
    _594 += _590;
    _594 *= _583.d1;
    _594 += _589;
    _594 *= _583.d2;
    _594 += _588;
    _583.data[_594] = _593;
    _588++;
    if (_588 < _585)
    goto _jump270;
    _588 = 0;
    _589++;
    if (_589 < _584)
    goto _jump270;
    _589 = 0;
    _590++;
    if (_590 < _581)
    goto _jump270;
    // End body of loop
    int64_t _595 = 795;
    int64_t _596 = _581 % _595;
    if (_596 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_596 < _583.d0)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    if (_580 >= 0)
    goto _jump273;
    fail_assertion("negative array index");
    _jump273:;
    if (_580 < _583.d1)
    goto _jump274;
    fail_assertion("index too large");
    _jump274:;
    if (_582 >= 0)
    goto _jump275;
    fail_assertion("negative array index");
    _jump275:;
    if (_582 < _583.d2)
    goto _jump276;
    fail_assertion("index too large");
    _jump276:;
    int64_t _597 = 0;
    _597 *= _583.d0;
    _597 += _596;
    _597 *= _583.d1;
    _597 += _580;
    _597 *= _583.d2;
    _597 += _582;
    bool _598 = _583.data[_597];
    int64_t _599;
    if (!_598)
    goto _jump277;
    int64_t _600 = -_581;
    int64_t _601 = -_600;
    int64_t _602 = -_601;
    _599 = _602;
    goto _jump278;
    _jump277:;
    _a1_int64_t _603;
    _603.d0 = 2;
    _603.data = jpl_alloc(sizeof(int64_t) * 2);
    _603.data[0] = _581;
    _603.data[1] = _581;
    if (_580 >= 0)
    goto _jump279;
    fail_assertion("negative array index");
    _jump279:;
    if (_580 < _603.d0)
    goto _jump280;
    fail_assertion("index too large");
    _jump280:;
    int64_t _604 = 0;
    _604 *= _603.d0;
    _604 += _580;
    int64_t _605 = _603.data[_604];
    bool _606 = false;
    bool _607 = !_606;
    int64_t _608;
    if (!_607)
    goto _jump281;
    int64_t _609 = 177;
    _608 = _609;
    goto _jump282;
    _jump281:;
    int64_t _610 = 597;
    _608 = _610;
    _jump282:;
    int64_t _611 = _605 / _608;
    _599 = _611;
    _jump278:;
    _527 += _599;
    _580++;
    if (_580 < _579)
    goto _jump264;
    _580 = 0;
    _581++;
    if (_581 < _540)
    goto _jump264;
    _581 = 0;
    _582++;
    if (_582 < _538)
    goto _jump264;
    // End body of loop
    int64_t _612 = _526 * _527;
    int64_t _613;
    // Computing bound for b
    int64_t _614;
    // Computing bound for b
    int64_t _615 = 912;
    if (_615 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    _614 = 0;
    int64_t _616 = 0; // b
    _jump284:; // Begin body of loop
    int64_t _617 = 488;
    _614 += _617;
    _616++;
    if (_616 < _615)
    goto _jump284;
    // End body of loop
    if (_614 > 0) 
    goto _jump285;
    fail_assertion("non-positive loop bound");
    _jump285:;
    _613 = 0;
    int64_t _618 = 0; // b
    _jump286:; // Begin body of loop
    _613 += _618;
    _618++;
    if (_618 < _614)
    goto _jump286;
    // End body of loop
    int64_t _619 = 365;
    int64_t _620 = -_619;
    int64_t _621 = _613 / _620;
    int64_t _622;
    // Computing bound for b
    int64_t _623 = 186;
    bool _624 = false;
    int64_t _625;
    if (!_624)
    goto _jump287;
    int64_t _626 = 362;
    _625 = _626;
    goto _jump288;
    _jump287:;
    int64_t _627 = 352;
    _625 = _627;
    _jump288:;
    int64_t _628 = _623 % _625;
    if (_628 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    _622 = 0;
    int64_t _629 = 0; // b
    _jump290:; // Begin body of loop
    _622 += _629;
    _629++;
    if (_629 < _628)
    goto _jump290;
    // End body of loop
    int64_t _630 = _621 / _622;
    double _631 = 34.0;
    double _632 = -_631;
    double _633 = 99.0;
    bool _634 = _632 == _633;
    int64_t _635;
    if (!_634)
    goto _jump291;
    int64_t _636 = 274;
    int64_t _637 = -_636;
    _635 = _637;
    goto _jump292;
    _jump291:;
    double _638 = 51.0;
    int64_t _639 = 408;
    int64_t _640 = -_639;
    a _641 = { _638, _640 };
    int64_t _642 = _641.b;
    _635 = _642;
    _jump292:;
    bool _643 = true;
    bool _644;
    if (!_643)
    goto _jump293;
    bool _645 = true;
    _644 = _645;
    goto _jump294;
    _jump293:;
    bool _646 = false;
    _644 = _646;
    _jump294:;
    a _647;
    if (!_644)
    goto _jump295;
    double _648 = 76.0;
    double _649 = -_648;
    int64_t _650 = 537;
    a _651 = { _649, _650 };
    _647 = _651;
    goto _jump296;
    _jump295:;
    double _652 = 14.0;
    int64_t _653 = 227;
    a _654 = { _652, _653 };
    _647 = _654;
    _jump296:;
    int64_t _655 = _647.b;
    _a1_int64_t _656;
    _656.d0 = 3;
    _656.data = jpl_alloc(sizeof(int64_t) * 3);
    _656.data[0] = _630;
    _656.data[1] = _635;
    _656.data[2] = _655;
    int64_t _657 = 41;
    if (_657 >= 0)
    goto _jump297;
    fail_assertion("negative array index");
    _jump297:;
    if (_657 < _656.d0)
    goto _jump298;
    fail_assertion("index too large");
    _jump298:;
    int64_t _658 = 0;
    _658 *= _656.d0;
    _658 += _657;
    int64_t _659 = _656.data[_658];
    bool _661 = true;
    bool _662;
    if (!_661)
    goto _jump299;
    bool _663 = true;
    bool _664 = !_663;
    _662 = _664;
    goto _jump300;
    _jump299:;
    bool _665 = true;
    _662 = _665;
    _jump300:;
    bool _666 = !_662;
    bool _660 = _666;
    if (0 == _666)
    goto _jump301;
    double _667 = 17.0;
    double _668 = 26.0;
    double _669 = _667 * _668;
    double _670 = 98.0;
    bool _671 = _669 <= _670;
    _660 = _671;
    _jump301:;
    _a2_int64_t _672;
    if (!_660)
    goto _jump302;
    _a2_int64_t _673;
    // Computing bound for b
    int64_t _674;
    // Computing bound for b
    int64_t _675;
    // Computing bound for b
    int64_t _676 = 776;
    int64_t _677 = -_676;
    if (_677 > 0) 
    goto _jump303;
    fail_assertion("non-positive loop bound");
    _jump303:;
    // Computing bound for c
    bool _678 = true;
    int64_t _679;
    if (!_678)
    goto _jump304;
    int64_t _680 = 227;
    _679 = _680;
    goto _jump305;
    _jump304:;
    int64_t _681 = 494;
    _679 = _681;
    _jump305:;
    if (_679 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for d
    int64_t _682 = 328;
    if (_682 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    _675 = 0;
    int64_t _683 = 0; // d
    int64_t _684 = 0; // c
    int64_t _685 = 0; // b
    _jump308:; // Begin body of loop
    _675 += _684;
    _683++;
    if (_683 < _682)
    goto _jump308;
    _683 = 0;
    _684++;
    if (_684 < _679)
    goto _jump308;
    _684 = 0;
    _685++;
    if (_685 < _677)
    goto _jump308;
    // End body of loop
    if (_675 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for c
    int64_t _686 = 158;
    if (_686 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    _674 = 0;
    int64_t _687 = 0; // c
    int64_t _688 = 0; // b
    _jump311:; // Begin body of loop
    _674 += _688;
    _687++;
    if (_687 < _686)
    goto _jump311;
    _687 = 0;
    _688++;
    if (_688 < _675)
    goto _jump311;
    // End body of loop
    _673.d0 = _674;
    if (_674 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for c
    int64_t _689 = 806;
    _673.d1 = _689;
    if (_689 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing total size of heap memory to allocate
    int64_t _690 = 1;
    _690 *= _674;
    _690 *= _689;
    _690 *= sizeof(int64_t);
    _673.data = jpl_alloc(_690);
    int64_t _691 = 0; // c
    int64_t _692 = 0; // b
    _jump314:; // Begin body of loop
    int64_t _693 = 107;
    int64_t _694 = 0;
    _694 *= _673.d0;
    _694 += _692;
    _694 *= _673.d1;
    _694 += _691;
    _673.data[_694] = _693;
    _691++;
    if (_691 < _689)
    goto _jump314;
    _691 = 0;
    _692++;
    if (_692 < _674)
    goto _jump314;
    // End body of loop
    _672 = _673;
    goto _jump315;
    _jump302:;
    _a2_int64_t _695;
    // Computing bound for b
    int64_t _696 = 690;
    _695.d0 = _696;
    if (_696 > 0) 
    goto _jump316;
    fail_assertion("non-positive loop bound");
    _jump316:;
    // Computing bound for c
    int64_t _697;
    // Computing bound for b
    int64_t _698 = 888;
    int64_t _699 = -_698;
    if (_699 > 0) 
    goto _jump317;
    fail_assertion("non-positive loop bound");
    _jump317:;
    _697 = 0;
    int64_t _700 = 0; // b
    _jump318:; // Begin body of loop
    double _701 = 86.0;
    a _702 = { _701, _700 };
    int64_t _703 = _702.b;
    _697 += _703;
    _700++;
    if (_700 < _699)
    goto _jump318;
    // End body of loop
    _695.d1 = _697;
    if (_697 > 0) 
    goto _jump319;
    fail_assertion("non-positive loop bound");
    _jump319:;
    // Computing total size of heap memory to allocate
    int64_t _704 = 1;
    _704 *= _696;
    _704 *= _697;
    _704 *= sizeof(int64_t);
    _695.data = jpl_alloc(_704);
    int64_t _705 = 0; // c
    int64_t _706 = 0; // b
    _jump320:; // Begin body of loop
    int64_t _707;
    // Computing bound for d
    int64_t _708 = 824;
    if (_708 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing bound for e
    int64_t _709 = -_706;
    int64_t _710 = -_709;
    if (_710 > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    _707 = 0;
    int64_t _711 = 0; // e
    int64_t _712 = 0; // d
    _jump323:; // Begin body of loop
    _707 += _711;
    _711++;
    if (_711 < _710)
    goto _jump323;
    _711 = 0;
    _712++;
    if (_712 < _708)
    goto _jump323;
    // End body of loop
    int64_t _713 = 0;
    _713 *= _695.d0;
    _713 += _706;
    _713 *= _695.d1;
    _713 += _705;
    _695.data[_713] = _707;
    _705++;
    if (_705 < _697)
    goto _jump320;
    _705 = 0;
    _706++;
    if (_706 < _696)
    goto _jump320;
    // End body of loop
    _672 = _695;
    _jump315:;
    int64_t _714;
    // Computing bound for b
    int64_t _715 = 239;
    if (_715 > 0) 
    goto _jump324;
    fail_assertion("non-positive loop bound");
    _jump324:;
    // Computing bound for c
    int64_t _716 = 812;
    if (_716 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    _714 = 0;
    int64_t _717 = 0; // c
    int64_t _718 = 0; // b
    _jump326:; // Begin body of loop
    _714 += _717;
    _717++;
    if (_717 < _716)
    goto _jump326;
    _717 = 0;
    _718++;
    if (_718 < _715)
    goto _jump326;
    // End body of loop
    int64_t _719 = 752;
    int64_t _720 = 970;
    int64_t _721 = _719 * _720;
    int64_t _722 = 560;
    int64_t _723 = -_722;
    int64_t _724 = _721 + _723;
    bool _725 = _714 >= _724;
    int64_t _726;
    if (!_725)
    goto _jump327;
    int64_t _727 = 377;
    bool _728 = true;
    _a1_bool _729;
    _729.d0 = 1;
    _729.data = jpl_alloc(sizeof(bool) * 1);
    _729.data[0] = _728;
    int64_t _730 = 872;
    int64_t _731 = -_730;
    if (_731 >= 0)
    goto _jump328;
    fail_assertion("negative array index");
    _jump328:;
    if (_731 < _729.d0)
    goto _jump329;
    fail_assertion("index too large");
    _jump329:;
    int64_t _732 = 0;
    _732 *= _729.d0;
    _732 += _731;
    bool _733 = _729.data[_732];
    int64_t _734;
    if (!_733)
    goto _jump330;
    int64_t _735 = 765;
    _734 = _735;
    goto _jump331;
    _jump330:;
    int64_t _736 = 396;
    _734 = _736;
    _jump331:;
    int64_t _737 = _727 - _734;
    _726 = _737;
    goto _jump332;
    _jump327:;
    bool _738 = false;
    int64_t _739;
    if (!_738)
    goto _jump333;
    int64_t _740 = 51;
    int64_t _741 = -_740;
    int64_t _742 = -_741;
    int64_t _743 = 499;
    int64_t _744 = _742 + _743;
    _739 = _744;
    goto _jump334;
    _jump333:;
    int64_t _745 = 669;
    _739 = _745;
    _jump334:;
    _726 = _739;
    _jump332:;
    int64_t _746;
    // Computing bound for b
    int64_t _747;
    // Computing bound for b
    int64_t _748 = 170;
    if (_748 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    _747 = 0;
    int64_t _749 = 0; // b
    _jump336:; // Begin body of loop
    int64_t _750;
    // Computing bound for c
    int64_t _751 = -_749;
    if (_751 > 0) 
    goto _jump337;
    fail_assertion("non-positive loop bound");
    _jump337:;
    // Computing bound for d
    int64_t _752 = 928;
    int64_t _753 = -_752;
    if (_753 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for e
    int64_t _754 = 746;
    if (_754 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    _750 = 0;
    int64_t _755 = 0; // e
    int64_t _756 = 0; // d
    int64_t _757 = 0; // c
    _jump340:; // Begin body of loop
    _750 += _755;
    _755++;
    if (_755 < _754)
    goto _jump340;
    _755 = 0;
    _756++;
    if (_756 < _753)
    goto _jump340;
    _756 = 0;
    _757++;
    if (_757 < _751)
    goto _jump340;
    // End body of loop
    _747 += _750;
    _749++;
    if (_749 < _748)
    goto _jump336;
    // End body of loop
    if (_747 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    _746 = 0;
    int64_t _758 = 0; // b
    _jump342:; // Begin body of loop
    int64_t _759 = -_758;
    _746 += _759;
    _758++;
    if (_758 < _747)
    goto _jump342;
    // End body of loop
    if (_726 >= 0)
    goto _jump343;
    fail_assertion("negative array index");
    _jump343:;
    if (_726 < _672.d0)
    goto _jump344;
    fail_assertion("index too large");
    _jump344:;
    if (_746 >= 0)
    goto _jump345;
    fail_assertion("negative array index");
    _jump345:;
    if (_746 < _672.d1)
    goto _jump346;
    fail_assertion("index too large");
    _jump346:;
    int64_t _760 = 0;
    _760 *= _672.d0;
    _760 += _726;
    _760 *= _672.d1;
    _760 += _746;
    int64_t _761 = _672.data[_760];
    if (_612 >= 0)
    goto _jump347;
    fail_assertion("negative array index");
    _jump347:;
    if (_612 < _434.d0)
    goto _jump348;
    fail_assertion("index too large");
    _jump348:;
    if (_659 >= 0)
    goto _jump349;
    fail_assertion("negative array index");
    _jump349:;
    if (_659 < _434.d1)
    goto _jump350;
    fail_assertion("index too large");
    _jump350:;
    if (_761 >= 0)
    goto _jump351;
    fail_assertion("negative array index");
    _jump351:;
    if (_761 < _434.d2)
    goto _jump352;
    fail_assertion("index too large");
    _jump352:;
    int64_t _762 = 0;
    _762 *= _434.d0;
    _762 += _612;
    _762 *= _434.d1;
    _762 += _659;
    _762 *= _434.d2;
    _762 += _761;
    _a2__a1_int64_t _763 = _434.data[_762];
    bool _764 = false;
    int64_t _765;
    if (!_764)
    goto _jump353;
    _765 = _763.d0;
    goto _jump354;
    _jump353:;
    _765 = _763.d1;
    _jump354:;
    int64_t _766 = _763.d1 / _763.d0;
    bool _767 = _765 == _766;
    bool _768;
    if (!_767)
    goto _jump355;
    bool _770 = true;
    bool _771 = !_770;
    bool _769 = _771;
    if (0 == _771)
    goto _jump356;
    bool _772 = false;
    _769 = _772;
    _jump356:;
    _768 = _769;
    goto _jump357;
    _jump355:;
    bool _773 = false;
    _768 = _773;
    _jump357:;
    bool _774 = !_768;
    bool _775 = !_774;
    bool _776 = !_775;
    bool _777 = !_776;
    _a2__a2_bool _778;
    // Computing bound for f
    int64_t _779 = -_763.d1;
    _778.d0 = _779;
    if (_779 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    // Computing bound for g
    _778.d1 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing total size of heap memory to allocate
    int64_t _780 = 1;
    _780 *= _779;
    _780 *= _763.d1;
    _780 *= sizeof(_a2_bool);
    _778.data = jpl_alloc(_780);
    int64_t _781 = 0; // g
    int64_t _782 = 0; // f
    _jump360:; // Begin body of loop
    _a2_bool _783;
    // Computing bound for h
    _783.d0 = _782;
    if (_782 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    // Computing bound for i
    _783.d1 = _782;
    if (_782 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing total size of heap memory to allocate
    int64_t _784 = 1;
    _784 *= _782;
    _784 *= _782;
    _784 *= sizeof(bool);
    _783.data = jpl_alloc(_784);
    int64_t _785 = 0; // i
    int64_t _786 = 0; // h
    _jump363:; // Begin body of loop
    bool _787 = true;
    int64_t _788 = 0;
    _788 *= _783.d0;
    _788 += _786;
    _788 *= _783.d1;
    _788 += _785;
    _783.data[_788] = _787;
    _785++;
    if (_785 < _782)
    goto _jump363;
    _785 = 0;
    _786++;
    if (_786 < _782)
    goto _jump363;
    // End body of loop
    int64_t _789 = 0;
    _789 *= _778.d0;
    _789 += _782;
    _789 *= _778.d1;
    _789 += _781;
    _778.data[_789] = _783;
    _781++;
    if (_781 < _763.d1)
    goto _jump360;
    _781 = 0;
    _782++;
    if (_782 < _779)
    goto _jump360;
    // End body of loop
    bool _790 = true;
    bool _791 = !_790;
    int64_t _792;
    if (!_791)
    goto _jump364;
    _792 = _763.d1;
    goto _jump365;
    _jump364:;
    int64_t _793 = -_763.d1;
    _792 = _793;
    _jump365:;
    int64_t _794;
    if (!_777)
    goto _jump366;
    int64_t _795 = 451;
    _794 = _795;
    goto _jump367;
    _jump366:;
    int64_t _796 = 268;
    _794 = _796;
    _jump367:;
    if (_792 >= 0)
    goto _jump368;
    fail_assertion("negative array index");
    _jump368:;
    if (_792 < _778.d0)
    goto _jump369;
    fail_assertion("index too large");
    _jump369:;
    if (_794 >= 0)
    goto _jump370;
    fail_assertion("negative array index");
    _jump370:;
    if (_794 < _778.d1)
    goto _jump371;
    fail_assertion("index too large");
    _jump371:;
    int64_t _797 = 0;
    _797 *= _778.d0;
    _797 += _792;
    _797 *= _778.d1;
    _797 += _794;
    _a2_bool _798 = _778.data[_797];
    bool _800;
    if (!_777)
    goto _jump372;
    bool _801 = false;
    _800 = _801;
    goto _jump373;
    _jump372:;
    bool _802 = true;
    _800 = _802;
    _jump373:;
    bool _799 = _800;
    if (0 == _800)
    goto _jump374;
    bool _803 = false;
    _799 = _803;
    _jump374:;
    int64_t _804;
    if (!_799)
    goto _jump375;
    int64_t _805 = -_763.d1;
    _804 = _805;
    goto _jump376;
    _jump375:;
    double _806 = 35.0;
    a _807 = { _806, _763.d0 };
    int64_t _808 = _807.b;
    _804 = _808;
    _jump376:;
    if (_804 >= 0)
    goto _jump377;
    fail_assertion("negative array index");
    _jump377:;
    if (_804 < _798.d0)
    goto _jump378;
    fail_assertion("index too large");
    _jump378:;
    if (_763.d1 >= 0)
    goto _jump379;
    fail_assertion("negative array index");
    _jump379:;
    if (_763.d1 < _798.d1)
    goto _jump380;
    fail_assertion("index too large");
    _jump380:;
    int64_t _809 = 0;
    _809 *= _798.d0;
    _809 += _804;
    _809 *= _798.d1;
    _809 += _763.d1;
    bool _810 = _798.data[_809];
    _a3__a2__a2__a1_int64_t _811;
    if (!_810)
    goto _jump381;
    _a3__a2__a2__a1_int64_t _812;
    // Computing bound for f
    _812.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for g
    int64_t _813 = 743;
    bool _814 = _813 >= _763.d0;
    int64_t _815;
    if (!_814)
    goto _jump383;
    int64_t _816 = -_763.d0;
    _815 = _816;
    goto _jump384;
    _jump383:;
    int64_t _817 = 451;
    int64_t _818 = _817 * _763.d1;
    _815 = _818;
    _jump384:;
    _812.d1 = _815;
    if (_815 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing bound for h
    _812.d2 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing total size of heap memory to allocate
    int64_t _819 = 1;
    _819 *= _763.d0;
    _819 *= _815;
    _819 *= _763.d0;
    _819 *= sizeof(_a2__a2__a1_int64_t);
    _812.data = jpl_alloc(_819);
    int64_t _820 = 0; // h
    int64_t _821 = 0; // g
    int64_t _822 = 0; // f
    _jump387:; // Begin body of loop
    _a1__a2__a2__a1_int64_t _823;
    // Computing bound for i
    int64_t _824 = -_763.d0;
    _823.d0 = _824;
    if (_824 > 0) 
    goto _jump388;
    fail_assertion("non-positive loop bound");
    _jump388:;
    // Computing total size of heap memory to allocate
    int64_t _825 = 1;
    _825 *= _824;
    _825 *= sizeof(_a2__a2__a1_int64_t);
    _823.data = jpl_alloc(_825);
    int64_t _826 = 0; // i
    _jump389:; // Begin body of loop
    _a2__a2__a1_int64_t _827;
    // Computing bound for j
    int64_t _828 = 303;
    _827.d0 = _828;
    if (_828 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for k
    _827.d1 = _820;
    if (_820 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing total size of heap memory to allocate
    int64_t _829 = 1;
    _829 *= _828;
    _829 *= _820;
    _829 *= sizeof(_a2__a1_int64_t);
    _827.data = jpl_alloc(_829);
    int64_t _830 = 0; // k
    int64_t _831 = 0; // j
    _jump392:; // Begin body of loop
    int64_t _832 = 0;
    _832 *= _827.d0;
    _832 += _831;
    _832 *= _827.d1;
    _832 += _830;
    _827.data[_832] = _763;
    _830++;
    if (_830 < _820)
    goto _jump392;
    _830 = 0;
    _831++;
    if (_831 < _828)
    goto _jump392;
    // End body of loop
    int64_t _833 = 0;
    _833 *= _823.d0;
    _833 += _826;
    _823.data[_833] = _827;
    _826++;
    if (_826 < _824)
    goto _jump389;
    // End body of loop
    int64_t _834 = -_763.d0;
    int64_t _835 = -_834;
    if (_835 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_835 < _823.d0)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    int64_t _836 = 0;
    _836 *= _823.d0;
    _836 += _835;
    _a2__a2__a1_int64_t _837 = _823.data[_836];
    int64_t _838 = 0;
    _838 *= _812.d0;
    _838 += _822;
    _838 *= _812.d1;
    _838 += _821;
    _838 *= _812.d2;
    _838 += _820;
    _812.data[_838] = _837;
    _820++;
    if (_820 < _763.d0)
    goto _jump387;
    _820 = 0;
    _821++;
    if (_821 < _815)
    goto _jump387;
    _821 = 0;
    _822++;
    if (_822 < _763.d0)
    goto _jump387;
    // End body of loop
    _811 = _812;
    goto _jump395;
    _jump381:;
    _a3__a3__a2__a2__a1_int64_t _839;
    // Computing bound for f
    int64_t _840 = 612;
    int64_t _841 = _840 - _763.d0;
    int64_t _842 = _841 / _763.d0;
    _839.d0 = _842;
    if (_842 > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    // Computing bound for g
    double _843 = 5.0;
    int64_t _844 = 102;
    a _845 = { _843, _844 };
    int64_t _846 = _845.b;
    _839.d1 = _846;
    if (_846 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing bound for h
    int64_t _847 = 185;
    int64_t _848 = _847 / _763.d0;
    int64_t _849 = -_848;
    _839.d2 = _849;
    if (_849 > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    // Computing total size of heap memory to allocate
    int64_t _850 = 1;
    _850 *= _842;
    _850 *= _846;
    _850 *= _849;
    _850 *= sizeof(_a3__a2__a2__a1_int64_t);
    _839.data = jpl_alloc(_850);
    int64_t _851 = 0; // h
    int64_t _852 = 0; // g
    int64_t _853 = 0; // f
    _jump399:; // Begin body of loop
    _a3__a2__a2__a1_int64_t _854;
    // Computing bound for i
    _854.d0 = _853;
    if (_853 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for j
    _854.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for k
    int64_t _855 = _763.d0 % _852;
    _854.d2 = _855;
    if (_855 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    // Computing total size of heap memory to allocate
    int64_t _856 = 1;
    _856 *= _853;
    _856 *= _763.d0;
    _856 *= _855;
    _856 *= sizeof(_a2__a2__a1_int64_t);
    _854.data = jpl_alloc(_856);
    int64_t _857 = 0; // k
    int64_t _858 = 0; // j
    int64_t _859 = 0; // i
    _jump403:; // Begin body of loop
    _a2__a2__a1_int64_t _860;
    // Computing bound for l
    _860.d0 = _857;
    if (_857 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    // Computing bound for m
    _860.d1 = _859;
    if (_859 > 0) 
    goto _jump405;
    fail_assertion("non-positive loop bound");
    _jump405:;
    // Computing total size of heap memory to allocate
    int64_t _861 = 1;
    _861 *= _857;
    _861 *= _859;
    _861 *= sizeof(_a2__a1_int64_t);
    _860.data = jpl_alloc(_861);
    int64_t _862 = 0; // m
    int64_t _863 = 0; // l
    _jump406:; // Begin body of loop
    int64_t _864 = 0;
    _864 *= _860.d0;
    _864 += _863;
    _864 *= _860.d1;
    _864 += _862;
    _860.data[_864] = _763;
    _862++;
    if (_862 < _859)
    goto _jump406;
    _862 = 0;
    _863++;
    if (_863 < _857)
    goto _jump406;
    // End body of loop
    int64_t _865 = 0;
    _865 *= _854.d0;
    _865 += _859;
    _865 *= _854.d1;
    _865 += _858;
    _865 *= _854.d2;
    _865 += _857;
    _854.data[_865] = _860;
    _857++;
    if (_857 < _855)
    goto _jump403;
    _857 = 0;
    _858++;
    if (_858 < _763.d0)
    goto _jump403;
    _858 = 0;
    _859++;
    if (_859 < _853)
    goto _jump403;
    // End body of loop
    int64_t _866 = 0;
    _866 *= _839.d0;
    _866 += _853;
    _866 *= _839.d1;
    _866 += _852;
    _866 *= _839.d2;
    _866 += _851;
    _839.data[_866] = _854;
    _851++;
    if (_851 < _849)
    goto _jump399;
    _851 = 0;
    _852++;
    if (_852 < _846)
    goto _jump399;
    _852 = 0;
    _853++;
    if (_853 < _842)
    goto _jump399;
    // End body of loop
    int64_t _867 = -_763.d1;
    int64_t _868 = 426;
    int64_t _869 = 185;
    int64_t _870 = -_869;
    if (_867 >= 0)
    goto _jump407;
    fail_assertion("negative array index");
    _jump407:;
    if (_867 < _839.d0)
    goto _jump408;
    fail_assertion("index too large");
    _jump408:;
    if (_868 >= 0)
    goto _jump409;
    fail_assertion("negative array index");
    _jump409:;
    if (_868 < _839.d1)
    goto _jump410;
    fail_assertion("index too large");
    _jump410:;
    if (_870 >= 0)
    goto _jump411;
    fail_assertion("negative array index");
    _jump411:;
    if (_870 < _839.d2)
    goto _jump412;
    fail_assertion("index too large");
    _jump412:;
    int64_t _871 = 0;
    _871 *= _839.d0;
    _871 += _867;
    _871 *= _839.d1;
    _871 += _868;
    _871 *= _839.d2;
    _871 += _870;
    _a3__a2__a2__a1_int64_t _872 = _839.data[_871];
    _811 = _872;
    _jump395:;
    bool _874 = !_777;
    _a1_bool _875;
    if (!_874)
    goto _jump413;
    bool _876 = true;
    _a1_bool _877;
    _877.d0 = 1;
    _877.data = jpl_alloc(sizeof(bool) * 1);
    _877.data[0] = _876;
    _875 = _877;
    goto _jump414;
    _jump413:;
    bool _878 = true;
    _a1_bool _879;
    _879.d0 = 1;
    _879.data = jpl_alloc(sizeof(bool) * 1);
    _879.data[0] = _878;
    _875 = _879;
    _jump414:;
    if (_763.d1 >= 0)
    goto _jump415;
    fail_assertion("negative array index");
    _jump415:;
    if (_763.d1 < _875.d0)
    goto _jump416;
    fail_assertion("index too large");
    _jump416:;
    int64_t _880 = 0;
    _880 *= _875.d0;
    _880 += _763.d1;
    bool _881 = _875.data[_880];
    bool _873 = _881;
    if (0 != _881)
    goto _jump417;
    _a3_bool _882;
    // Computing bound for f
    _882.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing bound for g
    _882.d1 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    // Computing bound for h
    int64_t _883 = _763.d1 % _763.d0;
    _882.d2 = _883;
    if (_883 > 0) 
    goto _jump420;
    fail_assertion("non-positive loop bound");
    _jump420:;
    // Computing total size of heap memory to allocate
    int64_t _884 = 1;
    _884 *= _763.d0;
    _884 *= _763.d1;
    _884 *= _883;
    _884 *= sizeof(bool);
    _882.data = jpl_alloc(_884);
    int64_t _885 = 0; // h
    int64_t _886 = 0; // g
    int64_t _887 = 0; // f
    _jump421:; // Begin body of loop
    int64_t _888 = 0;
    _888 *= _882.d0;
    _888 += _887;
    _888 *= _882.d1;
    _888 += _886;
    _888 *= _882.d2;
    _888 += _885;
    _882.data[_888] = _777;
    _885++;
    if (_885 < _883)
    goto _jump421;
    _885 = 0;
    _886++;
    if (_886 < _763.d1)
    goto _jump421;
    _886 = 0;
    _887++;
    if (_887 < _763.d0)
    goto _jump421;
    // End body of loop
    int64_t _889;
    // Computing bound for f
    int64_t _890 = 938;
    if (_890 > 0) 
    goto _jump422;
    fail_assertion("non-positive loop bound");
    _jump422:;
    _889 = 0;
    int64_t _891 = 0; // f
    _jump423:; // Begin body of loop
    int64_t _892 = 449;
    _889 += _892;
    _891++;
    if (_891 < _890)
    goto _jump423;
    // End body of loop
    _a1_int64_t _893;
    // Computing bound for f
    _893.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing total size of heap memory to allocate
    int64_t _894 = 1;
    _894 *= _763.d0;
    _894 *= sizeof(int64_t);
    _893.data = jpl_alloc(_894);
    int64_t _895 = 0; // f
    _jump425:; // Begin body of loop
    int64_t _896 = 0;
    _896 *= _893.d0;
    _896 += _895;
    _893.data[_896] = _763.d1;
    _895++;
    if (_895 < _763.d0)
    goto _jump425;
    // End body of loop
    int64_t _897 = 278;
    if (_897 >= 0)
    goto _jump426;
    fail_assertion("negative array index");
    _jump426:;
    if (_897 < _893.d0)
    goto _jump427;
    fail_assertion("index too large");
    _jump427:;
    int64_t _898 = 0;
    _898 *= _893.d0;
    _898 += _897;
    int64_t _899 = _893.data[_898];
    if (_889 >= 0)
    goto _jump428;
    fail_assertion("negative array index");
    _jump428:;
    if (_889 < _882.d0)
    goto _jump429;
    fail_assertion("index too large");
    _jump429:;
    if (_899 >= 0)
    goto _jump430;
    fail_assertion("negative array index");
    _jump430:;
    if (_899 < _882.d1)
    goto _jump431;
    fail_assertion("index too large");
    _jump431:;
    if (_763.d1 >= 0)
    goto _jump432;
    fail_assertion("negative array index");
    _jump432:;
    if (_763.d1 < _882.d2)
    goto _jump433;
    fail_assertion("index too large");
    _jump433:;
    int64_t _900 = 0;
    _900 *= _882.d0;
    _900 += _889;
    _900 *= _882.d1;
    _900 += _899;
    _900 *= _882.d2;
    _900 += _763.d1;
    bool _901 = _882.data[_900];
    _873 = _901;
    _jump417:;
    int64_t _902;
    if (!_873)
    goto _jump434;
    _902 = _763.d1;
    goto _jump435;
    _jump434:;
    _902 = _763.d1;
    _jump435:;
    int64_t _903 = 542;
    if (_902 >= 0)
    goto _jump436;
    fail_assertion("negative array index");
    _jump436:;
    if (_902 < _811.d0)
    goto _jump437;
    fail_assertion("index too large");
    _jump437:;
    if (_903 >= 0)
    goto _jump438;
    fail_assertion("negative array index");
    _jump438:;
    if (_903 < _811.d1)
    goto _jump439;
    fail_assertion("index too large");
    _jump439:;
    if (_763.d1 >= 0)
    goto _jump440;
    fail_assertion("negative array index");
    _jump440:;
    if (_763.d1 < _811.d2)
    goto _jump441;
    fail_assertion("index too large");
    _jump441:;
    int64_t _904 = 0;
    _904 *= _811.d0;
    _904 += _902;
    _904 *= _811.d1;
    _904 += _903;
    _904 *= _811.d2;
    _904 += _763.d1;
    _a2__a2__a1_int64_t _905 = _811.data[_904];
    int64_t _906 = 479;
    int64_t _907;
    // Computing bound for f
    int64_t _908 = 784;
    int64_t _909 = 885;
    int64_t _910 = _908 / _909;
    int64_t _911;
    if (!_777)
    goto _jump442;
    int64_t _912 = _763.d0 + _763.d0;
    _911 = _912;
    goto _jump443;
    _jump442:;
    int64_t _913 = 577;
    int64_t _914 = _763.d0 * _913;
    _911 = _914;
    _jump443:;
    int64_t _915 = _910 * _911;
    _a2_int64_t _916;
    // Computing bound for f
    _916.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump444;
    fail_assertion("non-positive loop bound");
    _jump444:;
    // Computing bound for g
    _916.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump445;
    fail_assertion("non-positive loop bound");
    _jump445:;
    // Computing total size of heap memory to allocate
    int64_t _917 = 1;
    _917 *= _763.d0;
    _917 *= _763.d0;
    _917 *= sizeof(int64_t);
    _916.data = jpl_alloc(_917);
    int64_t _918 = 0; // g
    int64_t _919 = 0; // f
    _jump446:; // Begin body of loop
    int64_t _920 = -_763.d0;
    int64_t _921 = 0;
    _921 *= _916.d0;
    _921 += _919;
    _921 *= _916.d1;
    _921 += _918;
    _916.data[_921] = _920;
    _918++;
    if (_918 < _763.d0)
    goto _jump446;
    _918 = 0;
    _919++;
    if (_919 < _763.d0)
    goto _jump446;
    // End body of loop
    int64_t _922 = 305;
    if (_763.d1 >= 0)
    goto _jump447;
    fail_assertion("negative array index");
    _jump447:;
    if (_763.d1 < _916.d0)
    goto _jump448;
    fail_assertion("index too large");
    _jump448:;
    if (_922 >= 0)
    goto _jump449;
    fail_assertion("negative array index");
    _jump449:;
    if (_922 < _916.d1)
    goto _jump450;
    fail_assertion("index too large");
    _jump450:;
    int64_t _923 = 0;
    _923 *= _916.d0;
    _923 += _763.d1;
    _923 *= _916.d1;
    _923 += _922;
    int64_t _924 = _916.data[_923];
    bool _925 = _915 <= _924;
    int64_t _926;
    if (!_925)
    goto _jump451;
    int64_t _927;
    if (!_777)
    goto _jump452;
    int64_t _928 = 966;
    _927 = _928;
    goto _jump453;
    _jump452:;
    int64_t _929;
    if (!_777)
    goto _jump454;
    int64_t _930 = -_763.d1;
    _929 = _930;
    goto _jump455;
    _jump454:;
    int64_t _931 = -_763.d0;
    _929 = _931;
    _jump455:;
    _927 = _929;
    _jump453:;
    _926 = _927;
    goto _jump456;
    _jump451:;
    bool _933 = _777;
    if (0 == _777)
    goto _jump457;
    _933 = _777;
    _jump457:;
    bool _934 = !_933;
    bool _932 = _934;
    if (0 == _934)
    goto _jump458;
    bool _935 = true;
    bool _936 = !_935;
    _932 = _936;
    _jump458:;
    int64_t _937;
    if (!_932)
    goto _jump459;
    _937 = _763.d1;
    goto _jump460;
    _jump459:;
    int64_t _938;
    // Computing bound for f
    int64_t _939 = 40;
    if (_939 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    _938 = 0;
    int64_t _940 = 0; // f
    _jump462:; // Begin body of loop
    _938 += _763.d1;
    _940++;
    if (_940 < _939)
    goto _jump462;
    // End body of loop
    int64_t _941 = -_938;
    int64_t _942 = _763.d1 % _941;
    _937 = _942;
    _jump460:;
    _926 = _937;
    _jump456:;
    if (_926 > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing bound for g
    int64_t _943 = 967;
    int64_t _944 = _763.d0 + _943;
    if (_944 > 0) 
    goto _jump464;
    fail_assertion("non-positive loop bound");
    _jump464:;
    _907 = 0;
    int64_t _945 = 0; // g
    int64_t _946 = 0; // f
    _jump465:; // Begin body of loop
    _907 += _763.d1;
    _945++;
    if (_945 < _944)
    goto _jump465;
    _945 = 0;
    _946++;
    if (_946 < _926)
    goto _jump465;
    // End body of loop
    if (_906 >= 0)
    goto _jump466;
    fail_assertion("negative array index");
    _jump466:;
    if (_906 < _905.d0)
    goto _jump467;
    fail_assertion("index too large");
    _jump467:;
    if (_907 >= 0)
    goto _jump468;
    fail_assertion("negative array index");
    _jump468:;
    if (_907 < _905.d1)
    goto _jump469;
    fail_assertion("index too large");
    _jump469:;
    int64_t _947 = 0;
    _947 *= _905.d0;
    _947 += _906;
    _947 *= _905.d1;
    _947 += _907;
    _a2__a1_int64_t _948 = _905.data[_947];
    double _949 = 9.0;
    _a3_bool _950;
    if (!_777)
    goto _jump470;
    _a3_bool _951;
    // Computing bound for j
    _951.d0 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing bound for k
    int64_t _952 = 835;
    _951.d1 = _952;
    if (_952 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for l
    _a2_int64_t _953;
    // Computing bound for j
    _953.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for k
    _953.d1 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing total size of heap memory to allocate
    int64_t _954 = 1;
    _954 *= _763.d0;
    _954 *= _763.d1;
    _954 *= sizeof(int64_t);
    _953.data = jpl_alloc(_954);
    int64_t _955 = 0; // k
    int64_t _956 = 0; // j
    _jump475:; // Begin body of loop
    int64_t _957 = 631;
    int64_t _958 = -_957;
    int64_t _959 = 0;
    _959 *= _953.d0;
    _959 += _956;
    _959 *= _953.d1;
    _959 += _955;
    _953.data[_959] = _958;
    _955++;
    if (_955 < _763.d1)
    goto _jump475;
    _955 = 0;
    _956++;
    if (_956 < _763.d0)
    goto _jump475;
    // End body of loop
    int64_t _960 = 865;
    if (_960 >= 0)
    goto _jump476;
    fail_assertion("negative array index");
    _jump476:;
    if (_960 < _953.d0)
    goto _jump477;
    fail_assertion("index too large");
    _jump477:;
    if (_763.d0 >= 0)
    goto _jump478;
    fail_assertion("negative array index");
    _jump478:;
    if (_763.d0 < _953.d1)
    goto _jump479;
    fail_assertion("index too large");
    _jump479:;
    int64_t _961 = 0;
    _961 *= _953.d0;
    _961 += _960;
    _961 *= _953.d1;
    _961 += _763.d0;
    int64_t _962 = _953.data[_961];
    int64_t _963 = -_962;
    _951.d2 = _963;
    if (_963 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing total size of heap memory to allocate
    int64_t _964 = 1;
    _964 *= _763.d1;
    _964 *= _952;
    _964 *= _963;
    _964 *= sizeof(bool);
    _951.data = jpl_alloc(_964);
    int64_t _965 = 0; // l
    int64_t _966 = 0; // k
    int64_t _967 = 0; // j
    _jump481:; // Begin body of loop
    int64_t _968 = -_966;
    bool _969 = _968 >= _966;
    int64_t _970 = 0;
    _970 *= _951.d0;
    _970 += _967;
    _970 *= _951.d1;
    _970 += _966;
    _970 *= _951.d2;
    _970 += _965;
    _951.data[_970] = _969;
    _965++;
    if (_965 < _963)
    goto _jump481;
    _965 = 0;
    _966++;
    if (_966 < _952)
    goto _jump481;
    _966 = 0;
    _967++;
    if (_967 < _763.d1)
    goto _jump481;
    // End body of loop
    _950 = _951;
    goto _jump482;
    _jump470:;
    a _971 = { _949, _763.d0 };
    double _972 = _971.a;
    double _973 = _972 * _949;
    _a2_double _974;
    // Computing bound for j
    _974.d0 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    // Computing bound for k
    _974.d1 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing total size of heap memory to allocate
    int64_t _975 = 1;
    _975 *= _763.d1;
    _975 *= _948.d0;
    _975 *= sizeof(double);
    _974.data = jpl_alloc(_975);
    int64_t _976 = 0; // k
    int64_t _977 = 0; // j
    _jump485:; // Begin body of loop
    double _978 = 13.0;
    double _979 = -_978;
    int64_t _980 = 0;
    _980 *= _974.d0;
    _980 += _977;
    _980 *= _974.d1;
    _980 += _976;
    _974.data[_980] = _979;
    _976++;
    if (_976 < _948.d0)
    goto _jump485;
    _976 = 0;
    _977++;
    if (_977 < _763.d1)
    goto _jump485;
    // End body of loop
    int64_t _981 = 902;
    int64_t _982 = -_763.d0;
    int64_t _983 = _981 * _982;
    int64_t _984 = 519;
    if (_983 >= 0)
    goto _jump486;
    fail_assertion("negative array index");
    _jump486:;
    if (_983 < _974.d0)
    goto _jump487;
    fail_assertion("index too large");
    _jump487:;
    if (_984 >= 0)
    goto _jump488;
    fail_assertion("negative array index");
    _jump488:;
    if (_984 < _974.d1)
    goto _jump489;
    fail_assertion("index too large");
    _jump489:;
    int64_t _985 = 0;
    _985 *= _974.d0;
    _985 += _983;
    _985 *= _974.d1;
    _985 += _984;
    double _986 = _974.data[_985];
    bool _987 = _973 == _986;
    _a3_bool _988;
    if (!_987)
    goto _jump490;
    _a3_bool _989;
    // Computing bound for j
    _989.d0 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for k
    int64_t _990;
    // Computing bound for j
    int64_t _991 = 82;
    int64_t _992 = _991 % _948.d0;
    if (_992 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    // Computing bound for k
    if (_763.d0 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for l
    int64_t _993;
    // Computing bound for j
    if (_763.d0 > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    _993 = 0;
    int64_t _994 = 0; // j
    _jump495:; // Begin body of loop
    _993 += _994;
    _994++;
    if (_994 < _763.d0)
    goto _jump495;
    // End body of loop
    if (_993 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    _990 = 0;
    int64_t _995 = 0; // l
    int64_t _996 = 0; // k
    int64_t _997 = 0; // j
    _jump497:; // Begin body of loop
    _990 += _763.d0;
    _995++;
    if (_995 < _993)
    goto _jump497;
    _995 = 0;
    _996++;
    if (_996 < _763.d0)
    goto _jump497;
    _996 = 0;
    _997++;
    if (_997 < _992)
    goto _jump497;
    // End body of loop
    _989.d1 = _990;
    if (_990 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing bound for l
    _989.d2 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing total size of heap memory to allocate
    int64_t _998 = 1;
    _998 *= _948.d0;
    _998 *= _990;
    _998 *= _948.d0;
    _998 *= sizeof(bool);
    _989.data = jpl_alloc(_998);
    int64_t _999 = 0; // l
    int64_t _1000 = 0; // k
    int64_t _1001 = 0; // j
    _jump500:; // Begin body of loop
    int64_t _1002 = 0;
    _1002 *= _989.d0;
    _1002 += _1001;
    _1002 *= _989.d1;
    _1002 += _1000;
    _1002 *= _989.d2;
    _1002 += _999;
    _989.data[_1002] = _777;
    _999++;
    if (_999 < _948.d0)
    goto _jump500;
    _999 = 0;
    _1000++;
    if (_1000 < _990)
    goto _jump500;
    _1000 = 0;
    _1001++;
    if (_1001 < _948.d0)
    goto _jump500;
    // End body of loop
    _988 = _989;
    goto _jump501;
    _jump490:;
    _a3__a3_bool _1003;
    // Computing bound for j
    _1003.d0 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    // Computing bound for k
    _1003.d1 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing bound for l
    int64_t _1004 = -_763.d1;
    _1003.d2 = _1004;
    if (_1004 > 0) 
    goto _jump504;
    fail_assertion("non-positive loop bound");
    _jump504:;
    // Computing total size of heap memory to allocate
    int64_t _1005 = 1;
    _1005 *= _948.d0;
    _1005 *= _763.d1;
    _1005 *= _1004;
    _1005 *= sizeof(_a3_bool);
    _1003.data = jpl_alloc(_1005);
    int64_t _1006 = 0; // l
    int64_t _1007 = 0; // k
    int64_t _1008 = 0; // j
    _jump505:; // Begin body of loop
    _a3_bool _1009;
    // Computing bound for m
    int64_t _1010 = _763.d1 * _948.d0;
    _1009.d0 = _1010;
    if (_1010 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for n
    int64_t _1011;
    if (!_777)
    goto _jump507;
    _1011 = _948.d1;
    goto _jump508;
    _jump507:;
    _1011 = _948.d1;
    _jump508:;
    _1009.d1 = _1011;
    if (_1011 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    // Computing bound for o
    _1009.d2 = _1007;
    if (_1007 > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing total size of heap memory to allocate
    int64_t _1012 = 1;
    _1012 *= _1010;
    _1012 *= _1011;
    _1012 *= _1007;
    _1012 *= sizeof(bool);
    _1009.data = jpl_alloc(_1012);
    int64_t _1013 = 0; // o
    int64_t _1014 = 0; // n
    int64_t _1015 = 0; // m
    _jump511:; // Begin body of loop
    bool _1016 = false;
    int64_t _1017 = 0;
    _1017 *= _1009.d0;
    _1017 += _1015;
    _1017 *= _1009.d1;
    _1017 += _1014;
    _1017 *= _1009.d2;
    _1017 += _1013;
    _1009.data[_1017] = _1016;
    _1013++;
    if (_1013 < _1007)
    goto _jump511;
    _1013 = 0;
    _1014++;
    if (_1014 < _1011)
    goto _jump511;
    _1014 = 0;
    _1015++;
    if (_1015 < _1010)
    goto _jump511;
    // End body of loop
    int64_t _1018 = 0;
    _1018 *= _1003.d0;
    _1018 += _1008;
    _1018 *= _1003.d1;
    _1018 += _1007;
    _1018 *= _1003.d2;
    _1018 += _1006;
    _1003.data[_1018] = _1009;
    _1006++;
    if (_1006 < _1004)
    goto _jump505;
    _1006 = 0;
    _1007++;
    if (_1007 < _763.d1)
    goto _jump505;
    _1007 = 0;
    _1008++;
    if (_1008 < _948.d0)
    goto _jump505;
    // End body of loop
    int64_t _1019;
    if (!_777)
    goto _jump512;
    _1019 = _763.d0;
    goto _jump513;
    _jump512:;
    int64_t _1020 = _948.d0 * _763.d1;
    _1019 = _1020;
    _jump513:;
    int64_t _1021;
    // Computing bound for j
    if (_948.d1 > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing bound for k
    bool _1022 = false;
    int64_t _1023;
    if (!_1022)
    goto _jump515;
    _1023 = _763.d0;
    goto _jump516;
    _jump515:;
    int64_t _1024;
    // Computing bound for j
    if (_948.d1 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for k
    if (_763.d1 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    _1024 = 0;
    int64_t _1025 = 0; // k
    int64_t _1026 = 0; // j
    _jump519:; // Begin body of loop
    int64_t _1027 = 457;
    _1024 += _1027;
    _1025++;
    if (_1025 < _763.d1)
    goto _jump519;
    _1025 = 0;
    _1026++;
    if (_1026 < _948.d1)
    goto _jump519;
    // End body of loop
    _1023 = _1024;
    _jump516:;
    if (_1023 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing bound for l
    int64_t _1028;
    // Computing bound for j
    if (_948.d1 > 0) 
    goto _jump521;
    fail_assertion("non-positive loop bound");
    _jump521:;
    _1028 = 0;
    int64_t _1029 = 0; // j
    _jump522:; // Begin body of loop
    int64_t _1030 = 947;
    _1028 += _1030;
    _1029++;
    if (_1029 < _948.d1)
    goto _jump522;
    // End body of loop
    if (_1028 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    _1021 = 0;
    int64_t _1031 = 0; // l
    int64_t _1032 = 0; // k
    int64_t _1033 = 0; // j
    _jump524:; // Begin body of loop
    _1021 += _763.d0;
    _1031++;
    if (_1031 < _1028)
    goto _jump524;
    _1031 = 0;
    _1032++;
    if (_1032 < _1023)
    goto _jump524;
    _1032 = 0;
    _1033++;
    if (_1033 < _948.d1)
    goto _jump524;
    // End body of loop
    if (_1019 >= 0)
    goto _jump525;
    fail_assertion("negative array index");
    _jump525:;
    if (_1019 < _1003.d0)
    goto _jump526;
    fail_assertion("index too large");
    _jump526:;
    if (_948.d0 >= 0)
    goto _jump527;
    fail_assertion("negative array index");
    _jump527:;
    if (_948.d0 < _1003.d1)
    goto _jump528;
    fail_assertion("index too large");
    _jump528:;
    if (_1021 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (_1021 < _1003.d2)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    int64_t _1034 = 0;
    _1034 *= _1003.d0;
    _1034 += _1019;
    _1034 *= _1003.d1;
    _1034 += _948.d0;
    _1034 *= _1003.d2;
    _1034 += _1021;
    _a3_bool _1035 = _1003.data[_1034];
    _988 = _1035;
    _jump501:;
    _950 = _988;
    _jump482:;
    _a2_int64_t _1036;
    // Computing bound for j
    int64_t _1037 = 698;
    int64_t _1038 = -_1037;
    _1036.d0 = _1038;
    if (_1038 > 0) 
    goto _jump531;
    fail_assertion("non-positive loop bound");
    _jump531:;
    // Computing bound for k
    _1036.d1 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing total size of heap memory to allocate
    int64_t _1039 = 1;
    _1039 *= _1038;
    _1039 *= _948.d0;
    _1039 *= sizeof(int64_t);
    _1036.data = jpl_alloc(_1039);
    int64_t _1040 = 0; // k
    int64_t _1041 = 0; // j
    _jump533:; // Begin body of loop
    int64_t _1042;
    // Computing bound for l
    if (_763.d0 > 0) 
    goto _jump534;
    fail_assertion("non-positive loop bound");
    _jump534:;
    // Computing bound for m
    if (_763.d1 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    _1042 = 0;
    int64_t _1043 = 0; // m
    int64_t _1044 = 0; // l
    _jump536:; // Begin body of loop
    _1042 += _763.d0;
    _1043++;
    if (_1043 < _763.d1)
    goto _jump536;
    _1043 = 0;
    _1044++;
    if (_1044 < _763.d0)
    goto _jump536;
    // End body of loop
    int64_t _1045 = 0;
    _1045 *= _1036.d0;
    _1045 += _1041;
    _1045 *= _1036.d1;
    _1045 += _1040;
    _1036.data[_1045] = _1042;
    _1040++;
    if (_1040 < _948.d0)
    goto _jump533;
    _1040 = 0;
    _1041++;
    if (_1041 < _1038)
    goto _jump533;
    // End body of loop
    _a1__a2_int64_t _1046;
    _1046.d0 = 1;
    _1046.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _1046.data[0] = _1036;
    bool _1047 = true;
    int64_t _1048;
    if (!_1047)
    goto _jump537;
    int64_t _1049;
    // Computing bound for j
    if (_763.d1 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing bound for k
    int64_t _1050 = 538;
    if (_1050 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    _1049 = 0;
    int64_t _1051 = 0; // k
    int64_t _1052 = 0; // j
    _jump540:; // Begin body of loop
    int64_t _1053 = 935;
    _1049 += _1053;
    _1051++;
    if (_1051 < _1050)
    goto _jump540;
    _1051 = 0;
    _1052++;
    if (_1052 < _763.d1)
    goto _jump540;
    // End body of loop
    _1048 = _1049;
    goto _jump541;
    _jump537:;
    _1048 = _948.d1;
    _jump541:;
    if (_1048 >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (_1048 < _1046.d0)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    int64_t _1054 = 0;
    _1054 *= _1046.d0;
    _1054 += _1048;
    _a2_int64_t _1055 = _1046.data[_1054];
    _a3_a _1056;
    // Computing bound for j
    int64_t _1057 = _763.d1 + _763.d0;
    int64_t _1058 = -_1057;
    _1056.d0 = _1058;
    if (_1058 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for k
    int64_t _1059 = 187;
    int64_t _1060 = _948.d0 % _1059;
    int64_t _1061 = -_1060;
    _1056.d1 = _1061;
    if (_1061 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing bound for l
    _1056.d2 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump546;
    fail_assertion("non-positive loop bound");
    _jump546:;
    // Computing total size of heap memory to allocate
    int64_t _1062 = 1;
    _1062 *= _1058;
    _1062 *= _1061;
    _1062 *= _763.d0;
    _1062 *= sizeof(a);
    _1056.data = jpl_alloc(_1062);
    int64_t _1063 = 0; // l
    int64_t _1064 = 0; // k
    int64_t _1065 = 0; // j
    _jump547:; // Begin body of loop
    a _1066 = { _949, _1063 };
    int64_t _1067 = 0;
    _1067 *= _1056.d0;
    _1067 += _1065;
    _1067 *= _1056.d1;
    _1067 += _1064;
    _1067 *= _1056.d2;
    _1067 += _1063;
    _1056.data[_1067] = _1066;
    _1063++;
    if (_1063 < _763.d0)
    goto _jump547;
    _1063 = 0;
    _1064++;
    if (_1064 < _1061)
    goto _jump547;
    _1064 = 0;
    _1065++;
    if (_1065 < _1058)
    goto _jump547;
    // End body of loop
    bool _1068 = true;
    int64_t _1069;
    if (!_1068)
    goto _jump548;
    _1069 = _763.d1;
    goto _jump549;
    _jump548:;
    _1069 = _948.d1;
    _jump549:;
    _a1_int64_t _1070;
    _1070.d0 = 2;
    _1070.data = jpl_alloc(sizeof(int64_t) * 2);
    _1070.data[0] = _1069;
    _1070.data[1] = _763.d1;
    if (_763.d1 >= 0)
    goto _jump550;
    fail_assertion("negative array index");
    _jump550:;
    if (_763.d1 < _1070.d0)
    goto _jump551;
    fail_assertion("index too large");
    _jump551:;
    int64_t _1071 = 0;
    _1071 *= _1070.d0;
    _1071 += _763.d1;
    int64_t _1072 = _1070.data[_1071];
    bool _1073 = _949 != _949;
    _a2_int64_t _1074;
    if (!_1073)
    goto _jump552;
    _a2_int64_t _1075;
    // Computing bound for j
    _1075.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for k
    _1075.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing total size of heap memory to allocate
    int64_t _1076 = 1;
    _1076 *= _763.d0;
    _1076 *= _763.d0;
    _1076 *= sizeof(int64_t);
    _1075.data = jpl_alloc(_1076);
    int64_t _1077 = 0; // k
    int64_t _1078 = 0; // j
    _jump555:; // Begin body of loop
    int64_t _1079 = 0;
    _1079 *= _1075.d0;
    _1079 += _1078;
    _1079 *= _1075.d1;
    _1079 += _1077;
    _1075.data[_1079] = _763.d0;
    _1077++;
    if (_1077 < _763.d0)
    goto _jump555;
    _1077 = 0;
    _1078++;
    if (_1078 < _763.d0)
    goto _jump555;
    // End body of loop
    _1074 = _1075;
    goto _jump556;
    _jump552:;
    _a2_int64_t _1080;
    // Computing bound for j
    _1080.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for k
    _1080.d1 = _948.d1;
    if (_948.d1 > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing total size of heap memory to allocate
    int64_t _1081 = 1;
    _1081 *= _763.d0;
    _1081 *= _948.d1;
    _1081 *= sizeof(int64_t);
    _1080.data = jpl_alloc(_1081);
    int64_t _1082 = 0; // k
    int64_t _1083 = 0; // j
    _jump559:; // Begin body of loop
    int64_t _1084 = 0;
    _1084 *= _1080.d0;
    _1084 += _1083;
    _1084 *= _1080.d1;
    _1084 += _1082;
    _1080.data[_1084] = _948.d0;
    _1082++;
    if (_1082 < _948.d1)
    goto _jump559;
    _1082 = 0;
    _1083++;
    if (_1083 < _763.d0)
    goto _jump559;
    // End body of loop
    _1074 = _1080;
    _jump556:;
    int64_t _1085 = -_763.d0;
    if (_1085 >= 0)
    goto _jump560;
    fail_assertion("negative array index");
    _jump560:;
    if (_1085 < _1074.d0)
    goto _jump561;
    fail_assertion("index too large");
    _jump561:;
    if (_948.d1 >= 0)
    goto _jump562;
    fail_assertion("negative array index");
    _jump562:;
    if (_948.d1 < _1074.d1)
    goto _jump563;
    fail_assertion("index too large");
    _jump563:;
    int64_t _1086 = 0;
    _1086 *= _1074.d0;
    _1086 += _1085;
    _1086 *= _1074.d1;
    _1086 += _948.d1;
    int64_t _1087 = _1074.data[_1086];
    if (_948.d1 >= 0)
    goto _jump564;
    fail_assertion("negative array index");
    _jump564:;
    if (_948.d1 < _1056.d0)
    goto _jump565;
    fail_assertion("index too large");
    _jump565:;
    if (_1072 >= 0)
    goto _jump566;
    fail_assertion("negative array index");
    _jump566:;
    if (_1072 < _1056.d1)
    goto _jump567;
    fail_assertion("index too large");
    _jump567:;
    if (_1087 >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (_1087 < _1056.d2)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    int64_t _1088 = 0;
    _1088 *= _1056.d0;
    _1088 += _948.d1;
    _1088 *= _1056.d1;
    _1088 += _1072;
    _1088 *= _1056.d2;
    _1088 += _1087;
    a _1089 = _1056.data[_1088];
    int64_t _1090 = _1089.b;
    double _1091 = 64.0;
    double _1092 = -_1091;
    bool _1093 = _949 > _1092;
    bool _1094;
    if (!_1093)
    goto _jump570;
    _a1_bool _1095;
    // Computing bound for j
    _1095.d0 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _1096 = 1;
    _1096 *= _948.d0;
    _1096 *= sizeof(bool);
    _1095.data = jpl_alloc(_1096);
    int64_t _1097 = 0; // j
    _jump572:; // Begin body of loop
    int64_t _1098 = 0;
    _1098 *= _1095.d0;
    _1098 += _1097;
    _1095.data[_1098] = _777;
    _1097++;
    if (_1097 < _948.d0)
    goto _jump572;
    // End body of loop
    int64_t _1099 = -_763.d1;
    if (_1099 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (_1099 < _1095.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    int64_t _1100 = 0;
    _1100 *= _1095.d0;
    _1100 += _1099;
    bool _1101 = _1095.data[_1100];
    _1094 = _1101;
    goto _jump575;
    _jump570:;
    bool _1102 = _777;
    if (0 == _777)
    goto _jump576;
    _1102 = _777;
    _jump576:;
    bool _1103 = !_1102;
    _1094 = _1103;
    _jump575:;
    _a3_int64_t _1104;
    if (!_1094)
    goto _jump577;
    _a3_int64_t _1105;
    // Computing bound for j
    int64_t _1106 = 581;
    _1105.d0 = _1106;
    if (_1106 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    // Computing bound for k
    _1105.d1 = _948.d1;
    if (_948.d1 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    // Computing bound for l
    int64_t _1107;
    if (!_777)
    goto _jump580;
    int64_t _1108 = 986;
    _1107 = _1108;
    goto _jump581;
    _jump580:;
    _1107 = _948.d0;
    _jump581:;
    _1105.d2 = _1107;
    if (_1107 > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    // Computing total size of heap memory to allocate
    int64_t _1109 = 1;
    _1109 *= _1106;
    _1109 *= _948.d1;
    _1109 *= _1107;
    _1109 *= sizeof(int64_t);
    _1105.data = jpl_alloc(_1109);
    int64_t _1110 = 0; // l
    int64_t _1111 = 0; // k
    int64_t _1112 = 0; // j
    _jump583:; // Begin body of loop
    int64_t _1113 = 0;
    _1113 *= _1105.d0;
    _1113 += _1112;
    _1113 *= _1105.d1;
    _1113 += _1111;
    _1113 *= _1105.d2;
    _1113 += _1110;
    _1105.data[_1113] = _1112;
    _1110++;
    if (_1110 < _1107)
    goto _jump583;
    _1110 = 0;
    _1111++;
    if (_1111 < _948.d1)
    goto _jump583;
    _1111 = 0;
    _1112++;
    if (_1112 < _1106)
    goto _jump583;
    // End body of loop
    _1104 = _1105;
    goto _jump584;
    _jump577:;
    _a2_bool _1114;
    // Computing bound for j
    _1114.d0 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump585;
    fail_assertion("non-positive loop bound");
    _jump585:;
    // Computing bound for k
    _1114.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump586;
    fail_assertion("non-positive loop bound");
    _jump586:;
    // Computing total size of heap memory to allocate
    int64_t _1115 = 1;
    _1115 *= _763.d1;
    _1115 *= _763.d0;
    _1115 *= sizeof(bool);
    _1114.data = jpl_alloc(_1115);
    int64_t _1116 = 0; // k
    int64_t _1117 = 0; // j
    _jump587:; // Begin body of loop
    bool _1118 = true;
    int64_t _1119 = 0;
    _1119 *= _1114.d0;
    _1119 += _1117;
    _1119 *= _1114.d1;
    _1119 += _1116;
    _1114.data[_1119] = _1118;
    _1116++;
    if (_1116 < _763.d0)
    goto _jump587;
    _1116 = 0;
    _1117++;
    if (_1117 < _763.d1)
    goto _jump587;
    // End body of loop
    if (_763.d1 >= 0)
    goto _jump588;
    fail_assertion("negative array index");
    _jump588:;
    if (_763.d1 < _1114.d0)
    goto _jump589;
    fail_assertion("index too large");
    _jump589:;
    if (_948.d0 >= 0)
    goto _jump590;
    fail_assertion("negative array index");
    _jump590:;
    if (_948.d0 < _1114.d1)
    goto _jump591;
    fail_assertion("index too large");
    _jump591:;
    int64_t _1120 = 0;
    _1120 *= _1114.d0;
    _1120 += _763.d1;
    _1120 *= _1114.d1;
    _1120 += _948.d0;
    bool _1121 = _1114.data[_1120];
    _a3_int64_t _1122;
    if (!_1121)
    goto _jump592;
    _a3_int64_t _1123;
    // Computing bound for j
    _1123.d0 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump593;
    fail_assertion("non-positive loop bound");
    _jump593:;
    // Computing bound for k
    _1123.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for l
    _1123.d2 = _948.d1;
    if (_948.d1 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing total size of heap memory to allocate
    int64_t _1124 = 1;
    _1124 *= _763.d1;
    _1124 *= _763.d0;
    _1124 *= _948.d1;
    _1124 *= sizeof(int64_t);
    _1123.data = jpl_alloc(_1124);
    int64_t _1125 = 0; // l
    int64_t _1126 = 0; // k
    int64_t _1127 = 0; // j
    _jump596:; // Begin body of loop
    int64_t _1128 = 0;
    _1128 *= _1123.d0;
    _1128 += _1127;
    _1128 *= _1123.d1;
    _1128 += _1126;
    _1128 *= _1123.d2;
    _1128 += _1125;
    _1123.data[_1128] = _948.d0;
    _1125++;
    if (_1125 < _948.d1)
    goto _jump596;
    _1125 = 0;
    _1126++;
    if (_1126 < _763.d0)
    goto _jump596;
    _1126 = 0;
    _1127++;
    if (_1127 < _763.d1)
    goto _jump596;
    // End body of loop
    _1122 = _1123;
    goto _jump597;
    _jump592:;
    _a3_int64_t _1129;
    // Computing bound for j
    bool _1130 = false;
    int64_t _1131;
    if (!_1130)
    goto _jump598;
    _1131 = _763.d1;
    goto _jump599;
    _jump598:;
    _1131 = _763.d0;
    _jump599:;
    _1129.d0 = _1131;
    if (_1131 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing bound for k
    _1129.d1 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    // Computing bound for l
    int64_t _1132;
    // Computing bound for j
    if (_763.d1 > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing bound for k
    if (_948.d0 > 0) 
    goto _jump603;
    fail_assertion("non-positive loop bound");
    _jump603:;
    _1132 = 0;
    int64_t _1133 = 0; // k
    int64_t _1134 = 0; // j
    _jump604:; // Begin body of loop
    _1132 += _1133;
    _1133++;
    if (_1133 < _948.d0)
    goto _jump604;
    _1133 = 0;
    _1134++;
    if (_1134 < _763.d1)
    goto _jump604;
    // End body of loop
    _1129.d2 = _1132;
    if (_1132 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing total size of heap memory to allocate
    int64_t _1135 = 1;
    _1135 *= _1131;
    _1135 *= _763.d1;
    _1135 *= _1132;
    _1135 *= sizeof(int64_t);
    _1129.data = jpl_alloc(_1135);
    int64_t _1136 = 0; // l
    int64_t _1137 = 0; // k
    int64_t _1138 = 0; // j
    _jump606:; // Begin body of loop
    int64_t _1139 = 0;
    _1139 *= _1129.d0;
    _1139 += _1138;
    _1139 *= _1129.d1;
    _1139 += _1137;
    _1139 *= _1129.d2;
    _1139 += _1136;
    _1129.data[_1139] = _1137;
    _1136++;
    if (_1136 < _1132)
    goto _jump606;
    _1136 = 0;
    _1137++;
    if (_1137 < _763.d1)
    goto _jump606;
    _1137 = 0;
    _1138++;
    if (_1138 < _1131)
    goto _jump606;
    // End body of loop
    _1122 = _1129;
    _jump597:;
    _1104 = _1122;
    _jump584:;
    int64_t _1140 = 11;
    double _1141 = 2.0;
    _a1_int64_t _1142;
    // Computing bound for j
    int64_t _1143 = 909;
    _1142.d0 = _1143;
    if (_1143 > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    // Computing total size of heap memory to allocate
    int64_t _1144 = 1;
    _1144 *= _1143;
    _1144 *= sizeof(int64_t);
    _1142.data = jpl_alloc(_1144);
    int64_t _1145 = 0; // j
    _jump608:; // Begin body of loop
    int64_t _1146 = 843;
    int64_t _1147 = 0;
    _1147 *= _1142.d0;
    _1147 += _1145;
    _1142.data[_1147] = _1146;
    _1145++;
    if (_1145 < _1143)
    goto _jump608;
    // End body of loop
    int64_t _1148 = -_948.d0;
    if (_1148 >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (_1148 < _1142.d0)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _1149 = 0;
    _1149 *= _1142.d0;
    _1149 += _1148;
    int64_t _1150 = _1142.data[_1149];
    a _1151 = { _1141, _1150 };
    int64_t _1152 = _1151.b;
    _a3_a _1153;
    // Computing bound for j
    _1153.d0 = _948.d1;
    if (_948.d1 > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for k
    _1153.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing bound for l
    bool _1154 = true;
    int64_t _1155;
    if (!_1154)
    goto _jump613;
    int64_t _1156 = 62;
    _1155 = _1156;
    goto _jump614;
    _jump613:;
    _1155 = _763.d1;
    _jump614:;
    _1153.d2 = _1155;
    if (_1155 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing total size of heap memory to allocate
    int64_t _1157 = 1;
    _1157 *= _948.d1;
    _1157 *= _763.d0;
    _1157 *= _1155;
    _1157 *= sizeof(a);
    _1153.data = jpl_alloc(_1157);
    int64_t _1158 = 0; // l
    int64_t _1159 = 0; // k
    int64_t _1160 = 0; // j
    _jump616:; // Begin body of loop
    a _1161 = { _949, _1158 };
    int64_t _1162 = 0;
    _1162 *= _1153.d0;
    _1162 += _1160;
    _1162 *= _1153.d1;
    _1162 += _1159;
    _1162 *= _1153.d2;
    _1162 += _1158;
    _1153.data[_1162] = _1161;
    _1158++;
    if (_1158 < _1155)
    goto _jump616;
    _1158 = 0;
    _1159++;
    if (_1159 < _763.d0)
    goto _jump616;
    _1159 = 0;
    _1160++;
    if (_1160 < _948.d1)
    goto _jump616;
    // End body of loop
    int64_t _1163 = -_948.d0;
    if (_1163 >= 0)
    goto _jump617;
    fail_assertion("negative array index");
    _jump617:;
    if (_1163 < _1153.d0)
    goto _jump618;
    fail_assertion("index too large");
    _jump618:;
    if (_948.d1 >= 0)
    goto _jump619;
    fail_assertion("negative array index");
    _jump619:;
    if (_948.d1 < _1153.d1)
    goto _jump620;
    fail_assertion("index too large");
    _jump620:;
    if (_763.d0 >= 0)
    goto _jump621;
    fail_assertion("negative array index");
    _jump621:;
    if (_763.d0 < _1153.d2)
    goto _jump622;
    fail_assertion("index too large");
    _jump622:;
    int64_t _1164 = 0;
    _1164 *= _1153.d0;
    _1164 += _1163;
    _1164 *= _1153.d1;
    _1164 += _948.d1;
    _1164 *= _1153.d2;
    _1164 += _763.d0;
    a _1165 = _1153.data[_1164];
    int64_t _1166 = _1165.b;
    if (_1140 >= 0)
    goto _jump623;
    fail_assertion("negative array index");
    _jump623:;
    if (_1140 < _1104.d0)
    goto _jump624;
    fail_assertion("index too large");
    _jump624:;
    if (_1152 >= 0)
    goto _jump625;
    fail_assertion("negative array index");
    _jump625:;
    if (_1152 < _1104.d1)
    goto _jump626;
    fail_assertion("index too large");
    _jump626:;
    if (_1166 >= 0)
    goto _jump627;
    fail_assertion("negative array index");
    _jump627:;
    if (_1166 < _1104.d2)
    goto _jump628;
    fail_assertion("index too large");
    _jump628:;
    int64_t _1167 = 0;
    _1167 *= _1104.d0;
    _1167 += _1140;
    _1167 *= _1104.d1;
    _1167 += _1152;
    _1167 *= _1104.d2;
    _1167 += _1166;
    int64_t _1168 = _1104.data[_1167];
    if (_1090 >= 0)
    goto _jump629;
    fail_assertion("negative array index");
    _jump629:;
    if (_1090 < _1055.d0)
    goto _jump630;
    fail_assertion("index too large");
    _jump630:;
    if (_1168 >= 0)
    goto _jump631;
    fail_assertion("negative array index");
    _jump631:;
    if (_1168 < _1055.d1)
    goto _jump632;
    fail_assertion("index too large");
    _jump632:;
    int64_t _1169 = 0;
    _1169 *= _1055.d0;
    _1169 += _1090;
    _1169 *= _1055.d1;
    _1169 += _1168;
    int64_t _1170 = _1055.data[_1169];
    int64_t _1171 = 515;
    int64_t _1172 = -_1171;
    bool _1173 = true;
    _a3_int64_t _1174;
    if (!_1173)
    goto _jump633;
    bool _1175 = _763.d0 != _763.d0;
    _a3_int64_t _1176;
    if (!_1175)
    goto _jump634;
    _a3_int64_t _1177;
    // Computing bound for j
    int64_t _1178 = 353;
    _1177.d0 = _1178;
    if (_1178 > 0) 
    goto _jump635;
    fail_assertion("non-positive loop bound");
    _jump635:;
    // Computing bound for k
    _1177.d1 = _948.d1;
    if (_948.d1 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for l
    _1177.d2 = _948.d0;
    if (_948.d0 > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing total size of heap memory to allocate
    int64_t _1179 = 1;
    _1179 *= _1178;
    _1179 *= _948.d1;
    _1179 *= _948.d0;
    _1179 *= sizeof(int64_t);
    _1177.data = jpl_alloc(_1179);
    int64_t _1180 = 0; // l
    int64_t _1181 = 0; // k
    int64_t _1182 = 0; // j
    _jump638:; // Begin body of loop
    int64_t _1183 = 0;
    _1183 *= _1177.d0;
    _1183 += _1182;
    _1183 *= _1177.d1;
    _1183 += _1181;
    _1183 *= _1177.d2;
    _1183 += _1180;
    _1177.data[_1183] = _763.d1;
    _1180++;
    if (_1180 < _948.d0)
    goto _jump638;
    _1180 = 0;
    _1181++;
    if (_1181 < _948.d1)
    goto _jump638;
    _1181 = 0;
    _1182++;
    if (_1182 < _1178)
    goto _jump638;
    // End body of loop
    _1176 = _1177;
    goto _jump639;
    _jump634:;
    _a3_int64_t _1184;
    // Computing bound for j
    int64_t _1185 = _763.d1 * _948.d0;
    _1184.d0 = _1185;
    if (_1185 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for k
    _1184.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing bound for l
    _1184.d2 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing total size of heap memory to allocate
    int64_t _1186 = 1;
    _1186 *= _1185;
    _1186 *= _763.d0;
    _1186 *= _763.d0;
    _1186 *= sizeof(int64_t);
    _1184.data = jpl_alloc(_1186);
    int64_t _1187 = 0; // l
    int64_t _1188 = 0; // k
    int64_t _1189 = 0; // j
    _jump643:; // Begin body of loop
    int64_t _1190 = 0;
    _1190 *= _1184.d0;
    _1190 += _1189;
    _1190 *= _1184.d1;
    _1190 += _1188;
    _1190 *= _1184.d2;
    _1190 += _1187;
    _1184.data[_1190] = _763.d0;
    _1187++;
    if (_1187 < _763.d0)
    goto _jump643;
    _1187 = 0;
    _1188++;
    if (_1188 < _763.d0)
    goto _jump643;
    _1188 = 0;
    _1189++;
    if (_1189 < _1185)
    goto _jump643;
    // End body of loop
    _1176 = _1184;
    _jump639:;
    _1174 = _1176;
    goto _jump644;
    _jump633:;
    _a3_int64_t _1191;
    // Computing bound for j
    int64_t _1192 = 706;
    _1191.d0 = _1192;
    if (_1192 > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    // Computing bound for k
    _1191.d1 = _948.d1;
    if (_948.d1 > 0) 
    goto _jump646;
    fail_assertion("non-positive loop bound");
    _jump646:;
    // Computing bound for l
    int64_t _1193;
    // Computing bound for j
    if (_948.d1 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    // Computing bound for k
    if (_763.d1 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing bound for l
    if (_948.d0 > 0) 
    goto _jump649;
    fail_assertion("non-positive loop bound");
    _jump649:;
    _1193 = 0;
    int64_t _1194 = 0; // l
    int64_t _1195 = 0; // k
    int64_t _1196 = 0; // j
    _jump650:; // Begin body of loop
    _1193 += _763.d0;
    _1194++;
    if (_1194 < _948.d0)
    goto _jump650;
    _1194 = 0;
    _1195++;
    if (_1195 < _763.d1)
    goto _jump650;
    _1195 = 0;
    _1196++;
    if (_1196 < _948.d1)
    goto _jump650;
    // End body of loop
    int64_t _1197;
    // Computing bound for j
    if (_763.d0 > 0) 
    goto _jump651;
    fail_assertion("non-positive loop bound");
    _jump651:;
    // Computing bound for k
    if (_763.d0 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing bound for l
    if (_948.d1 > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    _1197 = 0;
    int64_t _1198 = 0; // l
    int64_t _1199 = 0; // k
    int64_t _1200 = 0; // j
    _jump654:; // Begin body of loop
    _1197 += _1198;
    _1198++;
    if (_1198 < _948.d1)
    goto _jump654;
    _1198 = 0;
    _1199++;
    if (_1199 < _763.d0)
    goto _jump654;
    _1199 = 0;
    _1200++;
    if (_1200 < _763.d0)
    goto _jump654;
    // End body of loop
    int64_t _1201 = _1193 - _1197;
    _1191.d2 = _1201;
    if (_1201 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing total size of heap memory to allocate
    int64_t _1202 = 1;
    _1202 *= _1192;
    _1202 *= _948.d1;
    _1202 *= _1201;
    _1202 *= sizeof(int64_t);
    _1191.data = jpl_alloc(_1202);
    int64_t _1203 = 0; // l
    int64_t _1204 = 0; // k
    int64_t _1205 = 0; // j
    _jump656:; // Begin body of loop
    int64_t _1206 = 0;
    _1206 *= _1191.d0;
    _1206 += _1205;
    _1206 *= _1191.d1;
    _1206 += _1204;
    _1206 *= _1191.d2;
    _1206 += _1203;
    _1191.data[_1206] = _1203;
    _1203++;
    if (_1203 < _1201)
    goto _jump656;
    _1203 = 0;
    _1204++;
    if (_1204 < _948.d1)
    goto _jump656;
    _1204 = 0;
    _1205++;
    if (_1205 < _1192)
    goto _jump656;
    // End body of loop
    _1174 = _1191;
    _jump644:;
    bool _1207 = _948.d0 == _763.d1;
    bool _1208 = !_1207;
    int64_t _1209;
    if (!_1208)
    goto _jump657;
    _1209 = _948.d1;
    goto _jump658;
    _jump657:;
    int64_t _1210;
    // Computing bound for j
    if (_763.d1 > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing bound for k
    int64_t _1211 = 240;
    if (_1211 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    _1210 = 0;
    int64_t _1212 = 0; // k
    int64_t _1213 = 0; // j
    _jump661:; // Begin body of loop
    int64_t _1214 = 523;
    _1210 += _1214;
    _1212++;
    if (_1212 < _1211)
    goto _jump661;
    _1212 = 0;
    _1213++;
    if (_1213 < _763.d1)
    goto _jump661;
    // End body of loop
    int64_t _1215 = _763.d1 % _1210;
    int64_t _1216 = _1215 + _763.d1;
    _1209 = _1216;
    _jump658:;
    double _1217 = 21.0;
    a _1218 = { _1217, _948.d1 };
    int64_t _1219 = _1218.b;
    if (_1209 >= 0)
    goto _jump662;
    fail_assertion("negative array index");
    _jump662:;
    if (_1209 < _1174.d0)
    goto _jump663;
    fail_assertion("index too large");
    _jump663:;
    if (_948.d0 >= 0)
    goto _jump664;
    fail_assertion("negative array index");
    _jump664:;
    if (_948.d0 < _1174.d1)
    goto _jump665;
    fail_assertion("index too large");
    _jump665:;
    if (_1219 >= 0)
    goto _jump666;
    fail_assertion("negative array index");
    _jump666:;
    if (_1219 < _1174.d2)
    goto _jump667;
    fail_assertion("index too large");
    _jump667:;
    int64_t _1220 = 0;
    _1220 *= _1174.d0;
    _1220 += _1209;
    _1220 *= _1174.d1;
    _1220 += _948.d0;
    _1220 *= _1174.d2;
    _1220 += _1219;
    int64_t _1221 = _1174.data[_1220];
    int64_t _1222 = -_1221;
    if (_1170 >= 0)
    goto _jump668;
    fail_assertion("negative array index");
    _jump668:;
    if (_1170 < _950.d0)
    goto _jump669;
    fail_assertion("index too large");
    _jump669:;
    if (_1172 >= 0)
    goto _jump670;
    fail_assertion("negative array index");
    _jump670:;
    if (_1172 < _950.d1)
    goto _jump671;
    fail_assertion("index too large");
    _jump671:;
    if (_1222 >= 0)
    goto _jump672;
    fail_assertion("negative array index");
    _jump672:;
    if (_1222 < _950.d2)
    goto _jump673;
    fail_assertion("index too large");
    _jump673:;
    int64_t _1223 = 0;
    _1223 *= _950.d0;
    _1223 += _1170;
    _1223 *= _950.d1;
    _1223 += _1172;
    _1223 *= _950.d2;
    _1223 += _1222;
    bool _1224 = _950.data[_1223];
    bool _1225 = !_1224;
    _a1_int64_t _1226;
    if (!_1225)
    goto _jump674;
    bool _1227 = false;
    bool _1228;
    if (!_1227)
    goto _jump675;
    bool _1229;
    if (!_777)
    goto _jump676;
    bool _1230 = _949 <= _949;
    _a1_bool _1231;
    _1231.d0 = 3;
    _1231.data = jpl_alloc(sizeof(bool) * 3);
    _1231.data[0] = _1230;
    _1231.data[1] = _777;
    _1231.data[2] = _777;
    int64_t _1232;
    // Computing bound for k
    if (_948.d0 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    // Computing bound for l
    if (_948.d1 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    _1232 = 0;
    int64_t _1233 = 0; // l
    int64_t _1234 = 0; // k
    _jump679:; // Begin body of loop
    int64_t _1235;
    // Computing bound for m
    if (_948.d1 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing bound for n
    if (_763.d1 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    _1235 = 0;
    int64_t _1236 = 0; // n
    int64_t _1237 = 0; // m
    _jump682:; // Begin body of loop
    _1235 += _948.d0;
    _1236++;
    if (_1236 < _763.d1)
    goto _jump682;
    _1236 = 0;
    _1237++;
    if (_1237 < _948.d1)
    goto _jump682;
    // End body of loop
    _1232 += _1235;
    _1233++;
    if (_1233 < _948.d1)
    goto _jump679;
    _1233 = 0;
    _1234++;
    if (_1234 < _948.d0)
    goto _jump679;
    // End body of loop
    if (_1232 >= 0)
    goto _jump683;
    fail_assertion("negative array index");
    _jump683:;
    if (_1232 < _1231.d0)
    goto _jump684;
    fail_assertion("index too large");
    _jump684:;
    int64_t _1238 = 0;
    _1238 *= _1231.d0;
    _1238 += _1232;
    bool _1239 = _1231.data[_1238];
    _1229 = _1239;
    goto _jump685;
    _jump676:;
    bool _1240 = true;
    _1229 = _1240;
    _jump685:;
    _1228 = _1229;
    goto _jump686;
    _jump675:;
    bool _1241 = false;
    _1228 = _1241;
    _jump686:;
    _a1_int64_t _1242;
    if (!_1228)
    goto _jump687;
    _a1_int64_t _1243;
    _1243.d0 = 3;
    _1243.data = jpl_alloc(sizeof(int64_t) * 3);
    _1243.data[0] = _948.d1;
    _1243.data[1] = _948.d0;
    _1243.data[2] = _763.d1;
    _1242 = _1243;
    goto _jump688;
    _jump687:;
    a _1244;
    if (!_1224)
    goto _jump689;
    double _1245;
    // Computing bound for k
    if (_948.d1 > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    // Computing bound for l
    int64_t _1246 = 647;
    if (_1246 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for m
    if (_948.d0 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    _1245 = 0;
    int64_t _1247 = 0; // m
    int64_t _1248 = 0; // l
    int64_t _1249 = 0; // k
    _jump693:; // Begin body of loop
    _1245 += _949;
    _1247++;
    if (_1247 < _948.d0)
    goto _jump693;
    _1247 = 0;
    _1248++;
    if (_1248 < _1246)
    goto _jump693;
    _1248 = 0;
    _1249++;
    if (_1249 < _948.d1)
    goto _jump693;
    // End body of loop
    int64_t _1250 = 945;
    a _1251 = { _1245, _1250 };
    _1244 = _1251;
    goto _jump694;
    _jump689:;
    double _1252 = 35.0;
    double _1253 = -_1252;
    int64_t _1254;
    // Computing bound for k
    if (_948.d1 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for l
    if (_948.d0 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    _1254 = 0;
    int64_t _1255 = 0; // l
    int64_t _1256 = 0; // k
    _jump697:; // Begin body of loop
    _1254 += _763.d1;
    _1255++;
    if (_1255 < _948.d0)
    goto _jump697;
    _1255 = 0;
    _1256++;
    if (_1256 < _948.d1)
    goto _jump697;
    // End body of loop
    a _1257 = { _1253, _1254 };
    _1244 = _1257;
    _jump694:;
    int64_t _1258 = _1244.b;
    _a1_int64_t _1259;
    _1259.d0 = 3;
    _1259.data = jpl_alloc(sizeof(int64_t) * 3);
    _1259.data[0] = _948.d0;
    _1259.data[1] = _1258;
    _1259.data[2] = _763.d1;
    _1242 = _1259;
    _jump688:;
    _1226 = _1242;
    goto _jump698;
    _jump674:;
    bool _1260 = _777;
    if (0 != _777)
    goto _jump699;
    _1260 = _1224;
    _jump699:;
    _a3__a1_int64_t _1261;
    if (!_1260)
    goto _jump700;
    _a3__a1_int64_t _1262;
    // Computing bound for k
    int64_t _1263 = 158;
    int64_t _1264 = _1263 - _948.d0;
    _1262.d0 = _1264;
    if (_1264 > 0) 
    goto _jump701;
    fail_assertion("non-positive loop bound");
    _jump701:;
    // Computing bound for l
    _a3_int64_t _1265;
    // Computing bound for k
    _1265.d0 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    // Computing bound for l
    _1265.d1 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing bound for m
    int64_t _1266 = 720;
    _1265.d2 = _1266;
    if (_1266 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing total size of heap memory to allocate
    int64_t _1267 = 1;
    _1267 *= _763.d1;
    _1267 *= _763.d0;
    _1267 *= _1266;
    _1267 *= sizeof(int64_t);
    _1265.data = jpl_alloc(_1267);
    int64_t _1268 = 0; // m
    int64_t _1269 = 0; // l
    int64_t _1270 = 0; // k
    _jump705:; // Begin body of loop
    int64_t _1271 = 117;
    int64_t _1272 = _1271 / _1268;
    int64_t _1273 = 0;
    _1273 *= _1265.d0;
    _1273 += _1270;
    _1273 *= _1265.d1;
    _1273 += _1269;
    _1273 *= _1265.d2;
    _1273 += _1268;
    _1265.data[_1273] = _1272;
    _1268++;
    if (_1268 < _1266)
    goto _jump705;
    _1268 = 0;
    _1269++;
    if (_1269 < _763.d0)
    goto _jump705;
    _1269 = 0;
    _1270++;
    if (_1270 < _763.d1)
    goto _jump705;
    // End body of loop
    int64_t _1274 = 7;
    int64_t _1275 = 206;
    if (_1274 >= 0)
    goto _jump706;
    fail_assertion("negative array index");
    _jump706:;
    if (_1274 < _1265.d0)
    goto _jump707;
    fail_assertion("index too large");
    _jump707:;
    if (_1275 >= 0)
    goto _jump708;
    fail_assertion("negative array index");
    _jump708:;
    if (_1275 < _1265.d1)
    goto _jump709;
    fail_assertion("index too large");
    _jump709:;
    if (_948.d0 >= 0)
    goto _jump710;
    fail_assertion("negative array index");
    _jump710:;
    if (_948.d0 < _1265.d2)
    goto _jump711;
    fail_assertion("index too large");
    _jump711:;
    int64_t _1276 = 0;
    _1276 *= _1265.d0;
    _1276 += _1274;
    _1276 *= _1265.d1;
    _1276 += _1275;
    _1276 *= _1265.d2;
    _1276 += _948.d0;
    int64_t _1277 = _1265.data[_1276];
    _1262.d1 = _1277;
    if (_1277 > 0) 
    goto _jump712;
    fail_assertion("non-positive loop bound");
    _jump712:;
    // Computing bound for m
    if (_948.d0 >= 0)
    goto _jump713;
    fail_assertion("negative array index");
    _jump713:;
    if (_948.d0 < _763.d0)
    goto _jump714;
    fail_assertion("index too large");
    _jump714:;
    if (_763.d0 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_763.d0 < _763.d1)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    int64_t _1278 = 0;
    _1278 *= _763.d0;
    _1278 += _948.d0;
    _1278 *= _763.d1;
    _1278 += _763.d0;
    _a1_int64_t _1279 = _763.data[_1278];
    if (_948.d1 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (_948.d1 < _763.d0)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    if (_948.d0 >= 0)
    goto _jump719;
    fail_assertion("negative array index");
    _jump719:;
    if (_948.d0 < _763.d1)
    goto _jump720;
    fail_assertion("index too large");
    _jump720:;
    int64_t _1280 = 0;
    _1280 *= _763.d0;
    _1280 += _948.d1;
    _1280 *= _763.d1;
    _1280 += _948.d0;
    _a1_int64_t _1281 = _763.data[_1280];
    if (_948.d0 >= 0)
    goto _jump721;
    fail_assertion("negative array index");
    _jump721:;
    if (_948.d0 < _1281.d0)
    goto _jump722;
    fail_assertion("index too large");
    _jump722:;
    int64_t _1282 = 0;
    _1282 *= _1281.d0;
    _1282 += _948.d0;
    int64_t _1283 = _1281.data[_1282];
    if (_1283 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (_1283 < _1279.d0)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    int64_t _1284 = 0;
    _1284 *= _1279.d0;
    _1284 += _1283;
    int64_t _1285 = _1279.data[_1284];
    _1262.d2 = _1285;
    if (_1285 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing total size of heap memory to allocate
    int64_t _1286 = 1;
    _1286 *= _1264;
    _1286 *= _1277;
    _1286 *= _1285;
    _1286 *= sizeof(_a1_int64_t);
    _1262.data = jpl_alloc(_1286);
    int64_t _1287 = 0; // m
    int64_t _1288 = 0; // l
    int64_t _1289 = 0; // k
    _jump726:; // Begin body of loop
    _a1_int64_t _1290;
    if (!_777)
    goto _jump727;
    int64_t _1291;
    // Computing bound for n
    if (_1289 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    _1291 = 0;
    int64_t _1292 = 0; // n
    _jump729:; // Begin body of loop
    _1291 += _763.d0;
    _1292++;
    if (_1292 < _1289)
    goto _jump729;
    // End body of loop
    _a1_int64_t _1293;
    _1293.d0 = 2;
    _1293.data = jpl_alloc(sizeof(int64_t) * 2);
    _1293.data[0] = _1291;
    _1293.data[1] = _948.d0;
    _1290 = _1293;
    goto _jump730;
    _jump727:;
    _a1_int64_t _1294;
    // Computing bound for n
    _1294.d0 = _1288;
    if (_1288 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing total size of heap memory to allocate
    int64_t _1295 = 1;
    _1295 *= _1288;
    _1295 *= sizeof(int64_t);
    _1294.data = jpl_alloc(_1295);
    int64_t _1296 = 0; // n
    _jump732:; // Begin body of loop
    int64_t _1297 = 0;
    _1297 *= _1294.d0;
    _1297 += _1296;
    _1294.data[_1297] = _948.d1;
    _1296++;
    if (_1296 < _1288)
    goto _jump732;
    // End body of loop
    _1290 = _1294;
    _jump730:;
    int64_t _1298 = 0;
    _1298 *= _1262.d0;
    _1298 += _1289;
    _1298 *= _1262.d1;
    _1298 += _1288;
    _1298 *= _1262.d2;
    _1298 += _1287;
    _1262.data[_1298] = _1290;
    _1287++;
    if (_1287 < _1285)
    goto _jump726;
    _1287 = 0;
    _1288++;
    if (_1288 < _1277)
    goto _jump726;
    _1288 = 0;
    _1289++;
    if (_1289 < _1264)
    goto _jump726;
    // End body of loop
    _1261 = _1262;
    goto _jump733;
    _jump700:;
    _a3__a1_int64_t _1299;
    // Computing bound for k
    int64_t _1300 = _763.d1 - _948.d1;
    int64_t _1301 = _948.d0 - _948.d1;
    int64_t _1302 = _1300 % _1301;
    int64_t _1303 = _1302 + _763.d0;
    _1299.d0 = _1303;
    if (_1303 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing bound for l
    _a1_int64_t _1304;
    // Computing bound for k
    _1304.d0 = _763.d0;
    if (_763.d0 > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing total size of heap memory to allocate
    int64_t _1305 = 1;
    _1305 *= _763.d0;
    _1305 *= sizeof(int64_t);
    _1304.data = jpl_alloc(_1305);
    int64_t _1306 = 0; // k
    _jump736:; // Begin body of loop
    int64_t _1307;
    // Computing bound for l
    if (_948.d1 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    _1307 = 0;
    int64_t _1308 = 0; // l
    _jump738:; // Begin body of loop
    _1307 += _763.d0;
    _1308++;
    if (_1308 < _948.d1)
    goto _jump738;
    // End body of loop
    int64_t _1309 = 0;
    _1309 *= _1304.d0;
    _1309 += _1306;
    _1304.data[_1309] = _1307;
    _1306++;
    if (_1306 < _763.d0)
    goto _jump736;
    // End body of loop
    int64_t _1310 = -_948.d0;
    int64_t _1311 = _763.d0 % _1310;
    if (_1311 >= 0)
    goto _jump739;
    fail_assertion("negative array index");
    _jump739:;
    if (_1311 < _1304.d0)
    goto _jump740;
    fail_assertion("index too large");
    _jump740:;
    int64_t _1312 = 0;
    _1312 *= _1304.d0;
    _1312 += _1311;
    int64_t _1313 = _1304.data[_1312];
    _1299.d1 = _1313;
    if (_1313 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for m
    _1299.d2 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing total size of heap memory to allocate
    int64_t _1314 = 1;
    _1314 *= _1303;
    _1314 *= _1313;
    _1314 *= _763.d1;
    _1314 *= sizeof(_a1_int64_t);
    _1299.data = jpl_alloc(_1314);
    int64_t _1315 = 0; // m
    int64_t _1316 = 0; // l
    int64_t _1317 = 0; // k
    _jump743:; // Begin body of loop
    if (_763.d1 >= 0)
    goto _jump744;
    fail_assertion("negative array index");
    _jump744:;
    if (_763.d1 < _763.d0)
    goto _jump745;
    fail_assertion("index too large");
    _jump745:;
    if (_1317 >= 0)
    goto _jump746;
    fail_assertion("negative array index");
    _jump746:;
    if (_1317 < _763.d1)
    goto _jump747;
    fail_assertion("index too large");
    _jump747:;
    int64_t _1318 = 0;
    _1318 *= _763.d0;
    _1318 += _763.d1;
    _1318 *= _763.d1;
    _1318 += _1317;
    _a1_int64_t _1319 = _763.data[_1318];
    _a1_int64_t _1320;
    // Computing bound for n
    _1320.d0 = _1317;
    if (_1317 > 0) 
    goto _jump748;
    fail_assertion("non-positive loop bound");
    _jump748:;
    // Computing total size of heap memory to allocate
    int64_t _1321 = 1;
    _1321 *= _1317;
    _1321 *= sizeof(int64_t);
    _1320.data = jpl_alloc(_1321);
    int64_t _1322 = 0; // n
    _jump749:; // Begin body of loop
    int64_t _1323 = 0;
    _1323 *= _1320.d0;
    _1323 += _1322;
    _1320.data[_1323] = _948.d1;
    _1322++;
    if (_1322 < _1317)
    goto _jump749;
    // End body of loop
    _a1__a1_int64_t _1324;
    _1324.d0 = 2;
    _1324.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _1324.data[0] = _1319;
    _1324.data[1] = _1320;
    if (_1316 >= 0)
    goto _jump750;
    fail_assertion("negative array index");
    _jump750:;
    if (_1316 < _1324.d0)
    goto _jump751;
    fail_assertion("index too large");
    _jump751:;
    int64_t _1325 = 0;
    _1325 *= _1324.d0;
    _1325 += _1316;
    _a1_int64_t _1326 = _1324.data[_1325];
    int64_t _1327 = 0;
    _1327 *= _1299.d0;
    _1327 += _1317;
    _1327 *= _1299.d1;
    _1327 += _1316;
    _1327 *= _1299.d2;
    _1327 += _1315;
    _1299.data[_1327] = _1326;
    _1315++;
    if (_1315 < _763.d1)
    goto _jump743;
    _1315 = 0;
    _1316++;
    if (_1316 < _1313)
    goto _jump743;
    _1316 = 0;
    _1317++;
    if (_1317 < _1303)
    goto _jump743;
    // End body of loop
    _1261 = _1299;
    _jump733:;
    int64_t _1328;
    // Computing bound for k
    if (_948.d1 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for l
    int64_t _1329 = 307;
    if (_1329 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing bound for m
    int64_t _1330 = -_763.d1;
    if (_1330 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    _1328 = 0;
    int64_t _1331 = 0; // m
    int64_t _1332 = 0; // l
    int64_t _1333 = 0; // k
    _jump755:; // Begin body of loop
    _a1_int64_t _1334;
    if (!_1224)
    goto _jump756;
    _a1_int64_t _1335;
    _1335.d0 = 2;
    _1335.data = jpl_alloc(sizeof(int64_t) * 2);
    _1335.data[0] = _1333;
    _1335.data[1] = _1333;
    _1334 = _1335;
    goto _jump757;
    _jump756:;
    bool _1336 = true;
    int64_t _1337;
    if (!_1336)
    goto _jump758;
    _1337 = _1332;
    goto _jump759;
    _jump758:;
    _1337 = _1332;
    _jump759:;
    _a1_int64_t _1338;
    _1338.d0 = 2;
    _1338.data = jpl_alloc(sizeof(int64_t) * 2);
    _1338.data[0] = _1337;
    _1338.data[1] = _763.d0;
    _1334 = _1338;
    _jump757:;
    if (_1331 >= 0)
    goto _jump760;
    fail_assertion("negative array index");
    _jump760:;
    if (_1331 < _1334.d0)
    goto _jump761;
    fail_assertion("index too large");
    _jump761:;
    int64_t _1339 = 0;
    _1339 *= _1334.d0;
    _1339 += _1331;
    int64_t _1340 = _1334.data[_1339];
    _1328 += _1340;
    _1331++;
    if (_1331 < _1330)
    goto _jump755;
    _1331 = 0;
    _1332++;
    if (_1332 < _1329)
    goto _jump755;
    _1332 = 0;
    _1333++;
    if (_1333 < _948.d1)
    goto _jump755;
    // End body of loop
    int64_t _1341 = 628;
    a _1342;
    if (!_1224)
    goto _jump762;
    a _1343 = { _949, _948.d0 };
    _1342 = _1343;
    goto _jump763;
    _jump762:;
    double _1344;
    // Computing bound for k
    if (_948.d1 > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    _1344 = 0;
    int64_t _1345 = 0; // k
    _jump765:; // Begin body of loop
    double _1346 = 49.0;
    _1344 += _1346;
    _1345++;
    if (_1345 < _948.d1)
    goto _jump765;
    // End body of loop
    double _1347;
    // Computing bound for k
    if (_763.d1 > 0) 
    goto _jump766;
    fail_assertion("non-positive loop bound");
    _jump766:;
    _1347 = 0;
    int64_t _1348 = 0; // k
    _jump767:; // Begin body of loop
    double _1349 = 68.0;
    _1347 += _1349;
    _1348++;
    if (_1348 < _763.d1)
    goto _jump767;
    // End body of loop
    bool _1350 = _1344 < _1347;
    a _1351;
    if (!_1350)
    goto _jump768;
    a _1352;
    if (!_1224)
    goto _jump769;
    double _1353 = 62.0;
    int64_t _1354 = 115;
    a _1355 = { _1353, _1354 };
    _1352 = _1355;
    goto _jump770;
    _jump769:;
    double _1356 = 17.0;
    a _1357 = { _1356, _763.d0 };
    _1352 = _1357;
    _jump770:;
    _1351 = _1352;
    goto _jump771;
    _jump768:;
    double _1358 = 51.0;
    double _1359 = _949 + _1358;
    a _1360 = { _1359, _948.d0 };
    _1351 = _1360;
    _jump771:;
    _1342 = _1351;
    _jump763:;
    int64_t _1361 = _1342.b;
    if (_1328 >= 0)
    goto _jump772;
    fail_assertion("negative array index");
    _jump772:;
    if (_1328 < _1261.d0)
    goto _jump773;
    fail_assertion("index too large");
    _jump773:;
    if (_1341 >= 0)
    goto _jump774;
    fail_assertion("negative array index");
    _jump774:;
    if (_1341 < _1261.d1)
    goto _jump775;
    fail_assertion("index too large");
    _jump775:;
    if (_1361 >= 0)
    goto _jump776;
    fail_assertion("negative array index");
    _jump776:;
    if (_1361 < _1261.d2)
    goto _jump777;
    fail_assertion("index too large");
    _jump777:;
    int64_t _1362 = 0;
    _1362 *= _1261.d0;
    _1362 += _1328;
    _1362 *= _1261.d1;
    _1362 += _1341;
    _1362 *= _1261.d2;
    _1362 += _1361;
    _a1_int64_t _1363 = _1261.data[_1362];
    _1226 = _1363;
    _jump698:;
    _a3_int64_t _1364;
    // Computing bound for m
    _1364.d0 = _763.d1;
    if (_763.d1 > 0) 
    goto _jump778;
    fail_assertion("non-positive loop bound");
    _jump778:;
    // Computing bound for n
    _a2__a3_int64_t _1365;
    // Computing bound for m
    int64_t _1366 = -_763.d0;
    _1365.d0 = _1366;
    if (_1366 > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing bound for n
    int64_t _1367 = -_763.d1;
    _1365.d1 = _1367;
    if (_1367 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing total size of heap memory to allocate
    int64_t _1368 = 1;
    _1368 *= _1366;
    _1368 *= _1367;
    _1368 *= sizeof(_a3_int64_t);
    _1365.data = jpl_alloc(_1368);
    int64_t _1369 = 0; // n
    int64_t _1370 = 0; // m
    _jump781:; // Begin body of loop
    _a3_int64_t _1371;
    // Computing bound for o
    int64_t _1372;
    // Computing bound for o
    if (_763.d0 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing bound for p
    if (_1369 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing bound for q
    int64_t _1373 = 444;
    if (_1373 > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    _1372 = 0;
    int64_t _1374 = 0; // q
    int64_t _1375 = 0; // p
    int64_t _1376 = 0; // o
    _jump785:; // Begin body of loop
    _1372 += _1376;
    _1374++;
    if (_1374 < _1373)
    goto _jump785;
    _1374 = 0;
    _1375++;
    if (_1375 < _1369)
    goto _jump785;
    _1375 = 0;
    _1376++;
    if (_1376 < _763.d0)
    goto _jump785;
    // End body of loop
    _1371.d0 = _1372;
    if (_1372 > 0) 
    goto _jump786;
    fail_assertion("non-positive loop bound");
    _jump786:;
    // Computing bound for p
    _1371.d1 = _1226.d0;
    if (_1226.d0 > 0) 
    goto _jump787;
    fail_assertion("non-positive loop bound");
    _jump787:;
    // Computing bound for q
    _1371.d2 = _1370;
    if (_1370 > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    // Computing total size of heap memory to allocate
    int64_t _1377 = 1;
    _1377 *= _1372;
    _1377 *= _1226.d0;
    _1377 *= _1370;
    _1377 *= sizeof(int64_t);
    _1371.data = jpl_alloc(_1377);
    int64_t _1378 = 0; // q
    int64_t _1379 = 0; // p
    int64_t _1380 = 0; // o
    _jump789:; // Begin body of loop
    int64_t _1381;
    // Computing bound for r
    if (_763.d1 > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for s
    if (_1378 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for t
    int64_t _1382 = _1369 - _1369;
    if (_1382 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    _1381 = 0;
    int64_t _1383 = 0; // t
    int64_t _1384 = 0; // s
    int64_t _1385 = 0; // r
    _jump793:; // Begin body of loop
    int64_t _1386 = 689;
    _1381 += _1386;
    _1383++;
    if (_1383 < _1382)
    goto _jump793;
    _1383 = 0;
    _1384++;
    if (_1384 < _1378)
    goto _jump793;
    _1384 = 0;
    _1385++;
    if (_1385 < _763.d1)
    goto _jump793;
    // End body of loop
    int64_t _1387 = 0;
    _1387 *= _1371.d0;
    _1387 += _1380;
    _1387 *= _1371.d1;
    _1387 += _1379;
    _1387 *= _1371.d2;
    _1387 += _1378;
    _1371.data[_1387] = _1381;
    _1378++;
    if (_1378 < _1370)
    goto _jump789;
    _1378 = 0;
    _1379++;
    if (_1379 < _1226.d0)
    goto _jump789;
    _1379 = 0;
    _1380++;
    if (_1380 < _1372)
    goto _jump789;
    // End body of loop
    int64_t _1388 = 0;
    _1388 *= _1365.d0;
    _1388 += _1370;
    _1388 *= _1365.d1;
    _1388 += _1369;
    _1365.data[_1388] = _1371;
    _1369++;
    if (_1369 < _1367)
    goto _jump781;
    _1369 = 0;
    _1370++;
    if (_1370 < _1366)
    goto _jump781;
    // End body of loop
    double _1389 = -_949;
    double _1390 = _949 / _1389;
    bool _1391 = _777;
    if (0 != _777)
    goto _jump794;
    bool _1392 = true;
    _1391 = _1392;
    _jump794:;
    int64_t _1393;
    if (!_1391)
    goto _jump795;
    _1393 = _763.d0;
    goto _jump796;
    _jump795:;
    int64_t _1394;
    // Computing bound for m
    if (_763.d1 > 0) 
    goto _jump797;
    fail_assertion("non-positive loop bound");
    _jump797:;
    _1394 = 0;
    int64_t _1395 = 0; // m
    _jump798:; // Begin body of loop
    _1394 += _763.d1;
    _1395++;
    if (_1395 < _763.d1)
    goto _jump798;
    // End body of loop
    _1393 = _1394;
    _jump796:;
    a _1396 = { _1390, _1393 };
    int64_t _1397 = _1396.b;
    if (_763.d1 >= 0)
    goto _jump799;
    fail_assertion("negative array index");
    _jump799:;
    if (_763.d1 < _1365.d0)
    goto _jump800;
    fail_assertion("index too large");
    _jump800:;
    if (_1397 >= 0)
    goto _jump801;
    fail_assertion("negative array index");
    _jump801:;
    if (_1397 < _1365.d1)
    goto _jump802;
    fail_assertion("index too large");
    _jump802:;
    int64_t _1398 = 0;
    _1398 *= _1365.d0;
    _1398 += _763.d1;
    _1398 *= _1365.d1;
    _1398 += _1397;
    _a3_int64_t _1399 = _1365.data[_1398];
    int64_t _1400 = 78;
    int64_t _1401;
    // Computing bound for m
    int64_t _1402;
    if (!_777)
    goto _jump803;
    int64_t _1403 = 172;
    int64_t _1404 = _1403 * _763.d0;
    _1402 = _1404;
    goto _jump804;
    _jump803:;
    _1402 = _763.d1;
    _jump804:;
    if (_1402 > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing bound for n
    if (_763.d1 > 0) 
    goto _jump806;
    fail_assertion("non-positive loop bound");
    _jump806:;
    _1401 = 0;
    int64_t _1405 = 0; // n
    int64_t _1406 = 0; // m
    _jump807:; // Begin body of loop
    _1401 += _763.d1;
    _1405++;
    if (_1405 < _763.d1)
    goto _jump807;
    _1405 = 0;
    _1406++;
    if (_1406 < _1402)
    goto _jump807;
    // End body of loop
    int64_t _1407 = 954;
    if (_1400 >= 0)
    goto _jump808;
    fail_assertion("negative array index");
    _jump808:;
    if (_1400 < _1399.d0)
    goto _jump809;
    fail_assertion("index too large");
    _jump809:;
    if (_1401 >= 0)
    goto _jump810;
    fail_assertion("negative array index");
    _jump810:;
    if (_1401 < _1399.d1)
    goto _jump811;
    fail_assertion("index too large");
    _jump811:;
    if (_1407 >= 0)
    goto _jump812;
    fail_assertion("negative array index");
    _jump812:;
    if (_1407 < _1399.d2)
    goto _jump813;
    fail_assertion("index too large");
    _jump813:;
    int64_t _1408 = 0;
    _1408 *= _1399.d0;
    _1408 += _1400;
    _1408 *= _1399.d1;
    _1408 += _1401;
    _1408 *= _1399.d2;
    _1408 += _1407;
    int64_t _1409 = _1399.data[_1408];
    _1364.d1 = _1409;
    if (_1409 > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    // Computing bound for o
    int64_t _1410;
    // Computing bound for m
    double _1411 = 45.0;
    int64_t _1412;
    // Computing bound for m
    int64_t _1413;
    // Computing bound for m
    if (_948.d0 > 0) 
    goto _jump815;
    fail_assertion("non-positive loop bound");
    _jump815:;
    // Computing bound for n
    int64_t _1414 = 375;
    if (_1414 > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    _1413 = 0;
    int64_t _1415 = 0; // n
    int64_t _1416 = 0; // m
    _jump817:; // Begin body of loop
    int64_t _1417 = 30;
    _1413 += _1417;
    _1415++;
    if (_1415 < _1414)
    goto _jump817;
    _1415 = 0;
    _1416++;
    if (_1416 < _948.d0)
    goto _jump817;
    // End body of loop
    if (_1413 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for n
    if (_763.d1 > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    _1412 = 0;
    int64_t _1418 = 0; // n
    int64_t _1419 = 0; // m
    _jump820:; // Begin body of loop
    _1412 += _763.d1;
    _1418++;
    if (_1418 < _763.d1)
    goto _jump820;
    _1418 = 0;
    _1419++;
    if (_1419 < _1413)
    goto _jump820;
    // End body of loop
    a _1420 = { _1411, _1412 };
    int64_t _1421 = _1420.b;
    int64_t _1422 = _763.d0 / _1421;
    if (_1422 > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    _1410 = 0;
    int64_t _1423 = 0; // m
    _jump822:; // Begin body of loop
    _1410 += _948.d0;
    _1423++;
    if (_1423 < _1422)
    goto _jump822;
    // End body of loop
    _1364.d2 = _1410;
    if (_1410 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing total size of heap memory to allocate
    int64_t _1424 = 1;
    _1424 *= _763.d1;
    _1424 *= _1409;
    _1424 *= _1410;
    _1424 *= sizeof(int64_t);
    _1364.data = jpl_alloc(_1424);
    int64_t _1425 = 0; // o
    int64_t _1426 = 0; // n
    int64_t _1427 = 0; // m
    _jump824:; // Begin body of loop
    int64_t _1428 = 0;
    _1428 *= _1364.d0;
    _1428 += _1427;
    _1428 *= _1364.d1;
    _1428 += _1426;
    _1428 *= _1364.d2;
    _1428 += _1425;
    _1364.data[_1428] = _763.d0;
    _1425++;
    if (_1425 < _1410)
    goto _jump824;
    _1425 = 0;
    _1426++;
    if (_1426 < _1409)
    goto _jump824;
    _1426 = 0;
    _1427++;
    if (_1427 < _763.d1)
    goto _jump824;
    // End body of loop
    _a2_rgba _1429 = read_image("t.png");
    _a2_rgba _1430 = read_image("u.png");
    if (_948.d0 >= 0)
    goto _jump833;
    fail_assertion("negative array index");
    _jump833:;
    if (_948.d0 < _1226.d0)
    goto _jump834;
    fail_assertion("index too large");
    _jump834:;
    int64_t _1431 = 0;
    _1431 *= _1226.d0;
    _1431 += _948.d0;
    int64_t _1432 = _1226.data[_1431];
    int64_t _1433 = v();
}

