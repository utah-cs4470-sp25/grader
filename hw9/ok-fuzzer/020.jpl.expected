
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
    bool a;
    double b;
    bool c;
} a;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  a *data;
} _a2_a;

typedef struct {
  int64_t d0;
  _a2_a *data;
} _a1__a2_a;

typedef struct {
  int64_t d0;
  _a1__a2_a *data;
} _a1__a1__a2_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  a *data;
} _a1_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_a *data;
} _a2__a2_a;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_bool *data;
} _a2__a3__a2_bool;

typedef struct {
  int64_t d0;
  _a2__a3__a2_bool *data;
} _a1__a2__a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_double *data;
} _a3__a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  a *data;
} _a3_a;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

rgba e(_a2_bool f, _a2_a i, void_t l) {
    _a1__a1__a2_a _0;
    // Computing bound for m
    _a2_int64_t _1;
    // Computing bound for m
    _1.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing bound for n
    _1.d1 = c;
    if (c > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= i.d1;
    _2 *= c;
    _2 *= sizeof(int64_t);
    _1.data = jpl_alloc(_2);
    int64_t _3 = 0; // n
    int64_t _4 = 0; // m
    _jump3:; // Begin body of loop
    int64_t _5 = 0;
    _5 *= _1.d0;
    _5 += _4;
    _5 *= _1.d1;
    _5 += _3;
    _1.data[_5] = _3;
    _3++;
    if (_3 < c)
    goto _jump3;
    _3 = 0;
    _4++;
    if (_4 < i.d1)
    goto _jump3;
    // End body of loop
    int64_t _6 = f.d0 + i.d0;
    int64_t _7 = -_6;
    if (i.d1 >= 0)
    goto _jump4;
    fail_assertion("negative array index");
    _jump4:;
    if (i.d1 < _1.d0)
    goto _jump5;
    fail_assertion("index too large");
    _jump5:;
    if (_7 >= 0)
    goto _jump6;
    fail_assertion("negative array index");
    _jump6:;
    if (_7 < _1.d1)
    goto _jump7;
    fail_assertion("index too large");
    _jump7:;
    int64_t _8 = 0;
    _8 *= _1.d0;
    _8 += i.d1;
    _8 *= _1.d1;
    _8 += _7;
    int64_t _9 = _1.data[_8];
    _0.d0 = _9;
    if (_9 > 0) 
    goto _jump8;
    fail_assertion("non-positive loop bound");
    _jump8:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _9;
    _10 *= sizeof(_a1__a2_a);
    _0.data = jpl_alloc(_10);
    int64_t _11 = 0; // m
    _jump9:; // Begin body of loop
    _a1__a1__a2_a _12;
    // Computing bound for n
    _12.d0 = _11;
    if (_11 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _11;
    _13 *= sizeof(_a1__a2_a);
    _12.data = jpl_alloc(_13);
    int64_t _14 = 0; // n
    _jump11:; // Begin body of loop
    _a1__a2_a _15;
    // Computing bound for o
    int64_t _16 = 209;
    _15.d0 = _16;
    if (_16 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    // Computing total size of heap memory to allocate
    int64_t _17 = 1;
    _17 *= _16;
    _17 *= sizeof(_a2_a);
    _15.data = jpl_alloc(_17);
    int64_t _18 = 0; // o
    _jump13:; // Begin body of loop
    int64_t _19 = 0;
    _19 *= _15.d0;
    _19 += _18;
    _15.data[_19] = i;
    _18++;
    if (_18 < _16)
    goto _jump13;
    // End body of loop
    int64_t _20 = 0;
    _20 *= _12.d0;
    _20 += _14;
    _12.data[_20] = _15;
    _14++;
    if (_14 < _11)
    goto _jump11;
    // End body of loop
    int64_t _21;
    // Computing bound for n
    if (f.d1 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing bound for o
    if (i.d0 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    _21 = 0;
    int64_t _22 = 0; // o
    int64_t _23 = 0; // n
    _jump16:; // Begin body of loop
    _21 += _11;
    _22++;
    if (_22 < i.d0)
    goto _jump16;
    _22 = 0;
    _23++;
    if (_23 < f.d1)
    goto _jump16;
    // End body of loop
    int64_t _24 = -_21;
    if (_24 >= 0)
    goto _jump17;
    fail_assertion("negative array index");
    _jump17:;
    if (_24 < _12.d0)
    goto _jump18;
    fail_assertion("index too large");
    _jump18:;
    int64_t _25 = 0;
    _25 *= _12.d0;
    _25 += _24;
    _a1__a2_a _26 = _12.data[_25];
    int64_t _27 = 0;
    _27 *= _0.d0;
    _27 += _11;
    _0.data[_27] = _26;
    _11++;
    if (_11 < _9)
    goto _jump9;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump19;
    fail_assertion("negative array index");
    _jump19:;
    if (i.d0 < _0.d0)
    goto _jump20;
    fail_assertion("index too large");
    _jump20:;
    int64_t _28 = 0;
    _28 *= _0.d0;
    _28 += i.d0;
    _a1__a2_a _29 = _0.data[_28];
    int64_t _30;
    // Computing bound for m
    if (d > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    _30 = 0;
    int64_t _31 = 0; // m
    _jump22:; // Begin body of loop
    _a1_int64_t _32;
    // Computing bound for n
    _32.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= i.d1;
    _33 *= sizeof(int64_t);
    _32.data = jpl_alloc(_33);
    int64_t _34 = 0; // n
    _jump24:; // Begin body of loop
    int64_t _35 = 0;
    _35 *= _32.d0;
    _35 += _34;
    _32.data[_35] = i.d1;
    _34++;
    if (_34 < i.d1)
    goto _jump24;
    // End body of loop
    _a2_int64_t _36;
    // Computing bound for n
    bool _37 = false;
    int64_t _38;
    if (!_37)
    goto _jump25;
    int64_t _39 = 747;
    _38 = _39;
    goto _jump26;
    _jump25:;
    int64_t _40 = 251;
    _38 = _40;
    _jump26:;
    _36.d0 = _38;
    if (_38 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    // Computing bound for o
    int64_t _41 = 506;
    _36.d1 = _41;
    if (_41 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= _38;
    _42 *= _41;
    _42 *= sizeof(int64_t);
    _36.data = jpl_alloc(_42);
    int64_t _43 = 0; // o
    int64_t _44 = 0; // n
    _jump29:; // Begin body of loop
    int64_t _45 = 0;
    _45 *= _36.d0;
    _45 += _44;
    _45 *= _36.d1;
    _45 += _43;
    _36.data[_45] = i.d0;
    _43++;
    if (_43 < _41)
    goto _jump29;
    _43 = 0;
    _44++;
    if (_44 < _38)
    goto _jump29;
    // End body of loop
    if (c >= 0)
    goto _jump30;
    fail_assertion("negative array index");
    _jump30:;
    if (c < _36.d0)
    goto _jump31;
    fail_assertion("index too large");
    _jump31:;
    if (_31 >= 0)
    goto _jump32;
    fail_assertion("negative array index");
    _jump32:;
    if (_31 < _36.d1)
    goto _jump33;
    fail_assertion("index too large");
    _jump33:;
    int64_t _46 = 0;
    _46 *= _36.d0;
    _46 += c;
    _46 *= _36.d1;
    _46 += _31;
    int64_t _47 = _36.data[_46];
    if (_47 >= 0)
    goto _jump34;
    fail_assertion("negative array index");
    _jump34:;
    if (_47 < _32.d0)
    goto _jump35;
    fail_assertion("index too large");
    _jump35:;
    int64_t _48 = 0;
    _48 *= _32.d0;
    _48 += _47;
    int64_t _49 = _32.data[_48];
    _30 += _49;
    _31++;
    if (_31 < d)
    goto _jump22;
    // End body of loop
    if (_30 >= 0)
    goto _jump36;
    fail_assertion("negative array index");
    _jump36:;
    if (_30 < _29.d0)
    goto _jump37;
    fail_assertion("index too large");
    _jump37:;
    int64_t _50 = 0;
    _50 *= _29.d0;
    _50 += _30;
    _a2_a _51 = _29.data[_50];
    rgba _52 = e(f, _51, l);
    return _52;
    int64_t _53;
    // Computing bound for n
    int64_t _54;
    // Computing bound for n
    if (i.d1 > 0) 
    goto _jump38;
    fail_assertion("non-positive loop bound");
    _jump38:;
    // Computing bound for o
    if (f.d0 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    _54 = 0;
    int64_t _55 = 0; // o
    int64_t _56 = 0; // n
    _jump40:; // Begin body of loop
    _54 += f.d0;
    _55++;
    if (_55 < f.d0)
    goto _jump40;
    _55 = 0;
    _56++;
    if (_56 < i.d1)
    goto _jump40;
    // End body of loop
    if (_54 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    // Computing bound for o
    if (d > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    _53 = 0;
    int64_t _57 = 0; // o
    int64_t _58 = 0; // n
    _jump43:; // Begin body of loop
    int64_t _59 = -i.d0;
    _53 += _59;
    _57++;
    if (_57 < d)
    goto _jump43;
    _57 = 0;
    _58++;
    if (_58 < _54)
    goto _jump43;
    // End body of loop
    bool _60 = _53 != i.d0;
    bool _61;
    if (!_60)
    goto _jump44;
    _a1_a _63;
    // Computing bound for n
    _63.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= i.d1;
    _64 *= sizeof(a);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // n
    _jump46:; // Begin body of loop
    if (i.d1 >= 0)
    goto _jump47;
    fail_assertion("negative array index");
    _jump47:;
    if (i.d1 < i.d0)
    goto _jump48;
    fail_assertion("index too large");
    _jump48:;
    if (i.d1 >= 0)
    goto _jump49;
    fail_assertion("negative array index");
    _jump49:;
    if (i.d1 < i.d1)
    goto _jump50;
    fail_assertion("index too large");
    _jump50:;
    int64_t _66 = 0;
    _66 *= i.d0;
    _66 += i.d1;
    _66 *= i.d1;
    _66 += i.d1;
    a _67 = i.data[_66];
    int64_t _68 = 0;
    _68 *= _63.d0;
    _68 += _65;
    _63.data[_68] = _67;
    _65++;
    if (_65 < i.d1)
    goto _jump46;
    // End body of loop
    if (d >= 0)
    goto _jump51;
    fail_assertion("negative array index");
    _jump51:;
    if (d < _63.d0)
    goto _jump52;
    fail_assertion("index too large");
    _jump52:;
    int64_t _69 = 0;
    _69 *= _63.d0;
    _69 += d;
    a _70 = _63.data[_69];
    bool _71 = _70.c;
    bool _62 = _71;
    if (0 == _71)
    goto _jump53;
    int64_t _72 = 477;
    int64_t _73;
    // Computing bound for n
    if (i.d0 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for o
    int64_t _74 = 379;
    if (_74 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    _73 = 0;
    int64_t _75 = 0; // o
    int64_t _76 = 0; // n
    _jump56:; // Begin body of loop
    int64_t _77 = -d;
    _73 += _77;
    _75++;
    if (_75 < _74)
    goto _jump56;
    _75 = 0;
    _76++;
    if (_76 < i.d0)
    goto _jump56;
    // End body of loop
    bool _78 = _72 >= _73;
    _62 = _78;
    _jump53:;
    _61 = _62;
    goto _jump57;
    _jump44:;
    bool _79 = true;
    _61 = _79;
    _jump57:;
    bool _80 = !_61;
    bool _81 = true;
    bool _82;
    if (!_81)
    goto _jump58;
    _82 = _80;
    goto _jump59;
    _jump58:;
    bool _83 = _80;
    if (0 != _80)
    goto _jump60;
    _83 = _80;
    _jump60:;
    bool _84;
    if (!_83)
    goto _jump61;
    int64_t _85 = 9;
    if (i.d0 >= 0)
    goto _jump62;
    fail_assertion("negative array index");
    _jump62:;
    if (i.d0 < f.d0)
    goto _jump63;
    fail_assertion("index too large");
    _jump63:;
    if (_85 >= 0)
    goto _jump64;
    fail_assertion("negative array index");
    _jump64:;
    if (_85 < f.d1)
    goto _jump65;
    fail_assertion("index too large");
    _jump65:;
    int64_t _86 = 0;
    _86 *= f.d0;
    _86 += i.d0;
    _86 *= f.d1;
    _86 += _85;
    bool _87 = f.data[_86];
    _84 = _87;
    goto _jump66;
    _jump61:;
    bool _89 = false;
    bool _88 = _89;
    if (0 != _89)
    goto _jump67;
    _88 = _80;
    _jump67:;
    _84 = _88;
    _jump66:;
    _82 = _84;
    _jump59:;
    a _90;
    if (!_82)
    goto _jump68;
    if (f.d1 >= 0)
    goto _jump69;
    fail_assertion("negative array index");
    _jump69:;
    if (f.d1 < f.d0)
    goto _jump70;
    fail_assertion("index too large");
    _jump70:;
    if (f.d0 >= 0)
    goto _jump71;
    fail_assertion("negative array index");
    _jump71:;
    if (f.d0 < f.d1)
    goto _jump72;
    fail_assertion("index too large");
    _jump72:;
    int64_t _91 = 0;
    _91 *= f.d0;
    _91 += f.d1;
    _91 *= f.d1;
    _91 += f.d0;
    bool _92 = f.data[_91];
    a _93;
    if (!_92)
    goto _jump73;
    double _94 = 9.0;
    double _95 = 18.0;
    double _96 = 54.0;
    bool _97 = _95 >= _96;
    a _98 = { _80, _94, _97 };
    _93 = _98;
    goto _jump74;
    _jump73:;
    bool _99 = false;
    double _100 = 90.0;
    double _101 = -_100;
    int64_t _102 = 640;
    bool _103 = _102 != c;
    a _104 = { _99, _101, _103 };
    _93 = _104;
    _jump74:;
    _90 = _93;
    goto _jump75;
    _jump68:;
    _a2__a2_a _105;
    // Computing bound for o
    _105.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for p
    _105.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= i.d0;
    _106 *= f.d0;
    _106 *= sizeof(_a2_a);
    _105.data = jpl_alloc(_106);
    int64_t _107 = 0; // p
    int64_t _108 = 0; // o
    _jump78:; // Begin body of loop
    int64_t _109 = 0;
    _109 *= _105.d0;
    _109 += _108;
    _109 *= _105.d1;
    _109 += _107;
    _105.data[_109] = i;
    _107++;
    if (_107 < f.d0)
    goto _jump78;
    _107 = 0;
    _108++;
    if (_108 < i.d0)
    goto _jump78;
    // End body of loop
    if (d >= 0)
    goto _jump79;
    fail_assertion("negative array index");
    _jump79:;
    if (d < _105.d0)
    goto _jump80;
    fail_assertion("index too large");
    _jump80:;
    if (f.d0 >= 0)
    goto _jump81;
    fail_assertion("negative array index");
    _jump81:;
    if (f.d0 < _105.d1)
    goto _jump82;
    fail_assertion("index too large");
    _jump82:;
    int64_t _110 = 0;
    _110 *= _105.d0;
    _110 += d;
    _110 *= _105.d1;
    _110 += f.d0;
    _a2_a _111 = _105.data[_110];
    bool _112 = true;
    int64_t _113;
    if (!_112)
    goto _jump83;
    _113 = d;
    goto _jump84;
    _jump83:;
    _113 = c;
    _jump84:;
    if (i.d1 >= 0)
    goto _jump85;
    fail_assertion("negative array index");
    _jump85:;
    if (i.d1 < _111.d0)
    goto _jump86;
    fail_assertion("index too large");
    _jump86:;
    if (_113 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_113 < _111.d1)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    int64_t _114 = 0;
    _114 *= _111.d0;
    _114 += i.d1;
    _114 *= _111.d1;
    _114 += _113;
    a _115 = _111.data[_114];
    _90 = _115;
    _jump75:;
    bool _116 = _90.a;
    _a1_rgba _117;
    if (!_116)
    goto _jump89;
    double _118 = 67.0;
    double _119 = 14.0;
    double _120;
    // Computing bound for o
    if (d > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing bound for p
    if (f.d0 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for q
    if (i.d0 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    _120 = 0;
    int64_t _121 = 0; // q
    int64_t _122 = 0; // p
    int64_t _123 = 0; // o
    _jump93:; // Begin body of loop
    double _124 = 74.0;
    _120 += _124;
    _121++;
    if (_121 < i.d0)
    goto _jump93;
    _121 = 0;
    _122++;
    if (_122 < f.d0)
    goto _jump93;
    _122 = 0;
    _123++;
    if (_123 < d)
    goto _jump93;
    // End body of loop
    _a2_double _125;
    // Computing bound for o
    int64_t _126 = 365;
    int64_t _127 = i.d0 - _126;
    _125.d0 = _127;
    if (_127 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    // Computing bound for p
    _125.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _127;
    _128 *= i.d0;
    _128 *= sizeof(double);
    _125.data = jpl_alloc(_128);
    int64_t _129 = 0; // p
    int64_t _130 = 0; // o
    _jump96:; // Begin body of loop
    double _131 = 98.0;
    int64_t _132 = 0;
    _132 *= _125.d0;
    _132 += _130;
    _132 *= _125.d1;
    _132 += _129;
    _125.data[_132] = _131;
    _129++;
    if (_129 < i.d0)
    goto _jump96;
    _129 = 0;
    _130++;
    if (_130 < _127)
    goto _jump96;
    // End body of loop
    int64_t _133 = 496;
    int64_t _134;
    // Computing bound for o
    if (d > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing bound for p
    if (d > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    _134 = 0;
    int64_t _135 = 0; // p
    int64_t _136 = 0; // o
    _jump99:; // Begin body of loop
    _134 += i.d0;
    _135++;
    if (_135 < d)
    goto _jump99;
    _135 = 0;
    _136++;
    if (_136 < d)
    goto _jump99;
    // End body of loop
    if (_133 >= 0)
    goto _jump100;
    fail_assertion("negative array index");
    _jump100:;
    if (_133 < _125.d0)
    goto _jump101;
    fail_assertion("index too large");
    _jump101:;
    if (_134 >= 0)
    goto _jump102;
    fail_assertion("negative array index");
    _jump102:;
    if (_134 < _125.d1)
    goto _jump103;
    fail_assertion("index too large");
    _jump103:;
    int64_t _137 = 0;
    _137 *= _125.d0;
    _137 += _133;
    _137 *= _125.d1;
    _137 += _134;
    double _138 = _125.data[_137];
    rgba _139 = { _118, _119, _120, _138 };
    double _140 = 64.0;
    double _141;
    // Computing bound for o
    if (f.d1 > 0) 
    goto _jump104;
    fail_assertion("non-positive loop bound");
    _jump104:;
    // Computing bound for p
    if (c > 0) 
    goto _jump105;
    fail_assertion("non-positive loop bound");
    _jump105:;
    _141 = 0;
    int64_t _142 = 0; // p
    int64_t _143 = 0; // o
    _jump106:; // Begin body of loop
    double _144 = 52.0;
    _141 += _144;
    _142++;
    if (_142 < c)
    goto _jump106;
    _142 = 0;
    _143++;
    if (_143 < f.d1)
    goto _jump106;
    // End body of loop
    double _145 = 98.0;
    double _146 = _141 / _145;
    bool _147 = _140 > _146;
    rgba _148;
    if (!_147)
    goto _jump107;
    _a2_bool _149;
    // Computing bound for o
    int64_t _150 = 229;
    _149.d0 = _150;
    if (_150 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    // Computing bound for p
    int64_t _151 = 185;
    _149.d1 = _151;
    if (_151 > 0) 
    goto _jump109;
    fail_assertion("non-positive loop bound");
    _jump109:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= _150;
    _152 *= _151;
    _152 *= sizeof(bool);
    _149.data = jpl_alloc(_152);
    int64_t _153 = 0; // p
    int64_t _154 = 0; // o
    _jump110:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _149.d0;
    _155 += _154;
    _155 *= _149.d1;
    _155 += _153;
    _149.data[_155] = _80;
    _153++;
    if (_153 < _151)
    goto _jump110;
    _153 = 0;
    _154++;
    if (_154 < _150)
    goto _jump110;
    // End body of loop
    _a2_void_t _156;
    // Computing bound for o
    _156.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing bound for p
    _156.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= f.d0;
    _157 *= i.d0;
    _157 *= sizeof(void_t);
    _156.data = jpl_alloc(_157);
    int64_t _158 = 0; // p
    int64_t _159 = 0; // o
    _jump113:; // Begin body of loop
    int64_t _160 = 0;
    _160 *= _156.d0;
    _160 += _159;
    _160 *= _156.d1;
    _160 += _158;
    _156.data[_160] = l;
    _158++;
    if (_158 < i.d0)
    goto _jump113;
    _158 = 0;
    _159++;
    if (_159 < f.d0)
    goto _jump113;
    // End body of loop
    bool _161 = true;
    int64_t _162;
    if (!_161)
    goto _jump114;
    _162 = f.d0;
    goto _jump115;
    _jump114:;
    _162 = f.d1;
    _jump115:;
    int64_t _163;
    // Computing bound for o
    if (c > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    // Computing bound for p
    int64_t _164 = 398;
    if (_164 > 0) 
    goto _jump117;
    fail_assertion("non-positive loop bound");
    _jump117:;
    // Computing bound for q
    if (i.d0 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    _163 = 0;
    int64_t _165 = 0; // q
    int64_t _166 = 0; // p
    int64_t _167 = 0; // o
    _jump119:; // Begin body of loop
    _163 += d;
    _165++;
    if (_165 < i.d0)
    goto _jump119;
    _165 = 0;
    _166++;
    if (_166 < _164)
    goto _jump119;
    _166 = 0;
    _167++;
    if (_167 < c)
    goto _jump119;
    // End body of loop
    if (_162 >= 0)
    goto _jump120;
    fail_assertion("negative array index");
    _jump120:;
    if (_162 < _156.d0)
    goto _jump121;
    fail_assertion("index too large");
    _jump121:;
    if (_163 >= 0)
    goto _jump122;
    fail_assertion("negative array index");
    _jump122:;
    if (_163 < _156.d1)
    goto _jump123;
    fail_assertion("index too large");
    _jump123:;
    int64_t _168 = 0;
    _168 *= _156.d0;
    _168 += _162;
    _168 *= _156.d1;
    _168 += _163;
    void_t _169 = _156.data[_168];
    rgba _170 = e(_149, i, _169);
    _148 = _170;
    goto _jump124;
    _jump107:;
    if (d >= 0)
    goto _jump125;
    fail_assertion("negative array index");
    _jump125:;
    if (d < b.d0)
    goto _jump126;
    fail_assertion("index too large");
    _jump126:;
    if (f.d1 >= 0)
    goto _jump127;
    fail_assertion("negative array index");
    _jump127:;
    if (f.d1 < b.d1)
    goto _jump128;
    fail_assertion("index too large");
    _jump128:;
    int64_t _171 = 0;
    _171 *= b.d0;
    _171 += d;
    _171 *= b.d1;
    _171 += f.d1;
    rgba _172 = b.data[_171];
    _148 = _172;
    _jump124:;
    _a1_rgba _173;
    _173.d0 = 2;
    _173.data = jpl_alloc(sizeof(rgba) * 2);
    _173.data[0] = _139;
    _173.data[1] = _148;
    _117 = _173;
    goto _jump129;
    _jump89:;
    int64_t _174 = 567;
    if (_174 >= 0)
    goto _jump130;
    fail_assertion("negative array index");
    _jump130:;
    if (_174 < f.d0)
    goto _jump131;
    fail_assertion("index too large");
    _jump131:;
    if (i.d0 >= 0)
    goto _jump132;
    fail_assertion("negative array index");
    _jump132:;
    if (i.d0 < f.d1)
    goto _jump133;
    fail_assertion("index too large");
    _jump133:;
    int64_t _175 = 0;
    _175 *= f.d0;
    _175 += _174;
    _175 *= f.d1;
    _175 += i.d0;
    bool _176 = f.data[_175];
    bool _177 = !_176;
    bool _178 = !_177;
    _a1_rgba _179;
    if (!_178)
    goto _jump134;
    double _180 = 33.0;
    double _181 = 85.0;
    double _182 = _180 - _181;
    double _183 = 62.0;
    double _184 = -_183;
    double _185;
    // Computing bound for o
    int64_t _186;
    // Computing bound for o
    if (d > 0) 
    goto _jump135;
    fail_assertion("non-positive loop bound");
    _jump135:;
    // Computing bound for p
    int64_t _187 = 210;
    if (_187 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    _186 = 0;
    int64_t _188 = 0; // p
    int64_t _189 = 0; // o
    _jump137:; // Begin body of loop
    _186 += i.d0;
    _188++;
    if (_188 < _187)
    goto _jump137;
    _188 = 0;
    _189++;
    if (_189 < d)
    goto _jump137;
    // End body of loop
    if (_186 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    // Computing bound for p
    int64_t _190 = 797;
    if (_190 > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing bound for q
    int64_t _191 = 814;
    if (_191 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    _185 = 0;
    int64_t _192 = 0; // q
    int64_t _193 = 0; // p
    int64_t _194 = 0; // o
    _jump141:; // Begin body of loop
    double _195 = 41.0;
    _185 += _195;
    _192++;
    if (_192 < _191)
    goto _jump141;
    _192 = 0;
    _193++;
    if (_193 < _190)
    goto _jump141;
    _193 = 0;
    _194++;
    if (_194 < _186)
    goto _jump141;
    // End body of loop
    double _196 = 61.0;
    double _197 = -_196;
    rgba _198 = { _182, _184, _185, _197 };
    _a1_rgba _199;
    _199.d0 = 1;
    _199.data = jpl_alloc(sizeof(rgba) * 1);
    _199.data[0] = _198;
    _179 = _199;
    goto _jump142;
    _jump134:;
    _a1_rgba _200;
    // Computing bound for o
    _200.d0 = d;
    if (d > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    // Computing total size of heap memory to allocate
    int64_t _201 = 1;
    _201 *= d;
    _201 *= sizeof(rgba);
    _200.data = jpl_alloc(_201);
    int64_t _202 = 0; // o
    _jump144:; // Begin body of loop
    double _203 = 44.0;
    double _204 = 91.0;
    double _205 = -_204;
    double _206 = _203 * _205;
    double _207 = 77.0;
    double _208 = -_207;
    double _209 = -_208;
    _a2_double _210;
    // Computing bound for p
    _210.d0 = f.d1;
    if (f.d1 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing bound for q
    _210.d1 = d;
    if (d > 0) 
    goto _jump146;
    fail_assertion("non-positive loop bound");
    _jump146:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= f.d1;
    _211 *= d;
    _211 *= sizeof(double);
    _210.data = jpl_alloc(_211);
    int64_t _212 = 0; // q
    int64_t _213 = 0; // p
    _jump147:; // Begin body of loop
    double _214 = 39.0;
    int64_t _215 = 0;
    _215 *= _210.d0;
    _215 += _213;
    _215 *= _210.d1;
    _215 += _212;
    _210.data[_215] = _214;
    _212++;
    if (_212 < d)
    goto _jump147;
    _212 = 0;
    _213++;
    if (_213 < f.d1)
    goto _jump147;
    // End body of loop
    int64_t _216 = 388;
    if (_216 >= 0)
    goto _jump148;
    fail_assertion("negative array index");
    _jump148:;
    if (_216 < _210.d0)
    goto _jump149;
    fail_assertion("index too large");
    _jump149:;
    if (f.d1 >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (f.d1 < _210.d1)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    int64_t _217 = 0;
    _217 *= _210.d0;
    _217 += _216;
    _217 *= _210.d1;
    _217 += f.d1;
    double _218 = _210.data[_217];
    if (c >= 0)
    goto _jump152;
    fail_assertion("negative array index");
    _jump152:;
    if (c < b.d0)
    goto _jump153;
    fail_assertion("index too large");
    _jump153:;
    if (c >= 0)
    goto _jump154;
    fail_assertion("negative array index");
    _jump154:;
    if (c < b.d1)
    goto _jump155;
    fail_assertion("index too large");
    _jump155:;
    int64_t _219 = 0;
    _219 *= b.d0;
    _219 += c;
    _219 *= b.d1;
    _219 += c;
    rgba _220 = b.data[_219];
    double _221 = _220.b;
    rgba _222 = { _206, _209, _218, _221 };
    int64_t _223 = 0;
    _223 *= _200.d0;
    _223 += _202;
    _200.data[_223] = _222;
    _202++;
    if (_202 < d)
    goto _jump144;
    // End body of loop
    _179 = _200;
    _jump142:;
    _117 = _179;
    _jump129:;
    if (c >= 0)
    goto _jump156;
    fail_assertion("negative array index");
    _jump156:;
    if (c < _117.d0)
    goto _jump157;
    fail_assertion("index too large");
    _jump157:;
    int64_t _224 = 0;
    _224 *= _117.d0;
    _224 += c;
    rgba _225 = _117.data[_224];
    return _225;
    bool _226 = false;
    bool _227;
    if (!_226)
    goto _jump158;
    _227 = _80;
    goto _jump159;
    _jump158:;
    if (c >= 0)
    goto _jump160;
    fail_assertion("negative array index");
    _jump160:;
    if (c < f.d0)
    goto _jump161;
    fail_assertion("index too large");
    _jump161:;
    if (f.d1 >= 0)
    goto _jump162;
    fail_assertion("negative array index");
    _jump162:;
    if (f.d1 < f.d1)
    goto _jump163;
    fail_assertion("index too large");
    _jump163:;
    int64_t _228 = 0;
    _228 *= f.d0;
    _228 += c;
    _228 *= f.d1;
    _228 += f.d1;
    bool _229 = f.data[_228];
    _227 = _229;
    _jump159:;
    a _230;
    if (!_227)
    goto _jump164;
    if (b.d1 >= 0)
    goto _jump165;
    fail_assertion("negative array index");
    _jump165:;
    if (b.d1 < i.d0)
    goto _jump166;
    fail_assertion("index too large");
    _jump166:;
    if (f.d1 >= 0)
    goto _jump167;
    fail_assertion("negative array index");
    _jump167:;
    if (f.d1 < i.d1)
    goto _jump168;
    fail_assertion("index too large");
    _jump168:;
    int64_t _231 = 0;
    _231 *= i.d0;
    _231 += b.d1;
    _231 *= i.d1;
    _231 += f.d1;
    a _232 = i.data[_231];
    _230 = _232;
    goto _jump169;
    _jump164:;
    bool _234 = true;
    bool _233 = _234;
    if (0 != _234)
    goto _jump170;
    _233 = _80;
    _jump170:;
    a _235;
    if (!_233)
    goto _jump171;
    double _236 = 25.0;
    a _237 = { _80, _236, _80 };
    _235 = _237;
    goto _jump172;
    _jump171:;
    double _238 = 88.0;
    a _239 = { _80, _238, _80 };
    _235 = _239;
    _jump172:;
    _230 = _235;
    _jump169:;
    bool _240 = _230.a;
    double _241 = 28.0;
    double _242 = -_241;
    double _243 = -_242;
    bool _244 = f.d0 > d;
    a _245 = { _240, _243, _244 };
    double _246 = _245.b;
    _a3_bool _247;
    // Computing bound for u
    _247.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump173;
    fail_assertion("non-positive loop bound");
    _jump173:;
    // Computing bound for v
    int64_t _248 = -i.d0;
    _247.d1 = _248;
    if (_248 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    // Computing bound for w
    _247.d2 = f.d1;
    if (f.d1 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing total size of heap memory to allocate
    int64_t _249 = 1;
    _249 *= f.d0;
    _249 *= _248;
    _249 *= f.d1;
    _249 *= sizeof(bool);
    _247.data = jpl_alloc(_249);
    int64_t _250 = 0; // w
    int64_t _251 = 0; // v
    int64_t _252 = 0; // u
    _jump176:; // Begin body of loop
    int64_t _253 = 0;
    _253 *= _247.d0;
    _253 += _252;
    _253 *= _247.d1;
    _253 += _251;
    _253 *= _247.d2;
    _253 += _250;
    _247.data[_253] = _80;
    _250++;
    if (_250 < f.d1)
    goto _jump176;
    _250 = 0;
    _251++;
    if (_251 < _248)
    goto _jump176;
    _251 = 0;
    _252++;
    if (_252 < f.d0)
    goto _jump176;
    // End body of loop
    int64_t _254 = -f.d1;
    int64_t _255 = _254 * f.d1;
    int64_t _256 = c + f.d0;
    if (f.d1 >= 0)
    goto _jump177;
    fail_assertion("negative array index");
    _jump177:;
    if (f.d1 < _247.d0)
    goto _jump178;
    fail_assertion("index too large");
    _jump178:;
    if (_255 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_255 < _247.d1)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    if (_256 >= 0)
    goto _jump181;
    fail_assertion("negative array index");
    _jump181:;
    if (_256 < _247.d2)
    goto _jump182;
    fail_assertion("index too large");
    _jump182:;
    int64_t _257 = 0;
    _257 *= _247.d0;
    _257 += f.d1;
    _257 *= _247.d1;
    _257 += _255;
    _257 *= _247.d2;
    _257 += _256;
    bool _258 = _247.data[_257];
    bool _259 = !_258;
    rgba _260 = e(f, i, l);
    double _261 = _260.g;
    _a2_double _262;
    // Computing bound for u
    _262.d0 = f.d0;
    if (f.d0 > 0) 
    goto _jump183;
    fail_assertion("non-positive loop bound");
    _jump183:;
    // Computing bound for v
    _262.d1 = d;
    if (d > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= f.d0;
    _263 *= d;
    _263 *= sizeof(double);
    _262.data = jpl_alloc(_263);
    int64_t _264 = 0; // v
    int64_t _265 = 0; // u
    _jump185:; // Begin body of loop
    double _266 = 34.0;
    int64_t _267 = 0;
    _267 *= _262.d0;
    _267 += _265;
    _267 *= _262.d1;
    _267 += _264;
    _262.data[_267] = _266;
    _264++;
    if (_264 < d)
    goto _jump185;
    _264 = 0;
    _265++;
    if (_265 < f.d0)
    goto _jump185;
    // End body of loop
    if (i.d1 >= 0)
    goto _jump186;
    fail_assertion("negative array index");
    _jump186:;
    if (i.d1 < _262.d0)
    goto _jump187;
    fail_assertion("index too large");
    _jump187:;
    if (f.d0 >= 0)
    goto _jump188;
    fail_assertion("negative array index");
    _jump188:;
    if (f.d0 < _262.d1)
    goto _jump189;
    fail_assertion("index too large");
    _jump189:;
    int64_t _268 = 0;
    _268 *= _262.d0;
    _268 += i.d1;
    _268 *= _262.d1;
    _268 += f.d0;
    double _269 = _262.data[_268];
    int64_t _270 = 339;
    if (d >= 0)
    goto _jump190;
    fail_assertion("negative array index");
    _jump190:;
    if (d < b.d0)
    goto _jump191;
    fail_assertion("index too large");
    _jump191:;
    if (_270 >= 0)
    goto _jump192;
    fail_assertion("negative array index");
    _jump192:;
    if (_270 < b.d1)
    goto _jump193;
    fail_assertion("index too large");
    _jump193:;
    int64_t _271 = 0;
    _271 *= b.d0;
    _271 += d;
    _271 *= b.d1;
    _271 += _270;
    rgba _272 = b.data[_271];
    double _273 = _272.b;
    double _274 = _269 / _273;
    double _275 = fmod(_261, _274);
    bool _276 = true;
    int64_t _277;
    if (!_276)
    goto _jump194;
    _277 = f.d1;
    goto _jump195;
    _jump194:;
    int64_t _278 = 408;
    _277 = _278;
    _jump195:;
    bool _279 = _277 == i.d1;
    a _280 = { _259, _275, _279 };
    double _281 = _280.b;
    double _282;
    // Computing bound for u
    int64_t _283;
    // Computing bound for u
    if (d > 0) 
    goto _jump196;
    fail_assertion("non-positive loop bound");
    _jump196:;
    _283 = 0;
    int64_t _284 = 0; // u
    _jump197:; // Begin body of loop
    int64_t _285 = -b.d1;
    _283 += _285;
    _284++;
    if (_284 < d)
    goto _jump197;
    // End body of loop
    if (_283 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing bound for v
    if (f.d0 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    _282 = 0;
    int64_t _286 = 0; // v
    int64_t _287 = 0; // u
    _jump200:; // Begin body of loop
    _a3_bool _288;
    // Computing bound for w
    _288.d0 = f.d1;
    if (f.d1 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing bound for x
    _288.d1 = c;
    if (c > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    // Computing bound for y
    _288.d2 = b.d0;
    if (b.d0 > 0) 
    goto _jump203;
    fail_assertion("non-positive loop bound");
    _jump203:;
    // Computing total size of heap memory to allocate
    int64_t _289 = 1;
    _289 *= f.d1;
    _289 *= c;
    _289 *= b.d0;
    _289 *= sizeof(bool);
    _288.data = jpl_alloc(_289);
    int64_t _290 = 0; // y
    int64_t _291 = 0; // x
    int64_t _292 = 0; // w
    _jump204:; // Begin body of loop
    int64_t _293 = 0;
    _293 *= _288.d0;
    _293 += _292;
    _293 *= _288.d1;
    _293 += _291;
    _293 *= _288.d2;
    _293 += _290;
    _288.data[_293] = _80;
    _290++;
    if (_290 < b.d0)
    goto _jump204;
    _290 = 0;
    _291++;
    if (_291 < c)
    goto _jump204;
    _291 = 0;
    _292++;
    if (_292 < f.d1)
    goto _jump204;
    // End body of loop
    _a3_bool _294;
    // Computing bound for w
    _294.d0 = f.d1;
    if (f.d1 > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing bound for x
    _294.d1 = _286;
    if (_286 > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    // Computing bound for y
    _294.d2 = f.d1;
    if (f.d1 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing total size of heap memory to allocate
    int64_t _295 = 1;
    _295 *= f.d1;
    _295 *= _286;
    _295 *= f.d1;
    _295 *= sizeof(bool);
    _294.data = jpl_alloc(_295);
    int64_t _296 = 0; // y
    int64_t _297 = 0; // x
    int64_t _298 = 0; // w
    _jump208:; // Begin body of loop
    int64_t _299 = 0;
    _299 *= _294.d0;
    _299 += _298;
    _299 *= _294.d1;
    _299 += _297;
    _299 *= _294.d2;
    _299 += _296;
    _294.data[_299] = _80;
    _296++;
    if (_296 < f.d1)
    goto _jump208;
    _296 = 0;
    _297++;
    if (_297 < _286)
    goto _jump208;
    _297 = 0;
    _298++;
    if (_298 < f.d1)
    goto _jump208;
    // End body of loop
    _a1__a3_bool _300;
    _300.d0 = 2;
    _300.data = jpl_alloc(sizeof(_a3_bool) * 2);
    _300.data[0] = _288;
    _300.data[1] = _294;
    if (f.d0 >= 0)
    goto _jump209;
    fail_assertion("negative array index");
    _jump209:;
    if (f.d0 < _300.d0)
    goto _jump210;
    fail_assertion("index too large");
    _jump210:;
    int64_t _301 = 0;
    _301 *= _300.d0;
    _301 += f.d0;
    _a3_bool _302 = _300.data[_301];
    if (b.d0 >= 0)
    goto _jump211;
    fail_assertion("negative array index");
    _jump211:;
    if (b.d0 < _302.d0)
    goto _jump212;
    fail_assertion("index too large");
    _jump212:;
    if (i.d1 >= 0)
    goto _jump213;
    fail_assertion("negative array index");
    _jump213:;
    if (i.d1 < _302.d1)
    goto _jump214;
    fail_assertion("index too large");
    _jump214:;
    if (f.d0 >= 0)
    goto _jump215;
    fail_assertion("negative array index");
    _jump215:;
    if (f.d0 < _302.d2)
    goto _jump216;
    fail_assertion("index too large");
    _jump216:;
    int64_t _303 = 0;
    _303 *= _302.d0;
    _303 += b.d0;
    _303 *= _302.d1;
    _303 += i.d1;
    _303 *= _302.d2;
    _303 += f.d0;
    bool _304 = _302.data[_303];
    double _305;
    if (!_304)
    goto _jump217;
    double _306 = 72.0;
    _305 = _306;
    goto _jump218;
    _jump217:;
    double _307;
    // Computing bound for w
    if (f.d0 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing bound for x
    if (_287 > 0) 
    goto _jump220;
    fail_assertion("non-positive loop bound");
    _jump220:;
    // Computing bound for y
    if (d > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    _307 = 0;
    int64_t _308 = 0; // y
    int64_t _309 = 0; // x
    int64_t _310 = 0; // w
    _jump222:; // Begin body of loop
    double _311;
    // Computing bound for z
    if (f.d1 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    _311 = 0;
    int64_t _312 = 0; // z
    _jump224:; // Begin body of loop
    double _313 = 62.0;
    _311 += _313;
    _312++;
    if (_312 < f.d1)
    goto _jump224;
    // End body of loop
    _307 += _311;
    _308++;
    if (_308 < d)
    goto _jump222;
    _308 = 0;
    _309++;
    if (_309 < _287)
    goto _jump222;
    _309 = 0;
    _310++;
    if (_310 < f.d0)
    goto _jump222;
    // End body of loop
    double _314 = -_307;
    _305 = _314;
    _jump218:;
    _282 += _305;
    _286++;
    if (_286 < f.d0)
    goto _jump200;
    _286 = 0;
    _287++;
    if (_287 < _283)
    goto _jump200;
    // End body of loop
    bool _315;
    if (!_80)
    goto _jump225;
    _a2_bool _316;
    // Computing bound for u
    int64_t _317;
    // Computing bound for u
    if (b.d1 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for v
    if (f.d1 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    _317 = 0;
    int64_t _318 = 0; // v
    int64_t _319 = 0; // u
    _jump228:; // Begin body of loop
    _317 += b.d0;
    _318++;
    if (_318 < f.d1)
    goto _jump228;
    _318 = 0;
    _319++;
    if (_319 < b.d1)
    goto _jump228;
    // End body of loop
    _316.d0 = _317;
    if (_317 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for v
    _316.d1 = f.d0;
    if (f.d0 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing total size of heap memory to allocate
    int64_t _320 = 1;
    _320 *= _317;
    _320 *= f.d0;
    _320 *= sizeof(bool);
    _316.data = jpl_alloc(_320);
    int64_t _321 = 0; // v
    int64_t _322 = 0; // u
    _jump231:; // Begin body of loop
    bool _324 = false;
    bool _323 = _324;
    if (0 != _324)
    goto _jump232;
    _323 = _80;
    _jump232:;
    int64_t _325 = 0;
    _325 *= _316.d0;
    _325 += _322;
    _325 *= _316.d1;
    _325 += _321;
    _316.data[_325] = _323;
    _321++;
    if (_321 < f.d0)
    goto _jump231;
    _321 = 0;
    _322++;
    if (_322 < _317)
    goto _jump231;
    // End body of loop
    int64_t _326 = f.d1 - c;
    if (b.d1 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (b.d1 < _316.d0)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    if (_326 >= 0)
    goto _jump235;
    fail_assertion("negative array index");
    _jump235:;
    if (_326 < _316.d1)
    goto _jump236;
    fail_assertion("index too large");
    _jump236:;
    int64_t _327 = 0;
    _327 *= _316.d0;
    _327 += b.d1;
    _327 *= _316.d1;
    _327 += _326;
    bool _328 = _316.data[_327];
    _315 = _328;
    goto _jump237;
    _jump225:;
    double _329 = 17.0;
    double _330 = 83.0;
    double _331 = -_330;
    double _332 = -_331;
    bool _333 = _329 <= _332;
    _315 = _333;
    _jump237:;
    double _334;
    // Computing bound for u
    if (d > 0) 
    goto _jump238;
    fail_assertion("non-positive loop bound");
    _jump238:;
    // Computing bound for v
    if (f.d1 > 0) 
    goto _jump239;
    fail_assertion("non-positive loop bound");
    _jump239:;
    _334 = 0;
    int64_t _335 = 0; // v
    int64_t _336 = 0; // u
    _jump240:; // Begin body of loop
    _a1_double _337;
    // Computing bound for w
    _337.d0 = f.d1;
    if (f.d1 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing total size of heap memory to allocate
    int64_t _338 = 1;
    _338 *= f.d1;
    _338 *= sizeof(double);
    _337.data = jpl_alloc(_338);
    int64_t _339 = 0; // w
    _jump242:; // Begin body of loop
    double _340 = 21.0;
    int64_t _341 = 0;
    _341 *= _337.d0;
    _341 += _339;
    _337.data[_341] = _340;
    _339++;
    if (_339 < f.d1)
    goto _jump242;
    // End body of loop
    if (d >= 0)
    goto _jump243;
    fail_assertion("negative array index");
    _jump243:;
    if (d < _337.d0)
    goto _jump244;
    fail_assertion("index too large");
    _jump244:;
    int64_t _342 = 0;
    _342 *= _337.d0;
    _342 += d;
    double _343 = _337.data[_342];
    _334 += _343;
    _335++;
    if (_335 < f.d1)
    goto _jump240;
    _335 = 0;
    _336++;
    if (_336 < d)
    goto _jump240;
    // End body of loop
    double _344 = 39.0;
    double _345 = -_344;
    double _346 = 36.0;
    double _347 = _345 + _346;
    _a2_double _348;
    // Computing bound for u
    _348.d0 = d;
    if (d > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing bound for v
    _348.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing total size of heap memory to allocate
    int64_t _349 = 1;
    _349 *= d;
    _349 *= i.d0;
    _349 *= sizeof(double);
    _348.data = jpl_alloc(_349);
    int64_t _350 = 0; // v
    int64_t _351 = 0; // u
    _jump247:; // Begin body of loop
    double _352 = 81.0;
    int64_t _353 = 0;
    _353 *= _348.d0;
    _353 += _351;
    _353 *= _348.d1;
    _353 += _350;
    _348.data[_353] = _352;
    _350++;
    if (_350 < i.d0)
    goto _jump247;
    _350 = 0;
    _351++;
    if (_351 < d)
    goto _jump247;
    // End body of loop
    int64_t _354 = c + b.d1;
    if (_354 >= 0)
    goto _jump248;
    fail_assertion("negative array index");
    _jump248:;
    if (_354 < _348.d0)
    goto _jump249;
    fail_assertion("index too large");
    _jump249:;
    if (d >= 0)
    goto _jump250;
    fail_assertion("negative array index");
    _jump250:;
    if (d < _348.d1)
    goto _jump251;
    fail_assertion("index too large");
    _jump251:;
    int64_t _355 = 0;
    _355 *= _348.d0;
    _355 += _354;
    _355 *= _348.d1;
    _355 += d;
    double _356 = _348.data[_355];
    bool _357 = _347 >= _356;
    a _358 = { _315, _334, _357 };
    double _359 = _358.b;
    rgba _360 = { _246, _281, _282, _359 };
    return _360;
}

int64_t p(_a2_bool q, _a3_bool r) {
    int64_t _0 = -r.d1;
    return _0;
    int64_t _1 = -l.d1;
    _a2__a3__a2_bool _2;
    // Computing bound for E
    int64_t _3;
    // Computing bound for E
    if (k > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    _3 = 0;
    int64_t _4 = 0; // E
    _jump512:; // Begin body of loop
    _3 += r.d0;
    _4++;
    if (_4 < k)
    goto _jump512;
    // End body of loop
    _2.d0 = _3;
    if (_3 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    // Computing bound for F
    _2.d1 = c;
    if (c > 0) 
    goto _jump514;
    fail_assertion("non-positive loop bound");
    _jump514:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _3;
    _5 *= c;
    _5 *= sizeof(_a3__a2_bool);
    _2.data = jpl_alloc(_5);
    int64_t _6 = 0; // F
    int64_t _7 = 0; // E
    _jump515:; // Begin body of loop
    _a3__a2_bool _8;
    // Computing bound for G
    _8.d0 = h;
    if (h > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for H
    _8.d1 = b.d0;
    if (b.d0 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for I
    _8.d2 = r.d2;
    if (r.d2 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    // Computing total size of heap memory to allocate
    int64_t _9 = 1;
    _9 *= h;
    _9 *= b.d0;
    _9 *= r.d2;
    _9 *= sizeof(_a2_bool);
    _8.data = jpl_alloc(_9);
    int64_t _10 = 0; // I
    int64_t _11 = 0; // H
    int64_t _12 = 0; // G
    _jump519:; // Begin body of loop
    int64_t _13 = 0;
    _13 *= _8.d0;
    _13 += _12;
    _13 *= _8.d1;
    _13 += _11;
    _13 *= _8.d2;
    _13 += _10;
    _8.data[_13] = q;
    _10++;
    if (_10 < r.d2)
    goto _jump519;
    _10 = 0;
    _11++;
    if (_11 < b.d0)
    goto _jump519;
    _11 = 0;
    _12++;
    if (_12 < h)
    goto _jump519;
    // End body of loop
    int64_t _14 = 0;
    _14 *= _2.d0;
    _14 += _7;
    _14 *= _2.d1;
    _14 += _6;
    _2.data[_14] = _8;
    _6++;
    if (_6 < c)
    goto _jump515;
    _6 = 0;
    _7++;
    if (_7 < _3)
    goto _jump515;
    // End body of loop
    _a1__a2__a3__a2_bool _15;
    _15.d0 = 1;
    _15.data = jpl_alloc(sizeof(_a2__a3__a2_bool) * 1);
    _15.data[0] = _2;
    if (r.d2 >= 0)
    goto _jump520;
    fail_assertion("negative array index");
    _jump520:;
    if (r.d2 < _15.d0)
    goto _jump521;
    fail_assertion("index too large");
    _jump521:;
    int64_t _16 = 0;
    _16 *= _15.d0;
    _16 += r.d2;
    _a2__a3__a2_bool _17 = _15.data[_16];
    _a3_int64_t _18;
    // Computing bound for E
    int64_t _19 = -h;
    _18.d0 = _19;
    if (_19 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for F
    int64_t _20 = d * d;
    _18.d1 = _20;
    if (_20 > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing bound for G
    _18.d2 = c;
    if (c > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= _19;
    _21 *= _20;
    _21 *= c;
    _21 *= sizeof(int64_t);
    _18.data = jpl_alloc(_21);
    int64_t _22 = 0; // G
    int64_t _23 = 0; // F
    int64_t _24 = 0; // E
    _jump525:; // Begin body of loop
    int64_t _25 = 0;
    _25 *= _18.d0;
    _25 += _24;
    _25 *= _18.d1;
    _25 += _23;
    _25 *= _18.d2;
    _25 += _22;
    _18.data[_25] = d;
    _22++;
    if (_22 < c)
    goto _jump525;
    _22 = 0;
    _23++;
    if (_23 < _20)
    goto _jump525;
    _23 = 0;
    _24++;
    if (_24 < _19)
    goto _jump525;
    // End body of loop
    if (d >= 0)
    goto _jump526;
    fail_assertion("negative array index");
    _jump526:;
    if (d < _18.d0)
    goto _jump527;
    fail_assertion("index too large");
    _jump527:;
    if (l.d0 >= 0)
    goto _jump528;
    fail_assertion("negative array index");
    _jump528:;
    if (l.d0 < _18.d1)
    goto _jump529;
    fail_assertion("index too large");
    _jump529:;
    if (d >= 0)
    goto _jump530;
    fail_assertion("negative array index");
    _jump530:;
    if (d < _18.d2)
    goto _jump531;
    fail_assertion("index too large");
    _jump531:;
    int64_t _26 = 0;
    _26 *= _18.d0;
    _26 += d;
    _26 *= _18.d1;
    _26 += l.d0;
    _26 *= _18.d2;
    _26 += d;
    int64_t _27 = _18.data[_26];
    int64_t _28 = _27 * d;
    if (l.d1 >= 0)
    goto _jump532;
    fail_assertion("negative array index");
    _jump532:;
    if (l.d1 < _17.d0)
    goto _jump533;
    fail_assertion("index too large");
    _jump533:;
    if (_28 >= 0)
    goto _jump534;
    fail_assertion("negative array index");
    _jump534:;
    if (_28 < _17.d1)
    goto _jump535;
    fail_assertion("index too large");
    _jump535:;
    int64_t _29 = 0;
    _29 *= _17.d0;
    _29 += l.d1;
    _29 *= _17.d1;
    _29 += _28;
    _a3__a2_bool _30 = _17.data[_29];
    int64_t _31 = 1000;
    bool _32 = _31 == b.d0;
    _a3_int64_t _33;
    if (!_32)
    goto _jump536;
    _a3_int64_t _34;
    // Computing bound for E
    _34.d0 = n;
    if (n > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for F
    _34.d1 = b.d1;
    if (b.d1 > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing bound for G
    _34.d2 = _1;
    if (_1 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    // Computing total size of heap memory to allocate
    int64_t _35 = 1;
    _35 *= n;
    _35 *= b.d1;
    _35 *= _1;
    _35 *= sizeof(int64_t);
    _34.data = jpl_alloc(_35);
    int64_t _36 = 0; // G
    int64_t _37 = 0; // F
    int64_t _38 = 0; // E
    _jump540:; // Begin body of loop
    bool _39 = k > k;
    int64_t _40;
    if (!_39)
    goto _jump541;
    _40 = _37;
    goto _jump542;
    _jump541:;
    _40 = c;
    _jump542:;
    int64_t _41 = 0;
    _41 *= _34.d0;
    _41 += _38;
    _41 *= _34.d1;
    _41 += _37;
    _41 *= _34.d2;
    _41 += _36;
    _34.data[_41] = _40;
    _36++;
    if (_36 < _1)
    goto _jump540;
    _36 = 0;
    _37++;
    if (_37 < b.d1)
    goto _jump540;
    _37 = 0;
    _38++;
    if (_38 < n)
    goto _jump540;
    // End body of loop
    _33 = _34;
    goto _jump543;
    _jump536:;
    bool _42 = true;
    bool _43;
    if (!_42)
    goto _jump544;
    bool _44 = true;
    _43 = _44;
    goto _jump545;
    _jump544:;
    bool _45 = false;
    _43 = _45;
    _jump545:;
    _a3_int64_t _46;
    if (!_43)
    goto _jump546;
    bool _47 = m != r.d0;
    _a3_int64_t _48;
    if (!_47)
    goto _jump547;
    _a3_int64_t _49;
    // Computing bound for E
    _49.d0 = m;
    if (m > 0) 
    goto _jump548;
    fail_assertion("non-positive loop bound");
    _jump548:;
    // Computing bound for F
    _49.d1 = r.d1;
    if (r.d1 > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    // Computing bound for G
    _49.d2 = n;
    if (n > 0) 
    goto _jump550;
    fail_assertion("non-positive loop bound");
    _jump550:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= m;
    _50 *= r.d1;
    _50 *= n;
    _50 *= sizeof(int64_t);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // G
    int64_t _52 = 0; // F
    int64_t _53 = 0; // E
    _jump551:; // Begin body of loop
    int64_t _54 = 0;
    _54 *= _49.d0;
    _54 += _53;
    _54 *= _49.d1;
    _54 += _52;
    _54 *= _49.d2;
    _54 += _51;
    _49.data[_54] = _52;
    _51++;
    if (_51 < n)
    goto _jump551;
    _51 = 0;
    _52++;
    if (_52 < r.d1)
    goto _jump551;
    _52 = 0;
    _53++;
    if (_53 < m)
    goto _jump551;
    // End body of loop
    _48 = _49;
    goto _jump552;
    _jump547:;
    _a3_int64_t _55;
    // Computing bound for E
    _55.d0 = l.d1;
    if (l.d1 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for F
    _55.d1 = b.d1;
    if (b.d1 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for G
    _55.d2 = r.d2;
    if (r.d2 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= l.d1;
    _56 *= b.d1;
    _56 *= r.d2;
    _56 *= sizeof(int64_t);
    _55.data = jpl_alloc(_56);
    int64_t _57 = 0; // G
    int64_t _58 = 0; // F
    int64_t _59 = 0; // E
    _jump556:; // Begin body of loop
    int64_t _60 = 0;
    _60 *= _55.d0;
    _60 += _59;
    _60 *= _55.d1;
    _60 += _58;
    _60 *= _55.d2;
    _60 += _57;
    _55.data[_60] = h;
    _57++;
    if (_57 < r.d2)
    goto _jump556;
    _57 = 0;
    _58++;
    if (_58 < b.d1)
    goto _jump556;
    _58 = 0;
    _59++;
    if (_59 < l.d1)
    goto _jump556;
    // End body of loop
    _48 = _55;
    _jump552:;
    _46 = _48;
    goto _jump557;
    _jump546:;
    _a3_int64_t _61;
    // Computing bound for E
    _61.d0 = n;
    if (n > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    // Computing bound for F
    bool _62 = true;
    int64_t _63;
    if (!_62)
    goto _jump559;
    _63 = b.d1;
    goto _jump560;
    _jump559:;
    _63 = h;
    _jump560:;
    _61.d1 = _63;
    if (_63 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for G
    bool _64 = false;
    int64_t _65;
    if (!_64)
    goto _jump562;
    _65 = b.d1;
    goto _jump563;
    _jump562:;
    _65 = r.d0;
    _jump563:;
    _61.d2 = _65;
    if (_65 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= n;
    _66 *= _63;
    _66 *= _65;
    _66 *= sizeof(int64_t);
    _61.data = jpl_alloc(_66);
    int64_t _67 = 0; // G
    int64_t _68 = 0; // F
    int64_t _69 = 0; // E
    _jump565:; // Begin body of loop
    int64_t _70 = 232;
    int64_t _71 = 0;
    _71 *= _61.d0;
    _71 += _69;
    _71 *= _61.d1;
    _71 += _68;
    _71 *= _61.d2;
    _71 += _67;
    _61.data[_71] = _70;
    _67++;
    if (_67 < _65)
    goto _jump565;
    _67 = 0;
    _68++;
    if (_68 < _63)
    goto _jump565;
    _68 = 0;
    _69++;
    if (_69 < n)
    goto _jump565;
    // End body of loop
    _46 = _61;
    _jump557:;
    _33 = _46;
    _jump543:;
    int64_t _72 = -_1;
    if (_72 >= 0)
    goto _jump566;
    fail_assertion("negative array index");
    _jump566:;
    if (_72 < _33.d0)
    goto _jump567;
    fail_assertion("index too large");
    _jump567:;
    if (c >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (c < _33.d1)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    if (r.d0 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (r.d0 < _33.d2)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    int64_t _73 = 0;
    _73 *= _33.d0;
    _73 += _72;
    _73 *= _33.d1;
    _73 += c;
    _73 *= _33.d2;
    _73 += r.d0;
    int64_t _74 = _33.data[_73];
    if (b.d1 >= 0)
    goto _jump572;
    fail_assertion("negative array index");
    _jump572:;
    if (b.d1 < _30.d0)
    goto _jump573;
    fail_assertion("index too large");
    _jump573:;
    if (r.d2 >= 0)
    goto _jump574;
    fail_assertion("negative array index");
    _jump574:;
    if (r.d2 < _30.d1)
    goto _jump575;
    fail_assertion("index too large");
    _jump575:;
    if (_74 >= 0)
    goto _jump576;
    fail_assertion("negative array index");
    _jump576:;
    if (_74 < _30.d2)
    goto _jump577;
    fail_assertion("index too large");
    _jump577:;
    int64_t _75 = 0;
    _75 *= _30.d0;
    _75 += b.d1;
    _75 *= _30.d1;
    _75 += r.d2;
    _75 *= _30.d2;
    _75 += _74;
    _a2_bool _76 = _30.data[_75];
    bool _77 = r.d1 >= r.d0;
    double _78;
    if (!_77)
    goto _jump578;
    _78 = i;
    goto _jump579;
    _jump578:;
    double _79 = 49.0;
    _78 = _79;
    _jump579:;
    double _80 = _78 - i;
    double _81 = 65.0;
    double _82 = 89.0;
    double _83 = 86.0;
    rgba _84 = { _81, _82, _83, i };
    double _85 = _84.r;
    double _86 = 24.0;
    double _87 = _86 - i;
    double _88 = -_87;
    double _89 = fmod(_85, _88);
    bool _90 = _80 < _89;
    _a3_bool _91;
    // Computing bound for E
    _91.d0 = r.d0;
    if (r.d0 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    // Computing bound for F
    int64_t _92 = r.d0 / c;
    _91.d1 = _92;
    if (_92 > 0) 
    goto _jump581;
    fail_assertion("non-positive loop bound");
    _jump581:;
    // Computing bound for G
    _91.d2 = m;
    if (m > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= r.d0;
    _93 *= _92;
    _93 *= m;
    _93 *= sizeof(bool);
    _91.data = jpl_alloc(_93);
    int64_t _94 = 0; // G
    int64_t _95 = 0; // F
    int64_t _96 = 0; // E
    _jump583:; // Begin body of loop
    bool _97 = r.d0 < r.d0;
    int64_t _98 = 0;
    _98 *= _91.d0;
    _98 += _96;
    _98 *= _91.d1;
    _98 += _95;
    _98 *= _91.d2;
    _98 += _94;
    _91.data[_98] = _97;
    _94++;
    if (_94 < m)
    goto _jump583;
    _94 = 0;
    _95++;
    if (_95 < _92)
    goto _jump583;
    _95 = 0;
    _96++;
    if (_96 < r.d0)
    goto _jump583;
    // End body of loop
    if (l.d0 >= 0)
    goto _jump584;
    fail_assertion("negative array index");
    _jump584:;
    if (l.d0 < _91.d0)
    goto _jump585;
    fail_assertion("index too large");
    _jump585:;
    if (l.d0 >= 0)
    goto _jump586;
    fail_assertion("negative array index");
    _jump586:;
    if (l.d0 < _91.d1)
    goto _jump587;
    fail_assertion("index too large");
    _jump587:;
    if (r.d2 >= 0)
    goto _jump588;
    fail_assertion("negative array index");
    _jump588:;
    if (r.d2 < _91.d2)
    goto _jump589;
    fail_assertion("index too large");
    _jump589:;
    int64_t _99 = 0;
    _99 *= _91.d0;
    _99 += l.d0;
    _99 *= _91.d1;
    _99 += l.d0;
    _99 *= _91.d2;
    _99 += r.d2;
    bool _100 = _91.data[_99];
    bool _101 = _90 != _100;
    _a3_bool _102;
    if (!_101)
    goto _jump590;
    _a3_bool _103;
    // Computing bound for E
    double _104 = 79.0;
    double _105;
    // Computing bound for E
    if (b.d1 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for F
    if (k > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    _105 = 0;
    int64_t _106 = 0; // F
    int64_t _107 = 0; // E
    _jump593:; // Begin body of loop
    _105 += f;
    _106++;
    if (_106 < k)
    goto _jump593;
    _106 = 0;
    _107++;
    if (_107 < b.d1)
    goto _jump593;
    // End body of loop
    bool _108 = _104 != _105;
    int64_t _109;
    if (!_108)
    goto _jump594;
    _109 = h;
    goto _jump595;
    _jump594:;
    _109 = b.d0;
    _jump595:;
    _103.d0 = _109;
    if (_109 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    // Computing bound for F
    int64_t _110 = -c;
    _103.d1 = _110;
    if (_110 > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    // Computing bound for G
    _103.d2 = r.d2;
    if (r.d2 > 0) 
    goto _jump598;
    fail_assertion("non-positive loop bound");
    _jump598:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= _109;
    _111 *= _110;
    _111 *= r.d2;
    _111 *= sizeof(bool);
    _103.data = jpl_alloc(_111);
    int64_t _112 = 0; // G
    int64_t _113 = 0; // F
    int64_t _114 = 0; // E
    _jump599:; // Begin body of loop
    _a3_bool _115;
    // Computing bound for H
    _115.d0 = _114;
    if (_114 > 0) 
    goto _jump600;
    fail_assertion("non-positive loop bound");
    _jump600:;
    // Computing bound for I
    int64_t _116 = -d;
    _115.d1 = _116;
    if (_116 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    // Computing bound for J
    int64_t _117 = 137;
    int64_t _118 = _114 - _117;
    _115.d2 = _118;
    if (_118 > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= _114;
    _119 *= _116;
    _119 *= _118;
    _119 *= sizeof(bool);
    _115.data = jpl_alloc(_119);
    int64_t _120 = 0; // J
    int64_t _121 = 0; // I
    int64_t _122 = 0; // H
    _jump603:; // Begin body of loop
    int64_t _123 = 283;
    int64_t _124 = -_123;
    bool _125 = _124 < d;
    int64_t _126 = 0;
    _126 *= _115.d0;
    _126 += _122;
    _126 *= _115.d1;
    _126 += _121;
    _126 *= _115.d2;
    _126 += _120;
    _115.data[_126] = _125;
    _120++;
    if (_120 < _118)
    goto _jump603;
    _120 = 0;
    _121++;
    if (_121 < _116)
    goto _jump603;
    _121 = 0;
    _122++;
    if (_122 < _114)
    goto _jump603;
    // End body of loop
    if (d >= 0)
    goto _jump604;
    fail_assertion("negative array index");
    _jump604:;
    if (d < _115.d0)
    goto _jump605;
    fail_assertion("index too large");
    _jump605:;
    if (b.d0 >= 0)
    goto _jump606;
    fail_assertion("negative array index");
    _jump606:;
    if (b.d0 < _115.d1)
    goto _jump607;
    fail_assertion("index too large");
    _jump607:;
    if (h >= 0)
    goto _jump608;
    fail_assertion("negative array index");
    _jump608:;
    if (h < _115.d2)
    goto _jump609;
    fail_assertion("index too large");
    _jump609:;
    int64_t _127 = 0;
    _127 *= _115.d0;
    _127 += d;
    _127 *= _115.d1;
    _127 += b.d0;
    _127 *= _115.d2;
    _127 += h;
    bool _128 = _115.data[_127];
    int64_t _129 = 0;
    _129 *= _103.d0;
    _129 += _114;
    _129 *= _103.d1;
    _129 += _113;
    _129 *= _103.d2;
    _129 += _112;
    _103.data[_129] = _128;
    _112++;
    if (_112 < r.d2)
    goto _jump599;
    _112 = 0;
    _113++;
    if (_113 < _110)
    goto _jump599;
    _113 = 0;
    _114++;
    if (_114 < _109)
    goto _jump599;
    // End body of loop
    _102 = _103;
    goto _jump610;
    _jump590:;
    _a2__a3_bool _130;
    // Computing bound for E
    _130.d0 = d;
    if (d > 0) 
    goto _jump611;
    fail_assertion("non-positive loop bound");
    _jump611:;
    // Computing bound for F
    _130.d1 = r.d2;
    if (r.d2 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= d;
    _131 *= r.d2;
    _131 *= sizeof(_a3_bool);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // F
    int64_t _133 = 0; // E
    _jump613:; // Begin body of loop
    _a3_bool _134;
    // Computing bound for G
    _134.d0 = _1;
    if (_1 > 0) 
    goto _jump614;
    fail_assertion("non-positive loop bound");
    _jump614:;
    // Computing bound for H
    _134.d1 = l.d0;
    if (l.d0 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing bound for I
    _134.d2 = m;
    if (m > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= _1;
    _135 *= l.d0;
    _135 *= m;
    _135 *= sizeof(bool);
    _134.data = jpl_alloc(_135);
    int64_t _136 = 0; // I
    int64_t _137 = 0; // H
    int64_t _138 = 0; // G
    _jump617:; // Begin body of loop
    bool _139 = n == _136;
    bool _140;
    if (!_139)
    goto _jump618;
    bool _141 = _132 == h;
    _140 = _141;
    goto _jump619;
    _jump618:;
    bool _142 = true;
    _140 = _142;
    _jump619:;
    int64_t _143 = 0;
    _143 *= _134.d0;
    _143 += _138;
    _143 *= _134.d1;
    _143 += _137;
    _143 *= _134.d2;
    _143 += _136;
    _134.data[_143] = _140;
    _136++;
    if (_136 < m)
    goto _jump617;
    _136 = 0;
    _137++;
    if (_137 < l.d0)
    goto _jump617;
    _137 = 0;
    _138++;
    if (_138 < _1)
    goto _jump617;
    // End body of loop
    int64_t _144 = 0;
    _144 *= _130.d0;
    _144 += _133;
    _144 *= _130.d1;
    _144 += _132;
    _130.data[_144] = _134;
    _132++;
    if (_132 < r.d2)
    goto _jump613;
    _132 = 0;
    _133++;
    if (_133 < d)
    goto _jump613;
    // End body of loop
    if (b.d0 >= 0)
    goto _jump620;
    fail_assertion("negative array index");
    _jump620:;
    if (b.d0 < _130.d0)
    goto _jump621;
    fail_assertion("index too large");
    _jump621:;
    if (r.d1 >= 0)
    goto _jump622;
    fail_assertion("negative array index");
    _jump622:;
    if (r.d1 < _130.d1)
    goto _jump623;
    fail_assertion("index too large");
    _jump623:;
    int64_t _145 = 0;
    _145 *= _130.d0;
    _145 += b.d0;
    _145 *= _130.d1;
    _145 += r.d1;
    _a3_bool _146 = _130.data[_145];
    _102 = _146;
    _jump610:;
    int64_t _147 = p(_76, _102);
    return _147;
}

bool t(_a3__a2_double u, _a2_bool y) {
    _a3__a2_double _0;
    // Computing bound for D
    _0.d0 = y.d1;
    if (y.d1 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    // Computing bound for E
    _0.d1 = y.d1;
    if (y.d1 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for F
    _0.d2 = c;
    if (c > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= y.d1;
    _1 *= y.d1;
    _1 *= c;
    _1 *= sizeof(_a2_double);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // F
    int64_t _3 = 0; // E
    int64_t _4 = 0; // D
    _jump627:; // Begin body of loop
    _a2_double _5;
    // Computing bound for G
    _5.d0 = _2;
    if (_2 > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    // Computing bound for H
    _5.d1 = m;
    if (m > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _2;
    _6 *= m;
    _6 *= sizeof(double);
    _5.data = jpl_alloc(_6);
    int64_t _7 = 0; // H
    int64_t _8 = 0; // G
    _jump630:; // Begin body of loop
    int64_t _9 = 0;
    _9 *= _5.d0;
    _9 += _8;
    _9 *= _5.d1;
    _9 += _7;
    _5.data[_9] = i;
    _7++;
    if (_7 < m)
    goto _jump630;
    _7 = 0;
    _8++;
    if (_8 < _2)
    goto _jump630;
    // End body of loop
    int64_t _10 = 0;
    _10 *= _0.d0;
    _10 += _4;
    _10 *= _0.d1;
    _10 += _3;
    _10 *= _0.d2;
    _10 += _2;
    _0.data[_10] = _5;
    _2++;
    if (_2 < c)
    goto _jump627;
    _2 = 0;
    _3++;
    if (_3 < y.d1)
    goto _jump627;
    _3 = 0;
    _4++;
    if (_4 < y.d1)
    goto _jump627;
    // End body of loop
    _a2_bool _11;
    // Computing bound for D
    _11.d0 = y.d0;
    if (y.d0 > 0) 
    goto _jump631;
    fail_assertion("non-positive loop bound");
    _jump631:;
    // Computing bound for E
    _11.d1 = y.d0;
    if (y.d0 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= y.d0;
    _12 *= y.d0;
    _12 *= sizeof(bool);
    _11.data = jpl_alloc(_12);
    int64_t _13 = 0; // E
    int64_t _14 = 0; // D
    _jump633:; // Begin body of loop
    bool _15 = true;
    bool _16 = false;
    bool _17 = _15 == _16;
    int64_t _18 = 0;
    _18 *= _11.d0;
    _18 += _14;
    _18 *= _11.d1;
    _18 += _13;
    _11.data[_18] = _17;
    _13++;
    if (_13 < y.d0)
    goto _jump633;
    _13 = 0;
    _14++;
    if (_14 < y.d0)
    goto _jump633;
    // End body of loop
    bool _19 = t(_0, _11);
    double _20 = 16.0;
    bool _21 = t(u, y);
    a _22 = { _19, _20, _21 };
    bool _23 = false;
    bool _24 = !_23;
    if (0 != _24)
    goto _jump634;
    fail_assertion("E");
    _jump634:;
    bool _25 = t(u, y);
    int64_t _26;
    if (!_25)
    goto _jump635;
    _26 = h;
    goto _jump636;
    _jump635:;
    int64_t _27 = -u.d2;
    _26 = _27;
    _jump636:;
    bool _28 = k >= _26;
    bool _29 = false;
    double _30;
    if (!_29)
    goto _jump637;
    double _31 = 34.0;
    _30 = _31;
    goto _jump638;
    _jump637:;
    _a3_double _32;
    // Computing bound for E
    _32.d0 = k;
    if (k > 0) 
    goto _jump639;
    fail_assertion("non-positive loop bound");
    _jump639:;
    // Computing bound for F
    _32.d1 = m;
    if (m > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for G
    _32.d2 = u.d2;
    if (u.d2 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= k;
    _33 *= m;
    _33 *= u.d2;
    _33 *= sizeof(double);
    _32.data = jpl_alloc(_33);
    int64_t _34 = 0; // G
    int64_t _35 = 0; // F
    int64_t _36 = 0; // E
    _jump642:; // Begin body of loop
    double _37;
    // Computing bound for H
    int64_t _38 = 845;
    if (_38 > 0) 
    goto _jump643;
    fail_assertion("non-positive loop bound");
    _jump643:;
    // Computing bound for I
    if (u.d1 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    // Computing bound for J
    if (k > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    _37 = 0;
    int64_t _39 = 0; // J
    int64_t _40 = 0; // I
    int64_t _41 = 0; // H
    _jump646:; // Begin body of loop
    _37 += f;
    _39++;
    if (_39 < k)
    goto _jump646;
    _39 = 0;
    _40++;
    if (_40 < u.d1)
    goto _jump646;
    _40 = 0;
    _41++;
    if (_41 < _38)
    goto _jump646;
    // End body of loop
    int64_t _42 = 0;
    _42 *= _32.d0;
    _42 += _36;
    _42 *= _32.d1;
    _42 += _35;
    _42 *= _32.d2;
    _42 += _34;
    _32.data[_42] = _37;
    _34++;
    if (_34 < u.d2)
    goto _jump642;
    _34 = 0;
    _35++;
    if (_35 < m)
    goto _jump642;
    _35 = 0;
    _36++;
    if (_36 < k)
    goto _jump642;
    // End body of loop
    int64_t _43 = -m;
    int64_t _44;
    // Computing bound for E
    if (y.d0 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    _44 = 0;
    int64_t _45 = 0; // E
    _jump648:; // Begin body of loop
    _44 += u.d2;
    _45++;
    if (_45 < y.d0)
    goto _jump648;
    // End body of loop
    if (_43 >= 0)
    goto _jump649;
    fail_assertion("negative array index");
    _jump649:;
    if (_43 < _32.d0)
    goto _jump650;
    fail_assertion("index too large");
    _jump650:;
    if (_44 >= 0)
    goto _jump651;
    fail_assertion("negative array index");
    _jump651:;
    if (_44 < _32.d1)
    goto _jump652;
    fail_assertion("index too large");
    _jump652:;
    if (y.d0 >= 0)
    goto _jump653;
    fail_assertion("negative array index");
    _jump653:;
    if (y.d0 < _32.d2)
    goto _jump654;
    fail_assertion("index too large");
    _jump654:;
    int64_t _46 = 0;
    _46 *= _32.d0;
    _46 += _43;
    _46 *= _32.d1;
    _46 += _44;
    _46 *= _32.d2;
    _46 += y.d0;
    double _47 = _32.data[_46];
    _30 = _47;
    _jump638:;
    bool _48 = k == u.d1;
    a _49 = { _28, _30, _48 };
    bool _50 = _49.a;
    bool _51 = !_50;
    return _51;
    _a3_bool _52;
    // Computing bound for I
    int64_t _53 = 618;
    _52.d0 = _53;
    if (_53 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for J
    _52.d1 = r;
    if (r > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing bound for K
    _52.d2 = h;
    if (h > 0) 
    goto _jump657;
    fail_assertion("non-positive loop bound");
    _jump657:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= _53;
    _54 *= r;
    _54 *= h;
    _54 *= sizeof(bool);
    _52.data = jpl_alloc(_54);
    int64_t _55 = 0; // K
    int64_t _56 = 0; // J
    int64_t _57 = 0; // I
    _jump658:; // Begin body of loop
    bool _58 = false;
    _a3__a2_double _59;
    if (!_58)
    goto _jump659;
    _59 = u;
    goto _jump660;
    _jump659:;
    _59 = u;
    _jump660:;
    _a3__a2_bool _60;
    // Computing bound for L
    _60.d0 = _57;
    if (_57 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing bound for M
    _60.d1 = _57;
    if (_57 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing bound for N
    _60.d2 = u.d0;
    if (u.d0 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= _57;
    _61 *= _57;
    _61 *= u.d0;
    _61 *= sizeof(_a2_bool);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // N
    int64_t _63 = 0; // M
    int64_t _64 = 0; // L
    _jump664:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _60.d0;
    _65 += _64;
    _65 *= _60.d1;
    _65 += _63;
    _65 *= _60.d2;
    _65 += _62;
    _60.data[_65] = y;
    _62++;
    if (_62 < u.d0)
    goto _jump664;
    _62 = 0;
    _63++;
    if (_63 < _57)
    goto _jump664;
    _63 = 0;
    _64++;
    if (_64 < _57)
    goto _jump664;
    // End body of loop
    if (n >= 0)
    goto _jump665;
    fail_assertion("negative array index");
    _jump665:;
    if (n < _60.d0)
    goto _jump666;
    fail_assertion("index too large");
    _jump666:;
    if (u.d2 >= 0)
    goto _jump667;
    fail_assertion("negative array index");
    _jump667:;
    if (u.d2 < _60.d1)
    goto _jump668;
    fail_assertion("index too large");
    _jump668:;
    if (r >= 0)
    goto _jump669;
    fail_assertion("negative array index");
    _jump669:;
    if (r < _60.d2)
    goto _jump670;
    fail_assertion("index too large");
    _jump670:;
    int64_t _66 = 0;
    _66 *= _60.d0;
    _66 += n;
    _66 *= _60.d1;
    _66 += u.d2;
    _66 *= _60.d2;
    _66 += r;
    _a2_bool _67 = _60.data[_66];
    bool _68 = t(_59, _67);
    _a2_double _69;
    // Computing bound for L
    _69.d0 = m;
    if (m > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    // Computing bound for M
    _69.d1 = u.d1;
    if (u.d1 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= m;
    _70 *= u.d1;
    _70 *= sizeof(double);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // M
    int64_t _72 = 0; // L
    _jump673:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _69.d0;
    _73 += _72;
    _73 *= _69.d1;
    _73 += _71;
    _69.data[_73] = i;
    _71++;
    if (_71 < u.d1)
    goto _jump673;
    _71 = 0;
    _72++;
    if (_72 < m)
    goto _jump673;
    // End body of loop
    if (c >= 0)
    goto _jump674;
    fail_assertion("negative array index");
    _jump674:;
    if (c < _69.d0)
    goto _jump675;
    fail_assertion("index too large");
    _jump675:;
    if (m >= 0)
    goto _jump676;
    fail_assertion("negative array index");
    _jump676:;
    if (m < _69.d1)
    goto _jump677;
    fail_assertion("index too large");
    _jump677:;
    int64_t _74 = 0;
    _74 *= _69.d0;
    _74 += c;
    _74 *= _69.d1;
    _74 += m;
    double _75 = _69.data[_74];
    double _76 = 52.0;
    bool _77 = _75 > _76;
    bool _78 = _68 != _77;
    bool _79 = u.d0 <= m;
    double _80 = 12.0;
    bool _81 = false;
    a _82 = { _79, _80, _81 };
    bool _83 = _82.a;
    bool _84 = _78 == _83;
    int64_t _85 = 0;
    _85 *= _52.d0;
    _85 += _57;
    _85 *= _52.d1;
    _85 += _56;
    _85 *= _52.d2;
    _85 += _55;
    _52.data[_85] = _84;
    _55++;
    if (_55 < h)
    goto _jump658;
    _55 = 0;
    _56++;
    if (_56 < r)
    goto _jump658;
    _56 = 0;
    _57++;
    if (_57 < _53)
    goto _jump658;
    // End body of loop
    _a2__a2_bool _86;
    // Computing bound for I
    _86.d0 = u.d2;
    if (u.d2 > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing bound for J
    _86.d1 = y.d1;
    if (y.d1 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= u.d2;
    _87 *= y.d1;
    _87 *= sizeof(_a2_bool);
    _86.data = jpl_alloc(_87);
    int64_t _88 = 0; // J
    int64_t _89 = 0; // I
    _jump680:; // Begin body of loop
    _a2_bool _90;
    // Computing bound for K
    _a3_int64_t _91;
    // Computing bound for K
    _91.d0 = n;
    if (n > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    // Computing bound for L
    _91.d1 = h;
    if (h > 0) 
    goto _jump682;
    fail_assertion("non-positive loop bound");
    _jump682:;
    // Computing bound for M
    _91.d2 = m;
    if (m > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= n;
    _92 *= h;
    _92 *= m;
    _92 *= sizeof(int64_t);
    _91.data = jpl_alloc(_92);
    int64_t _93 = 0; // M
    int64_t _94 = 0; // L
    int64_t _95 = 0; // K
    _jump684:; // Begin body of loop
    int64_t _96 = 0;
    _96 *= _91.d0;
    _96 += _95;
    _96 *= _91.d1;
    _96 += _94;
    _96 *= _91.d2;
    _96 += _93;
    _91.data[_96] = r;
    _93++;
    if (_93 < m)
    goto _jump684;
    _93 = 0;
    _94++;
    if (_94 < h)
    goto _jump684;
    _94 = 0;
    _95++;
    if (_95 < n)
    goto _jump684;
    // End body of loop
    int64_t _97;
    // Computing bound for K
    if (u.d2 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing bound for L
    if (y.d1 > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    _97 = 0;
    int64_t _98 = 0; // L
    int64_t _99 = 0; // K
    _jump687:; // Begin body of loop
    _97 += y.d1;
    _98++;
    if (_98 < y.d1)
    goto _jump687;
    _98 = 0;
    _99++;
    if (_99 < u.d2)
    goto _jump687;
    // End body of loop
    int64_t _100 = 651;
    if (_97 >= 0)
    goto _jump688;
    fail_assertion("negative array index");
    _jump688:;
    if (_97 < _91.d0)
    goto _jump689;
    fail_assertion("index too large");
    _jump689:;
    if (_100 >= 0)
    goto _jump690;
    fail_assertion("negative array index");
    _jump690:;
    if (_100 < _91.d1)
    goto _jump691;
    fail_assertion("index too large");
    _jump691:;
    if (r >= 0)
    goto _jump692;
    fail_assertion("negative array index");
    _jump692:;
    if (r < _91.d2)
    goto _jump693;
    fail_assertion("index too large");
    _jump693:;
    int64_t _101 = 0;
    _101 *= _91.d0;
    _101 += _97;
    _101 *= _91.d1;
    _101 += _100;
    _101 *= _91.d2;
    _101 += r;
    int64_t _102 = _91.data[_101];
    _90.d0 = _102;
    if (_102 > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    // Computing bound for L
    int64_t _103 = u.d1 % u.d2;
    _90.d1 = _103;
    if (_103 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= _102;
    _104 *= _103;
    _104 *= sizeof(bool);
    _90.data = jpl_alloc(_104);
    int64_t _105 = 0; // L
    int64_t _106 = 0; // K
    _jump696:; // Begin body of loop
    bool _107 = true;
    int64_t _108 = 0;
    _108 *= _90.d0;
    _108 += _106;
    _108 *= _90.d1;
    _108 += _105;
    _90.data[_108] = _107;
    _105++;
    if (_105 < _103)
    goto _jump696;
    _105 = 0;
    _106++;
    if (_106 < _102)
    goto _jump696;
    // End body of loop
    int64_t _109 = 0;
    _109 *= _86.d0;
    _109 += _89;
    _109 *= _86.d1;
    _109 += _88;
    _86.data[_109] = _90;
    _88++;
    if (_88 < y.d1)
    goto _jump680;
    _88 = 0;
    _89++;
    if (_89 < u.d2)
    goto _jump680;
    // End body of loop
    if (y.d0 >= 0)
    goto _jump697;
    fail_assertion("negative array index");
    _jump697:;
    if (y.d0 < _86.d0)
    goto _jump698;
    fail_assertion("index too large");
    _jump698:;
    if (c >= 0)
    goto _jump699;
    fail_assertion("negative array index");
    _jump699:;
    if (c < _86.d1)
    goto _jump700;
    fail_assertion("index too large");
    _jump700:;
    int64_t _110 = 0;
    _110 *= _86.d0;
    _110 += y.d0;
    _110 *= _86.d1;
    _110 += c;
    _a2_bool _111 = _86.data[_110];
    bool _112 = true;
    _a3_bool _113;
    if (!_112)
    goto _jump701;
    _a3_bool _114;
    // Computing bound for I
    int64_t _115 = -r;
    _114.d0 = _115;
    if (_115 > 0) 
    goto _jump702;
    fail_assertion("non-positive loop bound");
    _jump702:;
    // Computing bound for J
    _114.d1 = n;
    if (n > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing bound for K
    int64_t _116;
    // Computing bound for I
    if (u.d1 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for J
    int64_t _117 = 32;
    if (_117 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing bound for K
    int64_t _118 = m / u.d1;
    if (_118 > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    _116 = 0;
    int64_t _119 = 0; // K
    int64_t _120 = 0; // J
    int64_t _121 = 0; // I
    _jump707:; // Begin body of loop
    _116 += y.d0;
    _119++;
    if (_119 < _118)
    goto _jump707;
    _119 = 0;
    _120++;
    if (_120 < _117)
    goto _jump707;
    _120 = 0;
    _121++;
    if (_121 < u.d1)
    goto _jump707;
    // End body of loop
    int64_t _122 = _116 - k;
    _114.d2 = _122;
    if (_122 > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    // Computing total size of heap memory to allocate
    int64_t _123 = 1;
    _123 *= _115;
    _123 *= n;
    _123 *= _122;
    _123 *= sizeof(bool);
    _114.data = jpl_alloc(_123);
    int64_t _124 = 0; // K
    int64_t _125 = 0; // J
    int64_t _126 = 0; // I
    _jump709:; // Begin body of loop
    bool _127 = true;
    int64_t _128 = 0;
    _128 *= _114.d0;
    _128 += _126;
    _128 *= _114.d1;
    _128 += _125;
    _128 *= _114.d2;
    _128 += _124;
    _114.data[_128] = _127;
    _124++;
    if (_124 < _122)
    goto _jump709;
    _124 = 0;
    _125++;
    if (_125 < n)
    goto _jump709;
    _125 = 0;
    _126++;
    if (_126 < _115)
    goto _jump709;
    // End body of loop
    _113 = _114;
    goto _jump710;
    _jump701:;
    bool _129 = true;
    _a3__a2_double _130;
    if (!_129)
    goto _jump711;
    _130 = u;
    goto _jump712;
    _jump711:;
    _130 = u;
    _jump712:;
    bool _131 = t(_130, y);
    bool _132;
    if (!_131)
    goto _jump713;
    if (h >= 0)
    goto _jump714;
    fail_assertion("negative array index");
    _jump714:;
    if (h < y.d0)
    goto _jump715;
    fail_assertion("index too large");
    _jump715:;
    if (u.d2 >= 0)
    goto _jump716;
    fail_assertion("negative array index");
    _jump716:;
    if (u.d2 < y.d1)
    goto _jump717;
    fail_assertion("index too large");
    _jump717:;
    int64_t _134 = 0;
    _134 *= y.d0;
    _134 += h;
    _134 *= y.d1;
    _134 += u.d2;
    bool _135 = y.data[_134];
    bool _133 = _135;
    if (0 != _135)
    goto _jump718;
    bool _136 = false;
    _133 = _136;
    _jump718:;
    _132 = _133;
    goto _jump719;
    _jump713:;
    bool _137 = _22.a;
    _132 = _137;
    _jump719:;
    _a3_bool _138;
    if (!_132)
    goto _jump720;
    _a2__a3_bool _139;
    // Computing bound for I
    _139.d0 = u.d0;
    if (u.d0 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for J
    _139.d1 = d;
    if (d > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= u.d0;
    _140 *= d;
    _140 *= sizeof(_a3_bool);
    _139.data = jpl_alloc(_140);
    int64_t _141 = 0; // J
    int64_t _142 = 0; // I
    _jump723:; // Begin body of loop
    _a3_bool _143;
    // Computing bound for K
    _143.d0 = c;
    if (c > 0) 
    goto _jump724;
    fail_assertion("non-positive loop bound");
    _jump724:;
    // Computing bound for L
    _143.d1 = y.d0;
    if (y.d0 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing bound for M
    _143.d2 = u.d0;
    if (u.d0 > 0) 
    goto _jump726;
    fail_assertion("non-positive loop bound");
    _jump726:;
    // Computing total size of heap memory to allocate
    int64_t _144 = 1;
    _144 *= c;
    _144 *= y.d0;
    _144 *= u.d0;
    _144 *= sizeof(bool);
    _143.data = jpl_alloc(_144);
    int64_t _145 = 0; // M
    int64_t _146 = 0; // L
    int64_t _147 = 0; // K
    _jump727:; // Begin body of loop
    bool _148 = false;
    int64_t _149 = 0;
    _149 *= _143.d0;
    _149 += _147;
    _149 *= _143.d1;
    _149 += _146;
    _149 *= _143.d2;
    _149 += _145;
    _143.data[_149] = _148;
    _145++;
    if (_145 < u.d0)
    goto _jump727;
    _145 = 0;
    _146++;
    if (_146 < y.d0)
    goto _jump727;
    _146 = 0;
    _147++;
    if (_147 < c)
    goto _jump727;
    // End body of loop
    int64_t _150 = 0;
    _150 *= _139.d0;
    _150 += _142;
    _150 *= _139.d1;
    _150 += _141;
    _139.data[_150] = _143;
    _141++;
    if (_141 < d)
    goto _jump723;
    _141 = 0;
    _142++;
    if (_142 < u.d0)
    goto _jump723;
    // End body of loop
    if (n >= 0)
    goto _jump728;
    fail_assertion("negative array index");
    _jump728:;
    if (n < _139.d0)
    goto _jump729;
    fail_assertion("index too large");
    _jump729:;
    if (m >= 0)
    goto _jump730;
    fail_assertion("negative array index");
    _jump730:;
    if (m < _139.d1)
    goto _jump731;
    fail_assertion("index too large");
    _jump731:;
    int64_t _151 = 0;
    _151 *= _139.d0;
    _151 += n;
    _151 *= _139.d1;
    _151 += m;
    _a3_bool _152 = _139.data[_151];
    _138 = _152;
    goto _jump732;
    _jump720:;
    _a2__a3_bool _153;
    // Computing bound for I
    _153.d0 = y.d0;
    if (y.d0 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing bound for J
    _153.d1 = h;
    if (h > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= y.d0;
    _154 *= h;
    _154 *= sizeof(_a3_bool);
    _153.data = jpl_alloc(_154);
    int64_t _155 = 0; // J
    int64_t _156 = 0; // I
    _jump735:; // Begin body of loop
    _a3_bool _157;
    // Computing bound for K
    _157.d0 = u.d0;
    if (u.d0 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for L
    _157.d1 = k;
    if (k > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    // Computing bound for M
    _157.d2 = k;
    if (k > 0) 
    goto _jump738;
    fail_assertion("non-positive loop bound");
    _jump738:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= u.d0;
    _158 *= k;
    _158 *= k;
    _158 *= sizeof(bool);
    _157.data = jpl_alloc(_158);
    int64_t _159 = 0; // M
    int64_t _160 = 0; // L
    int64_t _161 = 0; // K
    _jump739:; // Begin body of loop
    bool _162 = false;
    int64_t _163 = 0;
    _163 *= _157.d0;
    _163 += _161;
    _163 *= _157.d1;
    _163 += _160;
    _163 *= _157.d2;
    _163 += _159;
    _157.data[_163] = _162;
    _159++;
    if (_159 < k)
    goto _jump739;
    _159 = 0;
    _160++;
    if (_160 < k)
    goto _jump739;
    _160 = 0;
    _161++;
    if (_161 < u.d0)
    goto _jump739;
    // End body of loop
    int64_t _164 = 0;
    _164 *= _153.d0;
    _164 += _156;
    _164 *= _153.d1;
    _164 += _155;
    _153.data[_164] = _157;
    _155++;
    if (_155 < h)
    goto _jump735;
    _155 = 0;
    _156++;
    if (_156 < y.d0)
    goto _jump735;
    // End body of loop
    if (m >= 0)
    goto _jump740;
    fail_assertion("negative array index");
    _jump740:;
    if (m < _153.d0)
    goto _jump741;
    fail_assertion("index too large");
    _jump741:;
    if (m >= 0)
    goto _jump742;
    fail_assertion("negative array index");
    _jump742:;
    if (m < _153.d1)
    goto _jump743;
    fail_assertion("index too large");
    _jump743:;
    int64_t _165 = 0;
    _165 *= _153.d0;
    _165 += m;
    _165 *= _153.d1;
    _165 += m;
    _a3_bool _166 = _153.data[_165];
    _138 = _166;
    _jump732:;
    _113 = _138;
    _jump710:;
    int64_t _167 = p(_111, _113);
    if (u.d2 >= 0)
    goto _jump744;
    fail_assertion("negative array index");
    _jump744:;
    if (u.d2 < _52.d0)
    goto _jump745;
    fail_assertion("index too large");
    _jump745:;
    if (n >= 0)
    goto _jump746;
    fail_assertion("negative array index");
    _jump746:;
    if (n < _52.d1)
    goto _jump747;
    fail_assertion("index too large");
    _jump747:;
    if (_167 >= 0)
    goto _jump748;
    fail_assertion("negative array index");
    _jump748:;
    if (_167 < _52.d2)
    goto _jump749;
    fail_assertion("index too large");
    _jump749:;
    int64_t _168 = 0;
    _168 *= _52.d0;
    _168 += u.d2;
    _168 *= _52.d1;
    _168 += n;
    _168 *= _52.d2;
    _168 += _167;
    bool _169 = _52.data[_168];
    return _169;
}

void_t w(a x, rgba y, _a2_rgba z) {
    int64_t _0;
    // Computing bound for C
    int64_t _1 = 690;
    if (_1 >= 0)
    goto _jump750;
    fail_assertion("negative array index");
    _jump750:;
    if (_1 < g.d0)
    goto _jump751;
    fail_assertion("index too large");
    _jump751:;
    int64_t _2 = 0;
    _2 *= g.d0;
    _2 += _1;
    int64_t _3 = g.data[_2];
    if (_3 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for D
    if (k > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    _0 = 0;
    int64_t _4 = 0; // D
    int64_t _5 = 0; // C
    _jump754:; // Begin body of loop
    _0 += k;
    _4++;
    if (_4 < k)
    goto _jump754;
    _4 = 0;
    _5++;
    if (_5 < _3)
    goto _jump754;
    // End body of loop
    int64_t _6 = c / _0;
    _a3_int64_t _8;
    // Computing bound for D
    int64_t _9;
    // Computing bound for D
    if (h > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    // Computing bound for E
    if (c > 0) 
    goto _jump756;
    fail_assertion("non-positive loop bound");
    _jump756:;
    // Computing bound for F
    if (z.d1 > 0) 
    goto _jump757;
    fail_assertion("non-positive loop bound");
    _jump757:;
    _9 = 0;
    int64_t _10 = 0; // F
    int64_t _11 = 0; // E
    int64_t _12 = 0; // D
    _jump758:; // Begin body of loop
    _9 += u;
    _10++;
    if (_10 < z.d1)
    goto _jump758;
    _10 = 0;
    _11++;
    if (_11 < c)
    goto _jump758;
    _11 = 0;
    _12++;
    if (_12 < h)
    goto _jump758;
    // End body of loop
    _8.d0 = _9;
    if (_9 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing bound for E
    _8.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    // Computing bound for F
    _8.d2 = d;
    if (d > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _9;
    _13 *= z.d0;
    _13 *= d;
    _13 *= sizeof(int64_t);
    _8.data = jpl_alloc(_13);
    int64_t _14 = 0; // F
    int64_t _15 = 0; // E
    int64_t _16 = 0; // D
    _jump762:; // Begin body of loop
    int64_t _17 = -_6;
    int64_t _18 = 0;
    _18 *= _8.d0;
    _18 += _16;
    _18 *= _8.d1;
    _18 += _15;
    _18 *= _8.d2;
    _18 += _14;
    _8.data[_18] = _17;
    _14++;
    if (_14 < d)
    goto _jump762;
    _14 = 0;
    _15++;
    if (_15 < z.d0)
    goto _jump762;
    _15 = 0;
    _16++;
    if (_16 < _9)
    goto _jump762;
    // End body of loop
    if (h >= 0)
    goto _jump763;
    fail_assertion("negative array index");
    _jump763:;
    if (h < _8.d0)
    goto _jump764;
    fail_assertion("index too large");
    _jump764:;
    if (h >= 0)
    goto _jump765;
    fail_assertion("negative array index");
    _jump765:;
    if (h < _8.d1)
    goto _jump766;
    fail_assertion("index too large");
    _jump766:;
    if (n >= 0)
    goto _jump767;
    fail_assertion("negative array index");
    _jump767:;
    if (n < _8.d2)
    goto _jump768;
    fail_assertion("index too large");
    _jump768:;
    int64_t _19 = 0;
    _19 *= _8.d0;
    _19 += h;
    _19 *= _8.d1;
    _19 += h;
    _19 *= _8.d2;
    _19 += n;
    int64_t _20 = _8.data[_19];
    bool _21 = false;
    bool _22;
    if (!_21)
    goto _jump769;
    bool _23 = d >= r;
    _22 = _23;
    goto _jump770;
    _jump769:;
    int64_t _24 = 283;
    bool _25 = _24 >= d;
    _22 = _25;
    _jump770:;
    _a3__a3_int64_t _26;
    if (!_22)
    goto _jump771;
    _a3__a3_int64_t _27;
    // Computing bound for D
    bool _28 = true;
    int64_t _29;
    if (!_28)
    goto _jump772;
    int64_t _30 = 769;
    _29 = _30;
    goto _jump773;
    _jump772:;
    _29 = h;
    _jump773:;
    _27.d0 = _29;
    if (_29 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    // Computing bound for E
    int64_t _31 = -m;
    _27.d1 = _31;
    if (_31 > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    // Computing bound for F
    _27.d2 = m;
    if (m > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    // Computing total size of heap memory to allocate
    int64_t _32 = 1;
    _32 *= _29;
    _32 *= _31;
    _32 *= m;
    _32 *= sizeof(_a3_int64_t);
    _27.data = jpl_alloc(_32);
    int64_t _33 = 0; // F
    int64_t _34 = 0; // E
    int64_t _35 = 0; // D
    _jump777:; // Begin body of loop
    _a3_int64_t _36;
    // Computing bound for G
    _36.d0 = _35;
    if (_35 > 0) 
    goto _jump778;
    fail_assertion("non-positive loop bound");
    _jump778:;
    // Computing bound for H
    _36.d1 = d;
    if (d > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing bound for I
    _36.d2 = _35;
    if (_35 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _35;
    _37 *= d;
    _37 *= _35;
    _37 *= sizeof(int64_t);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // I
    int64_t _39 = 0; // H
    int64_t _40 = 0; // G
    _jump781:; // Begin body of loop
    int64_t _41 = 0;
    _41 *= _36.d0;
    _41 += _40;
    _41 *= _36.d1;
    _41 += _39;
    _41 *= _36.d2;
    _41 += _38;
    _36.data[_41] = n;
    _38++;
    if (_38 < _35)
    goto _jump781;
    _38 = 0;
    _39++;
    if (_39 < d)
    goto _jump781;
    _39 = 0;
    _40++;
    if (_40 < _35)
    goto _jump781;
    // End body of loop
    int64_t _42 = 0;
    _42 *= _27.d0;
    _42 += _35;
    _42 *= _27.d1;
    _42 += _34;
    _42 *= _27.d2;
    _42 += _33;
    _27.data[_42] = _36;
    _33++;
    if (_33 < m)
    goto _jump777;
    _33 = 0;
    _34++;
    if (_34 < _31)
    goto _jump777;
    _34 = 0;
    _35++;
    if (_35 < _29)
    goto _jump777;
    // End body of loop
    _26 = _27;
    goto _jump782;
    _jump771:;
    _a3__a3_int64_t _43;
    // Computing bound for D
    int64_t _44 = 605;
    _43.d0 = _44;
    if (_44 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing bound for E
    int64_t _45;
    // Computing bound for D
    if (h > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    // Computing bound for E
    if (n > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    _45 = 0;
    int64_t _46 = 0; // E
    int64_t _47 = 0; // D
    _jump786:; // Begin body of loop
    _45 += c;
    _46++;
    if (_46 < n)
    goto _jump786;
    _46 = 0;
    _47++;
    if (_47 < h)
    goto _jump786;
    // End body of loop
    _43.d1 = _45;
    if (_45 > 0) 
    goto _jump787;
    fail_assertion("non-positive loop bound");
    _jump787:;
    // Computing bound for F
    _43.d2 = z.d1;
    if (z.d1 > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= _44;
    _48 *= _45;
    _48 *= z.d1;
    _48 *= sizeof(_a3_int64_t);
    _43.data = jpl_alloc(_48);
    int64_t _49 = 0; // F
    int64_t _50 = 0; // E
    int64_t _51 = 0; // D
    _jump789:; // Begin body of loop
    _a3_int64_t _52;
    // Computing bound for G
    _52.d0 = d;
    if (d > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for H
    _52.d1 = _6;
    if (_6 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for I
    _52.d2 = _6;
    if (_6 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= d;
    _53 *= _6;
    _53 *= _6;
    _53 *= sizeof(int64_t);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // I
    int64_t _55 = 0; // H
    int64_t _56 = 0; // G
    _jump793:; // Begin body of loop
    int64_t _57 = 0;
    _57 *= _52.d0;
    _57 += _56;
    _57 *= _52.d1;
    _57 += _55;
    _57 *= _52.d2;
    _57 += _54;
    _52.data[_57] = h;
    _54++;
    if (_54 < _6)
    goto _jump793;
    _54 = 0;
    _55++;
    if (_55 < _6)
    goto _jump793;
    _55 = 0;
    _56++;
    if (_56 < d)
    goto _jump793;
    // End body of loop
    int64_t _58 = 0;
    _58 *= _43.d0;
    _58 += _51;
    _58 *= _43.d1;
    _58 += _50;
    _58 *= _43.d2;
    _58 += _49;
    _43.data[_58] = _52;
    _49++;
    if (_49 < z.d1)
    goto _jump789;
    _49 = 0;
    _50++;
    if (_50 < _45)
    goto _jump789;
    _50 = 0;
    _51++;
    if (_51 < _44)
    goto _jump789;
    // End body of loop
    _26 = _43;
    _jump782:;
    double _59 = 65.0;
    bool _60 = _59 == i;
    _a1_int64_t _61;
    if (!_60)
    goto _jump794;
    _61 = j;
    goto _jump795;
    _jump794:;
    _a1_int64_t _62;
    // Computing bound for D
    _62.d0 = r;
    if (r > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= r;
    _63 *= sizeof(int64_t);
    _62.data = jpl_alloc(_63);
    int64_t _64 = 0; // D
    _jump797:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _62.d0;
    _65 += _64;
    _62.data[_65] = u;
    _64++;
    if (_64 < r)
    goto _jump797;
    // End body of loop
    _61 = _62;
    _jump795:;
    if (m >= 0)
    goto _jump798;
    fail_assertion("negative array index");
    _jump798:;
    if (m < _61.d0)
    goto _jump799;
    fail_assertion("index too large");
    _jump799:;
    int64_t _66 = 0;
    _66 *= _61.d0;
    _66 += m;
    int64_t _67 = _61.data[_66];
    if (h >= 0)
    goto _jump800;
    fail_assertion("negative array index");
    _jump800:;
    if (h < _26.d0)
    goto _jump801;
    fail_assertion("index too large");
    _jump801:;
    if (_67 >= 0)
    goto _jump802;
    fail_assertion("negative array index");
    _jump802:;
    if (_67 < _26.d1)
    goto _jump803;
    fail_assertion("index too large");
    _jump803:;
    if (h >= 0)
    goto _jump804;
    fail_assertion("negative array index");
    _jump804:;
    if (h < _26.d2)
    goto _jump805;
    fail_assertion("index too large");
    _jump805:;
    int64_t _68 = 0;
    _68 *= _26.d0;
    _68 += h;
    _68 *= _26.d1;
    _68 += _67;
    _68 *= _26.d2;
    _68 += h;
    _a3_int64_t _69 = _26.data[_68];
    if (c >= 0)
    goto _jump806;
    fail_assertion("negative array index");
    _jump806:;
    if (c < _69.d0)
    goto _jump807;
    fail_assertion("index too large");
    _jump807:;
    if (n >= 0)
    goto _jump808;
    fail_assertion("negative array index");
    _jump808:;
    if (n < _69.d1)
    goto _jump809;
    fail_assertion("index too large");
    _jump809:;
    if (m >= 0)
    goto _jump810;
    fail_assertion("negative array index");
    _jump810:;
    if (m < _69.d2)
    goto _jump811;
    fail_assertion("index too large");
    _jump811:;
    int64_t _70 = 0;
    _70 *= _69.d0;
    _70 += c;
    _70 *= _69.d1;
    _70 += n;
    _70 *= _69.d2;
    _70 += m;
    int64_t _71 = _69.data[_70];
    bool _72 = _20 == _71;
    bool _7 = _72;
    if (0 == _72)
    goto _jump812;
    bool _74 = false;
    bool _73 = _74;
    if (0 == _74)
    goto _jump813;
    bool _75 = false;
    a _76;
    if (!_75)
    goto _jump814;
    bool _77 = false;
    double _78 = 96.0;
    bool _79 = true;
    a _80 = { _77, _78, _79 };
    _76 = _80;
    goto _jump815;
    _jump814:;
    _76 = x;
    _jump815:;
    bool _81 = _76.a;
    double _82;
    // Computing bound for D
    if (z.d0 > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    // Computing bound for E
    int64_t _83 = -z.d0;
    if (_83 > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for F
    int64_t _84;
    // Computing bound for D
    if (_6 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing bound for E
    if (d > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    // Computing bound for F
    if (m > 0) 
    goto _jump820;
    fail_assertion("non-positive loop bound");
    _jump820:;
    _84 = 0;
    int64_t _85 = 0; // F
    int64_t _86 = 0; // E
    int64_t _87 = 0; // D
    _jump821:; // Begin body of loop
    _84 += _6;
    _85++;
    if (_85 < m)
    goto _jump821;
    _85 = 0;
    _86++;
    if (_86 < d)
    goto _jump821;
    _86 = 0;
    _87++;
    if (_87 < _6)
    goto _jump821;
    // End body of loop
    int64_t _88 = _84 + d;
    if (_88 > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    _82 = 0;
    int64_t _89 = 0; // F
    int64_t _90 = 0; // E
    int64_t _91 = 0; // D
    _jump823:; // Begin body of loop
    double _92 = x.b;
    _82 += _92;
    _89++;
    if (_89 < _88)
    goto _jump823;
    _89 = 0;
    _90++;
    if (_90 < _83)
    goto _jump823;
    _90 = 0;
    _91++;
    if (_91 < z.d0)
    goto _jump823;
    // End body of loop
    bool _93 = false;
    double _94 = x.b;
    bool _95 = u == k;
    a _96 = { _93, _94, _95 };
    bool _97 = _96.a;
    a _98 = { _81, _82, _97 };
    bool _99 = _98.c;
    _73 = _99;
    _jump813:;
    _7 = _73;
    _jump812:;
    if (0 != _7)
    goto _jump824;
    fail_assertion("D");
    _jump824:;
    double _100;
    // Computing bound for D
    int64_t _101 = 244;
    if (_101 > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    // Computing bound for E
    if (u > 0) 
    goto _jump826;
    fail_assertion("non-positive loop bound");
    _jump826:;
    // Computing bound for F
    bool _102 = false;
    int64_t _103;
    if (!_102)
    goto _jump827;
    _103 = n;
    goto _jump828;
    _jump827:;
    _103 = h;
    _jump828:;
    if (_103 > 0) 
    goto _jump829;
    fail_assertion("non-positive loop bound");
    _jump829:;
    _100 = 0;
    int64_t _104 = 0; // F
    int64_t _105 = 0; // E
    int64_t _106 = 0; // D
    _jump830:; // Begin body of loop
    bool _108 = x.c;
    bool _107 = _108;
    if (0 == _108)
    goto _jump831;
    bool _109 = true;
    _107 = _109;
    _jump831:;
    _a2__a2_double _110;
    if (!_107)
    goto _jump832;
    _a2__a2_double _111;
    // Computing bound for G
    _111.d0 = d;
    if (d > 0) 
    goto _jump833;
    fail_assertion("non-positive loop bound");
    _jump833:;
    // Computing bound for H
    _111.d1 = z.d0;
    if (z.d0 > 0) 
    goto _jump834;
    fail_assertion("non-positive loop bound");
    _jump834:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= d;
    _112 *= z.d0;
    _112 *= sizeof(_a2_double);
    _111.data = jpl_alloc(_112);
    int64_t _113 = 0; // H
    int64_t _114 = 0; // G
    _jump835:; // Begin body of loop
    _a2_double _115;
    // Computing bound for I
    _115.d0 = k;
    if (k > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for J
    _115.d1 = _113;
    if (_113 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= k;
    _116 *= _113;
    _116 *= sizeof(double);
    _115.data = jpl_alloc(_116);
    int64_t _117 = 0; // J
    int64_t _118 = 0; // I
    _jump838:; // Begin body of loop
    double _119 = -f;
    int64_t _120 = 0;
    _120 *= _115.d0;
    _120 += _118;
    _120 *= _115.d1;
    _120 += _117;
    _115.data[_120] = _119;
    _117++;
    if (_117 < _113)
    goto _jump838;
    _117 = 0;
    _118++;
    if (_118 < k)
    goto _jump838;
    // End body of loop
    int64_t _121 = 0;
    _121 *= _111.d0;
    _121 += _114;
    _121 *= _111.d1;
    _121 += _113;
    _111.data[_121] = _115;
    _113++;
    if (_113 < z.d0)
    goto _jump835;
    _113 = 0;
    _114++;
    if (_114 < d)
    goto _jump835;
    // End body of loop
    _110 = _111;
    goto _jump839;
    _jump832:;
    _a2__a2_double _122;
    // Computing bound for G
    _122.d0 = c;
    if (c > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for H
    int64_t _123;
    // Computing bound for G
    if (k > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing bound for H
    if (n > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing bound for I
    int64_t _124 = 586;
    if (_124 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    _123 = 0;
    int64_t _125 = 0; // I
    int64_t _126 = 0; // H
    int64_t _127 = 0; // G
    _jump844:; // Begin body of loop
    int64_t _128 = 477;
    _123 += _128;
    _125++;
    if (_125 < _124)
    goto _jump844;
    _125 = 0;
    _126++;
    if (_126 < n)
    goto _jump844;
    _126 = 0;
    _127++;
    if (_127 < k)
    goto _jump844;
    // End body of loop
    _122.d1 = _123;
    if (_123 > 0) 
    goto _jump845;
    fail_assertion("non-positive loop bound");
    _jump845:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= c;
    _129 *= _123;
    _129 *= sizeof(_a2_double);
    _122.data = jpl_alloc(_129);
    int64_t _130 = 0; // H
    int64_t _131 = 0; // G
    _jump846:; // Begin body of loop
    _a2_double _132;
    // Computing bound for I
    _132.d0 = _130;
    if (_130 > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing bound for J
    _132.d1 = _131;
    if (_131 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing total size of heap memory to allocate
    int64_t _133 = 1;
    _133 *= _130;
    _133 *= _131;
    _133 *= sizeof(double);
    _132.data = jpl_alloc(_133);
    int64_t _134 = 0; // J
    int64_t _135 = 0; // I
    _jump849:; // Begin body of loop
    double _136 = y.b;
    int64_t _137 = 0;
    _137 *= _132.d0;
    _137 += _135;
    _137 *= _132.d1;
    _137 += _134;
    _132.data[_137] = _136;
    _134++;
    if (_134 < _131)
    goto _jump849;
    _134 = 0;
    _135++;
    if (_135 < _130)
    goto _jump849;
    // End body of loop
    int64_t _138 = 0;
    _138 *= _122.d0;
    _138 += _131;
    _138 *= _122.d1;
    _138 += _130;
    _122.data[_138] = _132;
    _130++;
    if (_130 < _123)
    goto _jump846;
    _130 = 0;
    _131++;
    if (_131 < c)
    goto _jump846;
    // End body of loop
    _110 = _122;
    _jump839:;
    if (d >= 0)
    goto _jump850;
    fail_assertion("negative array index");
    _jump850:;
    if (d < _110.d0)
    goto _jump851;
    fail_assertion("index too large");
    _jump851:;
    if (_106 >= 0)
    goto _jump852;
    fail_assertion("negative array index");
    _jump852:;
    if (_106 < _110.d1)
    goto _jump853;
    fail_assertion("index too large");
    _jump853:;
    int64_t _139 = 0;
    _139 *= _110.d0;
    _139 += d;
    _139 *= _110.d1;
    _139 += _106;
    _a2_double _140 = _110.data[_139];
    int64_t _142 = 146;
    bool _143 = _142 > k;
    bool _141 = _143;
    if (0 != _143)
    goto _jump854;
    bool _144 = m == _106;
    _141 = _144;
    _jump854:;
    _a3__a2_bool _145;
    if (!_141)
    goto _jump855;
    _a3__a2_bool _146;
    // Computing bound for G
    int64_t _147;
    // Computing bound for G
    if (d > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing bound for H
    if (z.d0 > 0) 
    goto _jump857;
    fail_assertion("non-positive loop bound");
    _jump857:;
    // Computing bound for I
    if (h > 0) 
    goto _jump858;
    fail_assertion("non-positive loop bound");
    _jump858:;
    _147 = 0;
    int64_t _148 = 0; // I
    int64_t _149 = 0; // H
    int64_t _150 = 0; // G
    _jump859:; // Begin body of loop
    _147 += _106;
    _148++;
    if (_148 < h)
    goto _jump859;
    _148 = 0;
    _149++;
    if (_149 < z.d0)
    goto _jump859;
    _149 = 0;
    _150++;
    if (_150 < d)
    goto _jump859;
    // End body of loop
    _146.d0 = _147;
    if (_147 > 0) 
    goto _jump860;
    fail_assertion("non-positive loop bound");
    _jump860:;
    // Computing bound for H
    int64_t _151 = n + k;
    _146.d1 = _151;
    if (_151 > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    // Computing bound for I
    int64_t _152 = -_104;
    _146.d2 = _152;
    if (_152 > 0) 
    goto _jump862;
    fail_assertion("non-positive loop bound");
    _jump862:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _147;
    _153 *= _151;
    _153 *= _152;
    _153 *= sizeof(_a2_bool);
    _146.data = jpl_alloc(_153);
    int64_t _154 = 0; // I
    int64_t _155 = 0; // H
    int64_t _156 = 0; // G
    _jump863:; // Begin body of loop
    _a2_bool _157;
    // Computing bound for J
    _157.d0 = _154;
    if (_154 > 0) 
    goto _jump864;
    fail_assertion("non-positive loop bound");
    _jump864:;
    // Computing bound for K
    _157.d1 = u;
    if (u > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= _154;
    _158 *= u;
    _158 *= sizeof(bool);
    _157.data = jpl_alloc(_158);
    int64_t _159 = 0; // K
    int64_t _160 = 0; // J
    _jump866:; // Begin body of loop
    bool _161 = false;
    int64_t _162 = 0;
    _162 *= _157.d0;
    _162 += _160;
    _162 *= _157.d1;
    _162 += _159;
    _157.data[_162] = _161;
    _159++;
    if (_159 < u)
    goto _jump866;
    _159 = 0;
    _160++;
    if (_160 < _154)
    goto _jump866;
    // End body of loop
    int64_t _163 = 0;
    _163 *= _146.d0;
    _163 += _156;
    _163 *= _146.d1;
    _163 += _155;
    _163 *= _146.d2;
    _163 += _154;
    _146.data[_163] = _157;
    _154++;
    if (_154 < _152)
    goto _jump863;
    _154 = 0;
    _155++;
    if (_155 < _151)
    goto _jump863;
    _155 = 0;
    _156++;
    if (_156 < _147)
    goto _jump863;
    // End body of loop
    _145 = _146;
    goto _jump867;
    _jump855:;
    _a3__a2_bool _164;
    // Computing bound for G
    _164.d0 = c;
    if (c > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing bound for H
    _164.d1 = d;
    if (d > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing bound for I
    _164.d2 = z.d0;
    if (z.d0 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= c;
    _165 *= d;
    _165 *= z.d0;
    _165 *= sizeof(_a2_bool);
    _164.data = jpl_alloc(_165);
    int64_t _166 = 0; // I
    int64_t _167 = 0; // H
    int64_t _168 = 0; // G
    _jump871:; // Begin body of loop
    _a2_bool _169;
    // Computing bound for J
    _169.d0 = _104;
    if (_104 > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    // Computing bound for K
    _169.d1 = n;
    if (n > 0) 
    goto _jump873;
    fail_assertion("non-positive loop bound");
    _jump873:;
    // Computing total size of heap memory to allocate
    int64_t _170 = 1;
    _170 *= _104;
    _170 *= n;
    _170 *= sizeof(bool);
    _169.data = jpl_alloc(_170);
    int64_t _171 = 0; // K
    int64_t _172 = 0; // J
    _jump874:; // Begin body of loop
    bool _173 = false;
    int64_t _174 = 0;
    _174 *= _169.d0;
    _174 += _172;
    _174 *= _169.d1;
    _174 += _171;
    _169.data[_174] = _173;
    _171++;
    if (_171 < n)
    goto _jump874;
    _171 = 0;
    _172++;
    if (_172 < _104)
    goto _jump874;
    // End body of loop
    int64_t _175 = 0;
    _175 *= _164.d0;
    _175 += _168;
    _175 *= _164.d1;
    _175 += _167;
    _175 *= _164.d2;
    _175 += _166;
    _164.data[_175] = _169;
    _166++;
    if (_166 < z.d0)
    goto _jump871;
    _166 = 0;
    _167++;
    if (_167 < d)
    goto _jump871;
    _167 = 0;
    _168++;
    if (_168 < c)
    goto _jump871;
    // End body of loop
    _145 = _164;
    _jump867:;
    bool _176 = true;
    int64_t _177;
    if (!_176)
    goto _jump875;
    _177 = c;
    goto _jump876;
    _jump875:;
    _177 = k;
    _jump876:;
    _a2_int64_t _178;
    // Computing bound for G
    _178.d0 = h;
    if (h > 0) 
    goto _jump877;
    fail_assertion("non-positive loop bound");
    _jump877:;
    // Computing bound for H
    _178.d1 = c;
    if (c > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= h;
    _179 *= c;
    _179 *= sizeof(int64_t);
    _178.data = jpl_alloc(_179);
    int64_t _180 = 0; // H
    int64_t _181 = 0; // G
    _jump879:; // Begin body of loop
    int64_t _182 = 0;
    _182 *= _178.d0;
    _182 += _181;
    _182 *= _178.d1;
    _182 += _180;
    _178.data[_182] = z.d1;
    _180++;
    if (_180 < c)
    goto _jump879;
    _180 = 0;
    _181++;
    if (_181 < h)
    goto _jump879;
    // End body of loop
    if (_6 >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (_6 < _178.d0)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    if (_105 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_105 < _178.d1)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    int64_t _183 = 0;
    _183 *= _178.d0;
    _183 += _6;
    _183 *= _178.d1;
    _183 += _105;
    int64_t _184 = _178.data[_183];
    int64_t _185 = _177 / _184;
    _a2_bool _186;
    // Computing bound for G
    _186.d0 = c;
    if (c > 0) 
    goto _jump884;
    fail_assertion("non-positive loop bound");
    _jump884:;
    // Computing bound for H
    _186.d1 = _105;
    if (_105 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= c;
    _187 *= _105;
    _187 *= sizeof(bool);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // H
    int64_t _189 = 0; // G
    _jump886:; // Begin body of loop
    bool _190 = h == n;
    int64_t _191 = 0;
    _191 *= _186.d0;
    _191 += _189;
    _191 *= _186.d1;
    _191 += _188;
    _186.data[_191] = _190;
    _188++;
    if (_188 < _105)
    goto _jump886;
    _188 = 0;
    _189++;
    if (_189 < c)
    goto _jump886;
    // End body of loop
    _a3_bool _192;
    // Computing bound for G
    _192.d0 = d;
    if (d > 0) 
    goto _jump887;
    fail_assertion("non-positive loop bound");
    _jump887:;
    // Computing bound for H
    _192.d1 = _6;
    if (_6 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    // Computing bound for I
    _192.d2 = z.d0;
    if (z.d0 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing total size of heap memory to allocate
    int64_t _193 = 1;
    _193 *= d;
    _193 *= _6;
    _193 *= z.d0;
    _193 *= sizeof(bool);
    _192.data = jpl_alloc(_193);
    int64_t _194 = 0; // I
    int64_t _195 = 0; // H
    int64_t _196 = 0; // G
    _jump890:; // Begin body of loop
    bool _197 = true;
    int64_t _198 = 0;
    _198 *= _192.d0;
    _198 += _196;
    _198 *= _192.d1;
    _198 += _195;
    _198 *= _192.d2;
    _198 += _194;
    _192.data[_198] = _197;
    _194++;
    if (_194 < z.d0)
    goto _jump890;
    _194 = 0;
    _195++;
    if (_195 < _6)
    goto _jump890;
    _195 = 0;
    _196++;
    if (_196 < d)
    goto _jump890;
    // End body of loop
    int64_t _199 = p(_186, _192);
    if (_185 >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (_185 < _145.d0)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    if (_106 >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (_106 < _145.d1)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    if (_199 >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (_199 < _145.d2)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    int64_t _200 = 0;
    _200 *= _145.d0;
    _200 += _185;
    _200 *= _145.d1;
    _200 += _106;
    _200 *= _145.d2;
    _200 += _199;
    _a2_bool _201 = _145.data[_200];
    _a3_bool _202;
    // Computing bound for G
    _202.d0 = _104;
    if (_104 > 0) 
    goto _jump897;
    fail_assertion("non-positive loop bound");
    _jump897:;
    // Computing bound for H
    _202.d1 = c;
    if (c > 0) 
    goto _jump898;
    fail_assertion("non-positive loop bound");
    _jump898:;
    // Computing bound for I
    _202.d2 = m;
    if (m > 0) 
    goto _jump899;
    fail_assertion("non-positive loop bound");
    _jump899:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _104;
    _203 *= c;
    _203 *= m;
    _203 *= sizeof(bool);
    _202.data = jpl_alloc(_203);
    int64_t _204 = 0; // I
    int64_t _205 = 0; // H
    int64_t _206 = 0; // G
    _jump900:; // Begin body of loop
    double _207 = y.a;
    bool _208 = i < _207;
    bool _209;
    if (!_208)
    goto _jump901;
    double _210 = 82.0;
    double _211 = -_210;
    bool _212 = _211 == f;
    _209 = _212;
    goto _jump902;
    _jump901:;
    bool _213 = true;
    double _214 = 74.0;
    bool _215 = false;
    a _216 = { _213, _214, _215 };
    bool _217 = _216.c;
    _209 = _217;
    _jump902:;
    int64_t _218 = 0;
    _218 *= _202.d0;
    _218 += _206;
    _218 *= _202.d1;
    _218 += _205;
    _218 *= _202.d2;
    _218 += _204;
    _202.data[_218] = _209;
    _204++;
    if (_204 < m)
    goto _jump900;
    _204 = 0;
    _205++;
    if (_205 < c)
    goto _jump900;
    _205 = 0;
    _206++;
    if (_206 < _104)
    goto _jump900;
    // End body of loop
    int64_t _219 = p(_201, _202);
    int64_t _220;
    // Computing bound for G
    if (h >= 0)
    goto _jump903;
    fail_assertion("negative array index");
    _jump903:;
    if (h < q.d0)
    goto _jump904;
    fail_assertion("index too large");
    _jump904:;
    int64_t _221 = 0;
    _221 *= q.d0;
    _221 += h;
    int64_t _222 = q.data[_221];
    if (_222 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing bound for H
    if (k > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    // Computing bound for I
    int64_t _223 = _104 - _105;
    if (_223 > 0) 
    goto _jump907;
    fail_assertion("non-positive loop bound");
    _jump907:;
    _220 = 0;
    int64_t _224 = 0; // I
    int64_t _225 = 0; // H
    int64_t _226 = 0; // G
    _jump908:; // Begin body of loop
    _220 += _224;
    _224++;
    if (_224 < _223)
    goto _jump908;
    _224 = 0;
    _225++;
    if (_225 < k)
    goto _jump908;
    _225 = 0;
    _226++;
    if (_226 < _222)
    goto _jump908;
    // End body of loop
    if (_219 >= 0)
    goto _jump909;
    fail_assertion("negative array index");
    _jump909:;
    if (_219 < _140.d0)
    goto _jump910;
    fail_assertion("index too large");
    _jump910:;
    if (_220 >= 0)
    goto _jump911;
    fail_assertion("negative array index");
    _jump911:;
    if (_220 < _140.d1)
    goto _jump912;
    fail_assertion("index too large");
    _jump912:;
    int64_t _227 = 0;
    _227 *= _140.d0;
    _227 += _219;
    _227 *= _140.d1;
    _227 += _220;
    double _228 = _140.data[_227];
    _100 += _228;
    _104++;
    if (_104 < _103)
    goto _jump830;
    _104 = 0;
    _105++;
    if (_105 < u)
    goto _jump830;
    _105 = 0;
    _106++;
    if (_106 < _101)
    goto _jump830;
    // End body of loop
    _a2_a _229;
    // Computing bound for E
    int64_t _230 = 711;
    _229.d0 = _230;
    if (_230 > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    // Computing bound for F
    _229.d1 = h;
    if (h > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing total size of heap memory to allocate
    int64_t _231 = 1;
    _231 *= _230;
    _231 *= h;
    _231 *= sizeof(a);
    _229.data = jpl_alloc(_231);
    int64_t _232 = 0; // F
    int64_t _233 = 0; // E
    _jump915:; // Begin body of loop
    int64_t _234 = 0;
    _234 *= _229.d0;
    _234 += _233;
    _234 *= _229.d1;
    _234 += _232;
    _229.data[_234] = x;
    _232++;
    if (_232 < h)
    goto _jump915;
    _232 = 0;
    _233++;
    if (_233 < _230)
    goto _jump915;
    // End body of loop
    if (u >= 0)
    goto _jump916;
    fail_assertion("negative array index");
    _jump916:;
    if (u < _229.d0)
    goto _jump917;
    fail_assertion("index too large");
    _jump917:;
    if (k >= 0)
    goto _jump918;
    fail_assertion("negative array index");
    _jump918:;
    if (k < _229.d1)
    goto _jump919;
    fail_assertion("index too large");
    _jump919:;
    int64_t _235 = 0;
    _235 *= _229.d0;
    _235 += u;
    _235 *= _229.d1;
    _235 += k;
    a _236 = _229.data[_235];
    bool _237 = _236.a;
    bool _238 = !_237;
    bool _239;
    if (!_238)
    goto _jump920;
    bool _240 = true;
    bool _241 = !_240;
    _239 = _241;
    goto _jump921;
    _jump920:;
    bool _242 = false;
    bool _243 = !_242;
    _239 = _243;
    _jump921:;
    _a1_void_t _244;
    if (!_239)
    goto _jump922;
    _a2_void_t _245;
    // Computing bound for E
    _245.d0 = z.d1;
    if (z.d1 > 0) 
    goto _jump923;
    fail_assertion("non-positive loop bound");
    _jump923:;
    // Computing bound for F
    int64_t _246;
    // Computing bound for E
    if (n > 0) 
    goto _jump924;
    fail_assertion("non-positive loop bound");
    _jump924:;
    _246 = 0;
    int64_t _247 = 0; // E
    _jump925:; // Begin body of loop
    _246 += h;
    _247++;
    if (_247 < n)
    goto _jump925;
    // End body of loop
    _245.d1 = _246;
    if (_246 > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing total size of heap memory to allocate
    int64_t _248 = 1;
    _248 *= z.d1;
    _248 *= _246;
    _248 *= sizeof(void_t);
    _245.data = jpl_alloc(_248);
    int64_t _249 = 0; // F
    int64_t _250 = 0; // E
    _jump927:; // Begin body of loop
    bool _251 = false;
    rgba _252;
    if (!_251)
    goto _jump928;
    _252 = y;
    goto _jump929;
    _jump928:;
    _252 = y;
    _jump929:;
    void_t _253 = w(x, _252, z);
    int64_t _254 = 0;
    _254 *= _245.d0;
    _254 += _250;
    _254 *= _245.d1;
    _254 += _249;
    _245.data[_254] = _253;
    _249++;
    if (_249 < _246)
    goto _jump927;
    _249 = 0;
    _250++;
    if (_250 < z.d1)
    goto _jump927;
    // End body of loop
    if (z.d0 >= 0)
    goto _jump930;
    fail_assertion("negative array index");
    _jump930:;
    if (z.d0 < _245.d0)
    goto _jump931;
    fail_assertion("index too large");
    _jump931:;
    if (z.d1 >= 0)
    goto _jump932;
    fail_assertion("negative array index");
    _jump932:;
    if (z.d1 < _245.d1)
    goto _jump933;
    fail_assertion("index too large");
    _jump933:;
    int64_t _255 = 0;
    _255 *= _245.d0;
    _255 += z.d0;
    _255 *= _245.d1;
    _255 += z.d1;
    void_t _256 = _245.data[_255];
    _a1_void_t _257;
    _257.d0 = 1;
    _257.data = jpl_alloc(sizeof(void_t) * 1);
    _257.data[0] = _256;
    _244 = _257;
    goto _jump934;
    _jump922:;
    _a1_void_t _258;
    // Computing bound for E
    _258.d0 = m;
    if (m > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= m;
    _259 *= sizeof(void_t);
    _258.data = jpl_alloc(_259);
    int64_t _260 = 0; // E
    _jump936:; // Begin body of loop
    _a3_rgba _261;
    // Computing bound for F
    _261.d0 = z.d1;
    if (z.d1 > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing bound for G
    int64_t _262 = 606;
    _261.d1 = _262;
    if (_262 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    // Computing bound for H
    _261.d2 = r;
    if (r > 0) 
    goto _jump939;
    fail_assertion("non-positive loop bound");
    _jump939:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= z.d1;
    _263 *= _262;
    _263 *= r;
    _263 *= sizeof(rgba);
    _261.data = jpl_alloc(_263);
    int64_t _264 = 0; // H
    int64_t _265 = 0; // G
    int64_t _266 = 0; // F
    _jump940:; // Begin body of loop
    double _267 = 6.0;
    rgba _268 = { _267, f, i, f };
    int64_t _269 = 0;
    _269 *= _261.d0;
    _269 += _266;
    _269 *= _261.d1;
    _269 += _265;
    _269 *= _261.d2;
    _269 += _264;
    _261.data[_269] = _268;
    _264++;
    if (_264 < r)
    goto _jump940;
    _264 = 0;
    _265++;
    if (_265 < _262)
    goto _jump940;
    _265 = 0;
    _266++;
    if (_266 < z.d1)
    goto _jump940;
    // End body of loop
    _a2_int64_t _270;
    // Computing bound for F
    _270.d0 = _6;
    if (_6 > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    // Computing bound for G
    _270.d1 = _260;
    if (_260 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= _6;
    _271 *= _260;
    _271 *= sizeof(int64_t);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // G
    int64_t _273 = 0; // F
    _jump943:; // Begin body of loop
    int64_t _274 = 0;
    _274 *= _270.d0;
    _274 += _273;
    _274 *= _270.d1;
    _274 += _272;
    _270.data[_274] = z.d0;
    _272++;
    if (_272 < _260)
    goto _jump943;
    _272 = 0;
    _273++;
    if (_273 < _6)
    goto _jump943;
    // End body of loop
    if (_6 >= 0)
    goto _jump944;
    fail_assertion("negative array index");
    _jump944:;
    if (_6 < _270.d0)
    goto _jump945;
    fail_assertion("index too large");
    _jump945:;
    if (u >= 0)
    goto _jump946;
    fail_assertion("negative array index");
    _jump946:;
    if (u < _270.d1)
    goto _jump947;
    fail_assertion("index too large");
    _jump947:;
    int64_t _275 = 0;
    _275 *= _270.d0;
    _275 += _6;
    _275 *= _270.d1;
    _275 += u;
    int64_t _276 = _270.data[_275];
    if (_276 >= 0)
    goto _jump948;
    fail_assertion("negative array index");
    _jump948:;
    if (_276 < _261.d0)
    goto _jump949;
    fail_assertion("index too large");
    _jump949:;
    if (_6 >= 0)
    goto _jump950;
    fail_assertion("negative array index");
    _jump950:;
    if (_6 < _261.d1)
    goto _jump951;
    fail_assertion("index too large");
    _jump951:;
    if (u >= 0)
    goto _jump952;
    fail_assertion("negative array index");
    _jump952:;
    if (u < _261.d2)
    goto _jump953;
    fail_assertion("index too large");
    _jump953:;
    int64_t _277 = 0;
    _277 *= _261.d0;
    _277 += _276;
    _277 *= _261.d1;
    _277 += _6;
    _277 *= _261.d2;
    _277 += u;
    rgba _278 = _261.data[_277];
    void_t _279 = w(x, _278, o);
    int64_t _280 = 0;
    _280 *= _258.d0;
    _280 += _260;
    _258.data[_280] = _279;
    _260++;
    if (_260 < m)
    goto _jump936;
    // End body of loop
    _244 = _258;
    _jump934:;
    _a3_int64_t _281;
    // Computing bound for E
    _281.d0 = n;
    if (n > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing bound for F
    _281.d1 = k;
    if (k > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing bound for G
    _281.d2 = z.d0;
    if (z.d0 > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing total size of heap memory to allocate
    int64_t _282 = 1;
    _282 *= n;
    _282 *= k;
    _282 *= z.d0;
    _282 *= sizeof(int64_t);
    _281.data = jpl_alloc(_282);
    int64_t _283 = 0; // G
    int64_t _284 = 0; // F
    int64_t _285 = 0; // E
    _jump957:; // Begin body of loop
    int64_t _286 = 0;
    _286 *= _281.d0;
    _286 += _285;
    _286 *= _281.d1;
    _286 += _284;
    _286 *= _281.d2;
    _286 += _283;
    _281.data[_286] = h;
    _283++;
    if (_283 < z.d0)
    goto _jump957;
    _283 = 0;
    _284++;
    if (_284 < k)
    goto _jump957;
    _284 = 0;
    _285++;
    if (_285 < n)
    goto _jump957;
    // End body of loop
    _a2_bool _287;
    // Computing bound for E
    _287.d0 = d;
    if (d > 0) 
    goto _jump958;
    fail_assertion("non-positive loop bound");
    _jump958:;
    // Computing bound for F
    _287.d1 = n;
    if (n > 0) 
    goto _jump959;
    fail_assertion("non-positive loop bound");
    _jump959:;
    // Computing total size of heap memory to allocate
    int64_t _288 = 1;
    _288 *= d;
    _288 *= n;
    _288 *= sizeof(bool);
    _287.data = jpl_alloc(_288);
    int64_t _289 = 0; // F
    int64_t _290 = 0; // E
    _jump960:; // Begin body of loop
    bool _291 = x.c;
    int64_t _292 = 0;
    _292 *= _287.d0;
    _292 += _290;
    _292 *= _287.d1;
    _292 += _289;
    _287.data[_292] = _291;
    _289++;
    if (_289 < n)
    goto _jump960;
    _289 = 0;
    _290++;
    if (_290 < d)
    goto _jump960;
    // End body of loop
    _a3_bool _293;
    // Computing bound for E
    _293.d0 = z.d0;
    if (z.d0 > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for F
    int64_t _294 = k * k;
    _293.d1 = _294;
    if (_294 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing bound for G
    int64_t _295 = 313;
    int64_t _296 = -_295;
    _293.d2 = _296;
    if (_296 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    // Computing total size of heap memory to allocate
    int64_t _297 = 1;
    _297 *= z.d0;
    _297 *= _294;
    _297 *= _296;
    _297 *= sizeof(bool);
    _293.data = jpl_alloc(_297);
    int64_t _298 = 0; // G
    int64_t _299 = 0; // F
    int64_t _300 = 0; // E
    _jump964:; // Begin body of loop
    bool _301 = z.d0 == n;
    int64_t _302 = 0;
    _302 *= _293.d0;
    _302 += _300;
    _302 *= _293.d1;
    _302 += _299;
    _302 *= _293.d2;
    _302 += _298;
    _293.data[_302] = _301;
    _298++;
    if (_298 < _296)
    goto _jump964;
    _298 = 0;
    _299++;
    if (_299 < _294)
    goto _jump964;
    _299 = 0;
    _300++;
    if (_300 < z.d0)
    goto _jump964;
    // End body of loop
    int64_t _303 = p(_287, _293);
    if (n >= 0)
    goto _jump965;
    fail_assertion("negative array index");
    _jump965:;
    if (n < _281.d0)
    goto _jump966;
    fail_assertion("index too large");
    _jump966:;
    if (c >= 0)
    goto _jump967;
    fail_assertion("negative array index");
    _jump967:;
    if (c < _281.d1)
    goto _jump968;
    fail_assertion("index too large");
    _jump968:;
    if (_303 >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (_303 < _281.d2)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    int64_t _304 = 0;
    _304 *= _281.d0;
    _304 += n;
    _304 *= _281.d1;
    _304 += c;
    _304 *= _281.d2;
    _304 += _303;
    int64_t _305 = _281.data[_304];
    int64_t _306 = _305 + d;
    int64_t _307 = -_306;
    if (_307 >= 0)
    goto _jump971;
    fail_assertion("negative array index");
    _jump971:;
    if (_307 < _244.d0)
    goto _jump972;
    fail_assertion("index too large");
    _jump972:;
    int64_t _308 = 0;
    _308 *= _244.d0;
    _308 += _307;
    void_t _309 = _244.data[_308];
    return _309;
    bool _310 = false;
    int64_t _311;
    // Computing bound for F
    if (_6 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for G
    int64_t _312 = 979;
    if (_312 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    _311 = 0;
    int64_t _313 = 0; // G
    int64_t _314 = 0; // F
    _jump975:; // Begin body of loop
    _311 += _314;
    _313++;
    if (_313 < _312)
    goto _jump975;
    _313 = 0;
    _314++;
    if (_314 < _6)
    goto _jump975;
    // End body of loop
    int64_t _315 = 907;
    bool _316 = _311 < _315;
    bool _317 = !_316;
    bool _318 = _310 != _317;
    _a3__a2_double _319;
    if (!_318)
    goto _jump976;
    _a3__a3__a2_double _320;
    // Computing bound for F
    _320.d0 = k;
    if (k > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing bound for G
    _320.d1 = n;
    if (n > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    // Computing bound for H
    _320.d2 = r;
    if (r > 0) 
    goto _jump979;
    fail_assertion("non-positive loop bound");
    _jump979:;
    // Computing total size of heap memory to allocate
    int64_t _321 = 1;
    _321 *= k;
    _321 *= n;
    _321 *= r;
    _321 *= sizeof(_a3__a2_double);
    _320.data = jpl_alloc(_321);
    int64_t _322 = 0; // H
    int64_t _323 = 0; // G
    int64_t _324 = 0; // F
    _jump980:; // Begin body of loop
    _a3__a2_double _325;
    // Computing bound for I
    int64_t _326 = -m;
    int64_t _327 = _326 * c;
    _325.d0 = _327;
    if (_327 > 0) 
    goto _jump981;
    fail_assertion("non-positive loop bound");
    _jump981:;
    // Computing bound for J
    int64_t _328 = _323 - n;
    if (_328 >= 0)
    goto _jump982;
    fail_assertion("negative array index");
    _jump982:;
    if (_328 < q.d0)
    goto _jump983;
    fail_assertion("index too large");
    _jump983:;
    int64_t _329 = 0;
    _329 *= q.d0;
    _329 += _328;
    int64_t _330 = q.data[_329];
    _325.d1 = _330;
    if (_330 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing bound for K
    _325.d2 = d;
    if (d > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    // Computing total size of heap memory to allocate
    int64_t _331 = 1;
    _331 *= _327;
    _331 *= _330;
    _331 *= d;
    _331 *= sizeof(_a2_double);
    _325.data = jpl_alloc(_331);
    int64_t _332 = 0; // K
    int64_t _333 = 0; // J
    int64_t _334 = 0; // I
    _jump986:; // Begin body of loop
    bool _335 = false;
    _a2_double _336;
    if (!_335)
    goto _jump987;
    _a2_double _337;
    // Computing bound for L
    _337.d0 = _6;
    if (_6 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing bound for M
    _337.d1 = _324;
    if (_324 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing total size of heap memory to allocate
    int64_t _338 = 1;
    _338 *= _6;
    _338 *= _324;
    _338 *= sizeof(double);
    _337.data = jpl_alloc(_338);
    int64_t _339 = 0; // M
    int64_t _340 = 0; // L
    _jump990:; // Begin body of loop
    int64_t _341 = 0;
    _341 *= _337.d0;
    _341 += _340;
    _341 *= _337.d1;
    _341 += _339;
    _337.data[_341] = _100;
    _339++;
    if (_339 < _324)
    goto _jump990;
    _339 = 0;
    _340++;
    if (_340 < _6)
    goto _jump990;
    // End body of loop
    _336 = _337;
    goto _jump991;
    _jump987:;
    _a2_double _342;
    // Computing bound for L
    _342.d0 = z.d1;
    if (z.d1 > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    // Computing bound for M
    _342.d1 = c;
    if (c > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing total size of heap memory to allocate
    int64_t _343 = 1;
    _343 *= z.d1;
    _343 *= c;
    _343 *= sizeof(double);
    _342.data = jpl_alloc(_343);
    int64_t _344 = 0; // M
    int64_t _345 = 0; // L
    _jump994:; // Begin body of loop
    int64_t _346 = 0;
    _346 *= _342.d0;
    _346 += _345;
    _346 *= _342.d1;
    _346 += _344;
    _342.data[_346] = _100;
    _344++;
    if (_344 < c)
    goto _jump994;
    _344 = 0;
    _345++;
    if (_345 < z.d1)
    goto _jump994;
    // End body of loop
    _336 = _342;
    _jump991:;
    int64_t _347 = 0;
    _347 *= _325.d0;
    _347 += _334;
    _347 *= _325.d1;
    _347 += _333;
    _347 *= _325.d2;
    _347 += _332;
    _325.data[_347] = _336;
    _332++;
    if (_332 < d)
    goto _jump986;
    _332 = 0;
    _333++;
    if (_333 < _330)
    goto _jump986;
    _333 = 0;
    _334++;
    if (_334 < _327)
    goto _jump986;
    // End body of loop
    int64_t _348 = 0;
    _348 *= _320.d0;
    _348 += _324;
    _348 *= _320.d1;
    _348 += _323;
    _348 *= _320.d2;
    _348 += _322;
    _320.data[_348] = _325;
    _322++;
    if (_322 < r)
    goto _jump980;
    _322 = 0;
    _323++;
    if (_323 < n)
    goto _jump980;
    _323 = 0;
    _324++;
    if (_324 < k)
    goto _jump980;
    // End body of loop
    int64_t _349 = 997;
    if (m >= 0)
    goto _jump995;
    fail_assertion("negative array index");
    _jump995:;
    if (m < _320.d0)
    goto _jump996;
    fail_assertion("index too large");
    _jump996:;
    if (d >= 0)
    goto _jump997;
    fail_assertion("negative array index");
    _jump997:;
    if (d < _320.d1)
    goto _jump998;
    fail_assertion("index too large");
    _jump998:;
    if (_349 >= 0)
    goto _jump999;
    fail_assertion("negative array index");
    _jump999:;
    if (_349 < _320.d2)
    goto _jump1000;
    fail_assertion("index too large");
    _jump1000:;
    int64_t _350 = 0;
    _350 *= _320.d0;
    _350 += m;
    _350 *= _320.d1;
    _350 += d;
    _350 *= _320.d2;
    _350 += _349;
    _a3__a2_double _351 = _320.data[_350];
    _319 = _351;
    goto _jump1001;
    _jump976:;
    _a3__a2_double _352;
    // Computing bound for F
    _352.d0 = n;
    if (n > 0) 
    goto _jump1002;
    fail_assertion("non-positive loop bound");
    _jump1002:;
    // Computing bound for G
    int64_t _353 = 342;
    _352.d1 = _353;
    if (_353 > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    // Computing bound for H
    _352.d2 = u;
    if (u > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing total size of heap memory to allocate
    int64_t _354 = 1;
    _354 *= n;
    _354 *= _353;
    _354 *= u;
    _354 *= sizeof(_a2_double);
    _352.data = jpl_alloc(_354);
    int64_t _355 = 0; // H
    int64_t _356 = 0; // G
    int64_t _357 = 0; // F
    _jump1005:; // Begin body of loop
    _a3__a2_double _358;
    // Computing bound for I
    _358.d0 = u;
    if (u > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    // Computing bound for J
    _358.d1 = _356;
    if (_356 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for K
    _358.d2 = _355;
    if (_355 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing total size of heap memory to allocate
    int64_t _359 = 1;
    _359 *= u;
    _359 *= _356;
    _359 *= _355;
    _359 *= sizeof(_a2_double);
    _358.data = jpl_alloc(_359);
    int64_t _360 = 0; // K
    int64_t _361 = 0; // J
    int64_t _362 = 0; // I
    _jump1009:; // Begin body of loop
    _a2_double _363;
    // Computing bound for L
    _363.d0 = _6;
    if (_6 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for M
    _363.d1 = _356;
    if (_356 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    // Computing total size of heap memory to allocate
    int64_t _364 = 1;
    _364 *= _6;
    _364 *= _356;
    _364 *= sizeof(double);
    _363.data = jpl_alloc(_364);
    int64_t _365 = 0; // M
    int64_t _366 = 0; // L
    _jump1012:; // Begin body of loop
    double _367 = f / f;
    int64_t _368 = 0;
    _368 *= _363.d0;
    _368 += _366;
    _368 *= _363.d1;
    _368 += _365;
    _363.data[_368] = _367;
    _365++;
    if (_365 < _356)
    goto _jump1012;
    _365 = 0;
    _366++;
    if (_366 < _6)
    goto _jump1012;
    // End body of loop
    int64_t _369 = 0;
    _369 *= _358.d0;
    _369 += _362;
    _369 *= _358.d1;
    _369 += _361;
    _369 *= _358.d2;
    _369 += _360;
    _358.data[_369] = _363;
    _360++;
    if (_360 < _355)
    goto _jump1009;
    _360 = 0;
    _361++;
    if (_361 < _356)
    goto _jump1009;
    _361 = 0;
    _362++;
    if (_362 < u)
    goto _jump1009;
    // End body of loop
    int64_t _370;
    // Computing bound for I
    if (_355 > 0) 
    goto _jump1013;
    fail_assertion("non-positive loop bound");
    _jump1013:;
    // Computing bound for J
    if (u > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing bound for K
    if (r > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    _370 = 0;
    int64_t _371 = 0; // K
    int64_t _372 = 0; // J
    int64_t _373 = 0; // I
    _jump1016:; // Begin body of loop
    _370 += _373;
    _371++;
    if (_371 < r)
    goto _jump1016;
    _371 = 0;
    _372++;
    if (_372 < u)
    goto _jump1016;
    _372 = 0;
    _373++;
    if (_373 < _355)
    goto _jump1016;
    // End body of loop
    int64_t _374 = m - z.d1;
    int64_t _375 = -z.d0;
    int64_t _376 = -_375;
    if (_370 >= 0)
    goto _jump1017;
    fail_assertion("negative array index");
    _jump1017:;
    if (_370 < _358.d0)
    goto _jump1018;
    fail_assertion("index too large");
    _jump1018:;
    if (_374 >= 0)
    goto _jump1019;
    fail_assertion("negative array index");
    _jump1019:;
    if (_374 < _358.d1)
    goto _jump1020;
    fail_assertion("index too large");
    _jump1020:;
    if (_376 >= 0)
    goto _jump1021;
    fail_assertion("negative array index");
    _jump1021:;
    if (_376 < _358.d2)
    goto _jump1022;
    fail_assertion("index too large");
    _jump1022:;
    int64_t _377 = 0;
    _377 *= _358.d0;
    _377 += _370;
    _377 *= _358.d1;
    _377 += _374;
    _377 *= _358.d2;
    _377 += _376;
    _a2_double _378 = _358.data[_377];
    int64_t _379 = 0;
    _379 *= _352.d0;
    _379 += _357;
    _379 *= _352.d1;
    _379 += _356;
    _379 *= _352.d2;
    _379 += _355;
    _352.data[_379] = _378;
    _355++;
    if (_355 < u)
    goto _jump1005;
    _355 = 0;
    _356++;
    if (_356 < _353)
    goto _jump1005;
    _356 = 0;
    _357++;
    if (_357 < n)
    goto _jump1005;
    // End body of loop
    _319 = _352;
    _jump1001:;
    _a3_a _381;
    // Computing bound for F
    _381.d0 = d;
    if (d > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing bound for G
    _381.d1 = n;
    if (n > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing bound for H
    _381.d2 = n;
    if (n > 0) 
    goto _jump1025;
    fail_assertion("non-positive loop bound");
    _jump1025:;
    // Computing total size of heap memory to allocate
    int64_t _382 = 1;
    _382 *= d;
    _382 *= n;
    _382 *= n;
    _382 *= sizeof(a);
    _381.data = jpl_alloc(_382);
    int64_t _383 = 0; // H
    int64_t _384 = 0; // G
    int64_t _385 = 0; // F
    _jump1026:; // Begin body of loop
    int64_t _386 = 0;
    _386 *= _381.d0;
    _386 += _385;
    _386 *= _381.d1;
    _386 += _384;
    _386 *= _381.d2;
    _386 += _383;
    _381.data[_386] = x;
    _383++;
    if (_383 < n)
    goto _jump1026;
    _383 = 0;
    _384++;
    if (_384 < n)
    goto _jump1026;
    _384 = 0;
    _385++;
    if (_385 < d)
    goto _jump1026;
    // End body of loop
    int64_t _387;
    // Computing bound for F
    if (k > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    // Computing bound for G
    if (k > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing bound for H
    if (r > 0) 
    goto _jump1029;
    fail_assertion("non-positive loop bound");
    _jump1029:;
    _387 = 0;
    int64_t _388 = 0; // H
    int64_t _389 = 0; // G
    int64_t _390 = 0; // F
    _jump1030:; // Begin body of loop
    _387 += _390;
    _388++;
    if (_388 < r)
    goto _jump1030;
    _388 = 0;
    _389++;
    if (_389 < k)
    goto _jump1030;
    _389 = 0;
    _390++;
    if (_390 < k)
    goto _jump1030;
    // End body of loop
    if (u >= 0)
    goto _jump1031;
    fail_assertion("negative array index");
    _jump1031:;
    if (u < _381.d0)
    goto _jump1032;
    fail_assertion("index too large");
    _jump1032:;
    if (_6 >= 0)
    goto _jump1033;
    fail_assertion("negative array index");
    _jump1033:;
    if (_6 < _381.d1)
    goto _jump1034;
    fail_assertion("index too large");
    _jump1034:;
    if (_387 >= 0)
    goto _jump1035;
    fail_assertion("negative array index");
    _jump1035:;
    if (_387 < _381.d2)
    goto _jump1036;
    fail_assertion("index too large");
    _jump1036:;
    int64_t _391 = 0;
    _391 *= _381.d0;
    _391 += u;
    _391 *= _381.d1;
    _391 += _6;
    _391 *= _381.d2;
    _391 += _387;
    a _392 = _381.data[_391];
    bool _393 = _392.c;
    bool _394 = !_393;
    bool _380 = _394;
    if (0 == _394)
    goto _jump1037;
    double _395 = 24.0;
    double _396 = -i;
    double _397 = 89.0;
    double _398 = _396 * _397;
    bool _399 = _395 != _398;
    bool _400 = !_399;
    _380 = _400;
    _jump1037:;
    _a2_bool _401;
    if (!_380)
    goto _jump1038;
    int64_t _403 = 542;
    bool _404 = c <= _403;
    bool _402 = _404;
    if (0 != _404)
    goto _jump1039;
    bool _405 = false;
    _402 = _405;
    _jump1039:;
    _a2_bool _406;
    if (!_402)
    goto _jump1040;
    bool _408 = false;
    bool _407 = _408;
    if (0 != _408)
    goto _jump1041;
    bool _409 = false;
    _407 = _409;
    _jump1041:;
    _a1_bool _410;
    _410.d0 = 1;
    _410.data = jpl_alloc(sizeof(bool) * 1);
    _410.data[0] = _407;
    if (u >= 0)
    goto _jump1042;
    fail_assertion("negative array index");
    _jump1042:;
    if (u < _410.d0)
    goto _jump1043;
    fail_assertion("index too large");
    _jump1043:;
    int64_t _411 = 0;
    _411 *= _410.d0;
    _411 += u;
    bool _412 = _410.data[_411];
    _a2_bool _413;
    if (!_412)
    goto _jump1044;
    _a2_bool _414;
    // Computing bound for F
    int64_t _415;
    // Computing bound for F
    if (k > 0) 
    goto _jump1045;
    fail_assertion("non-positive loop bound");
    _jump1045:;
    _415 = 0;
    int64_t _416 = 0; // F
    _jump1046:; // Begin body of loop
    _415 += r;
    _416++;
    if (_416 < k)
    goto _jump1046;
    // End body of loop
    _414.d0 = _415;
    if (_415 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing bound for G
    int64_t _417 = k * k;
    int64_t _418 = -_417;
    _414.d1 = _418;
    if (_418 > 0) 
    goto _jump1048;
    fail_assertion("non-positive loop bound");
    _jump1048:;
    // Computing total size of heap memory to allocate
    int64_t _419 = 1;
    _419 *= _415;
    _419 *= _418;
    _419 *= sizeof(bool);
    _414.data = jpl_alloc(_419);
    int64_t _420 = 0; // G
    int64_t _421 = 0; // F
    _jump1049:; // Begin body of loop
    bool _422 = false;
    int64_t _423 = 0;
    _423 *= _414.d0;
    _423 += _421;
    _423 *= _414.d1;
    _423 += _420;
    _414.data[_423] = _422;
    _420++;
    if (_420 < _418)
    goto _jump1049;
    _420 = 0;
    _421++;
    if (_421 < _415)
    goto _jump1049;
    // End body of loop
    _413 = _414;
    goto _jump1050;
    _jump1044:;
    _a1__a2_bool _424;
    // Computing bound for F
    _424.d0 = r;
    if (r > 0) 
    goto _jump1051;
    fail_assertion("non-positive loop bound");
    _jump1051:;
    // Computing total size of heap memory to allocate
    int64_t _425 = 1;
    _425 *= r;
    _425 *= sizeof(_a2_bool);
    _424.data = jpl_alloc(_425);
    int64_t _426 = 0; // F
    _jump1052:; // Begin body of loop
    _a2_bool _427;
    // Computing bound for G
    _427.d0 = h;
    if (h > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing bound for H
    _427.d1 = r;
    if (r > 0) 
    goto _jump1054;
    fail_assertion("non-positive loop bound");
    _jump1054:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= h;
    _428 *= r;
    _428 *= sizeof(bool);
    _427.data = jpl_alloc(_428);
    int64_t _429 = 0; // H
    int64_t _430 = 0; // G
    _jump1055:; // Begin body of loop
    bool _431 = true;
    int64_t _432 = 0;
    _432 *= _427.d0;
    _432 += _430;
    _432 *= _427.d1;
    _432 += _429;
    _427.data[_432] = _431;
    _429++;
    if (_429 < r)
    goto _jump1055;
    _429 = 0;
    _430++;
    if (_430 < h)
    goto _jump1055;
    // End body of loop
    int64_t _433 = 0;
    _433 *= _424.d0;
    _433 += _426;
    _424.data[_433] = _427;
    _426++;
    if (_426 < r)
    goto _jump1052;
    // End body of loop
    int64_t _434 = -r;
    if (_434 >= 0)
    goto _jump1056;
    fail_assertion("negative array index");
    _jump1056:;
    if (_434 < _424.d0)
    goto _jump1057;
    fail_assertion("index too large");
    _jump1057:;
    int64_t _435 = 0;
    _435 *= _424.d0;
    _435 += _434;
    _a2_bool _436 = _424.data[_435];
    _413 = _436;
    _jump1050:;
    _406 = _413;
    goto _jump1058;
    _jump1040:;
    _a2_bool _437;
    // Computing bound for F
    int64_t _438;
    // Computing bound for F
    _a2_bool _439;
    // Computing bound for F
    int64_t _440 = 757;
    _439.d0 = _440;
    if (_440 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing bound for G
    _439.d1 = d;
    if (d > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing total size of heap memory to allocate
    int64_t _441 = 1;
    _441 *= _440;
    _441 *= d;
    _441 *= sizeof(bool);
    _439.data = jpl_alloc(_441);
    int64_t _442 = 0; // G
    int64_t _443 = 0; // F
    _jump1061:; // Begin body of loop
    bool _444 = true;
    int64_t _445 = 0;
    _445 *= _439.d0;
    _445 += _443;
    _445 *= _439.d1;
    _445 += _442;
    _439.data[_445] = _444;
    _442++;
    if (_442 < d)
    goto _jump1061;
    _442 = 0;
    _443++;
    if (_443 < _440)
    goto _jump1061;
    // End body of loop
    _a3_bool _446;
    // Computing bound for F
    _446.d0 = _6;
    if (_6 > 0) 
    goto _jump1062;
    fail_assertion("non-positive loop bound");
    _jump1062:;
    // Computing bound for G
    _446.d1 = _6;
    if (_6 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for H
    _446.d2 = k;
    if (k > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= _6;
    _447 *= _6;
    _447 *= k;
    _447 *= sizeof(bool);
    _446.data = jpl_alloc(_447);
    int64_t _448 = 0; // H
    int64_t _449 = 0; // G
    int64_t _450 = 0; // F
    _jump1065:; // Begin body of loop
    bool _451 = false;
    int64_t _452 = 0;
    _452 *= _446.d0;
    _452 += _450;
    _452 *= _446.d1;
    _452 += _449;
    _452 *= _446.d2;
    _452 += _448;
    _446.data[_452] = _451;
    _448++;
    if (_448 < k)
    goto _jump1065;
    _448 = 0;
    _449++;
    if (_449 < _6)
    goto _jump1065;
    _449 = 0;
    _450++;
    if (_450 < _6)
    goto _jump1065;
    // End body of loop
    int64_t _453 = p(_439, _446);
    if (_453 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    _438 = 0;
    int64_t _454 = 0; // F
    _jump1067:; // Begin body of loop
    _438 += _454;
    _454++;
    if (_454 < _453)
    goto _jump1067;
    // End body of loop
    _437.d0 = _438;
    if (_438 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing bound for G
    _a3_int64_t _455;
    // Computing bound for F
    _455.d0 = k;
    if (k > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing bound for G
    _455.d1 = k;
    if (k > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing bound for H
    _455.d2 = h;
    if (h > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing total size of heap memory to allocate
    int64_t _456 = 1;
    _456 *= k;
    _456 *= k;
    _456 *= h;
    _456 *= sizeof(int64_t);
    _455.data = jpl_alloc(_456);
    int64_t _457 = 0; // H
    int64_t _458 = 0; // G
    int64_t _459 = 0; // F
    _jump1072:; // Begin body of loop
    int64_t _460 = 0;
    _460 *= _455.d0;
    _460 += _459;
    _460 *= _455.d1;
    _460 += _458;
    _460 *= _455.d2;
    _460 += _457;
    _455.data[_460] = k;
    _457++;
    if (_457 < h)
    goto _jump1072;
    _457 = 0;
    _458++;
    if (_458 < k)
    goto _jump1072;
    _458 = 0;
    _459++;
    if (_459 < k)
    goto _jump1072;
    // End body of loop
    int64_t _461 = z.d0 % c;
    if (r >= 0)
    goto _jump1073;
    fail_assertion("negative array index");
    _jump1073:;
    if (r < _455.d0)
    goto _jump1074;
    fail_assertion("index too large");
    _jump1074:;
    if (_461 >= 0)
    goto _jump1075;
    fail_assertion("negative array index");
    _jump1075:;
    if (_461 < _455.d1)
    goto _jump1076;
    fail_assertion("index too large");
    _jump1076:;
    if (d >= 0)
    goto _jump1077;
    fail_assertion("negative array index");
    _jump1077:;
    if (d < _455.d2)
    goto _jump1078;
    fail_assertion("index too large");
    _jump1078:;
    int64_t _462 = 0;
    _462 *= _455.d0;
    _462 += r;
    _462 *= _455.d1;
    _462 += _461;
    _462 *= _455.d2;
    _462 += d;
    int64_t _463 = _455.data[_462];
    int64_t _464 = -_463;
    _437.d1 = _464;
    if (_464 > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing total size of heap memory to allocate
    int64_t _465 = 1;
    _465 *= _438;
    _465 *= _464;
    _465 *= sizeof(bool);
    _437.data = jpl_alloc(_465);
    int64_t _466 = 0; // G
    int64_t _467 = 0; // F
    _jump1080:; // Begin body of loop
    bool _469 = true;
    bool _470 = !_469;
    bool _471 = !_470;
    bool _468 = _471;
    if (0 != _471)
    goto _jump1081;
    bool _472 = k == h;
    _468 = _472;
    _jump1081:;
    int64_t _473 = 0;
    _473 *= _437.d0;
    _473 += _467;
    _473 *= _437.d1;
    _473 += _466;
    _437.data[_473] = _468;
    _466++;
    if (_466 < _464)
    goto _jump1080;
    _466 = 0;
    _467++;
    if (_467 < _438)
    goto _jump1080;
    // End body of loop
    _406 = _437;
    _jump1058:;
    _401 = _406;
    goto _jump1082;
    _jump1038:;
    _a2_bool _474;
    // Computing bound for F
    _474.d0 = d;
    if (d > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing bound for G
    int64_t _475;
    // Computing bound for F
    if (k > 0) 
    goto _jump1084;
    fail_assertion("non-positive loop bound");
    _jump1084:;
    // Computing bound for G
    if (u > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing bound for H
    int64_t _476 = 177;
    if (_476 > 0) 
    goto _jump1086;
    fail_assertion("non-positive loop bound");
    _jump1086:;
    _475 = 0;
    int64_t _477 = 0; // H
    int64_t _478 = 0; // G
    int64_t _479 = 0; // F
    _jump1087:; // Begin body of loop
    int64_t _480 = m + h;
    _475 += _480;
    _477++;
    if (_477 < _476)
    goto _jump1087;
    _477 = 0;
    _478++;
    if (_478 < u)
    goto _jump1087;
    _478 = 0;
    _479++;
    if (_479 < k)
    goto _jump1087;
    // End body of loop
    _474.d1 = _475;
    if (_475 > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    // Computing total size of heap memory to allocate
    int64_t _481 = 1;
    _481 *= d;
    _481 *= _475;
    _481 *= sizeof(bool);
    _474.data = jpl_alloc(_481);
    int64_t _482 = 0; // G
    int64_t _483 = 0; // F
    _jump1089:; // Begin body of loop
    _a2_bool _484;
    // Computing bound for H
    _484.d0 = h;
    if (h > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    // Computing bound for I
    _484.d1 = m;
    if (m > 0) 
    goto _jump1091;
    fail_assertion("non-positive loop bound");
    _jump1091:;
    // Computing total size of heap memory to allocate
    int64_t _485 = 1;
    _485 *= h;
    _485 *= m;
    _485 *= sizeof(bool);
    _484.data = jpl_alloc(_485);
    int64_t _486 = 0; // I
    int64_t _487 = 0; // H
    _jump1092:; // Begin body of loop
    bool _488 = x.c;
    int64_t _489 = 0;
    _489 *= _484.d0;
    _489 += _487;
    _489 *= _484.d1;
    _489 += _486;
    _484.data[_489] = _488;
    _486++;
    if (_486 < m)
    goto _jump1092;
    _486 = 0;
    _487++;
    if (_487 < h)
    goto _jump1092;
    // End body of loop
    int64_t _490 = -_6;
    if (m >= 0)
    goto _jump1093;
    fail_assertion("negative array index");
    _jump1093:;
    if (m < _484.d0)
    goto _jump1094;
    fail_assertion("index too large");
    _jump1094:;
    if (_490 >= 0)
    goto _jump1095;
    fail_assertion("negative array index");
    _jump1095:;
    if (_490 < _484.d1)
    goto _jump1096;
    fail_assertion("index too large");
    _jump1096:;
    int64_t _491 = 0;
    _491 *= _484.d0;
    _491 += m;
    _491 *= _484.d1;
    _491 += _490;
    bool _492 = _484.data[_491];
    bool _493;
    if (!_492)
    goto _jump1097;
    int64_t _494 = 599;
    bool _495 = c != _494;
    bool _496;
    if (!_495)
    goto _jump1098;
    int64_t _497 = 878;
    int64_t _498 = z.d0 / k;
    bool _499 = _497 < _498;
    _496 = _499;
    goto _jump1099;
    _jump1098:;
    bool _500 = x.a;
    _496 = _500;
    _jump1099:;
    _493 = _496;
    goto _jump1100;
    _jump1097:;
    double _501;
    // Computing bound for H
    if (z.d1 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing bound for I
    if (h > 0) 
    goto _jump1102;
    fail_assertion("non-positive loop bound");
    _jump1102:;
    _501 = 0;
    int64_t _502 = 0; // I
    int64_t _503 = 0; // H
    _jump1103:; // Begin body of loop
    _501 += f;
    _502++;
    if (_502 < h)
    goto _jump1103;
    _502 = 0;
    _503++;
    if (_503 < z.d1)
    goto _jump1103;
    // End body of loop
    bool _504 = i == _501;
    _493 = _504;
    _jump1100:;
    int64_t _505 = 0;
    _505 *= _474.d0;
    _505 += _483;
    _505 *= _474.d1;
    _505 += _482;
    _474.data[_505] = _493;
    _482++;
    if (_482 < _475)
    goto _jump1089;
    _482 = 0;
    _483++;
    if (_483 < d)
    goto _jump1089;
    // End body of loop
    _401 = _474;
    _jump1082:;
    bool _506 = t(_319, _401);
    if (0 != _506)
    goto _jump1104;
    fail_assertion("F");
    _jump1104:;
}

void jpl_main(struct args args) {
    _a2_rgba _0 = read_image("b.png");
    int64_t c = _0.d0;
    int64_t d = _0.d1;
    write_image(_0, "f.png");
    _a2_rgba _1;
    // Computing bound for f
    _1.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for g
    bool _2 = false;
    bool _3 = !_2;
    int64_t _4;
    if (!_3)
    goto _jump253;
    _a1_int64_t _5;
    // Computing bound for f
    _5.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump254;
    fail_assertion("non-positive loop bound");
    _jump254:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _0.d1;
    _6 *= sizeof(int64_t);
    _5.data = jpl_alloc(_6);
    int64_t _7 = 0; // f
    _jump255:; // Begin body of loop
    int64_t _8;
    // Computing bound for g
    int64_t _9 = -_0.d0;
    int64_t _10 = _0.d1 / _9;
    if (_10 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing bound for h
    if (_0.d0 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    _8 = 0;
    int64_t _11 = 0; // h
    int64_t _12 = 0; // g
    _jump258:; // Begin body of loop
    _8 += _12;
    _11++;
    if (_11 < _0.d0)
    goto _jump258;
    _11 = 0;
    _12++;
    if (_12 < _10)
    goto _jump258;
    // End body of loop
    int64_t _13 = 0;
    _13 *= _5.d0;
    _13 += _7;
    _5.data[_13] = _8;
    _7++;
    if (_7 < _0.d1)
    goto _jump255;
    // End body of loop
    int64_t _14 = -_0.d1;
    int64_t _15 = 813;
    int64_t _16 = _0.d1 / _15;
    int64_t _17 = _14 * _16;
    int64_t _18 = -_17;
    if (_18 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_18 < _5.d0)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    int64_t _19 = 0;
    _19 *= _5.d0;
    _19 += _18;
    int64_t _20 = _5.data[_19];
    _4 = _20;
    goto _jump261;
    _jump253:;
    bool _21 = true;
    bool _22;
    if (!_21)
    goto _jump262;
    bool _23 = false;
    bool _24 = !_23;
    bool _25;
    if (!_24)
    goto _jump263;
    bool _26 = true;
    _25 = _26;
    goto _jump264;
    _jump263:;
    bool _27 = false;
    _25 = _27;
    _jump264:;
    _22 = _25;
    goto _jump265;
    _jump262:;
    bool _28 = true;
    _22 = _28;
    _jump265:;
    int64_t _29;
    if (!_22)
    goto _jump266;
    int64_t _30;
    // Computing bound for f
    _a2_int64_t _31;
    // Computing bound for f
    _31.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump267;
    fail_assertion("non-positive loop bound");
    _jump267:;
    // Computing bound for g
    int64_t _32 = 102;
    _31.d1 = _32;
    if (_32 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing total size of heap memory to allocate
    int64_t _33 = 1;
    _33 *= _0.d0;
    _33 *= _32;
    _33 *= sizeof(int64_t);
    _31.data = jpl_alloc(_33);
    int64_t _34 = 0; // g
    int64_t _35 = 0; // f
    _jump269:; // Begin body of loop
    int64_t _36 = 0;
    _36 *= _31.d0;
    _36 += _35;
    _36 *= _31.d1;
    _36 += _34;
    _31.data[_36] = _35;
    _34++;
    if (_34 < _32)
    goto _jump269;
    _34 = 0;
    _35++;
    if (_35 < _0.d0)
    goto _jump269;
    // End body of loop
    bool _37 = false;
    int64_t _38;
    if (!_37)
    goto _jump270;
    int64_t _39 = 475;
    _38 = _39;
    goto _jump271;
    _jump270:;
    int64_t _40 = 86;
    _38 = _40;
    _jump271:;
    if (_0.d1 >= 0)
    goto _jump272;
    fail_assertion("negative array index");
    _jump272:;
    if (_0.d1 < _31.d0)
    goto _jump273;
    fail_assertion("index too large");
    _jump273:;
    if (_38 >= 0)
    goto _jump274;
    fail_assertion("negative array index");
    _jump274:;
    if (_38 < _31.d1)
    goto _jump275;
    fail_assertion("index too large");
    _jump275:;
    int64_t _41 = 0;
    _41 *= _31.d0;
    _41 += _0.d1;
    _41 *= _31.d1;
    _41 += _38;
    int64_t _42 = _31.data[_41];
    if (_42 > 0) 
    goto _jump276;
    fail_assertion("non-positive loop bound");
    _jump276:;
    _30 = 0;
    int64_t _43 = 0; // f
    _jump277:; // Begin body of loop
    _30 += _0.d1;
    _43++;
    if (_43 < _42)
    goto _jump277;
    // End body of loop
    _29 = _30;
    goto _jump278;
    _jump266:;
    int64_t _44;
    // Computing bound for f
    int64_t _45 = 685;
    if (_45 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing bound for g
    if (_0.d0 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    _44 = 0;
    int64_t _46 = 0; // g
    int64_t _47 = 0; // f
    _jump281:; // Begin body of loop
    _44 += _0.d1;
    _46++;
    if (_46 < _0.d0)
    goto _jump281;
    _46 = 0;
    _47++;
    if (_47 < _45)
    goto _jump281;
    // End body of loop
    int64_t _48 = 258;
    int64_t _49 = _44 % _48;
    int64_t _50 = -_49;
    _29 = _50;
    _jump278:;
    int64_t _51;
    // Computing bound for f
    int64_t _52;
    // Computing bound for f
    int64_t _53 = 664;
    int64_t _54 = -_53;
    if (_54 > 0) 
    goto _jump282;
    fail_assertion("non-positive loop bound");
    _jump282:;
    // Computing bound for g
    int64_t _55 = 961;
    int64_t _56 = _55 * _0.d1;
    if (_56 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    // Computing bound for h
    if (_0.d0 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    _52 = 0;
    int64_t _57 = 0; // h
    int64_t _58 = 0; // g
    int64_t _59 = 0; // f
    _jump285:; // Begin body of loop
    int64_t _60 = 412;
    int64_t _61 = -_60;
    _52 += _61;
    _57++;
    if (_57 < _0.d0)
    goto _jump285;
    _57 = 0;
    _58++;
    if (_58 < _56)
    goto _jump285;
    _58 = 0;
    _59++;
    if (_59 < _54)
    goto _jump285;
    // End body of loop
    if (_52 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing bound for g
    int64_t _62 = 279;
    if (_62 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    _51 = 0;
    int64_t _63 = 0; // g
    int64_t _64 = 0; // f
    _jump288:; // Begin body of loop
    int64_t _65 = 799;
    _51 += _65;
    _63++;
    if (_63 < _62)
    goto _jump288;
    _63 = 0;
    _64++;
    if (_64 < _52)
    goto _jump288;
    // End body of loop
    int64_t _66 = -_51;
    int64_t _67 = _29 + _66;
    _4 = _67;
    _jump261:;
    _1.d1 = _4;
    if (_4 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    // Computing total size of heap memory to allocate
    int64_t _68 = 1;
    _68 *= _0.d0;
    _68 *= _4;
    _68 *= sizeof(rgba);
    _1.data = jpl_alloc(_68);
    int64_t _69 = 0; // g
    int64_t _70 = 0; // f
    _jump290:; // Begin body of loop
    bool _72 = true;
    bool _71 = _72;
    if (0 == _72)
    goto _jump291;
    bool _73 = false;
    bool _74 = !_73;
    _71 = _74;
    _jump291:;
    double _75 = 2.0;
    double _76 = -_75;
    _a2_bool _77;
    // Computing bound for h
    _77.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing bound for i
    _77.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= _0.d0;
    _78 *= _0.d0;
    _78 *= sizeof(bool);
    _77.data = jpl_alloc(_78);
    int64_t _79 = 0; // i
    int64_t _80 = 0; // h
    _jump294:; // Begin body of loop
    bool _81 = true;
    int64_t _82 = 0;
    _82 *= _77.d0;
    _82 += _80;
    _82 *= _77.d1;
    _82 += _79;
    _77.data[_82] = _81;
    _79++;
    if (_79 < _0.d0)
    goto _jump294;
    _79 = 0;
    _80++;
    if (_80 < _0.d0)
    goto _jump294;
    // End body of loop
    int64_t _83 = 470;
    int64_t _84 = _70 - _83;
    if (_0.d0 >= 0)
    goto _jump295;
    fail_assertion("negative array index");
    _jump295:;
    if (_0.d0 < _77.d0)
    goto _jump296;
    fail_assertion("index too large");
    _jump296:;
    if (_84 >= 0)
    goto _jump297;
    fail_assertion("negative array index");
    _jump297:;
    if (_84 < _77.d1)
    goto _jump298;
    fail_assertion("index too large");
    _jump298:;
    int64_t _85 = 0;
    _85 *= _77.d0;
    _85 += _0.d0;
    _85 *= _77.d1;
    _85 += _84;
    bool _86 = _77.data[_85];
    a _87 = { _71, _76, _86 };
    double _88 = _87.b;
    _a1_double _89;
    // Computing bound for h
    int64_t _90 = 271;
    _89.d0 = _90;
    if (_90 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= _90;
    _91 *= sizeof(double);
    _89.data = jpl_alloc(_91);
    int64_t _92 = 0; // h
    _jump300:; // Begin body of loop
    double _93 = 63.0;
    int64_t _94 = 0;
    _94 *= _89.d0;
    _94 += _92;
    _89.data[_94] = _93;
    _92++;
    if (_92 < _90)
    goto _jump300;
    // End body of loop
    int64_t _95 = 478;
    if (_95 >= 0)
    goto _jump301;
    fail_assertion("negative array index");
    _jump301:;
    if (_95 < _89.d0)
    goto _jump302;
    fail_assertion("index too large");
    _jump302:;
    int64_t _96 = 0;
    _96 *= _89.d0;
    _96 += _95;
    double _97 = _89.data[_96];
    _a2_double _98;
    // Computing bound for h
    int64_t _99 = 332;
    _98.d0 = _99;
    if (_99 > 0) 
    goto _jump303;
    fail_assertion("non-positive loop bound");
    _jump303:;
    // Computing bound for i
    int64_t _100 = 579;
    _98.d1 = _100;
    if (_100 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _99;
    _101 *= _100;
    _101 *= sizeof(double);
    _98.data = jpl_alloc(_101);
    int64_t _102 = 0; // i
    int64_t _103 = 0; // h
    _jump305:; // Begin body of loop
    double _104 = 97.0;
    double _105 = 37.0;
    double _106 = 7.0;
    double _107 = -_106;
    double _108 = _105 / _107;
    double _109 = _104 * _108;
    int64_t _110 = 0;
    _110 *= _98.d0;
    _110 += _103;
    _110 *= _98.d1;
    _110 += _102;
    _98.data[_110] = _109;
    _102++;
    if (_102 < _100)
    goto _jump305;
    _102 = 0;
    _103++;
    if (_103 < _99)
    goto _jump305;
    // End body of loop
    int64_t _111;
    // Computing bound for h
    int64_t _112 = -_0.d0;
    if (_112 > 0) 
    goto _jump306;
    fail_assertion("non-positive loop bound");
    _jump306:;
    // Computing bound for i
    if (_0.d1 > 0) 
    goto _jump307;
    fail_assertion("non-positive loop bound");
    _jump307:;
    _111 = 0;
    int64_t _113 = 0; // i
    int64_t _114 = 0; // h
    _jump308:; // Begin body of loop
    _111 += _0.d0;
    _113++;
    if (_113 < _0.d1)
    goto _jump308;
    _113 = 0;
    _114++;
    if (_114 < _112)
    goto _jump308;
    // End body of loop
    int64_t _115 = -_111;
    if (_70 >= 0)
    goto _jump309;
    fail_assertion("negative array index");
    _jump309:;
    if (_70 < _98.d0)
    goto _jump310;
    fail_assertion("index too large");
    _jump310:;
    if (_115 >= 0)
    goto _jump311;
    fail_assertion("negative array index");
    _jump311:;
    if (_115 < _98.d1)
    goto _jump312;
    fail_assertion("index too large");
    _jump312:;
    int64_t _116 = 0;
    _116 *= _98.d0;
    _116 += _70;
    _116 *= _98.d1;
    _116 += _115;
    double _117 = _98.data[_116];
    double _118;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for i
    int64_t _119;
    // Computing bound for h
    int64_t _120 = 764;
    if (_120 > 0) 
    goto _jump314;
    fail_assertion("non-positive loop bound");
    _jump314:;
    // Computing bound for i
    int64_t _121 = 508;
    if (_121 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    // Computing bound for j
    if (_0.d0 > 0) 
    goto _jump316;
    fail_assertion("non-positive loop bound");
    _jump316:;
    _119 = 0;
    int64_t _122 = 0; // j
    int64_t _123 = 0; // i
    int64_t _124 = 0; // h
    _jump317:; // Begin body of loop
    int64_t _125 = 454;
    _119 += _125;
    _122++;
    if (_122 < _0.d0)
    goto _jump317;
    _122 = 0;
    _123++;
    if (_123 < _121)
    goto _jump317;
    _123 = 0;
    _124++;
    if (_124 < _120)
    goto _jump317;
    // End body of loop
    int64_t _126 = _70 % _119;
    if (_126 > 0) 
    goto _jump318;
    fail_assertion("non-positive loop bound");
    _jump318:;
    // Computing bound for j
    int64_t _127 = 546;
    if (_127 > 0) 
    goto _jump319;
    fail_assertion("non-positive loop bound");
    _jump319:;
    _118 = 0;
    int64_t _128 = 0; // j
    int64_t _129 = 0; // i
    int64_t _130 = 0; // h
    _jump320:; // Begin body of loop
    double _131 = 41.0;
    double _132 = -_131;
    _118 += _132;
    _128++;
    if (_128 < _127)
    goto _jump320;
    _128 = 0;
    _129++;
    if (_129 < _126)
    goto _jump320;
    _129 = 0;
    _130++;
    if (_130 < _0.d1)
    goto _jump320;
    // End body of loop
    double _133;
    // Computing bound for h
    if (_69 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing bound for i
    int64_t _134 = 949;
    if (_134 > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    _133 = 0;
    int64_t _135 = 0; // i
    int64_t _136 = 0; // h
    _jump323:; // Begin body of loop
    if (_136 >= 0)
    goto _jump324;
    fail_assertion("negative array index");
    _jump324:;
    if (_136 < _0.d0)
    goto _jump325;
    fail_assertion("index too large");
    _jump325:;
    if (_70 >= 0)
    goto _jump326;
    fail_assertion("negative array index");
    _jump326:;
    if (_70 < _0.d1)
    goto _jump327;
    fail_assertion("index too large");
    _jump327:;
    int64_t _137 = 0;
    _137 *= _0.d0;
    _137 += _136;
    _137 *= _0.d1;
    _137 += _70;
    rgba _138 = _0.data[_137];
    double _139 = _138.b;
    _133 += _139;
    _135++;
    if (_135 < _134)
    goto _jump323;
    _135 = 0;
    _136++;
    if (_136 < _69)
    goto _jump323;
    // End body of loop
    bool _140 = _118 > _133;
    double _141;
    if (!_140)
    goto _jump328;
    int64_t _142 = _69 * _0.d0;
    int64_t _143;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for i
    if (_0.d1 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    _143 = 0;
    int64_t _144 = 0; // i
    int64_t _145 = 0; // h
    _jump331:; // Begin body of loop
    _143 += _144;
    _144++;
    if (_144 < _0.d1)
    goto _jump331;
    _144 = 0;
    _145++;
    if (_145 < _0.d1)
    goto _jump331;
    // End body of loop
    bool _146 = _142 != _143;
    a _147;
    if (!_146)
    goto _jump332;
    bool _148 = false;
    double _149 = 42.0;
    double _150 = -_149;
    bool _151 = true;
    a _152 = { _148, _150, _151 };
    _147 = _152;
    goto _jump333;
    _jump332:;
    int64_t _153 = 902;
    bool _154 = _69 != _153;
    double _155;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    // Computing bound for i
    if (_70 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    _155 = 0;
    int64_t _156 = 0; // i
    int64_t _157 = 0; // h
    _jump336:; // Begin body of loop
    double _158 = 62.0;
    _155 += _158;
    _156++;
    if (_156 < _70)
    goto _jump336;
    _156 = 0;
    _157++;
    if (_157 < _0.d1)
    goto _jump336;
    // End body of loop
    bool _160 = false;
    bool _159 = _160;
    if (0 != _160)
    goto _jump337;
    bool _161 = false;
    _159 = _161;
    _jump337:;
    a _162 = { _154, _155, _159 };
    _147 = _162;
    _jump333:;
    double _163 = _147.b;
    _141 = _163;
    goto _jump338;
    _jump328:;
    double _164 = 47.0;
    double _165 = -_164;
    double _166 = -_165;
    _141 = _166;
    _jump338:;
    rgba _167 = { _88, _97, _117, _141 };
    int64_t _168 = 0;
    _168 *= _1.d0;
    _168 += _70;
    _168 *= _1.d1;
    _168 += _69;
    _1.data[_168] = _167;
    _69++;
    if (_69 < _4)
    goto _jump290;
    _69 = 0;
    _70++;
    if (_70 < _0.d0)
    goto _jump290;
    // End body of loop
    write_image(_1, "f.png");
    _a3_rgba _169;
    // Computing bound for f
    int64_t _170 = 116;
    int64_t _171 = -_170;
    int64_t _172 = -_171;
    int64_t _173;
    // Computing bound for f
    int64_t _174 = 969;
    if (_174 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    _173 = 0;
    int64_t _175 = 0; // f
    _jump340:; // Begin body of loop
    int64_t _176 = -_0.d0;
    _173 += _176;
    _175++;
    if (_175 < _174)
    goto _jump340;
    // End body of loop
    int64_t _177 = _172 / _173;
    _169.d0 = _177;
    if (_177 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    // Computing bound for g
    int64_t _178;
    // Computing bound for f
    if (_0.d0 > 0) 
    goto _jump342;
    fail_assertion("non-positive loop bound");
    _jump342:;
    // Computing bound for g
    int64_t _179 = 793;
    int64_t _180 = 704;
    bool _181 = _179 == _180;
    int64_t _182;
    if (!_181)
    goto _jump343;
    int64_t _183 = 336;
    _182 = _183;
    goto _jump344;
    _jump343:;
    _182 = _0.d0;
    _jump344:;
    int64_t _184 = -_182;
    if (_184 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    _178 = 0;
    int64_t _185 = 0; // g
    int64_t _186 = 0; // f
    _jump346:; // Begin body of loop
    int64_t _187 = 494;
    _178 += _187;
    _185++;
    if (_185 < _184)
    goto _jump346;
    _185 = 0;
    _186++;
    if (_186 < _0.d0)
    goto _jump346;
    // End body of loop
    _169.d1 = _178;
    if (_178 > 0) 
    goto _jump347;
    fail_assertion("non-positive loop bound");
    _jump347:;
    // Computing bound for h
    _a3_int64_t _188;
    // Computing bound for f
    bool _189 = _0.d0 > _0.d0;
    int64_t _190;
    if (!_189)
    goto _jump348;
    int64_t _191 = -_0.d0;
    _190 = _191;
    goto _jump349;
    _jump348:;
    _190 = _0.d1;
    _jump349:;
    _188.d0 = _190;
    if (_190 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for g
    _188.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing bound for h
    int64_t _192;
    // Computing bound for f
    int64_t _193 = 992;
    int64_t _194 = -_193;
    if (_194 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    // Computing bound for g
    int64_t _195 = -_0.d1;
    if (_195 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    _192 = 0;
    int64_t _196 = 0; // g
    int64_t _197 = 0; // f
    _jump354:; // Begin body of loop
    _192 += _197;
    _196++;
    if (_196 < _195)
    goto _jump354;
    _196 = 0;
    _197++;
    if (_197 < _194)
    goto _jump354;
    // End body of loop
    _188.d2 = _192;
    if (_192 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing total size of heap memory to allocate
    int64_t _198 = 1;
    _198 *= _190;
    _198 *= _0.d0;
    _198 *= _192;
    _198 *= sizeof(int64_t);
    _188.data = jpl_alloc(_198);
    int64_t _199 = 0; // h
    int64_t _200 = 0; // g
    int64_t _201 = 0; // f
    _jump356:; // Begin body of loop
    int64_t _202;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    _202 = 0;
    int64_t _203 = 0; // i
    _jump358:; // Begin body of loop
    _202 += _201;
    _203++;
    if (_203 < _0.d0)
    goto _jump358;
    // End body of loop
    int64_t _204 = 0;
    _204 *= _188.d0;
    _204 += _201;
    _204 *= _188.d1;
    _204 += _200;
    _204 *= _188.d2;
    _204 += _199;
    _188.data[_204] = _202;
    _199++;
    if (_199 < _192)
    goto _jump356;
    _199 = 0;
    _200++;
    if (_200 < _0.d0)
    goto _jump356;
    _200 = 0;
    _201++;
    if (_201 < _190)
    goto _jump356;
    // End body of loop
    int64_t _205;
    // Computing bound for f
    if (_0.d0 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    _205 = 0;
    int64_t _206 = 0; // f
    _jump360:; // Begin body of loop
    int64_t _207 = 251;
    _205 += _207;
    _206++;
    if (_206 < _0.d0)
    goto _jump360;
    // End body of loop
    int64_t _208;
    // Computing bound for f
    int64_t _209;
    // Computing bound for f
    if (_0.d1 > 0) 
    goto _jump361;
    fail_assertion("non-positive loop bound");
    _jump361:;
    _209 = 0;
    int64_t _210 = 0; // f
    _jump362:; // Begin body of loop
    _209 += _0.d0;
    _210++;
    if (_210 < _0.d1)
    goto _jump362;
    // End body of loop
    int64_t _211 = -_209;
    if (_211 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    _208 = 0;
    int64_t _212 = 0; // f
    _jump364:; // Begin body of loop
    _208 += _0.d0;
    _212++;
    if (_212 < _211)
    goto _jump364;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump365;
    fail_assertion("negative array index");
    _jump365:;
    if (_0.d1 < _188.d0)
    goto _jump366;
    fail_assertion("index too large");
    _jump366:;
    if (_205 >= 0)
    goto _jump367;
    fail_assertion("negative array index");
    _jump367:;
    if (_205 < _188.d1)
    goto _jump368;
    fail_assertion("index too large");
    _jump368:;
    if (_208 >= 0)
    goto _jump369;
    fail_assertion("negative array index");
    _jump369:;
    if (_208 < _188.d2)
    goto _jump370;
    fail_assertion("index too large");
    _jump370:;
    int64_t _213 = 0;
    _213 *= _188.d0;
    _213 += _0.d1;
    _213 *= _188.d1;
    _213 += _205;
    _213 *= _188.d2;
    _213 += _208;
    int64_t _214 = _188.data[_213];
    _169.d2 = _214;
    if (_214 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing total size of heap memory to allocate
    int64_t _215 = 1;
    _215 *= _177;
    _215 *= _178;
    _215 *= _214;
    _215 *= sizeof(rgba);
    _169.data = jpl_alloc(_215);
    int64_t _216 = 0; // h
    int64_t _217 = 0; // g
    int64_t _218 = 0; // f
    _jump372:; // Begin body of loop
    bool _219 = false;
    rgba _220;
    if (!_219)
    goto _jump373;
    bool _221 = _217 < _0.d1;
    double _222;
    if (!_221)
    goto _jump374;
    double _223 = 93.0;
    _222 = _223;
    goto _jump375;
    _jump374:;
    double _224;
    // Computing bound for i
    if (_217 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    // Computing bound for k
    if (_217 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    _224 = 0;
    int64_t _225 = 0; // k
    int64_t _226 = 0; // j
    int64_t _227 = 0; // i
    _jump379:; // Begin body of loop
    double _228 = 9.0;
    _224 += _228;
    _225++;
    if (_225 < _217)
    goto _jump379;
    _225 = 0;
    _226++;
    if (_226 < _0.d1)
    goto _jump379;
    _226 = 0;
    _227++;
    if (_227 < _217)
    goto _jump379;
    // End body of loop
    _222 = _224;
    _jump375:;
    double _229 = 14.0;
    double _230 = 34.0;
    double _231;
    // Computing bound for i
    if (_217 > 0) 
    goto _jump380;
    fail_assertion("non-positive loop bound");
    _jump380:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing bound for k
    int64_t _232 = 245;
    if (_232 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    _231 = 0;
    int64_t _233 = 0; // k
    int64_t _234 = 0; // j
    int64_t _235 = 0; // i
    _jump383:; // Begin body of loop
    double _236 = 53.0;
    double _237 = -_236;
    _231 += _237;
    _233++;
    if (_233 < _232)
    goto _jump383;
    _233 = 0;
    _234++;
    if (_234 < _0.d1)
    goto _jump383;
    _234 = 0;
    _235++;
    if (_235 < _217)
    goto _jump383;
    // End body of loop
    rgba _238 = { _222, _229, _230, _231 };
    _220 = _238;
    goto _jump384;
    _jump373:;
    if (_218 >= 0)
    goto _jump385;
    fail_assertion("negative array index");
    _jump385:;
    if (_218 < _0.d0)
    goto _jump386;
    fail_assertion("index too large");
    _jump386:;
    if (_0.d1 >= 0)
    goto _jump387;
    fail_assertion("negative array index");
    _jump387:;
    if (_0.d1 < _0.d1)
    goto _jump388;
    fail_assertion("index too large");
    _jump388:;
    int64_t _239 = 0;
    _239 *= _0.d0;
    _239 += _218;
    _239 *= _0.d1;
    _239 += _0.d1;
    rgba _240 = _0.data[_239];
    _a1_rgba _241;
    _241.d0 = 1;
    _241.data = jpl_alloc(sizeof(rgba) * 1);
    _241.data[0] = _240;
    int64_t _242 = 828;
    int64_t _243 = _242 / _218;
    int64_t _244 = -_243;
    if (_244 >= 0)
    goto _jump389;
    fail_assertion("negative array index");
    _jump389:;
    if (_244 < _241.d0)
    goto _jump390;
    fail_assertion("index too large");
    _jump390:;
    int64_t _245 = 0;
    _245 *= _241.d0;
    _245 += _244;
    rgba _246 = _241.data[_245];
    _220 = _246;
    _jump384:;
    int64_t _247 = 0;
    _247 *= _169.d0;
    _247 += _218;
    _247 *= _169.d1;
    _247 += _217;
    _247 *= _169.d2;
    _247 += _216;
    _169.data[_247] = _220;
    _216++;
    if (_216 < _214)
    goto _jump372;
    _216 = 0;
    _217++;
    if (_217 < _178)
    goto _jump372;
    _217 = 0;
    _218++;
    if (_218 < _177)
    goto _jump372;
    // End body of loop
    int64_t _248 = _0.d0 - _0.d1;
    int64_t _249 = 292;
    int64_t _250 = -_249;
    if (_0.d0 >= 0)
    goto _jump391;
    fail_assertion("negative array index");
    _jump391:;
    if (_0.d0 < _169.d0)
    goto _jump392;
    fail_assertion("index too large");
    _jump392:;
    if (_248 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_248 < _169.d1)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    if (_250 >= 0)
    goto _jump395;
    fail_assertion("negative array index");
    _jump395:;
    if (_250 < _169.d2)
    goto _jump396;
    fail_assertion("index too large");
    _jump396:;
    int64_t _251 = 0;
    _251 *= _169.d0;
    _251 += _0.d0;
    _251 *= _169.d1;
    _251 += _248;
    _251 *= _169.d2;
    _251 += _250;
    rgba _252 = _169.data[_251];
    double _253 = _252.b;
    _a1_int64_t _254;
    // Computing bound for g
    _254.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing total size of heap memory to allocate
    int64_t _255 = 1;
    _255 *= _0.d0;
    _255 *= sizeof(int64_t);
    _254.data = jpl_alloc(_255);
    int64_t _256 = 0; // g
    _jump398:; // Begin body of loop
    int64_t _257 = 132;
    int64_t _258 = 0;
    _258 *= _254.d0;
    _258 += _256;
    _254.data[_258] = _257;
    _256++;
    if (_256 < _0.d0)
    goto _jump398;
    // End body of loop
    int64_t _259 = -_0.d0;
    if (_259 >= 0)
    goto _jump399;
    fail_assertion("negative array index");
    _jump399:;
    if (_259 < _254.d0)
    goto _jump400;
    fail_assertion("index too large");
    _jump400:;
    int64_t _260 = 0;
    _260 *= _254.d0;
    _260 += _259;
    int64_t _261 = _254.data[_260];
    int64_t _262 = _261 + _0.d0;
    int64_t _263 = 109;
    bool _264 = _262 >= _263;
    bool _265 = !_264;
    bool _266 = !_265;
    _a1_int64_t _267;
    if (!_266)
    goto _jump401;
    int64_t _268 = _0.d1 * _0.d1;
    int64_t _269 = -_268;
    int64_t _270 = 573;
    _a1_int64_t _271;
    _271.d0 = 2;
    _271.data = jpl_alloc(sizeof(int64_t) * 2);
    _271.data[0] = _269;
    _271.data[1] = _270;
    _267 = _271;
    goto _jump402;
    _jump401:;
    double _272 = 87.0;
    double _273 = 21.0;
    double _274 = -_273;
    bool _275 = _272 >= _274;
    bool _276 = !_275;
    _a1_int64_t _277;
    if (!_276)
    goto _jump403;
    int64_t _278 = 465;
    int64_t _279 = 635;
    bool _280 = _278 > _279;
    _a1_int64_t _281;
    if (!_280)
    goto _jump404;
    bool _282 = true;
    bool _283;
    if (!_282)
    goto _jump405;
    double _284 = 37.0;
    bool _285 = _253 != _284;
    bool _286;
    if (!_285)
    goto _jump406;
    bool _287 = true;
    _286 = _287;
    goto _jump407;
    _jump406:;
    bool _288 = true;
    _286 = _288;
    _jump407:;
    _283 = _286;
    goto _jump408;
    _jump405:;
    double _289 = 20.0;
    double _290 = 69.0;
    bool _291 = _289 < _290;
    _283 = _291;
    _jump408:;
    _a1_int64_t _292;
    if (!_283)
    goto _jump409;
    bool _293 = true;
    bool _294;
    if (!_293)
    goto _jump410;
    bool _296 = false;
    bool _295 = _296;
    if (0 == _296)
    goto _jump411;
    bool _297 = false;
    _295 = _297;
    _jump411:;
    _294 = _295;
    goto _jump412;
    _jump410:;
    bool _298 = false;
    bool _299 = !_298;
    _294 = _299;
    _jump412:;
    _a1_int64_t _300;
    if (!_294)
    goto _jump413;
    double _301 = 98.0;
    double _302 = 63.0;
    bool _303 = _301 == _302;
    _a1_int64_t _304;
    if (!_303)
    goto _jump414;
    _a1_int64_t _305;
    // Computing bound for g
    _305.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump415;
    fail_assertion("non-positive loop bound");
    _jump415:;
    // Computing total size of heap memory to allocate
    int64_t _306 = 1;
    _306 *= _0.d1;
    _306 *= sizeof(int64_t);
    _305.data = jpl_alloc(_306);
    int64_t _307 = 0; // g
    _jump416:; // Begin body of loop
    int64_t _308 = 0;
    _308 *= _305.d0;
    _308 += _307;
    _305.data[_308] = _307;
    _307++;
    if (_307 < _0.d1)
    goto _jump416;
    // End body of loop
    _304 = _305;
    goto _jump417;
    _jump414:;
    _a1_int64_t _309;
    // Computing bound for g
    int64_t _310 = 617;
    _309.d0 = _310;
    if (_310 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing total size of heap memory to allocate
    int64_t _311 = 1;
    _311 *= _310;
    _311 *= sizeof(int64_t);
    _309.data = jpl_alloc(_311);
    int64_t _312 = 0; // g
    _jump419:; // Begin body of loop
    int64_t _313 = 789;
    int64_t _314 = 0;
    _314 *= _309.d0;
    _314 += _312;
    _309.data[_314] = _313;
    _312++;
    if (_312 < _310)
    goto _jump419;
    // End body of loop
    _304 = _309;
    _jump417:;
    _300 = _304;
    goto _jump420;
    _jump413:;
    _a1_int64_t _315;
    // Computing bound for g
    int64_t _316 = 919;
    _315.d0 = _316;
    if (_316 > 0) 
    goto _jump421;
    fail_assertion("non-positive loop bound");
    _jump421:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= _316;
    _317 *= sizeof(int64_t);
    _315.data = jpl_alloc(_317);
    int64_t _318 = 0; // g
    _jump422:; // Begin body of loop
    int64_t _319 = 0;
    _319 *= _315.d0;
    _319 += _318;
    _315.data[_319] = _0.d1;
    _318++;
    if (_318 < _316)
    goto _jump422;
    // End body of loop
    _300 = _315;
    _jump420:;
    _292 = _300;
    goto _jump423;
    _jump409:;
    int64_t _320 = -_0.d1;
    bool _321 = _0.d1 > _320;
    _a1_int64_t _322;
    if (!_321)
    goto _jump424;
    _a1_int64_t _323;
    // Computing bound for g
    int64_t _324 = -_0.d0;
    _323.d0 = _324;
    if (_324 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= _324;
    _325 *= sizeof(int64_t);
    _323.data = jpl_alloc(_325);
    int64_t _326 = 0; // g
    _jump426:; // Begin body of loop
    int64_t _327 = 0;
    _327 *= _323.d0;
    _327 += _326;
    _323.data[_327] = _326;
    _326++;
    if (_326 < _324)
    goto _jump426;
    // End body of loop
    _322 = _323;
    goto _jump427;
    _jump424:;
    bool _328 = true;
    _a1_int64_t _329;
    if (!_328)
    goto _jump428;
    int64_t _330 = 261;
    _a1_int64_t _331;
    _331.d0 = 1;
    _331.data = jpl_alloc(sizeof(int64_t) * 1);
    _331.data[0] = _330;
    _329 = _331;
    goto _jump429;
    _jump428:;
    _a1_int64_t _332;
    // Computing bound for g
    _332.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing total size of heap memory to allocate
    int64_t _333 = 1;
    _333 *= _0.d1;
    _333 *= sizeof(int64_t);
    _332.data = jpl_alloc(_333);
    int64_t _334 = 0; // g
    _jump431:; // Begin body of loop
    int64_t _335 = 0;
    _335 *= _332.d0;
    _335 += _334;
    _332.data[_335] = _334;
    _334++;
    if (_334 < _0.d1)
    goto _jump431;
    // End body of loop
    _329 = _332;
    _jump429:;
    _322 = _329;
    _jump427:;
    _292 = _322;
    _jump423:;
    _281 = _292;
    goto _jump432;
    _jump404:;
    int64_t _336 = -_0.d0;
    int64_t _337 = 330;
    bool _338 = _336 >= _337;
    bool _339;
    if (!_338)
    goto _jump433;
    bool _341 = false;
    bool _340 = _341;
    if (0 == _341)
    goto _jump434;
    int64_t _342 = 968;
    int64_t _343 = 995;
    bool _344 = _342 <= _343;
    _340 = _344;
    _jump434:;
    _339 = _340;
    goto _jump435;
    _jump433:;
    bool _345 = false;
    _339 = _345;
    _jump435:;
    _a1_int64_t _346;
    if (!_339)
    goto _jump436;
    _a1_int64_t _347;
    // Computing bound for g
    int64_t _348 = -_0.d0;
    int64_t _349 = -_0.d0;
    int64_t _350 = _348 - _349;
    _347.d0 = _350;
    if (_350 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _351 = 1;
    _351 *= _350;
    _351 *= sizeof(int64_t);
    _347.data = jpl_alloc(_351);
    int64_t _352 = 0; // g
    _jump438:; // Begin body of loop
    int64_t _353 = 952;
    int64_t _354 = 0;
    _354 *= _347.d0;
    _354 += _352;
    _347.data[_354] = _353;
    _352++;
    if (_352 < _350)
    goto _jump438;
    // End body of loop
    _346 = _347;
    goto _jump439;
    _jump436:;
    double _355 = 4.0;
    bool _356 = _355 < _253;
    _a1_int64_t _357;
    if (!_356)
    goto _jump440;
    bool _358 = true;
    bool _359 = !_358;
    _a1_int64_t _360;
    if (!_359)
    goto _jump441;
    _a1_int64_t _361;
    // Computing bound for g
    _361.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    // Computing total size of heap memory to allocate
    int64_t _362 = 1;
    _362 *= _0.d1;
    _362 *= sizeof(int64_t);
    _361.data = jpl_alloc(_362);
    int64_t _363 = 0; // g
    _jump443:; // Begin body of loop
    int64_t _364 = 0;
    _364 *= _361.d0;
    _364 += _363;
    _361.data[_364] = _0.d0;
    _363++;
    if (_363 < _0.d1)
    goto _jump443;
    // End body of loop
    _360 = _361;
    goto _jump444;
    _jump441:;
    _a1_int64_t _365;
    _365.d0 = 2;
    _365.data = jpl_alloc(sizeof(int64_t) * 2);
    _365.data[0] = _0.d0;
    _365.data[1] = _0.d0;
    _360 = _365;
    _jump444:;
    _357 = _360;
    goto _jump445;
    _jump440:;
    int64_t _366 = 417;
    int64_t _367 = _0.d0 / _366;
    bool _368 = true;
    int64_t _369;
    if (!_368)
    goto _jump446;
    _369 = _0.d1;
    goto _jump447;
    _jump446:;
    int64_t _370 = 237;
    _369 = _370;
    _jump447:;
    _a1_int64_t _371;
    _371.d0 = 3;
    _371.data = jpl_alloc(sizeof(int64_t) * 3);
    _371.data[0] = _367;
    _371.data[1] = _369;
    _371.data[2] = _0.d0;
    _357 = _371;
    _jump445:;
    _346 = _357;
    _jump439:;
    _281 = _346;
    _jump432:;
    _277 = _281;
    goto _jump448;
    _jump403:;
    _a1_int64_t _372;
    // Computing bound for g
    int64_t _373 = 69;
    int64_t _374 = 545;
    int64_t _375 = _373 - _374;
    int64_t _376;
    // Computing bound for g
    if (_0.d0 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    _376 = 0;
    int64_t _377 = 0; // g
    _jump450:; // Begin body of loop
    _376 += _0.d1;
    _377++;
    if (_377 < _0.d0)
    goto _jump450;
    // End body of loop
    _a1_int64_t _378;
    _378.d0 = 3;
    _378.data = jpl_alloc(sizeof(int64_t) * 3);
    _378.data[0] = _375;
    _378.data[1] = _376;
    _378.data[2] = _0.d1;
    int64_t _379 = 151;
    if (_379 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (_379 < _378.d0)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    int64_t _380 = 0;
    _380 *= _378.d0;
    _380 += _379;
    int64_t _381 = _378.data[_380];
    int64_t _382 = -_381;
    _372.d0 = _382;
    if (_382 > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    // Computing total size of heap memory to allocate
    int64_t _383 = 1;
    _383 *= _382;
    _383 *= sizeof(int64_t);
    _372.data = jpl_alloc(_383);
    int64_t _384 = 0; // g
    _jump454:; // Begin body of loop
    _a2_int64_t _385;
    // Computing bound for h
    int64_t _386 = 87;
    int64_t _387 = -_386;
    _385.d0 = _387;
    if (_387 > 0) 
    goto _jump455;
    fail_assertion("non-positive loop bound");
    _jump455:;
    // Computing bound for i
    _385.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing total size of heap memory to allocate
    int64_t _388 = 1;
    _388 *= _387;
    _388 *= _0.d0;
    _388 *= sizeof(int64_t);
    _385.data = jpl_alloc(_388);
    int64_t _389 = 0; // i
    int64_t _390 = 0; // h
    _jump457:; // Begin body of loop
    int64_t _391 = -_390;
    int64_t _392 = 0;
    _392 *= _385.d0;
    _392 += _390;
    _392 *= _385.d1;
    _392 += _389;
    _385.data[_392] = _391;
    _389++;
    if (_389 < _0.d0)
    goto _jump457;
    _389 = 0;
    _390++;
    if (_390 < _387)
    goto _jump457;
    // End body of loop
    if (_0.d0 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_0.d0 < _385.d0)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    if (_384 >= 0)
    goto _jump460;
    fail_assertion("negative array index");
    _jump460:;
    if (_384 < _385.d1)
    goto _jump461;
    fail_assertion("index too large");
    _jump461:;
    int64_t _393 = 0;
    _393 *= _385.d0;
    _393 += _0.d0;
    _393 *= _385.d1;
    _393 += _384;
    int64_t _394 = _385.data[_393];
    int64_t _395 = 0;
    _395 *= _372.d0;
    _395 += _384;
    _372.data[_395] = _394;
    _384++;
    if (_384 < _382)
    goto _jump454;
    // End body of loop
    _277 = _372;
    _jump448:;
    _267 = _277;
    _jump402:;
    double _396 = 57.0;
    double _397 = get_time();
    int64_t _398;
    // Computing bound for k
    double _400 = 80.0;
    bool _401 = _396 >= _400;
    bool _399 = _401;
    if (0 == _401)
    goto _jump462;
    bool _402 = false;
    bool _403 = !_402;
    bool _404;
    if (!_403)
    goto _jump463;
    double _405 = 38.0;
    double _406 = 63.0;
    bool _407 = _405 != _406;
    _404 = _407;
    goto _jump464;
    _jump463:;
    bool _408 = true;
    _404 = _408;
    _jump464:;
    _399 = _404;
    _jump462:;
    _a1_int64_t _409;
    if (!_399)
    goto _jump465;
    if (_0.d0 >= 0)
    goto _jump466;
    fail_assertion("negative array index");
    _jump466:;
    if (_0.d0 < _267.d0)
    goto _jump467;
    fail_assertion("index too large");
    _jump467:;
    int64_t _410 = 0;
    _410 *= _267.d0;
    _410 += _0.d0;
    int64_t _411 = _267.data[_410];
    _a1_int64_t _412;
    _412.d0 = 2;
    _412.data = jpl_alloc(sizeof(int64_t) * 2);
    _412.data[0] = _411;
    _412.data[1] = _0.d1;
    _409 = _412;
    goto _jump468;
    _jump465:;
    _409 = _267;
    _jump468:;
    bool _413 = _267.d0 != _0.d0;
    bool _414 = !_413;
    int64_t _415;
    if (!_414)
    goto _jump469;
    int64_t _416 = _267.d0 + _267.d0;
    int64_t _417 = -_416;
    _415 = _417;
    goto _jump470;
    _jump469:;
    _415 = _0.d1;
    _jump470:;
    if (_415 >= 0)
    goto _jump471;
    fail_assertion("negative array index");
    _jump471:;
    if (_415 < _409.d0)
    goto _jump472;
    fail_assertion("index too large");
    _jump472:;
    int64_t _418 = 0;
    _418 *= _409.d0;
    _418 += _415;
    int64_t _419 = _409.data[_418];
    if (_419 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for l
    int64_t _420 = 374;
    if (_420 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    _398 = 0;
    int64_t _421 = 0; // l
    int64_t _422 = 0; // k
    _jump475:; // Begin body of loop
    _398 += _267.d0;
    _421++;
    if (_421 < _420)
    goto _jump475;
    _421 = 0;
    _422++;
    if (_422 < _419)
    goto _jump475;
    // End body of loop
    double _423 = get_time();
    print_time(_423 - _397);
    _a2_rgba _424 = read_image("l.png");
    int64_t m = _424.d0;
    int64_t n = _424.d1;
    bool _425 = true;
    bool _426 = !_425;
    bool _427;
    if (!_426)
    goto _jump476;
    bool _429 = false;
    bool _428 = _429;
    if (0 == _429)
    goto _jump477;
    bool _430 = true;
    _428 = _430;
    _jump477:;
    _427 = _428;
    goto _jump478;
    _jump476:;
    double _431;
    // Computing bound for o
    int64_t _432 = 323;
    int64_t _433 = _424.d1 % _432;
    if (_433 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing bound for p
    int64_t _434 = _0.d0 / _424.d1;
    if (_434 > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    // Computing bound for q
    if (_267.d0 > 0) 
    goto _jump481;
    fail_assertion("non-positive loop bound");
    _jump481:;
    _431 = 0;
    int64_t _435 = 0; // q
    int64_t _436 = 0; // p
    int64_t _437 = 0; // o
    _jump482:; // Begin body of loop
    bool _438 = true;
    bool _439;
    if (!_438)
    goto _jump483;
    bool _440 = true;
    _439 = _440;
    goto _jump484;
    _jump483:;
    double _441 = 69.0;
    double _442;
    // Computing bound for r
    if (_424.d0 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    // Computing bound for s
    if (_424.d1 > 0) 
    goto _jump486;
    fail_assertion("non-positive loop bound");
    _jump486:;
    _442 = 0;
    int64_t _443 = 0; // s
    int64_t _444 = 0; // r
    _jump487:; // Begin body of loop
    double _445 = 50.0;
    _442 += _445;
    _443++;
    if (_443 < _424.d1)
    goto _jump487;
    _443 = 0;
    _444++;
    if (_444 < _424.d0)
    goto _jump487;
    // End body of loop
    bool _446 = _441 <= _442;
    _439 = _446;
    _jump484:;
    double _447;
    if (!_439)
    goto _jump488;
    bool _448 = false;
    _a1_bool _449;
    _449.d0 = 1;
    _449.data = jpl_alloc(sizeof(bool) * 1);
    _449.data[0] = _448;
    int64_t _450 = 956;
    if (_450 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_450 < _449.d0)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _451 = 0;
    _451 *= _449.d0;
    _451 += _450;
    bool _452 = _449.data[_451];
    double _453;
    if (!_452)
    goto _jump491;
    _a1_double _454;
    // Computing bound for r
    _454.d0 = _398;
    if (_398 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    // Computing total size of heap memory to allocate
    int64_t _455 = 1;
    _455 *= _398;
    _455 *= sizeof(double);
    _454.data = jpl_alloc(_455);
    int64_t _456 = 0; // r
    _jump493:; // Begin body of loop
    double _457 = 38.0;
    int64_t _458 = 0;
    _458 *= _454.d0;
    _458 += _456;
    _454.data[_458] = _457;
    _456++;
    if (_456 < _398)
    goto _jump493;
    // End body of loop
    if (_267.d0 >= 0)
    goto _jump494;
    fail_assertion("negative array index");
    _jump494:;
    if (_267.d0 < _454.d0)
    goto _jump495;
    fail_assertion("index too large");
    _jump495:;
    int64_t _459 = 0;
    _459 *= _454.d0;
    _459 += _267.d0;
    double _460 = _454.data[_459];
    _453 = _460;
    goto _jump496;
    _jump491:;
    double _461 = 61.0;
    double _462 = -_461;
    _453 = _462;
    _jump496:;
    _447 = _453;
    goto _jump497;
    _jump488:;
    double _463 = 99.0;
    _447 = _463;
    _jump497:;
    _431 += _447;
    _435++;
    if (_435 < _267.d0)
    goto _jump482;
    _435 = 0;
    _436++;
    if (_436 < _434)
    goto _jump482;
    _436 = 0;
    _437++;
    if (_437 < _433)
    goto _jump482;
    // End body of loop
    double _464 = -_253;
    bool _465 = _431 < _464;
    _427 = _465;
    _jump478:;
    show("(BoolType)", &_427);
    int64_t _466 = -_0.d0;
    int64_t _467;
    // Computing bound for o
    if (_424.d0 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    _467 = 0;
    int64_t _468 = 0; // o
    _jump499:; // Begin body of loop
    _a1_int64_t _469;
    // Computing bound for p
    _469.d0 = _267.d0;
    if (_267.d0 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    // Computing total size of heap memory to allocate
    int64_t _470 = 1;
    _470 *= _267.d0;
    _470 *= sizeof(int64_t);
    _469.data = jpl_alloc(_470);
    int64_t _471 = 0; // p
    _jump501:; // Begin body of loop
    int64_t _472 = 0;
    _472 *= _469.d0;
    _472 += _471;
    _469.data[_472] = _471;
    _471++;
    if (_471 < _267.d0)
    goto _jump501;
    // End body of loop
    int64_t _473 = _424.d0 * _267.d0;
    if (_473 >= 0)
    goto _jump502;
    fail_assertion("negative array index");
    _jump502:;
    if (_473 < _469.d0)
    goto _jump503;
    fail_assertion("index too large");
    _jump503:;
    int64_t _474 = 0;
    _474 *= _469.d0;
    _474 += _473;
    int64_t _475 = _469.data[_474];
    _467 += _475;
    _468++;
    if (_468 < _424.d0)
    goto _jump499;
    // End body of loop
    bool _476 = _466 <= _467;
    bool _477;
    if (!_476)
    goto _jump504;
    bool _480 = _398 >= _0.d0;
    bool _479 = _480;
    if (0 == _480)
    goto _jump505;
    int64_t _481 = 987;
    bool _482 = _481 <= _424.d0;
    _479 = _482;
    _jump505:;
    bool _483 = _267.d0 != _424.d0;
    bool _484 = _479 == _483;
    bool _478 = _484;
    if (0 != _484)
    goto _jump506;
    int64_t _485 = 115;
    bool _486 = _0.d0 >= _485;
    double _487;
    if (!_486)
    goto _jump507;
    _487 = _396;
    goto _jump508;
    _jump507:;
    _487 = _396;
    _jump508:;
    bool _488 = _253 == _487;
    _478 = _488;
    _jump506:;
    _477 = _478;
    goto _jump509;
    _jump504:;
    bool _489 = false;
    bool _490 = !_489;
    _477 = _490;
    _jump509:;
    bool _491 = !_477;
    bool _492 = false;
    bool _493 = _491 != _492;
    if (0 != _493)
    goto _jump510;
    fail_assertion("o");
    _jump510:;
    _a2_rgba _494 = read_image("o.png");
    double _495 = get_time();
    show("(ArrayType (TupleType (FloatType) (FloatType) (FloatType) (FloatType)) 2)", &_0);
    double _496 = get_time();
    print_time(_496 - _495);
    _a2_rgba _497 = read_image("s.png");
    int64_t _498 = -_267.d0;
    write_image(_0, "v.png");
}

