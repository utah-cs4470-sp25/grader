
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_int64_t *data;
} _a2__a3__a2_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_bool *data;
} _a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2_bool *data;
} _a2__a3__a2_bool;

typedef struct {
  int64_t d0;
  _a2__a3__a2_bool *data;
} _a1__a2__a3__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  _a1__a3_bool *data;
} _a1__a1__a3_bool;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  _a1_double *data;
} _a1__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
    int64_t a;
    void_t b;
} r;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a1_bool *data;
} _a2__a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1__a1_bool *data;
} _a3__a2__a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1_bool *data;
} _a3__a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a1_int64_t *data;
} _a2__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  _a3__a1_int64_t *data;
} _a1__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a3__a1_int64_t *data;
} _a3__a1__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a1__a3__a1_int64_t *data;
} _a1__a1__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_rgba *data;
} _a3__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  r *data;
} _a2_r;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a2_int64_t *data;
} _a2__a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_double *data;
} _a2__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_r *data;
} _a2__a2_r;

typedef struct {
  int64_t d0;
  _a2__a2_r *data;
} _a1__a2__a2_r;

bool l() {
    _a1__a2__a3__a2_bool _0;
    // Computing bound for m
    _0.d0 = k;
    if (k > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing total size of heap memory to allocate
    int64_t _1 = 1;
    _1 *= k;
    _1 *= sizeof(_a2__a3__a2_bool);
    _0.data = jpl_alloc(_1);
    int64_t _2 = 0; // m
    _jump153:; // Begin body of loop
    _a2__a3__a2_bool _3;
    // Computing bound for n
    _3.d0 = _2;
    if (_2 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing bound for o
    int64_t _4 = -k;
    _3.d1 = _4;
    if (_4 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _2;
    _5 *= _4;
    _5 *= sizeof(_a3__a2_bool);
    _3.data = jpl_alloc(_5);
    int64_t _6 = 0; // o
    int64_t _7 = 0; // n
    _jump156:; // Begin body of loop
    _a3__a2_bool _8;
    // Computing bound for p
    int64_t _9 = -b;
    _8.d0 = _9;
    if (_9 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    // Computing bound for q
    _8.d1 = _6;
    if (_6 > 0) 
    goto _jump158;
    fail_assertion("non-positive loop bound");
    _jump158:;
    // Computing bound for r
    _8.d2 = _6;
    if (_6 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _9;
    _10 *= _6;
    _10 *= _6;
    _10 *= sizeof(_a2_bool);
    _8.data = jpl_alloc(_10);
    int64_t _11 = 0; // r
    int64_t _12 = 0; // q
    int64_t _13 = 0; // p
    _jump160:; // Begin body of loop
    bool _14 = false;
    _a2_bool _15;
    if (!_14)
    goto _jump161;
    _15 = e;
    goto _jump162;
    _jump161:;
    _15 = e;
    _jump162:;
    int64_t _16 = 0;
    _16 *= _8.d0;
    _16 += _13;
    _16 *= _8.d1;
    _16 += _12;
    _16 *= _8.d2;
    _16 += _11;
    _8.data[_16] = _15;
    _11++;
    if (_11 < _6)
    goto _jump160;
    _11 = 0;
    _12++;
    if (_12 < _6)
    goto _jump160;
    _12 = 0;
    _13++;
    if (_13 < _9)
    goto _jump160;
    // End body of loop
    int64_t _17 = 0;
    _17 *= _3.d0;
    _17 += _7;
    _17 *= _3.d1;
    _17 += _6;
    _3.data[_17] = _8;
    _6++;
    if (_6 < _4)
    goto _jump156;
    _6 = 0;
    _7++;
    if (_7 < _2)
    goto _jump156;
    // End body of loop
    int64_t _18 = 0;
    _18 *= _0.d0;
    _18 += _2;
    _0.data[_18] = _3;
    _2++;
    if (_2 < k)
    goto _jump153;
    // End body of loop
    int64_t _19 = 424;
    if (_19 >= 0)
    goto _jump163;
    fail_assertion("negative array index");
    _jump163:;
    if (_19 < _0.d0)
    goto _jump164;
    fail_assertion("index too large");
    _jump164:;
    int64_t _20 = 0;
    _20 *= _0.d0;
    _20 += _19;
    _a2__a3__a2_bool _21 = _0.data[_20];
    int64_t _22 = -d;
    int64_t _23 = -_22;
    if (g >= 0)
    goto _jump165;
    fail_assertion("negative array index");
    _jump165:;
    if (g < _21.d0)
    goto _jump166;
    fail_assertion("index too large");
    _jump166:;
    if (_23 >= 0)
    goto _jump167;
    fail_assertion("negative array index");
    _jump167:;
    if (_23 < _21.d1)
    goto _jump168;
    fail_assertion("index too large");
    _jump168:;
    int64_t _24 = 0;
    _24 *= _21.d0;
    _24 += g;
    _24 *= _21.d1;
    _24 += _23;
    _a3__a2_bool _25 = _21.data[_24];
    int64_t _26 = -c;
    int64_t _27 = g * _26;
    if (b >= 0)
    goto _jump169;
    fail_assertion("negative array index");
    _jump169:;
    if (b < _25.d0)
    goto _jump170;
    fail_assertion("index too large");
    _jump170:;
    if (b >= 0)
    goto _jump171;
    fail_assertion("negative array index");
    _jump171:;
    if (b < _25.d1)
    goto _jump172;
    fail_assertion("index too large");
    _jump172:;
    if (_27 >= 0)
    goto _jump173;
    fail_assertion("negative array index");
    _jump173:;
    if (_27 < _25.d2)
    goto _jump174;
    fail_assertion("index too large");
    _jump174:;
    int64_t _28 = 0;
    _28 *= _25.d0;
    _28 += b;
    _28 *= _25.d1;
    _28 += b;
    _28 *= _25.d2;
    _28 += _27;
    _a2_bool _29 = _25.data[_28];
    bool _30 = false;
    return _30;
    double _31 = 34.0;
    bool _32 = l();
    double _33;
    if (!_32)
    goto _jump175;
    double _34;
    // Computing bound for p
    if (k > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    // Computing bound for q
    int64_t _35 = -b;
    if (_35 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    _34 = 0;
    int64_t _36 = 0; // q
    int64_t _37 = 0; // p
    _jump178:; // Begin body of loop
    bool _38 = false;
    double _39;
    if (!_38)
    goto _jump179;
    double _40 = 0.0;
    double _41 = -_40;
    double _42 = 25.0;
    double _43 = -_42;
    double _44 = _41 - _43;
    _39 = _44;
    goto _jump180;
    _jump179:;
    _a2_double _45;
    // Computing bound for r
    _45.d0 = b;
    if (b > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing bound for s
    _45.d1 = g;
    if (g > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= b;
    _46 *= g;
    _46 *= sizeof(double);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // s
    int64_t _48 = 0; // r
    _jump183:; // Begin body of loop
    double _49 = 62.0;
    int64_t _50 = 0;
    _50 *= _45.d0;
    _50 += _48;
    _50 *= _45.d1;
    _50 += _47;
    _45.data[_50] = _49;
    _47++;
    if (_47 < g)
    goto _jump183;
    _47 = 0;
    _48++;
    if (_48 < b)
    goto _jump183;
    // End body of loop
    if (_36 >= 0)
    goto _jump184;
    fail_assertion("negative array index");
    _jump184:;
    if (_36 < _45.d0)
    goto _jump185;
    fail_assertion("index too large");
    _jump185:;
    if (_29.d1 >= 0)
    goto _jump186;
    fail_assertion("negative array index");
    _jump186:;
    if (_29.d1 < _45.d1)
    goto _jump187;
    fail_assertion("index too large");
    _jump187:;
    int64_t _51 = 0;
    _51 *= _45.d0;
    _51 += _36;
    _51 *= _45.d1;
    _51 += _29.d1;
    double _52 = _45.data[_51];
    _39 = _52;
    _jump180:;
    _34 += _39;
    _36++;
    if (_36 < _35)
    goto _jump178;
    _36 = 0;
    _37++;
    if (_37 < k)
    goto _jump178;
    // End body of loop
    double _53;
    // Computing bound for p
    if (k > 0) 
    goto _jump188;
    fail_assertion("non-positive loop bound");
    _jump188:;
    // Computing bound for q
    if (d > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing bound for r
    if (k > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    _53 = 0;
    int64_t _54 = 0; // r
    int64_t _55 = 0; // q
    int64_t _56 = 0; // p
    _jump191:; // Begin body of loop
    double _57 = 46.0;
    _53 += _57;
    _54++;
    if (_54 < k)
    goto _jump191;
    _54 = 0;
    _55++;
    if (_55 < d)
    goto _jump191;
    _55 = 0;
    _56++;
    if (_56 < k)
    goto _jump191;
    // End body of loop
    double _58 = 18.0;
    double _59 = -_58;
    double _60 = _53 - _59;
    double _61 = -_60;
    double _62 = 74.0;
    double _63 = fmod(_61, _62);
    double _64 = _34 * _63;
    _33 = _64;
    goto _jump192;
    _jump175:;
    bool _66 = l();
    bool _65 = _66;
    if (0 != _66)
    goto _jump193;
    int64_t _67;
    // Computing bound for p
    if (g > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    _67 = 0;
    int64_t _68 = 0; // p
    _jump195:; // Begin body of loop
    _67 += d;
    _68++;
    if (_68 < g)
    goto _jump195;
    // End body of loop
    bool _69 = c != _67;
    _65 = _69;
    _jump193:;
    rgba _70;
    if (!_65)
    goto _jump196;
    double _71;
    // Computing bound for p
    int64_t _72 = -b;
    if (_72 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing bound for q
    int64_t _73;
    // Computing bound for p
    int64_t _74 = 82;
    if (_74 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    _73 = 0;
    int64_t _75 = 0; // p
    _jump199:; // Begin body of loop
    _73 += j;
    _75++;
    if (_75 < _74)
    goto _jump199;
    // End body of loop
    if (_73 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    _71 = 0;
    int64_t _76 = 0; // q
    int64_t _77 = 0; // p
    _jump201:; // Begin body of loop
    double _78 = 30.0;
    double _79 = -_78;
    _71 += _79;
    _76++;
    if (_76 < _73)
    goto _jump201;
    _76 = 0;
    _77++;
    if (_77 < _72)
    goto _jump201;
    // End body of loop
    double _80;
    // Computing bound for p
    int64_t _81 = 187;
    if (_81 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    _80 = 0;
    int64_t _82 = 0; // p
    _jump203:; // Begin body of loop
    double _83 = 60.0;
    _80 += _83;
    _82++;
    if (_82 < _81)
    goto _jump203;
    // End body of loop
    double _84;
    // Computing bound for p
    if (c > 0) 
    goto _jump204;
    fail_assertion("non-positive loop bound");
    _jump204:;
    // Computing bound for q
    if (i > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    // Computing bound for r
    if (j > 0) 
    goto _jump206;
    fail_assertion("non-positive loop bound");
    _jump206:;
    _84 = 0;
    int64_t _85 = 0; // r
    int64_t _86 = 0; // q
    int64_t _87 = 0; // p
    _jump207:; // Begin body of loop
    bool _88 = l();
    double _89;
    if (!_88)
    goto _jump208;
    double _90 = 19.0;
    _89 = _90;
    goto _jump209;
    _jump208:;
    double _91 = 71.0;
    _89 = _91;
    _jump209:;
    _84 += _89;
    _85++;
    if (_85 < j)
    goto _jump207;
    _85 = 0;
    _86++;
    if (_86 < i)
    goto _jump207;
    _86 = 0;
    _87++;
    if (_87 < c)
    goto _jump207;
    // End body of loop
    _a3_double _92;
    // Computing bound for p
    _92.d0 = b;
    if (b > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing bound for q
    _92.d1 = j;
    if (j > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for r
    _92.d2 = j;
    if (j > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing total size of heap memory to allocate
    int64_t _93 = 1;
    _93 *= b;
    _93 *= j;
    _93 *= j;
    _93 *= sizeof(double);
    _92.data = jpl_alloc(_93);
    int64_t _94 = 0; // r
    int64_t _95 = 0; // q
    int64_t _96 = 0; // p
    _jump213:; // Begin body of loop
    double _97 = 79.0;
    int64_t _98 = 0;
    _98 *= _92.d0;
    _98 += _96;
    _98 *= _92.d1;
    _98 += _95;
    _98 *= _92.d2;
    _98 += _94;
    _92.data[_98] = _97;
    _94++;
    if (_94 < j)
    goto _jump213;
    _94 = 0;
    _95++;
    if (_95 < j)
    goto _jump213;
    _95 = 0;
    _96++;
    if (_96 < b)
    goto _jump213;
    // End body of loop
    if (g >= 0)
    goto _jump214;
    fail_assertion("negative array index");
    _jump214:;
    if (g < _92.d0)
    goto _jump215;
    fail_assertion("index too large");
    _jump215:;
    if (g >= 0)
    goto _jump216;
    fail_assertion("negative array index");
    _jump216:;
    if (g < _92.d1)
    goto _jump217;
    fail_assertion("index too large");
    _jump217:;
    if (g >= 0)
    goto _jump218;
    fail_assertion("negative array index");
    _jump218:;
    if (g < _92.d2)
    goto _jump219;
    fail_assertion("index too large");
    _jump219:;
    int64_t _99 = 0;
    _99 *= _92.d0;
    _99 += g;
    _99 *= _92.d1;
    _99 += g;
    _99 *= _92.d2;
    _99 += g;
    double _100 = _92.data[_99];
    rgba _101 = { _71, _80, _84, _100 };
    _70 = _101;
    goto _jump220;
    _jump196:;
    double _102 = 93.0;
    double _103;
    // Computing bound for p
    if (d > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing bound for q
    if (g > 0) 
    goto _jump222;
    fail_assertion("non-positive loop bound");
    _jump222:;
    // Computing bound for r
    int64_t _104 = 973;
    if (_104 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    _103 = 0;
    int64_t _105 = 0; // r
    int64_t _106 = 0; // q
    int64_t _107 = 0; // p
    _jump224:; // Begin body of loop
    double _108 = 36.0;
    double _109 = -_108;
    _103 += _109;
    _105++;
    if (_105 < _104)
    goto _jump224;
    _105 = 0;
    _106++;
    if (_106 < g)
    goto _jump224;
    _106 = 0;
    _107++;
    if (_107 < d)
    goto _jump224;
    // End body of loop
    _a3_double _110;
    // Computing bound for p
    _110.d0 = d;
    if (d > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for q
    _110.d1 = k;
    if (k > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for r
    _110.d2 = _29.d0;
    if (_29.d0 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= d;
    _111 *= k;
    _111 *= _29.d0;
    _111 *= sizeof(double);
    _110.data = jpl_alloc(_111);
    int64_t _112 = 0; // r
    int64_t _113 = 0; // q
    int64_t _114 = 0; // p
    _jump228:; // Begin body of loop
    double _115 = 60.0;
    int64_t _116 = 0;
    _116 *= _110.d0;
    _116 += _114;
    _116 *= _110.d1;
    _116 += _113;
    _116 *= _110.d2;
    _116 += _112;
    _110.data[_116] = _115;
    _112++;
    if (_112 < _29.d0)
    goto _jump228;
    _112 = 0;
    _113++;
    if (_113 < k)
    goto _jump228;
    _113 = 0;
    _114++;
    if (_114 < d)
    goto _jump228;
    // End body of loop
    if (g >= 0)
    goto _jump229;
    fail_assertion("negative array index");
    _jump229:;
    if (g < _110.d0)
    goto _jump230;
    fail_assertion("index too large");
    _jump230:;
    if (j >= 0)
    goto _jump231;
    fail_assertion("negative array index");
    _jump231:;
    if (j < _110.d1)
    goto _jump232;
    fail_assertion("index too large");
    _jump232:;
    if (_29.d1 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (_29.d1 < _110.d2)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    int64_t _117 = 0;
    _117 *= _110.d0;
    _117 += g;
    _117 *= _110.d1;
    _117 += j;
    _117 *= _110.d2;
    _117 += _29.d1;
    double _118 = _110.data[_117];
    double _119 = 11.0;
    rgba _120 = { _102, _103, _118, _119 };
    _70 = _120;
    _jump220:;
    double _121 = _70.r;
    _33 = _121;
    _jump192:;
    double _122;
    // Computing bound for p
    bool _123 = false;
    _a3__a2_int64_t _124;
    if (!_123)
    goto _jump235;
    _a3__a2_int64_t _125;
    // Computing bound for p
    _125.d0 = i;
    if (i > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing bound for q
    _125.d1 = _29.d0;
    if (_29.d0 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    // Computing bound for r
    _125.d2 = c;
    if (c > 0) 
    goto _jump238;
    fail_assertion("non-positive loop bound");
    _jump238:;
    // Computing total size of heap memory to allocate
    int64_t _126 = 1;
    _126 *= i;
    _126 *= _29.d0;
    _126 *= c;
    _126 *= sizeof(_a2_int64_t);
    _125.data = jpl_alloc(_126);
    int64_t _127 = 0; // r
    int64_t _128 = 0; // q
    int64_t _129 = 0; // p
    _jump239:; // Begin body of loop
    _a2_int64_t _130;
    // Computing bound for s
    _130.d0 = _128;
    if (_128 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    // Computing bound for t
    _130.d1 = _128;
    if (_128 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= _128;
    _131 *= _128;
    _131 *= sizeof(int64_t);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // t
    int64_t _133 = 0; // s
    _jump242:; // Begin body of loop
    int64_t _134 = 0;
    _134 *= _130.d0;
    _134 += _133;
    _134 *= _130.d1;
    _134 += _132;
    _130.data[_134] = g;
    _132++;
    if (_132 < _128)
    goto _jump242;
    _132 = 0;
    _133++;
    if (_133 < _128)
    goto _jump242;
    // End body of loop
    int64_t _135 = 0;
    _135 *= _125.d0;
    _135 += _129;
    _135 *= _125.d1;
    _135 += _128;
    _135 *= _125.d2;
    _135 += _127;
    _125.data[_135] = _130;
    _127++;
    if (_127 < c)
    goto _jump239;
    _127 = 0;
    _128++;
    if (_128 < _29.d0)
    goto _jump239;
    _128 = 0;
    _129++;
    if (_129 < i)
    goto _jump239;
    // End body of loop
    _124 = _125;
    goto _jump243;
    _jump235:;
    _a3__a2_int64_t _136;
    // Computing bound for p
    _136.d0 = g;
    if (g > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing bound for q
    int64_t _137 = 58;
    int64_t _138 = _137 + b;
    _136.d1 = _138;
    if (_138 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing bound for r
    _136.d2 = g;
    if (g > 0) 
    goto _jump246;
    fail_assertion("non-positive loop bound");
    _jump246:;
    // Computing total size of heap memory to allocate
    int64_t _139 = 1;
    _139 *= g;
    _139 *= _138;
    _139 *= g;
    _139 *= sizeof(_a2_int64_t);
    _136.data = jpl_alloc(_139);
    int64_t _140 = 0; // r
    int64_t _141 = 0; // q
    int64_t _142 = 0; // p
    _jump247:; // Begin body of loop
    _a2_int64_t _143;
    // Computing bound for s
    _143.d0 = _29.d0;
    if (_29.d0 > 0) 
    goto _jump248;
    fail_assertion("non-positive loop bound");
    _jump248:;
    // Computing bound for t
    _143.d1 = _142;
    if (_142 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    // Computing total size of heap memory to allocate
    int64_t _144 = 1;
    _144 *= _29.d0;
    _144 *= _142;
    _144 *= sizeof(int64_t);
    _143.data = jpl_alloc(_144);
    int64_t _145 = 0; // t
    int64_t _146 = 0; // s
    _jump250:; // Begin body of loop
    int64_t _147 = 0;
    _147 *= _143.d0;
    _147 += _146;
    _147 *= _143.d1;
    _147 += _145;
    _143.data[_147] = _29.d0;
    _145++;
    if (_145 < _142)
    goto _jump250;
    _145 = 0;
    _146++;
    if (_146 < _29.d0)
    goto _jump250;
    // End body of loop
    int64_t _148 = 0;
    _148 *= _136.d0;
    _148 += _142;
    _148 *= _136.d1;
    _148 += _141;
    _148 *= _136.d2;
    _148 += _140;
    _136.data[_148] = _143;
    _140++;
    if (_140 < g)
    goto _jump247;
    _140 = 0;
    _141++;
    if (_141 < _138)
    goto _jump247;
    _141 = 0;
    _142++;
    if (_142 < g)
    goto _jump247;
    // End body of loop
    _124 = _136;
    _jump243:;
    _a3_int64_t _149;
    // Computing bound for p
    _149.d0 = c;
    if (c > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing bound for q
    int64_t _150 = 443;
    _149.d1 = _150;
    if (_150 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for r
    _149.d2 = i;
    if (i > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= c;
    _151 *= _150;
    _151 *= i;
    _151 *= sizeof(int64_t);
    _149.data = jpl_alloc(_151);
    int64_t _152 = 0; // r
    int64_t _153 = 0; // q
    int64_t _154 = 0; // p
    _jump254:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _149.d0;
    _155 += _154;
    _155 *= _149.d1;
    _155 += _153;
    _155 *= _149.d2;
    _155 += _152;
    _149.data[_155] = b;
    _152++;
    if (_152 < i)
    goto _jump254;
    _152 = 0;
    _153++;
    if (_153 < _150)
    goto _jump254;
    _153 = 0;
    _154++;
    if (_154 < c)
    goto _jump254;
    // End body of loop
    int64_t _156 = 97;
    int64_t _157 = _156 * d;
    int64_t _158 = 195;
    if (d >= 0)
    goto _jump255;
    fail_assertion("negative array index");
    _jump255:;
    if (d < _149.d0)
    goto _jump256;
    fail_assertion("index too large");
    _jump256:;
    if (_157 >= 0)
    goto _jump257;
    fail_assertion("negative array index");
    _jump257:;
    if (_157 < _149.d1)
    goto _jump258;
    fail_assertion("index too large");
    _jump258:;
    if (_158 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_158 < _149.d2)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    int64_t _159 = 0;
    _159 *= _149.d0;
    _159 += d;
    _159 *= _149.d1;
    _159 += _157;
    _159 *= _149.d2;
    _159 += _158;
    int64_t _160 = _149.data[_159];
    int64_t _161 = _160 + k;
    if (_161 >= 0)
    goto _jump261;
    fail_assertion("negative array index");
    _jump261:;
    if (_161 < _124.d0)
    goto _jump262;
    fail_assertion("index too large");
    _jump262:;
    if (g >= 0)
    goto _jump263;
    fail_assertion("negative array index");
    _jump263:;
    if (g < _124.d1)
    goto _jump264;
    fail_assertion("index too large");
    _jump264:;
    if (i >= 0)
    goto _jump265;
    fail_assertion("negative array index");
    _jump265:;
    if (i < _124.d2)
    goto _jump266;
    fail_assertion("index too large");
    _jump266:;
    int64_t _162 = 0;
    _162 *= _124.d0;
    _162 += _161;
    _162 *= _124.d1;
    _162 += g;
    _162 *= _124.d2;
    _162 += i;
    _a2_int64_t _163 = _124.data[_162];
    if (i >= 0)
    goto _jump267;
    fail_assertion("negative array index");
    _jump267:;
    if (i < _163.d0)
    goto _jump268;
    fail_assertion("index too large");
    _jump268:;
    if (c >= 0)
    goto _jump269;
    fail_assertion("negative array index");
    _jump269:;
    if (c < _163.d1)
    goto _jump270;
    fail_assertion("index too large");
    _jump270:;
    int64_t _164 = 0;
    _164 *= _163.d0;
    _164 += i;
    _164 *= _163.d1;
    _164 += c;
    int64_t _165 = _163.data[_164];
    if (_165 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for q
    if (k > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing bound for r
    if (g > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    _122 = 0;
    int64_t _166 = 0; // r
    int64_t _167 = 0; // q
    int64_t _168 = 0; // p
    _jump274:; // Begin body of loop
    _a3_double _169;
    // Computing bound for s
    int64_t _170;
    // Computing bound for s
    int64_t _171 = 598;
    if (_171 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    _170 = 0;
    int64_t _172 = 0; // s
    _jump276:; // Begin body of loop
    _170 += k;
    _172++;
    if (_172 < _171)
    goto _jump276;
    // End body of loop
    int64_t _173 = _170 + b;
    _169.d0 = _173;
    if (_173 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    // Computing bound for t
    _169.d1 = c;
    if (c > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing bound for u
    _169.d2 = d;
    if (d > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing total size of heap memory to allocate
    int64_t _174 = 1;
    _174 *= _173;
    _174 *= c;
    _174 *= d;
    _174 *= sizeof(double);
    _169.data = jpl_alloc(_174);
    int64_t _175 = 0; // u
    int64_t _176 = 0; // t
    int64_t _177 = 0; // s
    _jump280:; // Begin body of loop
    double _178;
    // Computing bound for v
    bool _179 = l();
    int64_t _180;
    if (!_179)
    goto _jump281;
    _180 = _168;
    goto _jump282;
    _jump281:;
    _180 = b;
    _jump282:;
    if (_180 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    // Computing bound for w
    if (_177 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    _178 = 0;
    int64_t _181 = 0; // w
    int64_t _182 = 0; // v
    _jump285:; // Begin body of loop
    double _183 = 51.0;
    double _184 = 3.0;
    double _185 = -_184;
    double _186 = fmod(_183, _185);
    _178 += _186;
    _181++;
    if (_181 < _177)
    goto _jump285;
    _181 = 0;
    _182++;
    if (_182 < _180)
    goto _jump285;
    // End body of loop
    int64_t _187 = 0;
    _187 *= _169.d0;
    _187 += _177;
    _187 *= _169.d1;
    _187 += _176;
    _187 *= _169.d2;
    _187 += _175;
    _169.data[_187] = _178;
    _175++;
    if (_175 < d)
    goto _jump280;
    _175 = 0;
    _176++;
    if (_176 < c)
    goto _jump280;
    _176 = 0;
    _177++;
    if (_177 < _173)
    goto _jump280;
    // End body of loop
    if (i >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (i < _169.d0)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    if (b >= 0)
    goto _jump288;
    fail_assertion("negative array index");
    _jump288:;
    if (b < _169.d1)
    goto _jump289;
    fail_assertion("index too large");
    _jump289:;
    if (d >= 0)
    goto _jump290;
    fail_assertion("negative array index");
    _jump290:;
    if (d < _169.d2)
    goto _jump291;
    fail_assertion("index too large");
    _jump291:;
    int64_t _188 = 0;
    _188 *= _169.d0;
    _188 += i;
    _188 *= _169.d1;
    _188 += b;
    _188 *= _169.d2;
    _188 += d;
    double _189 = _169.data[_188];
    _122 += _189;
    _166++;
    if (_166 < g)
    goto _jump274;
    _166 = 0;
    _167++;
    if (_167 < k)
    goto _jump274;
    _167 = 0;
    _168++;
    if (_168 < _165)
    goto _jump274;
    // End body of loop
    double _190 = 23.0;
    rgba _191 = { _31, _33, _122, _190 };
    bool _193 = l();
    bool _192 = _193;
    if (0 == _193)
    goto _jump292;
    bool _194 = i > g;
    _192 = _194;
    _jump292:;
    _a1__a1__a3_bool _195;
    // Computing bound for v
    _195.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= e.d0;
    _196 *= sizeof(_a1__a3_bool);
    _195.data = jpl_alloc(_196);
    int64_t _197 = 0; // v
    _jump294:; // Begin body of loop
    _a3_bool _198;
    // Computing bound for w
    _198.d0 = _29.d1;
    if (_29.d1 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing bound for x
    _198.d1 = _29.d0;
    if (_29.d0 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing bound for y
    int64_t _199 = -e.d0;
    _198.d2 = _199;
    if (_199 > 0) 
    goto _jump297;
    fail_assertion("non-positive loop bound");
    _jump297:;
    // Computing total size of heap memory to allocate
    int64_t _200 = 1;
    _200 *= _29.d1;
    _200 *= _29.d0;
    _200 *= _199;
    _200 *= sizeof(bool);
    _198.data = jpl_alloc(_200);
    int64_t _201 = 0; // y
    int64_t _202 = 0; // x
    int64_t _203 = 0; // w
    _jump298:; // Begin body of loop
    bool _204 = l();
    bool _205 = !_204;
    int64_t _206 = 0;
    _206 *= _198.d0;
    _206 += _203;
    _206 *= _198.d1;
    _206 += _202;
    _206 *= _198.d2;
    _206 += _201;
    _198.data[_206] = _205;
    _201++;
    if (_201 < _199)
    goto _jump298;
    _201 = 0;
    _202++;
    if (_202 < _29.d0)
    goto _jump298;
    _202 = 0;
    _203++;
    if (_203 < _29.d1)
    goto _jump298;
    // End body of loop
    _a1__a3_bool _207;
    _207.d0 = 1;
    _207.data = jpl_alloc(sizeof(_a3_bool) * 1);
    _207.data[0] = _198;
    int64_t _208 = 0;
    _208 *= _195.d0;
    _208 += _197;
    _195.data[_208] = _207;
    _197++;
    if (_197 < e.d0)
    goto _jump294;
    // End body of loop
    int64_t _209 = b - b;
    if (_209 >= 0)
    goto _jump299;
    fail_assertion("negative array index");
    _jump299:;
    if (_209 < _195.d0)
    goto _jump300;
    fail_assertion("index too large");
    _jump300:;
    int64_t _210 = 0;
    _210 *= _195.d0;
    _210 += _209;
    _a1__a3_bool _211 = _195.data[_210];
    if (k >= 0)
    goto _jump301;
    fail_assertion("negative array index");
    _jump301:;
    if (k < _211.d0)
    goto _jump302;
    fail_assertion("index too large");
    _jump302:;
    int64_t _212 = 0;
    _212 *= _211.d0;
    _212 += k;
    _a3_bool _213 = _211.data[_212];
    if (i >= 0)
    goto _jump303;
    fail_assertion("negative array index");
    _jump303:;
    if (i < _213.d0)
    goto _jump304;
    fail_assertion("index too large");
    _jump304:;
    if (k >= 0)
    goto _jump305;
    fail_assertion("negative array index");
    _jump305:;
    if (k < _213.d1)
    goto _jump306;
    fail_assertion("index too large");
    _jump306:;
    if (_29.d0 >= 0)
    goto _jump307;
    fail_assertion("negative array index");
    _jump307:;
    if (_29.d0 < _213.d2)
    goto _jump308;
    fail_assertion("index too large");
    _jump308:;
    int64_t _214 = 0;
    _214 *= _213.d0;
    _214 += i;
    _214 *= _213.d1;
    _214 += k;
    _214 *= _213.d2;
    _214 += _29.d0;
    bool _215 = _213.data[_214];
    return _215;
}

bool m(_a1_double n, _a2_int64_t p) {
    _a3__a1_bool _0;
    // Computing bound for s
    _0.d0 = g;
    if (g > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for t
    int64_t _1 = -i;
    int64_t _2 = _1 - p.d0;
    _0.d1 = _2;
    if (_2 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    // Computing bound for u
    _0.d2 = i;
    if (i > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= g;
    _3 *= _2;
    _3 *= i;
    _3 *= sizeof(_a1_bool);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // u
    int64_t _5 = 0; // t
    int64_t _6 = 0; // s
    _jump312:; // Begin body of loop
    int64_t _7 = 0;
    _7 *= _0.d0;
    _7 += _6;
    _7 *= _0.d1;
    _7 += _5;
    _7 *= _0.d2;
    _7 += _4;
    _0.data[_7] = f;
    _4++;
    if (_4 < i)
    goto _jump312;
    _4 = 0;
    _5++;
    if (_5 < _2)
    goto _jump312;
    _5 = 0;
    _6++;
    if (_6 < g)
    goto _jump312;
    // End body of loop
    _a1_int64_t _8;
    // Computing bound for s
    int64_t _9 = 213;
    if (_9 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (_9 < p.d0)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    if (d >= 0)
    goto _jump315;
    fail_assertion("negative array index");
    _jump315:;
    if (d < p.d1)
    goto _jump316;
    fail_assertion("index too large");
    _jump316:;
    int64_t _10 = 0;
    _10 *= p.d0;
    _10 += _9;
    _10 *= p.d1;
    _10 += d;
    int64_t _11 = p.data[_10];
    _8.d0 = _11;
    if (_11 > 0) 
    goto _jump317;
    fail_assertion("non-positive loop bound");
    _jump317:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _11;
    _12 *= sizeof(int64_t);
    _8.data = jpl_alloc(_12);
    int64_t _13 = 0; // s
    _jump318:; // Begin body of loop
    int64_t _14;
    // Computing bound for t
    int64_t _15 = 854;
    if (_15 > 0) 
    goto _jump319;
    fail_assertion("non-positive loop bound");
    _jump319:;
    _14 = 0;
    int64_t _16 = 0; // t
    _jump320:; // Begin body of loop
    _14 += i;
    _16++;
    if (_16 < _15)
    goto _jump320;
    // End body of loop
    int64_t _17 = 0;
    _17 *= _8.d0;
    _17 += _13;
    _8.data[_17] = _14;
    _13++;
    if (_13 < _11)
    goto _jump318;
    // End body of loop
    if (j >= 0)
    goto _jump321;
    fail_assertion("negative array index");
    _jump321:;
    if (j < _8.d0)
    goto _jump322;
    fail_assertion("index too large");
    _jump322:;
    int64_t _18 = 0;
    _18 *= _8.d0;
    _18 += j;
    int64_t _19 = _8.data[_18];
    _a1_int64_t _20;
    // Computing bound for s
    _20.d0 = c;
    if (c > 0) 
    goto _jump323;
    fail_assertion("non-positive loop bound");
    _jump323:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= c;
    _21 *= sizeof(int64_t);
    _20.data = jpl_alloc(_21);
    int64_t _22 = 0; // s
    _jump324:; // Begin body of loop
    int64_t _23 = 0;
    _23 *= _20.d0;
    _23 += _22;
    _20.data[_23] = d;
    _22++;
    if (_22 < c)
    goto _jump324;
    // End body of loop
    int64_t _24 = 561;
    _a1_int64_t _25;
    _25.d0 = 3;
    _25.data = jpl_alloc(sizeof(int64_t) * 3);
    _25.data[0] = _24;
    _25.data[1] = n.d0;
    _25.data[2] = b;
    int64_t _26 = 47;
    if (_26 >= 0)
    goto _jump325;
    fail_assertion("negative array index");
    _jump325:;
    if (_26 < _25.d0)
    goto _jump326;
    fail_assertion("index too large");
    _jump326:;
    int64_t _27 = 0;
    _27 *= _25.d0;
    _27 += _26;
    int64_t _28 = _25.data[_27];
    if (_28 >= 0)
    goto _jump327;
    fail_assertion("negative array index");
    _jump327:;
    if (_28 < _20.d0)
    goto _jump328;
    fail_assertion("index too large");
    _jump328:;
    int64_t _29 = 0;
    _29 *= _20.d0;
    _29 += _28;
    int64_t _30 = _20.data[_29];
    if (b >= 0)
    goto _jump329;
    fail_assertion("negative array index");
    _jump329:;
    if (b < _0.d0)
    goto _jump330;
    fail_assertion("index too large");
    _jump330:;
    if (_19 >= 0)
    goto _jump331;
    fail_assertion("negative array index");
    _jump331:;
    if (_19 < _0.d1)
    goto _jump332;
    fail_assertion("index too large");
    _jump332:;
    if (_30 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (_30 < _0.d2)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    int64_t _31 = 0;
    _31 *= _0.d0;
    _31 += b;
    _31 *= _0.d1;
    _31 += _19;
    _31 *= _0.d2;
    _31 += _30;
    _a1_bool _32 = _0.data[_31];
    if (p.d1 >= 0)
    goto _jump335;
    fail_assertion("negative array index");
    _jump335:;
    if (p.d1 < _32.d0)
    goto _jump336;
    fail_assertion("index too large");
    _jump336:;
    int64_t _33 = 0;
    _33 *= _32.d0;
    _33 += p.d1;
    bool _34 = _32.data[_33];
    bool _35;
    if (!_34)
    goto _jump337;
    int64_t _36;
    // Computing bound for s
    if (n.d0 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for t
    if (p.d1 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    _36 = 0;
    int64_t _37 = 0; // t
    int64_t _38 = 0; // s
    _jump340:; // Begin body of loop
    _36 += i;
    _37++;
    if (_37 < p.d1)
    goto _jump340;
    _37 = 0;
    _38++;
    if (_38 < n.d0)
    goto _jump340;
    // End body of loop
    bool _39 = d != _36;
    bool _41 = false;
    bool _40 = _41;
    if (0 == _41)
    goto _jump341;
    int64_t _42 = 64;
    bool _43 = _42 > p.d1;
    _40 = _43;
    _jump341:;
    bool _44 = l();
    double _45;
    if (!_44)
    goto _jump342;
    double _46 = 36.0;
    _45 = _46;
    goto _jump343;
    _jump342:;
    double _47 = 47.0;
    _45 = _47;
    _jump343:;
    double _48 = 25.0;
    double _49 = -_48;
    bool _50 = _45 >= _49;
    _a1_bool _51;
    _51.d0 = 3;
    _51.data = jpl_alloc(sizeof(bool) * 3);
    _51.data[0] = _39;
    _51.data[1] = _40;
    _51.data[2] = _50;
    if (p.d1 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (p.d1 < _51.d0)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    int64_t _52 = 0;
    _52 *= _51.d0;
    _52 += p.d1;
    bool _53 = _51.data[_52];
    bool _54 = !_53;
    _35 = _54;
    goto _jump346;
    _jump337:;
    _a1_double _56;
    // Computing bound for s
    int64_t _57 = -i;
    _56.d0 = _57;
    if (_57 > 0) 
    goto _jump347;
    fail_assertion("non-positive loop bound");
    _jump347:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= _57;
    _58 *= sizeof(double);
    _56.data = jpl_alloc(_58);
    int64_t _59 = 0; // s
    _jump348:; // Begin body of loop
    double _60 = 51.0;
    int64_t _61 = 0;
    _61 *= _56.d0;
    _61 += _59;
    _56.data[_61] = _60;
    _59++;
    if (_59 < _57)
    goto _jump348;
    // End body of loop
    bool _62 = m(_56, p);
    bool _63;
    if (!_62)
    goto _jump349;
    bool _65 = n.d0 < p.d0;
    bool _66 = l();
    bool _67 = _65 == _66;
    bool _64 = _67;
    if (0 == _67)
    goto _jump350;
    bool _70 = false;
    bool _69 = _70;
    if (0 == _70)
    goto _jump351;
    bool _71 = false;
    _69 = _71;
    _jump351:;
    bool _68 = _69;
    if (0 != _69)
    goto _jump352;
    bool _72 = j >= p.d1;
    _68 = _72;
    _jump352:;
    _64 = _68;
    _jump350:;
    _63 = _64;
    goto _jump353;
    _jump349:;
    double _73 = 61.0;
    double _74 = 33.0;
    bool _75 = _73 != _74;
    _63 = _75;
    _jump353:;
    bool _55 = _63;
    if (0 == _63)
    goto _jump354;
    _a1_bool _76;
    // Computing bound for s
    _76.d0 = g;
    if (g > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= g;
    _77 *= sizeof(bool);
    _76.data = jpl_alloc(_77);
    int64_t _78 = 0; // s
    _jump356:; // Begin body of loop
    bool _79 = l();
    int64_t _80 = 0;
    _80 *= _76.d0;
    _80 += _78;
    _76.data[_80] = _79;
    _78++;
    if (_78 < g)
    goto _jump356;
    // End body of loop
    if (p.d0 >= 0)
    goto _jump357;
    fail_assertion("negative array index");
    _jump357:;
    if (p.d0 < _76.d0)
    goto _jump358;
    fail_assertion("index too large");
    _jump358:;
    int64_t _81 = 0;
    _81 *= _76.d0;
    _81 += p.d0;
    bool _82 = _76.data[_81];
    _a1_double _83;
    if (!_82)
    goto _jump359;
    _a1_double _84;
    // Computing bound for s
    _84.d0 = k;
    if (k > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= k;
    _85 *= sizeof(double);
    _84.data = jpl_alloc(_85);
    int64_t _86 = 0; // s
    _jump361:; // Begin body of loop
    double _87 = 66.0;
    int64_t _88 = 0;
    _88 *= _84.d0;
    _88 += _86;
    _84.data[_88] = _87;
    _86++;
    if (_86 < k)
    goto _jump361;
    // End body of loop
    _83 = _84;
    goto _jump362;
    _jump359:;
    _a1_double _89;
    // Computing bound for s
    _89.d0 = k;
    if (k > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing total size of heap memory to allocate
    int64_t _90 = 1;
    _90 *= k;
    _90 *= sizeof(double);
    _89.data = jpl_alloc(_90);
    int64_t _91 = 0; // s
    _jump364:; // Begin body of loop
    double _92 = 17.0;
    int64_t _93 = 0;
    _93 *= _89.d0;
    _93 += _91;
    _89.data[_93] = _92;
    _91++;
    if (_91 < k)
    goto _jump364;
    // End body of loop
    _83 = _89;
    _jump362:;
    bool _94 = m(_83, p);
    _55 = _94;
    _jump354:;
    _35 = _55;
    _jump346:;
    _a3__a1_int64_t _95;
    if (!_35)
    goto _jump365;
    _95 = h;
    goto _jump366;
    _jump365:;
    _95 = h;
    _jump366:;
    _a1_double _96;
    // Computing bound for w
    _96.d0 = b;
    if (b > 0) 
    goto _jump367;
    fail_assertion("non-positive loop bound");
    _jump367:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= b;
    _97 *= sizeof(double);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // w
    _jump368:; // Begin body of loop
    bool _100 = n.d0 >= _98;
    bool _99 = _100;
    if (0 != _100)
    goto _jump369;
    bool _101 = l();
    bool _102;
    if (!_101)
    goto _jump370;
    bool _103 = l();
    _102 = _103;
    goto _jump371;
    _jump370:;
    bool _104 = l();
    _102 = _104;
    _jump371:;
    _99 = _102;
    _jump369:;
    double _105;
    if (!_99)
    goto _jump372;
    double _106 = 95.0;
    _105 = _106;
    goto _jump373;
    _jump372:;
    double _107;
    // Computing bound for x
    if (j > 0) 
    goto _jump374;
    fail_assertion("non-positive loop bound");
    _jump374:;
    // Computing bound for y
    if (p.d1 > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    // Computing bound for z
    if (_98 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    _107 = 0;
    int64_t _108 = 0; // z
    int64_t _109 = 0; // y
    int64_t _110 = 0; // x
    _jump377:; // Begin body of loop
    double _111;
    // Computing bound for A
    if (_98 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    _111 = 0;
    int64_t _112 = 0; // A
    _jump379:; // Begin body of loop
    double _113 = 2.0;
    _111 += _113;
    _112++;
    if (_112 < _98)
    goto _jump379;
    // End body of loop
    _107 += _111;
    _108++;
    if (_108 < _98)
    goto _jump377;
    _108 = 0;
    _109++;
    if (_109 < p.d1)
    goto _jump377;
    _109 = 0;
    _110++;
    if (_110 < j)
    goto _jump377;
    // End body of loop
    _105 = _107;
    _jump373:;
    double _114 = 72.0;
    double _115 = _105 / _114;
    int64_t _116 = 0;
    _116 *= _96.d0;
    _116 += _98;
    _96.data[_116] = _115;
    _98++;
    if (_98 < b)
    goto _jump368;
    // End body of loop
    bool _117 = m(_96, p);
    bool _118 = !_117;
    return _118;
    bool _119 = true;
    _a1__a1_double _120;
    if (!_119)
    goto _jump380;
    double _121 = 69.0;
    double _122 = 38.0;
    double _123;
    // Computing bound for w
    if (_95.d2 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    _123 = 0;
    int64_t _124 = 0; // w
    _jump382:; // Begin body of loop
    double _125 = 61.0;
    _123 += _125;
    _124++;
    if (_124 < _95.d2)
    goto _jump382;
    // End body of loop
    _a1_double _126;
    _126.d0 = 3;
    _126.data = jpl_alloc(sizeof(double) * 3);
    _126.data[0] = _121;
    _126.data[1] = _122;
    _126.data[2] = _123;
    _a1__a1_double _127;
    _127.d0 = 2;
    _127.data = jpl_alloc(sizeof(_a1_double) * 2);
    _127.data[0] = n;
    _127.data[1] = _126;
    _120 = _127;
    goto _jump383;
    _jump380:;
    _a1_double _128;
    // Computing bound for w
    _128.d0 = k;
    if (k > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= k;
    _129 *= sizeof(double);
    _128.data = jpl_alloc(_129);
    int64_t _130 = 0; // w
    _jump385:; // Begin body of loop
    double _131 = 68.0;
    double _132 = 76.0;
    double _133 = _131 / _132;
    int64_t _134 = 0;
    _134 *= _128.d0;
    _134 += _130;
    _128.data[_134] = _133;
    _130++;
    if (_130 < k)
    goto _jump385;
    // End body of loop
    _a1__a1_double _135;
    _135.d0 = 1;
    _135.data = jpl_alloc(sizeof(_a1_double) * 1);
    _135.data[0] = _128;
    _120 = _135;
    _jump383:;
    int64_t _136;
    // Computing bound for w
    int64_t _137;
    // Computing bound for w
    if (c > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    // Computing bound for x
    if (i > 0) 
    goto _jump387;
    fail_assertion("non-positive loop bound");
    _jump387:;
    _137 = 0;
    int64_t _138 = 0; // x
    int64_t _139 = 0; // w
    _jump388:; // Begin body of loop
    int64_t _140 = 278;
    _137 += _140;
    _138++;
    if (_138 < i)
    goto _jump388;
    _138 = 0;
    _139++;
    if (_139 < c)
    goto _jump388;
    // End body of loop
    int64_t _141 = -_137;
    if (_141 > 0) 
    goto _jump389;
    fail_assertion("non-positive loop bound");
    _jump389:;
    _136 = 0;
    int64_t _142 = 0; // w
    _jump390:; // Begin body of loop
    _136 += g;
    _142++;
    if (_142 < _141)
    goto _jump390;
    // End body of loop
    if (_136 >= 0)
    goto _jump391;
    fail_assertion("negative array index");
    _jump391:;
    if (_136 < _120.d0)
    goto _jump392;
    fail_assertion("index too large");
    _jump392:;
    int64_t _143 = 0;
    _143 *= _120.d0;
    _143 += _136;
    _a1_double _144 = _120.data[_143];
    bool _145 = l();
    _a2_int64_t _146;
    if (!_145)
    goto _jump393;
    _146 = p;
    goto _jump394;
    _jump393:;
    _146 = p;
    _jump394:;
    bool _147 = m(_144, _146);
    bool _148;
    if (!_147)
    goto _jump395;
    bool _151 = l();
    bool _152 = !_151;
    bool _153 = l();
    bool _154 = _152 == _153;
    bool _155 = !_154;
    bool _150 = _155;
    if (0 != _155)
    goto _jump396;
    _a2_bool _156;
    // Computing bound for w
    _156.d0 = _95.d2;
    if (_95.d2 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    // Computing bound for x
    _156.d1 = k;
    if (k > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= _95.d2;
    _157 *= k;
    _157 *= sizeof(bool);
    _156.data = jpl_alloc(_157);
    int64_t _158 = 0; // x
    int64_t _159 = 0; // w
    _jump399:; // Begin body of loop
    bool _160 = true;
    int64_t _161 = 0;
    _161 *= _156.d0;
    _161 += _159;
    _161 *= _156.d1;
    _161 += _158;
    _156.data[_161] = _160;
    _158++;
    if (_158 < k)
    goto _jump399;
    _158 = 0;
    _159++;
    if (_159 < _95.d2)
    goto _jump399;
    // End body of loop
    if (_95.d2 >= 0)
    goto _jump400;
    fail_assertion("negative array index");
    _jump400:;
    if (_95.d2 < _156.d0)
    goto _jump401;
    fail_assertion("index too large");
    _jump401:;
    if (i >= 0)
    goto _jump402;
    fail_assertion("negative array index");
    _jump402:;
    if (i < _156.d1)
    goto _jump403;
    fail_assertion("index too large");
    _jump403:;
    int64_t _162 = 0;
    _162 *= _156.d0;
    _162 += _95.d2;
    _162 *= _156.d1;
    _162 += i;
    bool _163 = _156.data[_162];
    bool _164 = !_163;
    _150 = _164;
    _jump396:;
    bool _149 = _150;
    if (0 != _150)
    goto _jump404;
    bool _165 = false;
    _149 = _165;
    _jump404:;
    bool _166 = !_149;
    _148 = _166;
    goto _jump405;
    _jump395:;
    bool _167 = true;
    _148 = _167;
    _jump405:;
    return _148;
    int64_t _169 = c - p.d1;
    bool _170 = _169 < d;
    bool _168 = _170;
    if (0 != _170)
    goto _jump406;
    bool _171 = true;
    _168 = _171;
    _jump406:;
    if (0 != _168)
    goto _jump407;
    fail_assertion("w");
    _jump407:;
    int64_t _172 = _95.d2 + b;
    bool _173 = _172 == p.d1;
    bool _174;
    if (!_173)
    goto _jump408;
    bool _175 = i == b;
    _174 = _175;
    goto _jump409;
    _jump408:;
    bool _177 = false;
    _a1_double _178;
    if (!_177)
    goto _jump410;
    _178 = n;
    goto _jump411;
    _jump410:;
    _178 = n;
    _jump411:;
    if (_95.d1 >= 0)
    goto _jump412;
    fail_assertion("negative array index");
    _jump412:;
    if (_95.d1 < _178.d0)
    goto _jump413;
    fail_assertion("index too large");
    _jump413:;
    int64_t _179 = 0;
    _179 *= _178.d0;
    _179 += _95.d1;
    double _180 = _178.data[_179];
    double _181 = 89.0;
    bool _182 = true;
    bool _183 = !_182;
    double _184;
    if (!_183)
    goto _jump414;
    double _185 = 80.0;
    double _186 = -_185;
    _184 = _186;
    goto _jump415;
    _jump414:;
    double _187 = 46.0;
    _184 = _187;
    _jump415:;
    double _188 = 5.0;
    rgba _189 = { _180, _181, _184, _188 };
    double _190 = _189.r;
    double _191 = 21.0;
    bool _192 = _190 != _191;
    bool _176 = _192;
    if (0 == _192)
    goto _jump416;
    bool _193 = l();
    _176 = _193;
    _jump416:;
    _174 = _176;
    _jump409:;
    if (0 != _174)
    goto _jump417;
    fail_assertion("z");
    _jump417:;
    bool _194 = false;
    return _194;
}

double p(_a3_rgba q, _a1_void_t u, _a1_rgba w) {
    _a3__a2_int64_t _0;
    // Computing bound for z
    _0.d0 = q.d2;
    if (q.d2 > 0) 
    goto _jump470;
    fail_assertion("non-positive loop bound");
    _jump470:;
    // Computing bound for A
    _0.d1 = b;
    if (b > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing bound for B
    int64_t _1 = 48;
    _0.d2 = _1;
    if (_1 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= q.d2;
    _2 *= b;
    _2 *= _1;
    _2 *= sizeof(_a2_int64_t);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // B
    int64_t _4 = 0; // A
    int64_t _5 = 0; // z
    _jump473:; // Begin body of loop
    _a2_bool _6;
    // Computing bound for C
    _6.d0 = _3;
    if (_3 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing bound for D
    _6.d1 = d;
    if (d > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= _3;
    _7 *= d;
    _7 *= sizeof(bool);
    _6.data = jpl_alloc(_7);
    int64_t _8 = 0; // D
    int64_t _9 = 0; // C
    _jump476:; // Begin body of loop
    bool _10 = true;
    bool _11 = !_10;
    int64_t _12 = 0;
    _12 *= _6.d0;
    _12 += _9;
    _12 *= _6.d1;
    _12 += _8;
    _6.data[_12] = _11;
    _8++;
    if (_8 < d)
    goto _jump476;
    _8 = 0;
    _9++;
    if (_9 < _3)
    goto _jump476;
    // End body of loop
    if (_5 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_5 < _6.d0)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    if (k >= 0)
    goto _jump479;
    fail_assertion("negative array index");
    _jump479:;
    if (k < _6.d1)
    goto _jump480;
    fail_assertion("index too large");
    _jump480:;
    int64_t _13 = 0;
    _13 *= _6.d0;
    _13 += _5;
    _13 *= _6.d1;
    _13 += k;
    bool _14 = _6.data[_13];
    _a3__a2_int64_t _15;
    if (!_14)
    goto _jump481;
    _a3__a2_int64_t _16;
    // Computing bound for C
    _16.d0 = k;
    if (k > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing bound for D
    int64_t _17 = -q.d0;
    _16.d1 = _17;
    if (_17 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    // Computing bound for E
    _16.d2 = i;
    if (i > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= k;
    _18 *= _17;
    _18 *= i;
    _18 *= sizeof(_a2_int64_t);
    _16.data = jpl_alloc(_18);
    int64_t _19 = 0; // E
    int64_t _20 = 0; // D
    int64_t _21 = 0; // C
    _jump485:; // Begin body of loop
    _a2_int64_t _22;
    // Computing bound for F
    _22.d0 = c;
    if (c > 0) 
    goto _jump486;
    fail_assertion("non-positive loop bound");
    _jump486:;
    // Computing bound for G
    _22.d1 = c;
    if (c > 0) 
    goto _jump487;
    fail_assertion("non-positive loop bound");
    _jump487:;
    // Computing total size of heap memory to allocate
    int64_t _23 = 1;
    _23 *= c;
    _23 *= c;
    _23 *= sizeof(int64_t);
    _22.data = jpl_alloc(_23);
    int64_t _24 = 0; // G
    int64_t _25 = 0; // F
    _jump488:; // Begin body of loop
    int64_t _26 = 0;
    _26 *= _22.d0;
    _26 += _25;
    _26 *= _22.d1;
    _26 += _24;
    _22.data[_26] = w.d0;
    _24++;
    if (_24 < c)
    goto _jump488;
    _24 = 0;
    _25++;
    if (_25 < c)
    goto _jump488;
    // End body of loop
    int64_t _27 = 0;
    _27 *= _16.d0;
    _27 += _21;
    _27 *= _16.d1;
    _27 += _20;
    _27 *= _16.d2;
    _27 += _19;
    _16.data[_27] = _22;
    _19++;
    if (_19 < i)
    goto _jump485;
    _19 = 0;
    _20++;
    if (_20 < _17)
    goto _jump485;
    _20 = 0;
    _21++;
    if (_21 < k)
    goto _jump485;
    // End body of loop
    _15 = _16;
    goto _jump489;
    _jump481:;
    _a3__a2_int64_t _28;
    // Computing bound for C
    _28.d0 = _3;
    if (_3 > 0) 
    goto _jump490;
    fail_assertion("non-positive loop bound");
    _jump490:;
    // Computing bound for D
    _28.d1 = q.d1;
    if (q.d1 > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    // Computing bound for E
    _28.d2 = _5;
    if (_5 > 0) 
    goto _jump492;
    fail_assertion("non-positive loop bound");
    _jump492:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _3;
    _29 *= q.d1;
    _29 *= _5;
    _29 *= sizeof(_a2_int64_t);
    _28.data = jpl_alloc(_29);
    int64_t _30 = 0; // E
    int64_t _31 = 0; // D
    int64_t _32 = 0; // C
    _jump493:; // Begin body of loop
    bool _33 = l();
    _a2_int64_t _34;
    if (!_33)
    goto _jump494;
    _a2_int64_t _35;
    // Computing bound for F
    _35.d0 = u.d0;
    if (u.d0 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing bound for G
    _35.d1 = _30;
    if (_30 > 0) 
    goto _jump496;
    fail_assertion("non-positive loop bound");
    _jump496:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= u.d0;
    _36 *= _30;
    _36 *= sizeof(int64_t);
    _35.data = jpl_alloc(_36);
    int64_t _37 = 0; // G
    int64_t _38 = 0; // F
    _jump497:; // Begin body of loop
    int64_t _39 = 0;
    _39 *= _35.d0;
    _39 += _38;
    _39 *= _35.d1;
    _39 += _37;
    _35.data[_39] = i;
    _37++;
    if (_37 < _30)
    goto _jump497;
    _37 = 0;
    _38++;
    if (_38 < u.d0)
    goto _jump497;
    // End body of loop
    _34 = _35;
    goto _jump498;
    _jump494:;
    _a2_int64_t _40;
    // Computing bound for F
    _40.d0 = q.d1;
    if (q.d1 > 0) 
    goto _jump499;
    fail_assertion("non-positive loop bound");
    _jump499:;
    // Computing bound for G
    _40.d1 = _5;
    if (_5 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    // Computing total size of heap memory to allocate
    int64_t _41 = 1;
    _41 *= q.d1;
    _41 *= _5;
    _41 *= sizeof(int64_t);
    _40.data = jpl_alloc(_41);
    int64_t _42 = 0; // G
    int64_t _43 = 0; // F
    _jump501:; // Begin body of loop
    int64_t _44 = 0;
    _44 *= _40.d0;
    _44 += _43;
    _44 *= _40.d1;
    _44 += _42;
    _40.data[_44] = u.d0;
    _42++;
    if (_42 < _5)
    goto _jump501;
    _42 = 0;
    _43++;
    if (_43 < q.d1)
    goto _jump501;
    // End body of loop
    _34 = _40;
    _jump498:;
    int64_t _45 = 0;
    _45 *= _28.d0;
    _45 += _32;
    _45 *= _28.d1;
    _45 += _31;
    _45 *= _28.d2;
    _45 += _30;
    _28.data[_45] = _34;
    _30++;
    if (_30 < _5)
    goto _jump493;
    _30 = 0;
    _31++;
    if (_31 < q.d1)
    goto _jump493;
    _31 = 0;
    _32++;
    if (_32 < _3)
    goto _jump493;
    // End body of loop
    _15 = _28;
    _jump489:;
    if (_3 >= 0)
    goto _jump502;
    fail_assertion("negative array index");
    _jump502:;
    if (_3 < _15.d0)
    goto _jump503;
    fail_assertion("index too large");
    _jump503:;
    if (g >= 0)
    goto _jump504;
    fail_assertion("negative array index");
    _jump504:;
    if (g < _15.d1)
    goto _jump505;
    fail_assertion("index too large");
    _jump505:;
    if (b >= 0)
    goto _jump506;
    fail_assertion("negative array index");
    _jump506:;
    if (b < _15.d2)
    goto _jump507;
    fail_assertion("index too large");
    _jump507:;
    int64_t _46 = 0;
    _46 *= _15.d0;
    _46 += _3;
    _46 *= _15.d1;
    _46 += g;
    _46 *= _15.d2;
    _46 += b;
    _a2_int64_t _47 = _15.data[_46];
    int64_t _48 = 0;
    _48 *= _0.d0;
    _48 += _5;
    _48 *= _0.d1;
    _48 += _4;
    _48 *= _0.d2;
    _48 += _3;
    _0.data[_48] = _47;
    _3++;
    if (_3 < _1)
    goto _jump473;
    _3 = 0;
    _4++;
    if (_4 < b)
    goto _jump473;
    _4 = 0;
    _5++;
    if (_5 < q.d2)
    goto _jump473;
    // End body of loop
    _a1__a2_int64_t _49;
    // Computing bound for z
    _49.d0 = q.d2;
    if (q.d2 > 0) 
    goto _jump508;
    fail_assertion("non-positive loop bound");
    _jump508:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= q.d2;
    _50 *= sizeof(_a2_int64_t);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // z
    _jump509:; // Begin body of loop
    _a2_int64_t _52;
    // Computing bound for A
    _52.d0 = q.d1;
    if (q.d1 > 0) 
    goto _jump510;
    fail_assertion("non-positive loop bound");
    _jump510:;
    // Computing bound for B
    _52.d1 = d;
    if (d > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= q.d1;
    _53 *= d;
    _53 *= sizeof(int64_t);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // B
    int64_t _55 = 0; // A
    _jump512:; // Begin body of loop
    int64_t _56 = 0;
    _56 *= _52.d0;
    _56 += _55;
    _56 *= _52.d1;
    _56 += _54;
    _52.data[_56] = w.d0;
    _54++;
    if (_54 < d)
    goto _jump512;
    _54 = 0;
    _55++;
    if (_55 < q.d1)
    goto _jump512;
    // End body of loop
    int64_t _57 = 0;
    _57 *= _49.d0;
    _57 += _51;
    _49.data[_57] = _52;
    _51++;
    if (_51 < q.d2)
    goto _jump509;
    // End body of loop
    if (k >= 0)
    goto _jump513;
    fail_assertion("negative array index");
    _jump513:;
    if (k < _49.d0)
    goto _jump514;
    fail_assertion("index too large");
    _jump514:;
    int64_t _58 = 0;
    _58 *= _49.d0;
    _58 += k;
    _a2_int64_t _59 = _49.data[_58];
    if (k >= 0)
    goto _jump515;
    fail_assertion("negative array index");
    _jump515:;
    if (k < _59.d0)
    goto _jump516;
    fail_assertion("index too large");
    _jump516:;
    if (k >= 0)
    goto _jump517;
    fail_assertion("negative array index");
    _jump517:;
    if (k < _59.d1)
    goto _jump518;
    fail_assertion("index too large");
    _jump518:;
    int64_t _60 = 0;
    _60 *= _59.d0;
    _60 += k;
    _60 *= _59.d1;
    _60 += k;
    int64_t _61 = _59.data[_60];
    if (q.d1 >= 0)
    goto _jump519;
    fail_assertion("negative array index");
    _jump519:;
    if (q.d1 < _0.d0)
    goto _jump520;
    fail_assertion("index too large");
    _jump520:;
    if (j >= 0)
    goto _jump521;
    fail_assertion("negative array index");
    _jump521:;
    if (j < _0.d1)
    goto _jump522;
    fail_assertion("index too large");
    _jump522:;
    if (_61 >= 0)
    goto _jump523;
    fail_assertion("negative array index");
    _jump523:;
    if (_61 < _0.d2)
    goto _jump524;
    fail_assertion("index too large");
    _jump524:;
    int64_t _62 = 0;
    _62 *= _0.d0;
    _62 += q.d1;
    _62 *= _0.d1;
    _62 += j;
    _62 *= _0.d2;
    _62 += _61;
    _a2_int64_t _63 = _0.data[_62];
    _a3__a1_double _64;
    // Computing bound for C
    _64.d0 = k;
    if (k > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    // Computing bound for D
    int64_t _65;
    // Computing bound for C
    if (w.d0 > 0) 
    goto _jump526;
    fail_assertion("non-positive loop bound");
    _jump526:;
    // Computing bound for D
    if (b > 0) 
    goto _jump527;
    fail_assertion("non-positive loop bound");
    _jump527:;
    // Computing bound for E
    bool _66 = false;
    int64_t _67;
    if (!_66)
    goto _jump528;
    _67 = d;
    goto _jump529;
    _jump528:;
    _67 = j;
    _jump529:;
    if (_67 > 0) 
    goto _jump530;
    fail_assertion("non-positive loop bound");
    _jump530:;
    _65 = 0;
    int64_t _68 = 0; // E
    int64_t _69 = 0; // D
    int64_t _70 = 0; // C
    _jump531:; // Begin body of loop
    _65 += _68;
    _68++;
    if (_68 < _67)
    goto _jump531;
    _68 = 0;
    _69++;
    if (_69 < b)
    goto _jump531;
    _69 = 0;
    _70++;
    if (_70 < w.d0)
    goto _jump531;
    // End body of loop
    _64.d1 = _65;
    if (_65 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    // Computing bound for E
    _64.d2 = b;
    if (b > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= k;
    _71 *= _65;
    _71 *= b;
    _71 *= sizeof(_a1_double);
    _64.data = jpl_alloc(_71);
    int64_t _72 = 0; // E
    int64_t _73 = 0; // D
    int64_t _74 = 0; // C
    _jump534:; // Begin body of loop
    _a1__a1_double _75;
    // Computing bound for F
    _75.d0 = _72;
    if (_72 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    // Computing total size of heap memory to allocate
    int64_t _76 = 1;
    _76 *= _72;
    _76 *= sizeof(_a1_double);
    _75.data = jpl_alloc(_76);
    int64_t _77 = 0; // F
    _jump536:; // Begin body of loop
    double _78 = 61.0;
    double _79 = 31.0;
    _a1_double _80;
    _80.d0 = 2;
    _80.data = jpl_alloc(sizeof(double) * 2);
    _80.data[0] = _78;
    _80.data[1] = _79;
    int64_t _81 = 0;
    _81 *= _75.d0;
    _81 += _77;
    _75.data[_81] = _80;
    _77++;
    if (_77 < _72)
    goto _jump536;
    // End body of loop
    if (j >= 0)
    goto _jump537;
    fail_assertion("negative array index");
    _jump537:;
    if (j < _75.d0)
    goto _jump538;
    fail_assertion("index too large");
    _jump538:;
    int64_t _82 = 0;
    _82 *= _75.d0;
    _82 += j;
    _a1_double _83 = _75.data[_82];
    int64_t _84 = 0;
    _84 *= _64.d0;
    _84 += _74;
    _84 *= _64.d1;
    _84 += _73;
    _84 *= _64.d2;
    _84 += _72;
    _64.data[_84] = _83;
    _72++;
    if (_72 < b)
    goto _jump534;
    _72 = 0;
    _73++;
    if (_73 < _65)
    goto _jump534;
    _73 = 0;
    _74++;
    if (_74 < k)
    goto _jump534;
    // End body of loop
    bool _85 = true;
    _a1_int64_t _86;
    if (!_85)
    goto _jump539;
    _a1_int64_t _87;
    _87.d0 = 2;
    _87.data = jpl_alloc(sizeof(int64_t) * 2);
    _87.data[0] = q.d1;
    _87.data[1] = _63.d0;
    _86 = _87;
    goto _jump540;
    _jump539:;
    _a1_int64_t _88;
    _88.d0 = 1;
    _88.data = jpl_alloc(sizeof(int64_t) * 1);
    _88.data[0] = d;
    _86 = _88;
    _jump540:;
    if (c >= 0)
    goto _jump541;
    fail_assertion("negative array index");
    _jump541:;
    if (c < _86.d0)
    goto _jump542;
    fail_assertion("index too large");
    _jump542:;
    int64_t _89 = 0;
    _89 *= _86.d0;
    _89 += c;
    int64_t _90 = _86.data[_89];
    if (q.d1 >= 0)
    goto _jump543;
    fail_assertion("negative array index");
    _jump543:;
    if (q.d1 < _64.d0)
    goto _jump544;
    fail_assertion("index too large");
    _jump544:;
    if (_90 >= 0)
    goto _jump545;
    fail_assertion("negative array index");
    _jump545:;
    if (_90 < _64.d1)
    goto _jump546;
    fail_assertion("index too large");
    _jump546:;
    if (g >= 0)
    goto _jump547;
    fail_assertion("negative array index");
    _jump547:;
    if (g < _64.d2)
    goto _jump548;
    fail_assertion("index too large");
    _jump548:;
    int64_t _91 = 0;
    _91 *= _64.d0;
    _91 += q.d1;
    _91 *= _64.d1;
    _91 += _90;
    _91 *= _64.d2;
    _91 += g;
    _a1_double _92 = _64.data[_91];
    int64_t _93;
    // Computing bound for C
    bool _94 = false;
    bool _95 = !_94;
    int64_t _96;
    if (!_95)
    goto _jump549;
    _96 = _63.d0;
    goto _jump550;
    _jump549:;
    int64_t _97 = 110;
    _96 = _97;
    _jump550:;
    if (_96 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing bound for D
    if (d > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    // Computing bound for E
    if (q.d1 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    _93 = 0;
    int64_t _98 = 0; // E
    int64_t _99 = 0; // D
    int64_t _100 = 0; // C
    _jump554:; // Begin body of loop
    _93 += _99;
    _98++;
    if (_98 < q.d1)
    goto _jump554;
    _98 = 0;
    _99++;
    if (_99 < d)
    goto _jump554;
    _99 = 0;
    _100++;
    if (_100 < _96)
    goto _jump554;
    // End body of loop
    int64_t _101 = _93 + u.d0;
    if (_101 >= 0)
    goto _jump555;
    fail_assertion("negative array index");
    _jump555:;
    if (_101 < _92.d0)
    goto _jump556;
    fail_assertion("index too large");
    _jump556:;
    int64_t _102 = 0;
    _102 *= _92.d0;
    _102 += _101;
    double _103 = _92.data[_102];
    return _103;
    double _104;
    // Computing bound for C
    if (g > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing bound for D
    if (g > 0) 
    goto _jump558;
    fail_assertion("non-positive loop bound");
    _jump558:;
    _104 = 0;
    int64_t _105 = 0; // D
    int64_t _106 = 0; // C
    _jump559:; // Begin body of loop
    double _107;
    // Computing bound for E
    int64_t _108 = 295;
    if (_108 > 0) 
    goto _jump560;
    fail_assertion("non-positive loop bound");
    _jump560:;
    // Computing bound for F
    if (q.d1 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing bound for G
    if (u.d0 > 0) 
    goto _jump562;
    fail_assertion("non-positive loop bound");
    _jump562:;
    _107 = 0;
    int64_t _109 = 0; // G
    int64_t _110 = 0; // F
    int64_t _111 = 0; // E
    _jump563:; // Begin body of loop
    double _112 = 7.0;
    _107 += _112;
    _109++;
    if (_109 < u.d0)
    goto _jump563;
    _109 = 0;
    _110++;
    if (_110 < q.d1)
    goto _jump563;
    _110 = 0;
    _111++;
    if (_111 < _108)
    goto _jump563;
    // End body of loop
    double _113 = 97.0;
    double _114 = -_113;
    double _115;
    // Computing bound for E
    if (_106 > 0) 
    goto _jump564;
    fail_assertion("non-positive loop bound");
    _jump564:;
    _115 = 0;
    int64_t _116 = 0; // E
    _jump565:; // Begin body of loop
    double _117 = 53.0;
    _115 += _117;
    _116++;
    if (_116 < _106)
    goto _jump565;
    // End body of loop
    double _118;
    // Computing bound for E
    if (j > 0) 
    goto _jump566;
    fail_assertion("non-positive loop bound");
    _jump566:;
    // Computing bound for F
    if (c > 0) 
    goto _jump567;
    fail_assertion("non-positive loop bound");
    _jump567:;
    // Computing bound for G
    if (d > 0) 
    goto _jump568;
    fail_assertion("non-positive loop bound");
    _jump568:;
    _118 = 0;
    int64_t _119 = 0; // G
    int64_t _120 = 0; // F
    int64_t _121 = 0; // E
    _jump569:; // Begin body of loop
    double _122 = 13.0;
    _118 += _122;
    _119++;
    if (_119 < d)
    goto _jump569;
    _119 = 0;
    _120++;
    if (_120 < c)
    goto _jump569;
    _120 = 0;
    _121++;
    if (_121 < j)
    goto _jump569;
    // End body of loop
    rgba _123 = { _107, _114, _115, _118 };
    double _124 = _123.a;
    _104 += _124;
    _105++;
    if (_105 < g)
    goto _jump559;
    _105 = 0;
    _106++;
    if (_106 < g)
    goto _jump559;
    // End body of loop
    double _125 = 3.0;
    double _126 = -_125;
    double _127 = -_126;
    double _128 = p(q, u, w);
    double _129 = -_128;
    _a1_double _130;
    _130.d0 = 2;
    _130.data = jpl_alloc(sizeof(double) * 2);
    _130.data[0] = _127;
    _130.data[1] = _129;
    if (_63.d1 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (_63.d1 < _130.d0)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    int64_t _131 = 0;
    _131 *= _130.d0;
    _131 += _63.d1;
    double _132 = _130.data[_131];
    double _133;
    // Computing bound for C
    if (u.d0 > 0) 
    goto _jump572;
    fail_assertion("non-positive loop bound");
    _jump572:;
    // Computing bound for D
    if (w.d0 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    _133 = 0;
    int64_t _134 = 0; // D
    int64_t _135 = 0; // C
    _jump574:; // Begin body of loop
    double _136 = p(q, u, w);
    double _137 = 42.0;
    double _138 = -_137;
    double _139 = fmod(_136, _138);
    double _140 = -_139;
    _133 += _140;
    _134++;
    if (_134 < w.d0)
    goto _jump574;
    _134 = 0;
    _135++;
    if (_135 < u.d0)
    goto _jump574;
    // End body of loop
    double _141;
    // Computing bound for C
    int64_t _142 = 256;
    if (_142 > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    // Computing bound for D
    if (i > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing bound for E
    int64_t _143;
    // Computing bound for C
    if (_63.d0 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing bound for D
    int64_t _144 = 344;
    if (_144 > 0) 
    goto _jump578;
    fail_assertion("non-positive loop bound");
    _jump578:;
    _143 = 0;
    int64_t _145 = 0; // D
    int64_t _146 = 0; // C
    _jump579:; // Begin body of loop
    _143 += b;
    _145++;
    if (_145 < _144)
    goto _jump579;
    _145 = 0;
    _146++;
    if (_146 < _63.d0)
    goto _jump579;
    // End body of loop
    if (_143 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    _141 = 0;
    int64_t _147 = 0; // E
    int64_t _148 = 0; // D
    int64_t _149 = 0; // C
    _jump581:; // Begin body of loop
    if (q.d0 >= 0)
    goto _jump582;
    fail_assertion("negative array index");
    _jump582:;
    if (q.d0 < q.d0)
    goto _jump583;
    fail_assertion("index too large");
    _jump583:;
    if (q.d1 >= 0)
    goto _jump584;
    fail_assertion("negative array index");
    _jump584:;
    if (q.d1 < q.d1)
    goto _jump585;
    fail_assertion("index too large");
    _jump585:;
    if (w.d0 >= 0)
    goto _jump586;
    fail_assertion("negative array index");
    _jump586:;
    if (w.d0 < q.d2)
    goto _jump587;
    fail_assertion("index too large");
    _jump587:;
    int64_t _150 = 0;
    _150 *= q.d0;
    _150 += q.d0;
    _150 *= q.d1;
    _150 += q.d1;
    _150 *= q.d2;
    _150 += w.d0;
    rgba _151 = q.data[_150];
    double _152 = _151.r;
    _141 += _152;
    _147++;
    if (_147 < _143)
    goto _jump581;
    _147 = 0;
    _148++;
    if (_148 < i)
    goto _jump581;
    _148 = 0;
    _149++;
    if (_149 < _142)
    goto _jump581;
    // End body of loop
    rgba _153 = { _104, _132, _133, _141 };
    double _154 = _153.b;
    double _155 = 31.0;
    _a1__a2_double _156;
    // Computing bound for C
    int64_t _157 = -_63.d1;
    _156.d0 = _157;
    if (_157 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= _157;
    _158 *= sizeof(_a2_double);
    _156.data = jpl_alloc(_158);
    int64_t _159 = 0; // C
    _jump589:; // Begin body of loop
    _a2_double _160;
    // Computing bound for D
    int64_t _161;
    // Computing bound for D
    if (d > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing bound for E
    if (q.d1 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for F
    if (_63.d1 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    _161 = 0;
    int64_t _162 = 0; // F
    int64_t _163 = 0; // E
    int64_t _164 = 0; // D
    _jump593:; // Begin body of loop
    _161 += d;
    _162++;
    if (_162 < _63.d1)
    goto _jump593;
    _162 = 0;
    _163++;
    if (_163 < q.d1)
    goto _jump593;
    _163 = 0;
    _164++;
    if (_164 < d)
    goto _jump593;
    // End body of loop
    _160.d0 = _161;
    if (_161 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing bound for E
    int64_t _165 = 69;
    _160.d1 = _165;
    if (_165 > 0) 
    goto _jump595;
    fail_assertion("non-positive loop bound");
    _jump595:;
    // Computing total size of heap memory to allocate
    int64_t _166 = 1;
    _166 *= _161;
    _166 *= _165;
    _166 *= sizeof(double);
    _160.data = jpl_alloc(_166);
    int64_t _167 = 0; // E
    int64_t _168 = 0; // D
    _jump596:; // Begin body of loop
    double _169 = 91.0;
    double _170 = -_169;
    int64_t _171 = 0;
    _171 *= _160.d0;
    _171 += _168;
    _171 *= _160.d1;
    _171 += _167;
    _160.data[_171] = _170;
    _167++;
    if (_167 < _165)
    goto _jump596;
    _167 = 0;
    _168++;
    if (_168 < _161)
    goto _jump596;
    // End body of loop
    int64_t _172 = 0;
    _172 *= _156.d0;
    _172 += _159;
    _156.data[_172] = _160;
    _159++;
    if (_159 < _157)
    goto _jump589;
    // End body of loop
    if (k >= 0)
    goto _jump597;
    fail_assertion("negative array index");
    _jump597:;
    if (k < _156.d0)
    goto _jump598;
    fail_assertion("index too large");
    _jump598:;
    int64_t _173 = 0;
    _173 *= _156.d0;
    _173 += k;
    _a2_double _174 = _156.data[_173];
    if (k >= 0)
    goto _jump599;
    fail_assertion("negative array index");
    _jump599:;
    if (k < _174.d0)
    goto _jump600;
    fail_assertion("index too large");
    _jump600:;
    if (q.d2 >= 0)
    goto _jump601;
    fail_assertion("negative array index");
    _jump601:;
    if (q.d2 < _174.d1)
    goto _jump602;
    fail_assertion("index too large");
    _jump602:;
    int64_t _175 = 0;
    _175 *= _174.d0;
    _175 += k;
    _175 *= _174.d1;
    _175 += q.d2;
    double _176 = _174.data[_175];
    double _177 = _155 + _176;
    double _178 = _154 / _177;
    return _178;
    double _179 = 6.0;
    return _179;
}

int64_t y() {
    bool _0 = j < j;
    double _1 = 62.0;
    double _2 = 96.0;
    double _3 = _1 * _2;
    double _4;
    // Computing bound for H
    if (b > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    _4 = 0;
    int64_t _5 = 0; // H
    _jump817:; // Begin body of loop
    double _6 = 84.0;
    _4 += _6;
    _5++;
    if (_5 < b)
    goto _jump817;
    // End body of loop
    bool _7 = _3 == _4;
    _a1__a3__a1_int64_t _8;
    if (!_7)
    goto _jump818;
    bool _9 = o < t;
    _a1__a3__a1_int64_t _10;
    if (!_9)
    goto _jump819;
    _a3__a1_int64_t _11;
    if (!_0)
    goto _jump820;
    _11 = a;
    goto _jump821;
    _jump820:;
    _11 = a;
    _jump821:;
    _a1__a3__a1_int64_t _12;
    _12.d0 = 3;
    _12.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 3);
    _12.data[0] = _11;
    _12.data[1] = a;
    _12.data[2] = a;
    _10 = _12;
    goto _jump822;
    _jump819:;
    _a1__a3__a1_int64_t _13;
    // Computing bound for H
    int64_t _14 = y();
    _13.d0 = _14;
    if (_14 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= _14;
    _15 *= sizeof(_a3__a1_int64_t);
    _13.data = jpl_alloc(_15);
    int64_t _16 = 0; // H
    _jump824:; // Begin body of loop
    bool _17 = false;
    _a3__a1_int64_t _18;
    if (!_17)
    goto _jump825;
    _18 = a;
    goto _jump826;
    _jump825:;
    _18 = a;
    _jump826:;
    int64_t _19 = 0;
    _19 *= _13.d0;
    _19 += _16;
    _13.data[_19] = _18;
    _16++;
    if (_16 < _14)
    goto _jump824;
    // End body of loop
    _10 = _13;
    _jump822:;
    _8 = _10;
    goto _jump827;
    _jump818:;
    _a1__a3__a1_int64_t _20;
    // Computing bound for H
    _20.d0 = q;
    if (q > 0) 
    goto _jump828;
    fail_assertion("non-positive loop bound");
    _jump828:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= q;
    _21 *= sizeof(_a3__a1_int64_t);
    _20.data = jpl_alloc(_21);
    int64_t _22 = 0; // H
    _jump829:; // Begin body of loop
    _a2__a3__a1_int64_t _23;
    // Computing bound for I
    _23.d0 = q;
    if (q > 0) 
    goto _jump830;
    fail_assertion("non-positive loop bound");
    _jump830:;
    // Computing bound for J
    _23.d1 = g;
    if (g > 0) 
    goto _jump831;
    fail_assertion("non-positive loop bound");
    _jump831:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= q;
    _24 *= g;
    _24 *= sizeof(_a3__a1_int64_t);
    _23.data = jpl_alloc(_24);
    int64_t _25 = 0; // J
    int64_t _26 = 0; // I
    _jump832:; // Begin body of loop
    int64_t _27 = 0;
    _27 *= _23.d0;
    _27 += _26;
    _27 *= _23.d1;
    _27 += _25;
    _23.data[_27] = a;
    _25++;
    if (_25 < g)
    goto _jump832;
    _25 = 0;
    _26++;
    if (_26 < q)
    goto _jump832;
    // End body of loop
    int64_t _28 = y();
    int64_t _29 = _28 - b;
    if (_29 >= 0)
    goto _jump833;
    fail_assertion("negative array index");
    _jump833:;
    if (_29 < _23.d0)
    goto _jump834;
    fail_assertion("index too large");
    _jump834:;
    if (j >= 0)
    goto _jump835;
    fail_assertion("negative array index");
    _jump835:;
    if (j < _23.d1)
    goto _jump836;
    fail_assertion("index too large");
    _jump836:;
    int64_t _30 = 0;
    _30 *= _23.d0;
    _30 += _29;
    _30 *= _23.d1;
    _30 += j;
    _a3__a1_int64_t _31 = _23.data[_30];
    int64_t _32 = 0;
    _32 *= _20.d0;
    _32 += _22;
    _20.data[_32] = _31;
    _22++;
    if (_22 < q)
    goto _jump829;
    // End body of loop
    _8 = _20;
    _jump827:;
    bool _33 = _0;
    if (0 != _0)
    goto _jump837;
    _a3_bool _34;
    // Computing bound for H
    _34.d0 = a.d0;
    if (a.d0 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing bound for I
    _34.d1 = o;
    if (o > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    // Computing bound for J
    _34.d2 = d;
    if (d > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing total size of heap memory to allocate
    int64_t _35 = 1;
    _35 *= a.d0;
    _35 *= o;
    _35 *= d;
    _35 *= sizeof(bool);
    _34.data = jpl_alloc(_35);
    int64_t _36 = 0; // J
    int64_t _37 = 0; // I
    int64_t _38 = 0; // H
    _jump841:; // Begin body of loop
    int64_t _39 = 0;
    _39 *= _34.d0;
    _39 += _38;
    _39 *= _34.d1;
    _39 += _37;
    _39 *= _34.d2;
    _39 += _36;
    _34.data[_39] = _0;
    _36++;
    if (_36 < d)
    goto _jump841;
    _36 = 0;
    _37++;
    if (_37 < o)
    goto _jump841;
    _37 = 0;
    _38++;
    if (_38 < a.d0)
    goto _jump841;
    // End body of loop
    int64_t _40;
    // Computing bound for H
    if (g > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing bound for I
    if (k > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    _40 = 0;
    int64_t _41 = 0; // I
    int64_t _42 = 0; // H
    _jump844:; // Begin body of loop
    _40 += k;
    _41++;
    if (_41 < k)
    goto _jump844;
    _41 = 0;
    _42++;
    if (_42 < g)
    goto _jump844;
    // End body of loop
    if (_40 >= 0)
    goto _jump845;
    fail_assertion("negative array index");
    _jump845:;
    if (_40 < _34.d0)
    goto _jump846;
    fail_assertion("index too large");
    _jump846:;
    if (j >= 0)
    goto _jump847;
    fail_assertion("negative array index");
    _jump847:;
    if (j < _34.d1)
    goto _jump848;
    fail_assertion("index too large");
    _jump848:;
    if (a.d2 >= 0)
    goto _jump849;
    fail_assertion("negative array index");
    _jump849:;
    if (a.d2 < _34.d2)
    goto _jump850;
    fail_assertion("index too large");
    _jump850:;
    int64_t _43 = 0;
    _43 *= _34.d0;
    _43 += _40;
    _43 *= _34.d1;
    _43 += j;
    _43 *= _34.d2;
    _43 += a.d2;
    bool _44 = _34.data[_43];
    _33 = _44;
    _jump837:;
    _a1__a3__a1_int64_t _45;
    if (!_33)
    goto _jump851;
    _a3__a1__a3__a1_int64_t _46;
    // Computing bound for H
    bool _47 = l();
    int64_t _48;
    if (!_47)
    goto _jump852;
    _48 = g;
    goto _jump853;
    _jump852:;
    _48 = d;
    _jump853:;
    _46.d0 = _48;
    if (_48 > 0) 
    goto _jump854;
    fail_assertion("non-positive loop bound");
    _jump854:;
    // Computing bound for I
    _46.d1 = g;
    if (g > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    // Computing bound for J
    _46.d2 = q;
    if (q > 0) 
    goto _jump856;
    fail_assertion("non-positive loop bound");
    _jump856:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= _48;
    _49 *= g;
    _49 *= q;
    _49 *= sizeof(_a1__a3__a1_int64_t);
    _46.data = jpl_alloc(_49);
    int64_t _50 = 0; // J
    int64_t _51 = 0; // I
    int64_t _52 = 0; // H
    _jump857:; // Begin body of loop
    _a1__a3__a1_int64_t _53;
    _53.d0 = 2;
    _53.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 2);
    _53.data[0] = a;
    _53.data[1] = a;
    int64_t _54 = 0;
    _54 *= _46.d0;
    _54 += _52;
    _54 *= _46.d1;
    _54 += _51;
    _54 *= _46.d2;
    _54 += _50;
    _46.data[_54] = _53;
    _50++;
    if (_50 < q)
    goto _jump857;
    _50 = 0;
    _51++;
    if (_51 < g)
    goto _jump857;
    _51 = 0;
    _52++;
    if (_52 < _48)
    goto _jump857;
    // End body of loop
    if (k >= 0)
    goto _jump858;
    fail_assertion("negative array index");
    _jump858:;
    if (k < _46.d0)
    goto _jump859;
    fail_assertion("index too large");
    _jump859:;
    if (a.d0 >= 0)
    goto _jump860;
    fail_assertion("negative array index");
    _jump860:;
    if (a.d0 < _46.d1)
    goto _jump861;
    fail_assertion("index too large");
    _jump861:;
    if (t >= 0)
    goto _jump862;
    fail_assertion("negative array index");
    _jump862:;
    if (t < _46.d2)
    goto _jump863;
    fail_assertion("index too large");
    _jump863:;
    int64_t _55 = 0;
    _55 *= _46.d0;
    _55 += k;
    _55 *= _46.d1;
    _55 += a.d0;
    _55 *= _46.d2;
    _55 += t;
    _a1__a3__a1_int64_t _56 = _46.data[_55];
    _45 = _56;
    goto _jump864;
    _jump851:;
    if (w >= 0)
    goto _jump865;
    fail_assertion("negative array index");
    _jump865:;
    if (w < e.d0)
    goto _jump866;
    fail_assertion("index too large");
    _jump866:;
    if (w >= 0)
    goto _jump867;
    fail_assertion("negative array index");
    _jump867:;
    if (w < e.d1)
    goto _jump868;
    fail_assertion("index too large");
    _jump868:;
    int64_t _57 = 0;
    _57 *= e.d0;
    _57 += w;
    _57 *= e.d1;
    _57 += w;
    bool _58 = e.data[_57];
    _a1__a3__a1_int64_t _59;
    if (!_58)
    goto _jump869;
    _a1__a3__a1_int64_t _60;
    // Computing bound for H
    _60.d0 = a.d0;
    if (a.d0 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= a.d0;
    _61 *= sizeof(_a3__a1_int64_t);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // H
    _jump871:; // Begin body of loop
    int64_t _63 = 0;
    _63 *= _60.d0;
    _63 += _62;
    _60.data[_63] = a;
    _62++;
    if (_62 < a.d0)
    goto _jump871;
    // End body of loop
    _59 = _60;
    goto _jump872;
    _jump869:;
    if (k >= 0)
    goto _jump873;
    fail_assertion("negative array index");
    _jump873:;
    if (k < u.d0)
    goto _jump874;
    fail_assertion("index too large");
    _jump874:;
    if (b >= 0)
    goto _jump875;
    fail_assertion("negative array index");
    _jump875:;
    if (b < u.d1)
    goto _jump876;
    fail_assertion("index too large");
    _jump876:;
    int64_t _64 = 0;
    _64 *= u.d0;
    _64 += k;
    _64 *= u.d1;
    _64 += b;
    _a3__a1_int64_t _65 = u.data[_64];
    _a1__a3__a1_int64_t _66;
    _66.d0 = 3;
    _66.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 3);
    _66.data[0] = h;
    _66.data[1] = _65;
    _66.data[2] = a;
    _59 = _66;
    _jump872:;
    _45 = _59;
    _jump864:;
    int64_t _67 = 320;
    int64_t _68 = -_67;
    bool _69 = _68 <= d;
    _a1__a3__a1_int64_t _70;
    if (!_69)
    goto _jump877;
    int64_t _71 = y();
    if (_71 >= 0)
    goto _jump878;
    fail_assertion("negative array index");
    _jump878:;
    if (_71 < e.d0)
    goto _jump879;
    fail_assertion("index too large");
    _jump879:;
    if (a.d1 >= 0)
    goto _jump880;
    fail_assertion("negative array index");
    _jump880:;
    if (a.d1 < e.d1)
    goto _jump881;
    fail_assertion("index too large");
    _jump881:;
    int64_t _72 = 0;
    _72 *= e.d0;
    _72 += _71;
    _72 *= e.d1;
    _72 += a.d1;
    bool _73 = e.data[_72];
    bool _74;
    if (!_73)
    goto _jump882;
    if (w >= 0)
    goto _jump883;
    fail_assertion("negative array index");
    _jump883:;
    if (w < e.d0)
    goto _jump884;
    fail_assertion("index too large");
    _jump884:;
    if (k >= 0)
    goto _jump885;
    fail_assertion("negative array index");
    _jump885:;
    if (k < e.d1)
    goto _jump886;
    fail_assertion("index too large");
    _jump886:;
    int64_t _75 = 0;
    _75 *= e.d0;
    _75 += w;
    _75 *= e.d1;
    _75 += k;
    bool _76 = e.data[_75];
    _74 = _76;
    goto _jump887;
    _jump882:;
    bool _77 = true;
    _74 = _77;
    _jump887:;
    _a1__a3__a1_int64_t _78;
    if (!_74)
    goto _jump888;
    _a1__a3__a1_int64_t _79;
    // Computing bound for H
    _79.d0 = a.d1;
    if (a.d1 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= a.d1;
    _80 *= sizeof(_a3__a1_int64_t);
    _79.data = jpl_alloc(_80);
    int64_t _81 = 0; // H
    _jump890:; // Begin body of loop
    int64_t _82 = 0;
    _82 *= _79.d0;
    _82 += _81;
    _79.data[_82] = a;
    _81++;
    if (_81 < a.d1)
    goto _jump890;
    // End body of loop
    _78 = _79;
    goto _jump891;
    _jump888:;
    _a1__a3__a1_int64_t _83;
    _83.d0 = 1;
    _83.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 1);
    _83.data[0] = h;
    _78 = _83;
    _jump891:;
    _70 = _78;
    goto _jump892;
    _jump877:;
    _a1__a3__a1_int64_t _84;
    // Computing bound for H
    _84.d0 = i;
    if (i > 0) 
    goto _jump893;
    fail_assertion("non-positive loop bound");
    _jump893:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= i;
    _85 *= sizeof(_a3__a1_int64_t);
    _84.data = jpl_alloc(_85);
    int64_t _86 = 0; // H
    _jump894:; // Begin body of loop
    int64_t _87 = 0;
    _87 *= _84.d0;
    _87 += _86;
    _84.data[_87] = a;
    _86++;
    if (_86 < i)
    goto _jump894;
    // End body of loop
    if (w >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (w < _84.d0)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    int64_t _88 = 0;
    _88 *= _84.d0;
    _88 += w;
    _a3__a1_int64_t _89 = _84.data[_88];
    bool _91 = false;
    bool _90 = _91;
    if (0 == _91)
    goto _jump897;
    bool _92 = true;
    _90 = _92;
    _jump897:;
    _a3__a1_int64_t _93;
    if (!_90)
    goto _jump898;
    _93 = a;
    goto _jump899;
    _jump898:;
    _93 = a;
    _jump899:;
    _a1__a3__a1_int64_t _94;
    _94.d0 = 2;
    _94.data = jpl_alloc(sizeof(_a3__a1_int64_t) * 2);
    _94.data[0] = _89;
    _94.data[1] = _93;
    _70 = _94;
    _jump892:;
    _a1__a1__a3__a1_int64_t _95;
    _95.d0 = 3;
    _95.data = jpl_alloc(sizeof(_a1__a3__a1_int64_t) * 3);
    _95.data[0] = _8;
    _95.data[1] = _45;
    _95.data[2] = _70;
    if (t >= 0)
    goto _jump900;
    fail_assertion("negative array index");
    _jump900:;
    if (t < _95.d0)
    goto _jump901;
    fail_assertion("index too large");
    _jump901:;
    int64_t _96 = 0;
    _96 *= _95.d0;
    _96 += t;
    _a1__a3__a1_int64_t _97 = _95.data[_96];
    if (d >= 0)
    goto _jump902;
    fail_assertion("negative array index");
    _jump902:;
    if (d < _97.d0)
    goto _jump903;
    fail_assertion("index too large");
    _jump903:;
    int64_t _98 = 0;
    _98 *= _97.d0;
    _98 += d;
    _a3__a1_int64_t _99 = _97.data[_98];
    int64_t _100 = y();
    return _100;
}

rgba z(_a3_rgba A, int64_t E, _a3_void_t F) {
    bool _0 = l();
    _a2_rgba _1;
    if (!_0)
    goto _jump904;
    bool _2 = F.d0 == q;
    _a2_rgba _3;
    if (!_2)
    goto _jump905;
    _a3__a2_rgba _4;
    // Computing bound for L
    _4.d0 = E;
    if (E > 0) 
    goto _jump906;
    fail_assertion("non-positive loop bound");
    _jump906:;
    // Computing bound for M
    int64_t _5 = y();
    _4.d1 = _5;
    if (_5 > 0) 
    goto _jump907;
    fail_assertion("non-positive loop bound");
    _jump907:;
    // Computing bound for N
    _4.d2 = c;
    if (c > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= E;
    _6 *= _5;
    _6 *= c;
    _6 *= sizeof(_a2_rgba);
    _4.data = jpl_alloc(_6);
    int64_t _7 = 0; // N
    int64_t _8 = 0; // M
    int64_t _9 = 0; // L
    _jump909:; // Begin body of loop
    _a2_rgba _10;
    // Computing bound for O
    _10.d0 = k;
    if (k > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for P
    _10.d1 = A.d2;
    if (A.d2 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= k;
    _11 *= A.d2;
    _11 *= sizeof(rgba);
    _10.data = jpl_alloc(_11);
    int64_t _12 = 0; // P
    int64_t _13 = 0; // O
    _jump912:; // Begin body of loop
    int64_t _14 = 0;
    _14 *= _10.d0;
    _14 += _13;
    _14 *= _10.d1;
    _14 += _12;
    _10.data[_14] = x;
    _12++;
    if (_12 < A.d2)
    goto _jump912;
    _12 = 0;
    _13++;
    if (_13 < k)
    goto _jump912;
    // End body of loop
    int64_t _15 = 0;
    _15 *= _4.d0;
    _15 += _9;
    _15 *= _4.d1;
    _15 += _8;
    _15 *= _4.d2;
    _15 += _7;
    _4.data[_15] = _10;
    _7++;
    if (_7 < c)
    goto _jump909;
    _7 = 0;
    _8++;
    if (_8 < _5)
    goto _jump909;
    _8 = 0;
    _9++;
    if (_9 < E)
    goto _jump909;
    // End body of loop
    if (o >= 0)
    goto _jump913;
    fail_assertion("negative array index");
    _jump913:;
    if (o < _4.d0)
    goto _jump914;
    fail_assertion("index too large");
    _jump914:;
    if (E >= 0)
    goto _jump915;
    fail_assertion("negative array index");
    _jump915:;
    if (E < _4.d1)
    goto _jump916;
    fail_assertion("index too large");
    _jump916:;
    if (k >= 0)
    goto _jump917;
    fail_assertion("negative array index");
    _jump917:;
    if (k < _4.d2)
    goto _jump918;
    fail_assertion("index too large");
    _jump918:;
    int64_t _16 = 0;
    _16 *= _4.d0;
    _16 += o;
    _16 *= _4.d1;
    _16 += E;
    _16 *= _4.d2;
    _16 += k;
    _a2_rgba _17 = _4.data[_16];
    _3 = _17;
    goto _jump919;
    _jump905:;
    _a2_rgba _18;
    // Computing bound for L
    _18.d0 = A.d0;
    if (A.d0 > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for M
    _18.d1 = A.d1;
    if (A.d1 > 0) 
    goto _jump921;
    fail_assertion("non-positive loop bound");
    _jump921:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= A.d0;
    _19 *= A.d1;
    _19 *= sizeof(rgba);
    _18.data = jpl_alloc(_19);
    int64_t _20 = 0; // M
    int64_t _21 = 0; // L
    _jump922:; // Begin body of loop
    bool _23 = true;
    bool _22 = _23;
    if (0 != _23)
    goto _jump923;
    bool _24 = false;
    _22 = _24;
    _jump923:;
    rgba _25;
    if (!_22)
    goto _jump924;
    _a2_rgba _26;
    // Computing bound for N
    _26.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for O
    _26.d1 = q;
    if (q > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= n.d0;
    _27 *= q;
    _27 *= sizeof(rgba);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // O
    int64_t _29 = 0; // N
    _jump927:; // Begin body of loop
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += _29;
    _30 *= _26.d1;
    _30 += _28;
    _26.data[_30] = x;
    _28++;
    if (_28 < q)
    goto _jump927;
    _28 = 0;
    _29++;
    if (_29 < n.d0)
    goto _jump927;
    // End body of loop
    if (k >= 0)
    goto _jump928;
    fail_assertion("negative array index");
    _jump928:;
    if (k < _26.d0)
    goto _jump929;
    fail_assertion("index too large");
    _jump929:;
    if (w >= 0)
    goto _jump930;
    fail_assertion("negative array index");
    _jump930:;
    if (w < _26.d1)
    goto _jump931;
    fail_assertion("index too large");
    _jump931:;
    int64_t _31 = 0;
    _31 *= _26.d0;
    _31 += k;
    _31 *= _26.d1;
    _31 += w;
    rgba _32 = _26.data[_31];
    _25 = _32;
    goto _jump932;
    _jump924:;
    bool _33 = l();
    rgba _34;
    if (!_33)
    goto _jump933;
    int64_t _35 = 280;
    if (q >= 0)
    goto _jump934;
    fail_assertion("negative array index");
    _jump934:;
    if (q < A.d0)
    goto _jump935;
    fail_assertion("index too large");
    _jump935:;
    if (_35 >= 0)
    goto _jump936;
    fail_assertion("negative array index");
    _jump936:;
    if (_35 < A.d1)
    goto _jump937;
    fail_assertion("index too large");
    _jump937:;
    if (w >= 0)
    goto _jump938;
    fail_assertion("negative array index");
    _jump938:;
    if (w < A.d2)
    goto _jump939;
    fail_assertion("index too large");
    _jump939:;
    int64_t _36 = 0;
    _36 *= A.d0;
    _36 += q;
    _36 *= A.d1;
    _36 += _35;
    _36 *= A.d2;
    _36 += w;
    rgba _37 = A.data[_36];
    _34 = _37;
    goto _jump940;
    _jump933:;
    _34 = x;
    _jump940:;
    _25 = _34;
    _jump932:;
    int64_t _38 = 0;
    _38 *= _18.d0;
    _38 += _21;
    _38 *= _18.d1;
    _38 += _20;
    _18.data[_38] = _25;
    _20++;
    if (_20 < A.d1)
    goto _jump922;
    _20 = 0;
    _21++;
    if (_21 < A.d0)
    goto _jump922;
    // End body of loop
    _3 = _18;
    _jump919:;
    _1 = _3;
    goto _jump941;
    _jump904:;
    _a2_rgba _39;
    // Computing bound for L
    _39.d0 = F.d2;
    if (F.d2 > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing bound for M
    _39.d1 = A.d2;
    if (A.d2 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= F.d2;
    _40 *= A.d2;
    _40 *= sizeof(rgba);
    _39.data = jpl_alloc(_40);
    int64_t _41 = 0; // M
    int64_t _42 = 0; // L
    _jump944:; // Begin body of loop
    bool _43 = l();
    bool _44 = !_43;
    rgba _45;
    if (!_44)
    goto _jump945;
    _45 = x;
    goto _jump946;
    _jump945:;
    _45 = x;
    _jump946:;
    double _46 = _45.r;
    double _47 = x.b;
    double _48 = x.a;
    bool _49 = true;
    _a3_rgba _50;
    if (!_49)
    goto _jump947;
    _a3_rgba _51;
    // Computing bound for N
    _51.d0 = w;
    if (w > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing bound for O
    _51.d1 = b;
    if (b > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    // Computing bound for P
    _51.d2 = w;
    if (w > 0) 
    goto _jump950;
    fail_assertion("non-positive loop bound");
    _jump950:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= w;
    _52 *= b;
    _52 *= w;
    _52 *= sizeof(rgba);
    _51.data = jpl_alloc(_52);
    int64_t _53 = 0; // P
    int64_t _54 = 0; // O
    int64_t _55 = 0; // N
    _jump951:; // Begin body of loop
    int64_t _56 = 0;
    _56 *= _51.d0;
    _56 += _55;
    _56 *= _51.d1;
    _56 += _54;
    _56 *= _51.d2;
    _56 += _53;
    _51.data[_56] = x;
    _53++;
    if (_53 < w)
    goto _jump951;
    _53 = 0;
    _54++;
    if (_54 < b)
    goto _jump951;
    _54 = 0;
    _55++;
    if (_55 < w)
    goto _jump951;
    // End body of loop
    _50 = _51;
    goto _jump952;
    _jump947:;
    _a3_rgba _57;
    // Computing bound for N
    _57.d0 = A.d2;
    if (A.d2 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    // Computing bound for O
    _57.d1 = o;
    if (o > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing bound for P
    _57.d2 = d;
    if (d > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= A.d2;
    _58 *= o;
    _58 *= d;
    _58 *= sizeof(rgba);
    _57.data = jpl_alloc(_58);
    int64_t _59 = 0; // P
    int64_t _60 = 0; // O
    int64_t _61 = 0; // N
    _jump956:; // Begin body of loop
    int64_t _62 = 0;
    _62 *= _57.d0;
    _62 += _61;
    _62 *= _57.d1;
    _62 += _60;
    _62 *= _57.d2;
    _62 += _59;
    _57.data[_62] = x;
    _59++;
    if (_59 < d)
    goto _jump956;
    _59 = 0;
    _60++;
    if (_60 < o)
    goto _jump956;
    _60 = 0;
    _61++;
    if (_61 < A.d2)
    goto _jump956;
    // End body of loop
    _50 = _57;
    _jump952:;
    _a1_void_t _63;
    // Computing bound for N
    _63.d0 = F.d1;
    if (F.d1 > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= F.d1;
    _64 *= sizeof(void_t);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // N
    _jump958:; // Begin body of loop
    int64_t _66 = 229;
    if (_66 >= 0)
    goto _jump959;
    fail_assertion("negative array index");
    _jump959:;
    if (_66 < F.d0)
    goto _jump960;
    fail_assertion("index too large");
    _jump960:;
    if (b >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (b < F.d1)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    if (q >= 0)
    goto _jump963;
    fail_assertion("negative array index");
    _jump963:;
    if (q < F.d2)
    goto _jump964;
    fail_assertion("index too large");
    _jump964:;
    int64_t _67 = 0;
    _67 *= F.d0;
    _67 += _66;
    _67 *= F.d1;
    _67 += b;
    _67 *= F.d2;
    _67 += q;
    void_t _68 = F.data[_67];
    int64_t _69 = 0;
    _69 *= _63.d0;
    _69 += _65;
    _63.data[_69] = _68;
    _65++;
    if (_65 < F.d1)
    goto _jump958;
    // End body of loop
    _a1_rgba _70;
    // Computing bound for N
    _70.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= n.d0;
    _71 *= sizeof(rgba);
    _70.data = jpl_alloc(_71);
    int64_t _72 = 0; // N
    _jump966:; // Begin body of loop
    int64_t _73 = 0;
    _73 *= _70.d0;
    _73 += _72;
    _70.data[_73] = x;
    _72++;
    if (_72 < n.d0)
    goto _jump966;
    // End body of loop
    double _74 = p(_50, _63, _70);
    rgba _75 = { _46, _47, _48, _74 };
    int64_t _76 = 0;
    _76 *= _39.d0;
    _76 += _42;
    _76 *= _39.d1;
    _76 += _41;
    _39.data[_76] = _75;
    _41++;
    if (_41 < A.d2)
    goto _jump944;
    _41 = 0;
    _42++;
    if (_42 < F.d2)
    goto _jump944;
    // End body of loop
    _1 = _39;
    _jump941:;
    _a2_r _77;
    // Computing bound for L
    int64_t _78 = y();
    _77.d0 = _78;
    if (_78 > 0) 
    goto _jump967;
    fail_assertion("non-positive loop bound");
    _jump967:;
    // Computing bound for M
    _77.d1 = E;
    if (E > 0) 
    goto _jump968;
    fail_assertion("non-positive loop bound");
    _jump968:;
    // Computing total size of heap memory to allocate
    int64_t _79 = 1;
    _79 *= _78;
    _79 *= E;
    _79 *= sizeof(r);
    _77.data = jpl_alloc(_79);
    int64_t _80 = 0; // M
    int64_t _81 = 0; // L
    _jump969:; // Begin body of loop
    bool _82 = true;
    _a3_void_t _83;
    if (!_82)
    goto _jump970;
    _83 = F;
    goto _jump971;
    _jump970:;
    _83 = F;
    _jump971:;
    if (A.d2 >= 0)
    goto _jump972;
    fail_assertion("negative array index");
    _jump972:;
    if (A.d2 < _83.d0)
    goto _jump973;
    fail_assertion("index too large");
    _jump973:;
    if (t >= 0)
    goto _jump974;
    fail_assertion("negative array index");
    _jump974:;
    if (t < _83.d1)
    goto _jump975;
    fail_assertion("index too large");
    _jump975:;
    if (A.d0 >= 0)
    goto _jump976;
    fail_assertion("negative array index");
    _jump976:;
    if (A.d0 < _83.d2)
    goto _jump977;
    fail_assertion("index too large");
    _jump977:;
    int64_t _84 = 0;
    _84 *= _83.d0;
    _84 += A.d2;
    _84 *= _83.d1;
    _84 += t;
    _84 *= _83.d2;
    _84 += A.d0;
    void_t _85 = _83.data[_84];
    r _86 = { _80, _85 };
    int64_t _87 = 0;
    _87 *= _77.d0;
    _87 += _81;
    _87 *= _77.d1;
    _87 += _80;
    _77.data[_87] = _86;
    _80++;
    if (_80 < E)
    goto _jump969;
    _80 = 0;
    _81++;
    if (_81 < _78)
    goto _jump969;
    // End body of loop
    int64_t _88 = 544;
    if (_88 >= 0)
    goto _jump978;
    fail_assertion("negative array index");
    _jump978:;
    if (_88 < _77.d0)
    goto _jump979;
    fail_assertion("index too large");
    _jump979:;
    if (q >= 0)
    goto _jump980;
    fail_assertion("negative array index");
    _jump980:;
    if (q < _77.d1)
    goto _jump981;
    fail_assertion("index too large");
    _jump981:;
    int64_t _89 = 0;
    _89 *= _77.d0;
    _89 += _88;
    _89 *= _77.d1;
    _89 += q;
    r _90 = _77.data[_89];
    int64_t _91 = _90.a;
    if (i >= 0)
    goto _jump982;
    fail_assertion("negative array index");
    _jump982:;
    if (i < _1.d0)
    goto _jump983;
    fail_assertion("index too large");
    _jump983:;
    if (_91 >= 0)
    goto _jump984;
    fail_assertion("negative array index");
    _jump984:;
    if (_91 < _1.d1)
    goto _jump985;
    fail_assertion("index too large");
    _jump985:;
    int64_t _92 = 0;
    _92 *= _1.d0;
    _92 += i;
    _92 *= _1.d1;
    _92 += _91;
    rgba _93 = _1.data[_92];
    return _93;
    _a2_rgba _94;
    // Computing bound for S
    _94.d0 = c;
    if (c > 0) 
    goto _jump986;
    fail_assertion("non-positive loop bound");
    _jump986:;
    // Computing bound for T
    int64_t _95 = i - g;
    _94.d1 = _95;
    if (_95 > 0) 
    goto _jump987;
    fail_assertion("non-positive loop bound");
    _jump987:;
    // Computing total size of heap memory to allocate
    int64_t _96 = 1;
    _96 *= c;
    _96 *= _95;
    _96 *= sizeof(rgba);
    _94.data = jpl_alloc(_96);
    int64_t _97 = 0; // T
    int64_t _98 = 0; // S
    _jump988:; // Begin body of loop
    _a2_rgba _99;
    // Computing bound for U
    _99.d0 = _98;
    if (_98 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing bound for V
    int64_t _100 = c + n.d0;
    _99.d1 = _100;
    if (_100 > 0) 
    goto _jump990;
    fail_assertion("non-positive loop bound");
    _jump990:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _98;
    _101 *= _100;
    _101 *= sizeof(rgba);
    _99.data = jpl_alloc(_101);
    int64_t _102 = 0; // V
    int64_t _103 = 0; // U
    _jump991:; // Begin body of loop
    int64_t _104 = 0;
    _104 *= _99.d0;
    _104 += _103;
    _104 *= _99.d1;
    _104 += _102;
    _99.data[_104] = x;
    _102++;
    if (_102 < _100)
    goto _jump991;
    _102 = 0;
    _103++;
    if (_103 < _98)
    goto _jump991;
    // End body of loop
    _a2_int64_t _105;
    // Computing bound for U
    _105.d0 = F.d1;
    if (F.d1 > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    // Computing bound for V
    _105.d1 = F.d0;
    if (F.d0 > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= F.d1;
    _106 *= F.d0;
    _106 *= sizeof(int64_t);
    _105.data = jpl_alloc(_106);
    int64_t _107 = 0; // V
    int64_t _108 = 0; // U
    _jump994:; // Begin body of loop
    int64_t _109 = 0;
    _109 *= _105.d0;
    _109 += _108;
    _109 *= _105.d1;
    _109 += _107;
    _105.data[_109] = _108;
    _107++;
    if (_107 < F.d0)
    goto _jump994;
    _107 = 0;
    _108++;
    if (_108 < F.d1)
    goto _jump994;
    // End body of loop
    _a2_int64_t _110;
    // Computing bound for U
    _110.d0 = F.d2;
    if (F.d2 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for V
    _110.d1 = F.d0;
    if (F.d0 > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= F.d2;
    _111 *= F.d0;
    _111 *= sizeof(int64_t);
    _110.data = jpl_alloc(_111);
    int64_t _112 = 0; // V
    int64_t _113 = 0; // U
    _jump997:; // Begin body of loop
    int64_t _114 = 0;
    _114 *= _110.d0;
    _114 += _113;
    _114 *= _110.d1;
    _114 += _112;
    _110.data[_114] = F.d2;
    _112++;
    if (_112 < F.d0)
    goto _jump997;
    _112 = 0;
    _113++;
    if (_113 < F.d2)
    goto _jump997;
    // End body of loop
    _a1__a2_int64_t _115;
    _115.d0 = 2;
    _115.data = jpl_alloc(sizeof(_a2_int64_t) * 2);
    _115.data[0] = _105;
    _115.data[1] = _110;
    if (j >= 0)
    goto _jump998;
    fail_assertion("negative array index");
    _jump998:;
    if (j < _115.d0)
    goto _jump999;
    fail_assertion("index too large");
    _jump999:;
    int64_t _116 = 0;
    _116 *= _115.d0;
    _116 += j;
    _a2_int64_t _117 = _115.data[_116];
    int64_t _118;
    // Computing bound for U
    if (F.d0 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    _118 = 0;
    int64_t _119 = 0; // U
    _jump1001:; // Begin body of loop
    _118 += g;
    _119++;
    if (_119 < F.d0)
    goto _jump1001;
    // End body of loop
    if (A.d0 >= 0)
    goto _jump1002;
    fail_assertion("negative array index");
    _jump1002:;
    if (A.d0 < _117.d0)
    goto _jump1003;
    fail_assertion("index too large");
    _jump1003:;
    if (_118 >= 0)
    goto _jump1004;
    fail_assertion("negative array index");
    _jump1004:;
    if (_118 < _117.d1)
    goto _jump1005;
    fail_assertion("index too large");
    _jump1005:;
    int64_t _120 = 0;
    _120 *= _117.d0;
    _120 += A.d0;
    _120 *= _117.d1;
    _120 += _118;
    int64_t _121 = _117.data[_120];
    if (A.d0 >= 0)
    goto _jump1006;
    fail_assertion("negative array index");
    _jump1006:;
    if (A.d0 < _99.d0)
    goto _jump1007;
    fail_assertion("index too large");
    _jump1007:;
    if (_121 >= 0)
    goto _jump1008;
    fail_assertion("negative array index");
    _jump1008:;
    if (_121 < _99.d1)
    goto _jump1009;
    fail_assertion("index too large");
    _jump1009:;
    int64_t _122 = 0;
    _122 *= _99.d0;
    _122 += A.d0;
    _122 *= _99.d1;
    _122 += _121;
    rgba _123 = _99.data[_122];
    int64_t _124 = 0;
    _124 *= _94.d0;
    _124 += _98;
    _124 *= _94.d1;
    _124 += _97;
    _94.data[_124] = _123;
    _97++;
    if (_97 < _95)
    goto _jump988;
    _97 = 0;
    _98++;
    if (_98 < c)
    goto _jump988;
    // End body of loop
    _a3__a3_int64_t _125;
    // Computing bound for S
    _125.d0 = E;
    if (E > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for T
    int64_t _126;
    // Computing bound for S
    if (F.d0 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    // Computing bound for T
    if (j > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    _126 = 0;
    int64_t _127 = 0; // T
    int64_t _128 = 0; // S
    _jump1013:; // Begin body of loop
    int64_t _129 = -q;
    int64_t _130 = _129 - n.d0;
    _126 += _130;
    _127++;
    if (_127 < j)
    goto _jump1013;
    _127 = 0;
    _128++;
    if (_128 < F.d0)
    goto _jump1013;
    // End body of loop
    _125.d1 = _126;
    if (_126 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing bound for U
    _125.d2 = j;
    if (j > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= E;
    _131 *= _126;
    _131 *= j;
    _131 *= sizeof(_a3_int64_t);
    _125.data = jpl_alloc(_131);
    int64_t _132 = 0; // U
    int64_t _133 = 0; // T
    int64_t _134 = 0; // S
    _jump1016:; // Begin body of loop
    _a3_int64_t _135;
    // Computing bound for V
    _135.d0 = _133;
    if (_133 > 0) 
    goto _jump1017;
    fail_assertion("non-positive loop bound");
    _jump1017:;
    // Computing bound for W
    _135.d1 = A.d0;
    if (A.d0 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    // Computing bound for X
    _135.d2 = q;
    if (q > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _133;
    _136 *= A.d0;
    _136 *= q;
    _136 *= sizeof(int64_t);
    _135.data = jpl_alloc(_136);
    int64_t _137 = 0; // X
    int64_t _138 = 0; // W
    int64_t _139 = 0; // V
    _jump1020:; // Begin body of loop
    int64_t _140 = 0;
    _140 *= _135.d0;
    _140 += _139;
    _140 *= _135.d1;
    _140 += _138;
    _140 *= _135.d2;
    _140 += _137;
    _135.data[_140] = c;
    _137++;
    if (_137 < q)
    goto _jump1020;
    _137 = 0;
    _138++;
    if (_138 < A.d0)
    goto _jump1020;
    _138 = 0;
    _139++;
    if (_139 < _133)
    goto _jump1020;
    // End body of loop
    _a1__a3_int64_t _141;
    _141.d0 = 1;
    _141.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _141.data[0] = _135;
    if (F.d2 >= 0)
    goto _jump1021;
    fail_assertion("negative array index");
    _jump1021:;
    if (F.d2 < _141.d0)
    goto _jump1022;
    fail_assertion("index too large");
    _jump1022:;
    int64_t _142 = 0;
    _142 *= _141.d0;
    _142 += F.d2;
    _a3_int64_t _143 = _141.data[_142];
    int64_t _144 = 0;
    _144 *= _125.d0;
    _144 += _134;
    _144 *= _125.d1;
    _144 += _133;
    _144 *= _125.d2;
    _144 += _132;
    _125.data[_144] = _143;
    _132++;
    if (_132 < j)
    goto _jump1016;
    _132 = 0;
    _133++;
    if (_133 < _126)
    goto _jump1016;
    _133 = 0;
    _134++;
    if (_134 < E)
    goto _jump1016;
    // End body of loop
    if (n.d0 >= 0)
    goto _jump1023;
    fail_assertion("negative array index");
    _jump1023:;
    if (n.d0 < _125.d0)
    goto _jump1024;
    fail_assertion("index too large");
    _jump1024:;
    if (g >= 0)
    goto _jump1025;
    fail_assertion("negative array index");
    _jump1025:;
    if (g < _125.d1)
    goto _jump1026;
    fail_assertion("index too large");
    _jump1026:;
    if (d >= 0)
    goto _jump1027;
    fail_assertion("negative array index");
    _jump1027:;
    if (d < _125.d2)
    goto _jump1028;
    fail_assertion("index too large");
    _jump1028:;
    int64_t _145 = 0;
    _145 *= _125.d0;
    _145 += n.d0;
    _145 *= _125.d1;
    _145 += g;
    _145 *= _125.d2;
    _145 += d;
    _a3_int64_t _146 = _125.data[_145];
    int64_t _147 = -F.d0;
    if (_147 >= 0)
    goto _jump1029;
    fail_assertion("negative array index");
    _jump1029:;
    if (_147 < _146.d0)
    goto _jump1030;
    fail_assertion("index too large");
    _jump1030:;
    if (n.d0 >= 0)
    goto _jump1031;
    fail_assertion("negative array index");
    _jump1031:;
    if (n.d0 < _146.d1)
    goto _jump1032;
    fail_assertion("index too large");
    _jump1032:;
    if (q >= 0)
    goto _jump1033;
    fail_assertion("negative array index");
    _jump1033:;
    if (q < _146.d2)
    goto _jump1034;
    fail_assertion("index too large");
    _jump1034:;
    int64_t _148 = 0;
    _148 *= _146.d0;
    _148 += _147;
    _148 *= _146.d1;
    _148 += n.d0;
    _148 *= _146.d2;
    _148 += q;
    int64_t _149 = _146.data[_148];
    if (_149 >= 0)
    goto _jump1035;
    fail_assertion("negative array index");
    _jump1035:;
    if (_149 < _94.d0)
    goto _jump1036;
    fail_assertion("index too large");
    _jump1036:;
    if (F.d2 >= 0)
    goto _jump1037;
    fail_assertion("negative array index");
    _jump1037:;
    if (F.d2 < _94.d1)
    goto _jump1038;
    fail_assertion("index too large");
    _jump1038:;
    int64_t _150 = 0;
    _150 *= _94.d0;
    _150 += _149;
    _150 *= _94.d1;
    _150 += F.d2;
    rgba _151 = _94.data[_150];
    return _151;
}

int64_t A(_a1_double B) {
    _a1__a1_bool _0;
    // Computing bound for D
    _a1_int64_t _1;
    // Computing bound for D
    int64_t _2;
    // Computing bound for D
    int64_t _3 = y();
    if (_3 > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    _2 = 0;
    int64_t _4 = 0; // D
    _jump1040:; // Begin body of loop
    bool _5 = t == q;
    int64_t _6;
    if (!_5)
    goto _jump1041;
    int64_t _7 = -k;
    _6 = _7;
    goto _jump1042;
    _jump1041:;
    _6 = q;
    _jump1042:;
    _2 += _6;
    _4++;
    if (_4 < _3)
    goto _jump1040;
    // End body of loop
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing total size of heap memory to allocate
    int64_t _8 = 1;
    _8 *= _2;
    _8 *= sizeof(int64_t);
    _1.data = jpl_alloc(_8);
    int64_t _9 = 0; // D
    _jump1044:; // Begin body of loop
    int64_t _10 = 0;
    _10 *= _1.d0;
    _10 += _9;
    _1.data[_10] = q;
    _9++;
    if (_9 < _2)
    goto _jump1044;
    // End body of loop
    if (o >= 0)
    goto _jump1045;
    fail_assertion("negative array index");
    _jump1045:;
    if (o < _1.d0)
    goto _jump1046;
    fail_assertion("index too large");
    _jump1046:;
    int64_t _11 = 0;
    _11 *= _1.d0;
    _11 += o;
    int64_t _12 = _1.data[_11];
    _0.d0 = _12;
    if (_12 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _12;
    _13 *= sizeof(_a1_bool);
    _0.data = jpl_alloc(_13);
    int64_t _14 = 0; // D
    _jump1048:; // Begin body of loop
    int64_t _15 = 0;
    _15 *= _0.d0;
    _15 += _14;
    _0.data[_15] = s;
    _14++;
    if (_14 < _12)
    goto _jump1048;
    // End body of loop
    _a2_int64_t _16;
    // Computing bound for E
    _16.d0 = q;
    if (q > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    // Computing bound for F
    int64_t _17 = -w;
    _16.d1 = _17;
    if (_17 > 0) 
    goto _jump1050;
    fail_assertion("non-positive loop bound");
    _jump1050:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= q;
    _18 *= _17;
    _18 *= sizeof(int64_t);
    _16.data = jpl_alloc(_18);
    int64_t _19 = 0; // F
    int64_t _20 = 0; // E
    _jump1051:; // Begin body of loop
    int64_t _21 = 0;
    _21 *= _16.d0;
    _21 += _20;
    _21 *= _16.d1;
    _21 += _19;
    _16.data[_21] = g;
    _19++;
    if (_19 < _17)
    goto _jump1051;
    _19 = 0;
    _20++;
    if (_20 < q)
    goto _jump1051;
    // End body of loop
    return t;
    bool _22 = true;
    bool _23;
    if (!_22)
    goto _jump1052;
    _a1__a2_bool _24;
    // Computing bound for I
    int64_t _25 = 985;
    _24.d0 = _25;
    if (_25 > 0) 
    goto _jump1053;
    fail_assertion("non-positive loop bound");
    _jump1053:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= _25;
    _26 *= sizeof(_a2_bool);
    _24.data = jpl_alloc(_26);
    int64_t _27 = 0; // I
    _jump1054:; // Begin body of loop
    int64_t _28 = 0;
    _28 *= _24.d0;
    _28 += _27;
    _24.data[_28] = e;
    _27++;
    if (_27 < _25)
    goto _jump1054;
    // End body of loop
    int64_t _29 = y();
    if (_29 >= 0)
    goto _jump1055;
    fail_assertion("negative array index");
    _jump1055:;
    if (_29 < _24.d0)
    goto _jump1056;
    fail_assertion("index too large");
    _jump1056:;
    int64_t _30 = 0;
    _30 *= _24.d0;
    _30 += _29;
    _a2_bool _31 = _24.data[_30];
    int64_t _32 = -w;
    if (_32 >= 0)
    goto _jump1057;
    fail_assertion("negative array index");
    _jump1057:;
    if (_32 < _31.d0)
    goto _jump1058;
    fail_assertion("index too large");
    _jump1058:;
    if (i >= 0)
    goto _jump1059;
    fail_assertion("negative array index");
    _jump1059:;
    if (i < _31.d1)
    goto _jump1060;
    fail_assertion("index too large");
    _jump1060:;
    int64_t _33 = 0;
    _33 *= _31.d0;
    _33 += _32;
    _33 *= _31.d1;
    _33 += i;
    bool _34 = _31.data[_33];
    _23 = _34;
    goto _jump1061;
    _jump1052:;
    bool _35 = false;
    _23 = _35;
    _jump1061:;
    _a2_int64_t _36;
    if (!_23)
    goto _jump1062;
    _a2__a1__a2_int64_t _37;
    // Computing bound for I
    int64_t _38 = c + d;
    _37.d0 = _38;
    if (_38 > 0) 
    goto _jump1063;
    fail_assertion("non-positive loop bound");
    _jump1063:;
    // Computing bound for J
    int64_t _39 = A(B);
    _37.d1 = _39;
    if (_39 > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= _38;
    _40 *= _39;
    _40 *= sizeof(_a1__a2_int64_t);
    _37.data = jpl_alloc(_40);
    int64_t _41 = 0; // J
    int64_t _42 = 0; // I
    _jump1065:; // Begin body of loop
    _a1__a2_int64_t _43;
    // Computing bound for K
    int64_t _44 = y();
    _43.d0 = _44;
    if (_44 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing total size of heap memory to allocate
    int64_t _45 = 1;
    _45 *= _44;
    _45 *= sizeof(_a2_int64_t);
    _43.data = jpl_alloc(_45);
    int64_t _46 = 0; // K
    _jump1067:; // Begin body of loop
    _a2_int64_t _47;
    // Computing bound for L
    _47.d0 = t;
    if (t > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing bound for M
    _47.d1 = g;
    if (g > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= t;
    _48 *= g;
    _48 *= sizeof(int64_t);
    _47.data = jpl_alloc(_48);
    int64_t _49 = 0; // M
    int64_t _50 = 0; // L
    _jump1070:; // Begin body of loop
    int64_t _51 = 0;
    _51 *= _47.d0;
    _51 += _50;
    _51 *= _47.d1;
    _51 += _49;
    _47.data[_51] = i;
    _49++;
    if (_49 < g)
    goto _jump1070;
    _49 = 0;
    _50++;
    if (_50 < t)
    goto _jump1070;
    // End body of loop
    int64_t _52 = 0;
    _52 *= _43.d0;
    _52 += _46;
    _43.data[_52] = _47;
    _46++;
    if (_46 < _44)
    goto _jump1067;
    // End body of loop
    int64_t _53 = 0;
    _53 *= _37.d0;
    _53 += _42;
    _53 *= _37.d1;
    _53 += _41;
    _37.data[_53] = _43;
    _41++;
    if (_41 < _39)
    goto _jump1065;
    _41 = 0;
    _42++;
    if (_42 < _38)
    goto _jump1065;
    // End body of loop
    if (b >= 0)
    goto _jump1071;
    fail_assertion("negative array index");
    _jump1071:;
    if (b < _37.d0)
    goto _jump1072;
    fail_assertion("index too large");
    _jump1072:;
    if (w >= 0)
    goto _jump1073;
    fail_assertion("negative array index");
    _jump1073:;
    if (w < _37.d1)
    goto _jump1074;
    fail_assertion("index too large");
    _jump1074:;
    int64_t _54 = 0;
    _54 *= _37.d0;
    _54 += b;
    _54 *= _37.d1;
    _54 += w;
    _a1__a2_int64_t _55 = _37.data[_54];
    if (c >= 0)
    goto _jump1075;
    fail_assertion("negative array index");
    _jump1075:;
    if (c < _55.d0)
    goto _jump1076;
    fail_assertion("index too large");
    _jump1076:;
    int64_t _56 = 0;
    _56 *= _55.d0;
    _56 += c;
    _a2_int64_t _57 = _55.data[_56];
    _36 = _57;
    goto _jump1077;
    _jump1062:;
    _36 = _16;
    _jump1077:;
    bool _58 = m(B, _36);
    if (0 != _58)
    goto _jump1078;
    fail_assertion("I");
    _jump1078:;
    return s.d0;
}

bool B() {
    int64_t _0 = 881;
    bool _1 = t == _0;
    if (j >= 0)
    goto _jump1079;
    fail_assertion("negative array index");
    _jump1079:;
    if (j < e.d0)
    goto _jump1080;
    fail_assertion("index too large");
    _jump1080:;
    if (o >= 0)
    goto _jump1081;
    fail_assertion("negative array index");
    _jump1081:;
    if (o < e.d1)
    goto _jump1082;
    fail_assertion("index too large");
    _jump1082:;
    int64_t _2 = 0;
    _2 *= e.d0;
    _2 += j;
    _2 *= e.d1;
    _2 += o;
    bool _3 = e.data[_2];
    bool _4;
    if (!_3)
    goto _jump1083;
    bool _5 = b == w;
    _4 = _5;
    goto _jump1084;
    _jump1083:;
    bool _6 = l();
    _4 = _6;
    _jump1084:;
    bool _7 = _1 == _4;
    bool _8 = l();
    bool _9 = _7 != _8;
    double _10;
    if (!_9)
    goto _jump1085;
    double _11 = 83.0;
    double _12 = 74.0;
    _a1_double _13;
    _13.d0 = 1;
    _13.data = jpl_alloc(sizeof(double) * 1);
    _13.data[0] = _12;
    if (j >= 0)
    goto _jump1086;
    fail_assertion("negative array index");
    _jump1086:;
    if (j < _13.d0)
    goto _jump1087;
    fail_assertion("index too large");
    _jump1087:;
    int64_t _14 = 0;
    _14 *= _13.d0;
    _14 += j;
    double _15 = _13.data[_14];
    bool _16 = _11 < _15;
    double _17;
    if (!_16)
    goto _jump1088;
    bool _19 = B();
    bool _18 = _19;
    if (0 == _19)
    goto _jump1089;
    bool _20 = l();
    _18 = _20;
    _jump1089:;
    bool _21;
    if (!_18)
    goto _jump1090;
    bool _22 = true;
    _21 = _22;
    goto _jump1091;
    _jump1090:;
    if (t >= 0)
    goto _jump1092;
    fail_assertion("negative array index");
    _jump1092:;
    if (t < e.d0)
    goto _jump1093;
    fail_assertion("index too large");
    _jump1093:;
    if (i >= 0)
    goto _jump1094;
    fail_assertion("negative array index");
    _jump1094:;
    if (i < e.d1)
    goto _jump1095;
    fail_assertion("index too large");
    _jump1095:;
    int64_t _23 = 0;
    _23 *= e.d0;
    _23 += t;
    _23 *= e.d1;
    _23 += i;
    bool _24 = e.data[_23];
    _21 = _24;
    _jump1091:;
    double _25;
    if (!_21)
    goto _jump1096;
    bool _26 = false;
    bool _27;
    if (!_26)
    goto _jump1097;
    bool _28 = B();
    _27 = _28;
    goto _jump1098;
    _jump1097:;
    bool _29 = B();
    _27 = _29;
    _jump1098:;
    double _30;
    if (!_27)
    goto _jump1099;
    double _31 = x.g;
    _30 = _31;
    goto _jump1100;
    _jump1099:;
    double _32 = x.g;
    _30 = _32;
    _jump1100:;
    _25 = _30;
    goto _jump1101;
    _jump1096:;
    double _33 = x.a;
    double _34 = -_33;
    _25 = _34;
    _jump1101:;
    _17 = _25;
    goto _jump1102;
    _jump1088:;
    bool _35 = B();
    double _36;
    if (!_35)
    goto _jump1103;
    double _37 = 65.0;
    _36 = _37;
    goto _jump1104;
    _jump1103:;
    double _38;
    // Computing bound for C
    if (i > 0) 
    goto _jump1105;
    fail_assertion("non-positive loop bound");
    _jump1105:;
    // Computing bound for D
    if (d > 0) 
    goto _jump1106;
    fail_assertion("non-positive loop bound");
    _jump1106:;
    _38 = 0;
    int64_t _39 = 0; // D
    int64_t _40 = 0; // C
    _jump1107:; // Begin body of loop
    double _41;
    // Computing bound for E
    int64_t _42 = y();
    if (_42 > 0) 
    goto _jump1108;
    fail_assertion("non-positive loop bound");
    _jump1108:;
    // Computing bound for F
    if (o > 0) 
    goto _jump1109;
    fail_assertion("non-positive loop bound");
    _jump1109:;
    _41 = 0;
    int64_t _43 = 0; // F
    int64_t _44 = 0; // E
    _jump1110:; // Begin body of loop
    double _45 = 31.0;
    _41 += _45;
    _43++;
    if (_43 < o)
    goto _jump1110;
    _43 = 0;
    _44++;
    if (_44 < _42)
    goto _jump1110;
    // End body of loop
    _38 += _41;
    _39++;
    if (_39 < d)
    goto _jump1107;
    _39 = 0;
    _40++;
    if (_40 < i)
    goto _jump1107;
    // End body of loop
    _36 = _38;
    _jump1104:;
    _17 = _36;
    _jump1102:;
    _10 = _17;
    goto _jump1111;
    _jump1085:;
    bool _46 = B();
    _a1_double _47;
    if (!_46)
    goto _jump1112;
    _a1_double _48;
    // Computing bound for C
    _48.d0 = v;
    if (v > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= v;
    _49 *= sizeof(double);
    _48.data = jpl_alloc(_49);
    int64_t _50 = 0; // C
    _jump1114:; // Begin body of loop
    double _51 = x.g;
    int64_t _52 = 0;
    _52 *= _48.d0;
    _52 += _50;
    _48.data[_52] = _51;
    _50++;
    if (_50 < v)
    goto _jump1114;
    // End body of loop
    _47 = _48;
    goto _jump1115;
    _jump1112:;
    double _53 = x.a;
    double _54 = x.a;
    double _55;
    // Computing bound for C
    if (j > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for D
    if (i > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for E
    if (j > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    _55 = 0;
    int64_t _56 = 0; // E
    int64_t _57 = 0; // D
    int64_t _58 = 0; // C
    _jump1119:; // Begin body of loop
    double _59 = 79.0;
    _55 += _59;
    _56++;
    if (_56 < j)
    goto _jump1119;
    _56 = 0;
    _57++;
    if (_57 < i)
    goto _jump1119;
    _57 = 0;
    _58++;
    if (_58 < j)
    goto _jump1119;
    // End body of loop
    _a1_double _60;
    _60.d0 = 3;
    _60.data = jpl_alloc(sizeof(double) * 3);
    _60.data[0] = _53;
    _60.data[1] = _54;
    _60.data[2] = _55;
    _47 = _60;
    _jump1115:;
    _a1_double _61;
    // Computing bound for C
    _61.d0 = i;
    if (i > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing total size of heap memory to allocate
    int64_t _62 = 1;
    _62 *= i;
    _62 *= sizeof(double);
    _61.data = jpl_alloc(_62);
    int64_t _63 = 0; // C
    _jump1121:; // Begin body of loop
    double _64 = 73.0;
    int64_t _65 = 0;
    _65 *= _61.d0;
    _65 += _63;
    _61.data[_65] = _64;
    _63++;
    if (_63 < i)
    goto _jump1121;
    // End body of loop
    int64_t _66 = A(_61);
    if (_66 >= 0)
    goto _jump1122;
    fail_assertion("negative array index");
    _jump1122:;
    if (_66 < _47.d0)
    goto _jump1123;
    fail_assertion("index too large");
    _jump1123:;
    int64_t _67 = 0;
    _67 *= _47.d0;
    _67 += _66;
    double _68 = _47.data[_67];
    _10 = _68;
    _jump1111:;
    double _69 = 22.0;
    double _70 = -_69;
    double _71 = _10 - _70;
    bool _72 = l();
    double _73;
    if (!_72)
    goto _jump1124;
    bool _74 = B();
    double _75;
    if (!_74)
    goto _jump1125;
    double _76 = 82.0;
    _75 = _76;
    goto _jump1126;
    _jump1125:;
    double _77 = 68.0;
    double _78 = -_77;
    _75 = _78;
    _jump1126:;
    double _79 = -_75;
    _73 = _79;
    goto _jump1127;
    _jump1124:;
    double _80;
    // Computing bound for C
    if (j > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    _80 = 0;
    int64_t _81 = 0; // C
    _jump1129:; // Begin body of loop
    bool _82 = l();
    rgba _83;
    if (!_82)
    goto _jump1130;
    _83 = x;
    goto _jump1131;
    _jump1130:;
    _83 = x;
    _jump1131:;
    double _84 = _83.g;
    double _85 = -_84;
    _80 += _85;
    _81++;
    if (_81 < j)
    goto _jump1129;
    // End body of loop
    _73 = _80;
    _jump1127:;
    double _86;
    // Computing bound for C
    if (c > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing bound for D
    if (c > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    _86 = 0;
    int64_t _87 = 0; // D
    int64_t _88 = 0; // C
    _jump1134:; // Begin body of loop
    bool _89 = true;
    bool _90;
    if (!_89)
    goto _jump1135;
    bool _91 = j >= _87;
    _90 = _91;
    goto _jump1136;
    _jump1135:;
    bool _93 = true;
    bool _92 = _93;
    if (0 == _93)
    goto _jump1137;
    bool _94 = true;
    _92 = _94;
    _jump1137:;
    _90 = _92;
    _jump1136:;
    rgba _95;
    if (!_90)
    goto _jump1138;
    _95 = x;
    goto _jump1139;
    _jump1138:;
    _95 = x;
    _jump1139:;
    double _96 = _95.r;
    _86 += _96;
    _87++;
    if (_87 < c)
    goto _jump1134;
    _87 = 0;
    _88++;
    if (_88 < c)
    goto _jump1134;
    // End body of loop
    double _97 = _73 / _86;
    bool _98 = _71 != _97;
    if (0 != _98)
    goto _jump1140;
    fail_assertion("C");
    _jump1140:;
    bool _100 = B();
    bool _99 = _100;
    if (0 != _100)
    goto _jump1141;
    bool _101 = B();
    _99 = _101;
    _jump1141:;
    _a2_bool _102;
    if (!_99)
    goto _jump1142;
    _a2_bool _103;
    // Computing bound for D
    _103.d0 = g;
    if (g > 0) 
    goto _jump1143;
    fail_assertion("non-positive loop bound");
    _jump1143:;
    // Computing bound for E
    _103.d1 = g;
    if (g > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= g;
    _104 *= g;
    _104 *= sizeof(bool);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // E
    int64_t _106 = 0; // D
    _jump1145:; // Begin body of loop
    bool _107 = B();
    int64_t _108 = 0;
    _108 *= _103.d0;
    _108 += _106;
    _108 *= _103.d1;
    _108 += _105;
    _103.data[_108] = _107;
    _105++;
    if (_105 < g)
    goto _jump1145;
    _105 = 0;
    _106++;
    if (_106 < g)
    goto _jump1145;
    // End body of loop
    _a2_bool _109;
    // Computing bound for D
    _109.d0 = k;
    if (k > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing bound for E
    _109.d1 = b;
    if (b > 0) 
    goto _jump1147;
    fail_assertion("non-positive loop bound");
    _jump1147:;
    // Computing total size of heap memory to allocate
    int64_t _110 = 1;
    _110 *= k;
    _110 *= b;
    _110 *= sizeof(bool);
    _109.data = jpl_alloc(_110);
    int64_t _111 = 0; // E
    int64_t _112 = 0; // D
    _jump1148:; // Begin body of loop
    bool _113 = false;
    int64_t _114 = 0;
    _114 *= _109.d0;
    _114 += _112;
    _114 *= _109.d1;
    _114 += _111;
    _109.data[_114] = _113;
    _111++;
    if (_111 < b)
    goto _jump1148;
    _111 = 0;
    _112++;
    if (_112 < k)
    goto _jump1148;
    // End body of loop
    _a2_bool _115;
    // Computing bound for D
    _115.d0 = o;
    if (o > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    // Computing bound for E
    _115.d1 = b;
    if (b > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= o;
    _116 *= b;
    _116 *= sizeof(bool);
    _115.data = jpl_alloc(_116);
    int64_t _117 = 0; // E
    int64_t _118 = 0; // D
    _jump1151:; // Begin body of loop
    bool _119 = B();
    int64_t _120 = 0;
    _120 *= _115.d0;
    _120 += _118;
    _120 *= _115.d1;
    _120 += _117;
    _115.data[_120] = _119;
    _117++;
    if (_117 < b)
    goto _jump1151;
    _117 = 0;
    _118++;
    if (_118 < o)
    goto _jump1151;
    // End body of loop
    _a1__a2_bool _121;
    _121.d0 = 3;
    _121.data = jpl_alloc(sizeof(_a2_bool) * 3);
    _121.data[0] = _103;
    _121.data[1] = _109;
    _121.data[2] = _115;
    int64_t _122;
    // Computing bound for D
    bool _123 = false;
    int64_t _124;
    if (!_123)
    goto _jump1152;
    _124 = t;
    goto _jump1153;
    _jump1152:;
    _124 = w;
    _jump1153:;
    if (_124 > 0) 
    goto _jump1154;
    fail_assertion("non-positive loop bound");
    _jump1154:;
    _122 = 0;
    int64_t _125 = 0; // D
    _jump1155:; // Begin body of loop
    _122 += i;
    _125++;
    if (_125 < _124)
    goto _jump1155;
    // End body of loop
    if (_122 >= 0)
    goto _jump1156;
    fail_assertion("negative array index");
    _jump1156:;
    if (_122 < _121.d0)
    goto _jump1157;
    fail_assertion("index too large");
    _jump1157:;
    int64_t _126 = 0;
    _126 *= _121.d0;
    _126 += _122;
    _a2_bool _127 = _121.data[_126];
    _102 = _127;
    goto _jump1158;
    _jump1142:;
    _102 = e;
    _jump1158:;
    double _128;
    // Computing bound for D
    if (d > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    // Computing bound for E
    if (b > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing bound for F
    if (b > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    _128 = 0;
    int64_t _129 = 0; // F
    int64_t _130 = 0; // E
    int64_t _131 = 0; // D
    _jump1162:; // Begin body of loop
    double _132 = 58.0;
    _128 += _132;
    _129++;
    if (_129 < b)
    goto _jump1162;
    _129 = 0;
    _130++;
    if (_130 < b)
    goto _jump1162;
    _130 = 0;
    _131++;
    if (_131 < d)
    goto _jump1162;
    // End body of loop
    double _133 = -_128;
    _a1_double _134;
    _134.d0 = 1;
    _134.data = jpl_alloc(sizeof(double) * 1);
    _134.data[0] = _133;
    int64_t _135 = A(_134);
    if (_135 >= 0)
    goto _jump1163;
    fail_assertion("negative array index");
    _jump1163:;
    if (_135 < _102.d0)
    goto _jump1164;
    fail_assertion("index too large");
    _jump1164:;
    if (b >= 0)
    goto _jump1165;
    fail_assertion("negative array index");
    _jump1165:;
    if (b < _102.d1)
    goto _jump1166;
    fail_assertion("index too large");
    _jump1166:;
    int64_t _136 = 0;
    _136 *= _102.d0;
    _136 += _135;
    _136 *= _102.d1;
    _136 += b;
    bool _137 = _102.data[_136];
    _a1_double _138;
    if (!_137)
    goto _jump1167;
    bool _139 = q != o;
    _a1_int64_t _140;
    if (!_139)
    goto _jump1168;
    int64_t _141 = y();
    if (k >= 0)
    goto _jump1169;
    fail_assertion("negative array index");
    _jump1169:;
    if (k < a.d0)
    goto _jump1170;
    fail_assertion("index too large");
    _jump1170:;
    if (i >= 0)
    goto _jump1171;
    fail_assertion("negative array index");
    _jump1171:;
    if (i < a.d1)
    goto _jump1172;
    fail_assertion("index too large");
    _jump1172:;
    if (_141 >= 0)
    goto _jump1173;
    fail_assertion("negative array index");
    _jump1173:;
    if (_141 < a.d2)
    goto _jump1174;
    fail_assertion("index too large");
    _jump1174:;
    int64_t _142 = 0;
    _142 *= a.d0;
    _142 += k;
    _142 *= a.d1;
    _142 += i;
    _142 *= a.d2;
    _142 += _141;
    _a1_int64_t _143 = a.data[_142];
    _140 = _143;
    goto _jump1175;
    _jump1168:;
    _a1_int64_t _144;
    // Computing bound for D
    _144.d0 = v;
    if (v > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= v;
    _145 *= sizeof(int64_t);
    _144.data = jpl_alloc(_145);
    int64_t _146 = 0; // D
    _jump1177:; // Begin body of loop
    int64_t _147 = 0;
    _147 *= _144.d0;
    _147 += _146;
    _144.data[_147] = q;
    _146++;
    if (_146 < v)
    goto _jump1177;
    // End body of loop
    _140 = _144;
    _jump1175:;
    if (d >= 0)
    goto _jump1178;
    fail_assertion("negative array index");
    _jump1178:;
    if (d < _140.d0)
    goto _jump1179;
    fail_assertion("index too large");
    _jump1179:;
    int64_t _148 = 0;
    _148 *= _140.d0;
    _148 += d;
    int64_t _149 = _140.data[_148];
    int64_t _150 = 878;
    bool _151 = _149 != _150;
    _a1_double _152;
    if (!_151)
    goto _jump1180;
    _a1_double _153;
    // Computing bound for D
    bool _154 = l();
    int64_t _155;
    if (!_154)
    goto _jump1181;
    _155 = q;
    goto _jump1182;
    _jump1181:;
    int64_t _156 = d % t;
    _155 = _156;
    _jump1182:;
    _153.d0 = _155;
    if (_155 > 0) 
    goto _jump1183;
    fail_assertion("non-positive loop bound");
    _jump1183:;
    // Computing total size of heap memory to allocate
    int64_t _157 = 1;
    _157 *= _155;
    _157 *= sizeof(double);
    _153.data = jpl_alloc(_157);
    int64_t _158 = 0; // D
    _jump1184:; // Begin body of loop
    double _159;
    // Computing bound for E
    int64_t _160 = 872;
    if (_160 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    _159 = 0;
    int64_t _161 = 0; // E
    _jump1186:; // Begin body of loop
    bool _162 = l();
    double _163;
    if (!_162)
    goto _jump1187;
    double _164 = 20.0;
    double _165 = -_164;
    _163 = _165;
    goto _jump1188;
    _jump1187:;
    double _166 = 70.0;
    double _167 = 43.0;
    double _168 = fmod(_166, _167);
    _163 = _168;
    _jump1188:;
    _159 += _163;
    _161++;
    if (_161 < _160)
    goto _jump1186;
    // End body of loop
    int64_t _169 = 0;
    _169 *= _153.d0;
    _169 += _158;
    _153.data[_169] = _159;
    _158++;
    if (_158 < _155)
    goto _jump1184;
    // End body of loop
    _152 = _153;
    goto _jump1189;
    _jump1180:;
    _a1_double _170;
    // Computing bound for D
    _170.d0 = t;
    if (t > 0) 
    goto _jump1190;
    fail_assertion("non-positive loop bound");
    _jump1190:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= t;
    _171 *= sizeof(double);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // D
    _jump1191:; // Begin body of loop
    double _173 = 40.0;
    int64_t _174 = 0;
    _174 *= _170.d0;
    _174 += _172;
    _170.data[_174] = _173;
    _172++;
    if (_172 < t)
    goto _jump1191;
    // End body of loop
    _152 = _170;
    _jump1189:;
    _138 = _152;
    goto _jump1192;
    _jump1167:;
    _a1_double _175;
    // Computing bound for D
    int64_t _176;
    // Computing bound for D
    if (v > 0) 
    goto _jump1193;
    fail_assertion("non-positive loop bound");
    _jump1193:;
    // Computing bound for E
    if (c > 0) 
    goto _jump1194;
    fail_assertion("non-positive loop bound");
    _jump1194:;
    _176 = 0;
    int64_t _177 = 0; // E
    int64_t _178 = 0; // D
    _jump1195:; // Begin body of loop
    _176 += k;
    _177++;
    if (_177 < c)
    goto _jump1195;
    _177 = 0;
    _178++;
    if (_178 < v)
    goto _jump1195;
    // End body of loop
    _175.d0 = _176;
    if (_176 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing total size of heap memory to allocate
    int64_t _179 = 1;
    _179 *= _176;
    _179 *= sizeof(double);
    _175.data = jpl_alloc(_179);
    int64_t _180 = 0; // D
    _jump1197:; // Begin body of loop
    double _181 = x.g;
    int64_t _182 = 0;
    _182 *= _175.d0;
    _182 += _180;
    _175.data[_182] = _181;
    _180++;
    if (_180 < _176)
    goto _jump1197;
    // End body of loop
    _138 = _175;
    _jump1192:;
    _a2_int64_t _183;
    // Computing bound for D
    bool _184 = l();
    bool _185;
    if (!_184)
    goto _jump1198;
    if (c >= 0)
    goto _jump1199;
    fail_assertion("negative array index");
    _jump1199:;
    if (c < e.d0)
    goto _jump1200;
    fail_assertion("index too large");
    _jump1200:;
    if (c >= 0)
    goto _jump1201;
    fail_assertion("negative array index");
    _jump1201:;
    if (c < e.d1)
    goto _jump1202;
    fail_assertion("index too large");
    _jump1202:;
    int64_t _186 = 0;
    _186 *= e.d0;
    _186 += c;
    _186 *= e.d1;
    _186 += c;
    bool _187 = e.data[_186];
    bool _188 = !_187;
    _185 = _188;
    goto _jump1203;
    _jump1198:;
    bool _189 = true;
    _185 = _189;
    _jump1203:;
    _a1_double _190;
    if (!_185)
    goto _jump1204;
    int64_t _191 = y();
    bool _192 = i <= _191;
    _a1_double _193;
    if (!_192)
    goto _jump1205;
    _a1_double _194;
    // Computing bound for D
    _194.d0 = o;
    if (o > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= o;
    _195 *= sizeof(double);
    _194.data = jpl_alloc(_195);
    int64_t _196 = 0; // D
    _jump1207:; // Begin body of loop
    double _197 = 28.0;
    double _198 = -_197;
    int64_t _199 = 0;
    _199 *= _194.d0;
    _199 += _196;
    _194.data[_199] = _198;
    _196++;
    if (_196 < o)
    goto _jump1207;
    // End body of loop
    _193 = _194;
    goto _jump1208;
    _jump1205:;
    double _200;
    // Computing bound for D
    if (q > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    _200 = 0;
    int64_t _201 = 0; // D
    _jump1210:; // Begin body of loop
    double _202 = 47.0;
    _200 += _202;
    _201++;
    if (_201 < q)
    goto _jump1210;
    // End body of loop
    double _203 = 31.0;
    double _204 = -_203;
    _a1_double _205;
    _205.d0 = 2;
    _205.data = jpl_alloc(sizeof(double) * 2);
    _205.data[0] = _200;
    _205.data[1] = _204;
    _193 = _205;
    _jump1208:;
    _190 = _193;
    goto _jump1211;
    _jump1204:;
    double _206;
    // Computing bound for D
    if (w > 0) 
    goto _jump1212;
    fail_assertion("non-positive loop bound");
    _jump1212:;
    _206 = 0;
    int64_t _207 = 0; // D
    _jump1213:; // Begin body of loop
    double _208 = 75.0;
    _206 += _208;
    _207++;
    if (_207 < w)
    goto _jump1213;
    // End body of loop
    _a1_double _209;
    // Computing bound for D
    _209.d0 = b;
    if (b > 0) 
    goto _jump1214;
    fail_assertion("non-positive loop bound");
    _jump1214:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= b;
    _210 *= sizeof(double);
    _209.data = jpl_alloc(_210);
    int64_t _211 = 0; // D
    _jump1215:; // Begin body of loop
    double _212 = 29.0;
    int64_t _213 = 0;
    _213 *= _209.d0;
    _213 += _211;
    _209.data[_213] = _212;
    _211++;
    if (_211 < b)
    goto _jump1215;
    // End body of loop
    if (b >= 0)
    goto _jump1216;
    fail_assertion("negative array index");
    _jump1216:;
    if (b < _209.d0)
    goto _jump1217;
    fail_assertion("index too large");
    _jump1217:;
    int64_t _214 = 0;
    _214 *= _209.d0;
    _214 += b;
    double _215 = _209.data[_214];
    double _216;
    // Computing bound for D
    if (b > 0) 
    goto _jump1218;
    fail_assertion("non-positive loop bound");
    _jump1218:;
    // Computing bound for E
    if (b > 0) 
    goto _jump1219;
    fail_assertion("non-positive loop bound");
    _jump1219:;
    _216 = 0;
    int64_t _217 = 0; // E
    int64_t _218 = 0; // D
    _jump1220:; // Begin body of loop
    double _219 = 5.0;
    _216 += _219;
    _217++;
    if (_217 < b)
    goto _jump1220;
    _217 = 0;
    _218++;
    if (_218 < b)
    goto _jump1220;
    // End body of loop
    _a1_double _220;
    _220.d0 = 3;
    _220.data = jpl_alloc(sizeof(double) * 3);
    _220.data[0] = _206;
    _220.data[1] = _215;
    _220.data[2] = _216;
    _190 = _220;
    _jump1211:;
    int64_t _221 = A(_190);
    _183.d0 = _221;
    if (_221 > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing bound for E
    bool _222 = o >= v;
    _a1_int64_t _223;
    if (!_222)
    goto _jump1222;
    bool _224 = l();
    bool _225 = !_224;
    _a1_int64_t _226;
    if (!_225)
    goto _jump1223;
    bool _227 = B();
    _a1_int64_t _228;
    if (!_227)
    goto _jump1224;
    _a1_int64_t _229;
    // Computing bound for D
    _229.d0 = v;
    if (v > 0) 
    goto _jump1225;
    fail_assertion("non-positive loop bound");
    _jump1225:;
    // Computing total size of heap memory to allocate
    int64_t _230 = 1;
    _230 *= v;
    _230 *= sizeof(int64_t);
    _229.data = jpl_alloc(_230);
    int64_t _231 = 0; // D
    _jump1226:; // Begin body of loop
    int64_t _232 = y();
    int64_t _233 = 0;
    _233 *= _229.d0;
    _233 += _231;
    _229.data[_233] = _232;
    _231++;
    if (_231 < v)
    goto _jump1226;
    // End body of loop
    _228 = _229;
    goto _jump1227;
    _jump1224:;
    _a1_int64_t _234;
    // Computing bound for D
    _234.d0 = v;
    if (v > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    // Computing total size of heap memory to allocate
    int64_t _235 = 1;
    _235 *= v;
    _235 *= sizeof(int64_t);
    _234.data = jpl_alloc(_235);
    int64_t _236 = 0; // D
    _jump1229:; // Begin body of loop
    int64_t _237 = 0;
    _237 *= _234.d0;
    _237 += _236;
    _234.data[_237] = g;
    _236++;
    if (_236 < v)
    goto _jump1229;
    // End body of loop
    _228 = _234;
    _jump1227:;
    _226 = _228;
    goto _jump1230;
    _jump1223:;
    _a1_int64_t _238;
    _238.d0 = 1;
    _238.data = jpl_alloc(sizeof(int64_t) * 1);
    _238.data[0] = o;
    _226 = _238;
    _jump1230:;
    _223 = _226;
    goto _jump1231;
    _jump1222:;
    _a1_int64_t _239;
    _239.d0 = 1;
    _239.data = jpl_alloc(sizeof(int64_t) * 1);
    _239.data[0] = c;
    _223 = _239;
    _jump1231:;
    int64_t _240 = -k;
    if (_240 >= 0)
    goto _jump1232;
    fail_assertion("negative array index");
    _jump1232:;
    if (_240 < _223.d0)
    goto _jump1233;
    fail_assertion("index too large");
    _jump1233:;
    int64_t _241 = 0;
    _241 *= _223.d0;
    _241 += _240;
    int64_t _242 = _223.data[_241];
    _183.d1 = _242;
    if (_242 > 0) 
    goto _jump1234;
    fail_assertion("non-positive loop bound");
    _jump1234:;
    // Computing total size of heap memory to allocate
    int64_t _243 = 1;
    _243 *= _221;
    _243 *= _242;
    _243 *= sizeof(int64_t);
    _183.data = jpl_alloc(_243);
    int64_t _244 = 0; // E
    int64_t _245 = 0; // D
    _jump1235:; // Begin body of loop
    int64_t _246 = 0;
    _246 *= _183.d0;
    _246 += _245;
    _246 *= _183.d1;
    _246 += _244;
    _183.data[_246] = w;
    _244++;
    if (_244 < _242)
    goto _jump1235;
    _244 = 0;
    _245++;
    if (_245 < _221)
    goto _jump1235;
    // End body of loop
    bool _247 = m(_138, _183);
    return _247;
    bool _249 = l();
    bool _250 = !_249;
    bool _252 = B();
    bool _251 = _252;
    if (0 != _252)
    goto _jump1236;
    bool _254 = B();
    bool _253 = _254;
    if (0 != _254)
    goto _jump1237;
    bool _255 = false;
    _253 = _255;
    _jump1237:;
    _251 = _253;
    _jump1236:;
    bool _256 = _250 == _251;
    bool _257 = !_256;
    _a1_bool _258;
    if (!_257)
    goto _jump1238;
    _258 = s;
    goto _jump1239;
    _jump1238:;
    if (v >= 0)
    goto _jump1240;
    fail_assertion("negative array index");
    _jump1240:;
    if (v < s.d0)
    goto _jump1241;
    fail_assertion("index too large");
    _jump1241:;
    int64_t _261 = 0;
    _261 *= s.d0;
    _261 += v;
    bool _262 = s.data[_261];
    bool _260 = _262;
    if (0 == _262)
    goto _jump1242;
    bool _263 = false;
    _260 = _263;
    _jump1242:;
    bool _259 = _260;
    if (0 != _260)
    goto _jump1243;
    bool _265 = false;
    bool _264 = _265;
    if (0 != _265)
    goto _jump1244;
    bool _266 = true;
    _264 = _266;
    _jump1244:;
    _259 = _264;
    _jump1243:;
    _a1_bool _267;
    if (!_259)
    goto _jump1245;
    double _268 = 6.0;
    _a1_double _269;
    _269.d0 = 1;
    _269.data = jpl_alloc(sizeof(double) * 1);
    _269.data[0] = _268;
    _a2_int64_t _270;
    // Computing bound for D
    _270.d0 = v;
    if (v > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing bound for E
    _270.d1 = g;
    if (g > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= v;
    _271 *= g;
    _271 *= sizeof(int64_t);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // E
    int64_t _273 = 0; // D
    _jump1248:; // Begin body of loop
    int64_t _274 = 0;
    _274 *= _270.d0;
    _274 += _273;
    _274 *= _270.d1;
    _274 += _272;
    _270.data[_274] = _273;
    _272++;
    if (_272 < g)
    goto _jump1248;
    _272 = 0;
    _273++;
    if (_273 < v)
    goto _jump1248;
    // End body of loop
    bool _275 = m(_269, _270);
    _a1_bool _276;
    if (!_275)
    goto _jump1249;
    _276 = f;
    goto _jump1250;
    _jump1249:;
    _276 = f;
    _jump1250:;
    _267 = _276;
    goto _jump1251;
    _jump1245:;
    bool _277 = l();
    bool _278;
    if (!_277)
    goto _jump1252;
    bool _279 = false;
    bool _280 = !_279;
    _278 = _280;
    goto _jump1253;
    _jump1252:;
    bool _281 = j <= o;
    _278 = _281;
    _jump1253:;
    _a1_bool _282;
    if (!_278)
    goto _jump1254;
    _282 = n;
    goto _jump1255;
    _jump1254:;
    bool _283 = t > o;
    _a1_bool _284;
    if (!_283)
    goto _jump1256;
    _a1_bool _285;
    // Computing bound for D
    _285.d0 = q;
    if (q > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= q;
    _286 *= sizeof(bool);
    _285.data = jpl_alloc(_286);
    int64_t _287 = 0; // D
    _jump1258:; // Begin body of loop
    bool _288 = true;
    int64_t _289 = 0;
    _289 *= _285.d0;
    _289 += _287;
    _285.data[_289] = _288;
    _287++;
    if (_287 < q)
    goto _jump1258;
    // End body of loop
    _284 = _285;
    goto _jump1259;
    _jump1256:;
    _a1_bool _290;
    // Computing bound for D
    _290.d0 = c;
    if (c > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= c;
    _291 *= sizeof(bool);
    _290.data = jpl_alloc(_291);
    int64_t _292 = 0; // D
    _jump1261:; // Begin body of loop
    bool _293 = B();
    int64_t _294 = 0;
    _294 *= _290.d0;
    _294 += _292;
    _290.data[_294] = _293;
    _292++;
    if (_292 < c)
    goto _jump1261;
    // End body of loop
    _284 = _290;
    _jump1259:;
    _282 = _284;
    _jump1255:;
    _267 = _282;
    _jump1251:;
    _258 = _267;
    _jump1239:;
    int64_t _295 = -b;
    if (_295 >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (_295 < _258.d0)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    int64_t _296 = 0;
    _296 *= _258.d0;
    _296 += _295;
    bool _297 = _258.data[_296];
    bool _248 = _297;
    if (0 == _297)
    goto _jump1264;
    bool _298 = false;
    bool _299 = false;
    bool _300 = _298 != _299;
    double _301;
    if (!_300)
    goto _jump1265;
    double _302;
    // Computing bound for D
    if (d > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    // Computing bound for E
    int64_t _303;
    // Computing bound for D
    if (q > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    _303 = 0;
    int64_t _304 = 0; // D
    _jump1268:; // Begin body of loop
    _303 += b;
    _304++;
    if (_304 < q)
    goto _jump1268;
    // End body of loop
    if (_303 > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    _302 = 0;
    int64_t _305 = 0; // E
    int64_t _306 = 0; // D
    _jump1270:; // Begin body of loop
    double _307 = 78.0;
    _302 += _307;
    _305++;
    if (_305 < _303)
    goto _jump1270;
    _305 = 0;
    _306++;
    if (_306 < d)
    goto _jump1270;
    // End body of loop
    _301 = _302;
    goto _jump1271;
    _jump1265:;
    double _308 = 95.0;
    double _309;
    // Computing bound for D
    int64_t _310 = y();
    if (_310 > 0) 
    goto _jump1272;
    fail_assertion("non-positive loop bound");
    _jump1272:;
    // Computing bound for E
    if (d > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    _309 = 0;
    int64_t _311 = 0; // E
    int64_t _312 = 0; // D
    _jump1274:; // Begin body of loop
    double _313 = 87.0;
    _309 += _313;
    _311++;
    if (_311 < d)
    goto _jump1274;
    _311 = 0;
    _312++;
    if (_312 < _310)
    goto _jump1274;
    // End body of loop
    double _314 = _308 - _309;
    _301 = _314;
    _jump1271:;
    double _315 = -_301;
    double _316 = x.g;
    double _317 = 84.0;
    _a1_double _318;
    _318.d0 = 3;
    _318.data = jpl_alloc(sizeof(double) * 3);
    _318.data[0] = _315;
    _318.data[1] = _316;
    _318.data[2] = _317;
    bool _319 = B();
    bool _320 = B();
    bool _321 = _319 == _320;
    _a2_int64_t _322;
    if (!_321)
    goto _jump1275;
    _a2__a2_int64_t _323;
    // Computing bound for D
    _323.d0 = d;
    if (d > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    // Computing bound for E
    _323.d1 = t;
    if (t > 0) 
    goto _jump1277;
    fail_assertion("non-positive loop bound");
    _jump1277:;
    // Computing total size of heap memory to allocate
    int64_t _324 = 1;
    _324 *= d;
    _324 *= t;
    _324 *= sizeof(_a2_int64_t);
    _323.data = jpl_alloc(_324);
    int64_t _325 = 0; // E
    int64_t _326 = 0; // D
    _jump1278:; // Begin body of loop
    _a2_int64_t _327;
    // Computing bound for F
    int64_t _328 = -c;
    _327.d0 = _328;
    if (_328 > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing bound for G
    int64_t _329 = y();
    _327.d1 = _329;
    if (_329 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    // Computing total size of heap memory to allocate
    int64_t _330 = 1;
    _330 *= _328;
    _330 *= _329;
    _330 *= sizeof(int64_t);
    _327.data = jpl_alloc(_330);
    int64_t _331 = 0; // G
    int64_t _332 = 0; // F
    _jump1281:; // Begin body of loop
    int64_t _333 = 0;
    _333 *= _327.d0;
    _333 += _332;
    _333 *= _327.d1;
    _333 += _331;
    _327.data[_333] = k;
    _331++;
    if (_331 < _329)
    goto _jump1281;
    _331 = 0;
    _332++;
    if (_332 < _328)
    goto _jump1281;
    // End body of loop
    int64_t _334 = 0;
    _334 *= _323.d0;
    _334 += _326;
    _334 *= _323.d1;
    _334 += _325;
    _323.data[_334] = _327;
    _325++;
    if (_325 < t)
    goto _jump1278;
    _325 = 0;
    _326++;
    if (_326 < d)
    goto _jump1278;
    // End body of loop
    int64_t _335 = 80;
    if (_335 >= 0)
    goto _jump1282;
    fail_assertion("negative array index");
    _jump1282:;
    if (_335 < _323.d0)
    goto _jump1283;
    fail_assertion("index too large");
    _jump1283:;
    if (d >= 0)
    goto _jump1284;
    fail_assertion("negative array index");
    _jump1284:;
    if (d < _323.d1)
    goto _jump1285;
    fail_assertion("index too large");
    _jump1285:;
    int64_t _336 = 0;
    _336 *= _323.d0;
    _336 += _335;
    _336 *= _323.d1;
    _336 += d;
    _a2_int64_t _337 = _323.data[_336];
    _322 = _337;
    goto _jump1286;
    _jump1275:;
    int64_t _338 = y();
    int64_t _339 = 145;
    bool _340 = _338 == _339;
    bool _341;
    if (!_340)
    goto _jump1287;
    bool _342 = B();
    _341 = _342;
    goto _jump1288;
    _jump1287:;
    bool _343 = B();
    _341 = _343;
    _jump1288:;
    bool _344 = !_341;
    _a2_int64_t _345;
    if (!_344)
    goto _jump1289;
    bool _346 = false;
    bool _347;
    if (!_346)
    goto _jump1290;
    bool _348 = false;
    _347 = _348;
    goto _jump1291;
    _jump1290:;
    bool _349 = false;
    _347 = _349;
    _jump1291:;
    _a2_int64_t _350;
    if (!_347)
    goto _jump1292;
    _a2_int64_t _351;
    // Computing bound for D
    _351.d0 = j;
    if (j > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing bound for E
    _351.d1 = c;
    if (c > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    // Computing total size of heap memory to allocate
    int64_t _352 = 1;
    _352 *= j;
    _352 *= c;
    _352 *= sizeof(int64_t);
    _351.data = jpl_alloc(_352);
    int64_t _353 = 0; // E
    int64_t _354 = 0; // D
    _jump1295:; // Begin body of loop
    int64_t _355 = 0;
    _355 *= _351.d0;
    _355 += _354;
    _355 *= _351.d1;
    _355 += _353;
    _351.data[_355] = j;
    _353++;
    if (_353 < c)
    goto _jump1295;
    _353 = 0;
    _354++;
    if (_354 < j)
    goto _jump1295;
    // End body of loop
    _350 = _351;
    goto _jump1296;
    _jump1292:;
    bool _356 = l();
    _a2_int64_t _357;
    if (!_356)
    goto _jump1297;
    _a2_int64_t _358;
    // Computing bound for D
    _358.d0 = j;
    if (j > 0) 
    goto _jump1298;
    fail_assertion("non-positive loop bound");
    _jump1298:;
    // Computing bound for E
    int64_t _359 = 577;
    _358.d1 = _359;
    if (_359 > 0) 
    goto _jump1299;
    fail_assertion("non-positive loop bound");
    _jump1299:;
    // Computing total size of heap memory to allocate
    int64_t _360 = 1;
    _360 *= j;
    _360 *= _359;
    _360 *= sizeof(int64_t);
    _358.data = jpl_alloc(_360);
    int64_t _361 = 0; // E
    int64_t _362 = 0; // D
    _jump1300:; // Begin body of loop
    int64_t _363 = 0;
    _363 *= _358.d0;
    _363 += _362;
    _363 *= _358.d1;
    _363 += _361;
    _358.data[_363] = q;
    _361++;
    if (_361 < _359)
    goto _jump1300;
    _361 = 0;
    _362++;
    if (_362 < j)
    goto _jump1300;
    // End body of loop
    _357 = _358;
    goto _jump1301;
    _jump1297:;
    _a2_int64_t _364;
    // Computing bound for D
    _364.d0 = q;
    if (q > 0) 
    goto _jump1302;
    fail_assertion("non-positive loop bound");
    _jump1302:;
    // Computing bound for E
    _364.d1 = w;
    if (w > 0) 
    goto _jump1303;
    fail_assertion("non-positive loop bound");
    _jump1303:;
    // Computing total size of heap memory to allocate
    int64_t _365 = 1;
    _365 *= q;
    _365 *= w;
    _365 *= sizeof(int64_t);
    _364.data = jpl_alloc(_365);
    int64_t _366 = 0; // E
    int64_t _367 = 0; // D
    _jump1304:; // Begin body of loop
    int64_t _368 = 0;
    _368 *= _364.d0;
    _368 += _367;
    _368 *= _364.d1;
    _368 += _366;
    _364.data[_368] = q;
    _366++;
    if (_366 < w)
    goto _jump1304;
    _366 = 0;
    _367++;
    if (_367 < q)
    goto _jump1304;
    // End body of loop
    _357 = _364;
    _jump1301:;
    _350 = _357;
    _jump1296:;
    _345 = _350;
    goto _jump1305;
    _jump1289:;
    _a2_int64_t _369;
    // Computing bound for D
    _369.d0 = o;
    if (o > 0) 
    goto _jump1306;
    fail_assertion("non-positive loop bound");
    _jump1306:;
    // Computing bound for E
    _369.d1 = i;
    if (i > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing total size of heap memory to allocate
    int64_t _370 = 1;
    _370 *= o;
    _370 *= i;
    _370 *= sizeof(int64_t);
    _369.data = jpl_alloc(_370);
    int64_t _371 = 0; // E
    int64_t _372 = 0; // D
    _jump1308:; // Begin body of loop
    int64_t _373 = 0;
    _373 *= _369.d0;
    _373 += _372;
    _373 *= _369.d1;
    _373 += _371;
    _369.data[_373] = _371;
    _371++;
    if (_371 < i)
    goto _jump1308;
    _371 = 0;
    _372++;
    if (_372 < o)
    goto _jump1308;
    // End body of loop
    _345 = _369;
    _jump1305:;
    _322 = _345;
    _jump1286:;
    bool _374 = m(_318, _322);
    _248 = _374;
    _jump1264:;
    bool _375 = b >= w;
    return _375;
    bool _376 = l();
    return _376;
}

_a2_r C(bool D, _a2_double E, bool H) {
    bool _0 = B();
    bool _1 = l();
    bool _2 = _0 == _1;
    bool _3 = !_2;
    bool _4 = !_3;
    if (0 != _4)
    goto _jump1309;
    fail_assertion("I");
    _jump1309:;
    _a2__a1_double _5;
    // Computing bound for L
    int64_t _6 = e.d0 - e.d1;
    _5.d0 = _6;
    if (_6 > 0) 
    goto _jump1310;
    fail_assertion("non-positive loop bound");
    _jump1310:;
    // Computing bound for M
    _5.d1 = g;
    if (g > 0) 
    goto _jump1311;
    fail_assertion("non-positive loop bound");
    _jump1311:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= _6;
    _7 *= g;
    _7 *= sizeof(_a1_double);
    _5.data = jpl_alloc(_7);
    int64_t _8 = 0; // M
    int64_t _9 = 0; // L
    _jump1312:; // Begin body of loop
    _a2__a1_double _10;
    // Computing bound for N
    int64_t _11;
    // Computing bound for N
    if (v > 0) 
    goto _jump1313;
    fail_assertion("non-positive loop bound");
    _jump1313:;
    // Computing bound for O
    if (e.d0 > 0) 
    goto _jump1314;
    fail_assertion("non-positive loop bound");
    _jump1314:;
    // Computing bound for P
    int64_t _12 = 862;
    if (_12 > 0) 
    goto _jump1315;
    fail_assertion("non-positive loop bound");
    _jump1315:;
    _11 = 0;
    int64_t _13 = 0; // P
    int64_t _14 = 0; // O
    int64_t _15 = 0; // N
    _jump1316:; // Begin body of loop
    _11 += _14;
    _13++;
    if (_13 < _12)
    goto _jump1316;
    _13 = 0;
    _14++;
    if (_14 < e.d0)
    goto _jump1316;
    _14 = 0;
    _15++;
    if (_15 < v)
    goto _jump1316;
    // End body of loop
    _10.d0 = _11;
    if (_11 > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    // Computing bound for O
    _10.d1 = d;
    if (d > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _11;
    _16 *= d;
    _16 *= sizeof(_a1_double);
    _10.data = jpl_alloc(_16);
    int64_t _17 = 0; // O
    int64_t _18 = 0; // N
    _jump1319:; // Begin body of loop
    _a1_double _19;
    // Computing bound for P
    _19.d0 = g;
    if (g > 0) 
    goto _jump1320;
    fail_assertion("non-positive loop bound");
    _jump1320:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= g;
    _20 *= sizeof(double);
    _19.data = jpl_alloc(_20);
    int64_t _21 = 0; // P
    _jump1321:; // Begin body of loop
    double _22 = 71.0;
    int64_t _23 = 0;
    _23 *= _19.d0;
    _23 += _21;
    _19.data[_23] = _22;
    _21++;
    if (_21 < g)
    goto _jump1321;
    // End body of loop
    int64_t _24 = 0;
    _24 *= _10.d0;
    _24 += _18;
    _24 *= _10.d1;
    _24 += _17;
    _10.data[_24] = _19;
    _17++;
    if (_17 < d)
    goto _jump1319;
    _17 = 0;
    _18++;
    if (_18 < _11)
    goto _jump1319;
    // End body of loop
    if (E.d0 >= 0)
    goto _jump1322;
    fail_assertion("negative array index");
    _jump1322:;
    if (E.d0 < _10.d0)
    goto _jump1323;
    fail_assertion("index too large");
    _jump1323:;
    if (k >= 0)
    goto _jump1324;
    fail_assertion("negative array index");
    _jump1324:;
    if (k < _10.d1)
    goto _jump1325;
    fail_assertion("index too large");
    _jump1325:;
    int64_t _25 = 0;
    _25 *= _10.d0;
    _25 += E.d0;
    _25 *= _10.d1;
    _25 += k;
    _a1_double _26 = _10.data[_25];
    int64_t _27 = 0;
    _27 *= _5.d0;
    _27 += _9;
    _27 *= _5.d1;
    _27 += _8;
    _5.data[_27] = _26;
    _8++;
    if (_8 < g)
    goto _jump1312;
    _8 = 0;
    _9++;
    if (_9 < _6)
    goto _jump1312;
    // End body of loop
    if (b >= 0)
    goto _jump1326;
    fail_assertion("negative array index");
    _jump1326:;
    if (b < _5.d0)
    goto _jump1327;
    fail_assertion("index too large");
    _jump1327:;
    if (g >= 0)
    goto _jump1328;
    fail_assertion("negative array index");
    _jump1328:;
    if (g < _5.d1)
    goto _jump1329;
    fail_assertion("index too large");
    _jump1329:;
    int64_t _28 = 0;
    _28 *= _5.d0;
    _28 += b;
    _28 *= _5.d1;
    _28 += g;
    _a1_double _29 = _5.data[_28];
    int64_t _30;
    // Computing bound for L
    if (w > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    _30 = 0;
    int64_t _31 = 0; // L
    _jump1331:; // Begin body of loop
    _30 += g;
    _31++;
    if (_31 < w)
    goto _jump1331;
    // End body of loop
    bool _32 = k <= _30;
    _a2_int64_t _33;
    if (!_32)
    goto _jump1332;
    _a3__a2_int64_t _34;
    // Computing bound for L
    int64_t _35 = o * i;
    _34.d0 = _35;
    if (_35 > 0) 
    goto _jump1333;
    fail_assertion("non-positive loop bound");
    _jump1333:;
    // Computing bound for M
    int64_t _36 = -v;
    _34.d1 = _36;
    if (_36 > 0) 
    goto _jump1334;
    fail_assertion("non-positive loop bound");
    _jump1334:;
    // Computing bound for N
    _34.d2 = E.d1;
    if (E.d1 > 0) 
    goto _jump1335;
    fail_assertion("non-positive loop bound");
    _jump1335:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _35;
    _37 *= _36;
    _37 *= E.d1;
    _37 *= sizeof(_a2_int64_t);
    _34.data = jpl_alloc(_37);
    int64_t _38 = 0; // N
    int64_t _39 = 0; // M
    int64_t _40 = 0; // L
    _jump1336:; // Begin body of loop
    _a2_int64_t _41;
    // Computing bound for O
    _41.d0 = _39;
    if (_39 > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    // Computing bound for P
    _41.d1 = k;
    if (k > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= _39;
    _42 *= k;
    _42 *= sizeof(int64_t);
    _41.data = jpl_alloc(_42);
    int64_t _43 = 0; // P
    int64_t _44 = 0; // O
    _jump1339:; // Begin body of loop
    int64_t _45 = -i;
    int64_t _46 = 0;
    _46 *= _41.d0;
    _46 += _44;
    _46 *= _41.d1;
    _46 += _43;
    _41.data[_46] = _45;
    _43++;
    if (_43 < k)
    goto _jump1339;
    _43 = 0;
    _44++;
    if (_44 < _39)
    goto _jump1339;
    // End body of loop
    int64_t _47 = 0;
    _47 *= _34.d0;
    _47 += _40;
    _47 *= _34.d1;
    _47 += _39;
    _47 *= _34.d2;
    _47 += _38;
    _34.data[_47] = _41;
    _38++;
    if (_38 < E.d1)
    goto _jump1336;
    _38 = 0;
    _39++;
    if (_39 < _36)
    goto _jump1336;
    _39 = 0;
    _40++;
    if (_40 < _35)
    goto _jump1336;
    // End body of loop
    _a1_double _48;
    // Computing bound for L
    int64_t _49 = 566;
    _48.d0 = _49;
    if (_49 > 0) 
    goto _jump1340;
    fail_assertion("non-positive loop bound");
    _jump1340:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _49;
    _50 *= sizeof(double);
    _48.data = jpl_alloc(_50);
    int64_t _51 = 0; // L
    _jump1341:; // Begin body of loop
    double _52 = 9.0;
    int64_t _53 = 0;
    _53 *= _48.d0;
    _53 += _51;
    _48.data[_53] = _52;
    _51++;
    if (_51 < _49)
    goto _jump1341;
    // End body of loop
    int64_t _54 = A(_48);
    if (_54 >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (_54 < _34.d0)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    if (w >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (w < _34.d1)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    if (v >= 0)
    goto _jump1346;
    fail_assertion("negative array index");
    _jump1346:;
    if (v < _34.d2)
    goto _jump1347;
    fail_assertion("index too large");
    _jump1347:;
    int64_t _55 = 0;
    _55 *= _34.d0;
    _55 += _54;
    _55 *= _34.d1;
    _55 += w;
    _55 *= _34.d2;
    _55 += v;
    _a2_int64_t _56 = _34.data[_55];
    _33 = _56;
    goto _jump1348;
    _jump1332:;
    _a2_int64_t _57;
    // Computing bound for L
    _57.d0 = b;
    if (b > 0) 
    goto _jump1349;
    fail_assertion("non-positive loop bound");
    _jump1349:;
    // Computing bound for M
    _57.d1 = j;
    if (j > 0) 
    goto _jump1350;
    fail_assertion("non-positive loop bound");
    _jump1350:;
    // Computing total size of heap memory to allocate
    int64_t _58 = 1;
    _58 *= b;
    _58 *= j;
    _58 *= sizeof(int64_t);
    _57.data = jpl_alloc(_58);
    int64_t _59 = 0; // M
    int64_t _60 = 0; // L
    _jump1351:; // Begin body of loop
    int64_t _61 = 0;
    _61 *= _57.d0;
    _61 += _60;
    _61 *= _57.d1;
    _61 += _59;
    _57.data[_61] = d;
    _59++;
    if (_59 < j)
    goto _jump1351;
    _59 = 0;
    _60++;
    if (_60 < b)
    goto _jump1351;
    // End body of loop
    _33 = _57;
    _jump1348:;
    bool _62 = m(_29, _33);
    bool _63 = !_62;
    if (0 != _63)
    goto _jump1352;
    fail_assertion("L");
    _jump1352:;
    bool _64 = B();
    _a1_double _65;
    // Computing bound for R
    _65.d0 = k;
    if (k > 0) 
    goto _jump1353;
    fail_assertion("non-positive loop bound");
    _jump1353:;
    // Computing total size of heap memory to allocate
    int64_t _66 = 1;
    _66 *= k;
    _66 *= sizeof(double);
    _65.data = jpl_alloc(_66);
    int64_t _67 = 0; // R
    _jump1354:; // Begin body of loop
    double _68 = 55.0;
    int64_t _69 = 0;
    _69 *= _65.d0;
    _69 += _67;
    _65.data[_69] = _68;
    _67++;
    if (_67 < k)
    goto _jump1354;
    // End body of loop
    int64_t _70 = A(_65);
    bool _71 = s.d0 != _70;
    _a1__a2__a2_r _72;
    if (!_71)
    goto _jump1355;
    bool _73 = !H;
    _a1__a2__a2_r _74;
    if (!_73)
    goto _jump1356;
    _a2__a2_r _75;
    // Computing bound for R
    _75.d0 = s.d0;
    if (s.d0 > 0) 
    goto _jump1357;
    fail_assertion("non-positive loop bound");
    _jump1357:;
    // Computing bound for S
    int64_t _76 = -i;
    _75.d1 = _76;
    if (_76 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    // Computing total size of heap memory to allocate
    int64_t _77 = 1;
    _77 *= s.d0;
    _77 *= _76;
    _77 *= sizeof(_a2_r);
    _75.data = jpl_alloc(_77);
    int64_t _78 = 0; // S
    int64_t _79 = 0; // R
    _jump1359:; // Begin body of loop
    bool _80 = true;
    bool _81 = false;
    _a2_r _82 = C(_80, E, _81);
    int64_t _83 = 0;
    _83 *= _75.d0;
    _83 += _79;
    _83 *= _75.d1;
    _83 += _78;
    _75.data[_83] = _82;
    _78++;
    if (_78 < _76)
    goto _jump1359;
    _78 = 0;
    _79++;
    if (_79 < s.d0)
    goto _jump1359;
    // End body of loop
    _a2__a2_r _84;
    // Computing bound for R
    _84.d0 = E.d0;
    if (E.d0 > 0) 
    goto _jump1360;
    fail_assertion("non-positive loop bound");
    _jump1360:;
    // Computing bound for S
    int64_t _85;
    if (!D)
    goto _jump1361;
    _85 = E.d1;
    goto _jump1362;
    _jump1361:;
    _85 = c;
    _jump1362:;
    _84.d1 = _85;
    if (_85 > 0) 
    goto _jump1363;
    fail_assertion("non-positive loop bound");
    _jump1363:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= E.d0;
    _86 *= _85;
    _86 *= sizeof(_a2_r);
    _84.data = jpl_alloc(_86);
    int64_t _87 = 0; // S
    int64_t _88 = 0; // R
    _jump1364:; // Begin body of loop
    _a2_r _89 = C(_64, E, _64);
    int64_t _90 = 0;
    _90 *= _84.d0;
    _90 += _88;
    _90 *= _84.d1;
    _90 += _87;
    _84.data[_90] = _89;
    _87++;
    if (_87 < _85)
    goto _jump1364;
    _87 = 0;
    _88++;
    if (_88 < E.d0)
    goto _jump1364;
    // End body of loop
    _a1__a2__a2_r _91;
    _91.d0 = 2;
    _91.data = jpl_alloc(sizeof(_a2__a2_r) * 2);
    _91.data[0] = _75;
    _91.data[1] = _84;
    _74 = _91;
    goto _jump1365;
    _jump1356:;
    _a2__a2_r _92;
    // Computing bound for R
    int64_t _93 = y();
    int64_t _94 = _93 + e.d0;
    _92.d0 = _94;
    if (_94 > 0) 
    goto _jump1366;
    fail_assertion("non-positive loop bound");
    _jump1366:;
    // Computing bound for S
    _92.d1 = d;
    if (d > 0) 
    goto _jump1367;
    fail_assertion("non-positive loop bound");
    _jump1367:;
    // Computing total size of heap memory to allocate
    int64_t _95 = 1;
    _95 *= _94;
    _95 *= d;
    _95 *= sizeof(_a2_r);
    _92.data = jpl_alloc(_95);
    int64_t _96 = 0; // S
    int64_t _97 = 0; // R
    _jump1368:; // Begin body of loop
    bool _98 = true;
    bool _99 = true;
    _a2_r _100 = C(_98, E, _99);
    int64_t _101 = 0;
    _101 *= _92.d0;
    _101 += _97;
    _101 *= _92.d1;
    _101 += _96;
    _92.data[_101] = _100;
    _96++;
    if (_96 < d)
    goto _jump1368;
    _96 = 0;
    _97++;
    if (_97 < _94)
    goto _jump1368;
    // End body of loop
    _a1__a2__a2_r _102;
    _102.d0 = 1;
    _102.data = jpl_alloc(sizeof(_a2__a2_r) * 1);
    _102.data[0] = _92;
    _74 = _102;
    _jump1365:;
    _72 = _74;
    goto _jump1369;
    _jump1355:;
    _a2__a2_r _103;
    // Computing bound for R
    _103.d0 = i;
    if (i > 0) 
    goto _jump1370;
    fail_assertion("non-positive loop bound");
    _jump1370:;
    // Computing bound for S
    _103.d1 = e.d0;
    if (e.d0 > 0) 
    goto _jump1371;
    fail_assertion("non-positive loop bound");
    _jump1371:;
    // Computing total size of heap memory to allocate
    int64_t _104 = 1;
    _104 *= i;
    _104 *= e.d0;
    _104 *= sizeof(_a2_r);
    _103.data = jpl_alloc(_104);
    int64_t _105 = 0; // S
    int64_t _106 = 0; // R
    _jump1372:; // Begin body of loop
    bool _107 = !_64;
    bool _108 = H;
    if (0 == H)
    goto _jump1373;
    _108 = D;
    _jump1373:;
    _a2_r _109 = C(_107, E, _108);
    int64_t _110 = 0;
    _110 *= _103.d0;
    _110 += _106;
    _110 *= _103.d1;
    _110 += _105;
    _103.data[_110] = _109;
    _105++;
    if (_105 < e.d0)
    goto _jump1372;
    _105 = 0;
    _106++;
    if (_106 < i)
    goto _jump1372;
    // End body of loop
    _a1__a2__a2_r _111;
    _111.d0 = 1;
    _111.data = jpl_alloc(sizeof(_a2__a2_r) * 1);
    _111.data[0] = _103;
    _72 = _111;
    _jump1369:;
    if (k >= 0)
    goto _jump1374;
    fail_assertion("negative array index");
    _jump1374:;
    if (k < _72.d0)
    goto _jump1375;
    fail_assertion("index too large");
    _jump1375:;
    int64_t _112 = 0;
    _112 *= _72.d0;
    _112 += k;
    _a2__a2_r _113 = _72.data[_112];
    if (s.d0 >= 0)
    goto _jump1376;
    fail_assertion("negative array index");
    _jump1376:;
    if (s.d0 < _113.d0)
    goto _jump1377;
    fail_assertion("index too large");
    _jump1377:;
    if (s.d0 >= 0)
    goto _jump1378;
    fail_assertion("negative array index");
    _jump1378:;
    if (s.d0 < _113.d1)
    goto _jump1379;
    fail_assertion("index too large");
    _jump1379:;
    int64_t _114 = 0;
    _114 *= _113.d0;
    _114 += s.d0;
    _114 *= _113.d1;
    _114 += s.d0;
    _a2_r _115 = _113.data[_114];
    return _115;
}

void jpl_main(struct args args) {
    _a3__a1_int64_t _0;
    // Computing bound for a
    bool _1 = true;
    int64_t _2;
    if (!_1)
    goto _jump1;
    _a2_int64_t _3;
    // Computing bound for a
    int64_t _4 = 42;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for b
    int64_t _5 = 39;
    int64_t _6 = -_5;
    _3.d1 = _6;
    if (_6 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing total size of heap memory to allocate
    int64_t _7 = 1;
    _7 *= _4;
    _7 *= _6;
    _7 *= sizeof(int64_t);
    _3.data = jpl_alloc(_7);
    int64_t _8 = 0; // b
    int64_t _9 = 0; // a
    _jump4:; // Begin body of loop
    int64_t _10 = 222;
    int64_t _11 = 0;
    _11 *= _3.d0;
    _11 += _9;
    _11 *= _3.d1;
    _11 += _8;
    _3.data[_11] = _10;
    _8++;
    if (_8 < _6)
    goto _jump4;
    _8 = 0;
    _9++;
    if (_9 < _4)
    goto _jump4;
    // End body of loop
    int64_t _12 = 935;
    int64_t _13 = 407;
    int64_t _14 = -_13;
    if (_12 >= 0)
    goto _jump5;
    fail_assertion("negative array index");
    _jump5:;
    if (_12 < _3.d0)
    goto _jump6;
    fail_assertion("index too large");
    _jump6:;
    if (_14 >= 0)
    goto _jump7;
    fail_assertion("negative array index");
    _jump7:;
    if (_14 < _3.d1)
    goto _jump8;
    fail_assertion("index too large");
    _jump8:;
    int64_t _15 = 0;
    _15 *= _3.d0;
    _15 += _12;
    _15 *= _3.d1;
    _15 += _14;
    int64_t _16 = _3.data[_15];
    int64_t _17 = -_16;
    _2 = _17;
    goto _jump9;
    _jump1:;
    int64_t _18 = 833;
    _2 = _18;
    _jump9:;
    _0.d0 = _2;
    if (_2 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    // Computing bound for b
    _a2__a3__a2_int64_t _19;
    // Computing bound for a
    int64_t _20 = 750;
    _19.d0 = _20;
    if (_20 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for b
    int64_t _21 = 731;
    int64_t _22 = 885;
    int64_t _23 = _21 - _22;
    bool _24 = false;
    int64_t _25;
    if (!_24)
    goto _jump12;
    int64_t _26 = 550;
    _25 = _26;
    goto _jump13;
    _jump12:;
    int64_t _27 = 738;
    _25 = _27;
    _jump13:;
    int64_t _28 = _23 - _25;
    _19.d1 = _28;
    if (_28 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _20;
    _29 *= _28;
    _29 *= sizeof(_a3__a2_int64_t);
    _19.data = jpl_alloc(_29);
    int64_t _30 = 0; // b
    int64_t _31 = 0; // a
    _jump15:; // Begin body of loop
    _a3__a2_int64_t _32;
    // Computing bound for c
    int64_t _33 = _30 * _31;
    _32.d0 = _33;
    if (_33 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    // Computing bound for d
    _32.d1 = _31;
    if (_31 > 0) 
    goto _jump17;
    fail_assertion("non-positive loop bound");
    _jump17:;
    // Computing bound for e
    int64_t _34 = 68;
    int64_t _35 = _31 % _34;
    _32.d2 = _35;
    if (_35 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    // Computing total size of heap memory to allocate
    int64_t _36 = 1;
    _36 *= _33;
    _36 *= _31;
    _36 *= _35;
    _36 *= sizeof(_a2_int64_t);
    _32.data = jpl_alloc(_36);
    int64_t _37 = 0; // e
    int64_t _38 = 0; // d
    int64_t _39 = 0; // c
    _jump19:; // Begin body of loop
    _a2_int64_t _40;
    // Computing bound for f
    _40.d0 = _30;
    if (_30 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    // Computing bound for g
    int64_t _41 = 788;
    _40.d1 = _41;
    if (_41 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing total size of heap memory to allocate
    int64_t _42 = 1;
    _42 *= _30;
    _42 *= _41;
    _42 *= sizeof(int64_t);
    _40.data = jpl_alloc(_42);
    int64_t _43 = 0; // g
    int64_t _44 = 0; // f
    _jump22:; // Begin body of loop
    int64_t _45 = 0;
    _45 *= _40.d0;
    _45 += _44;
    _45 *= _40.d1;
    _45 += _43;
    _40.data[_45] = _37;
    _43++;
    if (_43 < _41)
    goto _jump22;
    _43 = 0;
    _44++;
    if (_44 < _30)
    goto _jump22;
    // End body of loop
    int64_t _46 = 0;
    _46 *= _32.d0;
    _46 += _39;
    _46 *= _32.d1;
    _46 += _38;
    _46 *= _32.d2;
    _46 += _37;
    _32.data[_46] = _40;
    _37++;
    if (_37 < _35)
    goto _jump19;
    _37 = 0;
    _38++;
    if (_38 < _31)
    goto _jump19;
    _38 = 0;
    _39++;
    if (_39 < _33)
    goto _jump19;
    // End body of loop
    int64_t _47 = 0;
    _47 *= _19.d0;
    _47 += _31;
    _47 *= _19.d1;
    _47 += _30;
    _19.data[_47] = _32;
    _30++;
    if (_30 < _28)
    goto _jump15;
    _30 = 0;
    _31++;
    if (_31 < _20)
    goto _jump15;
    // End body of loop
    int64_t _48 = 606;
    int64_t _49 = 148;
    int64_t _50 = 296;
    bool _51 = _49 == _50;
    int64_t _52;
    if (!_51)
    goto _jump23;
    int64_t _53 = 340;
    _52 = _53;
    goto _jump24;
    _jump23:;
    int64_t _54;
    // Computing bound for a
    int64_t _55 = 923;
    if (_55 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    _54 = 0;
    int64_t _56 = 0; // a
    _jump26:; // Begin body of loop
    int64_t _57 = 940;
    _54 += _57;
    _56++;
    if (_56 < _55)
    goto _jump26;
    // End body of loop
    int64_t _58 = -_54;
    _52 = _58;
    _jump24:;
    if (_48 >= 0)
    goto _jump27;
    fail_assertion("negative array index");
    _jump27:;
    if (_48 < _19.d0)
    goto _jump28;
    fail_assertion("index too large");
    _jump28:;
    if (_52 >= 0)
    goto _jump29;
    fail_assertion("negative array index");
    _jump29:;
    if (_52 < _19.d1)
    goto _jump30;
    fail_assertion("index too large");
    _jump30:;
    int64_t _59 = 0;
    _59 *= _19.d0;
    _59 += _48;
    _59 *= _19.d1;
    _59 += _52;
    _a3__a2_int64_t _60 = _19.data[_59];
    _a1__a1_int64_t _61;
    // Computing bound for a
    int64_t _62 = 108;
    int64_t _63 = -_62;
    _61.d0 = _63;
    if (_63 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= _63;
    _64 *= sizeof(_a1_int64_t);
    _61.data = jpl_alloc(_64);
    int64_t _65 = 0; // a
    _jump32:; // Begin body of loop
    _a1_int64_t _66;
    // Computing bound for b
    _66.d0 = _65;
    if (_65 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= _65;
    _67 *= sizeof(int64_t);
    _66.data = jpl_alloc(_67);
    int64_t _68 = 0; // b
    _jump34:; // Begin body of loop
    int64_t _69 = 725;
    int64_t _70 = 0;
    _70 *= _66.d0;
    _70 += _68;
    _66.data[_70] = _69;
    _68++;
    if (_68 < _65)
    goto _jump34;
    // End body of loop
    int64_t _71 = 0;
    _71 *= _61.d0;
    _71 += _65;
    _61.data[_71] = _66;
    _65++;
    if (_65 < _63)
    goto _jump32;
    // End body of loop
    int64_t _72 = 779;
    if (_72 >= 0)
    goto _jump35;
    fail_assertion("negative array index");
    _jump35:;
    if (_72 < _61.d0)
    goto _jump36;
    fail_assertion("index too large");
    _jump36:;
    int64_t _73 = 0;
    _73 *= _61.d0;
    _73 += _72;
    _a1_int64_t _74 = _61.data[_73];
    int64_t _75 = 737;
    int64_t _76 = -_75;
    if (_76 >= 0)
    goto _jump37;
    fail_assertion("negative array index");
    _jump37:;
    if (_76 < _74.d0)
    goto _jump38;
    fail_assertion("index too large");
    _jump38:;
    int64_t _77 = 0;
    _77 *= _74.d0;
    _77 += _76;
    int64_t _78 = _74.data[_77];
    int64_t _79;
    // Computing bound for a
    int64_t _80 = 901;
    int64_t _81 = -_80;
    int64_t _82;
    // Computing bound for a
    int64_t _83 = 726;
    if (_83 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    _82 = 0;
    int64_t _84 = 0; // a
    _jump40:; // Begin body of loop
    _82 += _84;
    _84++;
    if (_84 < _83)
    goto _jump40;
    // End body of loop
    int64_t _85 = -_82;
    int64_t _86 = _81 % _85;
    if (_86 > 0) 
    goto _jump41;
    fail_assertion("non-positive loop bound");
    _jump41:;
    // Computing bound for b
    bool _87 = true;
    bool _88 = !_87;
    bool _89 = !_88;
    int64_t _90;
    if (!_89)
    goto _jump42;
    int64_t _91 = 638;
    _90 = _91;
    goto _jump43;
    _jump42:;
    int64_t _92;
    // Computing bound for a
    int64_t _93 = 881;
    int64_t _94 = 444;
    int64_t _95 = _93 / _94;
    if (_95 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    // Computing bound for b
    int64_t _96 = 358;
    int64_t _97 = -_96;
    if (_97 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    _92 = 0;
    int64_t _98 = 0; // b
    int64_t _99 = 0; // a
    _jump46:; // Begin body of loop
    int64_t _100 = 393;
    _92 += _100;
    _98++;
    if (_98 < _97)
    goto _jump46;
    _98 = 0;
    _99++;
    if (_99 < _95)
    goto _jump46;
    // End body of loop
    _90 = _92;
    _jump43:;
    if (_90 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    _79 = 0;
    int64_t _101 = 0; // b
    int64_t _102 = 0; // a
    _jump48:; // Begin body of loop
    bool _103 = _102 != _102;
    int64_t _104;
    if (!_103)
    goto _jump49;
    int64_t _105;
    // Computing bound for c
    int64_t _106 = 552;
    if (_106 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    // Computing bound for d
    if (_101 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    _105 = 0;
    int64_t _107 = 0; // d
    int64_t _108 = 0; // c
    _jump52:; // Begin body of loop
    int64_t _109 = 105;
    _105 += _109;
    _107++;
    if (_107 < _101)
    goto _jump52;
    _107 = 0;
    _108++;
    if (_108 < _106)
    goto _jump52;
    // End body of loop
    _104 = _105;
    goto _jump53;
    _jump49:;
    _104 = _102;
    _jump53:;
    _79 += _104;
    _101++;
    if (_101 < _90)
    goto _jump48;
    _101 = 0;
    _102++;
    if (_102 < _86)
    goto _jump48;
    // End body of loop
    _a3_int64_t _110;
    // Computing bound for a
    int64_t _111 = 598;
    _110.d0 = _111;
    if (_111 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for b
    int64_t _112 = 592;
    _110.d1 = _112;
    if (_112 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    // Computing bound for c
    int64_t _113 = 792;
    bool _114 = false;
    int64_t _115;
    if (!_114)
    goto _jump56;
    int64_t _116 = 987;
    _115 = _116;
    goto _jump57;
    _jump56:;
    int64_t _117 = 59;
    _115 = _117;
    _jump57:;
    int64_t _118 = _113 % _115;
    _110.d2 = _118;
    if (_118 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    // Computing total size of heap memory to allocate
    int64_t _119 = 1;
    _119 *= _111;
    _119 *= _112;
    _119 *= _118;
    _119 *= sizeof(int64_t);
    _110.data = jpl_alloc(_119);
    int64_t _120 = 0; // c
    int64_t _121 = 0; // b
    int64_t _122 = 0; // a
    _jump59:; // Begin body of loop
    int64_t _123 = 0;
    _123 *= _110.d0;
    _123 += _122;
    _123 *= _110.d1;
    _123 += _121;
    _123 *= _110.d2;
    _123 += _120;
    _110.data[_123] = _121;
    _120++;
    if (_120 < _118)
    goto _jump59;
    _120 = 0;
    _121++;
    if (_121 < _112)
    goto _jump59;
    _121 = 0;
    _122++;
    if (_122 < _111)
    goto _jump59;
    // End body of loop
    int64_t _124 = 897;
    int64_t _125 = -_124;
    bool _126 = false;
    bool _127 = true;
    bool _128 = _126 != _127;
    int64_t _129;
    if (!_128)
    goto _jump60;
    int64_t _130 = 327;
    int64_t _131 = -_130;
    _129 = _131;
    goto _jump61;
    _jump60:;
    int64_t _132 = 474;
    int64_t _133 = 801;
    int64_t _134 = _132 * _133;
    int64_t _135 = 916;
    int64_t _136 = _134 + _135;
    _129 = _136;
    _jump61:;
    int64_t _137 = 3;
    bool _138 = false;
    int64_t _139;
    if (!_138)
    goto _jump62;
    int64_t _140 = 660;
    _139 = _140;
    goto _jump63;
    _jump62:;
    int64_t _141 = 744;
    _139 = _141;
    _jump63:;
    int64_t _142 = -_139;
    int64_t _143 = _137 % _142;
    if (_125 >= 0)
    goto _jump64;
    fail_assertion("negative array index");
    _jump64:;
    if (_125 < _110.d0)
    goto _jump65;
    fail_assertion("index too large");
    _jump65:;
    if (_129 >= 0)
    goto _jump66;
    fail_assertion("negative array index");
    _jump66:;
    if (_129 < _110.d1)
    goto _jump67;
    fail_assertion("index too large");
    _jump67:;
    if (_143 >= 0)
    goto _jump68;
    fail_assertion("negative array index");
    _jump68:;
    if (_143 < _110.d2)
    goto _jump69;
    fail_assertion("index too large");
    _jump69:;
    int64_t _144 = 0;
    _144 *= _110.d0;
    _144 += _125;
    _144 *= _110.d1;
    _144 += _129;
    _144 *= _110.d2;
    _144 += _143;
    int64_t _145 = _110.data[_144];
    if (_78 >= 0)
    goto _jump70;
    fail_assertion("negative array index");
    _jump70:;
    if (_78 < _60.d0)
    goto _jump71;
    fail_assertion("index too large");
    _jump71:;
    if (_79 >= 0)
    goto _jump72;
    fail_assertion("negative array index");
    _jump72:;
    if (_79 < _60.d1)
    goto _jump73;
    fail_assertion("index too large");
    _jump73:;
    if (_145 >= 0)
    goto _jump74;
    fail_assertion("negative array index");
    _jump74:;
    if (_145 < _60.d2)
    goto _jump75;
    fail_assertion("index too large");
    _jump75:;
    int64_t _146 = 0;
    _146 *= _60.d0;
    _146 += _78;
    _146 *= _60.d1;
    _146 += _79;
    _146 *= _60.d2;
    _146 += _145;
    _a2_int64_t _147 = _60.data[_146];
    _a1_int64_t _148;
    // Computing bound for a
    int64_t _149 = 814;
    _148.d0 = _149;
    if (_149 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= _149;
    _150 *= sizeof(int64_t);
    _148.data = jpl_alloc(_150);
    int64_t _151 = 0; // a
    _jump77:; // Begin body of loop
    int64_t _152 = 0;
    _152 *= _148.d0;
    _152 += _151;
    _148.data[_152] = _151;
    _151++;
    if (_151 < _149)
    goto _jump77;
    // End body of loop
    int64_t _153 = 402;
    int64_t _154 = -_153;
    if (_154 >= 0)
    goto _jump78;
    fail_assertion("negative array index");
    _jump78:;
    if (_154 < _148.d0)
    goto _jump79;
    fail_assertion("index too large");
    _jump79:;
    int64_t _155 = 0;
    _155 *= _148.d0;
    _155 += _154;
    int64_t _156 = _148.data[_155];
    int64_t _157 = -_156;
    int64_t _158 = -_157;
    int64_t _159;
    // Computing bound for a
    int64_t _160 = 213;
    if (_160 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    // Computing bound for b
    int64_t _161;
    // Computing bound for a
    int64_t _162 = 292;
    if (_162 > 0) 
    goto _jump81;
    fail_assertion("non-positive loop bound");
    _jump81:;
    // Computing bound for b
    int64_t _163 = 422;
    if (_163 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    _161 = 0;
    int64_t _164 = 0; // b
    int64_t _165 = 0; // a
    _jump83:; // Begin body of loop
    int64_t _166 = 5;
    _161 += _166;
    _164++;
    if (_164 < _163)
    goto _jump83;
    _164 = 0;
    _165++;
    if (_165 < _162)
    goto _jump83;
    // End body of loop
    int64_t _167 = -_161;
    if (_167 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    // Computing bound for c
    int64_t _168 = 442;
    int64_t _169 = -_168;
    if (_169 > 0) 
    goto _jump85;
    fail_assertion("non-positive loop bound");
    _jump85:;
    _159 = 0;
    int64_t _170 = 0; // c
    int64_t _171 = 0; // b
    int64_t _172 = 0; // a
    _jump86:; // Begin body of loop
    int64_t _173 = 591;
    bool _174 = _173 == _172;
    int64_t _175;
    if (!_174)
    goto _jump87;
    _175 = _170;
    goto _jump88;
    _jump87:;
    _175 = _170;
    _jump88:;
    _159 += _175;
    _170++;
    if (_170 < _169)
    goto _jump86;
    _170 = 0;
    _171++;
    if (_171 < _167)
    goto _jump86;
    _171 = 0;
    _172++;
    if (_172 < _160)
    goto _jump86;
    // End body of loop
    int64_t _176 = -_159;
    int64_t _177 = _158 + _176;
    int64_t _178 = 964;
    if (_177 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (_177 < _147.d0)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    if (_178 >= 0)
    goto _jump91;
    fail_assertion("negative array index");
    _jump91:;
    if (_178 < _147.d1)
    goto _jump92;
    fail_assertion("index too large");
    _jump92:;
    int64_t _179 = 0;
    _179 *= _147.d0;
    _179 += _177;
    _179 *= _147.d1;
    _179 += _178;
    int64_t _180 = _147.data[_179];
    _0.d1 = _180;
    if (_180 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing bound for c
    int64_t _181 = 205;
    _0.d2 = _181;
    if (_181 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= _2;
    _182 *= _180;
    _182 *= _181;
    _182 *= sizeof(_a1_int64_t);
    _0.data = jpl_alloc(_182);
    int64_t _183 = 0; // c
    int64_t _184 = 0; // b
    int64_t _185 = 0; // a
    _jump95:; // Begin body of loop
    _a1_int64_t _186;
    _186.d0 = 2;
    _186.data = jpl_alloc(sizeof(int64_t) * 2);
    _186.data[0] = _184;
    _186.data[1] = _184;
    int64_t _187 = 0;
    _187 *= _0.d0;
    _187 += _185;
    _187 *= _0.d1;
    _187 += _184;
    _187 *= _0.d2;
    _187 += _183;
    _0.data[_187] = _186;
    _183++;
    if (_183 < _181)
    goto _jump95;
    _183 = 0;
    _184++;
    if (_184 < _180)
    goto _jump95;
    _184 = 0;
    _185++;
    if (_185 < _2)
    goto _jump95;
    // End body of loop
    _a2_bool _188;
    // Computing bound for e
    _188.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing bound for f
    int64_t _189;
    // Computing bound for e
    if (_0.d0 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    _189 = 0;
    int64_t _190 = 0; // e
    _jump98:; // Begin body of loop
    int64_t _191 = -_190;
    _189 += _191;
    _190++;
    if (_190 < _0.d0)
    goto _jump98;
    // End body of loop
    _188.d1 = _189;
    if (_189 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= _0.d0;
    _192 *= _189;
    _192 *= sizeof(bool);
    _188.data = jpl_alloc(_192);
    int64_t _193 = 0; // f
    int64_t _194 = 0; // e
    _jump100:; // Begin body of loop
    int64_t _195 = _194 + _193;
    bool _196 = _193 >= _195;
    int64_t _197 = 0;
    _197 *= _188.d0;
    _197 += _194;
    _197 *= _188.d1;
    _197 += _193;
    _188.data[_197] = _196;
    _193++;
    if (_193 < _189)
    goto _jump100;
    _193 = 0;
    _194++;
    if (_194 < _0.d0)
    goto _jump100;
    // End body of loop
    double _198 = get_time();
    _a1_bool _199;
    // Computing bound for f
    _a1__a2_int64_t _200;
    // Computing bound for f
    _200.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump101;
    fail_assertion("non-positive loop bound");
    _jump101:;
    // Computing total size of heap memory to allocate
    int64_t _201 = 1;
    _201 *= _0.d2;
    _201 *= sizeof(_a2_int64_t);
    _200.data = jpl_alloc(_201);
    int64_t _202 = 0; // f
    _jump102:; // Begin body of loop
    _a2_int64_t _203;
    // Computing bound for g
    _203.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    // Computing bound for h
    bool _204 = true;
    int64_t _205;
    if (!_204)
    goto _jump104;
    _205 = _0.d0;
    goto _jump105;
    _jump104:;
    int64_t _206 = 966;
    _205 = _206;
    _jump105:;
    _203.d1 = _205;
    if (_205 > 0) 
    goto _jump106;
    fail_assertion("non-positive loop bound");
    _jump106:;
    // Computing total size of heap memory to allocate
    int64_t _207 = 1;
    _207 *= _0.d1;
    _207 *= _205;
    _207 *= sizeof(int64_t);
    _203.data = jpl_alloc(_207);
    int64_t _208 = 0; // h
    int64_t _209 = 0; // g
    _jump107:; // Begin body of loop
    int64_t _210 = 0;
    _210 *= _203.d0;
    _210 += _209;
    _210 *= _203.d1;
    _210 += _208;
    _203.data[_210] = _0.d1;
    _208++;
    if (_208 < _205)
    goto _jump107;
    _208 = 0;
    _209++;
    if (_209 < _0.d1)
    goto _jump107;
    // End body of loop
    int64_t _211 = 0;
    _211 *= _200.d0;
    _211 += _202;
    _200.data[_211] = _203;
    _202++;
    if (_202 < _0.d2)
    goto _jump102;
    // End body of loop
    int64_t _212 = 67;
    if (_212 >= 0)
    goto _jump108;
    fail_assertion("negative array index");
    _jump108:;
    if (_212 < _200.d0)
    goto _jump109;
    fail_assertion("index too large");
    _jump109:;
    int64_t _213 = 0;
    _213 *= _200.d0;
    _213 += _212;
    _a2_int64_t _214 = _200.data[_213];
    int64_t _215;
    // Computing bound for f
    int64_t _216 = 421;
    if (_216 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing bound for g
    bool _218 = false;
    bool _217 = _218;
    if (0 != _218)
    goto _jump111;
    bool _219 = false;
    _217 = _219;
    _jump111:;
    _a2_int64_t _220;
    if (!_217)
    goto _jump112;
    _a2_int64_t _221;
    // Computing bound for f
    _221.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    // Computing bound for g
    _221.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    // Computing total size of heap memory to allocate
    int64_t _222 = 1;
    _222 *= _0.d0;
    _222 *= _0.d1;
    _222 *= sizeof(int64_t);
    _221.data = jpl_alloc(_222);
    int64_t _223 = 0; // g
    int64_t _224 = 0; // f
    _jump115:; // Begin body of loop
    int64_t _225 = 934;
    int64_t _226 = 0;
    _226 *= _221.d0;
    _226 += _224;
    _226 *= _221.d1;
    _226 += _223;
    _221.data[_226] = _225;
    _223++;
    if (_223 < _0.d1)
    goto _jump115;
    _223 = 0;
    _224++;
    if (_224 < _0.d0)
    goto _jump115;
    // End body of loop
    _220 = _221;
    goto _jump116;
    _jump112:;
    _a2_int64_t _227;
    // Computing bound for f
    _227.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump117;
    fail_assertion("non-positive loop bound");
    _jump117:;
    // Computing bound for g
    _227.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump118;
    fail_assertion("non-positive loop bound");
    _jump118:;
    // Computing total size of heap memory to allocate
    int64_t _228 = 1;
    _228 *= _0.d0;
    _228 *= _0.d0;
    _228 *= sizeof(int64_t);
    _227.data = jpl_alloc(_228);
    int64_t _229 = 0; // g
    int64_t _230 = 0; // f
    _jump119:; // Begin body of loop
    int64_t _231 = 992;
    int64_t _232 = 0;
    _232 *= _227.d0;
    _232 += _230;
    _232 *= _227.d1;
    _232 += _229;
    _227.data[_232] = _231;
    _229++;
    if (_229 < _0.d0)
    goto _jump119;
    _229 = 0;
    _230++;
    if (_230 < _0.d0)
    goto _jump119;
    // End body of loop
    _220 = _227;
    _jump116:;
    _a2_int64_t _233;
    // Computing bound for f
    _233.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    // Computing bound for g
    _233.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump121;
    fail_assertion("non-positive loop bound");
    _jump121:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= _0.d2;
    _234 *= _0.d1;
    _234 *= sizeof(int64_t);
    _233.data = jpl_alloc(_234);
    int64_t _235 = 0; // g
    int64_t _236 = 0; // f
    _jump122:; // Begin body of loop
    int64_t _237 = 0;
    _237 *= _233.d0;
    _237 += _236;
    _237 *= _233.d1;
    _237 += _235;
    _233.data[_237] = _0.d2;
    _235++;
    if (_235 < _0.d1)
    goto _jump122;
    _235 = 0;
    _236++;
    if (_236 < _0.d2)
    goto _jump122;
    // End body of loop
    int64_t _238;
    // Computing bound for f
    if (_0.d2 > 0) 
    goto _jump123;
    fail_assertion("non-positive loop bound");
    _jump123:;
    _238 = 0;
    int64_t _239 = 0; // f
    _jump124:; // Begin body of loop
    _238 += _239;
    _239++;
    if (_239 < _0.d2)
    goto _jump124;
    // End body of loop
    if (_238 >= 0)
    goto _jump125;
    fail_assertion("negative array index");
    _jump125:;
    if (_238 < _233.d0)
    goto _jump126;
    fail_assertion("index too large");
    _jump126:;
    if (_0.d2 >= 0)
    goto _jump127;
    fail_assertion("negative array index");
    _jump127:;
    if (_0.d2 < _233.d1)
    goto _jump128;
    fail_assertion("index too large");
    _jump128:;
    int64_t _240 = 0;
    _240 *= _233.d0;
    _240 += _238;
    _240 *= _233.d1;
    _240 += _0.d2;
    int64_t _241 = _233.data[_240];
    if (_241 >= 0)
    goto _jump129;
    fail_assertion("negative array index");
    _jump129:;
    if (_241 < _220.d0)
    goto _jump130;
    fail_assertion("index too large");
    _jump130:;
    if (_0.d0 >= 0)
    goto _jump131;
    fail_assertion("negative array index");
    _jump131:;
    if (_0.d0 < _220.d1)
    goto _jump132;
    fail_assertion("index too large");
    _jump132:;
    int64_t _242 = 0;
    _242 *= _220.d0;
    _242 += _241;
    _242 *= _220.d1;
    _242 += _0.d0;
    int64_t _243 = _220.data[_242];
    if (_243 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump134;
    fail_assertion("non-positive loop bound");
    _jump134:;
    _215 = 0;
    int64_t _244 = 0; // h
    int64_t _245 = 0; // g
    int64_t _246 = 0; // f
    _jump135:; // Begin body of loop
    int64_t _247 = 28;
    _215 += _247;
    _244++;
    if (_244 < _0.d1)
    goto _jump135;
    _244 = 0;
    _245++;
    if (_245 < _243)
    goto _jump135;
    _245 = 0;
    _246++;
    if (_246 < _216)
    goto _jump135;
    // End body of loop
    if (_215 >= 0)
    goto _jump136;
    fail_assertion("negative array index");
    _jump136:;
    if (_215 < _214.d0)
    goto _jump137;
    fail_assertion("index too large");
    _jump137:;
    if (_0.d2 >= 0)
    goto _jump138;
    fail_assertion("negative array index");
    _jump138:;
    if (_0.d2 < _214.d1)
    goto _jump139;
    fail_assertion("index too large");
    _jump139:;
    int64_t _248 = 0;
    _248 *= _214.d0;
    _248 += _215;
    _248 *= _214.d1;
    _248 += _0.d2;
    int64_t _249 = _214.data[_248];
    _199.d0 = _249;
    if (_249 > 0) 
    goto _jump140;
    fail_assertion("non-positive loop bound");
    _jump140:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= _249;
    _250 *= sizeof(bool);
    _199.data = jpl_alloc(_250);
    int64_t _251 = 0; // f
    _jump141:; // Begin body of loop
    int64_t _252 = -_251;
    int64_t _253 = 181;
    if (_0.d1 >= 0)
    goto _jump142;
    fail_assertion("negative array index");
    _jump142:;
    if (_0.d1 < _188.d0)
    goto _jump143;
    fail_assertion("index too large");
    _jump143:;
    if (_253 >= 0)
    goto _jump144;
    fail_assertion("negative array index");
    _jump144:;
    if (_253 < _188.d1)
    goto _jump145;
    fail_assertion("index too large");
    _jump145:;
    int64_t _254 = 0;
    _254 *= _188.d0;
    _254 += _0.d1;
    _254 *= _188.d1;
    _254 += _253;
    bool _255 = _188.data[_254];
    int64_t _256;
    if (!_255)
    goto _jump146;
    int64_t _257 = _0.d2 % _0.d2;
    _256 = _257;
    goto _jump147;
    _jump146:;
    int64_t _258 = -_0.d2;
    _256 = _258;
    _jump147:;
    int64_t _259 = _252 * _256;
    if (_259 >= 0)
    goto _jump148;
    fail_assertion("negative array index");
    _jump148:;
    if (_259 < _188.d0)
    goto _jump149;
    fail_assertion("index too large");
    _jump149:;
    if (_0.d0 >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (_0.d0 < _188.d1)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    int64_t _260 = 0;
    _260 *= _188.d0;
    _260 += _259;
    _260 *= _188.d1;
    _260 += _0.d0;
    bool _261 = _188.data[_260];
    int64_t _262 = 0;
    _262 *= _199.d0;
    _262 += _251;
    _199.data[_262] = _261;
    _251++;
    if (_251 < _249)
    goto _jump141;
    // End body of loop
    double _263 = get_time();
    print_time(_263 - _198);
    if (_0.d1 >= 0)
    goto _jump418;
    fail_assertion("negative array index");
    _jump418:;
    if (_0.d1 < _188.d0)
    goto _jump419;
    fail_assertion("index too large");
    _jump419:;
    if (_0.d2 >= 0)
    goto _jump420;
    fail_assertion("negative array index");
    _jump420:;
    if (_0.d2 < _188.d1)
    goto _jump421;
    fail_assertion("index too large");
    _jump421:;
    int64_t _264 = 0;
    _264 *= _188.d0;
    _264 += _0.d1;
    _264 *= _188.d1;
    _264 += _0.d2;
    bool _265 = _188.data[_264];
    _a1_bool _266;
    if (!_265)
    goto _jump422;
    double _268 = 6.0;
    double _269 = -_268;
    double _270 = 46.0;
    bool _271 = _269 > _270;
    bool _272;
    if (!_271)
    goto _jump423;
    _a3_bool _273;
    // Computing bound for n
    _273.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing bound for o
    _273.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing bound for p
    _273.d2 = _199.d0;
    if (_199.d0 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= _0.d2;
    _274 *= _0.d1;
    _274 *= _199.d0;
    _274 *= sizeof(bool);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // p
    int64_t _276 = 0; // o
    int64_t _277 = 0; // n
    _jump427:; // Begin body of loop
    bool _278 = l();
    int64_t _279 = 0;
    _279 *= _273.d0;
    _279 += _277;
    _279 *= _273.d1;
    _279 += _276;
    _279 *= _273.d2;
    _279 += _275;
    _273.data[_279] = _278;
    _275++;
    if (_275 < _199.d0)
    goto _jump427;
    _275 = 0;
    _276++;
    if (_276 < _0.d1)
    goto _jump427;
    _276 = 0;
    _277++;
    if (_277 < _0.d2)
    goto _jump427;
    // End body of loop
    int64_t _280 = 725;
    if (_0.d1 >= 0)
    goto _jump428;
    fail_assertion("negative array index");
    _jump428:;
    if (_0.d1 < _273.d0)
    goto _jump429;
    fail_assertion("index too large");
    _jump429:;
    if (_199.d0 >= 0)
    goto _jump430;
    fail_assertion("negative array index");
    _jump430:;
    if (_199.d0 < _273.d1)
    goto _jump431;
    fail_assertion("index too large");
    _jump431:;
    if (_280 >= 0)
    goto _jump432;
    fail_assertion("negative array index");
    _jump432:;
    if (_280 < _273.d2)
    goto _jump433;
    fail_assertion("index too large");
    _jump433:;
    int64_t _281 = 0;
    _281 *= _273.d0;
    _281 += _0.d1;
    _281 *= _273.d1;
    _281 += _199.d0;
    _281 *= _273.d2;
    _281 += _280;
    bool _282 = _273.data[_281];
    _272 = _282;
    goto _jump434;
    _jump423:;
    int64_t _283 = 80;
    bool _284 = _0.d1 >= _283;
    _272 = _284;
    _jump434:;
    bool _285 = l();
    bool _286 = !_285;
    bool _287 = _272 != _286;
    bool _267 = _287;
    if (0 != _287)
    goto _jump435;
    double _288 = 9.0;
    double _289 = -_288;
    double _290 = -_289;
    bool _291 = l();
    _a1_double _292;
    if (!_291)
    goto _jump436;
    _a1_double _293;
    // Computing bound for n
    _293.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _294 = 1;
    _294 *= _0.d0;
    _294 *= sizeof(double);
    _293.data = jpl_alloc(_294);
    int64_t _295 = 0; // n
    _jump438:; // Begin body of loop
    double _296 = 71.0;
    int64_t _297 = 0;
    _297 *= _293.d0;
    _297 += _295;
    _293.data[_297] = _296;
    _295++;
    if (_295 < _0.d0)
    goto _jump438;
    // End body of loop
    _292 = _293;
    goto _jump439;
    _jump436:;
    _a1_double _298;
    // Computing bound for n
    _298.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump440;
    fail_assertion("non-positive loop bound");
    _jump440:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= _0.d0;
    _299 *= sizeof(double);
    _298.data = jpl_alloc(_299);
    int64_t _300 = 0; // n
    _jump441:; // Begin body of loop
    double _301 = 85.0;
    int64_t _302 = 0;
    _302 *= _298.d0;
    _302 += _300;
    _298.data[_302] = _301;
    _300++;
    if (_300 < _0.d0)
    goto _jump441;
    // End body of loop
    _292 = _298;
    _jump439:;
    bool _303 = _199.d0 < _0.d0;
    int64_t _304;
    if (!_303)
    goto _jump442;
    int64_t _305 = 887;
    _304 = _305;
    goto _jump443;
    _jump442:;
    int64_t _306 = 999;
    _304 = _306;
    _jump443:;
    if (_304 >= 0)
    goto _jump444;
    fail_assertion("negative array index");
    _jump444:;
    if (_304 < _292.d0)
    goto _jump445;
    fail_assertion("index too large");
    _jump445:;
    int64_t _307 = 0;
    _307 *= _292.d0;
    _307 += _304;
    double _308 = _292.data[_307];
    bool _309 = _290 <= _308;
    _267 = _309;
    _jump435:;
    _a1_bool _310;
    if (!_267)
    goto _jump446;
    _310 = _199;
    goto _jump447;
    _jump446:;
    bool _311 = false;
    int64_t _312;
    if (!_311)
    goto _jump448;
    int64_t _313 = 410;
    int64_t _314 = _0.d0 - _313;
    _312 = _314;
    goto _jump449;
    _jump448:;
    _312 = _0.d2;
    _jump449:;
    int64_t _315 = 818;
    int64_t _316 = _312 % _315;
    if (_316 >= 0)
    goto _jump450;
    fail_assertion("negative array index");
    _jump450:;
    if (_316 < _199.d0)
    goto _jump451;
    fail_assertion("index too large");
    _jump451:;
    int64_t _317 = 0;
    _317 *= _199.d0;
    _317 += _316;
    bool _318 = _199.data[_317];
    _a1_bool _319;
    _319.d0 = 1;
    _319.data = jpl_alloc(sizeof(bool) * 1);
    _319.data[0] = _318;
    _310 = _319;
    _jump447:;
    _266 = _310;
    goto _jump452;
    _jump422:;
    bool _320 = _0.d0 <= _0.d2;
    double _321 = 8.0;
    double _322 = -_321;
    double _323 = 33.0;
    double _324 = 33.0;
    double _325 = -_324;
    double _326 = -_325;
    _a2_double _327;
    // Computing bound for n
    int64_t _328 = 475;
    _327.d0 = _328;
    if (_328 > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    // Computing bound for o
    _327.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= _328;
    _329 *= _0.d0;
    _329 *= sizeof(double);
    _327.data = jpl_alloc(_329);
    int64_t _330 = 0; // o
    int64_t _331 = 0; // n
    _jump455:; // Begin body of loop
    double _332 = 84.0;
    int64_t _333 = 0;
    _333 *= _327.d0;
    _333 += _331;
    _333 *= _327.d1;
    _333 += _330;
    _327.data[_333] = _332;
    _330++;
    if (_330 < _0.d0)
    goto _jump455;
    _330 = 0;
    _331++;
    if (_331 < _328)
    goto _jump455;
    // End body of loop
    if (_0.d2 >= 0)
    goto _jump456;
    fail_assertion("negative array index");
    _jump456:;
    if (_0.d2 < _327.d0)
    goto _jump457;
    fail_assertion("index too large");
    _jump457:;
    if (_0.d1 >= 0)
    goto _jump458;
    fail_assertion("negative array index");
    _jump458:;
    if (_0.d1 < _327.d1)
    goto _jump459;
    fail_assertion("index too large");
    _jump459:;
    int64_t _334 = 0;
    _334 *= _327.d0;
    _334 += _0.d2;
    _334 *= _327.d1;
    _334 += _0.d1;
    double _335 = _327.data[_334];
    _a1_double _336;
    // Computing bound for n
    _336.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump460;
    fail_assertion("non-positive loop bound");
    _jump460:;
    // Computing total size of heap memory to allocate
    int64_t _337 = 1;
    _337 *= _0.d0;
    _337 *= sizeof(double);
    _336.data = jpl_alloc(_337);
    int64_t _338 = 0; // n
    _jump461:; // Begin body of loop
    double _339 = 72.0;
    int64_t _340 = 0;
    _340 *= _336.d0;
    _340 += _338;
    _336.data[_340] = _339;
    _338++;
    if (_338 < _0.d0)
    goto _jump461;
    // End body of loop
    int64_t _341;
    // Computing bound for n
    if (_0.d1 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    _341 = 0;
    int64_t _342 = 0; // n
    _jump463:; // Begin body of loop
    _341 += _0.d0;
    _342++;
    if (_342 < _0.d1)
    goto _jump463;
    // End body of loop
    if (_341 >= 0)
    goto _jump464;
    fail_assertion("negative array index");
    _jump464:;
    if (_341 < _336.d0)
    goto _jump465;
    fail_assertion("index too large");
    _jump465:;
    int64_t _343 = 0;
    _343 *= _336.d0;
    _343 += _341;
    double _344 = _336.data[_343];
    rgba _345 = { _323, _326, _335, _344 };
    double _346 = _345.g;
    bool _347 = _322 != _346;
    int64_t _348 = 536;
    if (_0.d0 >= 0)
    goto _jump466;
    fail_assertion("negative array index");
    _jump466:;
    if (_0.d0 < _188.d0)
    goto _jump467;
    fail_assertion("index too large");
    _jump467:;
    if (_348 >= 0)
    goto _jump468;
    fail_assertion("negative array index");
    _jump468:;
    if (_348 < _188.d1)
    goto _jump469;
    fail_assertion("index too large");
    _jump469:;
    int64_t _349 = 0;
    _349 *= _188.d0;
    _349 += _0.d0;
    _349 *= _188.d1;
    _349 += _348;
    bool _350 = _188.data[_349];
    _a1_bool _351;
    _351.d0 = 3;
    _351.data = jpl_alloc(sizeof(bool) * 3);
    _351.data[0] = _320;
    _351.data[1] = _347;
    _351.data[2] = _350;
    _266 = _351;
    _jump452:;
    print("p");
    print("q");
    int64_t _352 = 709;
    int64_t _353 = 560;
    bool _354 = _0.d0 <= _353;
    bool _355 = !_354;
    bool _356 = !_355;
    _a1__a1_bool _357;
    if (!_356)
    goto _jump603;
    _a3__a2__a1__a1_bool _358;
    // Computing bound for s
    _358.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    // Computing bound for t
    _358.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for u
    bool _359 = true;
    int64_t _360;
    if (!_359)
    goto _jump606;
    _360 = _0.d1;
    goto _jump607;
    _jump606:;
    _360 = _199.d0;
    _jump607:;
    _358.d2 = _360;
    if (_360 > 0) 
    goto _jump608;
    fail_assertion("non-positive loop bound");
    _jump608:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= _0.d1;
    _361 *= _0.d0;
    _361 *= _360;
    _361 *= sizeof(_a2__a1__a1_bool);
    _358.data = jpl_alloc(_361);
    int64_t _362 = 0; // u
    int64_t _363 = 0; // t
    int64_t _364 = 0; // s
    _jump609:; // Begin body of loop
    _a2__a1__a1_bool _365;
    // Computing bound for v
    int64_t _366;
    // Computing bound for v
    if (_0.d2 > 0) 
    goto _jump610;
    fail_assertion("non-positive loop bound");
    _jump610:;
    _366 = 0;
    int64_t _367 = 0; // v
    _jump611:; // Begin body of loop
    _366 += _362;
    _367++;
    if (_367 < _0.d2)
    goto _jump611;
    // End body of loop
    _365.d0 = _366;
    if (_366 > 0) 
    goto _jump612;
    fail_assertion("non-positive loop bound");
    _jump612:;
    // Computing bound for w
    _365.d1 = _199.d0;
    if (_199.d0 > 0) 
    goto _jump613;
    fail_assertion("non-positive loop bound");
    _jump613:;
    // Computing total size of heap memory to allocate
    int64_t _368 = 1;
    _368 *= _366;
    _368 *= _199.d0;
    _368 *= sizeof(_a1__a1_bool);
    _365.data = jpl_alloc(_368);
    int64_t _369 = 0; // w
    int64_t _370 = 0; // v
    _jump614:; // Begin body of loop
    _a1__a1_bool _371;
    // Computing bound for x
    _371.d0 = _363;
    if (_363 > 0) 
    goto _jump615;
    fail_assertion("non-positive loop bound");
    _jump615:;
    // Computing total size of heap memory to allocate
    int64_t _372 = 1;
    _372 *= _363;
    _372 *= sizeof(_a1_bool);
    _371.data = jpl_alloc(_372);
    int64_t _373 = 0; // x
    _jump616:; // Begin body of loop
    int64_t _374 = 0;
    _374 *= _371.d0;
    _374 += _373;
    _371.data[_374] = _199;
    _373++;
    if (_373 < _363)
    goto _jump616;
    // End body of loop
    int64_t _375 = 0;
    _375 *= _365.d0;
    _375 += _370;
    _375 *= _365.d1;
    _375 += _369;
    _365.data[_375] = _371;
    _369++;
    if (_369 < _199.d0)
    goto _jump614;
    _369 = 0;
    _370++;
    if (_370 < _366)
    goto _jump614;
    // End body of loop
    int64_t _376 = 0;
    _376 *= _358.d0;
    _376 += _364;
    _376 *= _358.d1;
    _376 += _363;
    _376 *= _358.d2;
    _376 += _362;
    _358.data[_376] = _365;
    _362++;
    if (_362 < _360)
    goto _jump609;
    _362 = 0;
    _363++;
    if (_363 < _0.d0)
    goto _jump609;
    _363 = 0;
    _364++;
    if (_364 < _0.d1)
    goto _jump609;
    // End body of loop
    int64_t _377 = 298;
    int64_t _378 = _266.d0 / _0.d0;
    int64_t _379 = _0.d0 + _378;
    int64_t _380 = 968;
    if (_377 >= 0)
    goto _jump617;
    fail_assertion("negative array index");
    _jump617:;
    if (_377 < _358.d0)
    goto _jump618;
    fail_assertion("index too large");
    _jump618:;
    if (_379 >= 0)
    goto _jump619;
    fail_assertion("negative array index");
    _jump619:;
    if (_379 < _358.d1)
    goto _jump620;
    fail_assertion("index too large");
    _jump620:;
    if (_380 >= 0)
    goto _jump621;
    fail_assertion("negative array index");
    _jump621:;
    if (_380 < _358.d2)
    goto _jump622;
    fail_assertion("index too large");
    _jump622:;
    int64_t _381 = 0;
    _381 *= _358.d0;
    _381 += _377;
    _381 *= _358.d1;
    _381 += _379;
    _381 *= _358.d2;
    _381 += _380;
    _a2__a1__a1_bool _382 = _358.data[_381];
    int64_t _383;
    // Computing bound for s
    int64_t _384 = -_0.d0;
    if (_384 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    _383 = 0;
    int64_t _385 = 0; // s
    _jump624:; // Begin body of loop
    int64_t _386;
    // Computing bound for t
    int64_t _387 = _352 * _385;
    if (_387 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    _386 = 0;
    int64_t _388 = 0; // t
    _jump626:; // Begin body of loop
    _386 += _199.d0;
    _388++;
    if (_388 < _387)
    goto _jump626;
    // End body of loop
    _383 += _386;
    _385++;
    if (_385 < _384)
    goto _jump624;
    // End body of loop
    if (_383 >= 0)
    goto _jump627;
    fail_assertion("negative array index");
    _jump627:;
    if (_383 < _382.d0)
    goto _jump628;
    fail_assertion("index too large");
    _jump628:;
    if (_352 >= 0)
    goto _jump629;
    fail_assertion("negative array index");
    _jump629:;
    if (_352 < _382.d1)
    goto _jump630;
    fail_assertion("index too large");
    _jump630:;
    int64_t _389 = 0;
    _389 *= _382.d0;
    _389 += _383;
    _389 *= _382.d1;
    _389 += _352;
    _a1__a1_bool _390 = _382.data[_389];
    _357 = _390;
    goto _jump631;
    _jump603:;
    _a3__a1__a1_bool _391;
    // Computing bound for s
    _391.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump632;
    fail_assertion("non-positive loop bound");
    _jump632:;
    // Computing bound for t
    _391.d1 = _352;
    if (_352 > 0) 
    goto _jump633;
    fail_assertion("non-positive loop bound");
    _jump633:;
    // Computing bound for u
    _391.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump634;
    fail_assertion("non-positive loop bound");
    _jump634:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= _0.d2;
    _392 *= _352;
    _392 *= _0.d0;
    _392 *= sizeof(_a1__a1_bool);
    _391.data = jpl_alloc(_392);
    int64_t _393 = 0; // u
    int64_t _394 = 0; // t
    int64_t _395 = 0; // s
    _jump635:; // Begin body of loop
    bool _396 = _0.d1 != _266.d0;
    bool _397 = !_396;
    _a1__a1_bool _398;
    if (!_397)
    goto _jump636;
    bool _399 = false;
    _a1__a1_bool _400;
    if (!_399)
    goto _jump637;
    _a1__a1_bool _401;
    // Computing bound for v
    _401.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    // Computing total size of heap memory to allocate
    int64_t _402 = 1;
    _402 *= _0.d0;
    _402 *= sizeof(_a1_bool);
    _401.data = jpl_alloc(_402);
    int64_t _403 = 0; // v
    _jump639:; // Begin body of loop
    int64_t _404 = 0;
    _404 *= _401.d0;
    _404 += _403;
    _401.data[_404] = _266;
    _403++;
    if (_403 < _0.d0)
    goto _jump639;
    // End body of loop
    _400 = _401;
    goto _jump640;
    _jump637:;
    _a1__a1_bool _405;
    // Computing bound for v
    _405.d0 = _352;
    if (_352 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _352;
    _406 *= sizeof(_a1_bool);
    _405.data = jpl_alloc(_406);
    int64_t _407 = 0; // v
    _jump642:; // Begin body of loop
    int64_t _408 = 0;
    _408 *= _405.d0;
    _408 += _407;
    _405.data[_408] = _199;
    _407++;
    if (_407 < _352)
    goto _jump642;
    // End body of loop
    _400 = _405;
    _jump640:;
    _398 = _400;
    goto _jump643;
    _jump636:;
    _a1_bool _409;
    // Computing bound for v
    _409.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump644;
    fail_assertion("non-positive loop bound");
    _jump644:;
    // Computing total size of heap memory to allocate
    int64_t _410 = 1;
    _410 *= _0.d2;
    _410 *= sizeof(bool);
    _409.data = jpl_alloc(_410);
    int64_t _411 = 0; // v
    _jump645:; // Begin body of loop
    bool _412 = l();
    int64_t _413 = 0;
    _413 *= _409.d0;
    _413 += _411;
    _409.data[_413] = _412;
    _411++;
    if (_411 < _0.d2)
    goto _jump645;
    // End body of loop
    bool _414 = true;
    bool _415 = true;
    _a1_bool _416;
    _416.d0 = 2;
    _416.data = jpl_alloc(sizeof(bool) * 2);
    _416.data[0] = _414;
    _416.data[1] = _415;
    _a1__a1_bool _417;
    _417.d0 = 3;
    _417.data = jpl_alloc(sizeof(_a1_bool) * 3);
    _417.data[0] = _409;
    _417.data[1] = _416;
    _417.data[2] = _199;
    _398 = _417;
    _jump643:;
    int64_t _418 = 0;
    _418 *= _391.d0;
    _418 += _395;
    _418 *= _391.d1;
    _418 += _394;
    _418 *= _391.d2;
    _418 += _393;
    _391.data[_418] = _398;
    _393++;
    if (_393 < _0.d0)
    goto _jump635;
    _393 = 0;
    _394++;
    if (_394 < _352)
    goto _jump635;
    _394 = 0;
    _395++;
    if (_395 < _0.d2)
    goto _jump635;
    // End body of loop
    int64_t _419 = _199.d0 / _0.d1;
    if (_419 >= 0)
    goto _jump646;
    fail_assertion("negative array index");
    _jump646:;
    if (_419 < _391.d0)
    goto _jump647;
    fail_assertion("index too large");
    _jump647:;
    if (_0.d2 >= 0)
    goto _jump648;
    fail_assertion("negative array index");
    _jump648:;
    if (_0.d2 < _391.d1)
    goto _jump649;
    fail_assertion("index too large");
    _jump649:;
    if (_0.d0 >= 0)
    goto _jump650;
    fail_assertion("negative array index");
    _jump650:;
    if (_0.d0 < _391.d2)
    goto _jump651;
    fail_assertion("index too large");
    _jump651:;
    int64_t _420 = 0;
    _420 *= _391.d0;
    _420 += _419;
    _420 *= _391.d1;
    _420 += _0.d2;
    _420 *= _391.d2;
    _420 += _0.d0;
    _a1__a1_bool _421 = _391.data[_420];
    _357 = _421;
    _jump631:;
    _a3_int64_t _422;
    // Computing bound for s
    _422.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump652;
    fail_assertion("non-positive loop bound");
    _jump652:;
    // Computing bound for t
    _422.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    // Computing bound for u
    int64_t _423;
    // Computing bound for s
    bool _424 = l();
    int64_t _425;
    if (!_424)
    goto _jump654;
    int64_t _426;
    // Computing bound for s
    if (_0.d2 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for t
    if (_0.d2 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing bound for u
    if (_0.d2 > 0) 
    goto _jump657;
    fail_assertion("non-positive loop bound");
    _jump657:;
    _426 = 0;
    int64_t _427 = 0; // u
    int64_t _428 = 0; // t
    int64_t _429 = 0; // s
    _jump658:; // Begin body of loop
    _426 += _427;
    _427++;
    if (_427 < _0.d2)
    goto _jump658;
    _427 = 0;
    _428++;
    if (_428 < _0.d2)
    goto _jump658;
    _428 = 0;
    _429++;
    if (_429 < _0.d2)
    goto _jump658;
    // End body of loop
    _425 = _426;
    goto _jump659;
    _jump654:;
    _425 = _0.d2;
    _jump659:;
    if (_425 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for t
    int64_t _430;
    // Computing bound for s
    if (_266.d0 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing bound for t
    int64_t _431 = -_0.d2;
    if (_431 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    _430 = 0;
    int64_t _432 = 0; // t
    int64_t _433 = 0; // s
    _jump663:; // Begin body of loop
    _430 += _0.d1;
    _432++;
    if (_432 < _431)
    goto _jump663;
    _432 = 0;
    _433++;
    if (_433 < _266.d0)
    goto _jump663;
    // End body of loop
    if (_430 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    _423 = 0;
    int64_t _434 = 0; // t
    int64_t _435 = 0; // s
    _jump665:; // Begin body of loop
    _423 += _266.d0;
    _434++;
    if (_434 < _430)
    goto _jump665;
    _434 = 0;
    _435++;
    if (_435 < _425)
    goto _jump665;
    // End body of loop
    _422.d2 = _423;
    if (_423 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing total size of heap memory to allocate
    int64_t _436 = 1;
    _436 *= _0.d0;
    _436 *= _0.d0;
    _436 *= _423;
    _436 *= sizeof(int64_t);
    _422.data = jpl_alloc(_436);
    int64_t _437 = 0; // u
    int64_t _438 = 0; // t
    int64_t _439 = 0; // s
    _jump667:; // Begin body of loop
    int64_t _440 = 0;
    _440 *= _422.d0;
    _440 += _439;
    _440 *= _422.d1;
    _440 += _438;
    _440 *= _422.d2;
    _440 += _437;
    _422.data[_440] = _437;
    _437++;
    if (_437 < _423)
    goto _jump667;
    _437 = 0;
    _438++;
    if (_438 < _0.d0)
    goto _jump667;
    _438 = 0;
    _439++;
    if (_439 < _0.d0)
    goto _jump667;
    // End body of loop
    if (_199.d0 >= 0)
    goto _jump668;
    fail_assertion("negative array index");
    _jump668:;
    if (_199.d0 < _422.d0)
    goto _jump669;
    fail_assertion("index too large");
    _jump669:;
    if (_199.d0 >= 0)
    goto _jump670;
    fail_assertion("negative array index");
    _jump670:;
    if (_199.d0 < _422.d1)
    goto _jump671;
    fail_assertion("index too large");
    _jump671:;
    if (_352 >= 0)
    goto _jump672;
    fail_assertion("negative array index");
    _jump672:;
    if (_352 < _422.d2)
    goto _jump673;
    fail_assertion("index too large");
    _jump673:;
    int64_t _441 = 0;
    _441 *= _422.d0;
    _441 += _199.d0;
    _441 *= _422.d1;
    _441 += _199.d0;
    _441 *= _422.d2;
    _441 += _352;
    int64_t _442 = _422.data[_441];
    int64_t _443 = _442 / _266.d0;
    if (_443 >= 0)
    goto _jump674;
    fail_assertion("negative array index");
    _jump674:;
    if (_443 < _357.d0)
    goto _jump675;
    fail_assertion("index too large");
    _jump675:;
    int64_t _444 = 0;
    _444 *= _357.d0;
    _444 += _443;
    _a1_bool _445 = _357.data[_444];
    _a2__a3__a1_int64_t _446;
    // Computing bound for u
    _446.d0 = _445.d0;
    if (_445.d0 > 0) 
    goto _jump676;
    fail_assertion("non-positive loop bound");
    _jump676:;
    // Computing bound for v
    int64_t _447 = -_0.d2;
    _446.d1 = _447;
    if (_447 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    // Computing total size of heap memory to allocate
    int64_t _448 = 1;
    _448 *= _445.d0;
    _448 *= _447;
    _448 *= sizeof(_a3__a1_int64_t);
    _446.data = jpl_alloc(_448);
    int64_t _449 = 0; // v
    int64_t _450 = 0; // u
    _jump678:; // Begin body of loop
    int64_t _451 = 0;
    _451 *= _446.d0;
    _451 += _450;
    _451 *= _446.d1;
    _451 += _449;
    _446.data[_451] = _0;
    _449++;
    if (_449 < _447)
    goto _jump678;
    _449 = 0;
    _450++;
    if (_450 < _445.d0)
    goto _jump678;
    // End body of loop
    double _452 = get_time();
    double _453;
    // Computing bound for x
    if (_266.d0 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing bound for y
    if (_0.d1 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing bound for z
    if (_446.d0 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    _453 = 0;
    int64_t _454 = 0; // z
    int64_t _455 = 0; // y
    int64_t _456 = 0; // x
    _jump682:; // Begin body of loop
    double _457;
    // Computing bound for A
    if (_0.d1 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing bound for B
    int64_t _458 = 778;
    if (_458 > 0) 
    goto _jump684;
    fail_assertion("non-positive loop bound");
    _jump684:;
    // Computing bound for C
    int64_t _459 = 862;
    if (_459 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    _457 = 0;
    int64_t _460 = 0; // C
    int64_t _461 = 0; // B
    int64_t _462 = 0; // A
    _jump686:; // Begin body of loop
    double _463 = 4.0;
    _457 += _463;
    _460++;
    if (_460 < _459)
    goto _jump686;
    _460 = 0;
    _461++;
    if (_461 < _458)
    goto _jump686;
    _461 = 0;
    _462++;
    if (_462 < _0.d1)
    goto _jump686;
    // End body of loop
    _453 += _457;
    _454++;
    if (_454 < _446.d0)
    goto _jump682;
    _454 = 0;
    _455++;
    if (_455 < _0.d1)
    goto _jump682;
    _455 = 0;
    _456++;
    if (_456 < _266.d0)
    goto _jump682;
    // End body of loop
    _a3_double _464;
    // Computing bound for x
    _464.d0 = _266.d0;
    if (_266.d0 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing bound for y
    _464.d1 = _446.d0;
    if (_446.d0 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for z
    int64_t _465;
    // Computing bound for x
    if (_445.d0 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing bound for y
    if (_352 > 0) 
    goto _jump690;
    fail_assertion("non-positive loop bound");
    _jump690:;
    _465 = 0;
    int64_t _466 = 0; // y
    int64_t _467 = 0; // x
    _jump691:; // Begin body of loop
    _465 += _0.d2;
    _466++;
    if (_466 < _352)
    goto _jump691;
    _466 = 0;
    _467++;
    if (_467 < _445.d0)
    goto _jump691;
    // End body of loop
    _464.d2 = _465;
    if (_465 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing total size of heap memory to allocate
    int64_t _468 = 1;
    _468 *= _266.d0;
    _468 *= _446.d0;
    _468 *= _465;
    _468 *= sizeof(double);
    _464.data = jpl_alloc(_468);
    int64_t _469 = 0; // z
    int64_t _470 = 0; // y
    int64_t _471 = 0; // x
    _jump693:; // Begin body of loop
    double _472;
    // Computing bound for A
    if (_352 > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    _472 = 0;
    int64_t _473 = 0; // A
    _jump695:; // Begin body of loop
    double _474 = 95.0;
    _472 += _474;
    _473++;
    if (_473 < _352)
    goto _jump695;
    // End body of loop
    int64_t _475 = 0;
    _475 *= _464.d0;
    _475 += _471;
    _475 *= _464.d1;
    _475 += _470;
    _475 *= _464.d2;
    _475 += _469;
    _464.data[_475] = _472;
    _469++;
    if (_469 < _465)
    goto _jump693;
    _469 = 0;
    _470++;
    if (_470 < _446.d0)
    goto _jump693;
    _470 = 0;
    _471++;
    if (_471 < _266.d0)
    goto _jump693;
    // End body of loop
    int64_t _476;
    // Computing bound for x
    if (_266.d0 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing bound for y
    int64_t _477;
    // Computing bound for x
    if (_352 > 0) 
    goto _jump697;
    fail_assertion("non-positive loop bound");
    _jump697:;
    _477 = 0;
    int64_t _478 = 0; // x
    _jump698:; // Begin body of loop
    _477 += _0.d0;
    _478++;
    if (_478 < _352)
    goto _jump698;
    // End body of loop
    if (_477 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    _476 = 0;
    int64_t _479 = 0; // y
    int64_t _480 = 0; // x
    _jump700:; // Begin body of loop
    _476 += _446.d1;
    _479++;
    if (_479 < _477)
    goto _jump700;
    _479 = 0;
    _480++;
    if (_480 < _266.d0)
    goto _jump700;
    // End body of loop
    if (_446.d1 >= 0)
    goto _jump701;
    fail_assertion("negative array index");
    _jump701:;
    if (_446.d1 < _464.d0)
    goto _jump702;
    fail_assertion("index too large");
    _jump702:;
    if (_476 >= 0)
    goto _jump703;
    fail_assertion("negative array index");
    _jump703:;
    if (_476 < _464.d1)
    goto _jump704;
    fail_assertion("index too large");
    _jump704:;
    if (_0.d0 >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (_0.d0 < _464.d2)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    int64_t _481 = 0;
    _481 *= _464.d0;
    _481 += _446.d1;
    _481 *= _464.d1;
    _481 += _476;
    _481 *= _464.d2;
    _481 += _0.d0;
    double _482 = _464.data[_481];
    _a1_double _483;
    // Computing bound for x
    _483.d0 = _446.d1;
    if (_446.d1 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    // Computing total size of heap memory to allocate
    int64_t _484 = 1;
    _484 *= _446.d1;
    _484 *= sizeof(double);
    _483.data = jpl_alloc(_484);
    int64_t _485 = 0; // x
    _jump708:; // Begin body of loop
    double _486 = 16.0;
    double _487 = -_486;
    int64_t _488 = 0;
    _488 *= _483.d0;
    _488 += _485;
    _483.data[_488] = _487;
    _485++;
    if (_485 < _446.d1)
    goto _jump708;
    // End body of loop
    if (_0.d2 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (_0.d2 < _483.d0)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    int64_t _489 = 0;
    _489 *= _483.d0;
    _489 += _0.d2;
    double _490 = _483.data[_489];
    _a3_double _491;
    // Computing bound for x
    _491.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    // Computing bound for y
    _491.d1 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump712;
    fail_assertion("non-positive loop bound");
    _jump712:;
    // Computing bound for z
    int64_t _492 = _266.d0 - _445.d0;
    _491.d2 = _492;
    if (_492 > 0) 
    goto _jump713;
    fail_assertion("non-positive loop bound");
    _jump713:;
    // Computing total size of heap memory to allocate
    int64_t _493 = 1;
    _493 *= _0.d0;
    _493 *= _0.d2;
    _493 *= _492;
    _493 *= sizeof(double);
    _491.data = jpl_alloc(_493);
    int64_t _494 = 0; // z
    int64_t _495 = 0; // y
    int64_t _496 = 0; // x
    _jump714:; // Begin body of loop
    double _497 = 18.0;
    double _498 = -_497;
    int64_t _499 = 0;
    _499 *= _491.d0;
    _499 += _496;
    _499 *= _491.d1;
    _499 += _495;
    _499 *= _491.d2;
    _499 += _494;
    _491.data[_499] = _498;
    _494++;
    if (_494 < _492)
    goto _jump714;
    _494 = 0;
    _495++;
    if (_495 < _0.d2)
    goto _jump714;
    _495 = 0;
    _496++;
    if (_496 < _0.d0)
    goto _jump714;
    // End body of loop
    int64_t _500 = -_0.d1;
    if (_500 >= 0)
    goto _jump715;
    fail_assertion("negative array index");
    _jump715:;
    if (_500 < _491.d0)
    goto _jump716;
    fail_assertion("index too large");
    _jump716:;
    if (_352 >= 0)
    goto _jump717;
    fail_assertion("negative array index");
    _jump717:;
    if (_352 < _491.d1)
    goto _jump718;
    fail_assertion("index too large");
    _jump718:;
    if (_0.d2 >= 0)
    goto _jump719;
    fail_assertion("negative array index");
    _jump719:;
    if (_0.d2 < _491.d2)
    goto _jump720;
    fail_assertion("index too large");
    _jump720:;
    int64_t _501 = 0;
    _501 *= _491.d0;
    _501 += _500;
    _501 *= _491.d1;
    _501 += _352;
    _501 *= _491.d2;
    _501 += _0.d2;
    double _502 = _491.data[_501];
    rgba _503 = { _453, _482, _490, _502 };
    double _504 = _503.b;
    double _505 = 95.0;
    double _506;
    // Computing bound for x
    int64_t _507 = -_0.d0;
    if (_507 > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for y
    if (_446.d0 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing bound for z
    if (_0.d1 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    _506 = 0;
    int64_t _508 = 0; // z
    int64_t _509 = 0; // y
    int64_t _510 = 0; // x
    _jump724:; // Begin body of loop
    double _511 = 56.0;
    _506 += _511;
    _508++;
    if (_508 < _0.d1)
    goto _jump724;
    _508 = 0;
    _509++;
    if (_509 < _446.d0)
    goto _jump724;
    _509 = 0;
    _510++;
    if (_510 < _507)
    goto _jump724;
    // End body of loop
    double _512 = 41.0;
    double _513 = _506 * _512;
    double _514 = 77.0;
    double _515 = 83.0;
    double _516 = _514 / _515;
    _a1_double _517;
    _517.d0 = 1;
    _517.data = jpl_alloc(sizeof(double) * 1);
    _517.data[0] = _516;
    if (_445.d0 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_445.d0 < _517.d0)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    int64_t _518 = 0;
    _518 *= _517.d0;
    _518 += _445.d0;
    double _519 = _517.data[_518];
    double _520 = 55.0;
    rgba _521 = { _505, _513, _519, _520 };
    double _522 = _521.b;
    double _523 = 71.0;
    double _524 = -_523;
    double _525 = -_524;
    double _526 = -_525;
    double _527 = -_526;
    double _528 = -_527;
    _a3__a3_double _529;
    // Computing bound for x
    _529.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump727;
    fail_assertion("non-positive loop bound");
    _jump727:;
    // Computing bound for y
    _529.d1 = _352;
    if (_352 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for z
    _529.d2 = _446.d0;
    if (_446.d0 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing total size of heap memory to allocate
    int64_t _530 = 1;
    _530 *= _0.d2;
    _530 *= _352;
    _530 *= _446.d0;
    _530 *= sizeof(_a3_double);
    _529.data = jpl_alloc(_530);
    int64_t _531 = 0; // z
    int64_t _532 = 0; // y
    int64_t _533 = 0; // x
    _jump730:; // Begin body of loop
    _a3_double _534;
    // Computing bound for A
    _534.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing bound for B
    _534.d1 = _446.d1;
    if (_446.d1 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    // Computing bound for C
    _534.d2 = _531;
    if (_531 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    // Computing total size of heap memory to allocate
    int64_t _535 = 1;
    _535 *= _0.d2;
    _535 *= _446.d1;
    _535 *= _531;
    _535 *= sizeof(double);
    _534.data = jpl_alloc(_535);
    int64_t _536 = 0; // C
    int64_t _537 = 0; // B
    int64_t _538 = 0; // A
    _jump734:; // Begin body of loop
    double _539 = 69.0;
    int64_t _540 = 0;
    _540 *= _534.d0;
    _540 += _538;
    _540 *= _534.d1;
    _540 += _537;
    _540 *= _534.d2;
    _540 += _536;
    _534.data[_540] = _539;
    _536++;
    if (_536 < _531)
    goto _jump734;
    _536 = 0;
    _537++;
    if (_537 < _446.d1)
    goto _jump734;
    _537 = 0;
    _538++;
    if (_538 < _0.d2)
    goto _jump734;
    // End body of loop
    int64_t _541 = 0;
    _541 *= _529.d0;
    _541 += _533;
    _541 *= _529.d1;
    _541 += _532;
    _541 *= _529.d2;
    _541 += _531;
    _529.data[_541] = _534;
    _531++;
    if (_531 < _446.d0)
    goto _jump730;
    _531 = 0;
    _532++;
    if (_532 < _352)
    goto _jump730;
    _532 = 0;
    _533++;
    if (_533 < _0.d2)
    goto _jump730;
    // End body of loop
    if (_352 >= 0)
    goto _jump735;
    fail_assertion("negative array index");
    _jump735:;
    if (_352 < _529.d0)
    goto _jump736;
    fail_assertion("index too large");
    _jump736:;
    if (_199.d0 >= 0)
    goto _jump737;
    fail_assertion("negative array index");
    _jump737:;
    if (_199.d0 < _529.d1)
    goto _jump738;
    fail_assertion("index too large");
    _jump738:;
    if (_199.d0 >= 0)
    goto _jump739;
    fail_assertion("negative array index");
    _jump739:;
    if (_199.d0 < _529.d2)
    goto _jump740;
    fail_assertion("index too large");
    _jump740:;
    int64_t _542 = 0;
    _542 *= _529.d0;
    _542 += _352;
    _542 *= _529.d1;
    _542 += _199.d0;
    _542 *= _529.d2;
    _542 += _199.d0;
    _a3_double _543 = _529.data[_542];
    int64_t _544;
    // Computing bound for x
    int64_t _545 = -_352;
    if (_545 > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing bound for y
    if (_445.d0 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    _544 = 0;
    int64_t _546 = 0; // y
    int64_t _547 = 0; // x
    _jump743:; // Begin body of loop
    bool _548 = l();
    int64_t _549;
    if (!_548)
    goto _jump744;
    int64_t _550 = -_0.d1;
    _549 = _550;
    goto _jump745;
    _jump744:;
    _549 = _0.d1;
    _jump745:;
    _544 += _549;
    _546++;
    if (_546 < _445.d0)
    goto _jump743;
    _546 = 0;
    _547++;
    if (_547 < _545)
    goto _jump743;
    // End body of loop
    if (_445.d0 >= 0)
    goto _jump746;
    fail_assertion("negative array index");
    _jump746:;
    if (_445.d0 < _543.d0)
    goto _jump747;
    fail_assertion("index too large");
    _jump747:;
    if (_199.d0 >= 0)
    goto _jump748;
    fail_assertion("negative array index");
    _jump748:;
    if (_199.d0 < _543.d1)
    goto _jump749;
    fail_assertion("index too large");
    _jump749:;
    if (_544 >= 0)
    goto _jump750;
    fail_assertion("negative array index");
    _jump750:;
    if (_544 < _543.d2)
    goto _jump751;
    fail_assertion("index too large");
    _jump751:;
    int64_t _551 = 0;
    _551 *= _543.d0;
    _551 += _445.d0;
    _551 *= _543.d1;
    _551 += _199.d0;
    _551 *= _543.d2;
    _551 += _544;
    double _552 = _543.data[_551];
    double _553 = 60.0;
    double _554 = 3.0;
    double _555;
    // Computing bound for x
    if (_0.d0 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for y
    if (_0.d0 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    _555 = 0;
    int64_t _556 = 0; // y
    int64_t _557 = 0; // x
    _jump754:; // Begin body of loop
    double _558 = 51.0;
    _555 += _558;
    _556++;
    if (_556 < _0.d0)
    goto _jump754;
    _556 = 0;
    _557++;
    if (_557 < _0.d0)
    goto _jump754;
    // End body of loop
    double _559;
    // Computing bound for x
    int64_t _560 = _445.d0 + _0.d1;
    if (_560 > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    _559 = 0;
    int64_t _561 = 0; // x
    _jump756:; // Begin body of loop
    double _562 = 27.0;
    double _563 = -_562;
    _559 += _563;
    _561++;
    if (_561 < _560)
    goto _jump756;
    // End body of loop
    rgba _564 = { _553, _554, _555, _559 };
    double _565 = _564.g;
    double _566 = _552 / _565;
    rgba _567 = { _504, _522, _528, _566 };
    double _568 = get_time();
    print_time(_568 - _452);
    double _569;
    // Computing bound for y
    if (_0.d2 > 0) 
    goto _jump757;
    fail_assertion("non-positive loop bound");
    _jump757:;
    _569 = 0;
    int64_t _570 = 0; // y
    _jump758:; // Begin body of loop
    double _571;
    // Computing bound for z
    if (_0.d0 > 0) 
    goto _jump759;
    fail_assertion("non-positive loop bound");
    _jump759:;
    // Computing bound for A
    if (_0.d1 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    // Computing bound for B
    int64_t _572 = -_0.d1;
    if (_572 > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    _571 = 0;
    int64_t _573 = 0; // B
    int64_t _574 = 0; // A
    int64_t _575 = 0; // z
    _jump762:; // Begin body of loop
    double _576 = 60.0;
    _571 += _576;
    _573++;
    if (_573 < _572)
    goto _jump762;
    _573 = 0;
    _574++;
    if (_574 < _0.d1)
    goto _jump762;
    _574 = 0;
    _575++;
    if (_575 < _0.d0)
    goto _jump762;
    // End body of loop
    _569 += _571;
    _570++;
    if (_570 < _0.d2)
    goto _jump758;
    // End body of loop
    bool _578 = l();
    bool _579 = !_578;
    bool _577 = _579;
    if (0 == _579)
    goto _jump763;
    bool _580 = true;
    _577 = _580;
    _jump763:;
    double _581;
    if (!_577)
    goto _jump764;
    double _582;
    // Computing bound for y
    if (_0.d1 > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    // Computing bound for z
    if (_266.d0 > 0) 
    goto _jump766;
    fail_assertion("non-positive loop bound");
    _jump766:;
    // Computing bound for A
    int64_t _583;
    // Computing bound for y
    if (_446.d1 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for z
    if (_0.d2 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    _583 = 0;
    int64_t _584 = 0; // z
    int64_t _585 = 0; // y
    _jump769:; // Begin body of loop
    _583 += _584;
    _584++;
    if (_584 < _0.d2)
    goto _jump769;
    _584 = 0;
    _585++;
    if (_585 < _446.d1)
    goto _jump769;
    // End body of loop
    if (_583 > 0) 
    goto _jump770;
    fail_assertion("non-positive loop bound");
    _jump770:;
    _582 = 0;
    int64_t _586 = 0; // A
    int64_t _587 = 0; // z
    int64_t _588 = 0; // y
    _jump771:; // Begin body of loop
    double _589 = 47.0;
    _582 += _589;
    _586++;
    if (_586 < _583)
    goto _jump771;
    _586 = 0;
    _587++;
    if (_587 < _266.d0)
    goto _jump771;
    _587 = 0;
    _588++;
    if (_588 < _0.d1)
    goto _jump771;
    // End body of loop
    _581 = _582;
    goto _jump772;
    _jump764:;
    double _590 = 17.0;
    _581 = _590;
    _jump772:;
    bool _591 = l();
    _a3_rgba _592;
    if (!_591)
    goto _jump773;
    _a3_rgba _593;
    // Computing bound for y
    _593.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    // Computing bound for z
    _593.d1 = _266.d0;
    if (_266.d0 > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    // Computing bound for A
    _593.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    // Computing total size of heap memory to allocate
    int64_t _594 = 1;
    _594 *= _0.d2;
    _594 *= _266.d0;
    _594 *= _0.d0;
    _594 *= sizeof(rgba);
    _593.data = jpl_alloc(_594);
    int64_t _595 = 0; // A
    int64_t _596 = 0; // z
    int64_t _597 = 0; // y
    _jump777:; // Begin body of loop
    int64_t _598 = 0;
    _598 *= _593.d0;
    _598 += _597;
    _598 *= _593.d1;
    _598 += _596;
    _598 *= _593.d2;
    _598 += _595;
    _593.data[_598] = _567;
    _595++;
    if (_595 < _0.d0)
    goto _jump777;
    _595 = 0;
    _596++;
    if (_596 < _266.d0)
    goto _jump777;
    _596 = 0;
    _597++;
    if (_597 < _0.d2)
    goto _jump777;
    // End body of loop
    _592 = _593;
    goto _jump778;
    _jump773:;
    _a3_rgba _599;
    // Computing bound for y
    _599.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing bound for z
    _599.d1 = _199.d0;
    if (_199.d0 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing bound for A
    int64_t _600 = 617;
    _599.d2 = _600;
    if (_600 > 0) 
    goto _jump781;
    fail_assertion("non-positive loop bound");
    _jump781:;
    // Computing total size of heap memory to allocate
    int64_t _601 = 1;
    _601 *= _0.d0;
    _601 *= _199.d0;
    _601 *= _600;
    _601 *= sizeof(rgba);
    _599.data = jpl_alloc(_601);
    int64_t _602 = 0; // A
    int64_t _603 = 0; // z
    int64_t _604 = 0; // y
    _jump782:; // Begin body of loop
    int64_t _605 = 0;
    _605 *= _599.d0;
    _605 += _604;
    _605 *= _599.d1;
    _605 += _603;
    _605 *= _599.d2;
    _605 += _602;
    _599.data[_605] = _567;
    _602++;
    if (_602 < _600)
    goto _jump782;
    _602 = 0;
    _603++;
    if (_603 < _199.d0)
    goto _jump782;
    _603 = 0;
    _604++;
    if (_604 < _0.d0)
    goto _jump782;
    // End body of loop
    _592 = _599;
    _jump778:;
    int64_t _606 = -_446.d1;
    bool _607 = l();
    int64_t _608;
    if (!_607)
    goto _jump783;
    int64_t _609 = -_199.d0;
    _608 = _609;
    goto _jump784;
    _jump783:;
    _608 = _199.d0;
    _jump784:;
    if (_606 >= 0)
    goto _jump785;
    fail_assertion("negative array index");
    _jump785:;
    if (_606 < _592.d0)
    goto _jump786;
    fail_assertion("index too large");
    _jump786:;
    if (_608 >= 0)
    goto _jump787;
    fail_assertion("negative array index");
    _jump787:;
    if (_608 < _592.d1)
    goto _jump788;
    fail_assertion("index too large");
    _jump788:;
    if (_0.d2 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_0.d2 < _592.d2)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    int64_t _610 = 0;
    _610 *= _592.d0;
    _610 += _606;
    _610 *= _592.d1;
    _610 += _608;
    _610 *= _592.d2;
    _610 += _0.d2;
    rgba _611 = _592.data[_610];
    double _612 = _611.r;
    _a1_double _613;
    // Computing bound for y
    _613.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing total size of heap memory to allocate
    int64_t _614 = 1;
    _614 *= _0.d2;
    _614 *= sizeof(double);
    _613.data = jpl_alloc(_614);
    int64_t _615 = 0; // y
    _jump792:; // Begin body of loop
    bool _616 = false;
    double _617;
    if (!_616)
    goto _jump793;
    double _618 = 26.0;
    _617 = _618;
    goto _jump794;
    _jump793:;
    double _619 = 49.0;
    _617 = _619;
    _jump794:;
    double _620 = -_617;
    int64_t _621 = 0;
    _621 *= _613.d0;
    _621 += _615;
    _613.data[_621] = _620;
    _615++;
    if (_615 < _0.d2)
    goto _jump792;
    // End body of loop
    if (_0.d0 >= 0)
    goto _jump795;
    fail_assertion("negative array index");
    _jump795:;
    if (_0.d0 < _613.d0)
    goto _jump796;
    fail_assertion("index too large");
    _jump796:;
    int64_t _622 = 0;
    _622 *= _613.d0;
    _622 += _0.d0;
    double _623 = _613.data[_622];
    _a2_double _624;
    // Computing bound for y
    int64_t _625;
    // Computing bound for y
    bool _626 = false;
    int64_t _627;
    if (!_626)
    goto _jump797;
    _627 = _0.d1;
    goto _jump798;
    _jump797:;
    _627 = _445.d0;
    _jump798:;
    if (_627 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    _625 = 0;
    int64_t _628 = 0; // y
    _jump800:; // Begin body of loop
    _625 += _446.d1;
    _628++;
    if (_628 < _627)
    goto _jump800;
    // End body of loop
    _624.d0 = _625;
    if (_625 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    // Computing bound for z
    int64_t _629;
    // Computing bound for y
    int64_t _630 = 908;
    if (_630 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing bound for z
    if (_352 > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    _629 = 0;
    int64_t _631 = 0; // z
    int64_t _632 = 0; // y
    _jump804:; // Begin body of loop
    _629 += _0.d1;
    _631++;
    if (_631 < _352)
    goto _jump804;
    _631 = 0;
    _632++;
    if (_632 < _630)
    goto _jump804;
    // End body of loop
    _624.d1 = _629;
    if (_629 > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing total size of heap memory to allocate
    int64_t _633 = 1;
    _633 *= _625;
    _633 *= _629;
    _633 *= sizeof(double);
    _624.data = jpl_alloc(_633);
    int64_t _634 = 0; // z
    int64_t _635 = 0; // y
    _jump806:; // Begin body of loop
    double _636;
    // Computing bound for A
    if (_0.d0 > 0) 
    goto _jump807;
    fail_assertion("non-positive loop bound");
    _jump807:;
    // Computing bound for B
    if (_446.d1 > 0) 
    goto _jump808;
    fail_assertion("non-positive loop bound");
    _jump808:;
    _636 = 0;
    int64_t _637 = 0; // B
    int64_t _638 = 0; // A
    _jump809:; // Begin body of loop
    double _639;
    // Computing bound for C
    if (_0.d1 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    _639 = 0;
    int64_t _640 = 0; // C
    _jump811:; // Begin body of loop
    double _641 = 41.0;
    _639 += _641;
    _640++;
    if (_640 < _0.d1)
    goto _jump811;
    // End body of loop
    _636 += _639;
    _637++;
    if (_637 < _446.d1)
    goto _jump809;
    _637 = 0;
    _638++;
    if (_638 < _0.d0)
    goto _jump809;
    // End body of loop
    int64_t _642 = 0;
    _642 *= _624.d0;
    _642 += _635;
    _642 *= _624.d1;
    _642 += _634;
    _624.data[_642] = _636;
    _634++;
    if (_634 < _629)
    goto _jump806;
    _634 = 0;
    _635++;
    if (_635 < _625)
    goto _jump806;
    // End body of loop
    if (_446.d0 >= 0)
    goto _jump812;
    fail_assertion("negative array index");
    _jump812:;
    if (_446.d0 < _624.d0)
    goto _jump813;
    fail_assertion("index too large");
    _jump813:;
    if (_0.d2 >= 0)
    goto _jump814;
    fail_assertion("negative array index");
    _jump814:;
    if (_0.d2 < _624.d1)
    goto _jump815;
    fail_assertion("index too large");
    _jump815:;
    int64_t _643 = 0;
    _643 *= _624.d0;
    _643 += _446.d0;
    _643 *= _624.d1;
    _643 += _0.d2;
    double _644 = _624.data[_643];
    rgba _645 = { _581, _612, _623, _644 };
    double _646 = _645.g;
    bool _647 = _569 > _646;
    show("(BoolType)", &_647);
    show("(IntType)", &_446.d1);
    if (_0.d1 >= 0)
    goto _jump1380;
    fail_assertion("negative array index");
    _jump1380:;
    if (_0.d1 < _188.d0)
    goto _jump1381;
    fail_assertion("index too large");
    _jump1381:;
    if (_445.d0 >= 0)
    goto _jump1382;
    fail_assertion("negative array index");
    _jump1382:;
    if (_445.d0 < _188.d1)
    goto _jump1383;
    fail_assertion("index too large");
    _jump1383:;
    int64_t _649 = 0;
    _649 *= _188.d0;
    _649 += _0.d1;
    _649 *= _188.d1;
    _649 += _445.d0;
    bool _650 = _188.data[_649];
    bool _651 = !_650;
    bool _652;
    if (!_651)
    goto _jump1384;
    bool _653 = B();
    _652 = _653;
    goto _jump1385;
    _jump1384:;
    _a1_double _654;
    // Computing bound for D
    _654.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing total size of heap memory to allocate
    int64_t _655 = 1;
    _655 *= _0.d0;
    _655 *= sizeof(double);
    _654.data = jpl_alloc(_655);
    int64_t _656 = 0; // D
    _jump1387:; // Begin body of loop
    double _657 = 55.0;
    int64_t _658 = 0;
    _658 *= _654.d0;
    _658 += _656;
    _654.data[_658] = _657;
    _656++;
    if (_656 < _0.d0)
    goto _jump1387;
    // End body of loop
    bool _659 = l();
    bool _660 = !_659;
    bool _661 = !_660;
    _a2_int64_t _662;
    if (!_661)
    goto _jump1388;
    _a2_int64_t _663;
    // Computing bound for D
    int64_t _664 = -_199.d0;
    _663.d0 = _664;
    if (_664 > 0) 
    goto _jump1389;
    fail_assertion("non-positive loop bound");
    _jump1389:;
    // Computing bound for E
    bool _665 = B();
    int64_t _666;
    if (!_665)
    goto _jump1390;
    int64_t _667 = y();
    _666 = _667;
    goto _jump1391;
    _jump1390:;
    int64_t _668 = 72;
    _666 = _668;
    _jump1391:;
    _663.d1 = _666;
    if (_666 > 0) 
    goto _jump1392;
    fail_assertion("non-positive loop bound");
    _jump1392:;
    // Computing total size of heap memory to allocate
    int64_t _669 = 1;
    _669 *= _664;
    _669 *= _666;
    _669 *= sizeof(int64_t);
    _663.data = jpl_alloc(_669);
    int64_t _670 = 0; // E
    int64_t _671 = 0; // D
    _jump1393:; // Begin body of loop
    int64_t _672 = 0;
    _672 *= _663.d0;
    _672 += _671;
    _672 *= _663.d1;
    _672 += _670;
    _663.data[_672] = _0.d0;
    _670++;
    if (_670 < _666)
    goto _jump1393;
    _670 = 0;
    _671++;
    if (_671 < _664)
    goto _jump1393;
    // End body of loop
    _662 = _663;
    goto _jump1394;
    _jump1388:;
    _a2_int64_t _673;
    // Computing bound for D
    _673.d0 = _446.d0;
    if (_446.d0 > 0) 
    goto _jump1395;
    fail_assertion("non-positive loop bound");
    _jump1395:;
    // Computing bound for E
    _673.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1396;
    fail_assertion("non-positive loop bound");
    _jump1396:;
    // Computing total size of heap memory to allocate
    int64_t _674 = 1;
    _674 *= _446.d0;
    _674 *= _0.d1;
    _674 *= sizeof(int64_t);
    _673.data = jpl_alloc(_674);
    int64_t _675 = 0; // E
    int64_t _676 = 0; // D
    _jump1397:; // Begin body of loop
    int64_t _677 = _266.d0 % _0.d0;
    int64_t _678 = 0;
    _678 *= _673.d0;
    _678 += _676;
    _678 *= _673.d1;
    _678 += _675;
    _673.data[_678] = _677;
    _675++;
    if (_675 < _0.d1)
    goto _jump1397;
    _675 = 0;
    _676++;
    if (_676 < _446.d0)
    goto _jump1397;
    // End body of loop
    _662 = _673;
    _jump1394:;
    bool _679 = m(_654, _662);
    _652 = _679;
    _jump1385:;
    bool _648 = _652;
    if (0 != _652)
    goto _jump1398;
    bool _680 = false;
    bool _681;
    if (!_680)
    goto _jump1399;
    bool _682 = l();
    bool _683 = !_682;
    _681 = _683;
    goto _jump1400;
    _jump1399:;
    bool _684 = l();
    _681 = _684;
    _jump1400:;
    _648 = _681;
    _jump1398:;
    _a1_bool _685;
    if (!_648)
    goto _jump1401;
    _685 = _266;
    goto _jump1402;
    _jump1401:;
    _a1_bool _686;
    // Computing bound for D
    int64_t _687 = y();
    int64_t _688 = -_687;
    _686.d0 = _688;
    if (_688 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    // Computing total size of heap memory to allocate
    int64_t _689 = 1;
    _689 *= _688;
    _689 *= sizeof(bool);
    _686.data = jpl_alloc(_689);
    int64_t _690 = 0; // D
    _jump1404:; // Begin body of loop
    bool _691 = B();
    int64_t _692 = 0;
    _692 *= _686.d0;
    _692 += _690;
    _686.data[_692] = _691;
    _690++;
    if (_690 < _688)
    goto _jump1404;
    // End body of loop
    _685 = _686;
    _jump1402:;
    print("F");
}

