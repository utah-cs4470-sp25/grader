
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_rgba *data;
} _a2__a2_rgba;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_int64_t *data;
} _a2__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  _a2__a1_int64_t *data;
} _a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_double *data;
} _a3__a1_double;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  _a2__a3_bool *data;
} _a1__a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  _a2__a1_bool *data;
} _a1__a2__a1_bool;

typedef struct {
  int64_t d0;
  _a2_rgba *data;
} _a1__a2_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_void_t *data;
} _a3__a3_void_t;

typedef struct {
  int64_t d0;
  _a3__a3_void_t *data;
} _a1__a3__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_void_t *data;
} _a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_void_t *data;
} _a3__a2__a3_void_t;

typedef struct {
  int64_t d0;
  _a3__a2__a3_void_t *data;
} _a1__a3__a2__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3__a2__a3_void_t *data;
} _a2__a3__a2__a3_void_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_void_t *data;
} _a2__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_void_t *data;
} _a2__a2__a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2__a1_void_t *data;
} _a3__a2__a2__a1_void_t;

double a(rgba b) {
    _a3_int64_t _0;
    // Computing bound for c
    _a3_bool _1;
    // Computing bound for c
    int64_t _2 = 187;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    // Computing bound for d
    int64_t _3 = 522;
    int64_t _4 = -_3;
    int64_t _5 = -_4;
    _1.d1 = _5;
    if (_5 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for e
    int64_t _6 = 833;
    bool _7 = true;
    int64_t _8;
    if (!_7)
    goto _jump3;
    int64_t _9 = 123;
    _8 = _9;
    goto _jump4;
    _jump3:;
    int64_t _10 = 183;
    _8 = _10;
    _jump4:;
    int64_t _11 = _6 * _8;
    _1.d2 = _11;
    if (_11 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _2;
    _12 *= _5;
    _12 *= _11;
    _12 *= sizeof(bool);
    _1.data = jpl_alloc(_12);
    int64_t _13 = 0; // e
    int64_t _14 = 0; // d
    int64_t _15 = 0; // c
    _jump6:; // Begin body of loop
    bool _16 = true;
    bool _17 = !_16;
    int64_t _18 = 0;
    _18 *= _1.d0;
    _18 += _15;
    _18 *= _1.d1;
    _18 += _14;
    _18 *= _1.d2;
    _18 += _13;
    _1.data[_18] = _17;
    _13++;
    if (_13 < _11)
    goto _jump6;
    _13 = 0;
    _14++;
    if (_14 < _5)
    goto _jump6;
    _14 = 0;
    _15++;
    if (_15 < _2)
    goto _jump6;
    // End body of loop
    int64_t _19;
    // Computing bound for c
    int64_t _20;
    // Computing bound for c
    int64_t _21 = 304;
    if (_21 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing bound for d
    bool _22 = false;
    int64_t _23;
    if (!_22)
    goto _jump8;
    int64_t _24 = 24;
    _23 = _24;
    goto _jump9;
    _jump8:;
    int64_t _25 = 267;
    _23 = _25;
    _jump9:;
    if (_23 > 0) 
    goto _jump10;
    fail_assertion("non-positive loop bound");
    _jump10:;
    // Computing bound for e
    int64_t _26 = 553;
    if (_26 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    _20 = 0;
    int64_t _27 = 0; // e
    int64_t _28 = 0; // d
    int64_t _29 = 0; // c
    _jump12:; // Begin body of loop
    int64_t _30 = 518;
    int64_t _31 = _30 - _29;
    _20 += _31;
    _27++;
    if (_27 < _26)
    goto _jump12;
    _27 = 0;
    _28++;
    if (_28 < _23)
    goto _jump12;
    _28 = 0;
    _29++;
    if (_29 < _21)
    goto _jump12;
    // End body of loop
    if (_20 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    // Computing bound for d
    int64_t _32 = 787;
    int64_t _33 = 936;
    int64_t _34 = _32 % _33;
    if (_34 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    _19 = 0;
    int64_t _35 = 0; // d
    int64_t _36 = 0; // c
    _jump15:; // Begin body of loop
    bool _37 = true;
    int64_t _38;
    if (!_37)
    goto _jump16;
    int64_t _39 = 971;
    _38 = _39;
    goto _jump17;
    _jump16:;
    int64_t _40 = 398;
    _38 = _40;
    _jump17:;
    int64_t _41 = _36 * _38;
    _19 += _41;
    _35++;
    if (_35 < _34)
    goto _jump15;
    _35 = 0;
    _36++;
    if (_36 < _20)
    goto _jump15;
    // End body of loop
    int64_t _42 = 451;
    int64_t _43 = 105;
    int64_t _44 = -_43;
    int64_t _45 = -_44;
    if (_19 >= 0)
    goto _jump18;
    fail_assertion("negative array index");
    _jump18:;
    if (_19 < _1.d0)
    goto _jump19;
    fail_assertion("index too large");
    _jump19:;
    if (_42 >= 0)
    goto _jump20;
    fail_assertion("negative array index");
    _jump20:;
    if (_42 < _1.d1)
    goto _jump21;
    fail_assertion("index too large");
    _jump21:;
    if (_45 >= 0)
    goto _jump22;
    fail_assertion("negative array index");
    _jump22:;
    if (_45 < _1.d2)
    goto _jump23;
    fail_assertion("index too large");
    _jump23:;
    int64_t _46 = 0;
    _46 *= _1.d0;
    _46 += _19;
    _46 *= _1.d1;
    _46 += _42;
    _46 *= _1.d2;
    _46 += _45;
    bool _47 = _1.data[_46];
    _a3_int64_t _48;
    if (!_47)
    goto _jump24;
    _a3_int64_t _49;
    // Computing bound for c
    int64_t _50 = 137;
    _49.d0 = _50;
    if (_50 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for d
    int64_t _51 = 639;
    _49.d1 = _51;
    if (_51 > 0) 
    goto _jump26;
    fail_assertion("non-positive loop bound");
    _jump26:;
    // Computing bound for e
    int64_t _52 = 676;
    int64_t _53 = -_52;
    _49.d2 = _53;
    if (_53 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= _50;
    _54 *= _51;
    _54 *= _53;
    _54 *= sizeof(int64_t);
    _49.data = jpl_alloc(_54);
    int64_t _55 = 0; // e
    int64_t _56 = 0; // d
    int64_t _57 = 0; // c
    _jump28:; // Begin body of loop
    int64_t _58 = -_55;
    int64_t _59 = 0;
    _59 *= _49.d0;
    _59 += _57;
    _59 *= _49.d1;
    _59 += _56;
    _59 *= _49.d2;
    _59 += _55;
    _49.data[_59] = _58;
    _55++;
    if (_55 < _53)
    goto _jump28;
    _55 = 0;
    _56++;
    if (_56 < _51)
    goto _jump28;
    _56 = 0;
    _57++;
    if (_57 < _50)
    goto _jump28;
    // End body of loop
    _48 = _49;
    goto _jump29;
    _jump24:;
    _a3_int64_t _60;
    // Computing bound for c
    int64_t _61 = 837;
    int64_t _62 = -_61;
    int64_t _63 = -_62;
    _60.d0 = _63;
    if (_63 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    // Computing bound for d
    double _64 = 32.0;
    double _65 = 0.0;
    bool _66 = _64 == _65;
    int64_t _67;
    if (!_66)
    goto _jump31;
    int64_t _68 = 448;
    int64_t _69 = 98;
    int64_t _70 = _68 * _69;
    int64_t _71 = 659;
    int64_t _72 = _70 / _71;
    _67 = _72;
    goto _jump32;
    _jump31:;
    int64_t _73 = 123;
    int64_t _74 = -_73;
    int64_t _75 = 395;
    int64_t _76 = _74 % _75;
    _67 = _76;
    _jump32:;
    _60.d1 = _67;
    if (_67 > 0) 
    goto _jump33;
    fail_assertion("non-positive loop bound");
    _jump33:;
    // Computing bound for e
    int64_t _77;
    // Computing bound for c
    int64_t _78 = 310;
    if (_78 > 0) 
    goto _jump34;
    fail_assertion("non-positive loop bound");
    _jump34:;
    // Computing bound for d
    int64_t _79 = 930;
    if (_79 > 0) 
    goto _jump35;
    fail_assertion("non-positive loop bound");
    _jump35:;
    // Computing bound for e
    int64_t _80 = 549;
    if (_80 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    _77 = 0;
    int64_t _81 = 0; // e
    int64_t _82 = 0; // d
    int64_t _83 = 0; // c
    _jump37:; // Begin body of loop
    int64_t _84 = 736;
    _77 += _84;
    _81++;
    if (_81 < _80)
    goto _jump37;
    _81 = 0;
    _82++;
    if (_82 < _79)
    goto _jump37;
    _82 = 0;
    _83++;
    if (_83 < _78)
    goto _jump37;
    // End body of loop
    int64_t _85 = -_77;
    int64_t _86 = -_85;
    _60.d2 = _86;
    if (_86 > 0) 
    goto _jump38;
    fail_assertion("non-positive loop bound");
    _jump38:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= _63;
    _87 *= _67;
    _87 *= _86;
    _87 *= sizeof(int64_t);
    _60.data = jpl_alloc(_87);
    int64_t _88 = 0; // e
    int64_t _89 = 0; // d
    int64_t _90 = 0; // c
    _jump39:; // Begin body of loop
    bool _91 = true;
    bool _92 = !_91;
    int64_t _93;
    if (!_92)
    goto _jump40;
    _93 = _88;
    goto _jump41;
    _jump40:;
    int64_t _94;
    // Computing bound for f
    int64_t _95 = -_90;
    if (_95 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    _94 = 0;
    int64_t _96 = 0; // f
    _jump43:; // Begin body of loop
    _94 += _90;
    _96++;
    if (_96 < _95)
    goto _jump43;
    // End body of loop
    _93 = _94;
    _jump41:;
    int64_t _97 = 0;
    _97 *= _60.d0;
    _97 += _90;
    _97 *= _60.d1;
    _97 += _89;
    _97 *= _60.d2;
    _97 += _88;
    _60.data[_97] = _93;
    _88++;
    if (_88 < _86)
    goto _jump39;
    _88 = 0;
    _89++;
    if (_89 < _67)
    goto _jump39;
    _89 = 0;
    _90++;
    if (_90 < _63)
    goto _jump39;
    // End body of loop
    _48 = _60;
    _jump29:;
    int64_t _98 = 37;
    int64_t _99 = 982;
    int64_t _100 = -_99;
    int64_t _101 = _98 * _100;
    int64_t _102 = 84;
    int64_t _103 = 423;
    int64_t _104 = -_103;
    int64_t _105 = _102 - _104;
    bool _106 = _101 <= _105;
    _a2_int64_t _107;
    if (!_106)
    goto _jump44;
    bool _108 = false;
    bool _109 = !_108;
    _a2_int64_t _110;
    if (!_109)
    goto _jump45;
    _a2_int64_t _111;
    // Computing bound for c
    int64_t _112 = 124;
    _111.d0 = _112;
    if (_112 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    // Computing bound for d
    int64_t _113 = 967;
    _111.d1 = _113;
    if (_113 > 0) 
    goto _jump47;
    fail_assertion("non-positive loop bound");
    _jump47:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= _112;
    _114 *= _113;
    _114 *= sizeof(int64_t);
    _111.data = jpl_alloc(_114);
    int64_t _115 = 0; // d
    int64_t _116 = 0; // c
    _jump48:; // Begin body of loop
    int64_t _117 = 0;
    _117 *= _111.d0;
    _117 += _116;
    _117 *= _111.d1;
    _117 += _115;
    _111.data[_117] = _116;
    _115++;
    if (_115 < _113)
    goto _jump48;
    _115 = 0;
    _116++;
    if (_116 < _112)
    goto _jump48;
    // End body of loop
    _110 = _111;
    goto _jump49;
    _jump45:;
    _a2_int64_t _118;
    // Computing bound for c
    int64_t _119 = 174;
    int64_t _120 = -_119;
    _118.d0 = _120;
    if (_120 > 0) 
    goto _jump50;
    fail_assertion("non-positive loop bound");
    _jump50:;
    // Computing bound for d
    int64_t _121 = 441;
    _118.d1 = _121;
    if (_121 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _120;
    _122 *= _121;
    _122 *= sizeof(int64_t);
    _118.data = jpl_alloc(_122);
    int64_t _123 = 0; // d
    int64_t _124 = 0; // c
    _jump52:; // Begin body of loop
    int64_t _125;
    // Computing bound for e
    if (_123 > 0) 
    goto _jump53;
    fail_assertion("non-positive loop bound");
    _jump53:;
    // Computing bound for f
    int64_t _126 = 257;
    if (_126 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for g
    if (_124 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    _125 = 0;
    int64_t _127 = 0; // g
    int64_t _128 = 0; // f
    int64_t _129 = 0; // e
    _jump56:; // Begin body of loop
    _125 += _124;
    _127++;
    if (_127 < _124)
    goto _jump56;
    _127 = 0;
    _128++;
    if (_128 < _126)
    goto _jump56;
    _128 = 0;
    _129++;
    if (_129 < _123)
    goto _jump56;
    // End body of loop
    int64_t _130 = 0;
    _130 *= _118.d0;
    _130 += _124;
    _130 *= _118.d1;
    _130 += _123;
    _118.data[_130] = _125;
    _123++;
    if (_123 < _121)
    goto _jump52;
    _123 = 0;
    _124++;
    if (_124 < _120)
    goto _jump52;
    // End body of loop
    _110 = _118;
    _jump49:;
    _107 = _110;
    goto _jump57;
    _jump44:;
    _a2_int64_t _131;
    // Computing bound for c
    int64_t _132;
    // Computing bound for c
    int64_t _133 = 55;
    if (_133 > 0) 
    goto _jump58;
    fail_assertion("non-positive loop bound");
    _jump58:;
    _132 = 0;
    int64_t _134 = 0; // c
    _jump59:; // Begin body of loop
    _132 += _134;
    _134++;
    if (_134 < _133)
    goto _jump59;
    // End body of loop
    _131.d0 = _132;
    if (_132 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    // Computing bound for d
    int64_t _135 = 891;
    _131.d1 = _135;
    if (_135 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _132;
    _136 *= _135;
    _136 *= sizeof(int64_t);
    _131.data = jpl_alloc(_136);
    int64_t _137 = 0; // d
    int64_t _138 = 0; // c
    _jump62:; // Begin body of loop
    int64_t _139 = 0;
    _139 *= _131.d0;
    _139 += _138;
    _139 *= _131.d1;
    _139 += _137;
    _131.data[_139] = _138;
    _137++;
    if (_137 < _135)
    goto _jump62;
    _137 = 0;
    _138++;
    if (_138 < _132)
    goto _jump62;
    // End body of loop
    _107 = _131;
    _jump57:;
    _a3_int64_t _140;
    // Computing bound for c
    int64_t _141 = 117;
    int64_t _142 = -_141;
    _140.d0 = _142;
    if (_142 > 0) 
    goto _jump63;
    fail_assertion("non-positive loop bound");
    _jump63:;
    // Computing bound for d
    int64_t _143;
    // Computing bound for c
    int64_t _144 = 948;
    if (_144 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    _143 = 0;
    int64_t _145 = 0; // c
    _jump65:; // Begin body of loop
    int64_t _146 = -_145;
    _143 += _146;
    _145++;
    if (_145 < _144)
    goto _jump65;
    // End body of loop
    _140.d1 = _143;
    if (_143 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    // Computing bound for e
    _a3_int64_t _147;
    // Computing bound for c
    int64_t _148 = 878;
    _147.d0 = _148;
    if (_148 > 0) 
    goto _jump67;
    fail_assertion("non-positive loop bound");
    _jump67:;
    // Computing bound for d
    int64_t _149 = 222;
    _147.d1 = _149;
    if (_149 > 0) 
    goto _jump68;
    fail_assertion("non-positive loop bound");
    _jump68:;
    // Computing bound for e
    int64_t _150 = 128;
    _147.d2 = _150;
    if (_150 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= _148;
    _151 *= _149;
    _151 *= _150;
    _151 *= sizeof(int64_t);
    _147.data = jpl_alloc(_151);
    int64_t _152 = 0; // e
    int64_t _153 = 0; // d
    int64_t _154 = 0; // c
    _jump70:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _147.d0;
    _155 += _154;
    _155 *= _147.d1;
    _155 += _153;
    _155 *= _147.d2;
    _155 += _152;
    _147.data[_155] = _152;
    _152++;
    if (_152 < _150)
    goto _jump70;
    _152 = 0;
    _153++;
    if (_153 < _149)
    goto _jump70;
    _153 = 0;
    _154++;
    if (_154 < _148)
    goto _jump70;
    // End body of loop
    int64_t _156 = 148;
    int64_t _157 = -_156;
    int64_t _158 = 746;
    int64_t _159 = 148;
    int64_t _160 = -_159;
    if (_157 >= 0)
    goto _jump71;
    fail_assertion("negative array index");
    _jump71:;
    if (_157 < _147.d0)
    goto _jump72;
    fail_assertion("index too large");
    _jump72:;
    if (_158 >= 0)
    goto _jump73;
    fail_assertion("negative array index");
    _jump73:;
    if (_158 < _147.d1)
    goto _jump74;
    fail_assertion("index too large");
    _jump74:;
    if (_160 >= 0)
    goto _jump75;
    fail_assertion("negative array index");
    _jump75:;
    if (_160 < _147.d2)
    goto _jump76;
    fail_assertion("index too large");
    _jump76:;
    int64_t _161 = 0;
    _161 *= _147.d0;
    _161 += _157;
    _161 *= _147.d1;
    _161 += _158;
    _161 *= _147.d2;
    _161 += _160;
    int64_t _162 = _147.data[_161];
    _140.d2 = _162;
    if (_162 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= _142;
    _163 *= _143;
    _163 *= _162;
    _163 *= sizeof(int64_t);
    _140.data = jpl_alloc(_163);
    int64_t _164 = 0; // e
    int64_t _165 = 0; // d
    int64_t _166 = 0; // c
    _jump78:; // Begin body of loop
    int64_t _167 = -_164;
    int64_t _168 = 0;
    _168 *= _140.d0;
    _168 += _166;
    _168 *= _140.d1;
    _168 += _165;
    _168 *= _140.d2;
    _168 += _164;
    _140.data[_168] = _167;
    _164++;
    if (_164 < _162)
    goto _jump78;
    _164 = 0;
    _165++;
    if (_165 < _143)
    goto _jump78;
    _165 = 0;
    _166++;
    if (_166 < _142)
    goto _jump78;
    // End body of loop
    int64_t _169 = 947;
    int64_t _170 = 399;
    int64_t _171 = 646;
    int64_t _172 = 440;
    int64_t _173 = _171 * _172;
    bool _174 = true;
    int64_t _175;
    if (!_174)
    goto _jump79;
    int64_t _176 = 197;
    _175 = _176;
    goto _jump80;
    _jump79:;
    int64_t _177 = 390;
    _175 = _177;
    _jump80:;
    bool _178 = _173 == _175;
    int64_t _179;
    if (!_178)
    goto _jump81;
    int64_t _180 = 811;
    int64_t _181 = 917;
    int64_t _182 = _180 * _181;
    int64_t _183 = 186;
    int64_t _184 = _182 % _183;
    _179 = _184;
    goto _jump82;
    _jump81:;
    int64_t _185 = 322;
    _179 = _185;
    _jump82:;
    if (_169 >= 0)
    goto _jump83;
    fail_assertion("negative array index");
    _jump83:;
    if (_169 < _140.d0)
    goto _jump84;
    fail_assertion("index too large");
    _jump84:;
    if (_170 >= 0)
    goto _jump85;
    fail_assertion("negative array index");
    _jump85:;
    if (_170 < _140.d1)
    goto _jump86;
    fail_assertion("index too large");
    _jump86:;
    if (_179 >= 0)
    goto _jump87;
    fail_assertion("negative array index");
    _jump87:;
    if (_179 < _140.d2)
    goto _jump88;
    fail_assertion("index too large");
    _jump88:;
    int64_t _186 = 0;
    _186 *= _140.d0;
    _186 += _169;
    _186 *= _140.d1;
    _186 += _170;
    _186 *= _140.d2;
    _186 += _179;
    int64_t _187 = _140.data[_186];
    int64_t _188 = 171;
    if (_187 >= 0)
    goto _jump89;
    fail_assertion("negative array index");
    _jump89:;
    if (_187 < _107.d0)
    goto _jump90;
    fail_assertion("index too large");
    _jump90:;
    if (_188 >= 0)
    goto _jump91;
    fail_assertion("negative array index");
    _jump91:;
    if (_188 < _107.d1)
    goto _jump92;
    fail_assertion("index too large");
    _jump92:;
    int64_t _189 = 0;
    _189 *= _107.d0;
    _189 += _187;
    _189 *= _107.d1;
    _189 += _188;
    int64_t _190 = _107.data[_189];
    int64_t _191 = 282;
    int64_t _192 = 301;
    int64_t _193 = _191 + _192;
    int64_t _194;
    // Computing bound for c
    int64_t _195;
    // Computing bound for c
    int64_t _196 = 408;
    if (_196 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing bound for d
    int64_t _197 = 482;
    if (_197 > 0) 
    goto _jump94;
    fail_assertion("non-positive loop bound");
    _jump94:;
    _195 = 0;
    int64_t _198 = 0; // d
    int64_t _199 = 0; // c
    _jump95:; // Begin body of loop
    _195 += _198;
    _198++;
    if (_198 < _197)
    goto _jump95;
    _198 = 0;
    _199++;
    if (_199 < _196)
    goto _jump95;
    // End body of loop
    int64_t _200 = 510;
    int64_t _201 = -_200;
    int64_t _202 = _195 * _201;
    if (_202 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    _194 = 0;
    int64_t _203 = 0; // c
    _jump97:; // Begin body of loop
    int64_t _204;
    // Computing bound for d
    if (_203 > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    // Computing bound for e
    if (_203 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing bound for f
    int64_t _205 = -_203;
    if (_205 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    _204 = 0;
    int64_t _206 = 0; // f
    int64_t _207 = 0; // e
    int64_t _208 = 0; // d
    _jump101:; // Begin body of loop
    int64_t _209 = 779;
    _204 += _209;
    _206++;
    if (_206 < _205)
    goto _jump101;
    _206 = 0;
    _207++;
    if (_207 < _203)
    goto _jump101;
    _207 = 0;
    _208++;
    if (_208 < _203)
    goto _jump101;
    // End body of loop
    int64_t _210 = _204 / _203;
    int64_t _211 = _203 / _203;
    int64_t _212 = 798;
    int64_t _213 = -_212;
    _a1_int64_t _214;
    _214.d0 = 3;
    _214.data = jpl_alloc(sizeof(int64_t) * 3);
    _214.data[0] = _203;
    _214.data[1] = _211;
    _214.data[2] = _213;
    int64_t _215 = 553;
    if (_215 >= 0)
    goto _jump102;
    fail_assertion("negative array index");
    _jump102:;
    if (_215 < _214.d0)
    goto _jump103;
    fail_assertion("index too large");
    _jump103:;
    int64_t _216 = 0;
    _216 *= _214.d0;
    _216 += _215;
    int64_t _217 = _214.data[_216];
    int64_t _218 = _210 - _217;
    _194 += _218;
    _203++;
    if (_203 < _202)
    goto _jump97;
    // End body of loop
    if (_190 >= 0)
    goto _jump104;
    fail_assertion("negative array index");
    _jump104:;
    if (_190 < _48.d0)
    goto _jump105;
    fail_assertion("index too large");
    _jump105:;
    if (_193 >= 0)
    goto _jump106;
    fail_assertion("negative array index");
    _jump106:;
    if (_193 < _48.d1)
    goto _jump107;
    fail_assertion("index too large");
    _jump107:;
    if (_194 >= 0)
    goto _jump108;
    fail_assertion("negative array index");
    _jump108:;
    if (_194 < _48.d2)
    goto _jump109;
    fail_assertion("index too large");
    _jump109:;
    int64_t _219 = 0;
    _219 *= _48.d0;
    _219 += _190;
    _219 *= _48.d1;
    _219 += _193;
    _219 *= _48.d2;
    _219 += _194;
    int64_t _220 = _48.data[_219];
    _0.d0 = _220;
    if (_220 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing bound for d
    bool _222 = false;
    bool _221 = _222;
    if (0 != _222)
    goto _jump111;
    double _223 = a(b);
    double _224 = b.a;
    double _225 = -_224;
    bool _226 = _223 > _225;
    _221 = _226;
    _jump111:;
    int64_t _227 = 144;
    int64_t _228 = -_227;
    int64_t _229 = 584;
    bool _230 = _228 != _229;
    bool _231 = _221 != _230;
    int64_t _232;
    if (!_231)
    goto _jump112;
    _a2_int64_t _233;
    // Computing bound for c
    int64_t _234 = 719;
    _233.d0 = _234;
    if (_234 > 0) 
    goto _jump113;
    fail_assertion("non-positive loop bound");
    _jump113:;
    // Computing bound for d
    int64_t _235 = 577;
    _233.d1 = _235;
    if (_235 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    // Computing total size of heap memory to allocate
    int64_t _236 = 1;
    _236 *= _234;
    _236 *= _235;
    _236 *= sizeof(int64_t);
    _233.data = jpl_alloc(_236);
    int64_t _237 = 0; // d
    int64_t _238 = 0; // c
    _jump115:; // Begin body of loop
    int64_t _239 = 270;
    int64_t _240 = 0;
    _240 *= _233.d0;
    _240 += _238;
    _240 *= _233.d1;
    _240 += _237;
    _233.data[_240] = _239;
    _237++;
    if (_237 < _235)
    goto _jump115;
    _237 = 0;
    _238++;
    if (_238 < _234)
    goto _jump115;
    // End body of loop
    int64_t _241;
    // Computing bound for c
    int64_t _242 = 102;
    int64_t _243 = 444;
    int64_t _244 = _242 / _243;
    int64_t _245 = 952;
    int64_t _246 = _244 % _245;
    if (_246 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _241 = 0;
    int64_t _247 = 0; // c
    _jump117:; // Begin body of loop
    int64_t _248 = 874;
    int64_t _249 = -_248;
    _241 += _249;
    _247++;
    if (_247 < _246)
    goto _jump117;
    // End body of loop
    int64_t _250 = 588;
    int64_t _251 = -_250;
    if (_241 >= 0)
    goto _jump118;
    fail_assertion("negative array index");
    _jump118:;
    if (_241 < _233.d0)
    goto _jump119;
    fail_assertion("index too large");
    _jump119:;
    if (_251 >= 0)
    goto _jump120;
    fail_assertion("negative array index");
    _jump120:;
    if (_251 < _233.d1)
    goto _jump121;
    fail_assertion("index too large");
    _jump121:;
    int64_t _252 = 0;
    _252 *= _233.d0;
    _252 += _241;
    _252 *= _233.d1;
    _252 += _251;
    int64_t _253 = _233.data[_252];
    int64_t _254 = -_253;
    _232 = _254;
    goto _jump122;
    _jump112:;
    bool _255 = true;
    int64_t _256;
    if (!_255)
    goto _jump123;
    double _257 = b.r;
    double _258 = 69.0;
    double _259 = -_258;
    bool _260 = _257 != _259;
    bool _261 = !_260;
    int64_t _262;
    if (!_261)
    goto _jump124;
    int64_t _263;
    // Computing bound for c
    int64_t _264 = 135;
    if (_264 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    _263 = 0;
    int64_t _265 = 0; // c
    _jump126:; // Begin body of loop
    int64_t _266;
    // Computing bound for d
    int64_t _267 = 172;
    int64_t _268 = -_267;
    if (_268 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for e
    int64_t _269 = 639;
    if (_269 > 0) 
    goto _jump128;
    fail_assertion("non-positive loop bound");
    _jump128:;
    // Computing bound for f
    int64_t _270 = 640;
    int64_t _271 = _270 * _265;
    if (_271 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    _266 = 0;
    int64_t _272 = 0; // f
    int64_t _273 = 0; // e
    int64_t _274 = 0; // d
    _jump130:; // Begin body of loop
    _266 += _265;
    _272++;
    if (_272 < _271)
    goto _jump130;
    _272 = 0;
    _273++;
    if (_273 < _269)
    goto _jump130;
    _273 = 0;
    _274++;
    if (_274 < _268)
    goto _jump130;
    // End body of loop
    _263 += _266;
    _265++;
    if (_265 < _264)
    goto _jump126;
    // End body of loop
    _262 = _263;
    goto _jump131;
    _jump124:;
    int64_t _275 = 38;
    _262 = _275;
    _jump131:;
    _256 = _262;
    goto _jump132;
    _jump123:;
    int64_t _276 = 655;
    int64_t _277 = -_276;
    _256 = _277;
    _jump132:;
    _232 = _256;
    _jump122:;
    _0.d1 = _232;
    if (_232 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    // Computing bound for e
    int64_t _278 = 939;
    int64_t _279 = -_278;
    _0.d2 = _279;
    if (_279 > 0) 
    goto _jump134;
    fail_assertion("non-positive loop bound");
    _jump134:;
    // Computing total size of heap memory to allocate
    int64_t _280 = 1;
    _280 *= _220;
    _280 *= _232;
    _280 *= _279;
    _280 *= sizeof(int64_t);
    _0.data = jpl_alloc(_280);
    int64_t _281 = 0; // e
    int64_t _282 = 0; // d
    int64_t _283 = 0; // c
    _jump135:; // Begin body of loop
    int64_t _284 = 0;
    _284 *= _0.d0;
    _284 += _283;
    _284 *= _0.d1;
    _284 += _282;
    _284 *= _0.d2;
    _284 += _281;
    _0.data[_284] = _282;
    _281++;
    if (_281 < _279)
    goto _jump135;
    _281 = 0;
    _282++;
    if (_282 < _232)
    goto _jump135;
    _282 = 0;
    _283++;
    if (_283 < _220)
    goto _jump135;
    // End body of loop
    bool _286 = false;
    bool _287 = !_286;
    bool _288;
    if (!_287)
    goto _jump136;
    bool _289 = false;
    bool _290 = !_289;
    bool _291;
    if (!_290)
    goto _jump137;
    bool _292 = true;
    _291 = _292;
    goto _jump138;
    _jump137:;
    bool _293 = true;
    _291 = _293;
    _jump138:;
    _288 = _291;
    goto _jump139;
    _jump136:;
    bool _294 = false;
    _288 = _294;
    _jump139:;
    bool _295;
    if (!_288)
    goto _jump140;
    double _296 = 76.0;
    double _297 = -_296;
    bool _298 = false;
    double _299;
    if (!_298)
    goto _jump141;
    double _300 = 24.0;
    _299 = _300;
    goto _jump142;
    _jump141:;
    double _301 = b.r;
    _299 = _301;
    _jump142:;
    bool _302 = _297 <= _299;
    _295 = _302;
    goto _jump143;
    _jump140:;
    bool _303 = false;
    bool _304 = !_303;
    bool _305 = !_304;
    _295 = _305;
    _jump143:;
    bool _285 = _295;
    if (0 != _295)
    goto _jump144;
    int64_t _306 = 946;
    int64_t _307 = -_306;
    int64_t _308 = -_307;
    int64_t _309 = 826;
    int64_t _310 = -_309;
    int64_t _311 = _308 / _310;
    bool _313 = false;
    bool _312 = _313;
    if (0 == _313)
    goto _jump145;
    bool _314 = false;
    _312 = _314;
    _jump145:;
    int64_t _315;
    if (!_312)
    goto _jump146;
    int64_t _316 = 756;
    _315 = _316;
    goto _jump147;
    _jump146:;
    int64_t _317 = 378;
    int64_t _318 = 642;
    int64_t _319 = _317 % _318;
    _315 = _319;
    _jump147:;
    int64_t _320 = 785;
    int64_t _321;
    // Computing bound for d
    int64_t _322 = 343;
    if (_322 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    _321 = 0;
    int64_t _323 = 0; // d
    _jump149:; // Begin body of loop
    _321 += _323;
    _323++;
    if (_323 < _322)
    goto _jump149;
    // End body of loop
    int64_t _324 = _320 % _321;
    int64_t _325 = _315 - _324;
    bool _326 = _311 != _325;
    _285 = _326;
    _jump144:;
    int64_t _327;
    if (!_285)
    goto _jump150;
    int64_t _328;
    // Computing bound for d
    int64_t _329 = 683;
    if (_329 > 0) 
    goto _jump151;
    fail_assertion("non-positive loop bound");
    _jump151:;
    // Computing bound for e
    int64_t _330;
    // Computing bound for d
    int64_t _331 = 277;
    int64_t _332 = -_331;
    if (_332 > 0) 
    goto _jump152;
    fail_assertion("non-positive loop bound");
    _jump152:;
    // Computing bound for e
    int64_t _333 = 59;
    int64_t _334 = -_333;
    if (_334 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    _330 = 0;
    int64_t _335 = 0; // e
    int64_t _336 = 0; // d
    _jump154:; // Begin body of loop
    bool _337 = true;
    int64_t _338;
    if (!_337)
    goto _jump155;
    _338 = _335;
    goto _jump156;
    _jump155:;
    _338 = _335;
    _jump156:;
    _330 += _338;
    _335++;
    if (_335 < _334)
    goto _jump154;
    _335 = 0;
    _336++;
    if (_336 < _332)
    goto _jump154;
    // End body of loop
    int64_t _339 = 800;
    int64_t _340 = _330 / _339;
    int64_t _341 = -_340;
    if (_341 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    _328 = 0;
    int64_t _342 = 0; // e
    int64_t _343 = 0; // d
    _jump158:; // Begin body of loop
    int64_t _344 = _343 / _342;
    _328 += _344;
    _342++;
    if (_342 < _341)
    goto _jump158;
    _342 = 0;
    _343++;
    if (_343 < _329)
    goto _jump158;
    // End body of loop
    _327 = _328;
    goto _jump159;
    _jump150:;
    _a2_int64_t _345;
    // Computing bound for d
    int64_t _346;
    // Computing bound for d
    int64_t _347 = 15;
    int64_t _348 = 982;
    int64_t _349 = 435;
    if (_347 >= 0)
    goto _jump160;
    fail_assertion("negative array index");
    _jump160:;
    if (_347 < _0.d0)
    goto _jump161;
    fail_assertion("index too large");
    _jump161:;
    if (_348 >= 0)
    goto _jump162;
    fail_assertion("negative array index");
    _jump162:;
    if (_348 < _0.d1)
    goto _jump163;
    fail_assertion("index too large");
    _jump163:;
    if (_349 >= 0)
    goto _jump164;
    fail_assertion("negative array index");
    _jump164:;
    if (_349 < _0.d2)
    goto _jump165;
    fail_assertion("index too large");
    _jump165:;
    int64_t _350 = 0;
    _350 *= _0.d0;
    _350 += _347;
    _350 *= _0.d1;
    _350 += _348;
    _350 *= _0.d2;
    _350 += _349;
    int64_t _351 = _0.data[_350];
    if (_351 > 0) 
    goto _jump166;
    fail_assertion("non-positive loop bound");
    _jump166:;
    _346 = 0;
    int64_t _352 = 0; // d
    _jump167:; // Begin body of loop
    int64_t _353 = 57;
    _346 += _353;
    _352++;
    if (_352 < _351)
    goto _jump167;
    // End body of loop
    int64_t _354 = -_346;
    _345.d0 = _354;
    if (_354 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    // Computing bound for e
    bool _355 = true;
    int64_t _356;
    if (!_355)
    goto _jump169;
    int64_t _357 = 1;
    _356 = _357;
    goto _jump170;
    _jump169:;
    int64_t _358 = 327;
    _356 = _358;
    _jump170:;
    _345.d1 = _356;
    if (_356 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing total size of heap memory to allocate
    int64_t _359 = 1;
    _359 *= _354;
    _359 *= _356;
    _359 *= sizeof(int64_t);
    _345.data = jpl_alloc(_359);
    int64_t _360 = 0; // e
    int64_t _361 = 0; // d
    _jump172:; // Begin body of loop
    bool _362 = false;
    int64_t _363;
    if (!_362)
    goto _jump173;
    _363 = _361;
    goto _jump174;
    _jump173:;
    _363 = _361;
    _jump174:;
    int64_t _364 = 800;
    int64_t _365 = _363 % _364;
    int64_t _366 = _361 * _365;
    int64_t _367 = 0;
    _367 *= _345.d0;
    _367 += _361;
    _367 *= _345.d1;
    _367 += _360;
    _345.data[_367] = _366;
    _360++;
    if (_360 < _356)
    goto _jump172;
    _360 = 0;
    _361++;
    if (_361 < _354)
    goto _jump172;
    // End body of loop
    int64_t _368 = 316;
    int64_t _369 = 73;
    int64_t _370 = 363;
    int64_t _371 = _369 - _370;
    int64_t _372 = _368 * _371;
    _a3_int64_t _373;
    // Computing bound for d
    int64_t _374 = 175;
    _373.d0 = _374;
    if (_374 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing bound for e
    int64_t _375 = 446;
    _373.d1 = _375;
    if (_375 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    // Computing bound for f
    int64_t _376 = 156;
    _373.d2 = _376;
    if (_376 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing total size of heap memory to allocate
    int64_t _377 = 1;
    _377 *= _374;
    _377 *= _375;
    _377 *= _376;
    _377 *= sizeof(int64_t);
    _373.data = jpl_alloc(_377);
    int64_t _378 = 0; // f
    int64_t _379 = 0; // e
    int64_t _380 = 0; // d
    _jump178:; // Begin body of loop
    int64_t _381 = 0;
    _381 *= _373.d0;
    _381 += _380;
    _381 *= _373.d1;
    _381 += _379;
    _381 *= _373.d2;
    _381 += _378;
    _373.data[_381] = _379;
    _378++;
    if (_378 < _376)
    goto _jump178;
    _378 = 0;
    _379++;
    if (_379 < _375)
    goto _jump178;
    _379 = 0;
    _380++;
    if (_380 < _374)
    goto _jump178;
    // End body of loop
    int64_t _382 = 409;
    int64_t _383 = 270;
    int64_t _384 = 795;
    if (_382 >= 0)
    goto _jump179;
    fail_assertion("negative array index");
    _jump179:;
    if (_382 < _373.d0)
    goto _jump180;
    fail_assertion("index too large");
    _jump180:;
    if (_383 >= 0)
    goto _jump181;
    fail_assertion("negative array index");
    _jump181:;
    if (_383 < _373.d1)
    goto _jump182;
    fail_assertion("index too large");
    _jump182:;
    if (_384 >= 0)
    goto _jump183;
    fail_assertion("negative array index");
    _jump183:;
    if (_384 < _373.d2)
    goto _jump184;
    fail_assertion("index too large");
    _jump184:;
    int64_t _385 = 0;
    _385 *= _373.d0;
    _385 += _382;
    _385 *= _373.d1;
    _385 += _383;
    _385 *= _373.d2;
    _385 += _384;
    int64_t _386 = _373.data[_385];
    int64_t _387 = -_386;
    _a1_int64_t _388;
    // Computing bound for d
    int64_t _389 = 349;
    int64_t _390 = -_389;
    _388.d0 = _390;
    if (_390 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= _390;
    _391 *= sizeof(int64_t);
    _388.data = jpl_alloc(_391);
    int64_t _392 = 0; // d
    _jump186:; // Begin body of loop
    int64_t _393 = 0;
    _393 *= _388.d0;
    _393 += _392;
    _388.data[_393] = _392;
    _392++;
    if (_392 < _390)
    goto _jump186;
    // End body of loop
    int64_t _394 = 8;
    int64_t _395 = -_394;
    int64_t _396 = -_395;
    if (_396 >= 0)
    goto _jump187;
    fail_assertion("negative array index");
    _jump187:;
    if (_396 < _388.d0)
    goto _jump188;
    fail_assertion("index too large");
    _jump188:;
    int64_t _397 = 0;
    _397 *= _388.d0;
    _397 += _396;
    int64_t _398 = _388.data[_397];
    int64_t _399 = _387 + _398;
    if (_372 >= 0)
    goto _jump189;
    fail_assertion("negative array index");
    _jump189:;
    if (_372 < _345.d0)
    goto _jump190;
    fail_assertion("index too large");
    _jump190:;
    if (_399 >= 0)
    goto _jump191;
    fail_assertion("negative array index");
    _jump191:;
    if (_399 < _345.d1)
    goto _jump192;
    fail_assertion("index too large");
    _jump192:;
    int64_t _400 = 0;
    _400 *= _345.d0;
    _400 += _372;
    _400 *= _345.d1;
    _400 += _399;
    int64_t _401 = _345.data[_400];
    _327 = _401;
    _jump159:;
    int64_t _402 = -_327;
    int64_t _404 = 573;
    _a2_int64_t _405;
    // Computing bound for e
    _405.d0 = _402;
    if (_402 > 0) 
    goto _jump193;
    fail_assertion("non-positive loop bound");
    _jump193:;
    // Computing bound for f
    _405.d1 = _402;
    if (_402 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _402;
    _406 *= _402;
    _406 *= sizeof(int64_t);
    _405.data = jpl_alloc(_406);
    int64_t _407 = 0; // f
    int64_t _408 = 0; // e
    _jump195:; // Begin body of loop
    int64_t _409 = 624;
    int64_t _410 = 0;
    _410 *= _405.d0;
    _410 += _408;
    _410 *= _405.d1;
    _410 += _407;
    _405.data[_410] = _409;
    _407++;
    if (_407 < _402)
    goto _jump195;
    _407 = 0;
    _408++;
    if (_408 < _402)
    goto _jump195;
    // End body of loop
    int64_t _411 = 523;
    int64_t _412 = 140;
    int64_t _413 = 295;
    if (_411 >= 0)
    goto _jump196;
    fail_assertion("negative array index");
    _jump196:;
    if (_411 < _0.d0)
    goto _jump197;
    fail_assertion("index too large");
    _jump197:;
    if (_412 >= 0)
    goto _jump198;
    fail_assertion("negative array index");
    _jump198:;
    if (_412 < _0.d1)
    goto _jump199;
    fail_assertion("index too large");
    _jump199:;
    if (_413 >= 0)
    goto _jump200;
    fail_assertion("negative array index");
    _jump200:;
    if (_413 < _0.d2)
    goto _jump201;
    fail_assertion("index too large");
    _jump201:;
    int64_t _414 = 0;
    _414 *= _0.d0;
    _414 += _411;
    _414 *= _0.d1;
    _414 += _412;
    _414 *= _0.d2;
    _414 += _413;
    int64_t _415 = _0.data[_414];
    int64_t _416 = -_402;
    int64_t _417 = -_416;
    if (_415 >= 0)
    goto _jump202;
    fail_assertion("negative array index");
    _jump202:;
    if (_415 < _405.d0)
    goto _jump203;
    fail_assertion("index too large");
    _jump203:;
    if (_417 >= 0)
    goto _jump204;
    fail_assertion("negative array index");
    _jump204:;
    if (_417 < _405.d1)
    goto _jump205;
    fail_assertion("index too large");
    _jump205:;
    int64_t _418 = 0;
    _418 *= _405.d0;
    _418 += _415;
    _418 *= _405.d1;
    _418 += _417;
    int64_t _419 = _405.data[_418];
    int64_t _420 = -_419;
    bool _421 = _404 > _420;
    bool _403 = _421;
    if (0 == _421)
    goto _jump206;
    bool _422 = true;
    _a3__a3_bool _423;
    if (!_422)
    goto _jump207;
    _a3__a3_bool _424;
    // Computing bound for e
    int64_t _425 = 370;
    _424.d0 = _425;
    if (_425 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing bound for f
    _424.d1 = _402;
    if (_402 > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    // Computing bound for g
    int64_t _426 = -_402;
    _424.d2 = _426;
    if (_426 > 0) 
    goto _jump210;
    fail_assertion("non-positive loop bound");
    _jump210:;
    // Computing total size of heap memory to allocate
    int64_t _427 = 1;
    _427 *= _425;
    _427 *= _402;
    _427 *= _426;
    _427 *= sizeof(_a3_bool);
    _424.data = jpl_alloc(_427);
    int64_t _428 = 0; // g
    int64_t _429 = 0; // f
    int64_t _430 = 0; // e
    _jump211:; // Begin body of loop
    _a3_bool _431;
    // Computing bound for h
    _431.d0 = _428;
    if (_428 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for i
    _431.d1 = _428;
    if (_428 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing bound for j
    _431.d2 = _430;
    if (_430 > 0) 
    goto _jump214;
    fail_assertion("non-positive loop bound");
    _jump214:;
    // Computing total size of heap memory to allocate
    int64_t _432 = 1;
    _432 *= _428;
    _432 *= _428;
    _432 *= _430;
    _432 *= sizeof(bool);
    _431.data = jpl_alloc(_432);
    int64_t _433 = 0; // j
    int64_t _434 = 0; // i
    int64_t _435 = 0; // h
    _jump215:; // Begin body of loop
    bool _436 = false;
    int64_t _437 = 0;
    _437 *= _431.d0;
    _437 += _435;
    _437 *= _431.d1;
    _437 += _434;
    _437 *= _431.d2;
    _437 += _433;
    _431.data[_437] = _436;
    _433++;
    if (_433 < _430)
    goto _jump215;
    _433 = 0;
    _434++;
    if (_434 < _428)
    goto _jump215;
    _434 = 0;
    _435++;
    if (_435 < _428)
    goto _jump215;
    // End body of loop
    int64_t _438 = 0;
    _438 *= _424.d0;
    _438 += _430;
    _438 *= _424.d1;
    _438 += _429;
    _438 *= _424.d2;
    _438 += _428;
    _424.data[_438] = _431;
    _428++;
    if (_428 < _426)
    goto _jump211;
    _428 = 0;
    _429++;
    if (_429 < _402)
    goto _jump211;
    _429 = 0;
    _430++;
    if (_430 < _425)
    goto _jump211;
    // End body of loop
    _423 = _424;
    goto _jump216;
    _jump207:;
    _a3__a3_bool _439;
    // Computing bound for e
    int64_t _440 = _402 - _402;
    _439.d0 = _440;
    if (_440 > 0) 
    goto _jump217;
    fail_assertion("non-positive loop bound");
    _jump217:;
    // Computing bound for f
    int64_t _441 = -_402;
    _439.d1 = _441;
    if (_441 > 0) 
    goto _jump218;
    fail_assertion("non-positive loop bound");
    _jump218:;
    // Computing bound for g
    int64_t _442 = 104;
    _439.d2 = _442;
    if (_442 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= _440;
    _443 *= _441;
    _443 *= _442;
    _443 *= sizeof(_a3_bool);
    _439.data = jpl_alloc(_443);
    int64_t _444 = 0; // g
    int64_t _445 = 0; // f
    int64_t _446 = 0; // e
    _jump220:; // Begin body of loop
    _a3_bool _447;
    // Computing bound for h
    _447.d0 = _444;
    if (_444 > 0) 
    goto _jump221;
    fail_assertion("non-positive loop bound");
    _jump221:;
    // Computing bound for i
    int64_t _448 = 996;
    _447.d1 = _448;
    if (_448 > 0) 
    goto _jump222;
    fail_assertion("non-positive loop bound");
    _jump222:;
    // Computing bound for j
    _447.d2 = _402;
    if (_402 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing total size of heap memory to allocate
    int64_t _449 = 1;
    _449 *= _444;
    _449 *= _448;
    _449 *= _402;
    _449 *= sizeof(bool);
    _447.data = jpl_alloc(_449);
    int64_t _450 = 0; // j
    int64_t _451 = 0; // i
    int64_t _452 = 0; // h
    _jump224:; // Begin body of loop
    bool _453 = true;
    int64_t _454 = 0;
    _454 *= _447.d0;
    _454 += _452;
    _454 *= _447.d1;
    _454 += _451;
    _454 *= _447.d2;
    _454 += _450;
    _447.data[_454] = _453;
    _450++;
    if (_450 < _402)
    goto _jump224;
    _450 = 0;
    _451++;
    if (_451 < _448)
    goto _jump224;
    _451 = 0;
    _452++;
    if (_452 < _444)
    goto _jump224;
    // End body of loop
    int64_t _455 = 0;
    _455 *= _439.d0;
    _455 += _446;
    _455 *= _439.d1;
    _455 += _445;
    _455 *= _439.d2;
    _455 += _444;
    _439.data[_455] = _447;
    _444++;
    if (_444 < _442)
    goto _jump220;
    _444 = 0;
    _445++;
    if (_445 < _441)
    goto _jump220;
    _445 = 0;
    _446++;
    if (_446 < _440)
    goto _jump220;
    // End body of loop
    _423 = _439;
    _jump216:;
    int64_t _456;
    // Computing bound for e
    int64_t _457;
    // Computing bound for e
    int64_t _458 = 278;
    int64_t _459 = -_458;
    if (_459 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    _457 = 0;
    int64_t _460 = 0; // e
    _jump226:; // Begin body of loop
    int64_t _461;
    // Computing bound for f
    if (_460 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    _461 = 0;
    int64_t _462 = 0; // f
    _jump228:; // Begin body of loop
    _461 += _402;
    _462++;
    if (_462 < _460)
    goto _jump228;
    // End body of loop
    _457 += _461;
    _460++;
    if (_460 < _459)
    goto _jump226;
    // End body of loop
    if (_457 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for f
    if (_402 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for g
    int64_t _463 = 305;
    if (_463 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    _456 = 0;
    int64_t _464 = 0; // g
    int64_t _465 = 0; // f
    int64_t _466 = 0; // e
    _jump232:; // Begin body of loop
    _456 += _464;
    _464++;
    if (_464 < _463)
    goto _jump232;
    _464 = 0;
    _465++;
    if (_465 < _402)
    goto _jump232;
    _465 = 0;
    _466++;
    if (_466 < _457)
    goto _jump232;
    // End body of loop
    int64_t _467;
    // Computing bound for e
    int64_t _468;
    // Computing bound for e
    int64_t _469 = 483;
    if (_469 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    _468 = 0;
    int64_t _470 = 0; // e
    _jump234:; // Begin body of loop
    _468 += _402;
    _470++;
    if (_470 < _469)
    goto _jump234;
    // End body of loop
    int64_t _471 = -_468;
    if (_471 > 0) 
    goto _jump235;
    fail_assertion("non-positive loop bound");
    _jump235:;
    // Computing bound for f
    if (_402 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    _467 = 0;
    int64_t _472 = 0; // f
    int64_t _473 = 0; // e
    _jump237:; // Begin body of loop
    _467 += _472;
    _472++;
    if (_472 < _402)
    goto _jump237;
    _472 = 0;
    _473++;
    if (_473 < _471)
    goto _jump237;
    // End body of loop
    bool _474 = true;
    bool _475;
    if (!_474)
    goto _jump238;
    bool _476 = false;
    _475 = _476;
    goto _jump239;
    _jump238:;
    bool _477 = false;
    _475 = _477;
    _jump239:;
    int64_t _478;
    if (!_475)
    goto _jump240;
    int64_t _479 = 99;
    int64_t _480 = -_402;
    int64_t _481 = _479 / _480;
    _478 = _481;
    goto _jump241;
    _jump240:;
    int64_t _482 = 632;
    int64_t _483 = 800;
    int64_t _484 = _482 + _483;
    int64_t _485 = 862;
    int64_t _486 = _484 % _485;
    _478 = _486;
    _jump241:;
    if (_456 >= 0)
    goto _jump242;
    fail_assertion("negative array index");
    _jump242:;
    if (_456 < _423.d0)
    goto _jump243;
    fail_assertion("index too large");
    _jump243:;
    if (_467 >= 0)
    goto _jump244;
    fail_assertion("negative array index");
    _jump244:;
    if (_467 < _423.d1)
    goto _jump245;
    fail_assertion("index too large");
    _jump245:;
    if (_478 >= 0)
    goto _jump246;
    fail_assertion("negative array index");
    _jump246:;
    if (_478 < _423.d2)
    goto _jump247;
    fail_assertion("index too large");
    _jump247:;
    int64_t _487 = 0;
    _487 *= _423.d0;
    _487 += _456;
    _487 *= _423.d1;
    _487 += _467;
    _487 *= _423.d2;
    _487 += _478;
    _a3_bool _488 = _423.data[_487];
    bool _489 = false;
    int64_t _490;
    if (!_489)
    goto _jump248;
    _490 = _402;
    goto _jump249;
    _jump248:;
    int64_t _491 = 455;
    int64_t _492 = -_402;
    int64_t _493 = -_492;
    int64_t _494 = 651;
    if (_491 >= 0)
    goto _jump250;
    fail_assertion("negative array index");
    _jump250:;
    if (_491 < _0.d0)
    goto _jump251;
    fail_assertion("index too large");
    _jump251:;
    if (_493 >= 0)
    goto _jump252;
    fail_assertion("negative array index");
    _jump252:;
    if (_493 < _0.d1)
    goto _jump253;
    fail_assertion("index too large");
    _jump253:;
    if (_494 >= 0)
    goto _jump254;
    fail_assertion("negative array index");
    _jump254:;
    if (_494 < _0.d2)
    goto _jump255;
    fail_assertion("index too large");
    _jump255:;
    int64_t _495 = 0;
    _495 *= _0.d0;
    _495 += _491;
    _495 *= _0.d1;
    _495 += _493;
    _495 *= _0.d2;
    _495 += _494;
    int64_t _496 = _0.data[_495];
    _490 = _496;
    _jump249:;
    int64_t _497 = 997;
    _a3_int64_t _498;
    // Computing bound for e
    int64_t _499 = 678;
    _498.d0 = _499;
    if (_499 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing bound for f
    int64_t _500 = -_402;
    _498.d1 = _500;
    if (_500 > 0) 
    goto _jump257;
    fail_assertion("non-positive loop bound");
    _jump257:;
    // Computing bound for g
    int64_t _501;
    // Computing bound for e
    if (_402 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    // Computing bound for f
    int64_t _502 = 318;
    if (_502 > 0) 
    goto _jump259;
    fail_assertion("non-positive loop bound");
    _jump259:;
    _501 = 0;
    int64_t _503 = 0; // f
    int64_t _504 = 0; // e
    _jump260:; // Begin body of loop
    int64_t _505 = 349;
    _501 += _505;
    _503++;
    if (_503 < _502)
    goto _jump260;
    _503 = 0;
    _504++;
    if (_504 < _402)
    goto _jump260;
    // End body of loop
    _498.d2 = _501;
    if (_501 > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    // Computing total size of heap memory to allocate
    int64_t _506 = 1;
    _506 *= _499;
    _506 *= _500;
    _506 *= _501;
    _506 *= sizeof(int64_t);
    _498.data = jpl_alloc(_506);
    int64_t _507 = 0; // g
    int64_t _508 = 0; // f
    int64_t _509 = 0; // e
    _jump262:; // Begin body of loop
    int64_t _510 = -_508;
    int64_t _511 = 0;
    _511 *= _498.d0;
    _511 += _509;
    _511 *= _498.d1;
    _511 += _508;
    _511 *= _498.d2;
    _511 += _507;
    _498.data[_511] = _510;
    _507++;
    if (_507 < _501)
    goto _jump262;
    _507 = 0;
    _508++;
    if (_508 < _500)
    goto _jump262;
    _508 = 0;
    _509++;
    if (_509 < _499)
    goto _jump262;
    // End body of loop
    int64_t _512 = -_402;
    int64_t _513;
    // Computing bound for e
    int64_t _514 = 29;
    int64_t _515 = 958;
    int64_t _516 = _514 + _515;
    if (_516 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing bound for f
    int64_t _517 = 802;
    if (_517 > 0) 
    goto _jump264;
    fail_assertion("non-positive loop bound");
    _jump264:;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    _513 = 0;
    int64_t _518 = 0; // g
    int64_t _519 = 0; // f
    int64_t _520 = 0; // e
    _jump266:; // Begin body of loop
    _513 += _519;
    _518++;
    if (_518 < _402)
    goto _jump266;
    _518 = 0;
    _519++;
    if (_519 < _517)
    goto _jump266;
    _519 = 0;
    _520++;
    if (_520 < _516)
    goto _jump266;
    // End body of loop
    int64_t _521 = 83;
    bool _522 = _521 == _402;
    int64_t _523;
    if (!_522)
    goto _jump267;
    int64_t _524 = 874;
    _523 = _524;
    goto _jump268;
    _jump267:;
    _523 = _402;
    _jump268:;
    if (_512 >= 0)
    goto _jump269;
    fail_assertion("negative array index");
    _jump269:;
    if (_512 < _498.d0)
    goto _jump270;
    fail_assertion("index too large");
    _jump270:;
    if (_513 >= 0)
    goto _jump271;
    fail_assertion("negative array index");
    _jump271:;
    if (_513 < _498.d1)
    goto _jump272;
    fail_assertion("index too large");
    _jump272:;
    if (_523 >= 0)
    goto _jump273;
    fail_assertion("negative array index");
    _jump273:;
    if (_523 < _498.d2)
    goto _jump274;
    fail_assertion("index too large");
    _jump274:;
    int64_t _525 = 0;
    _525 *= _498.d0;
    _525 += _512;
    _525 *= _498.d1;
    _525 += _513;
    _525 *= _498.d2;
    _525 += _523;
    int64_t _526 = _498.data[_525];
    int64_t _527 = _497 / _526;
    int64_t _528;
    // Computing bound for e
    if (_402 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    _528 = 0;
    int64_t _529 = 0; // e
    _jump276:; // Begin body of loop
    _528 += _402;
    _529++;
    if (_529 < _402)
    goto _jump276;
    // End body of loop
    int64_t _530 = -_402;
    bool _531 = _528 <= _530;
    _a1_int64_t _532;
    if (!_531)
    goto _jump277;
    _a1_int64_t _533;
    // Computing bound for e
    _533.d0 = _402;
    if (_402 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing total size of heap memory to allocate
    int64_t _534 = 1;
    _534 *= _402;
    _534 *= sizeof(int64_t);
    _533.data = jpl_alloc(_534);
    int64_t _535 = 0; // e
    _jump279:; // Begin body of loop
    int64_t _536;
    // Computing bound for f
    int64_t _537 = 936;
    if (_537 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    _536 = 0;
    int64_t _538 = 0; // f
    _jump281:; // Begin body of loop
    _536 += _538;
    _538++;
    if (_538 < _537)
    goto _jump281;
    // End body of loop
    int64_t _539 = 0;
    _539 *= _533.d0;
    _539 += _535;
    _533.data[_539] = _536;
    _535++;
    if (_535 < _402)
    goto _jump279;
    // End body of loop
    _532 = _533;
    goto _jump282;
    _jump277:;
    _a1_int64_t _540;
    // Computing bound for e
    int64_t _541 = 524;
    _540.d0 = _541;
    if (_541 > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    // Computing total size of heap memory to allocate
    int64_t _542 = 1;
    _542 *= _541;
    _542 *= sizeof(int64_t);
    _540.data = jpl_alloc(_542);
    int64_t _543 = 0; // e
    _jump284:; // Begin body of loop
    int64_t _544 = 0;
    _544 *= _540.d0;
    _544 += _543;
    _540.data[_544] = _402;
    _543++;
    if (_543 < _541)
    goto _jump284;
    // End body of loop
    _532 = _540;
    _jump282:;
    int64_t _545 = 98;
    int64_t _546 = _402 - _545;
    if (_546 >= 0)
    goto _jump285;
    fail_assertion("negative array index");
    _jump285:;
    if (_546 < _532.d0)
    goto _jump286;
    fail_assertion("index too large");
    _jump286:;
    int64_t _547 = 0;
    _547 *= _532.d0;
    _547 += _546;
    int64_t _548 = _532.data[_547];
    if (_490 >= 0)
    goto _jump287;
    fail_assertion("negative array index");
    _jump287:;
    if (_490 < _488.d0)
    goto _jump288;
    fail_assertion("index too large");
    _jump288:;
    if (_527 >= 0)
    goto _jump289;
    fail_assertion("negative array index");
    _jump289:;
    if (_527 < _488.d1)
    goto _jump290;
    fail_assertion("index too large");
    _jump290:;
    if (_548 >= 0)
    goto _jump291;
    fail_assertion("negative array index");
    _jump291:;
    if (_548 < _488.d2)
    goto _jump292;
    fail_assertion("index too large");
    _jump292:;
    int64_t _549 = 0;
    _549 *= _488.d0;
    _549 += _490;
    _549 *= _488.d1;
    _549 += _527;
    _549 *= _488.d2;
    _549 += _548;
    bool _550 = _488.data[_549];
    _403 = _550;
    _jump206:;
    bool _551 = !_403;
    _a3_rgba _552;
    // Computing bound for f
    int64_t _553;
    // Computing bound for f
    int64_t _554 = 125;
    int64_t _555 = 73;
    int64_t _556 = 819;
    int64_t _557 = -_556;
    bool _558 = _555 == _557;
    int64_t _559;
    if (!_558)
    goto _jump293;
    int64_t _560 = 329;
    int64_t _561 = -_560;
    _559 = _561;
    goto _jump294;
    _jump293:;
    bool _562 = true;
    int64_t _563;
    if (!_562)
    goto _jump295;
    _563 = _402;
    goto _jump296;
    _jump295:;
    _563 = _402;
    _jump296:;
    int64_t _564 = _402 + _563;
    _559 = _564;
    _jump294:;
    bool _565 = true;
    bool _566 = !_565;
    int64_t _567;
    if (!_566)
    goto _jump297;
    int64_t _568;
    // Computing bound for f
    int64_t _569;
    if (!_551)
    goto _jump298;
    int64_t _570 = 498;
    _569 = _570;
    goto _jump299;
    _jump298:;
    int64_t _571 = 790;
    _569 = _571;
    _jump299:;
    if (_569 > 0) 
    goto _jump300;
    fail_assertion("non-positive loop bound");
    _jump300:;
    // Computing bound for g
    int64_t _572 = 857;
    if (_572 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing bound for h
    int64_t _573 = 131;
    if (_573 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    _568 = 0;
    int64_t _574 = 0; // h
    int64_t _575 = 0; // g
    int64_t _576 = 0; // f
    _jump303:; // Begin body of loop
    int64_t _577;
    // Computing bound for i
    if (_574 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for j
    if (_576 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    _577 = 0;
    int64_t _578 = 0; // j
    int64_t _579 = 0; // i
    _jump306:; // Begin body of loop
    _577 += _578;
    _578++;
    if (_578 < _576)
    goto _jump306;
    _578 = 0;
    _579++;
    if (_579 < _574)
    goto _jump306;
    // End body of loop
    _568 += _577;
    _574++;
    if (_574 < _573)
    goto _jump303;
    _574 = 0;
    _575++;
    if (_575 < _572)
    goto _jump303;
    _575 = 0;
    _576++;
    if (_576 < _569)
    goto _jump303;
    // End body of loop
    _567 = _568;
    goto _jump307;
    _jump297:;
    double _580 = 49.0;
    double _581 = 79.0;
    bool _582 = _580 == _581;
    int64_t _583;
    if (!_582)
    goto _jump308;
    _583 = _402;
    goto _jump309;
    _jump308:;
    _583 = _402;
    _jump309:;
    _567 = _583;
    _jump307:;
    _a1_int64_t _584;
    _584.d0 = 3;
    _584.data = jpl_alloc(sizeof(int64_t) * 3);
    _584.data[0] = _554;
    _584.data[1] = _559;
    _584.data[2] = _567;
    if (_402 >= 0)
    goto _jump310;
    fail_assertion("negative array index");
    _jump310:;
    if (_402 < _584.d0)
    goto _jump311;
    fail_assertion("index too large");
    _jump311:;
    int64_t _585 = 0;
    _585 *= _584.d0;
    _585 += _402;
    int64_t _586 = _584.data[_585];
    if (_586 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for h
    bool _587 = _551;
    if (0 != _551)
    goto _jump314;
    bool _588 = false;
    bool _589 = !_588;
    _587 = _589;
    _jump314:;
    bool _590;
    if (!_587)
    goto _jump315;
    bool _591 = !_551;
    bool _592 = !_591;
    _590 = _592;
    goto _jump316;
    _jump315:;
    bool _593 = true;
    _590 = _593;
    _jump316:;
    _a1_int64_t _594;
    if (!_590)
    goto _jump317;
    int64_t _595 = 63;
    int64_t _596 = 273;
    if (_402 >= 0)
    goto _jump318;
    fail_assertion("negative array index");
    _jump318:;
    if (_402 < _0.d0)
    goto _jump319;
    fail_assertion("index too large");
    _jump319:;
    if (_595 >= 0)
    goto _jump320;
    fail_assertion("negative array index");
    _jump320:;
    if (_595 < _0.d1)
    goto _jump321;
    fail_assertion("index too large");
    _jump321:;
    if (_596 >= 0)
    goto _jump322;
    fail_assertion("negative array index");
    _jump322:;
    if (_596 < _0.d2)
    goto _jump323;
    fail_assertion("index too large");
    _jump323:;
    int64_t _597 = 0;
    _597 *= _0.d0;
    _597 += _402;
    _597 *= _0.d1;
    _597 += _595;
    _597 *= _0.d2;
    _597 += _596;
    int64_t _598 = _0.data[_597];
    _a1_int64_t _599;
    _599.d0 = 1;
    _599.data = jpl_alloc(sizeof(int64_t) * 1);
    _599.data[0] = _598;
    _594 = _599;
    goto _jump324;
    _jump317:;
    int64_t _600 = 901;
    _a1_int64_t _601;
    _601.d0 = 2;
    _601.data = jpl_alloc(sizeof(int64_t) * 2);
    _601.data[0] = _402;
    _601.data[1] = _600;
    _594 = _601;
    _jump324:;
    int64_t _602 = 818;
    if (_602 >= 0)
    goto _jump325;
    fail_assertion("negative array index");
    _jump325:;
    if (_602 < _594.d0)
    goto _jump326;
    fail_assertion("index too large");
    _jump326:;
    int64_t _603 = 0;
    _603 *= _594.d0;
    _603 += _602;
    int64_t _604 = _594.data[_603];
    if (_604 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    _553 = 0;
    int64_t _605 = 0; // h
    int64_t _606 = 0; // g
    int64_t _607 = 0; // f
    _jump328:; // Begin body of loop
    _a3_double _608;
    // Computing bound for i
    _608.d0 = _402;
    if (_402 > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for j
    _608.d1 = _605;
    if (_605 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing bound for k
    _608.d2 = _402;
    if (_402 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing total size of heap memory to allocate
    int64_t _609 = 1;
    _609 *= _402;
    _609 *= _605;
    _609 *= _402;
    _609 *= sizeof(double);
    _608.data = jpl_alloc(_609);
    int64_t _610 = 0; // k
    int64_t _611 = 0; // j
    int64_t _612 = 0; // i
    _jump332:; // Begin body of loop
    double _613 = 50.0;
    int64_t _614 = 0;
    _614 *= _608.d0;
    _614 += _612;
    _614 *= _608.d1;
    _614 += _611;
    _614 *= _608.d2;
    _614 += _610;
    _608.data[_614] = _613;
    _610++;
    if (_610 < _402)
    goto _jump332;
    _610 = 0;
    _611++;
    if (_611 < _605)
    goto _jump332;
    _611 = 0;
    _612++;
    if (_612 < _402)
    goto _jump332;
    // End body of loop
    if (_606 >= 0)
    goto _jump333;
    fail_assertion("negative array index");
    _jump333:;
    if (_606 < _608.d0)
    goto _jump334;
    fail_assertion("index too large");
    _jump334:;
    if (_605 >= 0)
    goto _jump335;
    fail_assertion("negative array index");
    _jump335:;
    if (_605 < _608.d1)
    goto _jump336;
    fail_assertion("index too large");
    _jump336:;
    if (_607 >= 0)
    goto _jump337;
    fail_assertion("negative array index");
    _jump337:;
    if (_607 < _608.d2)
    goto _jump338;
    fail_assertion("index too large");
    _jump338:;
    int64_t _615 = 0;
    _615 *= _608.d0;
    _615 += _606;
    _615 *= _608.d1;
    _615 += _605;
    _615 *= _608.d2;
    _615 += _607;
    double _616 = _608.data[_615];
    double _617 = 48.0;
    double _618 = -_617;
    bool _619 = _616 == _618;
    int64_t _620;
    if (!_619)
    goto _jump339;
    int64_t _621 = _607 + _607;
    _620 = _621;
    goto _jump340;
    _jump339:;
    _620 = _605;
    _jump340:;
    int64_t _622 = _620 - _402;
    _553 += _622;
    _605++;
    if (_605 < _604)
    goto _jump328;
    _605 = 0;
    _606++;
    if (_606 < _402)
    goto _jump328;
    _606 = 0;
    _607++;
    if (_607 < _586)
    goto _jump328;
    // End body of loop
    _552.d0 = _553;
    if (_553 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    // Computing bound for g
    int64_t _623 = 930;
    int64_t _624 = -_623;
    int64_t _625 = -_624;
    int64_t _626 = -_625;
    int64_t _627 = -_626;
    _552.d1 = _627;
    if (_627 > 0) 
    goto _jump342;
    fail_assertion("non-positive loop bound");
    _jump342:;
    // Computing bound for h
    bool _628 = false;
    bool _629 = !_628;
    int64_t _630;
    if (!_629)
    goto _jump343;
    int64_t _631;
    // Computing bound for f
    int64_t _632 = 77;
    int64_t _633 = _402 % _632;
    if (_633 > 0) 
    goto _jump344;
    fail_assertion("non-positive loop bound");
    _jump344:;
    // Computing bound for g
    int64_t _634;
    // Computing bound for f
    int64_t _635 = 196;
    if (_635 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    // Computing bound for g
    int64_t _636 = 385;
    if (_636 > 0) 
    goto _jump346;
    fail_assertion("non-positive loop bound");
    _jump346:;
    _634 = 0;
    int64_t _637 = 0; // g
    int64_t _638 = 0; // f
    _jump347:; // Begin body of loop
    _634 += _402;
    _637++;
    if (_637 < _636)
    goto _jump347;
    _637 = 0;
    _638++;
    if (_638 < _635)
    goto _jump347;
    // End body of loop
    int64_t _639 = 665;
    int64_t _640 = -_639;
    int64_t _641;
    // Computing bound for f
    int64_t _642 = 825;
    if (_642 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    _641 = 0;
    int64_t _643 = 0; // f
    _jump349:; // Begin body of loop
    int64_t _644 = 978;
    _641 += _644;
    _643++;
    if (_643 < _642)
    goto _jump349;
    // End body of loop
    int64_t _645 = _640 + _641;
    int64_t _646 = _634 % _645;
    bool _647 = false;
    bool _648 = !_647;
    int64_t _649;
    if (!_648)
    goto _jump350;
    int64_t _650;
    // Computing bound for f
    if (_402 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing bound for g
    int64_t _651 = 396;
    if (_651 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    _650 = 0;
    int64_t _652 = 0; // g
    int64_t _653 = 0; // f
    _jump353:; // Begin body of loop
    _650 += _652;
    _652++;
    if (_652 < _651)
    goto _jump353;
    _652 = 0;
    _653++;
    if (_653 < _402)
    goto _jump353;
    // End body of loop
    int64_t _654 = -_650;
    _649 = _654;
    goto _jump354;
    _jump350:;
    int64_t _655;
    // Computing bound for f
    int64_t _656 = 505;
    int64_t _657 = _656 * _402;
    if (_657 > 0) 
    goto _jump355;
    fail_assertion("non-positive loop bound");
    _jump355:;
    // Computing bound for g
    int64_t _658 = _402 % _402;
    if (_658 > 0) 
    goto _jump356;
    fail_assertion("non-positive loop bound");
    _jump356:;
    // Computing bound for h
    int64_t _659;
    // Computing bound for f
    int64_t _660 = 29;
    if (_660 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump358;
    fail_assertion("non-positive loop bound");
    _jump358:;
    _659 = 0;
    int64_t _661 = 0; // g
    int64_t _662 = 0; // f
    _jump359:; // Begin body of loop
    _659 += _662;
    _661++;
    if (_661 < _402)
    goto _jump359;
    _661 = 0;
    _662++;
    if (_662 < _660)
    goto _jump359;
    // End body of loop
    if (_659 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    _655 = 0;
    int64_t _663 = 0; // h
    int64_t _664 = 0; // g
    int64_t _665 = 0; // f
    _jump361:; // Begin body of loop
    int64_t _666 = _664 / _664;
    _655 += _666;
    _663++;
    if (_663 < _659)
    goto _jump361;
    _663 = 0;
    _664++;
    if (_664 < _658)
    goto _jump361;
    _664 = 0;
    _665++;
    if (_665 < _657)
    goto _jump361;
    // End body of loop
    _649 = _655;
    _jump354:;
    int64_t _667 = _646 * _649;
    if (_667 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    _631 = 0;
    int64_t _668 = 0; // g
    int64_t _669 = 0; // f
    _jump363:; // Begin body of loop
    int64_t _670;
    // Computing bound for h
    bool _671 = true;
    int64_t _672;
    if (!_671)
    goto _jump364;
    _672 = _668;
    goto _jump365;
    _jump364:;
    int64_t _673;
    // Computing bound for h
    int64_t _674 = 744;
    if (_674 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing bound for i
    bool _675 = true;
    int64_t _676;
    if (!_675)
    goto _jump367;
    _676 = _669;
    goto _jump368;
    _jump367:;
    _676 = _668;
    _jump368:;
    if (_676 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    // Computing bound for j
    if (_669 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    _673 = 0;
    int64_t _677 = 0; // j
    int64_t _678 = 0; // i
    int64_t _679 = 0; // h
    _jump371:; // Begin body of loop
    _673 += _669;
    _677++;
    if (_677 < _669)
    goto _jump371;
    _677 = 0;
    _678++;
    if (_678 < _676)
    goto _jump371;
    _678 = 0;
    _679++;
    if (_679 < _674)
    goto _jump371;
    // End body of loop
    _672 = _673;
    _jump365:;
    if (_672 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    // Computing bound for i
    int64_t _680;
    if (!_551)
    goto _jump373;
    _680 = _402;
    goto _jump374;
    _jump373:;
    _680 = _402;
    _jump374:;
    if (_680 > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    _670 = 0;
    int64_t _681 = 0; // i
    int64_t _682 = 0; // h
    _jump376:; // Begin body of loop
    int64_t _683 = 643;
    int64_t _684 = -_683;
    int64_t _685 = _668 / _684;
    _670 += _685;
    _681++;
    if (_681 < _680)
    goto _jump376;
    _681 = 0;
    _682++;
    if (_682 < _672)
    goto _jump376;
    // End body of loop
    _631 += _670;
    _668++;
    if (_668 < _667)
    goto _jump363;
    _668 = 0;
    _669++;
    if (_669 < _633)
    goto _jump363;
    // End body of loop
    _630 = _631;
    goto _jump377;
    _jump343:;
    _630 = _402;
    _jump377:;
    _552.d2 = _630;
    if (_630 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing total size of heap memory to allocate
    int64_t _686 = 1;
    _686 *= _553;
    _686 *= _627;
    _686 *= _630;
    _686 *= sizeof(rgba);
    _552.data = jpl_alloc(_686);
    int64_t _687 = 0; // h
    int64_t _688 = 0; // g
    int64_t _689 = 0; // f
    _jump379:; // Begin body of loop
    double _690 = a(b);
    _a2_rgba _691;
    // Computing bound for i
    int64_t _692;
    // Computing bound for i
    if (_687 >= 0)
    goto _jump380;
    fail_assertion("negative array index");
    _jump380:;
    if (_687 < _0.d0)
    goto _jump381;
    fail_assertion("index too large");
    _jump381:;
    if (_689 >= 0)
    goto _jump382;
    fail_assertion("negative array index");
    _jump382:;
    if (_689 < _0.d1)
    goto _jump383;
    fail_assertion("index too large");
    _jump383:;
    if (_687 >= 0)
    goto _jump384;
    fail_assertion("negative array index");
    _jump384:;
    if (_687 < _0.d2)
    goto _jump385;
    fail_assertion("index too large");
    _jump385:;
    int64_t _693 = 0;
    _693 *= _0.d0;
    _693 += _687;
    _693 *= _0.d1;
    _693 += _689;
    _693 *= _0.d2;
    _693 += _687;
    int64_t _694 = _0.data[_693];
    if (_694 > 0) 
    goto _jump386;
    fail_assertion("non-positive loop bound");
    _jump386:;
    _692 = 0;
    int64_t _695 = 0; // i
    _jump387:; // Begin body of loop
    bool _696 = false;
    int64_t _697;
    if (!_696)
    goto _jump388;
    _697 = _688;
    goto _jump389;
    _jump388:;
    int64_t _698 = 446;
    _697 = _698;
    _jump389:;
    _692 += _697;
    _695++;
    if (_695 < _694)
    goto _jump387;
    // End body of loop
    _691.d0 = _692;
    if (_692 > 0) 
    goto _jump390;
    fail_assertion("non-positive loop bound");
    _jump390:;
    // Computing bound for j
    _a1_int64_t _699;
    // Computing bound for i
    _699.d0 = _689;
    if (_689 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing total size of heap memory to allocate
    int64_t _700 = 1;
    _700 *= _689;
    _700 *= sizeof(int64_t);
    _699.data = jpl_alloc(_700);
    int64_t _701 = 0; // i
    _jump392:; // Begin body of loop
    int64_t _702 = 0;
    _702 *= _699.d0;
    _702 += _701;
    _699.data[_702] = _402;
    _701++;
    if (_701 < _689)
    goto _jump392;
    // End body of loop
    if (_689 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_689 < _699.d0)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    int64_t _703 = 0;
    _703 *= _699.d0;
    _703 += _689;
    int64_t _704 = _699.data[_703];
    _691.d1 = _704;
    if (_704 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    // Computing total size of heap memory to allocate
    int64_t _705 = 1;
    _705 *= _692;
    _705 *= _704;
    _705 *= sizeof(rgba);
    _691.data = jpl_alloc(_705);
    int64_t _706 = 0; // j
    int64_t _707 = 0; // i
    _jump396:; // Begin body of loop
    int64_t _708 = 0;
    _708 *= _691.d0;
    _708 += _707;
    _708 *= _691.d1;
    _708 += _706;
    _691.data[_708] = b;
    _706++;
    if (_706 < _704)
    goto _jump396;
    _706 = 0;
    _707++;
    if (_707 < _692)
    goto _jump396;
    // End body of loop
    int64_t _709 = -_689;
    int64_t _710 = _688 % _709;
    int64_t _711 = 977;
    int64_t _712 = _711 + _402;
    int64_t _713 = _712 * _402;
    int64_t _714 = _710 - _713;
    double _715 = 12.0;
    double _716;
    // Computing bound for i
    int64_t _717 = 275;
    if (_717 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    _716 = 0;
    int64_t _718 = 0; // i
    _jump398:; // Begin body of loop
    double _719 = 7.0;
    _716 += _719;
    _718++;
    if (_718 < _717)
    goto _jump398;
    // End body of loop
    bool _720 = _715 <= _716;
    int64_t _721;
    if (!_720)
    goto _jump399;
    int64_t _722;
    // Computing bound for i
    int64_t _723 = 347;
    if (_723 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    _722 = 0;
    int64_t _724 = 0; // i
    _jump401:; // Begin body of loop
    _722 += _688;
    _724++;
    if (_724 < _723)
    goto _jump401;
    // End body of loop
    _721 = _722;
    goto _jump402;
    _jump399:;
    _a2_int64_t _725;
    // Computing bound for i
    _725.d0 = _402;
    if (_402 > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    // Computing bound for j
    _725.d1 = _689;
    if (_689 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    // Computing total size of heap memory to allocate
    int64_t _726 = 1;
    _726 *= _402;
    _726 *= _689;
    _726 *= sizeof(int64_t);
    _725.data = jpl_alloc(_726);
    int64_t _727 = 0; // j
    int64_t _728 = 0; // i
    _jump405:; // Begin body of loop
    int64_t _729 = 0;
    _729 *= _725.d0;
    _729 += _728;
    _729 *= _725.d1;
    _729 += _727;
    _725.data[_729] = _728;
    _727++;
    if (_727 < _689)
    goto _jump405;
    _727 = 0;
    _728++;
    if (_728 < _402)
    goto _jump405;
    // End body of loop
    if (_688 >= 0)
    goto _jump406;
    fail_assertion("negative array index");
    _jump406:;
    if (_688 < _725.d0)
    goto _jump407;
    fail_assertion("index too large");
    _jump407:;
    if (_402 >= 0)
    goto _jump408;
    fail_assertion("negative array index");
    _jump408:;
    if (_402 < _725.d1)
    goto _jump409;
    fail_assertion("index too large");
    _jump409:;
    int64_t _730 = 0;
    _730 *= _725.d0;
    _730 += _688;
    _730 *= _725.d1;
    _730 += _402;
    int64_t _731 = _725.data[_730];
    _721 = _731;
    _jump402:;
    if (_714 >= 0)
    goto _jump410;
    fail_assertion("negative array index");
    _jump410:;
    if (_714 < _691.d0)
    goto _jump411;
    fail_assertion("index too large");
    _jump411:;
    if (_721 >= 0)
    goto _jump412;
    fail_assertion("negative array index");
    _jump412:;
    if (_721 < _691.d1)
    goto _jump413;
    fail_assertion("index too large");
    _jump413:;
    int64_t _732 = 0;
    _732 *= _691.d0;
    _732 += _714;
    _732 *= _691.d1;
    _732 += _721;
    rgba _733 = _691.data[_732];
    double _734 = a(_733);
    double _735 = a(b);
    double _736;
    // Computing bound for i
    if (_402 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    // Computing bound for j
    if (_687 > 0) 
    goto _jump415;
    fail_assertion("non-positive loop bound");
    _jump415:;
    // Computing bound for k
    if (_687 > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    _736 = 0;
    int64_t _737 = 0; // k
    int64_t _738 = 0; // j
    int64_t _739 = 0; // i
    _jump417:; // Begin body of loop
    double _740 = b.b;
    _736 += _740;
    _737++;
    if (_737 < _687)
    goto _jump417;
    _737 = 0;
    _738++;
    if (_738 < _687)
    goto _jump417;
    _738 = 0;
    _739++;
    if (_739 < _402)
    goto _jump417;
    // End body of loop
    double _741 = a(b);
    double _742;
    // Computing bound for i
    int64_t _743 = -_402;
    if (_743 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    _742 = 0;
    int64_t _744 = 0; // i
    _jump419:; // Begin body of loop
    double _745 = b.r;
    _742 += _745;
    _744++;
    if (_744 < _743)
    goto _jump419;
    // End body of loop
    rgba _746 = { _735, _736, _741, _742 };
    double _747 = _746.g;
    double _748 = -_747;
    double _749;
    // Computing bound for i
    int64_t _750 = _402 % _402;
    int64_t _751 = -_750;
    if (_751 > 0) 
    goto _jump420;
    fail_assertion("non-positive loop bound");
    _jump420:;
    // Computing bound for j
    bool _752 = _551;
    if (0 == _551)
    goto _jump421;
    bool _753 = true;
    _752 = _753;
    _jump421:;
    int64_t _754;
    if (!_752)
    goto _jump422;
    _754 = _402;
    goto _jump423;
    _jump422:;
    _754 = _402;
    _jump423:;
    bool _755 = !_551;
    _a3_int64_t _756;
    if (!_755)
    goto _jump424;
    _a3_int64_t _757;
    // Computing bound for i
    _757.d0 = _687;
    if (_687 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing bound for j
    _757.d1 = _689;
    if (_689 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    // Computing bound for k
    _757.d2 = _687;
    if (_687 > 0) 
    goto _jump427;
    fail_assertion("non-positive loop bound");
    _jump427:;
    // Computing total size of heap memory to allocate
    int64_t _758 = 1;
    _758 *= _687;
    _758 *= _689;
    _758 *= _687;
    _758 *= sizeof(int64_t);
    _757.data = jpl_alloc(_758);
    int64_t _759 = 0; // k
    int64_t _760 = 0; // j
    int64_t _761 = 0; // i
    _jump428:; // Begin body of loop
    int64_t _762 = 0;
    _762 *= _757.d0;
    _762 += _761;
    _762 *= _757.d1;
    _762 += _760;
    _762 *= _757.d2;
    _762 += _759;
    _757.data[_762] = _761;
    _759++;
    if (_759 < _687)
    goto _jump428;
    _759 = 0;
    _760++;
    if (_760 < _689)
    goto _jump428;
    _760 = 0;
    _761++;
    if (_761 < _687)
    goto _jump428;
    // End body of loop
    _756 = _757;
    goto _jump429;
    _jump424:;
    _756 = _0;
    _jump429:;
    int64_t _763 = -_688;
    int64_t _764 = 229;
    int64_t _765 = _402 % _402;
    int64_t _766 = _764 + _765;
    int64_t _767 = -_688;
    int64_t _768 = -_767;
    if (_763 >= 0)
    goto _jump430;
    fail_assertion("negative array index");
    _jump430:;
    if (_763 < _756.d0)
    goto _jump431;
    fail_assertion("index too large");
    _jump431:;
    if (_766 >= 0)
    goto _jump432;
    fail_assertion("negative array index");
    _jump432:;
    if (_766 < _756.d1)
    goto _jump433;
    fail_assertion("index too large");
    _jump433:;
    if (_768 >= 0)
    goto _jump434;
    fail_assertion("negative array index");
    _jump434:;
    if (_768 < _756.d2)
    goto _jump435;
    fail_assertion("index too large");
    _jump435:;
    int64_t _769 = 0;
    _769 *= _756.d0;
    _769 += _763;
    _769 *= _756.d1;
    _769 += _766;
    _769 *= _756.d2;
    _769 += _768;
    int64_t _770 = _756.data[_769];
    int64_t _771 = _754 * _770;
    if (_771 > 0) 
    goto _jump436;
    fail_assertion("non-positive loop bound");
    _jump436:;
    _749 = 0;
    int64_t _772 = 0; // j
    int64_t _773 = 0; // i
    _jump437:; // Begin body of loop
    double _774;
    // Computing bound for k
    if (_773 > 0) 
    goto _jump438;
    fail_assertion("non-positive loop bound");
    _jump438:;
    _774 = 0;
    int64_t _775 = 0; // k
    _jump439:; // Begin body of loop
    double _776;
    // Computing bound for l
    if (_688 > 0) 
    goto _jump440;
    fail_assertion("non-positive loop bound");
    _jump440:;
    // Computing bound for m
    int64_t _777 = 476;
    if (_777 > 0) 
    goto _jump441;
    fail_assertion("non-positive loop bound");
    _jump441:;
    // Computing bound for n
    int64_t _778 = _689 - _687;
    if (_778 > 0) 
    goto _jump442;
    fail_assertion("non-positive loop bound");
    _jump442:;
    _776 = 0;
    int64_t _779 = 0; // n
    int64_t _780 = 0; // m
    int64_t _781 = 0; // l
    _jump443:; // Begin body of loop
    double _782;
    if (!_551)
    goto _jump444;
    double _783 = 3.0;
    _782 = _783;
    goto _jump445;
    _jump444:;
    double _784 = 79.0;
    double _785 = -_784;
    _782 = _785;
    _jump445:;
    _776 += _782;
    _779++;
    if (_779 < _778)
    goto _jump443;
    _779 = 0;
    _780++;
    if (_780 < _777)
    goto _jump443;
    _780 = 0;
    _781++;
    if (_781 < _688)
    goto _jump443;
    // End body of loop
    _774 += _776;
    _775++;
    if (_775 < _773)
    goto _jump439;
    // End body of loop
    _749 += _774;
    _772++;
    if (_772 < _771)
    goto _jump437;
    _772 = 0;
    _773++;
    if (_773 < _751)
    goto _jump437;
    // End body of loop
    rgba _786 = { _690, _734, _748, _749 };
    int64_t _787 = 0;
    _787 *= _552.d0;
    _787 += _689;
    _787 *= _552.d1;
    _787 += _688;
    _787 *= _552.d2;
    _787 += _687;
    _552.data[_787] = _786;
    _687++;
    if (_687 < _630)
    goto _jump379;
    _687 = 0;
    _688++;
    if (_688 < _627)
    goto _jump379;
    _688 = 0;
    _689++;
    if (_689 < _553)
    goto _jump379;
    // End body of loop
    rgba _788;
    if (!_551)
    goto _jump446;
    _a1_rgba _789;
    // Computing bound for g
    int64_t _790;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    _790 = 0;
    int64_t _791 = 0; // g
    _jump448:; // Begin body of loop
    _790 += _791;
    _791++;
    if (_791 < _402)
    goto _jump448;
    // End body of loop
    _789.d0 = _790;
    if (_790 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing total size of heap memory to allocate
    int64_t _792 = 1;
    _792 *= _790;
    _792 *= sizeof(rgba);
    _789.data = jpl_alloc(_792);
    int64_t _793 = 0; // g
    _jump450:; // Begin body of loop
    int64_t _794 = 0;
    _794 *= _789.d0;
    _794 += _793;
    _789.data[_794] = b;
    _793++;
    if (_793 < _790)
    goto _jump450;
    // End body of loop
    int64_t _795 = 644;
    int64_t _796 = -_795;
    if (_796 >= 0)
    goto _jump451;
    fail_assertion("negative array index");
    _jump451:;
    if (_796 < _789.d0)
    goto _jump452;
    fail_assertion("index too large");
    _jump452:;
    int64_t _797 = 0;
    _797 *= _789.d0;
    _797 += _796;
    rgba _798 = _789.data[_797];
    double _799 = 10.0;
    double _800 = 75.0;
    double _801 = -_800;
    double _802 = 51.0;
    double _803 = -_802;
    bool _804 = true;
    rgba _805;
    if (!_804)
    goto _jump453;
    _805 = b;
    goto _jump454;
    _jump453:;
    _805 = b;
    _jump454:;
    double _806 = a(_805);
    rgba _807 = { _799, _801, _803, _806 };
    _a1_rgba _808;
    _808.d0 = 2;
    _808.data = jpl_alloc(sizeof(rgba) * 2);
    _808.data[0] = _798;
    _808.data[1] = _807;
    int64_t _809 = 846;
    if (_809 >= 0)
    goto _jump455;
    fail_assertion("negative array index");
    _jump455:;
    if (_809 < _808.d0)
    goto _jump456;
    fail_assertion("index too large");
    _jump456:;
    int64_t _810 = 0;
    _810 *= _808.d0;
    _810 += _809;
    rgba _811 = _808.data[_810];
    _788 = _811;
    goto _jump457;
    _jump446:;
    bool _813 = _551;
    if (0 == _551)
    goto _jump458;
    _813 = _551;
    _jump458:;
    bool _812 = _813;
    if (0 == _813)
    goto _jump459;
    int64_t _814 = 983;
    bool _815 = _402 == _814;
    _812 = _815;
    _jump459:;
    rgba _816;
    if (!_812)
    goto _jump460;
    double _817 = 26.0;
    double _818 = b.b;
    double _819 = -_818;
    double _820 = -_819;
    double _821;
    if (!_551)
    goto _jump461;
    double _822 = 39.0;
    double _823 = 52.0;
    bool _824 = _822 == _823;
    double _825;
    if (!_824)
    goto _jump462;
    double _826 = 50.0;
    _825 = _826;
    goto _jump463;
    _jump462:;
    double _827 = 71.0;
    _825 = _827;
    _jump463:;
    _821 = _825;
    goto _jump464;
    _jump461:;
    bool _828 = true;
    rgba _829;
    if (!_828)
    goto _jump465;
    _829 = b;
    goto _jump466;
    _jump465:;
    _829 = b;
    _jump466:;
    double _830 = a(_829);
    _821 = _830;
    _jump464:;
    double _831 = b.a;
    double _832 = -_831;
    double _833 = -_832;
    rgba _834 = { _817, _820, _821, _833 };
    _816 = _834;
    goto _jump467;
    _jump460:;
    _a2__a2_rgba _835;
    // Computing bound for g
    int64_t _836 = 657;
    _835.d0 = _836;
    if (_836 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for h
    int64_t _837;
    // Computing bound for g
    int64_t _838 = 966;
    if (_838 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    _837 = 0;
    int64_t _839 = 0; // g
    _jump470:; // Begin body of loop
    _837 += _402;
    _839++;
    if (_839 < _838)
    goto _jump470;
    // End body of loop
    _835.d1 = _837;
    if (_837 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing total size of heap memory to allocate
    int64_t _840 = 1;
    _840 *= _836;
    _840 *= _837;
    _840 *= sizeof(_a2_rgba);
    _835.data = jpl_alloc(_840);
    int64_t _841 = 0; // h
    int64_t _842 = 0; // g
    _jump472:; // Begin body of loop
    _a2_rgba _843;
    // Computing bound for i
    int64_t _844 = 259;
    _843.d0 = _844;
    if (_844 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing bound for j
    _843.d1 = _842;
    if (_842 > 0) 
    goto _jump474;
    fail_assertion("non-positive loop bound");
    _jump474:;
    // Computing total size of heap memory to allocate
    int64_t _845 = 1;
    _845 *= _844;
    _845 *= _842;
    _845 *= sizeof(rgba);
    _843.data = jpl_alloc(_845);
    int64_t _846 = 0; // j
    int64_t _847 = 0; // i
    _jump475:; // Begin body of loop
    int64_t _848 = 0;
    _848 *= _843.d0;
    _848 += _847;
    _848 *= _843.d1;
    _848 += _846;
    _843.data[_848] = b;
    _846++;
    if (_846 < _842)
    goto _jump475;
    _846 = 0;
    _847++;
    if (_847 < _844)
    goto _jump475;
    // End body of loop
    int64_t _849 = 0;
    _849 *= _835.d0;
    _849 += _842;
    _849 *= _835.d1;
    _849 += _841;
    _835.data[_849] = _843;
    _841++;
    if (_841 < _837)
    goto _jump472;
    _841 = 0;
    _842++;
    if (_842 < _836)
    goto _jump472;
    // End body of loop
    _a1_int64_t _850;
    // Computing bound for g
    _850.d0 = _402;
    if (_402 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing total size of heap memory to allocate
    int64_t _851 = 1;
    _851 *= _402;
    _851 *= sizeof(int64_t);
    _850.data = jpl_alloc(_851);
    int64_t _852 = 0; // g
    _jump477:; // Begin body of loop
    int64_t _853 = 0;
    _853 *= _850.d0;
    _853 += _852;
    _850.data[_853] = _852;
    _852++;
    if (_852 < _402)
    goto _jump477;
    // End body of loop
    if (_402 >= 0)
    goto _jump478;
    fail_assertion("negative array index");
    _jump478:;
    if (_402 < _850.d0)
    goto _jump479;
    fail_assertion("index too large");
    _jump479:;
    int64_t _854 = 0;
    _854 *= _850.d0;
    _854 += _402;
    int64_t _855 = _850.data[_854];
    if (_402 >= 0)
    goto _jump480;
    fail_assertion("negative array index");
    _jump480:;
    if (_402 < _835.d0)
    goto _jump481;
    fail_assertion("index too large");
    _jump481:;
    if (_855 >= 0)
    goto _jump482;
    fail_assertion("negative array index");
    _jump482:;
    if (_855 < _835.d1)
    goto _jump483;
    fail_assertion("index too large");
    _jump483:;
    int64_t _856 = 0;
    _856 *= _835.d0;
    _856 += _402;
    _856 *= _835.d1;
    _856 += _855;
    _a2_rgba _857 = _835.data[_856];
    int64_t _858;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump484;
    fail_assertion("non-positive loop bound");
    _jump484:;
    // Computing bound for h
    int64_t _859 = -_402;
    if (_859 > 0) 
    goto _jump485;
    fail_assertion("non-positive loop bound");
    _jump485:;
    _858 = 0;
    int64_t _860 = 0; // h
    int64_t _861 = 0; // g
    _jump486:; // Begin body of loop
    _858 += _402;
    _860++;
    if (_860 < _859)
    goto _jump486;
    _860 = 0;
    _861++;
    if (_861 < _402)
    goto _jump486;
    // End body of loop
    int64_t _862;
    // Computing bound for g
    int64_t _863 = -_402;
    if (_863 > 0) 
    goto _jump487;
    fail_assertion("non-positive loop bound");
    _jump487:;
    _862 = 0;
    int64_t _864 = 0; // g
    _jump488:; // Begin body of loop
    int64_t _865 = -_402;
    _862 += _865;
    _864++;
    if (_864 < _863)
    goto _jump488;
    // End body of loop
    int64_t _866 = _858 % _862;
    int64_t _867;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump489;
    fail_assertion("non-positive loop bound");
    _jump489:;
    _867 = 0;
    int64_t _868 = 0; // g
    _jump490:; // Begin body of loop
    int64_t _869 = 62;
    _867 += _869;
    _868++;
    if (_868 < _402)
    goto _jump490;
    // End body of loop
    if (_866 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_866 < _857.d0)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_867 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_867 < _857.d1)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    int64_t _870 = 0;
    _870 *= _857.d0;
    _870 += _866;
    _870 *= _857.d1;
    _870 += _867;
    rgba _871 = _857.data[_870];
    _816 = _871;
    _jump467:;
    _788 = _816;
    _jump457:;
    double _872 = _788.a;
    return _872;
    bool _873 = false;
    _a1_bool _874;
    // Computing bound for g
    _874.d0 = _402;
    if (_402 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    // Computing total size of heap memory to allocate
    int64_t _875 = 1;
    _875 *= _402;
    _875 *= sizeof(bool);
    _874.data = jpl_alloc(_875);
    int64_t _876 = 0; // g
    _jump496:; // Begin body of loop
    int64_t _877 = 0;
    _877 *= _874.d0;
    _877 += _876;
    _874.data[_877] = _551;
    _876++;
    if (_876 < _402)
    goto _jump496;
    // End body of loop
    int64_t _878 = _402 * _402;
    if (_878 >= 0)
    goto _jump497;
    fail_assertion("negative array index");
    _jump497:;
    if (_878 < _874.d0)
    goto _jump498;
    fail_assertion("index too large");
    _jump498:;
    int64_t _879 = 0;
    _879 *= _874.d0;
    _879 += _878;
    bool _880 = _874.data[_879];
    bool _881 = false;
    _a1_bool _882;
    _882.d0 = 3;
    _882.data = jpl_alloc(sizeof(bool) * 3);
    _882.data[0] = _873;
    _882.data[1] = _880;
    _882.data[2] = _881;
    if (_402 >= 0)
    goto _jump499;
    fail_assertion("negative array index");
    _jump499:;
    if (_402 < _882.d0)
    goto _jump500;
    fail_assertion("index too large");
    _jump500:;
    int64_t _883 = 0;
    _883 *= _882.d0;
    _883 += _402;
    bool _884 = _882.data[_883];
    bool _885 = !_884;
    _a2__a1_int64_t _886;
    if (!_885)
    goto _jump501;
    bool _887 = true;
    _a2__a1_int64_t _888;
    if (!_887)
    goto _jump502;
    _a2__a2__a1_int64_t _889;
    // Computing bound for g
    _889.d0 = _402;
    if (_402 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing bound for h
    int64_t _890 = 961;
    _889.d1 = _890;
    if (_890 > 0) 
    goto _jump504;
    fail_assertion("non-positive loop bound");
    _jump504:;
    // Computing total size of heap memory to allocate
    int64_t _891 = 1;
    _891 *= _402;
    _891 *= _890;
    _891 *= sizeof(_a2__a1_int64_t);
    _889.data = jpl_alloc(_891);
    int64_t _892 = 0; // h
    int64_t _893 = 0; // g
    _jump505:; // Begin body of loop
    _a2__a1_int64_t _894;
    // Computing bound for i
    int64_t _895 = 597;
    _894.d0 = _895;
    if (_895 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for j
    _894.d1 = _893;
    if (_893 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing total size of heap memory to allocate
    int64_t _896 = 1;
    _896 *= _895;
    _896 *= _893;
    _896 *= sizeof(_a1_int64_t);
    _894.data = jpl_alloc(_896);
    int64_t _897 = 0; // j
    int64_t _898 = 0; // i
    _jump508:; // Begin body of loop
    int64_t _899 = 846;
    _a1_int64_t _900;
    _900.d0 = 1;
    _900.data = jpl_alloc(sizeof(int64_t) * 1);
    _900.data[0] = _899;
    int64_t _901 = 0;
    _901 *= _894.d0;
    _901 += _898;
    _901 *= _894.d1;
    _901 += _897;
    _894.data[_901] = _900;
    _897++;
    if (_897 < _893)
    goto _jump508;
    _897 = 0;
    _898++;
    if (_898 < _895)
    goto _jump508;
    // End body of loop
    int64_t _902 = 0;
    _902 *= _889.d0;
    _902 += _893;
    _902 *= _889.d1;
    _902 += _892;
    _889.data[_902] = _894;
    _892++;
    if (_892 < _890)
    goto _jump505;
    _892 = 0;
    _893++;
    if (_893 < _402)
    goto _jump505;
    // End body of loop
    int64_t _903 = _402 - _402;
    int64_t _904 = -_903;
    int64_t _905;
    if (!_551)
    goto _jump509;
    int64_t _906 = 790;
    _905 = _906;
    goto _jump510;
    _jump509:;
    _905 = _402;
    _jump510:;
    bool _907 = _402 != _905;
    int64_t _908;
    if (!_907)
    goto _jump511;
    int64_t _909;
    if (!_551)
    goto _jump512;
    int64_t _910 = 921;
    _909 = _910;
    goto _jump513;
    _jump512:;
    _909 = _402;
    _jump513:;
    _908 = _909;
    goto _jump514;
    _jump511:;
    _908 = _402;
    _jump514:;
    if (_904 >= 0)
    goto _jump515;
    fail_assertion("negative array index");
    _jump515:;
    if (_904 < _889.d0)
    goto _jump516;
    fail_assertion("index too large");
    _jump516:;
    if (_908 >= 0)
    goto _jump517;
    fail_assertion("negative array index");
    _jump517:;
    if (_908 < _889.d1)
    goto _jump518;
    fail_assertion("index too large");
    _jump518:;
    int64_t _911 = 0;
    _911 *= _889.d0;
    _911 += _904;
    _911 *= _889.d1;
    _911 += _908;
    _a2__a1_int64_t _912 = _889.data[_911];
    _888 = _912;
    goto _jump519;
    _jump502:;
    _a2__a1_int64_t _913;
    // Computing bound for g
    int64_t _914 = 780;
    _913.d0 = _914;
    if (_914 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing bound for h
    _a1__a3_int64_t _915;
    // Computing bound for g
    _915.d0 = _402;
    if (_402 > 0) 
    goto _jump521;
    fail_assertion("non-positive loop bound");
    _jump521:;
    // Computing total size of heap memory to allocate
    int64_t _916 = 1;
    _916 *= _402;
    _916 *= sizeof(_a3_int64_t);
    _915.data = jpl_alloc(_916);
    int64_t _917 = 0; // g
    _jump522:; // Begin body of loop
    int64_t _918 = 0;
    _918 *= _915.d0;
    _918 += _917;
    _915.data[_918] = _0;
    _917++;
    if (_917 < _402)
    goto _jump522;
    // End body of loop
    int64_t _919 = 104;
    if (_919 >= 0)
    goto _jump523;
    fail_assertion("negative array index");
    _jump523:;
    if (_919 < _915.d0)
    goto _jump524;
    fail_assertion("index too large");
    _jump524:;
    int64_t _920 = 0;
    _920 *= _915.d0;
    _920 += _919;
    _a3_int64_t _921 = _915.data[_920];
    int64_t _922;
    // Computing bound for g
    int64_t _923 = 801;
    if (_923 > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    _922 = 0;
    int64_t _924 = 0; // g
    _jump526:; // Begin body of loop
    _922 += _402;
    _924++;
    if (_924 < _923)
    goto _jump526;
    // End body of loop
    if (_922 >= 0)
    goto _jump527;
    fail_assertion("negative array index");
    _jump527:;
    if (_922 < _921.d0)
    goto _jump528;
    fail_assertion("index too large");
    _jump528:;
    if (_402 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (_402 < _921.d1)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    if (_402 >= 0)
    goto _jump531;
    fail_assertion("negative array index");
    _jump531:;
    if (_402 < _921.d2)
    goto _jump532;
    fail_assertion("index too large");
    _jump532:;
    int64_t _925 = 0;
    _925 *= _921.d0;
    _925 += _922;
    _925 *= _921.d1;
    _925 += _402;
    _925 *= _921.d2;
    _925 += _402;
    int64_t _926 = _921.data[_925];
    _913.d1 = _926;
    if (_926 > 0) 
    goto _jump533;
    fail_assertion("non-positive loop bound");
    _jump533:;
    // Computing total size of heap memory to allocate
    int64_t _927 = 1;
    _927 *= _914;
    _927 *= _926;
    _927 *= sizeof(_a1_int64_t);
    _913.data = jpl_alloc(_927);
    int64_t _928 = 0; // h
    int64_t _929 = 0; // g
    _jump534:; // Begin body of loop
    _a1__a1_int64_t _930;
    // Computing bound for i
    int64_t _931 = -_928;
    _930.d0 = _931;
    if (_931 > 0) 
    goto _jump535;
    fail_assertion("non-positive loop bound");
    _jump535:;
    // Computing total size of heap memory to allocate
    int64_t _932 = 1;
    _932 *= _931;
    _932 *= sizeof(_a1_int64_t);
    _930.data = jpl_alloc(_932);
    int64_t _933 = 0; // i
    _jump536:; // Begin body of loop
    int64_t _934 = 770;
    _a1_int64_t _935;
    _935.d0 = 2;
    _935.data = jpl_alloc(sizeof(int64_t) * 2);
    _935.data[0] = _934;
    _935.data[1] = _928;
    int64_t _936 = 0;
    _936 *= _930.d0;
    _936 += _933;
    _930.data[_936] = _935;
    _933++;
    if (_933 < _931)
    goto _jump536;
    // End body of loop
    int64_t _937 = -_402;
    if (_937 >= 0)
    goto _jump537;
    fail_assertion("negative array index");
    _jump537:;
    if (_937 < _930.d0)
    goto _jump538;
    fail_assertion("index too large");
    _jump538:;
    int64_t _938 = 0;
    _938 *= _930.d0;
    _938 += _937;
    _a1_int64_t _939 = _930.data[_938];
    int64_t _940 = 0;
    _940 *= _913.d0;
    _940 += _929;
    _940 *= _913.d1;
    _940 += _928;
    _913.data[_940] = _939;
    _928++;
    if (_928 < _926)
    goto _jump534;
    _928 = 0;
    _929++;
    if (_929 < _914)
    goto _jump534;
    // End body of loop
    _888 = _913;
    _jump519:;
    _886 = _888;
    goto _jump539;
    _jump501:;
    _a2__a2_bool _941;
    // Computing bound for g
    _941.d0 = _402;
    if (_402 > 0) 
    goto _jump540;
    fail_assertion("non-positive loop bound");
    _jump540:;
    // Computing bound for h
    int64_t _942;
    // Computing bound for g
    int64_t _943 = 881;
    if (_943 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing bound for h
    if (_402 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    // Computing bound for i
    int64_t _944 = 862;
    if (_944 > 0) 
    goto _jump543;
    fail_assertion("non-positive loop bound");
    _jump543:;
    _942 = 0;
    int64_t _945 = 0; // i
    int64_t _946 = 0; // h
    int64_t _947 = 0; // g
    _jump544:; // Begin body of loop
    _942 += _945;
    _945++;
    if (_945 < _944)
    goto _jump544;
    _945 = 0;
    _946++;
    if (_946 < _402)
    goto _jump544;
    _946 = 0;
    _947++;
    if (_947 < _943)
    goto _jump544;
    // End body of loop
    _941.d1 = _942;
    if (_942 > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    // Computing total size of heap memory to allocate
    int64_t _948 = 1;
    _948 *= _402;
    _948 *= _942;
    _948 *= sizeof(_a2_bool);
    _941.data = jpl_alloc(_948);
    int64_t _949 = 0; // h
    int64_t _950 = 0; // g
    _jump546:; // Begin body of loop
    _a2_bool _951;
    // Computing bound for i
    int64_t _952 = 85;
    _951.d0 = _952;
    if (_952 > 0) 
    goto _jump547;
    fail_assertion("non-positive loop bound");
    _jump547:;
    // Computing bound for j
    _951.d1 = _949;
    if (_949 > 0) 
    goto _jump548;
    fail_assertion("non-positive loop bound");
    _jump548:;
    // Computing total size of heap memory to allocate
    int64_t _953 = 1;
    _953 *= _952;
    _953 *= _949;
    _953 *= sizeof(bool);
    _951.data = jpl_alloc(_953);
    int64_t _954 = 0; // j
    int64_t _955 = 0; // i
    _jump549:; // Begin body of loop
    int64_t _956 = 0;
    _956 *= _951.d0;
    _956 += _955;
    _956 *= _951.d1;
    _956 += _954;
    _951.data[_956] = _551;
    _954++;
    if (_954 < _949)
    goto _jump549;
    _954 = 0;
    _955++;
    if (_955 < _952)
    goto _jump549;
    // End body of loop
    int64_t _957 = 0;
    _957 *= _941.d0;
    _957 += _950;
    _957 *= _941.d1;
    _957 += _949;
    _941.data[_957] = _951;
    _949++;
    if (_949 < _942)
    goto _jump546;
    _949 = 0;
    _950++;
    if (_950 < _402)
    goto _jump546;
    // End body of loop
    int64_t _958;
    // Computing bound for g
    int64_t _959;
    if (!_551)
    goto _jump550;
    _959 = _402;
    goto _jump551;
    _jump550:;
    _959 = _402;
    _jump551:;
    if (_959 > 0) 
    goto _jump552;
    fail_assertion("non-positive loop bound");
    _jump552:;
    // Computing bound for h
    if (_402 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    _958 = 0;
    int64_t _960 = 0; // h
    int64_t _961 = 0; // g
    _jump554:; // Begin body of loop
    int64_t _962 = 93;
    int64_t _963 = _962 - _402;
    _958 += _963;
    _960++;
    if (_960 < _402)
    goto _jump554;
    _960 = 0;
    _961++;
    if (_961 < _959)
    goto _jump554;
    // End body of loop
    if (_958 >= 0)
    goto _jump555;
    fail_assertion("negative array index");
    _jump555:;
    if (_958 < _941.d0)
    goto _jump556;
    fail_assertion("index too large");
    _jump556:;
    if (_402 >= 0)
    goto _jump557;
    fail_assertion("negative array index");
    _jump557:;
    if (_402 < _941.d1)
    goto _jump558;
    fail_assertion("index too large");
    _jump558:;
    int64_t _964 = 0;
    _964 *= _941.d0;
    _964 += _958;
    _964 *= _941.d1;
    _964 += _402;
    _a2_bool _965 = _941.data[_964];
    _a1_bool _966;
    // Computing bound for g
    int64_t _967 = 741;
    _966.d0 = _967;
    if (_967 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    // Computing total size of heap memory to allocate
    int64_t _968 = 1;
    _968 *= _967;
    _968 *= sizeof(bool);
    _966.data = jpl_alloc(_968);
    int64_t _969 = 0; // g
    _jump560:; // Begin body of loop
    int64_t _970 = 0;
    _970 *= _966.d0;
    _970 += _969;
    _966.data[_970] = _551;
    _969++;
    if (_969 < _967)
    goto _jump560;
    // End body of loop
    int64_t _971 = -_402;
    if (_971 >= 0)
    goto _jump561;
    fail_assertion("negative array index");
    _jump561:;
    if (_971 < _966.d0)
    goto _jump562;
    fail_assertion("index too large");
    _jump562:;
    int64_t _972 = 0;
    _972 *= _966.d0;
    _972 += _971;
    bool _973 = _966.data[_972];
    int64_t _974;
    if (!_973)
    goto _jump563;
    _974 = _402;
    goto _jump564;
    _jump563:;
    int64_t _975 = 37;
    _974 = _975;
    _jump564:;
    if (_974 >= 0)
    goto _jump565;
    fail_assertion("negative array index");
    _jump565:;
    if (_974 < _965.d0)
    goto _jump566;
    fail_assertion("index too large");
    _jump566:;
    if (_402 >= 0)
    goto _jump567;
    fail_assertion("negative array index");
    _jump567:;
    if (_402 < _965.d1)
    goto _jump568;
    fail_assertion("index too large");
    _jump568:;
    int64_t _976 = 0;
    _976 *= _965.d0;
    _976 += _974;
    _976 *= _965.d1;
    _976 += _402;
    bool _977 = _965.data[_976];
    _a2__a1_int64_t _978;
    if (!_977)
    goto _jump569;
    _a2__a1_int64_t _979;
    // Computing bound for g
    _979.d0 = _402;
    if (_402 > 0) 
    goto _jump570;
    fail_assertion("non-positive loop bound");
    _jump570:;
    // Computing bound for h
    _979.d1 = _402;
    if (_402 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _980 = 1;
    _980 *= _402;
    _980 *= _402;
    _980 *= sizeof(_a1_int64_t);
    _979.data = jpl_alloc(_980);
    int64_t _981 = 0; // h
    int64_t _982 = 0; // g
    _jump572:; // Begin body of loop
    int64_t _983 = 514;
    int64_t _984 = 617;
    _a1_int64_t _985;
    _985.d0 = 2;
    _985.data = jpl_alloc(sizeof(int64_t) * 2);
    _985.data[0] = _983;
    _985.data[1] = _984;
    int64_t _986 = 0;
    _986 *= _979.d0;
    _986 += _982;
    _986 *= _979.d1;
    _986 += _981;
    _979.data[_986] = _985;
    _981++;
    if (_981 < _402)
    goto _jump572;
    _981 = 0;
    _982++;
    if (_982 < _402)
    goto _jump572;
    // End body of loop
    _a2__a1_int64_t _987;
    // Computing bound for g
    int64_t _988 = 444;
    _987.d0 = _988;
    if (_988 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    // Computing bound for h
    int64_t _989 = 341;
    _987.d1 = _989;
    if (_989 > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing total size of heap memory to allocate
    int64_t _990 = 1;
    _990 *= _988;
    _990 *= _989;
    _990 *= sizeof(_a1_int64_t);
    _987.data = jpl_alloc(_990);
    int64_t _991 = 0; // h
    int64_t _992 = 0; // g
    _jump575:; // Begin body of loop
    int64_t _993 = 863;
    int64_t _994 = 317;
    _a1_int64_t _995;
    _995.d0 = 2;
    _995.data = jpl_alloc(sizeof(int64_t) * 2);
    _995.data[0] = _993;
    _995.data[1] = _994;
    int64_t _996 = 0;
    _996 *= _987.d0;
    _996 += _992;
    _996 *= _987.d1;
    _996 += _991;
    _987.data[_996] = _995;
    _991++;
    if (_991 < _989)
    goto _jump575;
    _991 = 0;
    _992++;
    if (_992 < _988)
    goto _jump575;
    // End body of loop
    _a1__a2__a1_int64_t _997;
    _997.d0 = 2;
    _997.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 2);
    _997.data[0] = _979;
    _997.data[1] = _987;
    int64_t _998;
    // Computing bound for g
    int64_t _999 = 759;
    if (_999 > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing bound for h
    if (_402 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing bound for i
    int64_t _1000;
    if (!_551)
    goto _jump578;
    int64_t _1001 = 791;
    int64_t _1002 = 832;
    int64_t _1003 = _1001 / _1002;
    _1000 = _1003;
    goto _jump579;
    _jump578:;
    _1000 = _402;
    _jump579:;
    if (_1000 > 0) 
    goto _jump580;
    fail_assertion("non-positive loop bound");
    _jump580:;
    _998 = 0;
    int64_t _1004 = 0; // i
    int64_t _1005 = 0; // h
    int64_t _1006 = 0; // g
    _jump581:; // Begin body of loop
    int64_t _1007;
    // Computing bound for j
    if (_1004 > 0) 
    goto _jump582;
    fail_assertion("non-positive loop bound");
    _jump582:;
    _1007 = 0;
    int64_t _1008 = 0; // j
    _jump583:; // Begin body of loop
    _1007 += _1005;
    _1008++;
    if (_1008 < _1004)
    goto _jump583;
    // End body of loop
    _998 += _1007;
    _1004++;
    if (_1004 < _1000)
    goto _jump581;
    _1004 = 0;
    _1005++;
    if (_1005 < _402)
    goto _jump581;
    _1005 = 0;
    _1006++;
    if (_1006 < _999)
    goto _jump581;
    // End body of loop
    if (_998 >= 0)
    goto _jump584;
    fail_assertion("negative array index");
    _jump584:;
    if (_998 < _997.d0)
    goto _jump585;
    fail_assertion("index too large");
    _jump585:;
    int64_t _1009 = 0;
    _1009 *= _997.d0;
    _1009 += _998;
    _a2__a1_int64_t _1010 = _997.data[_1009];
    _978 = _1010;
    goto _jump586;
    _jump569:;
    bool _1012 = true;
    bool _1011 = _1012;
    if (0 == _1012)
    goto _jump587;
    bool _1013 = true;
    _1011 = _1013;
    _jump587:;
    _a2__a1_int64_t _1014;
    if (!_1011)
    goto _jump588;
    _a2__a1_int64_t _1015;
    // Computing bound for g
    _1015.d0 = _402;
    if (_402 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing bound for h
    int64_t _1016;
    // Computing bound for g
    if (_402 > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing bound for h
    int64_t _1017;
    if (!_551)
    goto _jump591;
    _1017 = _402;
    goto _jump592;
    _jump591:;
    int64_t _1018 = 487;
    _1017 = _1018;
    _jump592:;
    if (_1017 > 0) 
    goto _jump593;
    fail_assertion("non-positive loop bound");
    _jump593:;
    // Computing bound for i
    if (_402 > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    _1016 = 0;
    int64_t _1019 = 0; // i
    int64_t _1020 = 0; // h
    int64_t _1021 = 0; // g
    _jump595:; // Begin body of loop
    _1016 += _1021;
    _1019++;
    if (_1019 < _402)
    goto _jump595;
    _1019 = 0;
    _1020++;
    if (_1020 < _1017)
    goto _jump595;
    _1020 = 0;
    _1021++;
    if (_1021 < _402)
    goto _jump595;
    // End body of loop
    _1015.d1 = _1016;
    if (_1016 > 0) 
    goto _jump596;
    fail_assertion("non-positive loop bound");
    _jump596:;
    // Computing total size of heap memory to allocate
    int64_t _1022 = 1;
    _1022 *= _402;
    _1022 *= _1016;
    _1022 *= sizeof(_a1_int64_t);
    _1015.data = jpl_alloc(_1022);
    int64_t _1023 = 0; // h
    int64_t _1024 = 0; // g
    _jump597:; // Begin body of loop
    bool _1025 = false;
    _a1_int64_t _1026;
    if (!_1025)
    goto _jump598;
    _a1_int64_t _1027;
    _1027.d0 = 3;
    _1027.data = jpl_alloc(sizeof(int64_t) * 3);
    _1027.data[0] = _1023;
    _1027.data[1] = _402;
    _1027.data[2] = _1024;
    _1026 = _1027;
    goto _jump599;
    _jump598:;
    _a1_int64_t _1028;
    _1028.d0 = 1;
    _1028.data = jpl_alloc(sizeof(int64_t) * 1);
    _1028.data[0] = _402;
    _1026 = _1028;
    _jump599:;
    int64_t _1029 = 0;
    _1029 *= _1015.d0;
    _1029 += _1024;
    _1029 *= _1015.d1;
    _1029 += _1023;
    _1015.data[_1029] = _1026;
    _1023++;
    if (_1023 < _1016)
    goto _jump597;
    _1023 = 0;
    _1024++;
    if (_1024 < _402)
    goto _jump597;
    // End body of loop
    _1014 = _1015;
    goto _jump600;
    _jump588:;
    bool _1030 = true;
    _a2__a1_int64_t _1031;
    if (!_1030)
    goto _jump601;
    _a2__a1_int64_t _1032;
    // Computing bound for g
    _1032.d0 = _402;
    if (_402 > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing bound for h
    int64_t _1033;
    // Computing bound for g
    int64_t _1034 = 5;
    if (_1034 > 0) 
    goto _jump603;
    fail_assertion("non-positive loop bound");
    _jump603:;
    _1033 = 0;
    int64_t _1035 = 0; // g
    _jump604:; // Begin body of loop
    _1033 += _402;
    _1035++;
    if (_1035 < _1034)
    goto _jump604;
    // End body of loop
    _1032.d1 = _1033;
    if (_1033 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing total size of heap memory to allocate
    int64_t _1036 = 1;
    _1036 *= _402;
    _1036 *= _1033;
    _1036 *= sizeof(_a1_int64_t);
    _1032.data = jpl_alloc(_1036);
    int64_t _1037 = 0; // h
    int64_t _1038 = 0; // g
    _jump606:; // Begin body of loop
    _a1_int64_t _1039;
    _1039.d0 = 1;
    _1039.data = jpl_alloc(sizeof(int64_t) * 1);
    _1039.data[0] = _1037;
    int64_t _1040 = 0;
    _1040 *= _1032.d0;
    _1040 += _1038;
    _1040 *= _1032.d1;
    _1040 += _1037;
    _1032.data[_1040] = _1039;
    _1037++;
    if (_1037 < _1033)
    goto _jump606;
    _1037 = 0;
    _1038++;
    if (_1038 < _402)
    goto _jump606;
    // End body of loop
    _1031 = _1032;
    goto _jump607;
    _jump601:;
    _a2__a1_int64_t _1041;
    // Computing bound for g
    int64_t _1042 = 650;
    int64_t _1043 = _402 - _1042;
    _1041.d0 = _1043;
    if (_1043 > 0) 
    goto _jump608;
    fail_assertion("non-positive loop bound");
    _jump608:;
    // Computing bound for h
    int64_t _1044 = 905;
    _1041.d1 = _1044;
    if (_1044 > 0) 
    goto _jump609;
    fail_assertion("non-positive loop bound");
    _jump609:;
    // Computing total size of heap memory to allocate
    int64_t _1045 = 1;
    _1045 *= _1043;
    _1045 *= _1044;
    _1045 *= sizeof(_a1_int64_t);
    _1041.data = jpl_alloc(_1045);
    int64_t _1046 = 0; // h
    int64_t _1047 = 0; // g
    _jump610:; // Begin body of loop
    _a1_int64_t _1048;
    _1048.d0 = 1;
    _1048.data = jpl_alloc(sizeof(int64_t) * 1);
    _1048.data[0] = _1047;
    int64_t _1049 = 0;
    _1049 *= _1041.d0;
    _1049 += _1047;
    _1049 *= _1041.d1;
    _1049 += _1046;
    _1041.data[_1049] = _1048;
    _1046++;
    if (_1046 < _1044)
    goto _jump610;
    _1046 = 0;
    _1047++;
    if (_1047 < _1043)
    goto _jump610;
    // End body of loop
    _1031 = _1041;
    _jump607:;
    _1014 = _1031;
    _jump600:;
    _978 = _1014;
    _jump586:;
    _886 = _978;
    _jump539:;
    int64_t _1050 = 618;
    int64_t _1051 = 173;
    if (_1050 >= 0)
    goto _jump611;
    fail_assertion("negative array index");
    _jump611:;
    if (_1050 < _886.d0)
    goto _jump612;
    fail_assertion("index too large");
    _jump612:;
    if (_1051 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (_1051 < _886.d1)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    int64_t _1052 = 0;
    _1052 *= _886.d0;
    _1052 += _1050;
    _1052 *= _886.d1;
    _1052 += _1051;
    _a1_int64_t _1053 = _886.data[_1052];
    int64_t _1054 = 439;
    int64_t _1055 = 724;
    bool _1056 = _1054 != _1055;
    double _1057;
    if (!_1056)
    goto _jump615;
    _a3__a1_double _1058;
    // Computing bound for i
    _1058.d0 = _402;
    if (_402 > 0) 
    goto _jump616;
    fail_assertion("non-positive loop bound");
    _jump616:;
    // Computing bound for j
    int64_t _1059 = 275;
    _1058.d1 = _1059;
    if (_1059 > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    // Computing bound for k
    int64_t _1060 = -_1053.d0;
    int64_t _1061 = -_1060;
    _1058.d2 = _1061;
    if (_1061 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    // Computing total size of heap memory to allocate
    int64_t _1062 = 1;
    _1062 *= _402;
    _1062 *= _1059;
    _1062 *= _1061;
    _1062 *= sizeof(_a1_double);
    _1058.data = jpl_alloc(_1062);
    int64_t _1063 = 0; // k
    int64_t _1064 = 0; // j
    int64_t _1065 = 0; // i
    _jump619:; // Begin body of loop
    _a1_double _1066;
    // Computing bound for l
    bool _1068 = false;
    bool _1067 = _1068;
    if (0 == _1068)
    goto _jump620;
    bool _1069 = true;
    _1067 = _1069;
    _jump620:;
    int64_t _1070;
    if (!_1067)
    goto _jump621;
    _1070 = _1065;
    goto _jump622;
    _jump621:;
    _1070 = _1053.d0;
    _jump622:;
    _1066.d0 = _1070;
    if (_1070 > 0) 
    goto _jump623;
    fail_assertion("non-positive loop bound");
    _jump623:;
    // Computing total size of heap memory to allocate
    int64_t _1071 = 1;
    _1071 *= _1070;
    _1071 *= sizeof(double);
    _1066.data = jpl_alloc(_1071);
    int64_t _1072 = 0; // l
    _jump624:; // Begin body of loop
    double _1073;
    // Computing bound for m
    if (_1072 > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for n
    int64_t _1074 = 554;
    if (_1074 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    _1073 = 0;
    int64_t _1075 = 0; // n
    int64_t _1076 = 0; // m
    _jump627:; // Begin body of loop
    double _1077 = 22.0;
    double _1078 = -_1077;
    _1073 += _1078;
    _1075++;
    if (_1075 < _1074)
    goto _jump627;
    _1075 = 0;
    _1076++;
    if (_1076 < _1072)
    goto _jump627;
    // End body of loop
    int64_t _1079 = 0;
    _1079 *= _1066.d0;
    _1079 += _1072;
    _1066.data[_1079] = _1073;
    _1072++;
    if (_1072 < _1070)
    goto _jump624;
    // End body of loop
    int64_t _1080 = 0;
    _1080 *= _1058.d0;
    _1080 += _1065;
    _1080 *= _1058.d1;
    _1080 += _1064;
    _1080 *= _1058.d2;
    _1080 += _1063;
    _1058.data[_1080] = _1066;
    _1063++;
    if (_1063 < _1061)
    goto _jump619;
    _1063 = 0;
    _1064++;
    if (_1064 < _1059)
    goto _jump619;
    _1064 = 0;
    _1065++;
    if (_1065 < _402)
    goto _jump619;
    // End body of loop
    int64_t _1081 = 634;
    int64_t _1082 = 34;
    if (_1081 >= 0)
    goto _jump628;
    fail_assertion("negative array index");
    _jump628:;
    if (_1081 < _1058.d0)
    goto _jump629;
    fail_assertion("index too large");
    _jump629:;
    if (_1082 >= 0)
    goto _jump630;
    fail_assertion("negative array index");
    _jump630:;
    if (_1082 < _1058.d1)
    goto _jump631;
    fail_assertion("index too large");
    _jump631:;
    if (_1053.d0 >= 0)
    goto _jump632;
    fail_assertion("negative array index");
    _jump632:;
    if (_1053.d0 < _1058.d2)
    goto _jump633;
    fail_assertion("index too large");
    _jump633:;
    int64_t _1083 = 0;
    _1083 *= _1058.d0;
    _1083 += _1081;
    _1083 *= _1058.d1;
    _1083 += _1082;
    _1083 *= _1058.d2;
    _1083 += _1053.d0;
    _a1_double _1084 = _1058.data[_1083];
    if (_1053.d0 >= 0)
    goto _jump634;
    fail_assertion("negative array index");
    _jump634:;
    if (_1053.d0 < _1084.d0)
    goto _jump635;
    fail_assertion("index too large");
    _jump635:;
    int64_t _1085 = 0;
    _1085 *= _1084.d0;
    _1085 += _1053.d0;
    double _1086 = _1084.data[_1085];
    _1057 = _1086;
    goto _jump636;
    _jump615:;
    bool _1087 = false;
    bool _1088 = !_1087;
    bool _1089;
    if (!_1088)
    goto _jump637;
    _1089 = _551;
    goto _jump638;
    _jump637:;
    bool _1090 = !_551;
    _1089 = _1090;
    _jump638:;
    bool _1091;
    if (!_1089)
    goto _jump639;
    int64_t _1092;
    // Computing bound for i
    if (_1053.d0 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for j
    if (_1053.d0 > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing bound for k
    if (_1053.d0 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    _1092 = 0;
    int64_t _1093 = 0; // k
    int64_t _1094 = 0; // j
    int64_t _1095 = 0; // i
    _jump643:; // Begin body of loop
    _1092 += _402;
    _1093++;
    if (_1093 < _1053.d0)
    goto _jump643;
    _1093 = 0;
    _1094++;
    if (_1094 < _1053.d0)
    goto _jump643;
    _1094 = 0;
    _1095++;
    if (_1095 < _1053.d0)
    goto _jump643;
    // End body of loop
    int64_t _1096 = 643;
    bool _1097 = _1092 != _1096;
    _1091 = _1097;
    goto _jump644;
    _jump639:;
    int64_t _1098 = 279;
    bool _1099 = _1098 == _1053.d0;
    _1091 = _1099;
    _jump644:;
    _a3_bool _1100;
    if (!_1091)
    goto _jump645;
    double _1101 = 53.0;
    double _1102 = 36.0;
    double _1103 = _1101 + _1102;
    double _1104 = 97.0;
    bool _1105 = _1103 <= _1104;
    _a3_bool _1106;
    if (!_1105)
    goto _jump646;
    _a3_bool _1107;
    // Computing bound for i
    _1107.d0 = _402;
    if (_402 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    // Computing bound for j
    _1107.d1 = _1053.d0;
    if (_1053.d0 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    // Computing bound for k
    bool _1108 = false;
    int64_t _1109;
    if (!_1108)
    goto _jump649;
    _1109 = _402;
    goto _jump650;
    _jump649:;
    int64_t _1110 = 880;
    _1109 = _1110;
    _jump650:;
    _1107.d2 = _1109;
    if (_1109 > 0) 
    goto _jump651;
    fail_assertion("non-positive loop bound");
    _jump651:;
    // Computing total size of heap memory to allocate
    int64_t _1111 = 1;
    _1111 *= _402;
    _1111 *= _1053.d0;
    _1111 *= _1109;
    _1111 *= sizeof(bool);
    _1107.data = jpl_alloc(_1111);
    int64_t _1112 = 0; // k
    int64_t _1113 = 0; // j
    int64_t _1114 = 0; // i
    _jump652:; // Begin body of loop
    bool _1115 = true;
    int64_t _1116 = 0;
    _1116 *= _1107.d0;
    _1116 += _1114;
    _1116 *= _1107.d1;
    _1116 += _1113;
    _1116 *= _1107.d2;
    _1116 += _1112;
    _1107.data[_1116] = _1115;
    _1112++;
    if (_1112 < _1109)
    goto _jump652;
    _1112 = 0;
    _1113++;
    if (_1113 < _1053.d0)
    goto _jump652;
    _1113 = 0;
    _1114++;
    if (_1114 < _402)
    goto _jump652;
    // End body of loop
    _1106 = _1107;
    goto _jump653;
    _jump646:;
    _a3_bool _1117;
    // Computing bound for i
    _1117.d0 = _1053.d0;
    if (_1053.d0 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing bound for j
    int64_t _1118;
    // Computing bound for i
    int64_t _1119 = 815;
    if (_1119 > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing bound for j
    int64_t _1120 = 560;
    if (_1120 > 0) 
    goto _jump656;
    fail_assertion("non-positive loop bound");
    _jump656:;
    // Computing bound for k
    if (_1053.d0 > 0) 
    goto _jump657;
    fail_assertion("non-positive loop bound");
    _jump657:;
    _1118 = 0;
    int64_t _1121 = 0; // k
    int64_t _1122 = 0; // j
    int64_t _1123 = 0; // i
    _jump658:; // Begin body of loop
    _1118 += _1053.d0;
    _1121++;
    if (_1121 < _1053.d0)
    goto _jump658;
    _1121 = 0;
    _1122++;
    if (_1122 < _1120)
    goto _jump658;
    _1122 = 0;
    _1123++;
    if (_1123 < _1119)
    goto _jump658;
    // End body of loop
    _1117.d1 = _1118;
    if (_1118 > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing bound for k
    int64_t _1124 = 466;
    int64_t _1125 = 271;
    int64_t _1126 = _1124 % _1125;
    _1117.d2 = _1126;
    if (_1126 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing total size of heap memory to allocate
    int64_t _1127 = 1;
    _1127 *= _1053.d0;
    _1127 *= _1118;
    _1127 *= _1126;
    _1127 *= sizeof(bool);
    _1117.data = jpl_alloc(_1127);
    int64_t _1128 = 0; // k
    int64_t _1129 = 0; // j
    int64_t _1130 = 0; // i
    _jump661:; // Begin body of loop
    bool _1131 = true;
    int64_t _1132 = 0;
    _1132 *= _1117.d0;
    _1132 += _1130;
    _1132 *= _1117.d1;
    _1132 += _1129;
    _1132 *= _1117.d2;
    _1132 += _1128;
    _1117.data[_1132] = _1131;
    _1128++;
    if (_1128 < _1126)
    goto _jump661;
    _1128 = 0;
    _1129++;
    if (_1129 < _1118)
    goto _jump661;
    _1129 = 0;
    _1130++;
    if (_1130 < _1053.d0)
    goto _jump661;
    // End body of loop
    _1106 = _1117;
    _jump653:;
    _1100 = _1106;
    goto _jump662;
    _jump645:;
    _a1__a3_bool _1133;
    // Computing bound for i
    int64_t _1134 = _402 % _1053.d0;
    _1133.d0 = _1134;
    if (_1134 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing total size of heap memory to allocate
    int64_t _1135 = 1;
    _1135 *= _1134;
    _1135 *= sizeof(_a3_bool);
    _1133.data = jpl_alloc(_1135);
    int64_t _1136 = 0; // i
    _jump664:; // Begin body of loop
    _a3_bool _1137;
    // Computing bound for j
    _1137.d0 = _1136;
    if (_1136 > 0) 
    goto _jump665;
    fail_assertion("non-positive loop bound");
    _jump665:;
    // Computing bound for k
    _1137.d1 = _402;
    if (_402 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing bound for l
    _1137.d2 = _1053.d0;
    if (_1053.d0 > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    // Computing total size of heap memory to allocate
    int64_t _1138 = 1;
    _1138 *= _1136;
    _1138 *= _402;
    _1138 *= _1053.d0;
    _1138 *= sizeof(bool);
    _1137.data = jpl_alloc(_1138);
    int64_t _1139 = 0; // l
    int64_t _1140 = 0; // k
    int64_t _1141 = 0; // j
    _jump668:; // Begin body of loop
    bool _1142 = true;
    int64_t _1143 = 0;
    _1143 *= _1137.d0;
    _1143 += _1141;
    _1143 *= _1137.d1;
    _1143 += _1140;
    _1143 *= _1137.d2;
    _1143 += _1139;
    _1137.data[_1143] = _1142;
    _1139++;
    if (_1139 < _1053.d0)
    goto _jump668;
    _1139 = 0;
    _1140++;
    if (_1140 < _402)
    goto _jump668;
    _1140 = 0;
    _1141++;
    if (_1141 < _1136)
    goto _jump668;
    // End body of loop
    int64_t _1144 = 0;
    _1144 *= _1133.d0;
    _1144 += _1136;
    _1133.data[_1144] = _1137;
    _1136++;
    if (_1136 < _1134)
    goto _jump664;
    // End body of loop
    if (_402 >= 0)
    goto _jump669;
    fail_assertion("negative array index");
    _jump669:;
    if (_402 < _1133.d0)
    goto _jump670;
    fail_assertion("index too large");
    _jump670:;
    int64_t _1145 = 0;
    _1145 *= _1133.d0;
    _1145 += _402;
    _a3_bool _1146 = _1133.data[_1145];
    _1100 = _1146;
    _jump662:;
    int64_t _1147 = -_402;
    int64_t _1148 = 336;
    if (_402 >= 0)
    goto _jump671;
    fail_assertion("negative array index");
    _jump671:;
    if (_402 < _1100.d0)
    goto _jump672;
    fail_assertion("index too large");
    _jump672:;
    if (_1147 >= 0)
    goto _jump673;
    fail_assertion("negative array index");
    _jump673:;
    if (_1147 < _1100.d1)
    goto _jump674;
    fail_assertion("index too large");
    _jump674:;
    if (_1148 >= 0)
    goto _jump675;
    fail_assertion("negative array index");
    _jump675:;
    if (_1148 < _1100.d2)
    goto _jump676;
    fail_assertion("index too large");
    _jump676:;
    int64_t _1149 = 0;
    _1149 *= _1100.d0;
    _1149 += _402;
    _1149 *= _1100.d1;
    _1149 += _1147;
    _1149 *= _1100.d2;
    _1149 += _1148;
    bool _1150 = _1100.data[_1149];
    double _1151;
    if (!_1150)
    goto _jump677;
    double _1152 = 80.0;
    double _1153 = -_1152;
    double _1154 = 25.0;
    bool _1155 = _1153 == _1154;
    _a3_bool _1156;
    if (!_1155)
    goto _jump678;
    _a3_bool _1157;
    // Computing bound for i
    _1157.d0 = _1053.d0;
    if (_1053.d0 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing bound for j
    _1157.d1 = _402;
    if (_402 > 0) 
    goto _jump680;
    fail_assertion("non-positive loop bound");
    _jump680:;
    // Computing bound for k
    int64_t _1158 = 815;
    _1157.d2 = _1158;
    if (_1158 > 0) 
    goto _jump681;
    fail_assertion("non-positive loop bound");
    _jump681:;
    // Computing total size of heap memory to allocate
    int64_t _1159 = 1;
    _1159 *= _1053.d0;
    _1159 *= _402;
    _1159 *= _1158;
    _1159 *= sizeof(bool);
    _1157.data = jpl_alloc(_1159);
    int64_t _1160 = 0; // k
    int64_t _1161 = 0; // j
    int64_t _1162 = 0; // i
    _jump682:; // Begin body of loop
    bool _1163 = false;
    int64_t _1164 = 0;
    _1164 *= _1157.d0;
    _1164 += _1162;
    _1164 *= _1157.d1;
    _1164 += _1161;
    _1164 *= _1157.d2;
    _1164 += _1160;
    _1157.data[_1164] = _1163;
    _1160++;
    if (_1160 < _1158)
    goto _jump682;
    _1160 = 0;
    _1161++;
    if (_1161 < _402)
    goto _jump682;
    _1161 = 0;
    _1162++;
    if (_1162 < _1053.d0)
    goto _jump682;
    // End body of loop
    _1156 = _1157;
    goto _jump683;
    _jump678:;
    _a3_bool _1165;
    // Computing bound for i
    int64_t _1166 = 384;
    _1165.d0 = _1166;
    if (_1166 > 0) 
    goto _jump684;
    fail_assertion("non-positive loop bound");
    _jump684:;
    // Computing bound for j
    int64_t _1167 = -_1053.d0;
    _1165.d1 = _1167;
    if (_1167 > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing bound for k
    int64_t _1168 = 623;
    _1165.d2 = _1168;
    if (_1168 > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    // Computing total size of heap memory to allocate
    int64_t _1169 = 1;
    _1169 *= _1166;
    _1169 *= _1167;
    _1169 *= _1168;
    _1169 *= sizeof(bool);
    _1165.data = jpl_alloc(_1169);
    int64_t _1170 = 0; // k
    int64_t _1171 = 0; // j
    int64_t _1172 = 0; // i
    _jump687:; // Begin body of loop
    int64_t _1173 = 0;
    _1173 *= _1165.d0;
    _1173 += _1172;
    _1173 *= _1165.d1;
    _1173 += _1171;
    _1173 *= _1165.d2;
    _1173 += _1170;
    _1165.data[_1173] = _551;
    _1170++;
    if (_1170 < _1168)
    goto _jump687;
    _1170 = 0;
    _1171++;
    if (_1171 < _1167)
    goto _jump687;
    _1171 = 0;
    _1172++;
    if (_1172 < _1166)
    goto _jump687;
    // End body of loop
    _1156 = _1165;
    _jump683:;
    int64_t _1174;
    // Computing bound for i
    _a2_int64_t _1175;
    // Computing bound for i
    _1175.d0 = _1053.d0;
    if (_1053.d0 > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for j
    int64_t _1176 = 854;
    _1175.d1 = _1176;
    if (_1176 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    // Computing total size of heap memory to allocate
    int64_t _1177 = 1;
    _1177 *= _1053.d0;
    _1177 *= _1176;
    _1177 *= sizeof(int64_t);
    _1175.data = jpl_alloc(_1177);
    int64_t _1178 = 0; // j
    int64_t _1179 = 0; // i
    _jump690:; // Begin body of loop
    int64_t _1180 = 0;
    _1180 *= _1175.d0;
    _1180 += _1179;
    _1180 *= _1175.d1;
    _1180 += _1178;
    _1175.data[_1180] = _1179;
    _1178++;
    if (_1178 < _1176)
    goto _jump690;
    _1178 = 0;
    _1179++;
    if (_1179 < _1053.d0)
    goto _jump690;
    // End body of loop
    int64_t _1181 = 854;
    int64_t _1182;
    // Computing bound for i
    int64_t _1183 = 772;
    if (_1183 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for j
    if (_402 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing bound for k
    int64_t _1184 = 248;
    if (_1184 > 0) 
    goto _jump693;
    fail_assertion("non-positive loop bound");
    _jump693:;
    _1182 = 0;
    int64_t _1185 = 0; // k
    int64_t _1186 = 0; // j
    int64_t _1187 = 0; // i
    _jump694:; // Begin body of loop
    _1182 += _1053.d0;
    _1185++;
    if (_1185 < _1184)
    goto _jump694;
    _1185 = 0;
    _1186++;
    if (_1186 < _402)
    goto _jump694;
    _1186 = 0;
    _1187++;
    if (_1187 < _1183)
    goto _jump694;
    // End body of loop
    if (_1181 >= 0)
    goto _jump695;
    fail_assertion("negative array index");
    _jump695:;
    if (_1181 < _1175.d0)
    goto _jump696;
    fail_assertion("index too large");
    _jump696:;
    if (_1182 >= 0)
    goto _jump697;
    fail_assertion("negative array index");
    _jump697:;
    if (_1182 < _1175.d1)
    goto _jump698;
    fail_assertion("index too large");
    _jump698:;
    int64_t _1188 = 0;
    _1188 *= _1175.d0;
    _1188 += _1181;
    _1188 *= _1175.d1;
    _1188 += _1182;
    int64_t _1189 = _1175.data[_1188];
    if (_1189 > 0) 
    goto _jump699;
    fail_assertion("non-positive loop bound");
    _jump699:;
    _1174 = 0;
    int64_t _1190 = 0; // i
    _jump700:; // Begin body of loop
    int64_t _1191;
    // Computing bound for j
    int64_t _1192;
    if (!_551)
    goto _jump701;
    _1192 = _1053.d0;
    goto _jump702;
    _jump701:;
    _1192 = _1053.d0;
    _jump702:;
    if (_1192 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    _1191 = 0;
    int64_t _1193 = 0; // j
    _jump704:; // Begin body of loop
    int64_t _1194;
    // Computing bound for k
    int64_t _1195 = 453;
    if (_1195 > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    _1194 = 0;
    int64_t _1196 = 0; // k
    _jump706:; // Begin body of loop
    _1194 += _1190;
    _1196++;
    if (_1196 < _1195)
    goto _jump706;
    // End body of loop
    _1191 += _1194;
    _1193++;
    if (_1193 < _1192)
    goto _jump704;
    // End body of loop
    _1174 += _1191;
    _1190++;
    if (_1190 < _1189)
    goto _jump700;
    // End body of loop
    int64_t _1197;
    // Computing bound for i
    if (_402 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    // Computing bound for j
    int64_t _1198 = _1053.d0 - _1053.d0;
    int64_t _1199 = -_1198;
    if (_1199 > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    // Computing bound for k
    bool _1200 = false;
    int64_t _1201;
    if (!_1200)
    goto _jump709;
    _1201 = _402;
    goto _jump710;
    _jump709:;
    _1201 = _1053.d0;
    _jump710:;
    int64_t _1202 = _402 / _1201;
    if (_1202 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    _1197 = 0;
    int64_t _1203 = 0; // k
    int64_t _1204 = 0; // j
    int64_t _1205 = 0; // i
    _jump712:; // Begin body of loop
    int64_t _1206;
    // Computing bound for l
    if (_1204 > 0) 
    goto _jump713;
    fail_assertion("non-positive loop bound");
    _jump713:;
    // Computing bound for m
    int64_t _1207 = 805;
    if (_1207 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for n
    bool _1208 = false;
    int64_t _1209;
    if (!_1208)
    goto _jump715;
    _1209 = _1204;
    goto _jump716;
    _jump715:;
    _1209 = _1053.d0;
    _jump716:;
    if (_1209 > 0) 
    goto _jump717;
    fail_assertion("non-positive loop bound");
    _jump717:;
    _1206 = 0;
    int64_t _1210 = 0; // n
    int64_t _1211 = 0; // m
    int64_t _1212 = 0; // l
    _jump718:; // Begin body of loop
    int64_t _1213 = 146;
    int64_t _1214 = _1204 * _1213;
    _1206 += _1214;
    _1210++;
    if (_1210 < _1209)
    goto _jump718;
    _1210 = 0;
    _1211++;
    if (_1211 < _1207)
    goto _jump718;
    _1211 = 0;
    _1212++;
    if (_1212 < _1204)
    goto _jump718;
    // End body of loop
    _1197 += _1206;
    _1203++;
    if (_1203 < _1202)
    goto _jump712;
    _1203 = 0;
    _1204++;
    if (_1204 < _1199)
    goto _jump712;
    _1204 = 0;
    _1205++;
    if (_1205 < _402)
    goto _jump712;
    // End body of loop
    bool _1215 = !_551;
    int64_t _1216;
    if (!_1215)
    goto _jump719;
    int64_t _1217 = -_1053.d0;
    _1216 = _1217;
    goto _jump720;
    _jump719:;
    _1216 = _1053.d0;
    _jump720:;
    int64_t _1218 = -_1216;
    if (_1174 >= 0)
    goto _jump721;
    fail_assertion("negative array index");
    _jump721:;
    if (_1174 < _1156.d0)
    goto _jump722;
    fail_assertion("index too large");
    _jump722:;
    if (_1197 >= 0)
    goto _jump723;
    fail_assertion("negative array index");
    _jump723:;
    if (_1197 < _1156.d1)
    goto _jump724;
    fail_assertion("index too large");
    _jump724:;
    if (_1218 >= 0)
    goto _jump725;
    fail_assertion("negative array index");
    _jump725:;
    if (_1218 < _1156.d2)
    goto _jump726;
    fail_assertion("index too large");
    _jump726:;
    int64_t _1219 = 0;
    _1219 *= _1156.d0;
    _1219 += _1174;
    _1219 *= _1156.d1;
    _1219 += _1197;
    _1219 *= _1156.d2;
    _1219 += _1218;
    bool _1220 = _1156.data[_1219];
    double _1221;
    if (!_1220)
    goto _jump727;
    double _1222;
    // Computing bound for i
    bool _1224 = true;
    bool _1223 = _1224;
    if (0 == _1224)
    goto _jump728;
    bool _1225 = true;
    _1223 = _1225;
    _jump728:;
    int64_t _1226;
    if (!_1223)
    goto _jump729;
    int64_t _1227 = _402 / _402;
    _1226 = _1227;
    goto _jump730;
    _jump729:;
    _1226 = _1053.d0;
    _jump730:;
    int64_t _1228 = -_1053.d0;
    int64_t _1229 = _1226 % _1228;
    if (_1229 > 0) 
    goto _jump731;
    fail_assertion("non-positive loop bound");
    _jump731:;
    // Computing bound for j
    int64_t _1230 = -_402;
    int64_t _1231 = -_1230;
    int64_t _1232 = -_1231;
    if (_1232 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    // Computing bound for k
    int64_t _1233 = -_402;
    int64_t _1234 = _1233 + _1053.d0;
    if (_1234 > 0) 
    goto _jump733;
    fail_assertion("non-positive loop bound");
    _jump733:;
    _1222 = 0;
    int64_t _1235 = 0; // k
    int64_t _1236 = 0; // j
    int64_t _1237 = 0; // i
    _jump734:; // Begin body of loop
    double _1238 = 50.0;
    _1222 += _1238;
    _1235++;
    if (_1235 < _1234)
    goto _jump734;
    _1235 = 0;
    _1236++;
    if (_1236 < _1232)
    goto _jump734;
    _1236 = 0;
    _1237++;
    if (_1237 < _1229)
    goto _jump734;
    // End body of loop
    _1221 = _1222;
    goto _jump735;
    _jump727:;
    bool _1239 = true;
    rgba _1240;
    if (!_1239)
    goto _jump736;
    bool _1241 = true;
    rgba _1242;
    if (!_1241)
    goto _jump737;
    _1242 = b;
    goto _jump738;
    _jump737:;
    _1242 = b;
    _jump738:;
    _1240 = _1242;
    goto _jump739;
    _jump736:;
    _1240 = b;
    _jump739:;
    double _1243 = _1240.b;
    _1221 = _1243;
    _jump735:;
    _1151 = _1221;
    goto _jump740;
    _jump677:;
    double _1244 = 70.0;
    double _1245 = -_1244;
    double _1246 = -_1245;
    double _1247 = -_1246;
    double _1248 = -_1247;
    _1151 = _1248;
    _jump740:;
    _1057 = _1151;
    _jump636:;
    return _1057;
}

void_t f() {
    bool _1 = false;
    bool _0 = _1;
    if (0 != _1)
    goto _jump994;
    int64_t _2 = 238;
    bool _3 = _2 > d;
    bool _4 = !_3;
    _0 = _4;
    _jump994:;
    _a1_int64_t _5;
    // Computing bound for h
    _5.d0 = c;
    if (c > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= c;
    _6 *= sizeof(int64_t);
    _5.data = jpl_alloc(_6);
    int64_t _7 = 0; // h
    _jump996:; // Begin body of loop
    int64_t _8 = -d;
    int64_t _9 = 0;
    _9 *= _5.d0;
    _9 += _7;
    _5.data[_9] = _8;
    _7++;
    if (_7 < c)
    goto _jump996;
    // End body of loop
    _a2__a3_bool _10;
    if (!_0)
    goto _jump997;
    _a2__a3_bool _11;
    // Computing bound for j
    bool _12 = true;
    int64_t _13;
    if (!_12)
    goto _jump998;
    int64_t _14 = 451;
    _13 = _14;
    goto _jump999;
    _jump998:;
    _13 = c;
    _jump999:;
    _11.d0 = _13;
    if (_13 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for k
    int64_t _15 = 535;
    _11.d1 = _15;
    if (_15 > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _13;
    _16 *= _15;
    _16 *= sizeof(_a3_bool);
    _11.data = jpl_alloc(_16);
    int64_t _17 = 0; // k
    int64_t _18 = 0; // j
    _jump1002:; // Begin body of loop
    _a3_bool _19;
    // Computing bound for l
    _19.d0 = _17;
    if (_17 > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    // Computing bound for m
    _19.d1 = _5.d0;
    if (_5.d0 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for n
    _19.d2 = d;
    if (d > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _17;
    _20 *= _5.d0;
    _20 *= d;
    _20 *= sizeof(bool);
    _19.data = jpl_alloc(_20);
    int64_t _21 = 0; // n
    int64_t _22 = 0; // m
    int64_t _23 = 0; // l
    _jump1006:; // Begin body of loop
    int64_t _24 = 0;
    _24 *= _19.d0;
    _24 += _23;
    _24 *= _19.d1;
    _24 += _22;
    _24 *= _19.d2;
    _24 += _21;
    _19.data[_24] = _0;
    _21++;
    if (_21 < d)
    goto _jump1006;
    _21 = 0;
    _22++;
    if (_22 < _5.d0)
    goto _jump1006;
    _22 = 0;
    _23++;
    if (_23 < _17)
    goto _jump1006;
    // End body of loop
    int64_t _25 = 0;
    _25 *= _11.d0;
    _25 += _18;
    _25 *= _11.d1;
    _25 += _17;
    _11.data[_25] = _19;
    _17++;
    if (_17 < _15)
    goto _jump1002;
    _17 = 0;
    _18++;
    if (_18 < _13)
    goto _jump1002;
    // End body of loop
    _10 = _11;
    goto _jump1007;
    _jump997:;
    _a2__a3_bool _26;
    // Computing bound for j
    int64_t _27;
    // Computing bound for j
    if (_5.d0 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    _27 = 0;
    int64_t _28 = 0; // j
    _jump1009:; // Begin body of loop
    _27 += _28;
    _28++;
    if (_28 < _5.d0)
    goto _jump1009;
    // End body of loop
    _26.d0 = _27;
    if (_27 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    // Computing bound for k
    int64_t _29 = -c;
    _26.d1 = _29;
    if (_29 > 0) 
    goto _jump1011;
    fail_assertion("non-positive loop bound");
    _jump1011:;
    // Computing total size of heap memory to allocate
    int64_t _30 = 1;
    _30 *= _27;
    _30 *= _29;
    _30 *= sizeof(_a3_bool);
    _26.data = jpl_alloc(_30);
    int64_t _31 = 0; // k
    int64_t _32 = 0; // j
    _jump1012:; // Begin body of loop
    _a3_bool _33;
    // Computing bound for l
    _33.d0 = _5.d0;
    if (_5.d0 > 0) 
    goto _jump1013;
    fail_assertion("non-positive loop bound");
    _jump1013:;
    // Computing bound for m
    _33.d1 = _31;
    if (_31 > 0) 
    goto _jump1014;
    fail_assertion("non-positive loop bound");
    _jump1014:;
    // Computing bound for n
    _33.d2 = d;
    if (d > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= _5.d0;
    _34 *= _31;
    _34 *= d;
    _34 *= sizeof(bool);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // n
    int64_t _36 = 0; // m
    int64_t _37 = 0; // l
    _jump1016:; // Begin body of loop
    bool _38 = false;
    int64_t _39 = 0;
    _39 *= _33.d0;
    _39 += _37;
    _39 *= _33.d1;
    _39 += _36;
    _39 *= _33.d2;
    _39 += _35;
    _33.data[_39] = _38;
    _35++;
    if (_35 < d)
    goto _jump1016;
    _35 = 0;
    _36++;
    if (_36 < _31)
    goto _jump1016;
    _36 = 0;
    _37++;
    if (_37 < _5.d0)
    goto _jump1016;
    // End body of loop
    int64_t _40 = 0;
    _40 *= _26.d0;
    _40 += _32;
    _40 *= _26.d1;
    _40 += _31;
    _26.data[_40] = _33;
    _31++;
    if (_31 < _29)
    goto _jump1012;
    _31 = 0;
    _32++;
    if (_32 < _27)
    goto _jump1012;
    // End body of loop
    _10 = _26;
    _jump1007:;
    _a1__a2__a3_bool _41;
    _41.d0 = 1;
    _41.data = jpl_alloc(sizeof(_a2__a3_bool) * 1);
    _41.data[0] = _10;
    if (d >= 0)
    goto _jump1017;
    fail_assertion("negative array index");
    _jump1017:;
    if (d < _41.d0)
    goto _jump1018;
    fail_assertion("index too large");
    _jump1018:;
    int64_t _42 = 0;
    _42 *= _41.d0;
    _42 += d;
    _a2__a3_bool _43 = _41.data[_42];
    int64_t _44 = -c;
    int64_t _45;
    // Computing bound for j
    int64_t _46 = 82;
    if (_46 > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing bound for k
    if (d > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing bound for l
    if (_5.d0 > 0) 
    goto _jump1021;
    fail_assertion("non-positive loop bound");
    _jump1021:;
    _45 = 0;
    int64_t _47 = 0; // l
    int64_t _48 = 0; // k
    int64_t _49 = 0; // j
    _jump1022:; // Begin body of loop
    _45 += c;
    _47++;
    if (_47 < _5.d0)
    goto _jump1022;
    _47 = 0;
    _48++;
    if (_48 < d)
    goto _jump1022;
    _48 = 0;
    _49++;
    if (_49 < _46)
    goto _jump1022;
    // End body of loop
    _a1_int64_t _50;
    _50.d0 = 3;
    _50.data = jpl_alloc(sizeof(int64_t) * 3);
    _50.data[0] = _44;
    _50.data[1] = _45;
    _50.data[2] = _5.d0;
    _a1__a1_int64_t _51;
    _51.d0 = 1;
    _51.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _51.data[0] = _50;
    bool _52;
    if (!_0)
    goto _jump1023;
    _52 = _0;
    goto _jump1024;
    _jump1023:;
    bool _53 = true;
    _52 = _53;
    _jump1024:;
    int64_t _54;
    if (!_52)
    goto _jump1025;
    int64_t _55;
    // Computing bound for j
    if (_5.d0 > 0) 
    goto _jump1026;
    fail_assertion("non-positive loop bound");
    _jump1026:;
    // Computing bound for k
    if (c > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    _55 = 0;
    int64_t _56 = 0; // k
    int64_t _57 = 0; // j
    _jump1028:; // Begin body of loop
    _55 += _5.d0;
    _56++;
    if (_56 < c)
    goto _jump1028;
    _56 = 0;
    _57++;
    if (_57 < _5.d0)
    goto _jump1028;
    // End body of loop
    _54 = _55;
    goto _jump1029;
    _jump1025:;
    _54 = _5.d0;
    _jump1029:;
    if (_54 >= 0)
    goto _jump1030;
    fail_assertion("negative array index");
    _jump1030:;
    if (_54 < _51.d0)
    goto _jump1031;
    fail_assertion("index too large");
    _jump1031:;
    int64_t _58 = 0;
    _58 *= _51.d0;
    _58 += _54;
    _a1_int64_t _59 = _51.data[_58];
    if (d >= 0)
    goto _jump1032;
    fail_assertion("negative array index");
    _jump1032:;
    if (d < _59.d0)
    goto _jump1033;
    fail_assertion("index too large");
    _jump1033:;
    int64_t _60 = 0;
    _60 *= _59.d0;
    _60 += d;
    int64_t _61 = _59.data[_60];
    int64_t _62 = 930;
    if (_61 >= 0)
    goto _jump1034;
    fail_assertion("negative array index");
    _jump1034:;
    if (_61 < _43.d0)
    goto _jump1035;
    fail_assertion("index too large");
    _jump1035:;
    if (_62 >= 0)
    goto _jump1036;
    fail_assertion("negative array index");
    _jump1036:;
    if (_62 < _43.d1)
    goto _jump1037;
    fail_assertion("index too large");
    _jump1037:;
    int64_t _63 = 0;
    _63 *= _43.d0;
    _63 += _61;
    _63 *= _43.d1;
    _63 += _62;
    _a3_bool _64 = _43.data[_63];
    double _65;
    // Computing bound for j
    int64_t _66 = -d;
    if (_66 > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    // Computing bound for k
    if (_5.d0 > 0) 
    goto _jump1039;
    fail_assertion("non-positive loop bound");
    _jump1039:;
    // Computing bound for l
    if (_5.d0 > 0) 
    goto _jump1040;
    fail_assertion("non-positive loop bound");
    _jump1040:;
    _65 = 0;
    int64_t _67 = 0; // l
    int64_t _68 = 0; // k
    int64_t _69 = 0; // j
    _jump1041:; // Begin body of loop
    double _70 = 43.0;
    _65 += _70;
    _67++;
    if (_67 < _5.d0)
    goto _jump1041;
    _67 = 0;
    _68++;
    if (_68 < _5.d0)
    goto _jump1041;
    _68 = 0;
    _69++;
    if (_69 < _66)
    goto _jump1041;
    // End body of loop
    double _71 = 15.0;
    bool _72 = _65 == _71;
    int64_t _73;
    if (!_72)
    goto _jump1042;
    _73 = d;
    goto _jump1043;
    _jump1042:;
    _73 = d;
    _jump1043:;
    int64_t _74 = -_73;
    int64_t _75;
    // Computing bound for j
    _a1_int64_t _76;
    if (!_0)
    goto _jump1044;
    bool _77 = d > _5.d0;
    _a1_int64_t _78;
    if (!_77)
    goto _jump1045;
    _78 = _5;
    goto _jump1046;
    _jump1045:;
    _78 = _5;
    _jump1046:;
    _76 = _78;
    goto _jump1047;
    _jump1044:;
    int64_t _79 = 552;
    int64_t _80;
    // Computing bound for j
    if (c > 0) 
    goto _jump1048;
    fail_assertion("non-positive loop bound");
    _jump1048:;
    // Computing bound for k
    if (c > 0) 
    goto _jump1049;
    fail_assertion("non-positive loop bound");
    _jump1049:;
    _80 = 0;
    int64_t _81 = 0; // k
    int64_t _82 = 0; // j
    _jump1050:; // Begin body of loop
    _80 += _5.d0;
    _81++;
    if (_81 < c)
    goto _jump1050;
    _81 = 0;
    _82++;
    if (_82 < c)
    goto _jump1050;
    // End body of loop
    _a1_int64_t _83;
    _83.d0 = 3;
    _83.data = jpl_alloc(sizeof(int64_t) * 3);
    _83.data[0] = _79;
    _83.data[1] = _80;
    _83.data[2] = d;
    _76 = _83;
    _jump1047:;
    int64_t _84;
    // Computing bound for j
    if (_5.d0 > 0) 
    goto _jump1051;
    fail_assertion("non-positive loop bound");
    _jump1051:;
    // Computing bound for k
    if (d > 0) 
    goto _jump1052;
    fail_assertion("non-positive loop bound");
    _jump1052:;
    _84 = 0;
    int64_t _85 = 0; // k
    int64_t _86 = 0; // j
    _jump1053:; // Begin body of loop
    _84 += c;
    _85++;
    if (_85 < d)
    goto _jump1053;
    _85 = 0;
    _86++;
    if (_86 < _5.d0)
    goto _jump1053;
    // End body of loop
    if (_84 >= 0)
    goto _jump1054;
    fail_assertion("negative array index");
    _jump1054:;
    if (_84 < _76.d0)
    goto _jump1055;
    fail_assertion("index too large");
    _jump1055:;
    int64_t _87 = 0;
    _87 *= _76.d0;
    _87 += _84;
    int64_t _88 = _76.data[_87];
    int64_t _89 = -_88;
    if (_89 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    _75 = 0;
    int64_t _90 = 0; // j
    _jump1057:; // Begin body of loop
    int64_t _91 = 971;
    _75 += _91;
    _90++;
    if (_90 < _89)
    goto _jump1057;
    // End body of loop
    if (c >= 0)
    goto _jump1058;
    fail_assertion("negative array index");
    _jump1058:;
    if (c < _64.d0)
    goto _jump1059;
    fail_assertion("index too large");
    _jump1059:;
    if (_74 >= 0)
    goto _jump1060;
    fail_assertion("negative array index");
    _jump1060:;
    if (_74 < _64.d1)
    goto _jump1061;
    fail_assertion("index too large");
    _jump1061:;
    if (_75 >= 0)
    goto _jump1062;
    fail_assertion("negative array index");
    _jump1062:;
    if (_75 < _64.d2)
    goto _jump1063;
    fail_assertion("index too large");
    _jump1063:;
    int64_t _92 = 0;
    _92 *= _64.d0;
    _92 += c;
    _92 *= _64.d1;
    _92 += _74;
    _92 *= _64.d2;
    _92 += _75;
    bool _93 = _64.data[_92];
    if (0 != _93)
    goto _jump1064;
    fail_assertion("j");
    _jump1064:;
    void_t _94 = f();
    double _95 = 11.0;
    bool _96 = false;
    bool _97;
    if (!_96)
    goto _jump1065;
    bool _98 = _5.d0 == _5.d0;
    _97 = _98;
    goto _jump1066;
    _jump1065:;
    int64_t _99 = 400;
    bool _100 = d >= _99;
    _97 = _100;
    _jump1066:;
    _a2__a1_bool _101;
    if (!_97)
    goto _jump1067;
    _a2__a1_bool _102;
    // Computing bound for l
    int64_t _103 = -c;
    _102.d0 = _103;
    if (_103 > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing bound for m
    int64_t _104 = 607;
    _102.d1 = _104;
    if (_104 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    // Computing total size of heap memory to allocate
    int64_t _105 = 1;
    _105 *= _103;
    _105 *= _104;
    _105 *= sizeof(_a1_bool);
    _102.data = jpl_alloc(_105);
    int64_t _106 = 0; // m
    int64_t _107 = 0; // l
    _jump1070:; // Begin body of loop
    bool _108 = true;
    _a1_bool _109;
    _109.d0 = 3;
    _109.data = jpl_alloc(sizeof(bool) * 3);
    _109.data[0] = _0;
    _109.data[1] = _108;
    _109.data[2] = _0;
    int64_t _110 = 0;
    _110 *= _102.d0;
    _110 += _107;
    _110 *= _102.d1;
    _110 += _106;
    _102.data[_110] = _109;
    _106++;
    if (_106 < _104)
    goto _jump1070;
    _106 = 0;
    _107++;
    if (_107 < _103)
    goto _jump1070;
    // End body of loop
    _101 = _102;
    goto _jump1071;
    _jump1067:;
    _a2__a1_bool _111;
    // Computing bound for l
    _111.d0 = d;
    if (d > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    // Computing bound for m
    _111.d1 = d;
    if (d > 0) 
    goto _jump1073;
    fail_assertion("non-positive loop bound");
    _jump1073:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= d;
    _112 *= d;
    _112 *= sizeof(_a1_bool);
    _111.data = jpl_alloc(_112);
    int64_t _113 = 0; // m
    int64_t _114 = 0; // l
    _jump1074:; // Begin body of loop
    bool _115 = false;
    _a1_bool _116;
    _116.d0 = 1;
    _116.data = jpl_alloc(sizeof(bool) * 1);
    _116.data[0] = _115;
    int64_t _117 = 0;
    _117 *= _111.d0;
    _117 += _114;
    _117 *= _111.d1;
    _117 += _113;
    _111.data[_117] = _116;
    _113++;
    if (_113 < d)
    goto _jump1074;
    _113 = 0;
    _114++;
    if (_114 < d)
    goto _jump1074;
    // End body of loop
    _101 = _111;
    _jump1071:;
    _a2__a1_bool _118;
    // Computing bound for l
    int64_t _119 = -_5.d0;
    int64_t _120 = 29;
    int64_t _121 = -_120;
    int64_t _122 = _119 - _121;
    _118.d0 = _122;
    if (_122 > 0) 
    goto _jump1075;
    fail_assertion("non-positive loop bound");
    _jump1075:;
    // Computing bound for m
    int64_t _123;
    if (!_0)
    goto _jump1076;
    int64_t _124;
    // Computing bound for l
    if (_5.d0 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    _124 = 0;
    int64_t _125 = 0; // l
    _jump1078:; // Begin body of loop
    _124 += _5.d0;
    _125++;
    if (_125 < _5.d0)
    goto _jump1078;
    // End body of loop
    _123 = _124;
    goto _jump1079;
    _jump1076:;
    if (d >= 0)
    goto _jump1080;
    fail_assertion("negative array index");
    _jump1080:;
    if (d < _5.d0)
    goto _jump1081;
    fail_assertion("index too large");
    _jump1081:;
    int64_t _126 = 0;
    _126 *= _5.d0;
    _126 += d;
    int64_t _127 = _5.data[_126];
    _123 = _127;
    _jump1079:;
    _118.d1 = _123;
    if (_123 > 0) 
    goto _jump1082;
    fail_assertion("non-positive loop bound");
    _jump1082:;
    // Computing total size of heap memory to allocate
    int64_t _128 = 1;
    _128 *= _122;
    _128 *= _123;
    _128 *= sizeof(_a1_bool);
    _118.data = jpl_alloc(_128);
    int64_t _129 = 0; // m
    int64_t _130 = 0; // l
    _jump1083:; // Begin body of loop
    bool _131 = true;
    bool _132 = true;
    bool _133 = _131 != _132;
    _a1_bool _134;
    if (!_133)
    goto _jump1084;
    _a1_bool _135;
    // Computing bound for n
    _135.d0 = _130;
    if (_130 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _130;
    _136 *= sizeof(bool);
    _135.data = jpl_alloc(_136);
    int64_t _137 = 0; // n
    _jump1086:; // Begin body of loop
    int64_t _138 = 0;
    _138 *= _135.d0;
    _138 += _137;
    _135.data[_138] = _0;
    _137++;
    if (_137 < _130)
    goto _jump1086;
    // End body of loop
    _134 = _135;
    goto _jump1087;
    _jump1084:;
    _a1_bool _139;
    // Computing bound for n
    _139.d0 = d;
    if (d > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= d;
    _140 *= sizeof(bool);
    _139.data = jpl_alloc(_140);
    int64_t _141 = 0; // n
    _jump1089:; // Begin body of loop
    bool _142 = false;
    int64_t _143 = 0;
    _143 *= _139.d0;
    _143 += _141;
    _139.data[_143] = _142;
    _141++;
    if (_141 < d)
    goto _jump1089;
    // End body of loop
    _134 = _139;
    _jump1087:;
    int64_t _144 = 0;
    _144 *= _118.d0;
    _144 += _130;
    _144 *= _118.d1;
    _144 += _129;
    _118.data[_144] = _134;
    _129++;
    if (_129 < _123)
    goto _jump1083;
    _129 = 0;
    _130++;
    if (_130 < _122)
    goto _jump1083;
    // End body of loop
    _a1__a2__a1_bool _145;
    _145.d0 = 2;
    _145.data = jpl_alloc(sizeof(_a2__a1_bool) * 2);
    _145.data[0] = _101;
    _145.data[1] = _118;
    int64_t _146 = 816;
    if (_146 >= 0)
    goto _jump1090;
    fail_assertion("negative array index");
    _jump1090:;
    if (_146 < _145.d0)
    goto _jump1091;
    fail_assertion("index too large");
    _jump1091:;
    int64_t _147 = 0;
    _147 *= _145.d0;
    _147 += _146;
    _a2__a1_bool _148 = _145.data[_147];
    int64_t _149;
    // Computing bound for l
    int64_t _150 = 358;
    int64_t _151 = 1;
    bool _152 = _150 != _151;
    int64_t _153;
    if (!_152)
    goto _jump1092;
    _153 = d;
    goto _jump1093;
    _jump1092:;
    _153 = d;
    _jump1093:;
    bool _154 = _153 < d;
    int64_t _155;
    if (!_154)
    goto _jump1094;
    int64_t _156 = c / c;
    _155 = _156;
    goto _jump1095;
    _jump1094:;
    _155 = c;
    _jump1095:;
    if (_155 > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    _149 = 0;
    int64_t _157 = 0; // l
    _jump1097:; // Begin body of loop
    int64_t _158;
    // Computing bound for m
    int64_t _159 = 967;
    if (_159 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    _158 = 0;
    int64_t _160 = 0; // m
    _jump1099:; // Begin body of loop
    _158 += d;
    _160++;
    if (_160 < _159)
    goto _jump1099;
    // End body of loop
    int64_t _161 = _158 - _5.d0;
    _149 += _161;
    _157++;
    if (_157 < _155)
    goto _jump1097;
    // End body of loop
    if (d >= 0)
    goto _jump1100;
    fail_assertion("negative array index");
    _jump1100:;
    if (d < _148.d0)
    goto _jump1101;
    fail_assertion("index too large");
    _jump1101:;
    if (_149 >= 0)
    goto _jump1102;
    fail_assertion("negative array index");
    _jump1102:;
    if (_149 < _148.d1)
    goto _jump1103;
    fail_assertion("index too large");
    _jump1103:;
    int64_t _162 = 0;
    _162 *= _148.d0;
    _162 += d;
    _162 *= _148.d1;
    _162 += _149;
    _a1_bool _163 = _148.data[_162];
    if (d >= 0)
    goto _jump1104;
    fail_assertion("negative array index");
    _jump1104:;
    if (d < _163.d0)
    goto _jump1105;
    fail_assertion("index too large");
    _jump1105:;
    int64_t _164 = 0;
    _164 *= _163.d0;
    _164 += d;
    bool _165 = _163.data[_164];
    if (0 != _165)
    goto _jump1106;
    fail_assertion("l");
    _jump1106:;
    void_t _166 = f();
    return _166;
}

double k(_a1_void_t l) {
    return h;
    double _0 = 75.0;
    return _0;
    _a2__a1_int64_t _1;
    // Computing bound for r
    int64_t _2 = 535;
    bool _3 = _2 <= g;
    int64_t _4;
    if (!_3)
    goto _jump1275;
    _4 = c;
    goto _jump1276;
    _jump1275:;
    _4 = g;
    _jump1276:;
    _1.d0 = _4;
    if (_4 > 0) 
    goto _jump1277;
    fail_assertion("non-positive loop bound");
    _jump1277:;
    // Computing bound for s
    _1.d1 = j;
    if (j > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _4;
    _5 *= j;
    _5 *= sizeof(_a1_int64_t);
    _1.data = jpl_alloc(_5);
    int64_t _6 = 0; // s
    int64_t _7 = 0; // r
    _jump1279:; // Begin body of loop
    int64_t _8 = 0;
    _8 *= _1.d0;
    _8 += _7;
    _8 *= _1.d1;
    _8 += _6;
    _1.data[_8] = i;
    _6++;
    if (_6 < j)
    goto _jump1279;
    _6 = 0;
    _7++;
    if (_7 < _4)
    goto _jump1279;
    // End body of loop
    double _9;
    // Computing bound for u
    if (g > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    // Computing bound for v
    int64_t _10 = l.d0 / c;
    if (_10 > 0) 
    goto _jump1281;
    fail_assertion("non-positive loop bound");
    _jump1281:;
    // Computing bound for w
    if (c > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    _9 = 0;
    int64_t _11 = 0; // w
    int64_t _12 = 0; // v
    int64_t _13 = 0; // u
    _jump1283:; // Begin body of loop
    double _14;
    // Computing bound for x
    if (i.d0 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    _14 = 0;
    int64_t _15 = 0; // x
    _jump1285:; // Begin body of loop
    int64_t _16 = 792;
    bool _17 = _16 != _13;
    bool _18 = !_17;
    double _19;
    if (!_18)
    goto _jump1286;
    double _20 = -h;
    _19 = _20;
    goto _jump1287;
    _jump1286:;
    bool _22 = false;
    bool _21 = _22;
    if (0 != _22)
    goto _jump1288;
    bool _23 = true;
    _21 = _23;
    _jump1288:;
    bool _24 = _1.d1 == _11;
    bool _25 = _21 == _24;
    _a1_void_t _26;
    if (!_25)
    goto _jump1289;
    _26 = l;
    goto _jump1290;
    _jump1289:;
    _26 = l;
    _jump1290:;
    double _27 = k(_26);
    _19 = _27;
    _jump1287:;
    _14 += _19;
    _15++;
    if (_15 < i.d0)
    goto _jump1285;
    // End body of loop
    _9 += _14;
    _11++;
    if (_11 < c)
    goto _jump1283;
    _11 = 0;
    _12++;
    if (_12 < _10)
    goto _jump1283;
    _12 = 0;
    _13++;
    if (_13 < g)
    goto _jump1283;
    // End body of loop
    return _9;
}

bool p(_a3_void_t q, double r) {
    _a1__a3__a3_void_t _0;
    // Computing bound for s
    _a1_int64_t _1;
    _1.d0 = 3;
    _1.data = jpl_alloc(sizeof(int64_t) * 3);
    _1.data[0] = n;
    _1.data[1] = j;
    _1.data[2] = j;
    if (n >= 0)
    goto _jump1417;
    fail_assertion("negative array index");
    _jump1417:;
    if (n < _1.d0)
    goto _jump1418;
    fail_assertion("index too large");
    _jump1418:;
    int64_t _2 = 0;
    _2 *= _1.d0;
    _2 += n;
    int64_t _3 = _1.data[_2];
    int64_t _4 = _3 * c;
    _0.d0 = _4;
    if (_4 > 0) 
    goto _jump1419;
    fail_assertion("non-positive loop bound");
    _jump1419:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _4;
    _5 *= sizeof(_a3__a3_void_t);
    _0.data = jpl_alloc(_5);
    int64_t _6 = 0; // s
    _jump1420:; // Begin body of loop
    _a3__a3_void_t _7;
    // Computing bound for t
    _7.d0 = j;
    if (j > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    // Computing bound for u
    _7.d1 = c;
    if (c > 0) 
    goto _jump1422;
    fail_assertion("non-positive loop bound");
    _jump1422:;
    // Computing bound for v
    int64_t _8;
    // Computing bound for t
    _a3_int64_t _9;
    // Computing bound for t
    _9.d0 = n;
    if (n > 0) 
    goto _jump1423;
    fail_assertion("non-positive loop bound");
    _jump1423:;
    // Computing bound for u
    _9.d1 = g;
    if (g > 0) 
    goto _jump1424;
    fail_assertion("non-positive loop bound");
    _jump1424:;
    // Computing bound for v
    _9.d2 = c;
    if (c > 0) 
    goto _jump1425;
    fail_assertion("non-positive loop bound");
    _jump1425:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= n;
    _10 *= g;
    _10 *= c;
    _10 *= sizeof(int64_t);
    _9.data = jpl_alloc(_10);
    int64_t _11 = 0; // v
    int64_t _12 = 0; // u
    int64_t _13 = 0; // t
    _jump1426:; // Begin body of loop
    int64_t _14 = 0;
    _14 *= _9.d0;
    _14 += _13;
    _14 *= _9.d1;
    _14 += _12;
    _14 *= _9.d2;
    _14 += _11;
    _9.data[_14] = o;
    _11++;
    if (_11 < c)
    goto _jump1426;
    _11 = 0;
    _12++;
    if (_12 < g)
    goto _jump1426;
    _12 = 0;
    _13++;
    if (_13 < n)
    goto _jump1426;
    // End body of loop
    int64_t _15 = -c;
    if (n >= 0)
    goto _jump1427;
    fail_assertion("negative array index");
    _jump1427:;
    if (n < _9.d0)
    goto _jump1428;
    fail_assertion("index too large");
    _jump1428:;
    if (_15 >= 0)
    goto _jump1429;
    fail_assertion("negative array index");
    _jump1429:;
    if (_15 < _9.d1)
    goto _jump1430;
    fail_assertion("index too large");
    _jump1430:;
    if (j >= 0)
    goto _jump1431;
    fail_assertion("negative array index");
    _jump1431:;
    if (j < _9.d2)
    goto _jump1432;
    fail_assertion("index too large");
    _jump1432:;
    int64_t _16 = 0;
    _16 *= _9.d0;
    _16 += n;
    _16 *= _9.d1;
    _16 += _15;
    _16 *= _9.d2;
    _16 += j;
    int64_t _17 = _9.data[_16];
    if (_17 > 0) 
    goto _jump1433;
    fail_assertion("non-positive loop bound");
    _jump1433:;
    // Computing bound for u
    _a3_int64_t _18;
    // Computing bound for t
    int64_t _19 = 44;
    _18.d0 = _19;
    if (_19 > 0) 
    goto _jump1434;
    fail_assertion("non-positive loop bound");
    _jump1434:;
    // Computing bound for u
    _18.d1 = o;
    if (o > 0) 
    goto _jump1435;
    fail_assertion("non-positive loop bound");
    _jump1435:;
    // Computing bound for v
    _18.d2 = g;
    if (g > 0) 
    goto _jump1436;
    fail_assertion("non-positive loop bound");
    _jump1436:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _19;
    _20 *= o;
    _20 *= g;
    _20 *= sizeof(int64_t);
    _18.data = jpl_alloc(_20);
    int64_t _21 = 0; // v
    int64_t _22 = 0; // u
    int64_t _23 = 0; // t
    _jump1437:; // Begin body of loop
    int64_t _24 = 0;
    _24 *= _18.d0;
    _24 += _23;
    _24 *= _18.d1;
    _24 += _22;
    _24 *= _18.d2;
    _24 += _21;
    _18.data[_24] = j;
    _21++;
    if (_21 < g)
    goto _jump1437;
    _21 = 0;
    _22++;
    if (_22 < o)
    goto _jump1437;
    _22 = 0;
    _23++;
    if (_23 < _19)
    goto _jump1437;
    // End body of loop
    int64_t _25;
    // Computing bound for t
    if (n > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    _25 = 0;
    int64_t _26 = 0; // t
    _jump1439:; // Begin body of loop
    _25 += _6;
    _26++;
    if (_26 < n)
    goto _jump1439;
    // End body of loop
    if (n >= 0)
    goto _jump1440;
    fail_assertion("negative array index");
    _jump1440:;
    if (n < _18.d0)
    goto _jump1441;
    fail_assertion("index too large");
    _jump1441:;
    if (_25 >= 0)
    goto _jump1442;
    fail_assertion("negative array index");
    _jump1442:;
    if (_25 < _18.d1)
    goto _jump1443;
    fail_assertion("index too large");
    _jump1443:;
    if (j >= 0)
    goto _jump1444;
    fail_assertion("negative array index");
    _jump1444:;
    if (j < _18.d2)
    goto _jump1445;
    fail_assertion("index too large");
    _jump1445:;
    int64_t _27 = 0;
    _27 *= _18.d0;
    _27 += n;
    _27 *= _18.d1;
    _27 += _25;
    _27 *= _18.d2;
    _27 += j;
    int64_t _28 = _18.data[_27];
    if (_28 > 0) 
    goto _jump1446;
    fail_assertion("non-positive loop bound");
    _jump1446:;
    // Computing bound for v
    if (c > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    _8 = 0;
    int64_t _29 = 0; // v
    int64_t _30 = 0; // u
    int64_t _31 = 0; // t
    _jump1448:; // Begin body of loop
    int64_t _32;
    // Computing bound for w
    if (j > 0) 
    goto _jump1449;
    fail_assertion("non-positive loop bound");
    _jump1449:;
    // Computing bound for x
    if (c > 0) 
    goto _jump1450;
    fail_assertion("non-positive loop bound");
    _jump1450:;
    _32 = 0;
    int64_t _33 = 0; // x
    int64_t _34 = 0; // w
    _jump1451:; // Begin body of loop
    _32 += j;
    _33++;
    if (_33 < c)
    goto _jump1451;
    _33 = 0;
    _34++;
    if (_34 < j)
    goto _jump1451;
    // End body of loop
    _8 += _32;
    _29++;
    if (_29 < c)
    goto _jump1448;
    _29 = 0;
    _30++;
    if (_30 < _28)
    goto _jump1448;
    _30 = 0;
    _31++;
    if (_31 < _17)
    goto _jump1448;
    // End body of loop
    _7.d2 = _8;
    if (_8 > 0) 
    goto _jump1452;
    fail_assertion("non-positive loop bound");
    _jump1452:;
    // Computing total size of heap memory to allocate
    int64_t _35 = 1;
    _35 *= j;
    _35 *= c;
    _35 *= _8;
    _35 *= sizeof(_a3_void_t);
    _7.data = jpl_alloc(_35);
    int64_t _36 = 0; // v
    int64_t _37 = 0; // u
    int64_t _38 = 0; // t
    _jump1453:; // Begin body of loop
    bool _39 = c > c;
    bool _40;
    if (!_39)
    goto _jump1454;
    double _41 = 87.0;
    double _42 = 9.0;
    bool _43 = _41 == _42;
    _40 = _43;
    goto _jump1455;
    _jump1454:;
    bool _44 = false;
    _40 = _44;
    _jump1455:;
    _a3_void_t _45;
    if (!_40)
    goto _jump1456;
    _45 = q;
    goto _jump1457;
    _jump1456:;
    _45 = q;
    _jump1457:;
    int64_t _46 = 0;
    _46 *= _7.d0;
    _46 += _38;
    _46 *= _7.d1;
    _46 += _37;
    _46 *= _7.d2;
    _46 += _36;
    _7.data[_46] = _45;
    _36++;
    if (_36 < _8)
    goto _jump1453;
    _36 = 0;
    _37++;
    if (_37 < c)
    goto _jump1453;
    _37 = 0;
    _38++;
    if (_38 < j)
    goto _jump1453;
    // End body of loop
    int64_t _47 = 0;
    _47 *= _0.d0;
    _47 += _6;
    _0.data[_47] = _7;
    _6++;
    if (_6 < _4)
    goto _jump1420;
    // End body of loop
    int64_t _48 = -c;
    if (_48 >= 0)
    goto _jump1458;
    fail_assertion("negative array index");
    _jump1458:;
    if (_48 < _0.d0)
    goto _jump1459;
    fail_assertion("index too large");
    _jump1459:;
    int64_t _49 = 0;
    _49 *= _0.d0;
    _49 += _48;
    _a3__a3_void_t _50 = _0.data[_49];
    _a2_bool _51;
    // Computing bound for s
    int64_t _52;
    // Computing bound for s
    int64_t _53;
    // Computing bound for s
    if (d > 0) 
    goto _jump1460;
    fail_assertion("non-positive loop bound");
    _jump1460:;
    // Computing bound for t
    if (g > 0) 
    goto _jump1461;
    fail_assertion("non-positive loop bound");
    _jump1461:;
    _53 = 0;
    int64_t _54 = 0; // t
    int64_t _55 = 0; // s
    _jump1462:; // Begin body of loop
    _53 += o;
    _54++;
    if (_54 < g)
    goto _jump1462;
    _54 = 0;
    _55++;
    if (_55 < d)
    goto _jump1462;
    // End body of loop
    if (_53 > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing bound for t
    if (o > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing bound for u
    if (j > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    _52 = 0;
    int64_t _56 = 0; // u
    int64_t _57 = 0; // t
    int64_t _58 = 0; // s
    _jump1466:; // Begin body of loop
    _52 += _58;
    _56++;
    if (_56 < j)
    goto _jump1466;
    _56 = 0;
    _57++;
    if (_57 < o)
    goto _jump1466;
    _57 = 0;
    _58++;
    if (_58 < _53)
    goto _jump1466;
    // End body of loop
    _51.d0 = _52;
    if (_52 > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    // Computing bound for t
    int64_t _59;
    // Computing bound for s
    if (n > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing bound for t
    if (c > 0) 
    goto _jump1469;
    fail_assertion("non-positive loop bound");
    _jump1469:;
    // Computing bound for u
    if (o > 0) 
    goto _jump1470;
    fail_assertion("non-positive loop bound");
    _jump1470:;
    _59 = 0;
    int64_t _60 = 0; // u
    int64_t _61 = 0; // t
    int64_t _62 = 0; // s
    _jump1471:; // Begin body of loop
    _59 += j;
    _60++;
    if (_60 < o)
    goto _jump1471;
    _60 = 0;
    _61++;
    if (_61 < c)
    goto _jump1471;
    _61 = 0;
    _62++;
    if (_62 < n)
    goto _jump1471;
    // End body of loop
    _51.d1 = _59;
    if (_59 > 0) 
    goto _jump1472;
    fail_assertion("non-positive loop bound");
    _jump1472:;
    // Computing total size of heap memory to allocate
    int64_t _63 = 1;
    _63 *= _52;
    _63 *= _59;
    _63 *= sizeof(bool);
    _51.data = jpl_alloc(_63);
    int64_t _64 = 0; // t
    int64_t _65 = 0; // s
    _jump1473:; // Begin body of loop
    bool _66 = true;
    bool _67 = !_66;
    int64_t _68 = 0;
    _68 *= _51.d0;
    _68 += _65;
    _68 *= _51.d1;
    _68 += _64;
    _51.data[_68] = _67;
    _64++;
    if (_64 < _59)
    goto _jump1473;
    _64 = 0;
    _65++;
    if (_65 < _52)
    goto _jump1473;
    // End body of loop
    _a1_int64_t _69;
    // Computing bound for s
    _69.d0 = d;
    if (d > 0) 
    goto _jump1474;
    fail_assertion("non-positive loop bound");
    _jump1474:;
    // Computing total size of heap memory to allocate
    int64_t _70 = 1;
    _70 *= d;
    _70 *= sizeof(int64_t);
    _69.data = jpl_alloc(_70);
    int64_t _71 = 0; // s
    _jump1475:; // Begin body of loop
    int64_t _72;
    // Computing bound for t
    if (o > 0) 
    goto _jump1476;
    fail_assertion("non-positive loop bound");
    _jump1476:;
    _72 = 0;
    int64_t _73 = 0; // t
    _jump1477:; // Begin body of loop
    _72 += o;
    _73++;
    if (_73 < o)
    goto _jump1477;
    // End body of loop
    int64_t _74 = 0;
    _74 *= _69.d0;
    _74 += _71;
    _69.data[_74] = _72;
    _71++;
    if (_71 < d)
    goto _jump1475;
    // End body of loop
    int64_t _75;
    // Computing bound for s
    int64_t _76 = o + d;
    if (_76 > 0) 
    goto _jump1478;
    fail_assertion("non-positive loop bound");
    _jump1478:;
    // Computing bound for t
    if (c >= 0)
    goto _jump1479;
    fail_assertion("negative array index");
    _jump1479:;
    if (c < l.d0)
    goto _jump1480;
    fail_assertion("index too large");
    _jump1480:;
    int64_t _77 = 0;
    _77 *= l.d0;
    _77 += c;
    int64_t _78 = l.data[_77];
    if (_78 > 0) 
    goto _jump1481;
    fail_assertion("non-positive loop bound");
    _jump1481:;
    _75 = 0;
    int64_t _79 = 0; // t
    int64_t _80 = 0; // s
    _jump1482:; // Begin body of loop
    _75 += g;
    _79++;
    if (_79 < _78)
    goto _jump1482;
    _79 = 0;
    _80++;
    if (_80 < _76)
    goto _jump1482;
    // End body of loop
    if (_75 >= 0)
    goto _jump1483;
    fail_assertion("negative array index");
    _jump1483:;
    if (_75 < _69.d0)
    goto _jump1484;
    fail_assertion("index too large");
    _jump1484:;
    int64_t _81 = 0;
    _81 *= _69.d0;
    _81 += _75;
    int64_t _82 = _69.data[_81];
    if (_82 >= 0)
    goto _jump1485;
    fail_assertion("negative array index");
    _jump1485:;
    if (_82 < _51.d0)
    goto _jump1486;
    fail_assertion("index too large");
    _jump1486:;
    if (o >= 0)
    goto _jump1487;
    fail_assertion("negative array index");
    _jump1487:;
    if (o < _51.d1)
    goto _jump1488;
    fail_assertion("index too large");
    _jump1488:;
    int64_t _83 = 0;
    _83 *= _51.d0;
    _83 += _82;
    _83 *= _51.d1;
    _83 += o;
    bool _84 = _51.data[_83];
    double _85 = a(e);
    if (j >= 0)
    goto _jump1489;
    fail_assertion("negative array index");
    _jump1489:;
    if (j < m.d0)
    goto _jump1490;
    fail_assertion("index too large");
    _jump1490:;
    if (d >= 0)
    goto _jump1491;
    fail_assertion("negative array index");
    _jump1491:;
    if (d < m.d1)
    goto _jump1492;
    fail_assertion("index too large");
    _jump1492:;
    int64_t _86 = 0;
    _86 *= m.d0;
    _86 += j;
    _86 *= m.d1;
    _86 += d;
    double _87 = m.data[_86];
    bool _88 = _85 <= _87;
    bool _89 = !_88;
    bool _90;
    if (!_89)
    goto _jump1493;
    bool _91 = false;
    rgba _92;
    if (!_91)
    goto _jump1494;
    _92 = e;
    goto _jump1495;
    _jump1494:;
    _92 = e;
    _jump1495:;
    double _93 = _92.b;
    void_t _94 = f();
    _a1_void_t _95;
    _95.d0 = 1;
    _95.data = jpl_alloc(sizeof(void_t) * 1);
    _95.data[0] = _94;
    double _96 = k(_95);
    bool _97 = _93 < _96;
    _90 = _97;
    goto _jump1496;
    _jump1493:;
    bool _98 = true;
    _90 = _98;
    _jump1496:;
    bool _99 = _84 == _90;
    int64_t _100;
    if (!_99)
    goto _jump1497;
    int64_t _101 = -j;
    _100 = _101;
    goto _jump1498;
    _jump1497:;
    _100 = j;
    _jump1498:;
    int64_t _102 = 421;
    int64_t _103 = _102 % n;
    int64_t _104 = 371;
    int64_t _105 = _104 - g;
    if (_100 >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (_100 < _50.d0)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    if (_103 >= 0)
    goto _jump1501;
    fail_assertion("negative array index");
    _jump1501:;
    if (_103 < _50.d1)
    goto _jump1502;
    fail_assertion("index too large");
    _jump1502:;
    if (_105 >= 0)
    goto _jump1503;
    fail_assertion("negative array index");
    _jump1503:;
    if (_105 < _50.d2)
    goto _jump1504;
    fail_assertion("index too large");
    _jump1504:;
    int64_t _106 = 0;
    _106 *= _50.d0;
    _106 += _100;
    _106 *= _50.d1;
    _106 += _103;
    _106 *= _50.d2;
    _106 += _105;
    _a3_void_t _107 = _50.data[_106];
    int64_t _108 = 200;
    bool _109 = c <= _108;
    _a2__a3_void_t _110;
    if (!_109)
    goto _jump1505;
    _a1__a3__a2__a3_void_t _111;
    // Computing bound for A
    _111.d0 = q.d1;
    if (q.d1 > 0) 
    goto _jump1506;
    fail_assertion("non-positive loop bound");
    _jump1506:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= q.d1;
    _112 *= sizeof(_a3__a2__a3_void_t);
    _111.data = jpl_alloc(_112);
    int64_t _113 = 0; // A
    _jump1507:; // Begin body of loop
    _a3__a2__a3_void_t _114;
    // Computing bound for B
    _114.d0 = _107.d1;
    if (_107.d1 > 0) 
    goto _jump1508;
    fail_assertion("non-positive loop bound");
    _jump1508:;
    // Computing bound for C
    _114.d1 = _107.d1;
    if (_107.d1 > 0) 
    goto _jump1509;
    fail_assertion("non-positive loop bound");
    _jump1509:;
    // Computing bound for D
    int64_t _115 = -q.d2;
    _114.d2 = _115;
    if (_115 > 0) 
    goto _jump1510;
    fail_assertion("non-positive loop bound");
    _jump1510:;
    // Computing total size of heap memory to allocate
    int64_t _116 = 1;
    _116 *= _107.d1;
    _116 *= _107.d1;
    _116 *= _115;
    _116 *= sizeof(_a2__a3_void_t);
    _114.data = jpl_alloc(_116);
    int64_t _117 = 0; // D
    int64_t _118 = 0; // C
    int64_t _119 = 0; // B
    _jump1511:; // Begin body of loop
    _a2__a3_void_t _120;
    // Computing bound for E
    _120.d0 = o;
    if (o > 0) 
    goto _jump1512;
    fail_assertion("non-positive loop bound");
    _jump1512:;
    // Computing bound for F
    _120.d1 = _107.d0;
    if (_107.d0 > 0) 
    goto _jump1513;
    fail_assertion("non-positive loop bound");
    _jump1513:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= o;
    _121 *= _107.d0;
    _121 *= sizeof(_a3_void_t);
    _120.data = jpl_alloc(_121);
    int64_t _122 = 0; // F
    int64_t _123 = 0; // E
    _jump1514:; // Begin body of loop
    int64_t _124 = 0;
    _124 *= _120.d0;
    _124 += _123;
    _124 *= _120.d1;
    _124 += _122;
    _120.data[_124] = q;
    _122++;
    if (_122 < _107.d0)
    goto _jump1514;
    _122 = 0;
    _123++;
    if (_123 < o)
    goto _jump1514;
    // End body of loop
    int64_t _125 = 0;
    _125 *= _114.d0;
    _125 += _119;
    _125 *= _114.d1;
    _125 += _118;
    _125 *= _114.d2;
    _125 += _117;
    _114.data[_125] = _120;
    _117++;
    if (_117 < _115)
    goto _jump1511;
    _117 = 0;
    _118++;
    if (_118 < _107.d1)
    goto _jump1511;
    _118 = 0;
    _119++;
    if (_119 < _107.d1)
    goto _jump1511;
    // End body of loop
    int64_t _126 = 0;
    _126 *= _111.d0;
    _126 += _113;
    _111.data[_126] = _114;
    _113++;
    if (_113 < q.d1)
    goto _jump1507;
    // End body of loop
    bool _127 = true;
    int64_t _128;
    if (!_127)
    goto _jump1515;
    int64_t _129 = -_107.d0;
    _128 = _129;
    goto _jump1516;
    _jump1515:;
    _128 = c;
    _jump1516:;
    int64_t _130 = -_107.d2;
    int64_t _131 = _128 % _130;
    if (_131 >= 0)
    goto _jump1517;
    fail_assertion("negative array index");
    _jump1517:;
    if (_131 < _111.d0)
    goto _jump1518;
    fail_assertion("index too large");
    _jump1518:;
    int64_t _132 = 0;
    _132 *= _111.d0;
    _132 += _131;
    _a3__a2__a3_void_t _133 = _111.data[_132];
    bool _134 = true;
    bool _135 = !_134;
    _a1_int64_t _136;
    if (!_135)
    goto _jump1519;
    _a1_int64_t _137;
    // Computing bound for A
    _137.d0 = n;
    if (n > 0) 
    goto _jump1520;
    fail_assertion("non-positive loop bound");
    _jump1520:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= n;
    _138 *= sizeof(int64_t);
    _137.data = jpl_alloc(_138);
    int64_t _139 = 0; // A
    _jump1521:; // Begin body of loop
    int64_t _140 = 0;
    _140 *= _137.d0;
    _140 += _139;
    _137.data[_140] = q.d2;
    _139++;
    if (_139 < n)
    goto _jump1521;
    // End body of loop
    _136 = _137;
    goto _jump1522;
    _jump1519:;
    _136 = i;
    _jump1522:;
    int64_t _141 = d / g;
    if (_141 >= 0)
    goto _jump1523;
    fail_assertion("negative array index");
    _jump1523:;
    if (_141 < _136.d0)
    goto _jump1524;
    fail_assertion("index too large");
    _jump1524:;
    int64_t _142 = 0;
    _142 *= _136.d0;
    _142 += _141;
    int64_t _143 = _136.data[_142];
    if (q.d1 >= 0)
    goto _jump1525;
    fail_assertion("negative array index");
    _jump1525:;
    if (q.d1 < _133.d0)
    goto _jump1526;
    fail_assertion("index too large");
    _jump1526:;
    if (q.d0 >= 0)
    goto _jump1527;
    fail_assertion("negative array index");
    _jump1527:;
    if (q.d0 < _133.d1)
    goto _jump1528;
    fail_assertion("index too large");
    _jump1528:;
    if (_143 >= 0)
    goto _jump1529;
    fail_assertion("negative array index");
    _jump1529:;
    if (_143 < _133.d2)
    goto _jump1530;
    fail_assertion("index too large");
    _jump1530:;
    int64_t _144 = 0;
    _144 *= _133.d0;
    _144 += q.d1;
    _144 *= _133.d1;
    _144 += q.d0;
    _144 *= _133.d2;
    _144 += _143;
    _a2__a3_void_t _145 = _133.data[_144];
    _110 = _145;
    goto _jump1531;
    _jump1505:;
    _a2__a3__a2__a3_void_t _146;
    // Computing bound for A
    _146.d0 = q.d0;
    if (q.d0 > 0) 
    goto _jump1532;
    fail_assertion("non-positive loop bound");
    _jump1532:;
    // Computing bound for B
    _146.d1 = q.d2;
    if (q.d2 > 0) 
    goto _jump1533;
    fail_assertion("non-positive loop bound");
    _jump1533:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= q.d0;
    _147 *= q.d2;
    _147 *= sizeof(_a3__a2__a3_void_t);
    _146.data = jpl_alloc(_147);
    int64_t _148 = 0; // B
    int64_t _149 = 0; // A
    _jump1534:; // Begin body of loop
    _a3__a2__a3_void_t _150;
    // Computing bound for C
    _150.d0 = q.d2;
    if (q.d2 > 0) 
    goto _jump1535;
    fail_assertion("non-positive loop bound");
    _jump1535:;
    // Computing bound for D
    _150.d1 = q.d2;
    if (q.d2 > 0) 
    goto _jump1536;
    fail_assertion("non-positive loop bound");
    _jump1536:;
    // Computing bound for E
    _150.d2 = q.d0;
    if (q.d0 > 0) 
    goto _jump1537;
    fail_assertion("non-positive loop bound");
    _jump1537:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= q.d2;
    _151 *= q.d2;
    _151 *= q.d0;
    _151 *= sizeof(_a2__a3_void_t);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // E
    int64_t _153 = 0; // D
    int64_t _154 = 0; // C
    _jump1538:; // Begin body of loop
    _a2__a3_void_t _155;
    // Computing bound for F
    _155.d0 = g;
    if (g > 0) 
    goto _jump1539;
    fail_assertion("non-positive loop bound");
    _jump1539:;
    // Computing bound for G
    _155.d1 = _148;
    if (_148 > 0) 
    goto _jump1540;
    fail_assertion("non-positive loop bound");
    _jump1540:;
    // Computing total size of heap memory to allocate
    int64_t _156 = 1;
    _156 *= g;
    _156 *= _148;
    _156 *= sizeof(_a3_void_t);
    _155.data = jpl_alloc(_156);
    int64_t _157 = 0; // G
    int64_t _158 = 0; // F
    _jump1541:; // Begin body of loop
    int64_t _159 = 0;
    _159 *= _155.d0;
    _159 += _158;
    _159 *= _155.d1;
    _159 += _157;
    _155.data[_159] = q;
    _157++;
    if (_157 < _148)
    goto _jump1541;
    _157 = 0;
    _158++;
    if (_158 < g)
    goto _jump1541;
    // End body of loop
    int64_t _160 = 0;
    _160 *= _150.d0;
    _160 += _154;
    _160 *= _150.d1;
    _160 += _153;
    _160 *= _150.d2;
    _160 += _152;
    _150.data[_160] = _155;
    _152++;
    if (_152 < q.d0)
    goto _jump1538;
    _152 = 0;
    _153++;
    if (_153 < q.d2)
    goto _jump1538;
    _153 = 0;
    _154++;
    if (_154 < q.d2)
    goto _jump1538;
    // End body of loop
    int64_t _161 = 0;
    _161 *= _146.d0;
    _161 += _149;
    _161 *= _146.d1;
    _161 += _148;
    _146.data[_161] = _150;
    _148++;
    if (_148 < q.d2)
    goto _jump1534;
    _148 = 0;
    _149++;
    if (_149 < q.d0)
    goto _jump1534;
    // End body of loop
    if (q.d0 >= 0)
    goto _jump1542;
    fail_assertion("negative array index");
    _jump1542:;
    if (q.d0 < _146.d0)
    goto _jump1543;
    fail_assertion("index too large");
    _jump1543:;
    if (_107.d0 >= 0)
    goto _jump1544;
    fail_assertion("negative array index");
    _jump1544:;
    if (_107.d0 < _146.d1)
    goto _jump1545;
    fail_assertion("index too large");
    _jump1545:;
    int64_t _162 = 0;
    _162 *= _146.d0;
    _162 += q.d0;
    _162 *= _146.d1;
    _162 += _107.d0;
    _a3__a2__a3_void_t _163 = _146.data[_162];
    int64_t _164 = 938;
    if (q.d1 >= 0)
    goto _jump1546;
    fail_assertion("negative array index");
    _jump1546:;
    if (q.d1 < _163.d0)
    goto _jump1547;
    fail_assertion("index too large");
    _jump1547:;
    if (q.d1 >= 0)
    goto _jump1548;
    fail_assertion("negative array index");
    _jump1548:;
    if (q.d1 < _163.d1)
    goto _jump1549;
    fail_assertion("index too large");
    _jump1549:;
    if (_164 >= 0)
    goto _jump1550;
    fail_assertion("negative array index");
    _jump1550:;
    if (_164 < _163.d2)
    goto _jump1551;
    fail_assertion("index too large");
    _jump1551:;
    int64_t _165 = 0;
    _165 *= _163.d0;
    _165 += q.d1;
    _165 *= _163.d1;
    _165 += q.d1;
    _165 *= _163.d2;
    _165 += _164;
    _a2__a3_void_t _166 = _163.data[_165];
    _110 = _166;
    _jump1531:;
    int64_t _167;
    // Computing bound for A
    if (d > 0) 
    goto _jump1552;
    fail_assertion("non-positive loop bound");
    _jump1552:;
    // Computing bound for B
    if (g > 0) 
    goto _jump1553;
    fail_assertion("non-positive loop bound");
    _jump1553:;
    _167 = 0;
    int64_t _168 = 0; // B
    int64_t _169 = 0; // A
    _jump1554:; // Begin body of loop
    _167 += j;
    _168++;
    if (_168 < g)
    goto _jump1554;
    _168 = 0;
    _169++;
    if (_169 < d)
    goto _jump1554;
    // End body of loop
    if (q.d2 >= 0)
    goto _jump1555;
    fail_assertion("negative array index");
    _jump1555:;
    if (q.d2 < _110.d0)
    goto _jump1556;
    fail_assertion("index too large");
    _jump1556:;
    if (_167 >= 0)
    goto _jump1557;
    fail_assertion("negative array index");
    _jump1557:;
    if (_167 < _110.d1)
    goto _jump1558;
    fail_assertion("index too large");
    _jump1558:;
    int64_t _170 = 0;
    _170 *= _110.d0;
    _170 += q.d2;
    _170 *= _110.d1;
    _170 += _167;
    _a3_void_t _171 = _110.data[_170];
    bool _173 = true;
    bool _172 = _173;
    if (0 == _173)
    goto _jump1559;
    bool _174 = _171.d2 != g;
    _172 = _174;
    _jump1559:;
    bool _175;
    if (!_172)
    goto _jump1560;
    bool _177 = true;
    bool _176 = _177;
    if (0 == _177)
    goto _jump1561;
    if (o >= 0)
    goto _jump1562;
    fail_assertion("negative array index");
    _jump1562:;
    if (o < l.d0)
    goto _jump1563;
    fail_assertion("index too large");
    _jump1563:;
    int64_t _178 = 0;
    _178 *= l.d0;
    _178 += o;
    int64_t _179 = l.data[_178];
    bool _180 = false;
    _a3_int64_t _181;
    if (!_180)
    goto _jump1564;
    _a3_int64_t _182;
    // Computing bound for E
    int64_t _183 = 982;
    _182.d0 = _183;
    if (_183 > 0) 
    goto _jump1565;
    fail_assertion("non-positive loop bound");
    _jump1565:;
    // Computing bound for F
    _182.d1 = n;
    if (n > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    // Computing bound for G
    _182.d2 = c;
    if (c > 0) 
    goto _jump1567;
    fail_assertion("non-positive loop bound");
    _jump1567:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= _183;
    _184 *= n;
    _184 *= c;
    _184 *= sizeof(int64_t);
    _182.data = jpl_alloc(_184);
    int64_t _185 = 0; // G
    int64_t _186 = 0; // F
    int64_t _187 = 0; // E
    _jump1568:; // Begin body of loop
    int64_t _188 = 0;
    _188 *= _182.d0;
    _188 += _187;
    _188 *= _182.d1;
    _188 += _186;
    _188 *= _182.d2;
    _188 += _185;
    _182.data[_188] = _187;
    _185++;
    if (_185 < c)
    goto _jump1568;
    _185 = 0;
    _186++;
    if (_186 < n)
    goto _jump1568;
    _186 = 0;
    _187++;
    if (_187 < _183)
    goto _jump1568;
    // End body of loop
    _181 = _182;
    goto _jump1569;
    _jump1564:;
    _a3_int64_t _189;
    // Computing bound for E
    _189.d0 = j;
    if (j > 0) 
    goto _jump1570;
    fail_assertion("non-positive loop bound");
    _jump1570:;
    // Computing bound for F
    _189.d1 = _171.d2;
    if (_171.d2 > 0) 
    goto _jump1571;
    fail_assertion("non-positive loop bound");
    _jump1571:;
    // Computing bound for G
    _189.d2 = o;
    if (o > 0) 
    goto _jump1572;
    fail_assertion("non-positive loop bound");
    _jump1572:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= j;
    _190 *= _171.d2;
    _190 *= o;
    _190 *= sizeof(int64_t);
    _189.data = jpl_alloc(_190);
    int64_t _191 = 0; // G
    int64_t _192 = 0; // F
    int64_t _193 = 0; // E
    _jump1573:; // Begin body of loop
    int64_t _194 = 0;
    _194 *= _189.d0;
    _194 += _193;
    _194 *= _189.d1;
    _194 += _192;
    _194 *= _189.d2;
    _194 += _191;
    _189.data[_194] = c;
    _191++;
    if (_191 < o)
    goto _jump1573;
    _191 = 0;
    _192++;
    if (_192 < _171.d2)
    goto _jump1573;
    _192 = 0;
    _193++;
    if (_193 < j)
    goto _jump1573;
    // End body of loop
    _181 = _189;
    _jump1569:;
    _a1_int64_t _195;
    _195.d0 = 1;
    _195.data = jpl_alloc(sizeof(int64_t) * 1);
    _195.data[0] = q.d2;
    if (q.d0 >= 0)
    goto _jump1574;
    fail_assertion("negative array index");
    _jump1574:;
    if (q.d0 < _195.d0)
    goto _jump1575;
    fail_assertion("index too large");
    _jump1575:;
    int64_t _196 = 0;
    _196 *= _195.d0;
    _196 += q.d0;
    int64_t _197 = _195.data[_196];
    if (_197 >= 0)
    goto _jump1576;
    fail_assertion("negative array index");
    _jump1576:;
    if (_197 < _181.d0)
    goto _jump1577;
    fail_assertion("index too large");
    _jump1577:;
    if (_107.d1 >= 0)
    goto _jump1578;
    fail_assertion("negative array index");
    _jump1578:;
    if (_107.d1 < _181.d1)
    goto _jump1579;
    fail_assertion("index too large");
    _jump1579:;
    if (c >= 0)
    goto _jump1580;
    fail_assertion("negative array index");
    _jump1580:;
    if (c < _181.d2)
    goto _jump1581;
    fail_assertion("index too large");
    _jump1581:;
    int64_t _198 = 0;
    _198 *= _181.d0;
    _198 += _197;
    _198 *= _181.d1;
    _198 += _107.d1;
    _198 *= _181.d2;
    _198 += c;
    int64_t _199 = _181.data[_198];
    bool _200 = _179 != _199;
    _176 = _200;
    _jump1561:;
    _175 = _176;
    goto _jump1582;
    _jump1560:;
    _a1_double _201;
    // Computing bound for E
    _201.d0 = _171.d1;
    if (_171.d1 > 0) 
    goto _jump1583;
    fail_assertion("non-positive loop bound");
    _jump1583:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _171.d1;
    _202 *= sizeof(double);
    _201.data = jpl_alloc(_202);
    int64_t _203 = 0; // E
    _jump1584:; // Begin body of loop
    double _204;
    // Computing bound for F
    int64_t _205 = 335;
    if (_205 > 0) 
    goto _jump1585;
    fail_assertion("non-positive loop bound");
    _jump1585:;
    // Computing bound for G
    if (c > 0) 
    goto _jump1586;
    fail_assertion("non-positive loop bound");
    _jump1586:;
    _204 = 0;
    int64_t _206 = 0; // G
    int64_t _207 = 0; // F
    _jump1587:; // Begin body of loop
    _204 += r;
    _206++;
    if (_206 < c)
    goto _jump1587;
    _206 = 0;
    _207++;
    if (_207 < _205)
    goto _jump1587;
    // End body of loop
    int64_t _208 = 0;
    _208 *= _201.d0;
    _208 += _203;
    _201.data[_208] = _204;
    _203++;
    if (_203 < _171.d1)
    goto _jump1584;
    // End body of loop
    if (g >= 0)
    goto _jump1588;
    fail_assertion("negative array index");
    _jump1588:;
    if (g < _201.d0)
    goto _jump1589;
    fail_assertion("index too large");
    _jump1589:;
    int64_t _209 = 0;
    _209 *= _201.d0;
    _209 += g;
    double _210 = _201.data[_209];
    if (q.d1 >= 0)
    goto _jump1590;
    fail_assertion("negative array index");
    _jump1590:;
    if (q.d1 < m.d0)
    goto _jump1591;
    fail_assertion("index too large");
    _jump1591:;
    if (q.d0 >= 0)
    goto _jump1592;
    fail_assertion("negative array index");
    _jump1592:;
    if (q.d0 < m.d1)
    goto _jump1593;
    fail_assertion("index too large");
    _jump1593:;
    int64_t _211 = 0;
    _211 *= m.d0;
    _211 += q.d1;
    _211 *= m.d1;
    _211 += q.d0;
    double _212 = m.data[_211];
    double _213 = _210 - _212;
    bool _214 = p(q, _213);
    _175 = _214;
    _jump1582:;
    bool _215 = !_175;
    return _215;
    _a3__a1_int64_t _216;
    // Computing bound for E
    _216.d0 = d;
    if (d > 0) 
    goto _jump1594;
    fail_assertion("non-positive loop bound");
    _jump1594:;
    // Computing bound for F
    _216.d1 = d;
    if (d > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing bound for G
    _216.d2 = n;
    if (n > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= d;
    _217 *= d;
    _217 *= n;
    _217 *= sizeof(_a1_int64_t);
    _216.data = jpl_alloc(_217);
    int64_t _218 = 0; // G
    int64_t _219 = 0; // F
    int64_t _220 = 0; // E
    _jump1597:; // Begin body of loop
    int64_t _221 = 0;
    _221 *= _216.d0;
    _221 += _220;
    _221 *= _216.d1;
    _221 += _219;
    _221 *= _216.d2;
    _221 += _218;
    _216.data[_221] = l;
    _218++;
    if (_218 < n)
    goto _jump1597;
    _218 = 0;
    _219++;
    if (_219 < d)
    goto _jump1597;
    _219 = 0;
    _220++;
    if (_220 < d)
    goto _jump1597;
    // End body of loop
    bool _222 = false;
    return _222;
}

double s(rgba t, _a2_rgba u, void_t v) {
    _a3_void_t _0;
    // Computing bound for y
    _0.d0 = r;
    if (r > 0) 
    goto _jump1661;
    fail_assertion("non-positive loop bound");
    _jump1661:;
    // Computing bound for z
    _0.d1 = g;
    if (g > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    // Computing bound for A
    int64_t _1;
    // Computing bound for y
    if (n > 0) 
    goto _jump1663;
    fail_assertion("non-positive loop bound");
    _jump1663:;
    _1 = 0;
    int64_t _2 = 0; // y
    _jump1664:; // Begin body of loop
    _1 += n;
    _2++;
    if (_2 < n)
    goto _jump1664;
    // End body of loop
    _0.d2 = _1;
    if (_1 > 0) 
    goto _jump1665;
    fail_assertion("non-positive loop bound");
    _jump1665:;
    // Computing total size of heap memory to allocate
    int64_t _3 = 1;
    _3 *= r;
    _3 *= g;
    _3 *= _1;
    _3 *= sizeof(void_t);
    _0.data = jpl_alloc(_3);
    int64_t _4 = 0; // A
    int64_t _5 = 0; // z
    int64_t _6 = 0; // y
    _jump1666:; // Begin body of loop
    bool _7 = false;
    void_t _8;
    if (!_7)
    goto _jump1667;
    void_t _9 = f();
    _8 = _9;
    goto _jump1668;
    _jump1667:;
    void_t _10 = f();
    _8 = _10;
    _jump1668:;
    int64_t _11 = 0;
    _11 *= _0.d0;
    _11 += _6;
    _11 *= _0.d1;
    _11 += _5;
    _11 *= _0.d2;
    _11 += _4;
    _0.data[_11] = _8;
    _4++;
    if (_4 < _1)
    goto _jump1666;
    _4 = 0;
    _5++;
    if (_5 < g)
    goto _jump1666;
    _5 = 0;
    _6++;
    if (_6 < r)
    goto _jump1666;
    // End body of loop
    bool _12 = p(_0, h);
    double _13;
    if (!_12)
    goto _jump1669;
    bool _14 = c <= n;
    bool _15 = !_14;
    _a1_void_t _16;
    if (!_15)
    goto _jump1670;
    _a1_void_t _17;
    // Computing bound for y
    _17.d0 = j;
    if (j > 0) 
    goto _jump1671;
    fail_assertion("non-positive loop bound");
    _jump1671:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= j;
    _18 *= sizeof(void_t);
    _17.data = jpl_alloc(_18);
    int64_t _19 = 0; // y
    _jump1672:; // Begin body of loop
    void_t _20 = f();
    int64_t _21 = 0;
    _21 *= _17.d0;
    _21 += _19;
    _17.data[_21] = _20;
    _19++;
    if (_19 < j)
    goto _jump1672;
    // End body of loop
    _16 = _17;
    goto _jump1673;
    _jump1670:;
    bool _22 = true;
    _a1_void_t _23;
    if (!_22)
    goto _jump1674;
    _a1_void_t _24;
    // Computing bound for y
    _24.d0 = q.d0;
    if (q.d0 > 0) 
    goto _jump1675;
    fail_assertion("non-positive loop bound");
    _jump1675:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= q.d0;
    _25 *= sizeof(void_t);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // y
    _jump1676:; // Begin body of loop
    void_t _27 = f();
    int64_t _28 = 0;
    _28 *= _24.d0;
    _28 += _26;
    _24.data[_28] = _27;
    _26++;
    if (_26 < q.d0)
    goto _jump1676;
    // End body of loop
    _23 = _24;
    goto _jump1677;
    _jump1674:;
    _23 = q;
    _jump1677:;
    _16 = _23;
    _jump1673:;
    double _29 = k(_16);
    double _30 = -_29;
    _13 = _30;
    goto _jump1678;
    _jump1669:;
    _a2_rgba _31;
    // Computing bound for y
    int64_t _32;
    // Computing bound for y
    int64_t _33 = 152;
    if (_33 >= 0)
    goto _jump1679;
    fail_assertion("negative array index");
    _jump1679:;
    if (_33 < l.d0)
    goto _jump1680;
    fail_assertion("index too large");
    _jump1680:;
    int64_t _34 = 0;
    _34 *= l.d0;
    _34 += _33;
    int64_t _35 = l.data[_34];
    if (_35 > 0) 
    goto _jump1681;
    fail_assertion("non-positive loop bound");
    _jump1681:;
    // Computing bound for z
    if (j > 0) 
    goto _jump1682;
    fail_assertion("non-positive loop bound");
    _jump1682:;
    _32 = 0;
    int64_t _36 = 0; // z
    int64_t _37 = 0; // y
    _jump1683:; // Begin body of loop
    _32 += _36;
    _36++;
    if (_36 < j)
    goto _jump1683;
    _36 = 0;
    _37++;
    if (_37 < _35)
    goto _jump1683;
    // End body of loop
    int64_t _38 = -_32;
    _31.d0 = _38;
    if (_38 > 0) 
    goto _jump1684;
    fail_assertion("non-positive loop bound");
    _jump1684:;
    // Computing bound for z
    int64_t _39 = -o;
    int64_t _40 = 372;
    int64_t _41 = _40 * n;
    bool _42 = _39 >= _41;
    int64_t _43;
    if (!_42)
    goto _jump1685;
    int64_t _44 = -n;
    _43 = _44;
    goto _jump1686;
    _jump1685:;
    int64_t _45 = 689;
    int64_t _46;
    // Computing bound for y
    if (q.d0 > 0) 
    goto _jump1687;
    fail_assertion("non-positive loop bound");
    _jump1687:;
    // Computing bound for z
    if (d > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    _46 = 0;
    int64_t _47 = 0; // z
    int64_t _48 = 0; // y
    _jump1689:; // Begin body of loop
    _46 += d;
    _47++;
    if (_47 < d)
    goto _jump1689;
    _47 = 0;
    _48++;
    if (_48 < q.d0)
    goto _jump1689;
    // End body of loop
    int64_t _49 = _45 / _46;
    _43 = _49;
    _jump1686:;
    _31.d1 = _43;
    if (_43 > 0) 
    goto _jump1690;
    fail_assertion("non-positive loop bound");
    _jump1690:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= _38;
    _50 *= _43;
    _50 *= sizeof(rgba);
    _31.data = jpl_alloc(_50);
    int64_t _51 = 0; // z
    int64_t _52 = 0; // y
    _jump1691:; // Begin body of loop
    int64_t _53 = 0;
    _53 *= _31.d0;
    _53 += _52;
    _53 *= _31.d1;
    _53 += _51;
    _31.data[_53] = e;
    _51++;
    if (_51 < _43)
    goto _jump1691;
    _51 = 0;
    _52++;
    if (_52 < _38)
    goto _jump1691;
    // End body of loop
    void_t _54 = f();
    double _55 = s(e, _31, _54);
    _13 = _55;
    _jump1678:;
    double _56 = -_13;
    double _57 = 62.0;
    return _57;
    _a1_int64_t _58;
    // Computing bound for z
    _a2_bool _59;
    // Computing bound for z
    _59.d0 = r;
    if (r > 0) 
    goto _jump1692;
    fail_assertion("non-positive loop bound");
    _jump1692:;
    // Computing bound for A
    _59.d1 = n;
    if (n > 0) 
    goto _jump1693;
    fail_assertion("non-positive loop bound");
    _jump1693:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= r;
    _60 *= n;
    _60 *= sizeof(bool);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // A
    int64_t _62 = 0; // z
    _jump1694:; // Begin body of loop
    bool _63 = false;
    int64_t _64 = 0;
    _64 *= _59.d0;
    _64 += _62;
    _64 *= _59.d1;
    _64 += _61;
    _59.data[_64] = _63;
    _61++;
    if (_61 < n)
    goto _jump1694;
    _61 = 0;
    _62++;
    if (_62 < r)
    goto _jump1694;
    // End body of loop
    int64_t _65 = q.d0 - c;
    int64_t _66;
    // Computing bound for z
    int64_t _67 = 729;
    if (_67 > 0) 
    goto _jump1695;
    fail_assertion("non-positive loop bound");
    _jump1695:;
    // Computing bound for A
    bool _68 = h > _56;
    int64_t _69;
    if (!_68)
    goto _jump1696;
    bool _70 = false;
    int64_t _71;
    if (!_70)
    goto _jump1697;
    _71 = g;
    goto _jump1698;
    _jump1697:;
    _71 = c;
    _jump1698:;
    _69 = _71;
    goto _jump1699;
    _jump1696:;
    _69 = d;
    _jump1699:;
    if (_69 > 0) 
    goto _jump1700;
    fail_assertion("non-positive loop bound");
    _jump1700:;
    // Computing bound for B
    if (d > 0) 
    goto _jump1701;
    fail_assertion("non-positive loop bound");
    _jump1701:;
    _66 = 0;
    int64_t _72 = 0; // B
    int64_t _73 = 0; // A
    int64_t _74 = 0; // z
    _jump1702:; // Begin body of loop
    _66 += _73;
    _72++;
    if (_72 < d)
    goto _jump1702;
    _72 = 0;
    _73++;
    if (_73 < _69)
    goto _jump1702;
    _73 = 0;
    _74++;
    if (_74 < _67)
    goto _jump1702;
    // End body of loop
    if (_65 >= 0)
    goto _jump1703;
    fail_assertion("negative array index");
    _jump1703:;
    if (_65 < _59.d0)
    goto _jump1704;
    fail_assertion("index too large");
    _jump1704:;
    if (_66 >= 0)
    goto _jump1705;
    fail_assertion("negative array index");
    _jump1705:;
    if (_66 < _59.d1)
    goto _jump1706;
    fail_assertion("index too large");
    _jump1706:;
    int64_t _75 = 0;
    _75 *= _59.d0;
    _75 += _65;
    _75 *= _59.d1;
    _75 += _66;
    bool _76 = _59.data[_75];
    bool _77 = !_76;
    int64_t _78;
    if (!_77)
    goto _jump1707;
    _78 = o;
    goto _jump1708;
    _jump1707:;
    int64_t _79;
    // Computing bound for z
    if (d > 0) 
    goto _jump1709;
    fail_assertion("non-positive loop bound");
    _jump1709:;
    // Computing bound for A
    int64_t _80;
    // Computing bound for z
    if (n > 0) 
    goto _jump1710;
    fail_assertion("non-positive loop bound");
    _jump1710:;
    _80 = 0;
    int64_t _81 = 0; // z
    _jump1711:; // Begin body of loop
    int64_t _82 = d * c;
    _80 += _82;
    _81++;
    if (_81 < n)
    goto _jump1711;
    // End body of loop
    if (_80 > 0) 
    goto _jump1712;
    fail_assertion("non-positive loop bound");
    _jump1712:;
    _79 = 0;
    int64_t _83 = 0; // A
    int64_t _84 = 0; // z
    _jump1713:; // Begin body of loop
    _79 += q.d0;
    _83++;
    if (_83 < _80)
    goto _jump1713;
    _83 = 0;
    _84++;
    if (_84 < d)
    goto _jump1713;
    // End body of loop
    int64_t _85 = -_79;
    _78 = _85;
    _jump1708:;
    _58.d0 = _78;
    if (_78 > 0) 
    goto _jump1714;
    fail_assertion("non-positive loop bound");
    _jump1714:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= _78;
    _86 *= sizeof(int64_t);
    _58.data = jpl_alloc(_86);
    int64_t _87 = 0; // z
    _jump1715:; // Begin body of loop
    int64_t _88 = 581;
    int64_t _89 = 0;
    _89 *= _58.d0;
    _89 += _87;
    _58.data[_89] = _88;
    _87++;
    if (_87 < _78)
    goto _jump1715;
    // End body of loop
    double _91 = 58.0;
    bool _92 = _56 != _91;
    bool _90 = _92;
    if (0 == _92)
    goto _jump1716;
    _a2_bool _93;
    // Computing bound for B
    int64_t _94;
    // Computing bound for B
    int64_t _95 = -n;
    if (_95 > 0) 
    goto _jump1717;
    fail_assertion("non-positive loop bound");
    _jump1717:;
    // Computing bound for C
    if (c > 0) 
    goto _jump1718;
    fail_assertion("non-positive loop bound");
    _jump1718:;
    // Computing bound for D
    if (g > 0) 
    goto _jump1719;
    fail_assertion("non-positive loop bound");
    _jump1719:;
    _94 = 0;
    int64_t _96 = 0; // D
    int64_t _97 = 0; // C
    int64_t _98 = 0; // B
    _jump1720:; // Begin body of loop
    int64_t _99;
    // Computing bound for E
    bool _100 = _96 > r;
    int64_t _101;
    if (!_100)
    goto _jump1721;
    _101 = d;
    goto _jump1722;
    _jump1721:;
    _101 = o;
    _jump1722:;
    if (_101 > 0) 
    goto _jump1723;
    fail_assertion("non-positive loop bound");
    _jump1723:;
    _99 = 0;
    int64_t _102 = 0; // E
    _jump1724:; // Begin body of loop
    _99 += g;
    _102++;
    if (_102 < _101)
    goto _jump1724;
    // End body of loop
    _94 += _99;
    _96++;
    if (_96 < g)
    goto _jump1720;
    _96 = 0;
    _97++;
    if (_97 < c)
    goto _jump1720;
    _97 = 0;
    _98++;
    if (_98 < _95)
    goto _jump1720;
    // End body of loop
    _93.d0 = _94;
    if (_94 > 0) 
    goto _jump1725;
    fail_assertion("non-positive loop bound");
    _jump1725:;
    // Computing bound for C
    _93.d1 = j;
    if (j > 0) 
    goto _jump1726;
    fail_assertion("non-positive loop bound");
    _jump1726:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= _94;
    _103 *= j;
    _103 *= sizeof(bool);
    _93.data = jpl_alloc(_103);
    int64_t _104 = 0; // C
    int64_t _105 = 0; // B
    _jump1727:; // Begin body of loop
    _a3_void_t _106;
    // Computing bound for D
    _106.d0 = q.d0;
    if (q.d0 > 0) 
    goto _jump1728;
    fail_assertion("non-positive loop bound");
    _jump1728:;
    // Computing bound for E
    _106.d1 = n;
    if (n > 0) 
    goto _jump1729;
    fail_assertion("non-positive loop bound");
    _jump1729:;
    // Computing bound for F
    int64_t _107 = 826;
    _106.d2 = _107;
    if (_107 > 0) 
    goto _jump1730;
    fail_assertion("non-positive loop bound");
    _jump1730:;
    // Computing total size of heap memory to allocate
    int64_t _108 = 1;
    _108 *= q.d0;
    _108 *= n;
    _108 *= _107;
    _108 *= sizeof(void_t);
    _106.data = jpl_alloc(_108);
    int64_t _109 = 0; // F
    int64_t _110 = 0; // E
    int64_t _111 = 0; // D
    _jump1731:; // Begin body of loop
    int64_t _112 = 0;
    _112 *= _106.d0;
    _112 += _111;
    _112 *= _106.d1;
    _112 += _110;
    _112 *= _106.d2;
    _112 += _109;
    _106.data[_112] = v;
    _109++;
    if (_109 < _107)
    goto _jump1731;
    _109 = 0;
    _110++;
    if (_110 < n)
    goto _jump1731;
    _110 = 0;
    _111++;
    if (_111 < q.d0)
    goto _jump1731;
    // End body of loop
    double _113 = 7.0;
    double _114 = -_113;
    bool _115 = p(_106, _114);
    int64_t _116 = 0;
    _116 *= _93.d0;
    _116 += _105;
    _116 *= _93.d1;
    _116 += _104;
    _93.data[_116] = _115;
    _104++;
    if (_104 < j)
    goto _jump1727;
    _104 = 0;
    _105++;
    if (_105 < _94)
    goto _jump1727;
    // End body of loop
    if (o >= 0)
    goto _jump1732;
    fail_assertion("negative array index");
    _jump1732:;
    if (o < _93.d0)
    goto _jump1733;
    fail_assertion("index too large");
    _jump1733:;
    if (n >= 0)
    goto _jump1734;
    fail_assertion("negative array index");
    _jump1734:;
    if (n < _93.d1)
    goto _jump1735;
    fail_assertion("index too large");
    _jump1735:;
    int64_t _117 = 0;
    _117 *= _93.d0;
    _117 += o;
    _117 *= _93.d1;
    _117 += n;
    bool _118 = _93.data[_117];
    _90 = _118;
    _jump1716:;
    if (0 != _90)
    goto _jump1736;
    fail_assertion("B");
    _jump1736:;
    return _56;
}

bool t(_a3_int64_t u) {
    bool _0 = false;
    return _0;
    _a2_rgba _2;
    // Computing bound for y
    int64_t _3 = 640;
    _2.d0 = _3;
    if (_3 > 0) 
    goto _jump1737;
    fail_assertion("non-positive loop bound");
    _jump1737:;
    // Computing bound for z
    int64_t _4 = o * j;
    _2.d1 = _4;
    if (_4 > 0) 
    goto _jump1738;
    fail_assertion("non-positive loop bound");
    _jump1738:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= _3;
    _5 *= _4;
    _5 *= sizeof(rgba);
    _2.data = jpl_alloc(_5);
    int64_t _6 = 0; // z
    int64_t _7 = 0; // y
    _jump1739:; // Begin body of loop
    int64_t _8 = 0;
    _8 *= _2.d0;
    _8 += _7;
    _8 *= _2.d1;
    _8 += _6;
    _2.data[_8] = e;
    _6++;
    if (_6 < _4)
    goto _jump1739;
    _6 = 0;
    _7++;
    if (_7 < _3)
    goto _jump1739;
    // End body of loop
    bool _9 = u.d1 <= u.d1;
    void_t _10;
    if (!_9)
    goto _jump1740;
    void_t _11 = f();
    _10 = _11;
    goto _jump1741;
    _jump1740:;
    void_t _12 = f();
    _10 = _12;
    _jump1741:;
    double _13 = s(e, _2, _10);
    bool _14 = t(u);
    rgba _15;
    if (!_14)
    goto _jump1742;
    double _16 = k(q);
    _a2_rgba _17;
    // Computing bound for y
    _17.d0 = g;
    if (g > 0) 
    goto _jump1743;
    fail_assertion("non-positive loop bound");
    _jump1743:;
    // Computing bound for z
    _17.d1 = o;
    if (o > 0) 
    goto _jump1744;
    fail_assertion("non-positive loop bound");
    _jump1744:;
    // Computing total size of heap memory to allocate
    int64_t _18 = 1;
    _18 *= g;
    _18 *= o;
    _18 *= sizeof(rgba);
    _17.data = jpl_alloc(_18);
    int64_t _19 = 0; // z
    int64_t _20 = 0; // y
    _jump1745:; // Begin body of loop
    int64_t _21 = 0;
    _21 *= _17.d0;
    _21 += _20;
    _21 *= _17.d1;
    _21 += _19;
    _17.data[_21] = e;
    _19++;
    if (_19 < o)
    goto _jump1745;
    _19 = 0;
    _20++;
    if (_20 < g)
    goto _jump1745;
    // End body of loop
    void_t _22 = f();
    double _23 = s(e, _17, _22);
    double _24 = e.r;
    double _25 = _24 / h;
    _a1_double _26;
    // Computing bound for y
    _26.d0 = u.d1;
    if (u.d1 > 0) 
    goto _jump1746;
    fail_assertion("non-positive loop bound");
    _jump1746:;
    // Computing total size of heap memory to allocate
    int64_t _27 = 1;
    _27 *= u.d1;
    _27 *= sizeof(double);
    _26.data = jpl_alloc(_27);
    int64_t _28 = 0; // y
    _jump1747:; // Begin body of loop
    int64_t _29 = 0;
    _29 *= _26.d0;
    _29 += _28;
    _26.data[_29] = h;
    _28++;
    if (_28 < u.d1)
    goto _jump1747;
    // End body of loop
    if (o >= 0)
    goto _jump1748;
    fail_assertion("negative array index");
    _jump1748:;
    if (o < _26.d0)
    goto _jump1749;
    fail_assertion("index too large");
    _jump1749:;
    int64_t _30 = 0;
    _30 *= _26.d0;
    _30 += o;
    double _31 = _26.data[_30];
    rgba _32 = { _16, _23, _25, _31 };
    _15 = _32;
    goto _jump1750;
    _jump1742:;
    double _33 = e.r;
    double _34 = e.g;
    double _35 = _33 - _34;
    double _36 = a(e);
    double _37 = -_36;
    double _38 = a(e);
    double _39 = e.g;
    rgba _40 = { _35, _37, _38, _39 };
    _15 = _40;
    _jump1750:;
    double _41 = _15.a;
    bool _42 = _13 >= _41;
    bool _1 = _42;
    if (0 != _42)
    goto _jump1751;
    bool _43 = false;
    bool _44 = o <= u.d1;
    bool _45;
    if (!_44)
    goto _jump1752;
    bool _46 = true;
    _45 = _46;
    goto _jump1753;
    _jump1752:;
    int64_t _47 = -r;
    bool _48 = j <= _47;
    _45 = _48;
    _jump1753:;
    bool _49 = _43 != _45;
    bool _50 = !_49;
    bool _51;
    if (!_50)
    goto _jump1754;
    bool _52 = d < g;
    _51 = _52;
    goto _jump1755;
    _jump1754:;
    _a2_bool _53;
    // Computing bound for y
    _53.d0 = j;
    if (j > 0) 
    goto _jump1756;
    fail_assertion("non-positive loop bound");
    _jump1756:;
    // Computing bound for z
    _53.d1 = d;
    if (d > 0) 
    goto _jump1757;
    fail_assertion("non-positive loop bound");
    _jump1757:;
    // Computing total size of heap memory to allocate
    int64_t _54 = 1;
    _54 *= j;
    _54 *= d;
    _54 *= sizeof(bool);
    _53.data = jpl_alloc(_54);
    int64_t _55 = 0; // z
    int64_t _56 = 0; // y
    _jump1758:; // Begin body of loop
    bool _57 = u.d2 >= u.d0;
    int64_t _58 = 0;
    _58 *= _53.d0;
    _58 += _56;
    _58 *= _53.d1;
    _58 += _55;
    _53.data[_58] = _57;
    _55++;
    if (_55 < d)
    goto _jump1758;
    _55 = 0;
    _56++;
    if (_56 < j)
    goto _jump1758;
    // End body of loop
    _a1__a2_bool _59;
    _59.d0 = 1;
    _59.data = jpl_alloc(sizeof(_a2_bool) * 1);
    _59.data[0] = _53;
    int64_t _60 = 831;
    if (_60 >= 0)
    goto _jump1759;
    fail_assertion("negative array index");
    _jump1759:;
    if (_60 < _59.d0)
    goto _jump1760;
    fail_assertion("index too large");
    _jump1760:;
    int64_t _61 = 0;
    _61 *= _59.d0;
    _61 += _60;
    _a2_bool _62 = _59.data[_61];
    int64_t _63;
    // Computing bound for y
    if (u.d2 > 0) 
    goto _jump1761;
    fail_assertion("non-positive loop bound");
    _jump1761:;
    // Computing bound for z
    if (o > 0) 
    goto _jump1762;
    fail_assertion("non-positive loop bound");
    _jump1762:;
    _63 = 0;
    int64_t _64 = 0; // z
    int64_t _65 = 0; // y
    _jump1763:; // Begin body of loop
    _63 += g;
    _64++;
    if (_64 < o)
    goto _jump1763;
    _64 = 0;
    _65++;
    if (_65 < u.d2)
    goto _jump1763;
    // End body of loop
    if (c >= 0)
    goto _jump1764;
    fail_assertion("negative array index");
    _jump1764:;
    if (c < _62.d0)
    goto _jump1765;
    fail_assertion("index too large");
    _jump1765:;
    if (_63 >= 0)
    goto _jump1766;
    fail_assertion("negative array index");
    _jump1766:;
    if (_63 < _62.d1)
    goto _jump1767;
    fail_assertion("index too large");
    _jump1767:;
    int64_t _66 = 0;
    _66 *= _62.d0;
    _66 += c;
    _66 *= _62.d1;
    _66 += _63;
    bool _67 = _62.data[_66];
    _51 = _67;
    _jump1755:;
    _1 = _51;
    _jump1751:;
    if (0 != _1)
    goto _jump1768;
    fail_assertion("y");
    _jump1768:;
    double _68;
    // Computing bound for H
    if (r > 0) 
    goto _jump1769;
    fail_assertion("non-positive loop bound");
    _jump1769:;
    // Computing bound for I
    if (u.d2 > 0) 
    goto _jump1770;
    fail_assertion("non-positive loop bound");
    _jump1770:;
    _68 = 0;
    int64_t _69 = 0; // I
    int64_t _70 = 0; // H
    _jump1771:; // Begin body of loop
    double _71 = k(q);
    _68 += _71;
    _69++;
    if (_69 < u.d2)
    goto _jump1771;
    _69 = 0;
    _70++;
    if (_70 < r)
    goto _jump1771;
    // End body of loop
    double _72;
    // Computing bound for H
    if (r > 0) 
    goto _jump1772;
    fail_assertion("non-positive loop bound");
    _jump1772:;
    _72 = 0;
    int64_t _73 = 0; // H
    _jump1773:; // Begin body of loop
    _a2_double _74;
    // Computing bound for I
    _74.d0 = u.d1;
    if (u.d1 > 0) 
    goto _jump1774;
    fail_assertion("non-positive loop bound");
    _jump1774:;
    // Computing bound for J
    _74.d1 = n;
    if (n > 0) 
    goto _jump1775;
    fail_assertion("non-positive loop bound");
    _jump1775:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= u.d1;
    _75 *= n;
    _75 *= sizeof(double);
    _74.data = jpl_alloc(_75);
    int64_t _76 = 0; // J
    int64_t _77 = 0; // I
    _jump1776:; // Begin body of loop
    double _78 = 89.0;
    int64_t _79 = 0;
    _79 *= _74.d0;
    _79 += _77;
    _79 *= _74.d1;
    _79 += _76;
    _74.data[_79] = _78;
    _76++;
    if (_76 < n)
    goto _jump1776;
    _76 = 0;
    _77++;
    if (_77 < u.d1)
    goto _jump1776;
    // End body of loop
    if (m.d0 >= 0)
    goto _jump1777;
    fail_assertion("negative array index");
    _jump1777:;
    if (m.d0 < _74.d0)
    goto _jump1778;
    fail_assertion("index too large");
    _jump1778:;
    if (j >= 0)
    goto _jump1779;
    fail_assertion("negative array index");
    _jump1779:;
    if (j < _74.d1)
    goto _jump1780;
    fail_assertion("index too large");
    _jump1780:;
    int64_t _80 = 0;
    _80 *= _74.d0;
    _80 += m.d0;
    _80 *= _74.d1;
    _80 += j;
    double _81 = _74.data[_80];
    double _82;
    // Computing bound for I
    int64_t _83;
    // Computing bound for I
    if (u.d2 > 0) 
    goto _jump1781;
    fail_assertion("non-positive loop bound");
    _jump1781:;
    _83 = 0;
    int64_t _84 = 0; // I
    _jump1782:; // Begin body of loop
    _83 += m.d0;
    _84++;
    if (_84 < u.d2)
    goto _jump1782;
    // End body of loop
    if (_83 > 0) 
    goto _jump1783;
    fail_assertion("non-positive loop bound");
    _jump1783:;
    _82 = 0;
    int64_t _85 = 0; // I
    _jump1784:; // Begin body of loop
    if (u.d0 >= 0)
    goto _jump1785;
    fail_assertion("negative array index");
    _jump1785:;
    if (u.d0 < m.d0)
    goto _jump1786;
    fail_assertion("index too large");
    _jump1786:;
    if (n >= 0)
    goto _jump1787;
    fail_assertion("negative array index");
    _jump1787:;
    if (n < m.d1)
    goto _jump1788;
    fail_assertion("index too large");
    _jump1788:;
    int64_t _86 = 0;
    _86 *= m.d0;
    _86 += u.d0;
    _86 *= m.d1;
    _86 += n;
    double _87 = m.data[_86];
    _82 += _87;
    _85++;
    if (_85 < _83)
    goto _jump1784;
    // End body of loop
    double _88 = fmod(_81, _82);
    _72 += _88;
    _73++;
    if (_73 < r)
    goto _jump1773;
    // End body of loop
    double _89 = -_72;
    bool _90 = _68 < _89;
    bool _91 = !_90;
    return _91;
    bool _92 = true;
    return _92;
}

bool x(bool y) {
    bool _0 = true;
    return _0;
    _a3_void_t _1;
    // Computing bound for z
    bool _2 = n >= n;
    int64_t _3;
    if (!_2)
    goto _jump1789;
    int64_t _4 = -r;
    _3 = _4;
    goto _jump1790;
    _jump1789:;
    int64_t _5;
    // Computing bound for z
    if (g > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    // Computing bound for A
    int64_t _6 = 506;
    if (_6 > 0) 
    goto _jump1792;
    fail_assertion("non-positive loop bound");
    _jump1792:;
    // Computing bound for B
    if (d > 0) 
    goto _jump1793;
    fail_assertion("non-positive loop bound");
    _jump1793:;
    _5 = 0;
    int64_t _7 = 0; // B
    int64_t _8 = 0; // A
    int64_t _9 = 0; // z
    _jump1794:; // Begin body of loop
    _5 += v;
    _7++;
    if (_7 < d)
    goto _jump1794;
    _7 = 0;
    _8++;
    if (_8 < _6)
    goto _jump1794;
    _8 = 0;
    _9++;
    if (_9 < g)
    goto _jump1794;
    // End body of loop
    _3 = _5;
    _jump1790:;
    _1.d0 = _3;
    if (_3 > 0) 
    goto _jump1795;
    fail_assertion("non-positive loop bound");
    _jump1795:;
    // Computing bound for A
    _1.d1 = n;
    if (n > 0) 
    goto _jump1796;
    fail_assertion("non-positive loop bound");
    _jump1796:;
    // Computing bound for B
    _1.d2 = r;
    if (r > 0) 
    goto _jump1797;
    fail_assertion("non-positive loop bound");
    _jump1797:;
    // Computing total size of heap memory to allocate
    int64_t _10 = 1;
    _10 *= _3;
    _10 *= n;
    _10 *= r;
    _10 *= sizeof(void_t);
    _1.data = jpl_alloc(_10);
    int64_t _11 = 0; // B
    int64_t _12 = 0; // A
    int64_t _13 = 0; // z
    _jump1798:; // Begin body of loop
    void_t _14 = f();
    int64_t _15 = 0;
    _15 *= _1.d0;
    _15 += _13;
    _15 *= _1.d1;
    _15 += _12;
    _15 *= _1.d2;
    _15 += _11;
    _1.data[_15] = _14;
    _11++;
    if (_11 < r)
    goto _jump1798;
    _11 = 0;
    _12++;
    if (_12 < n)
    goto _jump1798;
    _12 = 0;
    _13++;
    if (_13 < _3)
    goto _jump1798;
    // End body of loop
    bool _16 = false;
    _a3_void_t _17;
    if (!_16)
    goto _jump1799;
    _a3_void_t _18;
    // Computing bound for z
    _18.d0 = v;
    if (v > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for A
    _18.d1 = n;
    if (n > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    // Computing bound for B
    _18.d2 = o;
    if (o > 0) 
    goto _jump1802;
    fail_assertion("non-positive loop bound");
    _jump1802:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= v;
    _19 *= n;
    _19 *= o;
    _19 *= sizeof(void_t);
    _18.data = jpl_alloc(_19);
    int64_t _20 = 0; // B
    int64_t _21 = 0; // A
    int64_t _22 = 0; // z
    _jump1803:; // Begin body of loop
    void_t _23 = f();
    int64_t _24 = 0;
    _24 *= _18.d0;
    _24 += _22;
    _24 *= _18.d1;
    _24 += _21;
    _24 *= _18.d2;
    _24 += _20;
    _18.data[_24] = _23;
    _20++;
    if (_20 < o)
    goto _jump1803;
    _20 = 0;
    _21++;
    if (_21 < n)
    goto _jump1803;
    _21 = 0;
    _22++;
    if (_22 < v)
    goto _jump1803;
    // End body of loop
    _17 = _18;
    goto _jump1804;
    _jump1799:;
    _a3_void_t _25;
    // Computing bound for z
    int64_t _26 = -g;
    _25.d0 = _26;
    if (_26 > 0) 
    goto _jump1805;
    fail_assertion("non-positive loop bound");
    _jump1805:;
    // Computing bound for A
    int64_t _27 = g % d;
    _25.d1 = _27;
    if (_27 > 0) 
    goto _jump1806;
    fail_assertion("non-positive loop bound");
    _jump1806:;
    // Computing bound for B
    int64_t _28 = -g;
    _25.d2 = _28;
    if (_28 > 0) 
    goto _jump1807;
    fail_assertion("non-positive loop bound");
    _jump1807:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _26;
    _29 *= _27;
    _29 *= _28;
    _29 *= sizeof(void_t);
    _25.data = jpl_alloc(_29);
    int64_t _30 = 0; // B
    int64_t _31 = 0; // A
    int64_t _32 = 0; // z
    _jump1808:; // Begin body of loop
    bool _33 = false;
    void_t _34;
    if (!_33)
    goto _jump1809;
    void_t _35 = f();
    _34 = _35;
    goto _jump1810;
    _jump1809:;
    void_t _36 = f();
    _34 = _36;
    _jump1810:;
    int64_t _37 = 0;
    _37 *= _25.d0;
    _37 += _32;
    _37 *= _25.d1;
    _37 += _31;
    _37 *= _25.d2;
    _37 += _30;
    _25.data[_37] = _34;
    _30++;
    if (_30 < _28)
    goto _jump1808;
    _30 = 0;
    _31++;
    if (_31 < _27)
    goto _jump1808;
    _31 = 0;
    _32++;
    if (_32 < _26)
    goto _jump1808;
    // End body of loop
    _17 = _25;
    _jump1804:;
    _a1__a3_void_t _38;
    _38.d0 = 2;
    _38.data = jpl_alloc(sizeof(_a3_void_t) * 2);
    _38.data[0] = _1;
    _38.data[1] = _17;
    if (w >= 0)
    goto _jump1811;
    fail_assertion("negative array index");
    _jump1811:;
    if (w < _38.d0)
    goto _jump1812;
    fail_assertion("index too large");
    _jump1812:;
    int64_t _39 = 0;
    _39 *= _38.d0;
    _39 += w;
    _a3_void_t _40 = _38.data[_39];
    bool _41 = true;
    rgba _42;
    if (!_41)
    goto _jump1813;
    double _43 = e.r;
    double _44 = e.a;
    double _45 = a(e);
    double _46 = fmod(_44, _45);
    double _47 = k(q);
    rgba _48 = { _43, h, _46, _47 };
    _42 = _48;
    goto _jump1814;
    _jump1813:;
    double _49 = h / h;
    int64_t _50 = 967;
    int64_t _51 = -d;
    if (_50 >= 0)
    goto _jump1815;
    fail_assertion("negative array index");
    _jump1815:;
    if (_50 < u.d0)
    goto _jump1816;
    fail_assertion("index too large");
    _jump1816:;
    if (_51 >= 0)
    goto _jump1817;
    fail_assertion("negative array index");
    _jump1817:;
    if (_51 < u.d1)
    goto _jump1818;
    fail_assertion("index too large");
    _jump1818:;
    int64_t _52 = 0;
    _52 *= u.d0;
    _52 += _50;
    _52 *= u.d1;
    _52 += _51;
    double _53 = u.data[_52];
    double _54 = a(e);
    double _55 = h + _54;
    double _56 = 31.0;
    rgba _57 = { _49, _53, _55, _56 };
    _42 = _57;
    _jump1814:;
    double _58 = a(_42);
    bool _59 = p(_40, _58);
    rgba _60;
    if (!_59)
    goto _jump1819;
    double _61 = e.g;
    double _62 = e.a;
    double _63 = _61 * _62;
    _a2_rgba _64;
    // Computing bound for z
    _64.d0 = w;
    if (w > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing bound for A
    _64.d1 = w;
    if (w > 0) 
    goto _jump1821;
    fail_assertion("non-positive loop bound");
    _jump1821:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= w;
    _65 *= w;
    _65 *= sizeof(rgba);
    _64.data = jpl_alloc(_65);
    int64_t _66 = 0; // A
    int64_t _67 = 0; // z
    _jump1822:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _64.d0;
    _68 += _67;
    _68 *= _64.d1;
    _68 += _66;
    _64.data[_68] = e;
    _66++;
    if (_66 < w)
    goto _jump1822;
    _66 = 0;
    _67++;
    if (_67 < w)
    goto _jump1822;
    // End body of loop
    if (v >= 0)
    goto _jump1823;
    fail_assertion("negative array index");
    _jump1823:;
    if (v < _64.d0)
    goto _jump1824;
    fail_assertion("index too large");
    _jump1824:;
    if (r >= 0)
    goto _jump1825;
    fail_assertion("negative array index");
    _jump1825:;
    if (r < _64.d1)
    goto _jump1826;
    fail_assertion("index too large");
    _jump1826:;
    int64_t _69 = 0;
    _69 *= _64.d0;
    _69 += v;
    _69 *= _64.d1;
    _69 += r;
    rgba _70 = _64.data[_69];
    _a2_rgba _71;
    // Computing bound for z
    int64_t _72 = -v;
    _71.d0 = _72;
    if (_72 > 0) 
    goto _jump1827;
    fail_assertion("non-positive loop bound");
    _jump1827:;
    // Computing bound for A
    _71.d1 = w;
    if (w > 0) 
    goto _jump1828;
    fail_assertion("non-positive loop bound");
    _jump1828:;
    // Computing total size of heap memory to allocate
    int64_t _73 = 1;
    _73 *= _72;
    _73 *= w;
    _73 *= sizeof(rgba);
    _71.data = jpl_alloc(_73);
    int64_t _74 = 0; // A
    int64_t _75 = 0; // z
    _jump1829:; // Begin body of loop
    int64_t _76 = 0;
    _76 *= _71.d0;
    _76 += _75;
    _76 *= _71.d1;
    _76 += _74;
    _71.data[_76] = e;
    _74++;
    if (_74 < w)
    goto _jump1829;
    _74 = 0;
    _75++;
    if (_75 < _72)
    goto _jump1829;
    // End body of loop
    void_t _77;
    if (!y)
    goto _jump1830;
    if (o >= 0)
    goto _jump1831;
    fail_assertion("negative array index");
    _jump1831:;
    if (o < q.d0)
    goto _jump1832;
    fail_assertion("index too large");
    _jump1832:;
    int64_t _78 = 0;
    _78 *= q.d0;
    _78 += o;
    void_t _79 = q.data[_78];
    _77 = _79;
    goto _jump1833;
    _jump1830:;
    void_t _80;
    if (!y)
    goto _jump1834;
    void_t _81 = f();
    _80 = _81;
    goto _jump1835;
    _jump1834:;
    void_t _82 = f();
    _80 = _82;
    _jump1835:;
    _77 = _80;
    _jump1833:;
    double _83 = s(_70, _71, _77);
    _a1_void_t _84;
    // Computing bound for z
    _84.d0 = w;
    if (w > 0) 
    goto _jump1836;
    fail_assertion("non-positive loop bound");
    _jump1836:;
    // Computing total size of heap memory to allocate
    int64_t _85 = 1;
    _85 *= w;
    _85 *= sizeof(void_t);
    _84.data = jpl_alloc(_85);
    int64_t _86 = 0; // z
    _jump1837:; // Begin body of loop
    void_t _87 = f();
    int64_t _88 = 0;
    _88 *= _84.d0;
    _88 += _86;
    _84.data[_88] = _87;
    _86++;
    if (_86 < w)
    goto _jump1837;
    // End body of loop
    double _89 = k(_84);
    double _90 = e.b;
    double _91 = 39.0;
    double _92 = 65.0;
    double _93 = e.b;
    rgba _94 = { _90, _91, _92, _93 };
    double _95 = a(_94);
    rgba _96 = { _63, _83, _89, _95 };
    double _97 = _96.a;
    _a3_rgba _98;
    // Computing bound for z
    _98.d0 = v;
    if (v > 0) 
    goto _jump1838;
    fail_assertion("non-positive loop bound");
    _jump1838:;
    // Computing bound for A
    int64_t _99 = 180;
    int64_t _100 = w - _99;
    int64_t _101 = -_100;
    _98.d1 = _101;
    if (_101 > 0) 
    goto _jump1839;
    fail_assertion("non-positive loop bound");
    _jump1839:;
    // Computing bound for B
    int64_t _102 = 303;
    _98.d2 = _102;
    if (_102 > 0) 
    goto _jump1840;
    fail_assertion("non-positive loop bound");
    _jump1840:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= v;
    _103 *= _101;
    _103 *= _102;
    _103 *= sizeof(rgba);
    _98.data = jpl_alloc(_103);
    int64_t _104 = 0; // B
    int64_t _105 = 0; // A
    int64_t _106 = 0; // z
    _jump1841:; // Begin body of loop
    int64_t _107 = 0;
    _107 *= _98.d0;
    _107 += _106;
    _107 *= _98.d1;
    _107 += _105;
    _107 *= _98.d2;
    _107 += _104;
    _98.data[_107] = e;
    _104++;
    if (_104 < _102)
    goto _jump1841;
    _104 = 0;
    _105++;
    if (_105 < _101)
    goto _jump1841;
    _105 = 0;
    _106++;
    if (_106 < v)
    goto _jump1841;
    // End body of loop
    int64_t _108 = 574;
    int64_t _109 = -_108;
    int64_t _110 = -_109;
    if (j >= 0)
    goto _jump1842;
    fail_assertion("negative array index");
    _jump1842:;
    if (j < _98.d0)
    goto _jump1843;
    fail_assertion("index too large");
    _jump1843:;
    if (_110 >= 0)
    goto _jump1844;
    fail_assertion("negative array index");
    _jump1844:;
    if (_110 < _98.d1)
    goto _jump1845;
    fail_assertion("index too large");
    _jump1845:;
    if (o >= 0)
    goto _jump1846;
    fail_assertion("negative array index");
    _jump1846:;
    if (o < _98.d2)
    goto _jump1847;
    fail_assertion("index too large");
    _jump1847:;
    int64_t _111 = 0;
    _111 *= _98.d0;
    _111 += j;
    _111 *= _98.d1;
    _111 += _110;
    _111 *= _98.d2;
    _111 += o;
    rgba _112 = _98.data[_111];
    _a2_rgba _113;
    // Computing bound for z
    bool _114 = !y;
    bool _115 = x(_114);
    int64_t _116;
    if (!_115)
    goto _jump1848;
    _116 = c;
    goto _jump1849;
    _jump1848:;
    _116 = v;
    _jump1849:;
    _113.d0 = _116;
    if (_116 > 0) 
    goto _jump1850;
    fail_assertion("non-positive loop bound");
    _jump1850:;
    // Computing bound for A
    _113.d1 = v;
    if (v > 0) 
    goto _jump1851;
    fail_assertion("non-positive loop bound");
    _jump1851:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= _116;
    _117 *= v;
    _117 *= sizeof(rgba);
    _113.data = jpl_alloc(_117);
    int64_t _118 = 0; // A
    int64_t _119 = 0; // z
    _jump1852:; // Begin body of loop
    int64_t _120 = 0;
    _120 *= _113.d0;
    _120 += _119;
    _120 *= _113.d1;
    _120 += _118;
    _113.data[_120] = e;
    _118++;
    if (_118 < v)
    goto _jump1852;
    _118 = 0;
    _119++;
    if (_119 < _116)
    goto _jump1852;
    // End body of loop
    _a3_void_t _121;
    // Computing bound for z
    _121.d0 = j;
    if (j > 0) 
    goto _jump1853;
    fail_assertion("non-positive loop bound");
    _jump1853:;
    // Computing bound for A
    _121.d1 = g;
    if (g > 0) 
    goto _jump1854;
    fail_assertion("non-positive loop bound");
    _jump1854:;
    // Computing bound for B
    _121.d2 = r;
    if (r > 0) 
    goto _jump1855;
    fail_assertion("non-positive loop bound");
    _jump1855:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= j;
    _122 *= g;
    _122 *= r;
    _122 *= sizeof(void_t);
    _121.data = jpl_alloc(_122);
    int64_t _123 = 0; // B
    int64_t _124 = 0; // A
    int64_t _125 = 0; // z
    _jump1856:; // Begin body of loop
    void_t _126 = f();
    int64_t _127 = 0;
    _127 *= _121.d0;
    _127 += _125;
    _127 *= _121.d1;
    _127 += _124;
    _127 *= _121.d2;
    _127 += _123;
    _121.data[_127] = _126;
    _123++;
    if (_123 < r)
    goto _jump1856;
    _123 = 0;
    _124++;
    if (_124 < g)
    goto _jump1856;
    _124 = 0;
    _125++;
    if (_125 < j)
    goto _jump1856;
    // End body of loop
    double _128 = 85.0;
    bool _129 = p(_121, _128);
    bool _130 = !_129;
    void_t _131;
    if (!_130)
    goto _jump1857;
    bool _132 = !y;
    void_t _133;
    if (!_132)
    goto _jump1858;
    void_t _134 = f();
    _133 = _134;
    goto _jump1859;
    _jump1858:;
    _a3_void_t _135;
    // Computing bound for z
    int64_t _136 = 580;
    _135.d0 = _136;
    if (_136 > 0) 
    goto _jump1860;
    fail_assertion("non-positive loop bound");
    _jump1860:;
    // Computing bound for A
    _135.d1 = c;
    if (c > 0) 
    goto _jump1861;
    fail_assertion("non-positive loop bound");
    _jump1861:;
    // Computing bound for B
    _135.d2 = c;
    if (c > 0) 
    goto _jump1862;
    fail_assertion("non-positive loop bound");
    _jump1862:;
    // Computing total size of heap memory to allocate
    int64_t _137 = 1;
    _137 *= _136;
    _137 *= c;
    _137 *= c;
    _137 *= sizeof(void_t);
    _135.data = jpl_alloc(_137);
    int64_t _138 = 0; // B
    int64_t _139 = 0; // A
    int64_t _140 = 0; // z
    _jump1863:; // Begin body of loop
    void_t _141 = f();
    int64_t _142 = 0;
    _142 *= _135.d0;
    _142 += _140;
    _142 *= _135.d1;
    _142 += _139;
    _142 *= _135.d2;
    _142 += _138;
    _135.data[_142] = _141;
    _138++;
    if (_138 < c)
    goto _jump1863;
    _138 = 0;
    _139++;
    if (_139 < c)
    goto _jump1863;
    _139 = 0;
    _140++;
    if (_140 < _136)
    goto _jump1863;
    // End body of loop
    bool _143 = true;
    int64_t _144;
    if (!_143)
    goto _jump1864;
    _144 = v;
    goto _jump1865;
    _jump1864:;
    _144 = r;
    _jump1865:;
    if (d >= 0)
    goto _jump1866;
    fail_assertion("negative array index");
    _jump1866:;
    if (d < _135.d0)
    goto _jump1867;
    fail_assertion("index too large");
    _jump1867:;
    if (_144 >= 0)
    goto _jump1868;
    fail_assertion("negative array index");
    _jump1868:;
    if (_144 < _135.d1)
    goto _jump1869;
    fail_assertion("index too large");
    _jump1869:;
    if (j >= 0)
    goto _jump1870;
    fail_assertion("negative array index");
    _jump1870:;
    if (j < _135.d2)
    goto _jump1871;
    fail_assertion("index too large");
    _jump1871:;
    int64_t _145 = 0;
    _145 *= _135.d0;
    _145 += d;
    _145 *= _135.d1;
    _145 += _144;
    _145 *= _135.d2;
    _145 += j;
    void_t _146 = _135.data[_145];
    _133 = _146;
    _jump1859:;
    _131 = _133;
    goto _jump1872;
    _jump1857:;
    bool _147 = false;
    void_t _148;
    if (!_147)
    goto _jump1873;
    _a1_void_t _149;
    // Computing bound for z
    _149.d0 = c;
    if (c > 0) 
    goto _jump1874;
    fail_assertion("non-positive loop bound");
    _jump1874:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= c;
    _150 *= sizeof(void_t);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // z
    _jump1875:; // Begin body of loop
    void_t _152 = f();
    int64_t _153 = 0;
    _153 *= _149.d0;
    _153 += _151;
    _149.data[_153] = _152;
    _151++;
    if (_151 < c)
    goto _jump1875;
    // End body of loop
    if (w >= 0)
    goto _jump1876;
    fail_assertion("negative array index");
    _jump1876:;
    if (w < _149.d0)
    goto _jump1877;
    fail_assertion("index too large");
    _jump1877:;
    int64_t _154 = 0;
    _154 *= _149.d0;
    _154 += w;
    void_t _155 = _149.data[_154];
    _148 = _155;
    goto _jump1878;
    _jump1873:;
    void_t _156 = f();
    _148 = _156;
    _jump1878:;
    _131 = _148;
    _jump1872:;
    double _157 = s(_112, _113, _131);
    rgba _158 = { _97, h, h, _157 };
    _60 = _158;
    goto _jump1879;
    _jump1819:;
    _60 = e;
    _jump1879:;
    bool _159 = true;
    bool _160 = x(_159);
    return _160;
    _a1_void_t _161;
    // Computing bound for B
    _161.d0 = g;
    if (g > 0) 
    goto _jump1880;
    fail_assertion("non-positive loop bound");
    _jump1880:;
    // Computing total size of heap memory to allocate
    int64_t _162 = 1;
    _162 *= g;
    _162 *= sizeof(void_t);
    _161.data = jpl_alloc(_162);
    int64_t _163 = 0; // B
    _jump1881:; // Begin body of loop
    void_t _164 = f();
    int64_t _165 = 0;
    _165 *= _161.d0;
    _165 += _163;
    _161.data[_165] = _164;
    _163++;
    if (_163 < g)
    goto _jump1881;
    // End body of loop
    _a3_void_t _167;
    // Computing bound for F
    _167.d0 = c;
    if (c > 0) 
    goto _jump1882;
    fail_assertion("non-positive loop bound");
    _jump1882:;
    // Computing bound for G
    _167.d1 = r;
    if (r > 0) 
    goto _jump1883;
    fail_assertion("non-positive loop bound");
    _jump1883:;
    // Computing bound for H
    _167.d2 = c;
    if (c > 0) 
    goto _jump1884;
    fail_assertion("non-positive loop bound");
    _jump1884:;
    // Computing total size of heap memory to allocate
    int64_t _168 = 1;
    _168 *= c;
    _168 *= r;
    _168 *= c;
    _168 *= sizeof(void_t);
    _167.data = jpl_alloc(_168);
    int64_t _169 = 0; // H
    int64_t _170 = 0; // G
    int64_t _171 = 0; // F
    _jump1885:; // Begin body of loop
    void_t _172 = f();
    int64_t _173 = 0;
    _173 *= _167.d0;
    _173 += _171;
    _173 *= _167.d1;
    _173 += _170;
    _173 *= _167.d2;
    _173 += _169;
    _167.data[_173] = _172;
    _169++;
    if (_169 < c)
    goto _jump1885;
    _169 = 0;
    _170++;
    if (_170 < r)
    goto _jump1885;
    _170 = 0;
    _171++;
    if (_171 < c)
    goto _jump1885;
    // End body of loop
    bool _174 = p(_167, h);
    _a3_bool _175;
    // Computing bound for F
    int64_t _176 = 768;
    _175.d0 = _176;
    if (_176 > 0) 
    goto _jump1886;
    fail_assertion("non-positive loop bound");
    _jump1886:;
    // Computing bound for G
    _175.d1 = j;
    if (j > 0) 
    goto _jump1887;
    fail_assertion("non-positive loop bound");
    _jump1887:;
    // Computing bound for H
    _175.d2 = j;
    if (j > 0) 
    goto _jump1888;
    fail_assertion("non-positive loop bound");
    _jump1888:;
    // Computing total size of heap memory to allocate
    int64_t _177 = 1;
    _177 *= _176;
    _177 *= j;
    _177 *= j;
    _177 *= sizeof(bool);
    _175.data = jpl_alloc(_177);
    int64_t _178 = 0; // H
    int64_t _179 = 0; // G
    int64_t _180 = 0; // F
    _jump1889:; // Begin body of loop
    bool _181 = true;
    bool _182 = !_181;
    int64_t _183 = 0;
    _183 *= _175.d0;
    _183 += _180;
    _183 *= _175.d1;
    _183 += _179;
    _183 *= _175.d2;
    _183 += _178;
    _175.data[_183] = _182;
    _178++;
    if (_178 < j)
    goto _jump1889;
    _178 = 0;
    _179++;
    if (_179 < j)
    goto _jump1889;
    _179 = 0;
    _180++;
    if (_180 < _176)
    goto _jump1889;
    // End body of loop
    int64_t _184 = 701;
    if (_184 >= 0)
    goto _jump1890;
    fail_assertion("negative array index");
    _jump1890:;
    if (_184 < _175.d0)
    goto _jump1891;
    fail_assertion("index too large");
    _jump1891:;
    if (_161.d0 >= 0)
    goto _jump1892;
    fail_assertion("negative array index");
    _jump1892:;
    if (_161.d0 < _175.d1)
    goto _jump1893;
    fail_assertion("index too large");
    _jump1893:;
    if (_161.d0 >= 0)
    goto _jump1894;
    fail_assertion("negative array index");
    _jump1894:;
    if (_161.d0 < _175.d2)
    goto _jump1895;
    fail_assertion("index too large");
    _jump1895:;
    int64_t _185 = 0;
    _185 *= _175.d0;
    _185 += _184;
    _185 *= _175.d1;
    _185 += _161.d0;
    _185 *= _175.d2;
    _185 += _161.d0;
    bool _186 = _175.data[_185];
    bool _187 = _174 == _186;
    bool _188;
    if (!_187)
    goto _jump1896;
    _188 = y;
    goto _jump1897;
    _jump1896:;
    int64_t _190 = -w;
    bool _191 = v != _190;
    bool _192 = !_191;
    bool _189 = _192;
    if (0 != _192)
    goto _jump1898;
    int64_t _194 = 571;
    bool _195 = _194 <= d;
    bool _193 = _195;
    if (0 != _195)
    goto _jump1899;
    bool _196 = d > w;
    _193 = _196;
    _jump1899:;
    bool _197 = !_193;
    _189 = _197;
    _jump1898:;
    _188 = _189;
    _jump1897:;
    bool _166 = _188;
    if (0 != _188)
    goto _jump1900;
    double _198;
    // Computing bound for F
    if (c > 0) 
    goto _jump1901;
    fail_assertion("non-positive loop bound");
    _jump1901:;
    // Computing bound for G
    if (o > 0) 
    goto _jump1902;
    fail_assertion("non-positive loop bound");
    _jump1902:;
    // Computing bound for H
    if (r > 0) 
    goto _jump1903;
    fail_assertion("non-positive loop bound");
    _jump1903:;
    _198 = 0;
    int64_t _199 = 0; // H
    int64_t _200 = 0; // G
    int64_t _201 = 0; // F
    _jump1904:; // Begin body of loop
    _a2_double _202;
    // Computing bound for I
    _202.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1905;
    fail_assertion("non-positive loop bound");
    _jump1905:;
    // Computing bound for J
    _202.d1 = w;
    if (w > 0) 
    goto _jump1906;
    fail_assertion("non-positive loop bound");
    _jump1906:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _161.d0;
    _203 *= w;
    _203 *= sizeof(double);
    _202.data = jpl_alloc(_203);
    int64_t _204 = 0; // J
    int64_t _205 = 0; // I
    _jump1907:; // Begin body of loop
    double _206 = 87.0;
    int64_t _207 = 0;
    _207 *= _202.d0;
    _207 += _205;
    _207 *= _202.d1;
    _207 += _204;
    _202.data[_207] = _206;
    _204++;
    if (_204 < w)
    goto _jump1907;
    _204 = 0;
    _205++;
    if (_205 < _161.d0)
    goto _jump1907;
    // End body of loop
    if (v >= 0)
    goto _jump1908;
    fail_assertion("negative array index");
    _jump1908:;
    if (v < _202.d0)
    goto _jump1909;
    fail_assertion("index too large");
    _jump1909:;
    if (_199 >= 0)
    goto _jump1910;
    fail_assertion("negative array index");
    _jump1910:;
    if (_199 < _202.d1)
    goto _jump1911;
    fail_assertion("index too large");
    _jump1911:;
    int64_t _208 = 0;
    _208 *= _202.d0;
    _208 += v;
    _208 *= _202.d1;
    _208 += _199;
    double _209 = _202.data[_208];
    double _210 = -_209;
    _198 += _210;
    _199++;
    if (_199 < r)
    goto _jump1904;
    _199 = 0;
    _200++;
    if (_200 < o)
    goto _jump1904;
    _200 = 0;
    _201++;
    if (_201 < c)
    goto _jump1904;
    // End body of loop
    bool _211 = _198 < h;
    _166 = _211;
    _jump1900:;
    bool _212;
    if (!_166)
    goto _jump1912;
    bool _213 = true;
    bool _214;
    if (!_213)
    goto _jump1913;
    bool _215 = false;
    bool _216 = !_215;
    _214 = _216;
    goto _jump1914;
    _jump1913:;
    bool _217 = d == g;
    _214 = _217;
    _jump1914:;
    bool _218;
    if (!_214)
    goto _jump1915;
    bool _219 = true;
    bool _220 = x(_219);
    bool _221 = !_220;
    _218 = _221;
    goto _jump1916;
    _jump1915:;
    bool _222 = true;
    bool _223 = x(_222);
    _218 = _223;
    _jump1916:;
    bool _224 = x(_218);
    bool _225;
    if (!_224)
    goto _jump1917;
    _a3_void_t _226;
    // Computing bound for F
    _226.d0 = v;
    if (v > 0) 
    goto _jump1918;
    fail_assertion("non-positive loop bound");
    _jump1918:;
    // Computing bound for G
    _226.d1 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1919;
    fail_assertion("non-positive loop bound");
    _jump1919:;
    // Computing bound for H
    _226.d2 = n;
    if (n > 0) 
    goto _jump1920;
    fail_assertion("non-positive loop bound");
    _jump1920:;
    // Computing total size of heap memory to allocate
    int64_t _227 = 1;
    _227 *= v;
    _227 *= _161.d0;
    _227 *= n;
    _227 *= sizeof(void_t);
    _226.data = jpl_alloc(_227);
    int64_t _228 = 0; // H
    int64_t _229 = 0; // G
    int64_t _230 = 0; // F
    _jump1921:; // Begin body of loop
    void_t _231 = f();
    int64_t _232 = 0;
    _232 *= _226.d0;
    _232 += _230;
    _232 *= _226.d1;
    _232 += _229;
    _232 *= _226.d2;
    _232 += _228;
    _226.data[_232] = _231;
    _228++;
    if (_228 < n)
    goto _jump1921;
    _228 = 0;
    _229++;
    if (_229 < _161.d0)
    goto _jump1921;
    _229 = 0;
    _230++;
    if (_230 < v)
    goto _jump1921;
    // End body of loop
    double _233 = k(q);
    double _234 = 10.0;
    bool _235 = _233 < _234;
    double _236;
    if (!_235)
    goto _jump1922;
    if (r >= 0)
    goto _jump1923;
    fail_assertion("negative array index");
    _jump1923:;
    if (r < u.d0)
    goto _jump1924;
    fail_assertion("index too large");
    _jump1924:;
    if (j >= 0)
    goto _jump1925;
    fail_assertion("negative array index");
    _jump1925:;
    if (j < u.d1)
    goto _jump1926;
    fail_assertion("index too large");
    _jump1926:;
    int64_t _237 = 0;
    _237 *= u.d0;
    _237 += r;
    _237 *= u.d1;
    _237 += j;
    double _238 = u.data[_237];
    _236 = _238;
    goto _jump1927;
    _jump1922:;
    double _239 = k(q);
    _236 = _239;
    _jump1927:;
    bool _240 = p(_226, _236);
    _225 = _240;
    goto _jump1928;
    _jump1917:;
    _a3__a3_void_t _241;
    // Computing bound for F
    _241.d0 = n;
    if (n > 0) 
    goto _jump1929;
    fail_assertion("non-positive loop bound");
    _jump1929:;
    // Computing bound for G
    if (o >= 0)
    goto _jump1930;
    fail_assertion("negative array index");
    _jump1930:;
    if (o < l.d0)
    goto _jump1931;
    fail_assertion("index too large");
    _jump1931:;
    int64_t _242 = 0;
    _242 *= l.d0;
    _242 += o;
    int64_t _243 = l.data[_242];
    _241.d1 = _243;
    if (_243 > 0) 
    goto _jump1932;
    fail_assertion("non-positive loop bound");
    _jump1932:;
    // Computing bound for H
    int64_t _244 = -o;
    _241.d2 = _244;
    if (_244 > 0) 
    goto _jump1933;
    fail_assertion("non-positive loop bound");
    _jump1933:;
    // Computing total size of heap memory to allocate
    int64_t _245 = 1;
    _245 *= n;
    _245 *= _243;
    _245 *= _244;
    _245 *= sizeof(_a3_void_t);
    _241.data = jpl_alloc(_245);
    int64_t _246 = 0; // H
    int64_t _247 = 0; // G
    int64_t _248 = 0; // F
    _jump1934:; // Begin body of loop
    _a3_void_t _249;
    // Computing bound for I
    _249.d0 = _248;
    if (_248 > 0) 
    goto _jump1935;
    fail_assertion("non-positive loop bound");
    _jump1935:;
    // Computing bound for J
    _249.d1 = r;
    if (r > 0) 
    goto _jump1936;
    fail_assertion("non-positive loop bound");
    _jump1936:;
    // Computing bound for K
    int64_t _250 = 985;
    _249.d2 = _250;
    if (_250 > 0) 
    goto _jump1937;
    fail_assertion("non-positive loop bound");
    _jump1937:;
    // Computing total size of heap memory to allocate
    int64_t _251 = 1;
    _251 *= _248;
    _251 *= r;
    _251 *= _250;
    _251 *= sizeof(void_t);
    _249.data = jpl_alloc(_251);
    int64_t _252 = 0; // K
    int64_t _253 = 0; // J
    int64_t _254 = 0; // I
    _jump1938:; // Begin body of loop
    void_t _255 = f();
    int64_t _256 = 0;
    _256 *= _249.d0;
    _256 += _254;
    _256 *= _249.d1;
    _256 += _253;
    _256 *= _249.d2;
    _256 += _252;
    _249.data[_256] = _255;
    _252++;
    if (_252 < _250)
    goto _jump1938;
    _252 = 0;
    _253++;
    if (_253 < r)
    goto _jump1938;
    _253 = 0;
    _254++;
    if (_254 < _248)
    goto _jump1938;
    // End body of loop
    int64_t _257 = 0;
    _257 *= _241.d0;
    _257 += _248;
    _257 *= _241.d1;
    _257 += _247;
    _257 *= _241.d2;
    _257 += _246;
    _241.data[_257] = _249;
    _246++;
    if (_246 < _244)
    goto _jump1934;
    _246 = 0;
    _247++;
    if (_247 < _243)
    goto _jump1934;
    _247 = 0;
    _248++;
    if (_248 < n)
    goto _jump1934;
    // End body of loop
    if (w >= 0)
    goto _jump1939;
    fail_assertion("negative array index");
    _jump1939:;
    if (w < _241.d0)
    goto _jump1940;
    fail_assertion("index too large");
    _jump1940:;
    if (o >= 0)
    goto _jump1941;
    fail_assertion("negative array index");
    _jump1941:;
    if (o < _241.d1)
    goto _jump1942;
    fail_assertion("index too large");
    _jump1942:;
    if (g >= 0)
    goto _jump1943;
    fail_assertion("negative array index");
    _jump1943:;
    if (g < _241.d2)
    goto _jump1944;
    fail_assertion("index too large");
    _jump1944:;
    int64_t _258 = 0;
    _258 *= _241.d0;
    _258 += w;
    _258 *= _241.d1;
    _258 += o;
    _258 *= _241.d2;
    _258 += g;
    _a3_void_t _259 = _241.data[_258];
    _a1_int64_t _260;
    // Computing bound for F
    _260.d0 = o;
    if (o > 0) 
    goto _jump1945;
    fail_assertion("non-positive loop bound");
    _jump1945:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= o;
    _261 *= sizeof(int64_t);
    _260.data = jpl_alloc(_261);
    int64_t _262 = 0; // F
    _jump1946:; // Begin body of loop
    int64_t _263 = 0;
    _263 *= _260.d0;
    _263 += _262;
    _260.data[_263] = _161.d0;
    _262++;
    if (_262 < o)
    goto _jump1946;
    // End body of loop
    if (j >= 0)
    goto _jump1947;
    fail_assertion("negative array index");
    _jump1947:;
    if (j < _260.d0)
    goto _jump1948;
    fail_assertion("index too large");
    _jump1948:;
    int64_t _264 = 0;
    _264 *= _260.d0;
    _264 += j;
    int64_t _265 = _260.data[_264];
    int64_t _266;
    // Computing bound for F
    if (q.d0 >= 0)
    goto _jump1949;
    fail_assertion("negative array index");
    _jump1949:;
    if (q.d0 < i.d0)
    goto _jump1950;
    fail_assertion("index too large");
    _jump1950:;
    int64_t _267 = 0;
    _267 *= i.d0;
    _267 += q.d0;
    int64_t _268 = i.data[_267];
    if (_268 > 0) 
    goto _jump1951;
    fail_assertion("non-positive loop bound");
    _jump1951:;
    // Computing bound for G
    if (j > 0) 
    goto _jump1952;
    fail_assertion("non-positive loop bound");
    _jump1952:;
    // Computing bound for H
    if (c > 0) 
    goto _jump1953;
    fail_assertion("non-positive loop bound");
    _jump1953:;
    _266 = 0;
    int64_t _269 = 0; // H
    int64_t _270 = 0; // G
    int64_t _271 = 0; // F
    _jump1954:; // Begin body of loop
    _266 += _269;
    _269++;
    if (_269 < c)
    goto _jump1954;
    _269 = 0;
    _270++;
    if (_270 < j)
    goto _jump1954;
    _270 = 0;
    _271++;
    if (_271 < _268)
    goto _jump1954;
    // End body of loop
    if (_265 >= 0)
    goto _jump1955;
    fail_assertion("negative array index");
    _jump1955:;
    if (_265 < m.d0)
    goto _jump1956;
    fail_assertion("index too large");
    _jump1956:;
    if (_266 >= 0)
    goto _jump1957;
    fail_assertion("negative array index");
    _jump1957:;
    if (_266 < m.d1)
    goto _jump1958;
    fail_assertion("index too large");
    _jump1958:;
    int64_t _272 = 0;
    _272 *= m.d0;
    _272 += _265;
    _272 *= m.d1;
    _272 += _266;
    double _273 = m.data[_272];
    bool _274 = p(_259, _273);
    _225 = _274;
    _jump1928:;
    bool _275 = !_225;
    _212 = _275;
    goto _jump1959;
    _jump1912:;
    _a3_int64_t _276;
    // Computing bound for F
    _276.d0 = v;
    if (v > 0) 
    goto _jump1960;
    fail_assertion("non-positive loop bound");
    _jump1960:;
    // Computing bound for G
    _276.d1 = q.d0;
    if (q.d0 > 0) 
    goto _jump1961;
    fail_assertion("non-positive loop bound");
    _jump1961:;
    // Computing bound for H
    _a3_int64_t _277;
    // Computing bound for F
    _277.d0 = w;
    if (w > 0) 
    goto _jump1962;
    fail_assertion("non-positive loop bound");
    _jump1962:;
    // Computing bound for G
    _277.d1 = j;
    if (j > 0) 
    goto _jump1963;
    fail_assertion("non-positive loop bound");
    _jump1963:;
    // Computing bound for H
    _277.d2 = r;
    if (r > 0) 
    goto _jump1964;
    fail_assertion("non-positive loop bound");
    _jump1964:;
    // Computing total size of heap memory to allocate
    int64_t _278 = 1;
    _278 *= w;
    _278 *= j;
    _278 *= r;
    _278 *= sizeof(int64_t);
    _277.data = jpl_alloc(_278);
    int64_t _279 = 0; // H
    int64_t _280 = 0; // G
    int64_t _281 = 0; // F
    _jump1965:; // Begin body of loop
    int64_t _282 = 0;
    _282 *= _277.d0;
    _282 += _281;
    _282 *= _277.d1;
    _282 += _280;
    _282 *= _277.d2;
    _282 += _279;
    _277.data[_282] = g;
    _279++;
    if (_279 < r)
    goto _jump1965;
    _279 = 0;
    _280++;
    if (_280 < j)
    goto _jump1965;
    _280 = 0;
    _281++;
    if (_281 < w)
    goto _jump1965;
    // End body of loop
    int64_t _283 = -c;
    int64_t _284 = 309;
    if (_283 >= 0)
    goto _jump1966;
    fail_assertion("negative array index");
    _jump1966:;
    if (_283 < _277.d0)
    goto _jump1967;
    fail_assertion("index too large");
    _jump1967:;
    if (r >= 0)
    goto _jump1968;
    fail_assertion("negative array index");
    _jump1968:;
    if (r < _277.d1)
    goto _jump1969;
    fail_assertion("index too large");
    _jump1969:;
    if (_284 >= 0)
    goto _jump1970;
    fail_assertion("negative array index");
    _jump1970:;
    if (_284 < _277.d2)
    goto _jump1971;
    fail_assertion("index too large");
    _jump1971:;
    int64_t _285 = 0;
    _285 *= _277.d0;
    _285 += _283;
    _285 *= _277.d1;
    _285 += r;
    _285 *= _277.d2;
    _285 += _284;
    int64_t _286 = _277.data[_285];
    _276.d2 = _286;
    if (_286 > 0) 
    goto _jump1972;
    fail_assertion("non-positive loop bound");
    _jump1972:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= v;
    _287 *= q.d0;
    _287 *= _286;
    _287 *= sizeof(int64_t);
    _276.data = jpl_alloc(_287);
    int64_t _288 = 0; // H
    int64_t _289 = 0; // G
    int64_t _290 = 0; // F
    _jump1973:; // Begin body of loop
    int64_t _291 = 0;
    _291 *= _276.d0;
    _291 += _290;
    _291 *= _276.d1;
    _291 += _289;
    _291 *= _276.d2;
    _291 += _288;
    _276.data[_291] = o;
    _288++;
    if (_288 < _286)
    goto _jump1973;
    _288 = 0;
    _289++;
    if (_289 < q.d0)
    goto _jump1973;
    _289 = 0;
    _290++;
    if (_290 < v)
    goto _jump1973;
    // End body of loop
    bool _292 = t(_276);
    bool _293;
    if (!_292)
    goto _jump1974;
    _a3_int64_t _294;
    if (!y)
    goto _jump1975;
    _a3_int64_t _295;
    // Computing bound for F
    _295.d0 = c;
    if (c > 0) 
    goto _jump1976;
    fail_assertion("non-positive loop bound");
    _jump1976:;
    // Computing bound for G
    int64_t _296 = -j;
    _295.d1 = _296;
    if (_296 > 0) 
    goto _jump1977;
    fail_assertion("non-positive loop bound");
    _jump1977:;
    // Computing bound for H
    _295.d2 = w;
    if (w > 0) 
    goto _jump1978;
    fail_assertion("non-positive loop bound");
    _jump1978:;
    // Computing total size of heap memory to allocate
    int64_t _297 = 1;
    _297 *= c;
    _297 *= _296;
    _297 *= w;
    _297 *= sizeof(int64_t);
    _295.data = jpl_alloc(_297);
    int64_t _298 = 0; // H
    int64_t _299 = 0; // G
    int64_t _300 = 0; // F
    _jump1979:; // Begin body of loop
    int64_t _301 = 0;
    _301 *= _295.d0;
    _301 += _300;
    _301 *= _295.d1;
    _301 += _299;
    _301 *= _295.d2;
    _301 += _298;
    _295.data[_301] = _298;
    _298++;
    if (_298 < w)
    goto _jump1979;
    _298 = 0;
    _299++;
    if (_299 < _296)
    goto _jump1979;
    _299 = 0;
    _300++;
    if (_300 < c)
    goto _jump1979;
    // End body of loop
    _294 = _295;
    goto _jump1980;
    _jump1975:;
    _a3_int64_t _302;
    // Computing bound for F
    int64_t _303 = g + j;
    _302.d0 = _303;
    if (_303 > 0) 
    goto _jump1981;
    fail_assertion("non-positive loop bound");
    _jump1981:;
    // Computing bound for G
    _302.d1 = o;
    if (o > 0) 
    goto _jump1982;
    fail_assertion("non-positive loop bound");
    _jump1982:;
    // Computing bound for H
    int64_t _304 = 133;
    _302.d2 = _304;
    if (_304 > 0) 
    goto _jump1983;
    fail_assertion("non-positive loop bound");
    _jump1983:;
    // Computing total size of heap memory to allocate
    int64_t _305 = 1;
    _305 *= _303;
    _305 *= o;
    _305 *= _304;
    _305 *= sizeof(int64_t);
    _302.data = jpl_alloc(_305);
    int64_t _306 = 0; // H
    int64_t _307 = 0; // G
    int64_t _308 = 0; // F
    _jump1984:; // Begin body of loop
    int64_t _309 = 0;
    _309 *= _302.d0;
    _309 += _308;
    _309 *= _302.d1;
    _309 += _307;
    _309 *= _302.d2;
    _309 += _306;
    _302.data[_309] = o;
    _306++;
    if (_306 < _304)
    goto _jump1984;
    _306 = 0;
    _307++;
    if (_307 < o)
    goto _jump1984;
    _307 = 0;
    _308++;
    if (_308 < _303)
    goto _jump1984;
    // End body of loop
    _294 = _302;
    _jump1980:;
    bool _310 = t(_294);
    _293 = _310;
    goto _jump1985;
    _jump1974:;
    _a3_int64_t _311;
    // Computing bound for F
    _311.d0 = w;
    if (w > 0) 
    goto _jump1986;
    fail_assertion("non-positive loop bound");
    _jump1986:;
    // Computing bound for G
    _311.d1 = r;
    if (r > 0) 
    goto _jump1987;
    fail_assertion("non-positive loop bound");
    _jump1987:;
    // Computing bound for H
    _311.d2 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1988;
    fail_assertion("non-positive loop bound");
    _jump1988:;
    // Computing total size of heap memory to allocate
    int64_t _312 = 1;
    _312 *= w;
    _312 *= r;
    _312 *= _161.d0;
    _312 *= sizeof(int64_t);
    _311.data = jpl_alloc(_312);
    int64_t _313 = 0; // H
    int64_t _314 = 0; // G
    int64_t _315 = 0; // F
    _jump1989:; // Begin body of loop
    int64_t _316 = 0;
    _316 *= _311.d0;
    _316 += _315;
    _316 *= _311.d1;
    _316 += _314;
    _316 *= _311.d2;
    _316 += _313;
    _311.data[_316] = q.d0;
    _313++;
    if (_313 < _161.d0)
    goto _jump1989;
    _313 = 0;
    _314++;
    if (_314 < r)
    goto _jump1989;
    _314 = 0;
    _315++;
    if (_315 < w)
    goto _jump1989;
    // End body of loop
    bool _317 = t(_311);
    bool _318;
    if (!_317)
    goto _jump1990;
    _318 = y;
    goto _jump1991;
    _jump1990:;
    _a3_int64_t _319;
    // Computing bound for F
    _319.d0 = g;
    if (g > 0) 
    goto _jump1992;
    fail_assertion("non-positive loop bound");
    _jump1992:;
    // Computing bound for G
    _319.d1 = w;
    if (w > 0) 
    goto _jump1993;
    fail_assertion("non-positive loop bound");
    _jump1993:;
    // Computing bound for H
    _319.d2 = c;
    if (c > 0) 
    goto _jump1994;
    fail_assertion("non-positive loop bound");
    _jump1994:;
    // Computing total size of heap memory to allocate
    int64_t _320 = 1;
    _320 *= g;
    _320 *= w;
    _320 *= c;
    _320 *= sizeof(int64_t);
    _319.data = jpl_alloc(_320);
    int64_t _321 = 0; // H
    int64_t _322 = 0; // G
    int64_t _323 = 0; // F
    _jump1995:; // Begin body of loop
    int64_t _324 = 0;
    _324 *= _319.d0;
    _324 += _323;
    _324 *= _319.d1;
    _324 += _322;
    _324 *= _319.d2;
    _324 += _321;
    _319.data[_324] = v;
    _321++;
    if (_321 < c)
    goto _jump1995;
    _321 = 0;
    _322++;
    if (_322 < w)
    goto _jump1995;
    _322 = 0;
    _323++;
    if (_323 < g)
    goto _jump1995;
    // End body of loop
    bool _325 = t(_319);
    _318 = _325;
    _jump1991:;
    bool _326 = x(_318);
    _293 = _326;
    _jump1985:;
    bool _327 = !_293;
    _212 = _327;
    _jump1959:;
    return _212;
}

void jpl_main(struct args args) {
    _a2_double _0;
    // Computing bound for b
    _a2_int64_t _1;
    // Computing bound for b
    int64_t _2;
    // Computing bound for b
    double _3 = 41.0;
    double _4 = 26.0;
    double _5 = -_4;
    bool _6 = _3 < _5;
    int64_t _7;
    if (!_6)
    goto _jump741;
    int64_t _8 = 246;
    int64_t _9 = -_8;
    int64_t _10;
    // Computing bound for b
    int64_t _11 = 261;
    if (_11 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    _10 = 0;
    int64_t _12 = 0; // b
    _jump743:; // Begin body of loop
    _10 += _12;
    _12++;
    if (_12 < _11)
    goto _jump743;
    // End body of loop
    int64_t _13 = _9 - _10;
    _7 = _13;
    goto _jump744;
    _jump741:;
    int64_t _14 = 183;
    int64_t _15 = 829;
    int64_t _16 = _14 - _15;
    int64_t _17;
    // Computing bound for b
    int64_t _18 = 5;
    if (_18 > 0) 
    goto _jump745;
    fail_assertion("non-positive loop bound");
    _jump745:;
    _17 = 0;
    int64_t _19 = 0; // b
    _jump746:; // Begin body of loop
    int64_t _20 = 425;
    _17 += _20;
    _19++;
    if (_19 < _18)
    goto _jump746;
    // End body of loop
    int64_t _21 = _16 - _17;
    _7 = _21;
    _jump744:;
    if (_7 > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    // Computing bound for c
    int64_t _22 = 569;
    int64_t _23 = 677;
    int64_t _24 = _22 / _23;
    if (_24 > 0) 
    goto _jump748;
    fail_assertion("non-positive loop bound");
    _jump748:;
    // Computing bound for d
    int64_t _25 = 779;
    int64_t _26 = -_25;
    if (_26 > 0) 
    goto _jump749;
    fail_assertion("non-positive loop bound");
    _jump749:;
    _2 = 0;
    int64_t _27 = 0; // d
    int64_t _28 = 0; // c
    int64_t _29 = 0; // b
    _jump750:; // Begin body of loop
    int64_t _30;
    // Computing bound for e
    if (_27 > 0) 
    goto _jump751;
    fail_assertion("non-positive loop bound");
    _jump751:;
    // Computing bound for f
    int64_t _31 = 356;
    if (_31 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for g
    if (_27 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    _30 = 0;
    int64_t _32 = 0; // g
    int64_t _33 = 0; // f
    int64_t _34 = 0; // e
    _jump754:; // Begin body of loop
    _30 += _34;
    _32++;
    if (_32 < _27)
    goto _jump754;
    _32 = 0;
    _33++;
    if (_33 < _31)
    goto _jump754;
    _33 = 0;
    _34++;
    if (_34 < _27)
    goto _jump754;
    // End body of loop
    _2 += _30;
    _27++;
    if (_27 < _26)
    goto _jump750;
    _27 = 0;
    _28++;
    if (_28 < _24)
    goto _jump750;
    _28 = 0;
    _29++;
    if (_29 < _7)
    goto _jump750;
    // End body of loop
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump755;
    fail_assertion("non-positive loop bound");
    _jump755:;
    // Computing bound for c
    bool _35 = true;
    bool _36 = !_35;
    int64_t _37;
    if (!_36)
    goto _jump756;
    int64_t _38 = 552;
    _37 = _38;
    goto _jump757;
    _jump756:;
    int64_t _39;
    // Computing bound for b
    int64_t _40 = 30;
    if (_40 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    _39 = 0;
    int64_t _41 = 0; // b
    _jump759:; // Begin body of loop
    _39 += _41;
    _41++;
    if (_41 < _40)
    goto _jump759;
    // End body of loop
    _37 = _39;
    _jump757:;
    int64_t _42 = -_37;
    int64_t _43;
    // Computing bound for b
    int64_t _44 = 70;
    if (_44 > 0) 
    goto _jump760;
    fail_assertion("non-positive loop bound");
    _jump760:;
    // Computing bound for c
    int64_t _45 = 511;
    if (_45 > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    _43 = 0;
    int64_t _46 = 0; // c
    int64_t _47 = 0; // b
    _jump762:; // Begin body of loop
    int64_t _48 = 881;
    bool _49 = _46 <= _48;
    int64_t _50;
    if (!_49)
    goto _jump763;
    bool _51 = true;
    int64_t _52;
    if (!_51)
    goto _jump764;
    _52 = _47;
    goto _jump765;
    _jump764:;
    _52 = _46;
    _jump765:;
    _50 = _52;
    goto _jump766;
    _jump763:;
    bool _53 = false;
    int64_t _54;
    if (!_53)
    goto _jump767;
    _54 = _46;
    goto _jump768;
    _jump767:;
    _54 = _46;
    _jump768:;
    _50 = _54;
    _jump766:;
    _43 += _50;
    _46++;
    if (_46 < _45)
    goto _jump762;
    _46 = 0;
    _47++;
    if (_47 < _44)
    goto _jump762;
    // End body of loop
    int64_t _55 = _42 + _43;
    _1.d1 = _55;
    if (_55 > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= _2;
    _56 *= _55;
    _56 *= sizeof(int64_t);
    _1.data = jpl_alloc(_56);
    int64_t _57 = 0; // c
    int64_t _58 = 0; // b
    _jump770:; // Begin body of loop
    int64_t _59 = 0;
    _59 *= _1.d0;
    _59 += _58;
    _59 *= _1.d1;
    _59 += _57;
    _1.data[_59] = _58;
    _57++;
    if (_57 < _55)
    goto _jump770;
    _57 = 0;
    _58++;
    if (_58 < _2)
    goto _jump770;
    // End body of loop
    int64_t _60 = 946;
    int64_t _61 = 650;
    bool _62 = _60 < _61;
    bool _63 = false;
    bool _64 = _62 == _63;
    bool _65 = !_64;
    int64_t _66;
    if (!_65)
    goto _jump771;
    int64_t _67 = 734;
    _66 = _67;
    goto _jump772;
    _jump771:;
    int64_t _68 = 267;
    _66 = _68;
    _jump772:;
    int64_t _69 = -_66;
    int64_t _70;
    // Computing bound for b
    int64_t _71 = 9;
    if (_71 > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    _70 = 0;
    int64_t _72 = 0; // b
    _jump774:; // Begin body of loop
    int64_t _73 = 79;
    _70 += _73;
    _72++;
    if (_72 < _71)
    goto _jump774;
    // End body of loop
    int64_t _74 = 376;
    _a1_int64_t _75;
    _75.d0 = 1;
    _75.data = jpl_alloc(sizeof(int64_t) * 1);
    _75.data[0] = _74;
    int64_t _76 = 646;
    if (_76 >= 0)
    goto _jump775;
    fail_assertion("negative array index");
    _jump775:;
    if (_76 < _75.d0)
    goto _jump776;
    fail_assertion("index too large");
    _jump776:;
    int64_t _77 = 0;
    _77 *= _75.d0;
    _77 += _76;
    int64_t _78 = _75.data[_77];
    bool _79 = _70 != _78;
    _a1_int64_t _80;
    if (!_79)
    goto _jump777;
    _a1_int64_t _81;
    // Computing bound for b
    int64_t _82 = 394;
    _81.d0 = _82;
    if (_82 > 0) 
    goto _jump778;
    fail_assertion("non-positive loop bound");
    _jump778:;
    // Computing total size of heap memory to allocate
    int64_t _83 = 1;
    _83 *= _82;
    _83 *= sizeof(int64_t);
    _81.data = jpl_alloc(_83);
    int64_t _84 = 0; // b
    _jump779:; // Begin body of loop
    int64_t _85 = 0;
    _85 *= _81.d0;
    _85 += _84;
    _81.data[_85] = _84;
    _84++;
    if (_84 < _82)
    goto _jump779;
    // End body of loop
    int64_t _86 = 637;
    int64_t _87 = -_86;
    if (_87 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_87 < _81.d0)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _88 = 0;
    _88 *= _81.d0;
    _88 += _87;
    int64_t _89 = _81.data[_88];
    _a1_int64_t _90;
    _90.d0 = 1;
    _90.data = jpl_alloc(sizeof(int64_t) * 1);
    _90.data[0] = _89;
    _80 = _90;
    goto _jump782;
    _jump777:;
    int64_t _91 = 92;
    int64_t _92 = 236;
    int64_t _93 = 837;
    int64_t _94 = _92 - _93;
    int64_t _95 = _91 / _94;
    int64_t _96 = 243;
    int64_t _97 = -_96;
    int64_t _98 = 497;
    int64_t _99 = _97 - _98;
    _a1_int64_t _100;
    _100.d0 = 2;
    _100.data = jpl_alloc(sizeof(int64_t) * 2);
    _100.data[0] = _95;
    _100.data[1] = _99;
    _80 = _100;
    _jump782:;
    int64_t _101 = 778;
    _a1_int64_t _102;
    _102.d0 = 1;
    _102.data = jpl_alloc(sizeof(int64_t) * 1);
    _102.data[0] = _101;
    int64_t _103 = 179;
    if (_103 >= 0)
    goto _jump783;
    fail_assertion("negative array index");
    _jump783:;
    if (_103 < _102.d0)
    goto _jump784;
    fail_assertion("index too large");
    _jump784:;
    int64_t _104 = 0;
    _104 *= _102.d0;
    _104 += _103;
    int64_t _105 = _102.data[_104];
    int64_t _106 = -_105;
    int64_t _107 = -_106;
    if (_107 >= 0)
    goto _jump785;
    fail_assertion("negative array index");
    _jump785:;
    if (_107 < _80.d0)
    goto _jump786;
    fail_assertion("index too large");
    _jump786:;
    int64_t _108 = 0;
    _108 *= _80.d0;
    _108 += _107;
    int64_t _109 = _80.data[_108];
    if (_69 >= 0)
    goto _jump787;
    fail_assertion("negative array index");
    _jump787:;
    if (_69 < _1.d0)
    goto _jump788;
    fail_assertion("index too large");
    _jump788:;
    if (_109 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_109 < _1.d1)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    int64_t _110 = 0;
    _110 *= _1.d0;
    _110 += _69;
    _110 *= _1.d1;
    _110 += _109;
    int64_t _111 = _1.data[_110];
    _0.d0 = _111;
    if (_111 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing bound for c
    int64_t _112 = 125;
    _0.d1 = _112;
    if (_112 > 0) 
    goto _jump792;
    fail_assertion("non-positive loop bound");
    _jump792:;
    // Computing total size of heap memory to allocate
    int64_t _113 = 1;
    _113 *= _111;
    _113 *= _112;
    _113 *= sizeof(double);
    _0.data = jpl_alloc(_113);
    int64_t _114 = 0; // c
    int64_t _115 = 0; // b
    _jump793:; // Begin body of loop
    int64_t _116 = 291;
    int64_t _117 = _115 + _116;
    int64_t _118 = -_117;
    bool _119 = false;
    int64_t _120;
    if (!_119)
    goto _jump794;
    _120 = _115;
    goto _jump795;
    _jump794:;
    int64_t _121 = 702;
    _120 = _121;
    _jump795:;
    int64_t _122 = -_120;
    bool _123 = _118 <= _122;
    double _124;
    if (!_123)
    goto _jump796;
    double _125 = 7.0;
    double _126 = 8.0;
    double _127 = fmod(_125, _126);
    _124 = _127;
    goto _jump797;
    _jump796:;
    double _128;
    // Computing bound for d
    int64_t _129 = 443;
    if (_129 > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing bound for e
    int64_t _130 = _114 % _115;
    int64_t _131 = -_130;
    if (_131 > 0) 
    goto _jump799;
    fail_assertion("non-positive loop bound");
    _jump799:;
    _128 = 0;
    int64_t _132 = 0; // e
    int64_t _133 = 0; // d
    _jump800:; // Begin body of loop
    double _134 = 78.0;
    _128 += _134;
    _132++;
    if (_132 < _131)
    goto _jump800;
    _132 = 0;
    _133++;
    if (_133 < _129)
    goto _jump800;
    // End body of loop
    _124 = _128;
    _jump797:;
    double _135 = 74.0;
    int64_t _136;
    // Computing bound for d
    if (_115 > 0) 
    goto _jump801;
    fail_assertion("non-positive loop bound");
    _jump801:;
    _136 = 0;
    int64_t _137 = 0; // d
    _jump802:; // Begin body of loop
    _136 += _114;
    _137++;
    if (_137 < _115)
    goto _jump802;
    // End body of loop
    int64_t _138 = -_136;
    bool _139 = _114 == _138;
    double _140;
    if (!_139)
    goto _jump803;
    _a2_double _141;
    // Computing bound for d
    _141.d0 = _114;
    if (_114 > 0) 
    goto _jump804;
    fail_assertion("non-positive loop bound");
    _jump804:;
    // Computing bound for e
    int64_t _142 = 275;
    _141.d1 = _142;
    if (_142 > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing total size of heap memory to allocate
    int64_t _143 = 1;
    _143 *= _114;
    _143 *= _142;
    _143 *= sizeof(double);
    _141.data = jpl_alloc(_143);
    int64_t _144 = 0; // e
    int64_t _145 = 0; // d
    _jump806:; // Begin body of loop
    double _146 = 50.0;
    int64_t _147 = 0;
    _147 *= _141.d0;
    _147 += _145;
    _147 *= _141.d1;
    _147 += _144;
    _141.data[_147] = _146;
    _144++;
    if (_144 < _142)
    goto _jump806;
    _144 = 0;
    _145++;
    if (_145 < _114)
    goto _jump806;
    // End body of loop
    int64_t _148 = 308;
    if (_114 >= 0)
    goto _jump807;
    fail_assertion("negative array index");
    _jump807:;
    if (_114 < _141.d0)
    goto _jump808;
    fail_assertion("index too large");
    _jump808:;
    if (_148 >= 0)
    goto _jump809;
    fail_assertion("negative array index");
    _jump809:;
    if (_148 < _141.d1)
    goto _jump810;
    fail_assertion("index too large");
    _jump810:;
    int64_t _149 = 0;
    _149 *= _141.d0;
    _149 += _114;
    _149 *= _141.d1;
    _149 += _148;
    double _150 = _141.data[_149];
    double _151 = -_150;
    _140 = _151;
    goto _jump811;
    _jump803:;
    _a2_double _152;
    // Computing bound for d
    _152.d0 = _115;
    if (_115 > 0) 
    goto _jump812;
    fail_assertion("non-positive loop bound");
    _jump812:;
    // Computing bound for e
    _152.d1 = _114;
    if (_114 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= _115;
    _153 *= _114;
    _153 *= sizeof(double);
    _152.data = jpl_alloc(_153);
    int64_t _154 = 0; // e
    int64_t _155 = 0; // d
    _jump814:; // Begin body of loop
    double _156 = 15.0;
    int64_t _157 = 0;
    _157 *= _152.d0;
    _157 += _155;
    _157 *= _152.d1;
    _157 += _154;
    _152.data[_157] = _156;
    _154++;
    if (_154 < _114)
    goto _jump814;
    _154 = 0;
    _155++;
    if (_155 < _115)
    goto _jump814;
    // End body of loop
    int64_t _158 = 664;
    int64_t _159 = 850;
    int64_t _160 = _114 % _159;
    if (_158 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (_158 < _152.d0)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    if (_160 >= 0)
    goto _jump817;
    fail_assertion("negative array index");
    _jump817:;
    if (_160 < _152.d1)
    goto _jump818;
    fail_assertion("index too large");
    _jump818:;
    int64_t _161 = 0;
    _161 *= _152.d0;
    _161 += _158;
    _161 *= _152.d1;
    _161 += _160;
    double _162 = _152.data[_161];
    bool _163 = false;
    bool _164 = !_163;
    double _165;
    if (!_164)
    goto _jump819;
    double _166 = 74.0;
    _165 = _166;
    goto _jump820;
    _jump819:;
    double _167;
    // Computing bound for d
    if (_115 > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    _167 = 0;
    int64_t _168 = 0; // d
    _jump822:; // Begin body of loop
    double _169 = 97.0;
    _167 += _169;
    _168++;
    if (_168 < _115)
    goto _jump822;
    // End body of loop
    _165 = _167;
    _jump820:;
    double _170 = _162 / _165;
    _140 = _170;
    _jump811:;
    double _171 = 74.0;
    double _172 = 56.0;
    double _173 = -_172;
    bool _174 = false;
    double _175;
    if (!_174)
    goto _jump823;
    double _176 = 17.0;
    _175 = _176;
    goto _jump824;
    _jump823:;
    double _177 = 32.0;
    _175 = _177;
    _jump824:;
    double _178 = 85.0;
    rgba _179 = { _171, _173, _175, _178 };
    double _180 = a(_179);
    double _181;
    // Computing bound for d
    if (_114 > 0) 
    goto _jump825;
    fail_assertion("non-positive loop bound");
    _jump825:;
    // Computing bound for e
    int64_t _182 = 782;
    if (_182 > 0) 
    goto _jump826;
    fail_assertion("non-positive loop bound");
    _jump826:;
    // Computing bound for f
    int64_t _183 = 712;
    if (_183 > 0) 
    goto _jump827;
    fail_assertion("non-positive loop bound");
    _jump827:;
    _181 = 0;
    int64_t _184 = 0; // f
    int64_t _185 = 0; // e
    int64_t _186 = 0; // d
    _jump828:; // Begin body of loop
    double _187 = 55.0;
    _181 += _187;
    _184++;
    if (_184 < _183)
    goto _jump828;
    _184 = 0;
    _185++;
    if (_185 < _182)
    goto _jump828;
    _185 = 0;
    _186++;
    if (_186 < _114)
    goto _jump828;
    // End body of loop
    double _188 = _180 - _181;
    rgba _189 = { _124, _135, _140, _188 };
    double _190 = _189.b;
    int64_t _191 = 0;
    _191 *= _0.d0;
    _191 += _115;
    _191 *= _0.d1;
    _191 += _114;
    _0.data[_191] = _190;
    _114++;
    if (_114 < _112)
    goto _jump793;
    _114 = 0;
    _115++;
    if (_115 < _111)
    goto _jump793;
    // End body of loop
    double _192;
    // Computing bound for e
    bool _193 = false;
    int64_t _194;
    if (!_193)
    goto _jump829;
    int64_t _195;
    // Computing bound for e
    double _196 = 12.0;
    double _197 = 40.0;
    bool _198 = _196 != _197;
    int64_t _199;
    if (!_198)
    goto _jump830;
    _199 = _0.d0;
    goto _jump831;
    _jump830:;
    int64_t _200 = -_0.d1;
    int64_t _201 = -_200;
    _199 = _201;
    _jump831:;
    if (_199 > 0) 
    goto _jump832;
    fail_assertion("non-positive loop bound");
    _jump832:;
    _195 = 0;
    int64_t _202 = 0; // e
    _jump833:; // Begin body of loop
    _195 += _0.d0;
    _202++;
    if (_202 < _199)
    goto _jump833;
    // End body of loop
    _194 = _195;
    goto _jump834;
    _jump829:;
    int64_t _203 = 692;
    _194 = _203;
    _jump834:;
    if (_194 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    _192 = 0;
    int64_t _204 = 0; // e
    _jump836:; // Begin body of loop
    double _205;
    // Computing bound for f
    _a2_int64_t _206;
    // Computing bound for f
    _a2_int64_t _207;
    // Computing bound for f
    int64_t _208 = 328;
    _207.d0 = _208;
    if (_208 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for g
    _207.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing total size of heap memory to allocate
    int64_t _209 = 1;
    _209 *= _208;
    _209 *= _0.d1;
    _209 *= sizeof(int64_t);
    _207.data = jpl_alloc(_209);
    int64_t _210 = 0; // g
    int64_t _211 = 0; // f
    _jump839:; // Begin body of loop
    int64_t _212 = 0;
    _212 *= _207.d0;
    _212 += _211;
    _212 *= _207.d1;
    _212 += _210;
    _207.data[_212] = _0.d1;
    _210++;
    if (_210 < _0.d1)
    goto _jump839;
    _210 = 0;
    _211++;
    if (_211 < _208)
    goto _jump839;
    // End body of loop
    int64_t _213;
    // Computing bound for f
    if (_0.d1 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for g
    int64_t _214 = 374;
    if (_214 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    _213 = 0;
    int64_t _215 = 0; // g
    int64_t _216 = 0; // f
    _jump842:; // Begin body of loop
    _213 += _216;
    _215++;
    if (_215 < _214)
    goto _jump842;
    _215 = 0;
    _216++;
    if (_216 < _0.d1)
    goto _jump842;
    // End body of loop
    if (_213 >= 0)
    goto _jump843;
    fail_assertion("negative array index");
    _jump843:;
    if (_213 < _207.d0)
    goto _jump844;
    fail_assertion("index too large");
    _jump844:;
    if (_204 >= 0)
    goto _jump845;
    fail_assertion("negative array index");
    _jump845:;
    if (_204 < _207.d1)
    goto _jump846;
    fail_assertion("index too large");
    _jump846:;
    int64_t _217 = 0;
    _217 *= _207.d0;
    _217 += _213;
    _217 *= _207.d1;
    _217 += _204;
    int64_t _218 = _207.data[_217];
    _206.d0 = _218;
    if (_218 > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing bound for g
    _206.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing total size of heap memory to allocate
    int64_t _219 = 1;
    _219 *= _218;
    _219 *= _0.d1;
    _219 *= sizeof(int64_t);
    _206.data = jpl_alloc(_219);
    int64_t _220 = 0; // g
    int64_t _221 = 0; // f
    _jump849:; // Begin body of loop
    int64_t _222 = 41;
    int64_t _223 = 0;
    _223 *= _206.d0;
    _223 += _221;
    _223 *= _206.d1;
    _223 += _220;
    _206.data[_223] = _222;
    _220++;
    if (_220 < _0.d1)
    goto _jump849;
    _220 = 0;
    _221++;
    if (_221 < _218)
    goto _jump849;
    // End body of loop
    int64_t _224 = 442;
    int64_t _225 = -_224;
    int64_t _226 = 33;
    bool _227 = _225 == _226;
    int64_t _228;
    if (!_227)
    goto _jump850;
    _228 = _204;
    goto _jump851;
    _jump850:;
    bool _229 = true;
    int64_t _230;
    if (!_229)
    goto _jump852;
    int64_t _231 = -_0.d0;
    _230 = _231;
    goto _jump853;
    _jump852:;
    int64_t _232 = 986;
    int64_t _233 = -_232;
    _230 = _233;
    _jump853:;
    _228 = _230;
    _jump851:;
    if (_0.d1 >= 0)
    goto _jump854;
    fail_assertion("negative array index");
    _jump854:;
    if (_0.d1 < _206.d0)
    goto _jump855;
    fail_assertion("index too large");
    _jump855:;
    if (_228 >= 0)
    goto _jump856;
    fail_assertion("negative array index");
    _jump856:;
    if (_228 < _206.d1)
    goto _jump857;
    fail_assertion("index too large");
    _jump857:;
    int64_t _234 = 0;
    _234 *= _206.d0;
    _234 += _0.d1;
    _234 *= _206.d1;
    _234 += _228;
    int64_t _235 = _206.data[_234];
    if (_235 > 0) 
    goto _jump858;
    fail_assertion("non-positive loop bound");
    _jump858:;
    // Computing bound for g
    if (_204 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    _205 = 0;
    int64_t _236 = 0; // g
    int64_t _237 = 0; // f
    _jump860:; // Begin body of loop
    _a3_bool _238;
    // Computing bound for h
    _238.d0 = _204;
    if (_204 > 0) 
    goto _jump861;
    fail_assertion("non-positive loop bound");
    _jump861:;
    // Computing bound for i
    _238.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump862;
    fail_assertion("non-positive loop bound");
    _jump862:;
    // Computing bound for j
    int64_t _239 = 977;
    _238.d2 = _239;
    if (_239 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing total size of heap memory to allocate
    int64_t _240 = 1;
    _240 *= _204;
    _240 *= _0.d1;
    _240 *= _239;
    _240 *= sizeof(bool);
    _238.data = jpl_alloc(_240);
    int64_t _241 = 0; // j
    int64_t _242 = 0; // i
    int64_t _243 = 0; // h
    _jump864:; // Begin body of loop
    bool _245 = true;
    bool _244 = _245;
    if (0 != _245)
    goto _jump865;
    bool _246 = false;
    _244 = _246;
    _jump865:;
    int64_t _247 = 0;
    _247 *= _238.d0;
    _247 += _243;
    _247 *= _238.d1;
    _247 += _242;
    _247 *= _238.d2;
    _247 += _241;
    _238.data[_247] = _244;
    _241++;
    if (_241 < _239)
    goto _jump864;
    _241 = 0;
    _242++;
    if (_242 < _0.d1)
    goto _jump864;
    _242 = 0;
    _243++;
    if (_243 < _204)
    goto _jump864;
    // End body of loop
    int64_t _248 = 401;
    int64_t _249 = 861;
    bool _250 = _249 == _236;
    int64_t _251;
    if (!_250)
    goto _jump866;
    int64_t _252 = 847;
    _251 = _252;
    goto _jump867;
    _jump866:;
    int64_t _253 = -_0.d0;
    _251 = _253;
    _jump867:;
    if (_248 >= 0)
    goto _jump868;
    fail_assertion("negative array index");
    _jump868:;
    if (_248 < _238.d0)
    goto _jump869;
    fail_assertion("index too large");
    _jump869:;
    if (_251 >= 0)
    goto _jump870;
    fail_assertion("negative array index");
    _jump870:;
    if (_251 < _238.d1)
    goto _jump871;
    fail_assertion("index too large");
    _jump871:;
    if (_236 >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (_236 < _238.d2)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    int64_t _254 = 0;
    _254 *= _238.d0;
    _254 += _248;
    _254 *= _238.d1;
    _254 += _251;
    _254 *= _238.d2;
    _254 += _236;
    bool _255 = _238.data[_254];
    double _256;
    if (!_255)
    goto _jump874;
    double _257;
    // Computing bound for h
    _a3_int64_t _258;
    // Computing bound for h
    int64_t _259 = 491;
    _258.d0 = _259;
    if (_259 > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for i
    _258.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing bound for j
    int64_t _260 = 928;
    _258.d2 = _260;
    if (_260 > 0) 
    goto _jump877;
    fail_assertion("non-positive loop bound");
    _jump877:;
    // Computing total size of heap memory to allocate
    int64_t _261 = 1;
    _261 *= _259;
    _261 *= _0.d1;
    _261 *= _260;
    _261 *= sizeof(int64_t);
    _258.data = jpl_alloc(_261);
    int64_t _262 = 0; // j
    int64_t _263 = 0; // i
    int64_t _264 = 0; // h
    _jump878:; // Begin body of loop
    int64_t _265 = 519;
    int64_t _266 = 0;
    _266 *= _258.d0;
    _266 += _264;
    _266 *= _258.d1;
    _266 += _263;
    _266 *= _258.d2;
    _266 += _262;
    _258.data[_266] = _265;
    _262++;
    if (_262 < _260)
    goto _jump878;
    _262 = 0;
    _263++;
    if (_263 < _0.d1)
    goto _jump878;
    _263 = 0;
    _264++;
    if (_264 < _259)
    goto _jump878;
    // End body of loop
    int64_t _267 = 822;
    int64_t _268;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing bound for i
    if (_237 > 0) 
    goto _jump880;
    fail_assertion("non-positive loop bound");
    _jump880:;
    _268 = 0;
    int64_t _269 = 0; // i
    int64_t _270 = 0; // h
    _jump881:; // Begin body of loop
    _268 += _0.d1;
    _269++;
    if (_269 < _237)
    goto _jump881;
    _269 = 0;
    _270++;
    if (_270 < _0.d1)
    goto _jump881;
    // End body of loop
    if (_267 >= 0)
    goto _jump882;
    fail_assertion("negative array index");
    _jump882:;
    if (_267 < _258.d0)
    goto _jump883;
    fail_assertion("index too large");
    _jump883:;
    if (_0.d1 >= 0)
    goto _jump884;
    fail_assertion("negative array index");
    _jump884:;
    if (_0.d1 < _258.d1)
    goto _jump885;
    fail_assertion("index too large");
    _jump885:;
    if (_268 >= 0)
    goto _jump886;
    fail_assertion("negative array index");
    _jump886:;
    if (_268 < _258.d2)
    goto _jump887;
    fail_assertion("index too large");
    _jump887:;
    int64_t _271 = 0;
    _271 *= _258.d0;
    _271 += _267;
    _271 *= _258.d1;
    _271 += _0.d1;
    _271 *= _258.d2;
    _271 += _268;
    int64_t _272 = _258.data[_271];
    if (_272 > 0) 
    goto _jump888;
    fail_assertion("non-positive loop bound");
    _jump888:;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    // Computing bound for j
    if (_204 > 0) 
    goto _jump890;
    fail_assertion("non-positive loop bound");
    _jump890:;
    _257 = 0;
    int64_t _273 = 0; // j
    int64_t _274 = 0; // i
    int64_t _275 = 0; // h
    _jump891:; // Begin body of loop
    bool _276 = false;
    double _277;
    if (!_276)
    goto _jump892;
    double _278;
    // Computing bound for k
    int64_t _279 = 209;
    if (_279 > 0) 
    goto _jump893;
    fail_assertion("non-positive loop bound");
    _jump893:;
    _278 = 0;
    int64_t _280 = 0; // k
    _jump894:; // Begin body of loop
    double _281 = 18.0;
    _278 += _281;
    _280++;
    if (_280 < _279)
    goto _jump894;
    // End body of loop
    _277 = _278;
    goto _jump895;
    _jump892:;
    double _282 = 75.0;
    _277 = _282;
    _jump895:;
    _257 += _277;
    _273++;
    if (_273 < _204)
    goto _jump891;
    _273 = 0;
    _274++;
    if (_274 < _0.d0)
    goto _jump891;
    _274 = 0;
    _275++;
    if (_275 < _272)
    goto _jump891;
    // End body of loop
    _256 = _257;
    goto _jump896;
    _jump874:;
    _a2_double _283;
    // Computing bound for h
    int64_t _284 = 639;
    int64_t _285 = -_284;
    _283.d0 = _285;
    if (_285 > 0) 
    goto _jump897;
    fail_assertion("non-positive loop bound");
    _jump897:;
    // Computing bound for i
    int64_t _286 = 770;
    _283.d1 = _286;
    if (_286 > 0) 
    goto _jump898;
    fail_assertion("non-positive loop bound");
    _jump898:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= _285;
    _287 *= _286;
    _287 *= sizeof(double);
    _283.data = jpl_alloc(_287);
    int64_t _288 = 0; // i
    int64_t _289 = 0; // h
    _jump899:; // Begin body of loop
    double _290;
    // Computing bound for j
    if (_288 > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for k
    if (_288 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing bound for l
    if (_0.d1 > 0) 
    goto _jump902;
    fail_assertion("non-positive loop bound");
    _jump902:;
    _290 = 0;
    int64_t _291 = 0; // l
    int64_t _292 = 0; // k
    int64_t _293 = 0; // j
    _jump903:; // Begin body of loop
    double _294 = 20.0;
    _290 += _294;
    _291++;
    if (_291 < _0.d1)
    goto _jump903;
    _291 = 0;
    _292++;
    if (_292 < _288)
    goto _jump903;
    _292 = 0;
    _293++;
    if (_293 < _288)
    goto _jump903;
    // End body of loop
    int64_t _295 = 0;
    _295 *= _283.d0;
    _295 += _289;
    _295 *= _283.d1;
    _295 += _288;
    _283.data[_295] = _290;
    _288++;
    if (_288 < _286)
    goto _jump899;
    _288 = 0;
    _289++;
    if (_289 < _285)
    goto _jump899;
    // End body of loop
    int64_t _296 = 1;
    int64_t _297 = _296 / _0.d1;
    if (_236 >= 0)
    goto _jump904;
    fail_assertion("negative array index");
    _jump904:;
    if (_236 < _283.d0)
    goto _jump905;
    fail_assertion("index too large");
    _jump905:;
    if (_297 >= 0)
    goto _jump906;
    fail_assertion("negative array index");
    _jump906:;
    if (_297 < _283.d1)
    goto _jump907;
    fail_assertion("index too large");
    _jump907:;
    int64_t _298 = 0;
    _298 *= _283.d0;
    _298 += _236;
    _298 *= _283.d1;
    _298 += _297;
    double _299 = _283.data[_298];
    _256 = _299;
    _jump896:;
    _205 += _256;
    _236++;
    if (_236 < _204)
    goto _jump860;
    _236 = 0;
    _237++;
    if (_237 < _235)
    goto _jump860;
    // End body of loop
    _192 += _205;
    _204++;
    if (_204 < _194)
    goto _jump836;
    // End body of loop
    double _300;
    // Computing bound for e
    int64_t _301;
    // Computing bound for e
    if (_0.d0 > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    _301 = 0;
    int64_t _302 = 0; // e
    _jump909:; // Begin body of loop
    _301 += _0.d0;
    _302++;
    if (_302 < _0.d0)
    goto _jump909;
    // End body of loop
    if (_301 > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for f
    int64_t _303 = _0.d1 % _0.d1;
    if (_303 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing bound for g
    bool _304 = false;
    int64_t _305;
    if (!_304)
    goto _jump912;
    int64_t _306 = 744;
    _305 = _306;
    goto _jump913;
    _jump912:;
    _305 = _0.d0;
    _jump913:;
    if (_305 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    _300 = 0;
    int64_t _307 = 0; // g
    int64_t _308 = 0; // f
    int64_t _309 = 0; // e
    _jump915:; // Begin body of loop
    double _310 = 19.0;
    _300 += _310;
    _307++;
    if (_307 < _305)
    goto _jump915;
    _307 = 0;
    _308++;
    if (_308 < _303)
    goto _jump915;
    _308 = 0;
    _309++;
    if (_309 < _301)
    goto _jump915;
    // End body of loop
    double _311 = -_300;
    _a3_double _312;
    // Computing bound for e
    int64_t _313 = 492;
    int64_t _314 = -_313;
    _312.d0 = _314;
    if (_314 > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    // Computing bound for f
    int64_t _315 = 399;
    _312.d1 = _315;
    if (_315 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for g
    _312.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing total size of heap memory to allocate
    int64_t _316 = 1;
    _316 *= _314;
    _316 *= _315;
    _316 *= _0.d0;
    _316 *= sizeof(double);
    _312.data = jpl_alloc(_316);
    int64_t _317 = 0; // g
    int64_t _318 = 0; // f
    int64_t _319 = 0; // e
    _jump919:; // Begin body of loop
    if (_0.d0 >= 0)
    goto _jump920;
    fail_assertion("negative array index");
    _jump920:;
    if (_0.d0 < _0.d0)
    goto _jump921;
    fail_assertion("index too large");
    _jump921:;
    if (_318 >= 0)
    goto _jump922;
    fail_assertion("negative array index");
    _jump922:;
    if (_318 < _0.d1)
    goto _jump923;
    fail_assertion("index too large");
    _jump923:;
    int64_t _320 = 0;
    _320 *= _0.d0;
    _320 += _0.d0;
    _320 *= _0.d1;
    _320 += _318;
    double _321 = _0.data[_320];
    int64_t _322 = 0;
    _322 *= _312.d0;
    _322 += _319;
    _322 *= _312.d1;
    _322 += _318;
    _322 *= _312.d2;
    _322 += _317;
    _312.data[_322] = _321;
    _317++;
    if (_317 < _0.d0)
    goto _jump919;
    _317 = 0;
    _318++;
    if (_318 < _315)
    goto _jump919;
    _318 = 0;
    _319++;
    if (_319 < _314)
    goto _jump919;
    // End body of loop
    if (_0.d0 >= 0)
    goto _jump924;
    fail_assertion("negative array index");
    _jump924:;
    if (_0.d0 < _312.d0)
    goto _jump925;
    fail_assertion("index too large");
    _jump925:;
    if (_0.d1 >= 0)
    goto _jump926;
    fail_assertion("negative array index");
    _jump926:;
    if (_0.d1 < _312.d1)
    goto _jump927;
    fail_assertion("index too large");
    _jump927:;
    if (_0.d1 >= 0)
    goto _jump928;
    fail_assertion("negative array index");
    _jump928:;
    if (_0.d1 < _312.d2)
    goto _jump929;
    fail_assertion("index too large");
    _jump929:;
    int64_t _323 = 0;
    _323 *= _312.d0;
    _323 += _0.d0;
    _323 *= _312.d1;
    _323 += _0.d1;
    _323 *= _312.d2;
    _323 += _0.d1;
    double _324 = _312.data[_323];
    bool _325 = _311 <= _324;
    rgba _326;
    if (!_325)
    goto _jump930;
    double _327 = 49.0;
    double _328;
    // Computing bound for e
    int64_t _329 = 113;
    if (_329 > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    _328 = 0;
    int64_t _330 = 0; // e
    _jump932:; // Begin body of loop
    double _331 = 3.0;
    _328 += _331;
    _330++;
    if (_330 < _329)
    goto _jump932;
    // End body of loop
    double _332 = 60.0;
    double _333 = -_332;
    double _334 = 66.0;
    double _335 = 78.0;
    rgba _336 = { _328, _333, _334, _335 };
    double _337 = _336.r;
    double _338 = 4.0;
    double _339 = 26.0;
    rgba _340 = { _327, _337, _338, _339 };
    _326 = _340;
    goto _jump933;
    _jump930:;
    double _341 = 7.0;
    double _342 = -_341;
    double _343;
    // Computing bound for e
    int64_t _344 = 532;
    if (_344 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing bound for f
    int64_t _345 = _0.d0 + _0.d1;
    if (_345 > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    _343 = 0;
    int64_t _346 = 0; // f
    int64_t _347 = 0; // e
    _jump936:; // Begin body of loop
    double _348 = 1.0;
    double _349 = -_348;
    _343 += _349;
    _346++;
    if (_346 < _345)
    goto _jump936;
    _346 = 0;
    _347++;
    if (_347 < _344)
    goto _jump936;
    // End body of loop
    double _350 = _342 * _343;
    double _351;
    // Computing bound for e
    int64_t _352 = 599;
    if (_352 > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing bound for f
    if (_0.d1 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    _351 = 0;
    int64_t _353 = 0; // f
    int64_t _354 = 0; // e
    _jump939:; // Begin body of loop
    double _355 = 70.0;
    _351 += _355;
    _353++;
    if (_353 < _0.d1)
    goto _jump939;
    _353 = 0;
    _354++;
    if (_354 < _352)
    goto _jump939;
    // End body of loop
    double _356 = 77.0;
    double _357 = 56.0;
    double _358 = -_357;
    double _359 = 10.0;
    double _360 = -_359;
    rgba _361 = { _351, _356, _358, _360 };
    double _362 = a(_361);
    double _363 = 7.0;
    double _364 = -_363;
    _a2_double _365;
    // Computing bound for e
    int64_t _366 = 161;
    _365.d0 = _366;
    if (_366 > 0) 
    goto _jump940;
    fail_assertion("non-positive loop bound");
    _jump940:;
    // Computing bound for f
    _365.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    // Computing total size of heap memory to allocate
    int64_t _367 = 1;
    _367 *= _366;
    _367 *= _0.d1;
    _367 *= sizeof(double);
    _365.data = jpl_alloc(_367);
    int64_t _368 = 0; // f
    int64_t _369 = 0; // e
    _jump942:; // Begin body of loop
    double _370 = 23.0;
    int64_t _371 = 0;
    _371 *= _365.d0;
    _371 += _369;
    _371 *= _365.d1;
    _371 += _368;
    _365.data[_371] = _370;
    _368++;
    if (_368 < _0.d1)
    goto _jump942;
    _368 = 0;
    _369++;
    if (_369 < _366)
    goto _jump942;
    // End body of loop
    int64_t _372 = 305;
    int64_t _373 = -_0.d1;
    if (_372 >= 0)
    goto _jump943;
    fail_assertion("negative array index");
    _jump943:;
    if (_372 < _365.d0)
    goto _jump944;
    fail_assertion("index too large");
    _jump944:;
    if (_373 >= 0)
    goto _jump945;
    fail_assertion("negative array index");
    _jump945:;
    if (_373 < _365.d1)
    goto _jump946;
    fail_assertion("index too large");
    _jump946:;
    int64_t _374 = 0;
    _374 *= _365.d0;
    _374 += _372;
    _374 *= _365.d1;
    _374 += _373;
    double _375 = _365.data[_374];
    rgba _376 = { _350, _362, _364, _375 };
    _326 = _376;
    _jump933:;
    double _377 = _326.r;
    bool _380 = _0.d1 > _0.d1;
    bool _381 = false;
    bool _382 = !_381;
    bool _383 = _380 == _382;
    bool _379 = _383;
    if (0 != _383)
    goto _jump947;
    bool _384 = _0.d1 >= _0.d0;
    bool _385 = !_384;
    _379 = _385;
    _jump947:;
    bool _378 = _379;
    if (0 == _379)
    goto _jump948;
    int64_t _386 = 910;
    int64_t _387 = -_0.d0;
    int64_t _388 = _386 - _387;
    int64_t _389 = 234;
    bool _390 = _0.d0 <= _389;
    int64_t _391;
    if (!_390)
    goto _jump949;
    int64_t _392 = 296;
    _391 = _392;
    goto _jump950;
    _jump949:;
    int64_t _393 = -_0.d1;
    _391 = _393;
    _jump950:;
    bool _394 = _388 >= _391;
    _378 = _394;
    _jump948:;
    rgba _395;
    if (!_378)
    goto _jump951;
    _a3_rgba _396;
    // Computing bound for e
    int64_t _397 = 933;
    _396.d0 = _397;
    if (_397 > 0) 
    goto _jump952;
    fail_assertion("non-positive loop bound");
    _jump952:;
    // Computing bound for f
    int64_t _398 = 389;
    _396.d1 = _398;
    if (_398 > 0) 
    goto _jump953;
    fail_assertion("non-positive loop bound");
    _jump953:;
    // Computing bound for g
    _396.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing total size of heap memory to allocate
    int64_t _399 = 1;
    _399 *= _397;
    _399 *= _398;
    _399 *= _0.d0;
    _399 *= sizeof(rgba);
    _396.data = jpl_alloc(_399);
    int64_t _400 = 0; // g
    int64_t _401 = 0; // f
    int64_t _402 = 0; // e
    _jump955:; // Begin body of loop
    double _403;
    // Computing bound for h
    int64_t _404 = 976;
    if (_404 > 0) 
    goto _jump956;
    fail_assertion("non-positive loop bound");
    _jump956:;
    // Computing bound for i
    int64_t _405 = 100;
    if (_405 > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    _403 = 0;
    int64_t _406 = 0; // i
    int64_t _407 = 0; // h
    _jump958:; // Begin body of loop
    double _408 = 10.0;
    _403 += _408;
    _406++;
    if (_406 < _405)
    goto _jump958;
    _406 = 0;
    _407++;
    if (_407 < _404)
    goto _jump958;
    // End body of loop
    if (_400 >= 0)
    goto _jump959;
    fail_assertion("negative array index");
    _jump959:;
    if (_400 < _0.d0)
    goto _jump960;
    fail_assertion("index too large");
    _jump960:;
    if (_0.d1 >= 0)
    goto _jump961;
    fail_assertion("negative array index");
    _jump961:;
    if (_0.d1 < _0.d1)
    goto _jump962;
    fail_assertion("index too large");
    _jump962:;
    int64_t _409 = 0;
    _409 *= _0.d0;
    _409 += _400;
    _409 *= _0.d1;
    _409 += _0.d1;
    double _410 = _0.data[_409];
    double _411 = 12.0;
    double _412 = 86.0;
    double _413 = -_412;
    rgba _414 = { _403, _410, _411, _413 };
    int64_t _415 = 0;
    _415 *= _396.d0;
    _415 += _402;
    _415 *= _396.d1;
    _415 += _401;
    _415 *= _396.d2;
    _415 += _400;
    _396.data[_415] = _414;
    _400++;
    if (_400 < _0.d0)
    goto _jump955;
    _400 = 0;
    _401++;
    if (_401 < _398)
    goto _jump955;
    _401 = 0;
    _402++;
    if (_402 < _397)
    goto _jump955;
    // End body of loop
    int64_t _416;
    // Computing bound for e
    int64_t _417 = 812;
    if (_417 > 0) 
    goto _jump963;
    fail_assertion("non-positive loop bound");
    _jump963:;
    // Computing bound for f
    int64_t _418 = 80;
    if (_418 > 0) 
    goto _jump964;
    fail_assertion("non-positive loop bound");
    _jump964:;
    // Computing bound for g
    if (_0.d0 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    _416 = 0;
    int64_t _419 = 0; // g
    int64_t _420 = 0; // f
    int64_t _421 = 0; // e
    _jump966:; // Begin body of loop
    _416 += _0.d0;
    _419++;
    if (_419 < _0.d0)
    goto _jump966;
    _419 = 0;
    _420++;
    if (_420 < _418)
    goto _jump966;
    _420 = 0;
    _421++;
    if (_421 < _417)
    goto _jump966;
    // End body of loop
    int64_t _422 = -_416;
    int64_t _423 = -_422;
    int64_t _424 = -_0.d0;
    int64_t _425 = -_424;
    int64_t _426 = -_0.d1;
    int64_t _427 = _425 - _426;
    double _429 = 71.0;
    double _430 = 24.0;
    bool _431 = _429 >= _430;
    bool _428 = _431;
    if (0 == _431)
    goto _jump967;
    bool _432 = true;
    bool _433;
    if (!_432)
    goto _jump968;
    bool _434 = false;
    _433 = _434;
    goto _jump969;
    _jump968:;
    bool _435 = true;
    _433 = _435;
    _jump969:;
    _428 = _433;
    _jump967:;
    int64_t _436;
    if (!_428)
    goto _jump970;
    int64_t _437 = 57;
    _436 = _437;
    goto _jump971;
    _jump970:;
    int64_t _438 = 847;
    int64_t _439 = -_438;
    _436 = _439;
    _jump971:;
    if (_423 >= 0)
    goto _jump972;
    fail_assertion("negative array index");
    _jump972:;
    if (_423 < _396.d0)
    goto _jump973;
    fail_assertion("index too large");
    _jump973:;
    if (_427 >= 0)
    goto _jump974;
    fail_assertion("negative array index");
    _jump974:;
    if (_427 < _396.d1)
    goto _jump975;
    fail_assertion("index too large");
    _jump975:;
    if (_436 >= 0)
    goto _jump976;
    fail_assertion("negative array index");
    _jump976:;
    if (_436 < _396.d2)
    goto _jump977;
    fail_assertion("index too large");
    _jump977:;
    int64_t _440 = 0;
    _440 *= _396.d0;
    _440 += _423;
    _440 *= _396.d1;
    _440 += _427;
    _440 *= _396.d2;
    _440 += _436;
    rgba _441 = _396.data[_440];
    _395 = _441;
    goto _jump978;
    _jump951:;
    if (_0.d1 >= 0)
    goto _jump979;
    fail_assertion("negative array index");
    _jump979:;
    if (_0.d1 < _0.d0)
    goto _jump980;
    fail_assertion("index too large");
    _jump980:;
    if (_0.d1 >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (_0.d1 < _0.d1)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    int64_t _442 = 0;
    _442 *= _0.d0;
    _442 += _0.d1;
    _442 *= _0.d1;
    _442 += _0.d1;
    double _443 = _0.data[_442];
    double _444 = 15.0;
    double _445 = 91.0;
    _a1_double _446;
    _446.d0 = 2;
    _446.data = jpl_alloc(sizeof(double) * 2);
    _446.data[0] = _444;
    _446.data[1] = _445;
    if (_0.d0 >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (_0.d0 < _446.d0)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    int64_t _447 = 0;
    _447 *= _446.d0;
    _447 += _0.d0;
    double _448 = _446.data[_447];
    double _449 = -_448;
    bool _451 = false;
    bool _450 = _451;
    if (0 == _451)
    goto _jump985;
    bool _452 = false;
    _450 = _452;
    _jump985:;
    double _453;
    if (!_450)
    goto _jump986;
    bool _454 = false;
    double _455;
    if (!_454)
    goto _jump987;
    double _456 = 73.0;
    _455 = _456;
    goto _jump988;
    _jump987:;
    double _457 = 22.0;
    _455 = _457;
    _jump988:;
    _453 = _455;
    goto _jump989;
    _jump986:;
    int64_t _458 = 890;
    if (_0.d1 >= 0)
    goto _jump990;
    fail_assertion("negative array index");
    _jump990:;
    if (_0.d1 < _0.d0)
    goto _jump991;
    fail_assertion("index too large");
    _jump991:;
    if (_458 >= 0)
    goto _jump992;
    fail_assertion("negative array index");
    _jump992:;
    if (_458 < _0.d1)
    goto _jump993;
    fail_assertion("index too large");
    _jump993:;
    int64_t _459 = 0;
    _459 *= _0.d0;
    _459 += _0.d1;
    _459 *= _0.d1;
    _459 += _458;
    double _460 = _0.data[_459];
    _453 = _460;
    _jump989:;
    double _461 = -_453;
    double _462 = 60.0;
    double _463 = 53.0;
    double _464 = _462 - _463;
    double _465 = -_464;
    rgba _466 = { _443, _449, _461, _465 };
    _395 = _466;
    _jump978:;
    double _467 = _395.b;
    double _468 = 89.0;
    rgba _469 = { _192, _377, _467, _468 };
    _a2_rgba _470;
    // Computing bound for g
    _470.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1107;
    fail_assertion("non-positive loop bound");
    _jump1107:;
    // Computing bound for h
    _a2_int64_t _471;
    // Computing bound for g
    int64_t _472;
    // Computing bound for g
    int64_t _473 = 296;
    if (_473 > 0) 
    goto _jump1108;
    fail_assertion("non-positive loop bound");
    _jump1108:;
    _472 = 0;
    int64_t _474 = 0; // g
    _jump1109:; // Begin body of loop
    int64_t _475 = -_0.d1;
    _472 += _475;
    _474++;
    if (_474 < _473)
    goto _jump1109;
    // End body of loop
    _471.d0 = _472;
    if (_472 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for h
    int64_t _476 = -_0.d1;
    _471.d1 = _476;
    if (_476 > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing total size of heap memory to allocate
    int64_t _477 = 1;
    _477 *= _472;
    _477 *= _476;
    _477 *= sizeof(int64_t);
    _471.data = jpl_alloc(_477);
    int64_t _478 = 0; // h
    int64_t _479 = 0; // g
    _jump1112:; // Begin body of loop
    bool _480 = false;
    int64_t _481;
    if (!_480)
    goto _jump1113;
    int64_t _482 = _478 - _0.d0;
    _481 = _482;
    goto _jump1114;
    _jump1113:;
    _481 = _478;
    _jump1114:;
    int64_t _483 = 0;
    _483 *= _471.d0;
    _483 += _479;
    _483 *= _471.d1;
    _483 += _478;
    _471.data[_483] = _481;
    _478++;
    if (_478 < _476)
    goto _jump1112;
    _478 = 0;
    _479++;
    if (_479 < _472)
    goto _jump1112;
    // End body of loop
    int64_t _484 = -_0.d1;
    bool _485 = true;
    bool _486 = !_485;
    bool _487 = !_486;
    int64_t _488;
    if (!_487)
    goto _jump1115;
    int64_t _489 = 870;
    _488 = _489;
    goto _jump1116;
    _jump1115:;
    int64_t _490 = 49;
    _488 = _490;
    _jump1116:;
    if (_484 >= 0)
    goto _jump1117;
    fail_assertion("negative array index");
    _jump1117:;
    if (_484 < _471.d0)
    goto _jump1118;
    fail_assertion("index too large");
    _jump1118:;
    if (_488 >= 0)
    goto _jump1119;
    fail_assertion("negative array index");
    _jump1119:;
    if (_488 < _471.d1)
    goto _jump1120;
    fail_assertion("index too large");
    _jump1120:;
    int64_t _491 = 0;
    _491 *= _471.d0;
    _491 += _484;
    _491 *= _471.d1;
    _491 += _488;
    int64_t _492 = _471.data[_491];
    _470.d1 = _492;
    if (_492 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    // Computing total size of heap memory to allocate
    int64_t _493 = 1;
    _493 *= _0.d1;
    _493 *= _492;
    _493 *= sizeof(rgba);
    _470.data = jpl_alloc(_493);
    int64_t _494 = 0; // h
    int64_t _495 = 0; // g
    _jump1122:; // Begin body of loop
    _a2_bool _496;
    // Computing bound for i
    _496.d0 = _495;
    if (_495 > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    // Computing bound for j
    _496.d1 = _495;
    if (_495 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing total size of heap memory to allocate
    int64_t _497 = 1;
    _497 *= _495;
    _497 *= _495;
    _497 *= sizeof(bool);
    _496.data = jpl_alloc(_497);
    int64_t _498 = 0; // j
    int64_t _499 = 0; // i
    _jump1125:; // Begin body of loop
    bool _500 = false;
    bool _501 = !_500;
    int64_t _502 = 0;
    _502 *= _496.d0;
    _502 += _499;
    _502 *= _496.d1;
    _502 += _498;
    _496.data[_502] = _501;
    _498++;
    if (_498 < _495)
    goto _jump1125;
    _498 = 0;
    _499++;
    if (_499 < _495)
    goto _jump1125;
    // End body of loop
    bool _503 = true;
    int64_t _504;
    if (!_503)
    goto _jump1126;
    _504 = _495;
    goto _jump1127;
    _jump1126:;
    int64_t _505;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump1128;
    fail_assertion("non-positive loop bound");
    _jump1128:;
    _505 = 0;
    int64_t _506 = 0; // i
    _jump1129:; // Begin body of loop
    _505 += _495;
    _506++;
    if (_506 < _0.d0)
    goto _jump1129;
    // End body of loop
    _504 = _505;
    _jump1127:;
    if (_494 >= 0)
    goto _jump1130;
    fail_assertion("negative array index");
    _jump1130:;
    if (_494 < _496.d0)
    goto _jump1131;
    fail_assertion("index too large");
    _jump1131:;
    if (_504 >= 0)
    goto _jump1132;
    fail_assertion("negative array index");
    _jump1132:;
    if (_504 < _496.d1)
    goto _jump1133;
    fail_assertion("index too large");
    _jump1133:;
    int64_t _507 = 0;
    _507 *= _496.d0;
    _507 += _494;
    _507 *= _496.d1;
    _507 += _504;
    bool _508 = _496.data[_507];
    rgba _509;
    if (!_508)
    goto _jump1134;
    _509 = _469;
    goto _jump1135;
    _jump1134:;
    _509 = _469;
    _jump1135:;
    int64_t _510 = 0;
    _510 *= _470.d0;
    _510 += _495;
    _510 *= _470.d1;
    _510 += _494;
    _470.data[_510] = _509;
    _494++;
    if (_494 < _492)
    goto _jump1122;
    _494 = 0;
    _495++;
    if (_495 < _0.d1)
    goto _jump1122;
    // End body of loop
    _a2_rgba _511;
    // Computing bound for g
    _a1_int64_t _512;
    // Computing bound for g
    int64_t _513 = 1000;
    _512.d0 = _513;
    if (_513 > 0) 
    goto _jump1136;
    fail_assertion("non-positive loop bound");
    _jump1136:;
    // Computing total size of heap memory to allocate
    int64_t _514 = 1;
    _514 *= _513;
    _514 *= sizeof(int64_t);
    _512.data = jpl_alloc(_514);
    int64_t _515 = 0; // g
    _jump1137:; // Begin body of loop
    int64_t _516 = 0;
    _516 *= _512.d0;
    _516 += _515;
    _512.data[_516] = _515;
    _515++;
    if (_515 < _513)
    goto _jump1137;
    // End body of loop
    int64_t _517 = 602;
    int64_t _518 = 637;
    int64_t _519 = _0.d0 - _518;
    int64_t _520 = _517 - _519;
    if (_520 >= 0)
    goto _jump1138;
    fail_assertion("negative array index");
    _jump1138:;
    if (_520 < _512.d0)
    goto _jump1139;
    fail_assertion("index too large");
    _jump1139:;
    int64_t _521 = 0;
    _521 *= _512.d0;
    _521 += _520;
    int64_t _522 = _512.data[_521];
    int64_t _523;
    // Computing bound for g
    int64_t _524 = 526;
    int64_t _525 = _0.d0 * _524;
    int64_t _526 = -_525;
    if (_526 > 0) 
    goto _jump1140;
    fail_assertion("non-positive loop bound");
    _jump1140:;
    // Computing bound for h
    int64_t _527 = -_0.d1;
    int64_t _528 = -_527;
    if (_528 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    _523 = 0;
    int64_t _529 = 0; // h
    int64_t _530 = 0; // g
    _jump1142:; // Begin body of loop
    _523 += _0.d1;
    _529++;
    if (_529 < _528)
    goto _jump1142;
    _529 = 0;
    _530++;
    if (_530 < _526)
    goto _jump1142;
    // End body of loop
    int64_t _531 = _522 % _523;
    _511.d0 = _531;
    if (_531 > 0) 
    goto _jump1143;
    fail_assertion("non-positive loop bound");
    _jump1143:;
    // Computing bound for h
    int64_t _532;
    // Computing bound for g
    bool _533 = _0.d1 == _0.d1;
    _a1_int64_t _534;
    if (!_533)
    goto _jump1144;
    int64_t _535 = 455;
    _a1_int64_t _536;
    _536.d0 = 2;
    _536.data = jpl_alloc(sizeof(int64_t) * 2);
    _536.data[0] = _535;
    _536.data[1] = _0.d1;
    _534 = _536;
    goto _jump1145;
    _jump1144:;
    int64_t _537 = 434;
    _a1_int64_t _538;
    _538.d0 = 2;
    _538.data = jpl_alloc(sizeof(int64_t) * 2);
    _538.data[0] = _0.d1;
    _538.data[1] = _537;
    _534 = _538;
    _jump1145:;
    int64_t _539 = -_0.d1;
    if (_539 >= 0)
    goto _jump1146;
    fail_assertion("negative array index");
    _jump1146:;
    if (_539 < _534.d0)
    goto _jump1147;
    fail_assertion("index too large");
    _jump1147:;
    int64_t _540 = 0;
    _540 *= _534.d0;
    _540 += _539;
    int64_t _541 = _534.data[_540];
    if (_541 > 0) 
    goto _jump1148;
    fail_assertion("non-positive loop bound");
    _jump1148:;
    // Computing bound for h
    if (_0.d0 > 0) 
    goto _jump1149;
    fail_assertion("non-positive loop bound");
    _jump1149:;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump1150;
    fail_assertion("non-positive loop bound");
    _jump1150:;
    _532 = 0;
    int64_t _542 = 0; // i
    int64_t _543 = 0; // h
    int64_t _544 = 0; // g
    _jump1151:; // Begin body of loop
    int64_t _545;
    // Computing bound for j
    int64_t _546 = 797;
    if (_546 > 0) 
    goto _jump1152;
    fail_assertion("non-positive loop bound");
    _jump1152:;
    // Computing bound for k
    if (_543 > 0) 
    goto _jump1153;
    fail_assertion("non-positive loop bound");
    _jump1153:;
    _545 = 0;
    int64_t _547 = 0; // k
    int64_t _548 = 0; // j
    _jump1154:; // Begin body of loop
    _545 += _0.d1;
    _547++;
    if (_547 < _543)
    goto _jump1154;
    _547 = 0;
    _548++;
    if (_548 < _546)
    goto _jump1154;
    // End body of loop
    int64_t _549 = _545 + _542;
    _532 += _549;
    _542++;
    if (_542 < _0.d0)
    goto _jump1151;
    _542 = 0;
    _543++;
    if (_543 < _0.d0)
    goto _jump1151;
    _543 = 0;
    _544++;
    if (_544 < _541)
    goto _jump1151;
    // End body of loop
    _511.d1 = _532;
    if (_532 > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing total size of heap memory to allocate
    int64_t _550 = 1;
    _550 *= _531;
    _550 *= _532;
    _550 *= sizeof(rgba);
    _511.data = jpl_alloc(_550);
    int64_t _551 = 0; // h
    int64_t _552 = 0; // g
    _jump1156:; // Begin body of loop
    _a1_rgba _553;
    // Computing bound for i
    bool _554 = false;
    bool _555 = !_554;
    int64_t _556;
    if (!_555)
    goto _jump1157;
    int64_t _557;
    // Computing bound for i
    if (_0.d1 > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    _557 = 0;
    int64_t _558 = 0; // i
    _jump1159:; // Begin body of loop
    _557 += _558;
    _558++;
    if (_558 < _0.d1)
    goto _jump1159;
    // End body of loop
    _556 = _557;
    goto _jump1160;
    _jump1157:;
    int64_t _559;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    // Computing bound for j
    if (_552 > 0) 
    goto _jump1162;
    fail_assertion("non-positive loop bound");
    _jump1162:;
    _559 = 0;
    int64_t _560 = 0; // j
    int64_t _561 = 0; // i
    _jump1163:; // Begin body of loop
    _559 += _560;
    _560++;
    if (_560 < _552)
    goto _jump1163;
    _560 = 0;
    _561++;
    if (_561 < _0.d0)
    goto _jump1163;
    // End body of loop
    _556 = _559;
    _jump1160:;
    _553.d0 = _556;
    if (_556 > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    // Computing total size of heap memory to allocate
    int64_t _562 = 1;
    _562 *= _556;
    _562 *= sizeof(rgba);
    _553.data = jpl_alloc(_562);
    int64_t _563 = 0; // i
    _jump1165:; // Begin body of loop
    double _564 = _469.r;
    double _565 = a(_469);
    double _566;
    // Computing bound for j
    if (_563 > 0) 
    goto _jump1166;
    fail_assertion("non-positive loop bound");
    _jump1166:;
    // Computing bound for k
    if (_0.d1 > 0) 
    goto _jump1167;
    fail_assertion("non-positive loop bound");
    _jump1167:;
    // Computing bound for l
    if (_0.d0 > 0) 
    goto _jump1168;
    fail_assertion("non-positive loop bound");
    _jump1168:;
    _566 = 0;
    int64_t _567 = 0; // l
    int64_t _568 = 0; // k
    int64_t _569 = 0; // j
    _jump1169:; // Begin body of loop
    double _570 = 13.0;
    _566 += _570;
    _567++;
    if (_567 < _0.d0)
    goto _jump1169;
    _567 = 0;
    _568++;
    if (_568 < _0.d1)
    goto _jump1169;
    _568 = 0;
    _569++;
    if (_569 < _563)
    goto _jump1169;
    // End body of loop
    double _571 = 52.0;
    rgba _572 = { _564, _565, _566, _571 };
    int64_t _573 = 0;
    _573 *= _553.d0;
    _573 += _563;
    _553.data[_573] = _572;
    _563++;
    if (_563 < _556)
    goto _jump1165;
    // End body of loop
    int64_t _574 = _551 - _0.d0;
    if (_574 >= 0)
    goto _jump1170;
    fail_assertion("negative array index");
    _jump1170:;
    if (_574 < _553.d0)
    goto _jump1171;
    fail_assertion("index too large");
    _jump1171:;
    int64_t _575 = 0;
    _575 *= _553.d0;
    _575 += _574;
    rgba _576 = _553.data[_575];
    int64_t _577 = 0;
    _577 *= _511.d0;
    _577 += _552;
    _577 *= _511.d1;
    _577 += _551;
    _511.data[_577] = _576;
    _551++;
    if (_551 < _532)
    goto _jump1156;
    _551 = 0;
    _552++;
    if (_552 < _531)
    goto _jump1156;
    // End body of loop
    _a2_rgba _578;
    // Computing bound for g
    _578.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1172;
    fail_assertion("non-positive loop bound");
    _jump1172:;
    // Computing bound for h
    int64_t _579 = -_0.d1;
    int64_t _580 = _0.d0 % _579;
    _578.d1 = _580;
    if (_580 > 0) 
    goto _jump1173;
    fail_assertion("non-positive loop bound");
    _jump1173:;
    // Computing total size of heap memory to allocate
    int64_t _581 = 1;
    _581 *= _0.d0;
    _581 *= _580;
    _581 *= sizeof(rgba);
    _578.data = jpl_alloc(_581);
    int64_t _582 = 0; // h
    int64_t _583 = 0; // g
    _jump1174:; // Begin body of loop
    int64_t _584 = 0;
    _584 *= _578.d0;
    _584 += _583;
    _584 *= _578.d1;
    _584 += _582;
    _578.data[_584] = _469;
    _582++;
    if (_582 < _580)
    goto _jump1174;
    _582 = 0;
    _583++;
    if (_583 < _0.d0)
    goto _jump1174;
    // End body of loop
    _a1__a2_rgba _585;
    _585.d0 = 3;
    _585.data = jpl_alloc(sizeof(_a2_rgba) * 3);
    _585.data[0] = _470;
    _585.data[1] = _511;
    _585.data[2] = _578;
    int64_t _587;
    // Computing bound for g
    if (_0.d1 > 0) 
    goto _jump1175;
    fail_assertion("non-positive loop bound");
    _jump1175:;
    _587 = 0;
    int64_t _588 = 0; // g
    _jump1176:; // Begin body of loop
    _587 += _588;
    _588++;
    if (_588 < _0.d1)
    goto _jump1176;
    // End body of loop
    bool _589 = _587 == _0.d1;
    bool _586 = _589;
    if (0 != _589)
    goto _jump1177;
    int64_t _590 = 671;
    int64_t _591 = -_590;
    int64_t _592 = 40;
    int64_t _593 = -_592;
    bool _594 = _591 < _593;
    _586 = _594;
    _jump1177:;
    int64_t _595;
    if (!_586)
    goto _jump1178;
    _595 = _0.d1;
    goto _jump1179;
    _jump1178:;
    int64_t _596;
    // Computing bound for g
    int64_t _597 = 571;
    if (_597 > 0) 
    goto _jump1180;
    fail_assertion("non-positive loop bound");
    _jump1180:;
    // Computing bound for h
    if (_0.d1 > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump1182;
    fail_assertion("non-positive loop bound");
    _jump1182:;
    _596 = 0;
    int64_t _598 = 0; // i
    int64_t _599 = 0; // h
    int64_t _600 = 0; // g
    _jump1183:; // Begin body of loop
    _a2_int64_t _601;
    // Computing bound for j
    int64_t _602 = 749;
    _601.d0 = _602;
    if (_602 > 0) 
    goto _jump1184;
    fail_assertion("non-positive loop bound");
    _jump1184:;
    // Computing bound for k
    _601.d1 = _599;
    if (_599 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing total size of heap memory to allocate
    int64_t _603 = 1;
    _603 *= _602;
    _603 *= _599;
    _603 *= sizeof(int64_t);
    _601.data = jpl_alloc(_603);
    int64_t _604 = 0; // k
    int64_t _605 = 0; // j
    _jump1186:; // Begin body of loop
    int64_t _606 = 0;
    _606 *= _601.d0;
    _606 += _605;
    _606 *= _601.d1;
    _606 += _604;
    _601.data[_606] = _0.d1;
    _604++;
    if (_604 < _599)
    goto _jump1186;
    _604 = 0;
    _605++;
    if (_605 < _602)
    goto _jump1186;
    // End body of loop
    int64_t _607;
    // Computing bound for j
    if (_600 > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    // Computing bound for k
    if (_0.d0 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    _607 = 0;
    int64_t _608 = 0; // k
    int64_t _609 = 0; // j
    _jump1189:; // Begin body of loop
    _607 += _0.d1;
    _608++;
    if (_608 < _0.d0)
    goto _jump1189;
    _608 = 0;
    _609++;
    if (_609 < _600)
    goto _jump1189;
    // End body of loop
    if (_607 >= 0)
    goto _jump1190;
    fail_assertion("negative array index");
    _jump1190:;
    if (_607 < _601.d0)
    goto _jump1191;
    fail_assertion("index too large");
    _jump1191:;
    if (_0.d1 >= 0)
    goto _jump1192;
    fail_assertion("negative array index");
    _jump1192:;
    if (_0.d1 < _601.d1)
    goto _jump1193;
    fail_assertion("index too large");
    _jump1193:;
    int64_t _610 = 0;
    _610 *= _601.d0;
    _610 += _607;
    _610 *= _601.d1;
    _610 += _0.d1;
    int64_t _611 = _601.data[_610];
    _596 += _611;
    _598++;
    if (_598 < _0.d0)
    goto _jump1183;
    _598 = 0;
    _599++;
    if (_599 < _0.d1)
    goto _jump1183;
    _599 = 0;
    _600++;
    if (_600 < _597)
    goto _jump1183;
    // End body of loop
    int64_t _612 = -_596;
    _595 = _612;
    _jump1179:;
    int64_t _613 = -_595;
    if (_613 >= 0)
    goto _jump1194;
    fail_assertion("negative array index");
    _jump1194:;
    if (_613 < _585.d0)
    goto _jump1195;
    fail_assertion("index too large");
    _jump1195:;
    int64_t _614 = 0;
    _614 *= _585.d0;
    _614 += _613;
    _a2_rgba _615 = _585.data[_614];
    write_image(_615, "g.png");
    double _616 = get_time();
    int64_t _617 = 193;
    double _618 = get_time();
    print_time(_618 - _616);
    double _619 = get_time();
    _a2_rgba _620;
    // Computing bound for h
    _a3_int64_t _621;
    // Computing bound for h
    _621.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for i
    _621.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing bound for j
    _621.d2 = _617;
    if (_617 > 0) 
    goto _jump1198;
    fail_assertion("non-positive loop bound");
    _jump1198:;
    // Computing total size of heap memory to allocate
    int64_t _622 = 1;
    _622 *= _0.d0;
    _622 *= _0.d0;
    _622 *= _617;
    _622 *= sizeof(int64_t);
    _621.data = jpl_alloc(_622);
    int64_t _623 = 0; // j
    int64_t _624 = 0; // i
    int64_t _625 = 0; // h
    _jump1199:; // Begin body of loop
    int64_t _626 = 0;
    _626 *= _621.d0;
    _626 += _625;
    _626 *= _621.d1;
    _626 += _624;
    _626 *= _621.d2;
    _626 += _623;
    _621.data[_626] = _624;
    _623++;
    if (_623 < _617)
    goto _jump1199;
    _623 = 0;
    _624++;
    if (_624 < _0.d0)
    goto _jump1199;
    _624 = 0;
    _625++;
    if (_625 < _0.d0)
    goto _jump1199;
    // End body of loop
    int64_t _627 = _0.d1 * _617;
    int64_t _628;
    // Computing bound for h
    int64_t _629 = 582;
    if (_629 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing bound for i
    int64_t _630 = 185;
    if (_630 > 0) 
    goto _jump1201;
    fail_assertion("non-positive loop bound");
    _jump1201:;
    // Computing bound for j
    if (_0.d0 > 0) 
    goto _jump1202;
    fail_assertion("non-positive loop bound");
    _jump1202:;
    _628 = 0;
    int64_t _631 = 0; // j
    int64_t _632 = 0; // i
    int64_t _633 = 0; // h
    _jump1203:; // Begin body of loop
    _628 += _0.d1;
    _631++;
    if (_631 < _0.d0)
    goto _jump1203;
    _631 = 0;
    _632++;
    if (_632 < _630)
    goto _jump1203;
    _632 = 0;
    _633++;
    if (_633 < _629)
    goto _jump1203;
    // End body of loop
    if (_617 >= 0)
    goto _jump1204;
    fail_assertion("negative array index");
    _jump1204:;
    if (_617 < _621.d0)
    goto _jump1205;
    fail_assertion("index too large");
    _jump1205:;
    if (_627 >= 0)
    goto _jump1206;
    fail_assertion("negative array index");
    _jump1206:;
    if (_627 < _621.d1)
    goto _jump1207;
    fail_assertion("index too large");
    _jump1207:;
    if (_628 >= 0)
    goto _jump1208;
    fail_assertion("negative array index");
    _jump1208:;
    if (_628 < _621.d2)
    goto _jump1209;
    fail_assertion("index too large");
    _jump1209:;
    int64_t _634 = 0;
    _634 *= _621.d0;
    _634 += _617;
    _634 *= _621.d1;
    _634 += _627;
    _634 *= _621.d2;
    _634 += _628;
    int64_t _635 = _621.data[_634];
    int64_t _636 = _635 * _0.d1;
    _620.d0 = _636;
    if (_636 > 0) 
    goto _jump1210;
    fail_assertion("non-positive loop bound");
    _jump1210:;
    // Computing bound for i
    _a1_int64_t _637;
    // Computing bound for h
    _637.d0 = _617;
    if (_617 > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    // Computing total size of heap memory to allocate
    int64_t _638 = 1;
    _638 *= _617;
    _638 *= sizeof(int64_t);
    _637.data = jpl_alloc(_638);
    int64_t _639 = 0; // h
    _jump1212:; // Begin body of loop
    bool _640 = true;
    int64_t _641;
    if (!_640)
    goto _jump1213;
    int64_t _642 = 238;
    _641 = _642;
    goto _jump1214;
    _jump1213:;
    _641 = _617;
    _jump1214:;
    int64_t _643 = 0;
    _643 *= _637.d0;
    _643 += _639;
    _637.data[_643] = _641;
    _639++;
    if (_639 < _617)
    goto _jump1212;
    // End body of loop
    int64_t _644 = 714;
    if (_644 >= 0)
    goto _jump1215;
    fail_assertion("negative array index");
    _jump1215:;
    if (_644 < _637.d0)
    goto _jump1216;
    fail_assertion("index too large");
    _jump1216:;
    int64_t _645 = 0;
    _645 *= _637.d0;
    _645 += _644;
    int64_t _646 = _637.data[_645];
    _620.d1 = _646;
    if (_646 > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    // Computing total size of heap memory to allocate
    int64_t _647 = 1;
    _647 *= _636;
    _647 *= _646;
    _647 *= sizeof(rgba);
    _620.data = jpl_alloc(_647);
    int64_t _648 = 0; // i
    int64_t _649 = 0; // h
    _jump1218:; // Begin body of loop
    double _650 = a(_469);
    double _651 = 2.0;
    bool _652 = _650 == _651;
    rgba _653;
    if (!_652)
    goto _jump1219;
    _653 = _469;
    goto _jump1220;
    _jump1219:;
    _653 = _469;
    _jump1220:;
    int64_t _654 = 0;
    _654 *= _620.d0;
    _654 += _649;
    _654 *= _620.d1;
    _654 += _648;
    _620.data[_654] = _653;
    _648++;
    if (_648 < _646)
    goto _jump1218;
    _648 = 0;
    _649++;
    if (_649 < _636)
    goto _jump1218;
    // End body of loop
    int64_t _655 = 412;
    double _656 = _469.r;
    double _657 = -_656;
    double _658;
    // Computing bound for h
    int64_t _659 = -_617;
    if (_659 > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    _658 = 0;
    int64_t _660 = 0; // h
    _jump1222:; // Begin body of loop
    double _661 = a(_469);
    _658 += _661;
    _660++;
    if (_660 < _659)
    goto _jump1222;
    // End body of loop
    bool _662 = _657 == _658;
    int64_t _663;
    if (!_662)
    goto _jump1223;
    _a1_int64_t _664;
    _664.d0 = 2;
    _664.data = jpl_alloc(sizeof(int64_t) * 2);
    _664.data[0] = _0.d1;
    _664.data[1] = _617;
    int64_t _665 = 463;
    int64_t _666 = -_665;
    if (_666 >= 0)
    goto _jump1224;
    fail_assertion("negative array index");
    _jump1224:;
    if (_666 < _664.d0)
    goto _jump1225;
    fail_assertion("index too large");
    _jump1225:;
    int64_t _667 = 0;
    _667 *= _664.d0;
    _667 += _666;
    int64_t _668 = _664.data[_667];
    int64_t _669 = -_668;
    _663 = _669;
    goto _jump1226;
    _jump1223:;
    int64_t _670 = 634;
    _663 = _670;
    _jump1226:;
    if (_655 >= 0)
    goto _jump1227;
    fail_assertion("negative array index");
    _jump1227:;
    if (_655 < _620.d0)
    goto _jump1228;
    fail_assertion("index too large");
    _jump1228:;
    if (_663 >= 0)
    goto _jump1229;
    fail_assertion("negative array index");
    _jump1229:;
    if (_663 < _620.d1)
    goto _jump1230;
    fail_assertion("index too large");
    _jump1230:;
    int64_t _671 = 0;
    _671 *= _620.d0;
    _671 += _655;
    _671 *= _620.d1;
    _671 += _663;
    rgba _672 = _620.data[_671];
    double _673 = a(_672);
    double _674 = get_time();
    print_time(_674 - _619);
    double _675 = get_time();
    double _676 = 33.0;
    double _677 = _673 / _676;
    bool _678 = _673 >= _677;
    int64_t _679;
    if (!_678)
    goto _jump1231;
    int64_t _680;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump1232;
    fail_assertion("non-positive loop bound");
    _jump1232:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    _680 = 0;
    int64_t _681 = 0; // j
    int64_t _682 = 0; // i
    _jump1234:; // Begin body of loop
    _680 += _0.d1;
    _681++;
    if (_681 < _0.d1)
    goto _jump1234;
    _681 = 0;
    _682++;
    if (_682 < _0.d0)
    goto _jump1234;
    // End body of loop
    int64_t _683 = -_0.d1;
    int64_t _684 = _680 + _683;
    _679 = _684;
    goto _jump1235;
    _jump1231:;
    int64_t _685 = _617 - _617;
    _679 = _685;
    _jump1235:;
    int64_t _686 = -_679;
    int64_t _687;
    // Computing bound for i
    if (_0.d0 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing bound for j
    if (_0.d1 > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    // Computing bound for k
    int64_t _688 = 318;
    if (_688 > 0) 
    goto _jump1238;
    fail_assertion("non-positive loop bound");
    _jump1238:;
    _687 = 0;
    int64_t _689 = 0; // k
    int64_t _690 = 0; // j
    int64_t _691 = 0; // i
    _jump1239:; // Begin body of loop
    _687 += _0.d0;
    _689++;
    if (_689 < _688)
    goto _jump1239;
    _689 = 0;
    _690++;
    if (_690 < _0.d1)
    goto _jump1239;
    _690 = 0;
    _691++;
    if (_691 < _0.d0)
    goto _jump1239;
    // End body of loop
    bool _692 = _686 < _687;
    _a1_int64_t _693;
    if (!_692)
    goto _jump1240;
    int64_t _694 = -_617;
    bool _695 = _617 < _694;
    _a1_int64_t _696;
    if (!_695)
    goto _jump1241;
    bool _698 = _0.d0 == _617;
    bool _697 = _698;
    if (0 != _698)
    goto _jump1242;
    double _699 = 75.0;
    double _700 = 46.0;
    bool _701 = _699 < _700;
    _697 = _701;
    _jump1242:;
    _a1_int64_t _702;
    if (!_697)
    goto _jump1243;
    _a1_int64_t _703;
    _703.d0 = 2;
    _703.data = jpl_alloc(sizeof(int64_t) * 2);
    _703.data[0] = _617;
    _703.data[1] = _617;
    _a1_int64_t _704;
    // Computing bound for i
    _704.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1244;
    fail_assertion("non-positive loop bound");
    _jump1244:;
    // Computing total size of heap memory to allocate
    int64_t _705 = 1;
    _705 *= _0.d1;
    _705 *= sizeof(int64_t);
    _704.data = jpl_alloc(_705);
    int64_t _706 = 0; // i
    _jump1245:; // Begin body of loop
    int64_t _707 = 0;
    _707 *= _704.d0;
    _707 += _706;
    _704.data[_707] = _0.d1;
    _706++;
    if (_706 < _0.d1)
    goto _jump1245;
    // End body of loop
    _a1__a1_int64_t _708;
    _708.d0 = 2;
    _708.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _708.data[0] = _703;
    _708.data[1] = _704;
    if (_0.d0 >= 0)
    goto _jump1246;
    fail_assertion("negative array index");
    _jump1246:;
    if (_0.d0 < _708.d0)
    goto _jump1247;
    fail_assertion("index too large");
    _jump1247:;
    int64_t _709 = 0;
    _709 *= _708.d0;
    _709 += _0.d0;
    _a1_int64_t _710 = _708.data[_709];
    _702 = _710;
    goto _jump1248;
    _jump1243:;
    _a1_int64_t _711;
    _711.d0 = 1;
    _711.data = jpl_alloc(sizeof(int64_t) * 1);
    _711.data[0] = _0.d1;
    _702 = _711;
    _jump1248:;
    _696 = _702;
    goto _jump1249;
    _jump1241:;
    int64_t _712 = -_0.d0;
    int64_t _713 = -_712;
    int64_t _714 = _617 + _713;
    _a1_int64_t _715;
    _715.d0 = 2;
    _715.data = jpl_alloc(sizeof(int64_t) * 2);
    _715.data[0] = _0.d1;
    _715.data[1] = _714;
    _696 = _715;
    _jump1249:;
    _693 = _696;
    goto _jump1250;
    _jump1240:;
    bool _716 = _617 > _617;
    _a1_int64_t _717;
    if (!_716)
    goto _jump1251;
    int64_t _718 = 489;
    int64_t _719 = _0.d0 + _0.d0;
    _a1_int64_t _720;
    _720.d0 = 2;
    _720.data = jpl_alloc(sizeof(int64_t) * 2);
    _720.data[0] = _718;
    _720.data[1] = _719;
    _717 = _720;
    goto _jump1252;
    _jump1251:;
    int64_t _721 = 593;
    bool _722 = _721 != _0.d1;
    bool _723 = !_722;
    _a3__a1_int64_t _724;
    if (!_723)
    goto _jump1253;
    _a3__a1_int64_t _725;
    // Computing bound for i
    _725.d0 = _617;
    if (_617 > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    // Computing bound for j
    _725.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1255;
    fail_assertion("non-positive loop bound");
    _jump1255:;
    // Computing bound for k
    bool _726 = true;
    int64_t _727;
    if (!_726)
    goto _jump1256;
    int64_t _728 = 662;
    _727 = _728;
    goto _jump1257;
    _jump1256:;
    _727 = _0.d1;
    _jump1257:;
    _725.d2 = _727;
    if (_727 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    // Computing total size of heap memory to allocate
    int64_t _729 = 1;
    _729 *= _617;
    _729 *= _0.d1;
    _729 *= _727;
    _729 *= sizeof(_a1_int64_t);
    _725.data = jpl_alloc(_729);
    int64_t _730 = 0; // k
    int64_t _731 = 0; // j
    int64_t _732 = 0; // i
    _jump1259:; // Begin body of loop
    _a1_int64_t _733;
    _733.d0 = 3;
    _733.data = jpl_alloc(sizeof(int64_t) * 3);
    _733.data[0] = _732;
    _733.data[1] = _617;
    _733.data[2] = _731;
    int64_t _734 = 0;
    _734 *= _725.d0;
    _734 += _732;
    _734 *= _725.d1;
    _734 += _731;
    _734 *= _725.d2;
    _734 += _730;
    _725.data[_734] = _733;
    _730++;
    if (_730 < _727)
    goto _jump1259;
    _730 = 0;
    _731++;
    if (_731 < _0.d1)
    goto _jump1259;
    _731 = 0;
    _732++;
    if (_732 < _617)
    goto _jump1259;
    // End body of loop
    _724 = _725;
    goto _jump1260;
    _jump1253:;
    _a3__a1_int64_t _735;
    // Computing bound for i
    int64_t _736 = 142;
    _735.d0 = _736;
    if (_736 > 0) 
    goto _jump1261;
    fail_assertion("non-positive loop bound");
    _jump1261:;
    // Computing bound for j
    bool _737 = true;
    int64_t _738;
    if (!_737)
    goto _jump1262;
    _738 = _0.d1;
    goto _jump1263;
    _jump1262:;
    _738 = _0.d0;
    _jump1263:;
    _735.d1 = _738;
    if (_738 > 0) 
    goto _jump1264;
    fail_assertion("non-positive loop bound");
    _jump1264:;
    // Computing bound for k
    _735.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1265;
    fail_assertion("non-positive loop bound");
    _jump1265:;
    // Computing total size of heap memory to allocate
    int64_t _739 = 1;
    _739 *= _736;
    _739 *= _738;
    _739 *= _0.d0;
    _739 *= sizeof(_a1_int64_t);
    _735.data = jpl_alloc(_739);
    int64_t _740 = 0; // k
    int64_t _741 = 0; // j
    int64_t _742 = 0; // i
    _jump1266:; // Begin body of loop
    _a1_int64_t _743;
    _743.d0 = 2;
    _743.data = jpl_alloc(sizeof(int64_t) * 2);
    _743.data[0] = _0.d0;
    _743.data[1] = _617;
    int64_t _744 = 0;
    _744 *= _735.d0;
    _744 += _742;
    _744 *= _735.d1;
    _744 += _741;
    _744 *= _735.d2;
    _744 += _740;
    _735.data[_744] = _743;
    _740++;
    if (_740 < _0.d0)
    goto _jump1266;
    _740 = 0;
    _741++;
    if (_741 < _738)
    goto _jump1266;
    _741 = 0;
    _742++;
    if (_742 < _736)
    goto _jump1266;
    // End body of loop
    _724 = _735;
    _jump1260:;
    int64_t _745 = 635;
    int64_t _746 = -_0.d1;
    int64_t _747;
    // Computing bound for i
    int64_t _748 = 646;
    if (_748 > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    _747 = 0;
    int64_t _749 = 0; // i
    _jump1268:; // Begin body of loop
    _747 += _0.d1;
    _749++;
    if (_749 < _748)
    goto _jump1268;
    // End body of loop
    int64_t _750 = -_747;
    if (_745 >= 0)
    goto _jump1269;
    fail_assertion("negative array index");
    _jump1269:;
    if (_745 < _724.d0)
    goto _jump1270;
    fail_assertion("index too large");
    _jump1270:;
    if (_746 >= 0)
    goto _jump1271;
    fail_assertion("negative array index");
    _jump1271:;
    if (_746 < _724.d1)
    goto _jump1272;
    fail_assertion("index too large");
    _jump1272:;
    if (_750 >= 0)
    goto _jump1273;
    fail_assertion("negative array index");
    _jump1273:;
    if (_750 < _724.d2)
    goto _jump1274;
    fail_assertion("index too large");
    _jump1274:;
    int64_t _751 = 0;
    _751 *= _724.d0;
    _751 += _745;
    _751 *= _724.d1;
    _751 += _746;
    _751 *= _724.d2;
    _751 += _750;
    _a1_int64_t _752 = _724.data[_751];
    _717 = _752;
    _jump1252:;
    _693 = _717;
    _jump1250:;
    double _753 = get_time();
    print_time(_753 - _675);
    print("l");
    int64_t _754;
    // Computing bound for m
    int64_t _755 = 223;
    int64_t _756 = -_755;
    if (_756 > 0) 
    goto _jump1291;
    fail_assertion("non-positive loop bound");
    _jump1291:;
    _754 = 0;
    int64_t _757 = 0; // m
    _jump1292:; // Begin body of loop
    _754 += _757;
    _757++;
    if (_757 < _756)
    goto _jump1292;
    // End body of loop
    _a3_int64_t _758;
    // Computing bound for m
    _758.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1293;
    fail_assertion("non-positive loop bound");
    _jump1293:;
    // Computing bound for n
    int64_t _759 = 995;
    _758.d1 = _759;
    if (_759 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    // Computing bound for o
    int64_t _760 = 575;
    _758.d2 = _760;
    if (_760 > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing total size of heap memory to allocate
    int64_t _761 = 1;
    _761 *= _0.d1;
    _761 *= _759;
    _761 *= _760;
    _761 *= sizeof(int64_t);
    _758.data = jpl_alloc(_761);
    int64_t _762 = 0; // o
    int64_t _763 = 0; // n
    int64_t _764 = 0; // m
    _jump1296:; // Begin body of loop
    int64_t _765 = 0;
    _765 *= _758.d0;
    _765 += _764;
    _765 *= _758.d1;
    _765 += _763;
    _765 *= _758.d2;
    _765 += _762;
    _758.data[_765] = _764;
    _762++;
    if (_762 < _760)
    goto _jump1296;
    _762 = 0;
    _763++;
    if (_763 < _759)
    goto _jump1296;
    _763 = 0;
    _764++;
    if (_764 < _0.d1)
    goto _jump1296;
    // End body of loop
    int64_t _766 = -_0.d1;
    int64_t _767 = 770;
    int64_t _768 = _767 + _617;
    if (_617 >= 0)
    goto _jump1297;
    fail_assertion("negative array index");
    _jump1297:;
    if (_617 < _758.d0)
    goto _jump1298;
    fail_assertion("index too large");
    _jump1298:;
    if (_766 >= 0)
    goto _jump1299;
    fail_assertion("negative array index");
    _jump1299:;
    if (_766 < _758.d1)
    goto _jump1300;
    fail_assertion("index too large");
    _jump1300:;
    if (_768 >= 0)
    goto _jump1301;
    fail_assertion("negative array index");
    _jump1301:;
    if (_768 < _758.d2)
    goto _jump1302;
    fail_assertion("index too large");
    _jump1302:;
    int64_t _769 = 0;
    _769 *= _758.d0;
    _769 += _617;
    _769 *= _758.d1;
    _769 += _766;
    _769 *= _758.d2;
    _769 += _768;
    int64_t _770 = _758.data[_769];
    bool _771 = _754 == _770;
    bool _772;
    if (!_771)
    goto _jump1303;
    _a3_double _773;
    // Computing bound for m
    _773.d0 = _617;
    if (_617 > 0) 
    goto _jump1304;
    fail_assertion("non-positive loop bound");
    _jump1304:;
    // Computing bound for n
    _773.d1 = _693.d0;
    if (_693.d0 > 0) 
    goto _jump1305;
    fail_assertion("non-positive loop bound");
    _jump1305:;
    // Computing bound for o
    _773.d2 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1306;
    fail_assertion("non-positive loop bound");
    _jump1306:;
    // Computing total size of heap memory to allocate
    int64_t _774 = 1;
    _774 *= _617;
    _774 *= _693.d0;
    _774 *= _0.d1;
    _774 *= sizeof(double);
    _773.data = jpl_alloc(_774);
    int64_t _775 = 0; // o
    int64_t _776 = 0; // n
    int64_t _777 = 0; // m
    _jump1307:; // Begin body of loop
    int64_t _778 = 0;
    _778 *= _773.d0;
    _778 += _777;
    _778 *= _773.d1;
    _778 += _776;
    _778 *= _773.d2;
    _778 += _775;
    _773.data[_778] = _673;
    _775++;
    if (_775 < _0.d1)
    goto _jump1307;
    _775 = 0;
    _776++;
    if (_776 < _693.d0)
    goto _jump1307;
    _776 = 0;
    _777++;
    if (_777 < _617)
    goto _jump1307;
    // End body of loop
    int64_t _779 = 20;
    int64_t _780 = -_779;
    int64_t _781 = 213;
    int64_t _782 = _617 / _781;
    if (_780 >= 0)
    goto _jump1308;
    fail_assertion("negative array index");
    _jump1308:;
    if (_780 < _773.d0)
    goto _jump1309;
    fail_assertion("index too large");
    _jump1309:;
    if (_0.d0 >= 0)
    goto _jump1310;
    fail_assertion("negative array index");
    _jump1310:;
    if (_0.d0 < _773.d1)
    goto _jump1311;
    fail_assertion("index too large");
    _jump1311:;
    if (_782 >= 0)
    goto _jump1312;
    fail_assertion("negative array index");
    _jump1312:;
    if (_782 < _773.d2)
    goto _jump1313;
    fail_assertion("index too large");
    _jump1313:;
    int64_t _783 = 0;
    _783 *= _773.d0;
    _783 += _780;
    _783 *= _773.d1;
    _783 += _0.d0;
    _783 *= _773.d2;
    _783 += _782;
    double _784 = _773.data[_783];
    double _785;
    // Computing bound for m
    bool _786 = false;
    int64_t _787;
    if (!_786)
    goto _jump1314;
    _787 = _0.d1;
    goto _jump1315;
    _jump1314:;
    _787 = _0.d1;
    _jump1315:;
    if (_787 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    // Computing bound for n
    if (_0.d1 > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    _785 = 0;
    int64_t _788 = 0; // n
    int64_t _789 = 0; // m
    _jump1318:; // Begin body of loop
    double _790 = -_673;
    _785 += _790;
    _788++;
    if (_788 < _0.d1)
    goto _jump1318;
    _788 = 0;
    _789++;
    if (_789 < _787)
    goto _jump1318;
    // End body of loop
    bool _791 = _784 > _785;
    _772 = _791;
    goto _jump1319;
    _jump1303:;
    bool _792 = true;
    bool _793;
    if (!_792)
    goto _jump1320;
    bool _795 = _617 == _0.d1;
    bool _794 = _795;
    if (0 != _795)
    goto _jump1321;
    bool _796 = false;
    bool _797 = false;
    bool _798 = _796 != _797;
    _794 = _798;
    _jump1321:;
    _793 = _794;
    goto _jump1322;
    _jump1320:;
    bool _799 = false;
    _793 = _799;
    _jump1322:;
    _772 = _793;
    _jump1319:;
    int64_t _800 = -_617;
    bool _801 = _800 >= _0.d0;
    _a2_bool _802;
    // Computing bound for m
    _802.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    // Computing bound for n
    int64_t _803 = 153;
    _802.d1 = _803;
    if (_803 > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing total size of heap memory to allocate
    int64_t _804 = 1;
    _804 *= _0.d1;
    _804 *= _803;
    _804 *= sizeof(bool);
    _802.data = jpl_alloc(_804);
    int64_t _805 = 0; // n
    int64_t _806 = 0; // m
    _jump1325:; // Begin body of loop
    bool _807 = true;
    int64_t _808 = 0;
    _808 *= _802.d0;
    _808 += _806;
    _808 *= _802.d1;
    _808 += _805;
    _802.data[_808] = _807;
    _805++;
    if (_805 < _803)
    goto _jump1325;
    _805 = 0;
    _806++;
    if (_806 < _0.d1)
    goto _jump1325;
    // End body of loop
    if (_693.d0 >= 0)
    goto _jump1326;
    fail_assertion("negative array index");
    _jump1326:;
    if (_693.d0 < _693.d0)
    goto _jump1327;
    fail_assertion("index too large");
    _jump1327:;
    int64_t _809 = 0;
    _809 *= _693.d0;
    _809 += _693.d0;
    int64_t _810 = _693.data[_809];
    int64_t _811 = _617 * _617;
    if (_810 >= 0)
    goto _jump1328;
    fail_assertion("negative array index");
    _jump1328:;
    if (_810 < _802.d0)
    goto _jump1329;
    fail_assertion("index too large");
    _jump1329:;
    if (_811 >= 0)
    goto _jump1330;
    fail_assertion("negative array index");
    _jump1330:;
    if (_811 < _802.d1)
    goto _jump1331;
    fail_assertion("index too large");
    _jump1331:;
    int64_t _812 = 0;
    _812 *= _802.d0;
    _812 += _810;
    _812 *= _802.d1;
    _812 += _811;
    bool _813 = _802.data[_812];
    double _814 = a(_469);
    double _815 = _469.b;
    bool _816 = _814 >= _815;
    _a1_bool _817;
    _817.d0 = 3;
    _817.data = jpl_alloc(sizeof(bool) * 3);
    _817.data[0] = _801;
    _817.data[1] = _813;
    _817.data[2] = _816;
    int64_t _818 = -_693.d0;
    int64_t _819 = _617 % _818;
    int64_t _820 = -_819;
    if (_820 >= 0)
    goto _jump1332;
    fail_assertion("negative array index");
    _jump1332:;
    if (_820 < _817.d0)
    goto _jump1333;
    fail_assertion("index too large");
    _jump1333:;
    int64_t _821 = 0;
    _821 *= _817.d0;
    _821 += _820;
    bool _822 = _817.data[_821];
    bool _823 = _772 != _822;
    _a1__a2_double _824;
    if (!_823)
    goto _jump1334;
    _a2__a2_double _825;
    // Computing bound for m
    bool _826 = true;
    int64_t _827;
    if (!_826)
    goto _jump1335;
    _827 = _0.d1;
    goto _jump1336;
    _jump1335:;
    _827 = _0.d1;
    _jump1336:;
    int64_t _828 = -_827;
    _825.d0 = _828;
    if (_828 > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    // Computing bound for n
    _825.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing total size of heap memory to allocate
    int64_t _829 = 1;
    _829 *= _828;
    _829 *= _0.d1;
    _829 *= sizeof(_a2_double);
    _825.data = jpl_alloc(_829);
    int64_t _830 = 0; // n
    int64_t _831 = 0; // m
    _jump1339:; // Begin body of loop
    int64_t _832 = 0;
    _832 *= _825.d0;
    _832 += _831;
    _832 *= _825.d1;
    _832 += _830;
    _825.data[_832] = _0;
    _830++;
    if (_830 < _0.d1)
    goto _jump1339;
    _830 = 0;
    _831++;
    if (_831 < _828)
    goto _jump1339;
    // End body of loop
    int64_t _833 = 64;
    bool _834 = _833 != _0.d1;
    int64_t _835;
    if (!_834)
    goto _jump1340;
    int64_t _836 = 924;
    _835 = _836;
    goto _jump1341;
    _jump1340:;
    int64_t _837 = 477;
    int64_t _838 = -_837;
    _835 = _838;
    _jump1341:;
    int64_t _839 = _0.d1 - _835;
    if (_839 >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (_839 < _825.d0)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    if (_693.d0 >= 0)
    goto _jump1344;
    fail_assertion("negative array index");
    _jump1344:;
    if (_693.d0 < _825.d1)
    goto _jump1345;
    fail_assertion("index too large");
    _jump1345:;
    int64_t _840 = 0;
    _840 *= _825.d0;
    _840 += _839;
    _840 *= _825.d1;
    _840 += _693.d0;
    _a2_double _841 = _825.data[_840];
    bool _843 = _0.d0 >= _0.d1;
    bool _844 = !_843;
    bool _842 = _844;
    if (0 == _844)
    goto _jump1346;
    int64_t _845;
    // Computing bound for m
    if (_0.d1 > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing bound for n
    if (_617 > 0) 
    goto _jump1348;
    fail_assertion("non-positive loop bound");
    _jump1348:;
    // Computing bound for o
    if (_693.d0 > 0) 
    goto _jump1349;
    fail_assertion("non-positive loop bound");
    _jump1349:;
    _845 = 0;
    int64_t _846 = 0; // o
    int64_t _847 = 0; // n
    int64_t _848 = 0; // m
    _jump1350:; // Begin body of loop
    _845 += _0.d0;
    _846++;
    if (_846 < _693.d0)
    goto _jump1350;
    _846 = 0;
    _847++;
    if (_847 < _617)
    goto _jump1350;
    _847 = 0;
    _848++;
    if (_848 < _0.d1)
    goto _jump1350;
    // End body of loop
    int64_t _849 = 161;
    int64_t _850 = 698;
    int64_t _851 = _849 / _850;
    bool _852 = _845 > _851;
    _842 = _852;
    _jump1346:;
    _a2_double _853;
    if (!_842)
    goto _jump1351;
    _a2_double _854;
    // Computing bound for m
    int64_t _855 = 963;
    _854.d0 = _855;
    if (_855 > 0) 
    goto _jump1352;
    fail_assertion("non-positive loop bound");
    _jump1352:;
    // Computing bound for n
    _854.d1 = _693.d0;
    if (_693.d0 > 0) 
    goto _jump1353;
    fail_assertion("non-positive loop bound");
    _jump1353:;
    // Computing total size of heap memory to allocate
    int64_t _856 = 1;
    _856 *= _855;
    _856 *= _693.d0;
    _856 *= sizeof(double);
    _854.data = jpl_alloc(_856);
    int64_t _857 = 0; // n
    int64_t _858 = 0; // m
    _jump1354:; // Begin body of loop
    bool _859 = true;
    double _860;
    if (!_859)
    goto _jump1355;
    double _861 = -_673;
    _860 = _861;
    goto _jump1356;
    _jump1355:;
    double _862;
    // Computing bound for o
    int64_t _863 = 162;
    if (_863 > 0) 
    goto _jump1357;
    fail_assertion("non-positive loop bound");
    _jump1357:;
    // Computing bound for p
    if (_617 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    _862 = 0;
    int64_t _864 = 0; // p
    int64_t _865 = 0; // o
    _jump1359:; // Begin body of loop
    double _866 = 56.0;
    _862 += _866;
    _864++;
    if (_864 < _617)
    goto _jump1359;
    _864 = 0;
    _865++;
    if (_865 < _863)
    goto _jump1359;
    // End body of loop
    _860 = _862;
    _jump1356:;
    int64_t _867 = 0;
    _867 *= _854.d0;
    _867 += _858;
    _867 *= _854.d1;
    _867 += _857;
    _854.data[_867] = _860;
    _857++;
    if (_857 < _693.d0)
    goto _jump1354;
    _857 = 0;
    _858++;
    if (_858 < _855)
    goto _jump1354;
    // End body of loop
    _853 = _854;
    goto _jump1360;
    _jump1351:;
    _a2__a2_double _868;
    // Computing bound for m
    int64_t _869 = 41;
    int64_t _870 = _869 * _0.d0;
    _868.d0 = _870;
    if (_870 > 0) 
    goto _jump1361;
    fail_assertion("non-positive loop bound");
    _jump1361:;
    // Computing bound for n
    _868.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1362;
    fail_assertion("non-positive loop bound");
    _jump1362:;
    // Computing total size of heap memory to allocate
    int64_t _871 = 1;
    _871 *= _870;
    _871 *= _0.d1;
    _871 *= sizeof(_a2_double);
    _868.data = jpl_alloc(_871);
    int64_t _872 = 0; // n
    int64_t _873 = 0; // m
    _jump1363:; // Begin body of loop
    int64_t _874 = 0;
    _874 *= _868.d0;
    _874 += _873;
    _874 *= _868.d1;
    _874 += _872;
    _868.data[_874] = _0;
    _872++;
    if (_872 < _0.d1)
    goto _jump1363;
    _872 = 0;
    _873++;
    if (_873 < _870)
    goto _jump1363;
    // End body of loop
    int64_t _875 = -_617;
    int64_t _876 = -_875;
    int64_t _877 = -_0.d0;
    if (_876 >= 0)
    goto _jump1364;
    fail_assertion("negative array index");
    _jump1364:;
    if (_876 < _868.d0)
    goto _jump1365;
    fail_assertion("index too large");
    _jump1365:;
    if (_877 >= 0)
    goto _jump1366;
    fail_assertion("negative array index");
    _jump1366:;
    if (_877 < _868.d1)
    goto _jump1367;
    fail_assertion("index too large");
    _jump1367:;
    int64_t _878 = 0;
    _878 *= _868.d0;
    _878 += _876;
    _878 *= _868.d1;
    _878 += _877;
    _a2_double _879 = _868.data[_878];
    _853 = _879;
    _jump1360:;
    _a1__a2_double _880;
    _880.d0 = 2;
    _880.data = jpl_alloc(sizeof(_a2_double) * 2);
    _880.data[0] = _841;
    _880.data[1] = _853;
    _824 = _880;
    goto _jump1368;
    _jump1334:;
    _a1__a2_double _881;
    // Computing bound for m
    int64_t _882 = _0.d0 % _0.d0;
    bool _883 = true;
    bool _884 = !_883;
    int64_t _885;
    if (!_884)
    goto _jump1369;
    int64_t _886 = 175;
    _885 = _886;
    goto _jump1370;
    _jump1369:;
    _885 = _693.d0;
    _jump1370:;
    int64_t _887 = _882 / _885;
    _881.d0 = _887;
    if (_887 > 0) 
    goto _jump1371;
    fail_assertion("non-positive loop bound");
    _jump1371:;
    // Computing total size of heap memory to allocate
    int64_t _888 = 1;
    _888 *= _887;
    _888 *= sizeof(_a2_double);
    _881.data = jpl_alloc(_888);
    int64_t _889 = 0; // m
    _jump1372:; // Begin body of loop
    int64_t _891;
    // Computing bound for n
    if (_889 > 0) 
    goto _jump1373;
    fail_assertion("non-positive loop bound");
    _jump1373:;
    // Computing bound for o
    if (_889 > 0) 
    goto _jump1374;
    fail_assertion("non-positive loop bound");
    _jump1374:;
    // Computing bound for p
    if (_0.d1 > 0) 
    goto _jump1375;
    fail_assertion("non-positive loop bound");
    _jump1375:;
    _891 = 0;
    int64_t _892 = 0; // p
    int64_t _893 = 0; // o
    int64_t _894 = 0; // n
    _jump1376:; // Begin body of loop
    _891 += _893;
    _892++;
    if (_892 < _0.d1)
    goto _jump1376;
    _892 = 0;
    _893++;
    if (_893 < _889)
    goto _jump1376;
    _893 = 0;
    _894++;
    if (_894 < _889)
    goto _jump1376;
    // End body of loop
    bool _895 = _891 == _0.d1;
    bool _890 = _895;
    if (0 == _895)
    goto _jump1377;
    bool _896 = true;
    _890 = _896;
    _jump1377:;
    _a2_double _897;
    if (!_890)
    goto _jump1378;
    _a3__a2_double _898;
    // Computing bound for n
    _898.d0 = _617;
    if (_617 > 0) 
    goto _jump1379;
    fail_assertion("non-positive loop bound");
    _jump1379:;
    // Computing bound for o
    _898.d1 = _693.d0;
    if (_693.d0 > 0) 
    goto _jump1380;
    fail_assertion("non-positive loop bound");
    _jump1380:;
    // Computing bound for p
    if (_693.d0 >= 0)
    goto _jump1381;
    fail_assertion("negative array index");
    _jump1381:;
    if (_693.d0 < _693.d0)
    goto _jump1382;
    fail_assertion("index too large");
    _jump1382:;
    int64_t _899 = 0;
    _899 *= _693.d0;
    _899 += _693.d0;
    int64_t _900 = _693.data[_899];
    _898.d2 = _900;
    if (_900 > 0) 
    goto _jump1383;
    fail_assertion("non-positive loop bound");
    _jump1383:;
    // Computing total size of heap memory to allocate
    int64_t _901 = 1;
    _901 *= _617;
    _901 *= _693.d0;
    _901 *= _900;
    _901 *= sizeof(_a2_double);
    _898.data = jpl_alloc(_901);
    int64_t _902 = 0; // p
    int64_t _903 = 0; // o
    int64_t _904 = 0; // n
    _jump1384:; // Begin body of loop
    int64_t _905 = 0;
    _905 *= _898.d0;
    _905 += _904;
    _905 *= _898.d1;
    _905 += _903;
    _905 *= _898.d2;
    _905 += _902;
    _898.data[_905] = _0;
    _902++;
    if (_902 < _900)
    goto _jump1384;
    _902 = 0;
    _903++;
    if (_903 < _693.d0)
    goto _jump1384;
    _903 = 0;
    _904++;
    if (_904 < _617)
    goto _jump1384;
    // End body of loop
    int64_t _906;
    // Computing bound for n
    int64_t _907 = 996;
    if (_907 > 0) 
    goto _jump1385;
    fail_assertion("non-positive loop bound");
    _jump1385:;
    _906 = 0;
    int64_t _908 = 0; // n
    _jump1386:; // Begin body of loop
    int64_t _909;
    // Computing bound for o
    if (_0.d1 > 0) 
    goto _jump1387;
    fail_assertion("non-positive loop bound");
    _jump1387:;
    _909 = 0;
    int64_t _910 = 0; // o
    _jump1388:; // Begin body of loop
    _909 += _0.d0;
    _910++;
    if (_910 < _0.d1)
    goto _jump1388;
    // End body of loop
    _906 += _909;
    _908++;
    if (_908 < _907)
    goto _jump1386;
    // End body of loop
    int64_t _911 = 284;
    if (_906 >= 0)
    goto _jump1389;
    fail_assertion("negative array index");
    _jump1389:;
    if (_906 < _898.d0)
    goto _jump1390;
    fail_assertion("index too large");
    _jump1390:;
    if (_911 >= 0)
    goto _jump1391;
    fail_assertion("negative array index");
    _jump1391:;
    if (_911 < _898.d1)
    goto _jump1392;
    fail_assertion("index too large");
    _jump1392:;
    if (_0.d1 >= 0)
    goto _jump1393;
    fail_assertion("negative array index");
    _jump1393:;
    if (_0.d1 < _898.d2)
    goto _jump1394;
    fail_assertion("index too large");
    _jump1394:;
    int64_t _912 = 0;
    _912 *= _898.d0;
    _912 += _906;
    _912 *= _898.d1;
    _912 += _911;
    _912 *= _898.d2;
    _912 += _0.d1;
    _a2_double _913 = _898.data[_912];
    _897 = _913;
    goto _jump1395;
    _jump1378:;
    _a2_double _914;
    // Computing bound for n
    _914.d0 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1396;
    fail_assertion("non-positive loop bound");
    _jump1396:;
    // Computing bound for o
    if (_889 >= 0)
    goto _jump1397;
    fail_assertion("negative array index");
    _jump1397:;
    if (_889 < _693.d0)
    goto _jump1398;
    fail_assertion("index too large");
    _jump1398:;
    int64_t _915 = 0;
    _915 *= _693.d0;
    _915 += _889;
    int64_t _916 = _693.data[_915];
    int64_t _917 = _916 + _693.d0;
    _914.d1 = _917;
    if (_917 > 0) 
    goto _jump1399;
    fail_assertion("non-positive loop bound");
    _jump1399:;
    // Computing total size of heap memory to allocate
    int64_t _918 = 1;
    _918 *= _0.d1;
    _918 *= _917;
    _918 *= sizeof(double);
    _914.data = jpl_alloc(_918);
    int64_t _919 = 0; // o
    int64_t _920 = 0; // n
    _jump1400:; // Begin body of loop
    int64_t _921 = 0;
    _921 *= _914.d0;
    _921 += _920;
    _921 *= _914.d1;
    _921 += _919;
    _914.data[_921] = _673;
    _919++;
    if (_919 < _917)
    goto _jump1400;
    _919 = 0;
    _920++;
    if (_920 < _0.d1)
    goto _jump1400;
    // End body of loop
    _897 = _914;
    _jump1395:;
    int64_t _922 = 0;
    _922 *= _881.d0;
    _922 += _889;
    _881.data[_922] = _897;
    _889++;
    if (_889 < _887)
    goto _jump1372;
    // End body of loop
    _824 = _881;
    _jump1368:;
    if (_0.d0 >= 0)
    goto _jump1401;
    fail_assertion("negative array index");
    _jump1401:;
    if (_0.d0 < _824.d0)
    goto _jump1402;
    fail_assertion("index too large");
    _jump1402:;
    int64_t _923 = 0;
    _923 *= _824.d0;
    _923 += _0.d0;
    _a2_double _924 = _824.data[_923];
    double _925 = get_time();
    int64_t _926;
    // Computing bound for p
    int64_t _927;
    // Computing bound for p
    if (_0.d0 > 0) 
    goto _jump1403;
    fail_assertion("non-positive loop bound");
    _jump1403:;
    // Computing bound for q
    if (_0.d1 > 0) 
    goto _jump1404;
    fail_assertion("non-positive loop bound");
    _jump1404:;
    _927 = 0;
    int64_t _928 = 0; // q
    int64_t _929 = 0; // p
    _jump1405:; // Begin body of loop
    _927 += _924.d0;
    _928++;
    if (_928 < _0.d1)
    goto _jump1405;
    _928 = 0;
    _929++;
    if (_929 < _0.d0)
    goto _jump1405;
    // End body of loop
    bool _930 = _924.d1 != _927;
    int64_t _931;
    if (!_930)
    goto _jump1406;
    bool _932 = true;
    bool _933 = !_932;
    bool _934;
    if (!_933)
    goto _jump1407;
    bool _935 = _673 <= _673;
    bool _936 = !_935;
    _934 = _936;
    goto _jump1408;
    _jump1407:;
    bool _937 = false;
    _934 = _937;
    _jump1408:;
    int64_t _938;
    if (!_934)
    goto _jump1409;
    bool _939 = true;
    int64_t _940;
    if (!_939)
    goto _jump1410;
    _940 = _0.d0;
    goto _jump1411;
    _jump1410:;
    _940 = _924.d0;
    _jump1411:;
    _938 = _940;
    goto _jump1412;
    _jump1409:;
    _938 = _924.d1;
    _jump1412:;
    _931 = _938;
    goto _jump1413;
    _jump1406:;
    _931 = _0.d0;
    _jump1413:;
    if (_931 > 0) 
    goto _jump1414;
    fail_assertion("non-positive loop bound");
    _jump1414:;
    // Computing bound for q
    if (_924.d1 > 0) 
    goto _jump1415;
    fail_assertion("non-positive loop bound");
    _jump1415:;
    _926 = 0;
    int64_t _941 = 0; // q
    int64_t _942 = 0; // p
    _jump1416:; // Begin body of loop
    _926 += _941;
    _941++;
    if (_941 < _924.d1)
    goto _jump1416;
    _941 = 0;
    _942++;
    if (_942 < _931)
    goto _jump1416;
    // End body of loop
    show("(IntType)", &_926);
    double _943 = get_time();
    print_time(_943 - _925);
    bool _944 = true;
    _a1_void_t _945;
    if (!_944)
    goto _jump1598;
    void_t _946 = f();
    _a1_void_t _947;
    _947.d0 = 1;
    _947.data = jpl_alloc(sizeof(void_t) * 1);
    _947.data[0] = _946;
    _945 = _947;
    goto _jump1599;
    _jump1598:;
    _a1_void_t _948;
    // Computing bound for q
    bool _949 = true;
    int64_t _950;
    if (!_949)
    goto _jump1600;
    _950 = _693.d0;
    goto _jump1601;
    _jump1600:;
    _950 = _693.d0;
    _jump1601:;
    _948.d0 = _950;
    if (_950 > 0) 
    goto _jump1602;
    fail_assertion("non-positive loop bound");
    _jump1602:;
    // Computing total size of heap memory to allocate
    int64_t _951 = 1;
    _951 *= _950;
    _951 *= sizeof(void_t);
    _948.data = jpl_alloc(_951);
    int64_t _952 = 0; // q
    _jump1603:; // Begin body of loop
    void_t _953 = f();
    int64_t _954 = 0;
    _954 *= _948.d0;
    _954 += _952;
    _948.data[_954] = _953;
    _952++;
    if (_952 < _950)
    goto _jump1603;
    // End body of loop
    _945 = _948;
    _jump1599:;
    _a3_void_t _955;
    // Computing bound for s
    int64_t _956;
    // Computing bound for s
    if (_945.d0 > 0) 
    goto _jump1604;
    fail_assertion("non-positive loop bound");
    _jump1604:;
    // Computing bound for t
    if (_0.d0 > 0) 
    goto _jump1605;
    fail_assertion("non-positive loop bound");
    _jump1605:;
    // Computing bound for u
    if (_0.d0 > 0) 
    goto _jump1606;
    fail_assertion("non-positive loop bound");
    _jump1606:;
    _956 = 0;
    int64_t _957 = 0; // u
    int64_t _958 = 0; // t
    int64_t _959 = 0; // s
    _jump1607:; // Begin body of loop
    bool _960 = true;
    _a3_int64_t _961;
    if (!_960)
    goto _jump1608;
    _a3_int64_t _962;
    // Computing bound for v
    _962.d0 = _959;
    if (_959 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    // Computing bound for w
    _962.d1 = _924.d0;
    if (_924.d0 > 0) 
    goto _jump1610;
    fail_assertion("non-positive loop bound");
    _jump1610:;
    // Computing bound for x
    _962.d2 = _924.d0;
    if (_924.d0 > 0) 
    goto _jump1611;
    fail_assertion("non-positive loop bound");
    _jump1611:;
    // Computing total size of heap memory to allocate
    int64_t _963 = 1;
    _963 *= _959;
    _963 *= _924.d0;
    _963 *= _924.d0;
    _963 *= sizeof(int64_t);
    _962.data = jpl_alloc(_963);
    int64_t _964 = 0; // x
    int64_t _965 = 0; // w
    int64_t _966 = 0; // v
    _jump1612:; // Begin body of loop
    int64_t _967 = 0;
    _967 *= _962.d0;
    _967 += _966;
    _967 *= _962.d1;
    _967 += _965;
    _967 *= _962.d2;
    _967 += _964;
    _962.data[_967] = _693.d0;
    _964++;
    if (_964 < _924.d0)
    goto _jump1612;
    _964 = 0;
    _965++;
    if (_965 < _924.d0)
    goto _jump1612;
    _965 = 0;
    _966++;
    if (_966 < _959)
    goto _jump1612;
    // End body of loop
    _961 = _962;
    goto _jump1613;
    _jump1608:;
    _a3_int64_t _968;
    // Computing bound for v
    _968.d0 = _958;
    if (_958 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for w
    _968.d1 = _617;
    if (_617 > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    // Computing bound for x
    _968.d2 = _617;
    if (_617 > 0) 
    goto _jump1616;
    fail_assertion("non-positive loop bound");
    _jump1616:;
    // Computing total size of heap memory to allocate
    int64_t _969 = 1;
    _969 *= _958;
    _969 *= _617;
    _969 *= _617;
    _969 *= sizeof(int64_t);
    _968.data = jpl_alloc(_969);
    int64_t _970 = 0; // x
    int64_t _971 = 0; // w
    int64_t _972 = 0; // v
    _jump1617:; // Begin body of loop
    int64_t _973 = 0;
    _973 *= _968.d0;
    _973 += _972;
    _973 *= _968.d1;
    _973 += _971;
    _973 *= _968.d2;
    _973 += _970;
    _968.data[_973] = _959;
    _970++;
    if (_970 < _617)
    goto _jump1617;
    _970 = 0;
    _971++;
    if (_971 < _617)
    goto _jump1617;
    _971 = 0;
    _972++;
    if (_972 < _958)
    goto _jump1617;
    // End body of loop
    _961 = _968;
    _jump1613:;
    if (_958 >= 0)
    goto _jump1618;
    fail_assertion("negative array index");
    _jump1618:;
    if (_958 < _961.d0)
    goto _jump1619;
    fail_assertion("index too large");
    _jump1619:;
    if (_945.d0 >= 0)
    goto _jump1620;
    fail_assertion("negative array index");
    _jump1620:;
    if (_945.d0 < _961.d1)
    goto _jump1621;
    fail_assertion("index too large");
    _jump1621:;
    if (_617 >= 0)
    goto _jump1622;
    fail_assertion("negative array index");
    _jump1622:;
    if (_617 < _961.d2)
    goto _jump1623;
    fail_assertion("index too large");
    _jump1623:;
    int64_t _974 = 0;
    _974 *= _961.d0;
    _974 += _958;
    _974 *= _961.d1;
    _974 += _945.d0;
    _974 *= _961.d2;
    _974 += _617;
    int64_t _975 = _961.data[_974];
    _956 += _975;
    _957++;
    if (_957 < _0.d0)
    goto _jump1607;
    _957 = 0;
    _958++;
    if (_958 < _0.d0)
    goto _jump1607;
    _958 = 0;
    _959++;
    if (_959 < _945.d0)
    goto _jump1607;
    // End body of loop
    int64_t _976 = -_956;
    _955.d0 = _976;
    if (_976 > 0) 
    goto _jump1624;
    fail_assertion("non-positive loop bound");
    _jump1624:;
    // Computing bound for t
    int64_t _977;
    // Computing bound for s
    int64_t _978 = -_0.d1;
    if (_978 > 0) 
    goto _jump1625;
    fail_assertion("non-positive loop bound");
    _jump1625:;
    _977 = 0;
    int64_t _979 = 0; // s
    _jump1626:; // Begin body of loop
    _a1_int64_t _980;
    // Computing bound for t
    int64_t _981;
    // Computing bound for t
    int64_t _982 = 68;
    if (_982 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    // Computing bound for u
    if (_693.d0 > 0) 
    goto _jump1628;
    fail_assertion("non-positive loop bound");
    _jump1628:;
    // Computing bound for v
    if (_617 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    _981 = 0;
    int64_t _983 = 0; // v
    int64_t _984 = 0; // u
    int64_t _985 = 0; // t
    _jump1630:; // Begin body of loop
    _981 += _693.d0;
    _983++;
    if (_983 < _617)
    goto _jump1630;
    _983 = 0;
    _984++;
    if (_984 < _693.d0)
    goto _jump1630;
    _984 = 0;
    _985++;
    if (_985 < _982)
    goto _jump1630;
    // End body of loop
    _980.d0 = _981;
    if (_981 > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing total size of heap memory to allocate
    int64_t _986 = 1;
    _986 *= _981;
    _986 *= sizeof(int64_t);
    _980.data = jpl_alloc(_986);
    int64_t _987 = 0; // t
    _jump1632:; // Begin body of loop
    int64_t _988 = 0;
    _988 *= _980.d0;
    _988 += _987;
    _980.data[_988] = _945.d0;
    _987++;
    if (_987 < _981)
    goto _jump1632;
    // End body of loop
    bool _989 = _979 != _0.d1;
    _a3_int64_t _990;
    if (!_989)
    goto _jump1633;
    _a3_int64_t _991;
    // Computing bound for t
    _991.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1634;
    fail_assertion("non-positive loop bound");
    _jump1634:;
    // Computing bound for u
    int64_t _992 = 24;
    _991.d1 = _992;
    if (_992 > 0) 
    goto _jump1635;
    fail_assertion("non-positive loop bound");
    _jump1635:;
    // Computing bound for v
    _991.d2 = _945.d0;
    if (_945.d0 > 0) 
    goto _jump1636;
    fail_assertion("non-positive loop bound");
    _jump1636:;
    // Computing total size of heap memory to allocate
    int64_t _993 = 1;
    _993 *= _0.d0;
    _993 *= _992;
    _993 *= _945.d0;
    _993 *= sizeof(int64_t);
    _991.data = jpl_alloc(_993);
    int64_t _994 = 0; // v
    int64_t _995 = 0; // u
    int64_t _996 = 0; // t
    _jump1637:; // Begin body of loop
    int64_t _997 = 0;
    _997 *= _991.d0;
    _997 += _996;
    _997 *= _991.d1;
    _997 += _995;
    _997 *= _991.d2;
    _997 += _994;
    _991.data[_997] = _996;
    _994++;
    if (_994 < _945.d0)
    goto _jump1637;
    _994 = 0;
    _995++;
    if (_995 < _992)
    goto _jump1637;
    _995 = 0;
    _996++;
    if (_996 < _0.d0)
    goto _jump1637;
    // End body of loop
    _990 = _991;
    goto _jump1638;
    _jump1633:;
    _a3_int64_t _998;
    // Computing bound for t
    _998.d0 = _617;
    if (_617 > 0) 
    goto _jump1639;
    fail_assertion("non-positive loop bound");
    _jump1639:;
    // Computing bound for u
    _998.d1 = _0.d1;
    if (_0.d1 > 0) 
    goto _jump1640;
    fail_assertion("non-positive loop bound");
    _jump1640:;
    // Computing bound for v
    _998.d2 = _945.d0;
    if (_945.d0 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    // Computing total size of heap memory to allocate
    int64_t _999 = 1;
    _999 *= _617;
    _999 *= _0.d1;
    _999 *= _945.d0;
    _999 *= sizeof(int64_t);
    _998.data = jpl_alloc(_999);
    int64_t _1000 = 0; // v
    int64_t _1001 = 0; // u
    int64_t _1002 = 0; // t
    _jump1642:; // Begin body of loop
    int64_t _1003 = 0;
    _1003 *= _998.d0;
    _1003 += _1002;
    _1003 *= _998.d1;
    _1003 += _1001;
    _1003 *= _998.d2;
    _1003 += _1000;
    _998.data[_1003] = _945.d0;
    _1000++;
    if (_1000 < _945.d0)
    goto _jump1642;
    _1000 = 0;
    _1001++;
    if (_1001 < _0.d1)
    goto _jump1642;
    _1001 = 0;
    _1002++;
    if (_1002 < _617)
    goto _jump1642;
    // End body of loop
    _990 = _998;
    _jump1638:;
    _a1_int64_t _1004;
    // Computing bound for t
    _1004.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1643;
    fail_assertion("non-positive loop bound");
    _jump1643:;
    // Computing total size of heap memory to allocate
    int64_t _1005 = 1;
    _1005 *= _0.d0;
    _1005 *= sizeof(int64_t);
    _1004.data = jpl_alloc(_1005);
    int64_t _1006 = 0; // t
    _jump1644:; // Begin body of loop
    int64_t _1007 = 0;
    _1007 *= _1004.d0;
    _1007 += _1006;
    _1004.data[_1007] = _979;
    _1006++;
    if (_1006 < _0.d0)
    goto _jump1644;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump1645;
    fail_assertion("negative array index");
    _jump1645:;
    if (_0.d1 < _1004.d0)
    goto _jump1646;
    fail_assertion("index too large");
    _jump1646:;
    int64_t _1008 = 0;
    _1008 *= _1004.d0;
    _1008 += _0.d1;
    int64_t _1009 = _1004.data[_1008];
    if (_1009 >= 0)
    goto _jump1647;
    fail_assertion("negative array index");
    _jump1647:;
    if (_1009 < _990.d0)
    goto _jump1648;
    fail_assertion("index too large");
    _jump1648:;
    if (_979 >= 0)
    goto _jump1649;
    fail_assertion("negative array index");
    _jump1649:;
    if (_979 < _990.d1)
    goto _jump1650;
    fail_assertion("index too large");
    _jump1650:;
    if (_924.d0 >= 0)
    goto _jump1651;
    fail_assertion("negative array index");
    _jump1651:;
    if (_924.d0 < _990.d2)
    goto _jump1652;
    fail_assertion("index too large");
    _jump1652:;
    int64_t _1010 = 0;
    _1010 *= _990.d0;
    _1010 += _1009;
    _1010 *= _990.d1;
    _1010 += _979;
    _1010 *= _990.d2;
    _1010 += _924.d0;
    int64_t _1011 = _990.data[_1010];
    if (_1011 >= 0)
    goto _jump1653;
    fail_assertion("negative array index");
    _jump1653:;
    if (_1011 < _980.d0)
    goto _jump1654;
    fail_assertion("index too large");
    _jump1654:;
    int64_t _1012 = 0;
    _1012 *= _980.d0;
    _1012 += _1011;
    int64_t _1013 = _980.data[_1012];
    _977 += _1013;
    _979++;
    if (_979 < _978)
    goto _jump1626;
    // End body of loop
    _955.d1 = _977;
    if (_977 > 0) 
    goto _jump1655;
    fail_assertion("non-positive loop bound");
    _jump1655:;
    // Computing bound for u
    int64_t _1014 = -_945.d0;
    _955.d2 = _1014;
    if (_1014 > 0) 
    goto _jump1656;
    fail_assertion("non-positive loop bound");
    _jump1656:;
    // Computing total size of heap memory to allocate
    int64_t _1015 = 1;
    _1015 *= _976;
    _1015 *= _977;
    _1015 *= _1014;
    _1015 *= sizeof(void_t);
    _955.data = jpl_alloc(_1015);
    int64_t _1016 = 0; // u
    int64_t _1017 = 0; // t
    int64_t _1018 = 0; // s
    _jump1657:; // Begin body of loop
    if (_945.d0 >= 0)
    goto _jump1658;
    fail_assertion("negative array index");
    _jump1658:;
    if (_945.d0 < _945.d0)
    goto _jump1659;
    fail_assertion("index too large");
    _jump1659:;
    int64_t _1019 = 0;
    _1019 *= _945.d0;
    _1019 += _945.d0;
    void_t _1020 = _945.data[_1019];
    int64_t _1021 = 0;
    _1021 *= _955.d0;
    _1021 += _1018;
    _1021 *= _955.d1;
    _1021 += _1017;
    _1021 *= _955.d2;
    _1021 += _1016;
    _955.data[_1021] = _1020;
    _1016++;
    if (_1016 < _1014)
    goto _jump1657;
    _1016 = 0;
    _1017++;
    if (_1017 < _977)
    goto _jump1657;
    _1017 = 0;
    _1018++;
    if (_1018 < _976)
    goto _jump1657;
    // End body of loop
    double _1022 = 54.0;
    bool _1023 = p(_955, _1022);
    if (0 != _1023)
    goto _jump1660;
    fail_assertion("s");
    _jump1660:;
    double _1024 = 13.0;
    _a1_double _1025;
    _1025.d0 = 1;
    _1025.data = jpl_alloc(sizeof(double) * 1);
    _1025.data[0] = _1024;
    show("(ArrayType (FloatType) 1)", &_1025);
    _a3__a2__a2__a1_void_t _1026;
    // Computing bound for A
    _1026.d0 = _945.d0;
    if (_945.d0 > 0) 
    goto _jump1996;
    fail_assertion("non-positive loop bound");
    _jump1996:;
    // Computing bound for B
    _1026.d1 = _617;
    if (_617 > 0) 
    goto _jump1997;
    fail_assertion("non-positive loop bound");
    _jump1997:;
    // Computing bound for C
    _1026.d2 = _693.d0;
    if (_693.d0 > 0) 
    goto _jump1998;
    fail_assertion("non-positive loop bound");
    _jump1998:;
    // Computing total size of heap memory to allocate
    int64_t _1027 = 1;
    _1027 *= _945.d0;
    _1027 *= _617;
    _1027 *= _693.d0;
    _1027 *= sizeof(_a2__a2__a1_void_t);
    _1026.data = jpl_alloc(_1027);
    int64_t _1028 = 0; // C
    int64_t _1029 = 0; // B
    int64_t _1030 = 0; // A
    _jump1999:; // Begin body of loop
    _a2__a2__a1_void_t _1031;
    // Computing bound for D
    _1031.d0 = _1030;
    if (_1030 > 0) 
    goto _jump2000;
    fail_assertion("non-positive loop bound");
    _jump2000:;
    // Computing bound for E
    _1031.d1 = _924.d0;
    if (_924.d0 > 0) 
    goto _jump2001;
    fail_assertion("non-positive loop bound");
    _jump2001:;
    // Computing total size of heap memory to allocate
    int64_t _1032 = 1;
    _1032 *= _1030;
    _1032 *= _924.d0;
    _1032 *= sizeof(_a2__a1_void_t);
    _1031.data = jpl_alloc(_1032);
    int64_t _1033 = 0; // E
    int64_t _1034 = 0; // D
    _jump2002:; // Begin body of loop
    _a2__a1_void_t _1035;
    // Computing bound for F
    _1035.d0 = _1034;
    if (_1034 > 0) 
    goto _jump2003;
    fail_assertion("non-positive loop bound");
    _jump2003:;
    // Computing bound for G
    _1035.d1 = _1033;
    if (_1033 > 0) 
    goto _jump2004;
    fail_assertion("non-positive loop bound");
    _jump2004:;
    // Computing total size of heap memory to allocate
    int64_t _1036 = 1;
    _1036 *= _1034;
    _1036 *= _1033;
    _1036 *= sizeof(_a1_void_t);
    _1035.data = jpl_alloc(_1036);
    int64_t _1037 = 0; // G
    int64_t _1038 = 0; // F
    _jump2005:; // Begin body of loop
    int64_t _1039 = 0;
    _1039 *= _1035.d0;
    _1039 += _1038;
    _1039 *= _1035.d1;
    _1039 += _1037;
    _1035.data[_1039] = _945;
    _1037++;
    if (_1037 < _1033)
    goto _jump2005;
    _1037 = 0;
    _1038++;
    if (_1038 < _1034)
    goto _jump2005;
    // End body of loop
    int64_t _1040 = 0;
    _1040 *= _1031.d0;
    _1040 += _1034;
    _1040 *= _1031.d1;
    _1040 += _1033;
    _1031.data[_1040] = _1035;
    _1033++;
    if (_1033 < _924.d0)
    goto _jump2002;
    _1033 = 0;
    _1034++;
    if (_1034 < _1030)
    goto _jump2002;
    // End body of loop
    int64_t _1041 = 0;
    _1041 *= _1026.d0;
    _1041 += _1030;
    _1041 *= _1026.d1;
    _1041 += _1029;
    _1041 *= _1026.d2;
    _1041 += _1028;
    _1026.data[_1041] = _1031;
    _1028++;
    if (_1028 < _693.d0)
    goto _jump1999;
    _1028 = 0;
    _1029++;
    if (_1029 < _617)
    goto _jump1999;
    _1029 = 0;
    _1030++;
    if (_1030 < _945.d0)
    goto _jump1999;
    // End body of loop
    if (_945.d0 >= 0)
    goto _jump2006;
    fail_assertion("negative array index");
    _jump2006:;
    if (_945.d0 < _1026.d0)
    goto _jump2007;
    fail_assertion("index too large");
    _jump2007:;
    if (_0.d1 >= 0)
    goto _jump2008;
    fail_assertion("negative array index");
    _jump2008:;
    if (_0.d1 < _1026.d1)
    goto _jump2009;
    fail_assertion("index too large");
    _jump2009:;
    if (_617 >= 0)
    goto _jump2010;
    fail_assertion("negative array index");
    _jump2010:;
    if (_617 < _1026.d2)
    goto _jump2011;
    fail_assertion("index too large");
    _jump2011:;
    int64_t _1042 = 0;
    _1042 *= _1026.d0;
    _1042 += _945.d0;
    _1042 *= _1026.d1;
    _1042 += _0.d1;
    _1042 *= _1026.d2;
    _1042 += _617;
    _a2__a2__a1_void_t _1043 = _1026.data[_1042];
    if (_924.d0 >= 0)
    goto _jump2012;
    fail_assertion("negative array index");
    _jump2012:;
    if (_924.d0 < _1043.d0)
    goto _jump2013;
    fail_assertion("index too large");
    _jump2013:;
    if (_924.d1 >= 0)
    goto _jump2014;
    fail_assertion("negative array index");
    _jump2014:;
    if (_924.d1 < _1043.d1)
    goto _jump2015;
    fail_assertion("index too large");
    _jump2015:;
    int64_t _1044 = 0;
    _1044 *= _1043.d0;
    _1044 += _924.d0;
    _1044 *= _1043.d1;
    _1044 += _924.d1;
    _a2__a1_void_t _1045 = _1043.data[_1044];
    int64_t _1046 = -_945.d0;
    if (_0.d0 >= 0)
    goto _jump2016;
    fail_assertion("negative array index");
    _jump2016:;
    if (_0.d0 < _1045.d0)
    goto _jump2017;
    fail_assertion("index too large");
    _jump2017:;
    if (_1046 >= 0)
    goto _jump2018;
    fail_assertion("negative array index");
    _jump2018:;
    if (_1046 < _1045.d1)
    goto _jump2019;
    fail_assertion("index too large");
    _jump2019:;
    int64_t _1047 = 0;
    _1047 *= _1045.d0;
    _1047 += _0.d0;
    _1047 *= _1045.d1;
    _1047 += _1046;
    _a1_void_t _1048 = _1045.data[_1047];
}

