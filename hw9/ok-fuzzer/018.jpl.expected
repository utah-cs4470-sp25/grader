
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
    int64_t a;
    void_t b;
} a;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  a *data;
} _a1_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_int64_t *data;
} _a3__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  a *data;
} _a2_a;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  a *data;
} _a3_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_bool *data;
} _a2__a1_bool;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  void_t *data;
} _a1_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_int64_t *data;
} _a2__a2__a1_int64_t;

typedef struct {
    rgba a;
} e;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_bool *data;
} _a3__a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_a *data;
} _a2__a3_a;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  e *data;
} _a2_e;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_e *data;
} _a3__a2_e;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_bool *data;
} _a3__a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a1_bool *data;
} _a2__a2__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a3_int64_t *data;
} _a3__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_bool *data;
} _a3__a1_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  _a1__a1_bool *data;
} _a1__a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a2_int64_t *data;
} _a3__a3__a2_int64_t;

typedef struct {
  int64_t d0;
  e *data;
} _a1_e;

a b(int64_t c, _a1_int64_t d, a f) {
    int64_t _0;
    // Computing bound for g
    _a2_int64_t _1;
    // Computing bound for g
    int64_t _2 = 671;
    _1.d0 = _2;
    if (_2 > 0) 
    goto _jump74;
    fail_assertion("non-positive loop bound");
    _jump74:;
    // Computing bound for h
    int64_t _3 = 226;
    _1.d1 = _3;
    if (_3 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing total size of heap memory to allocate
    int64_t _4 = 1;
    _4 *= _2;
    _4 *= _3;
    _4 *= sizeof(int64_t);
    _1.data = jpl_alloc(_4);
    int64_t _5 = 0; // h
    int64_t _6 = 0; // g
    _jump76:; // Begin body of loop
    int64_t _7 = 536;
    int64_t _8 = 0;
    _8 *= _1.d0;
    _8 += _6;
    _8 *= _1.d1;
    _8 += _5;
    _1.data[_8] = _7;
    _5++;
    if (_5 < _3)
    goto _jump76;
    _5 = 0;
    _6++;
    if (_6 < _2)
    goto _jump76;
    // End body of loop
    _a1__a2_int64_t _9;
    _9.d0 = 1;
    _9.data = jpl_alloc(sizeof(_a2_int64_t) * 1);
    _9.data[0] = _1;
    a _10 = b(d.d0, d, f);
    int64_t _11 = _10.a;
    if (_11 >= 0)
    goto _jump77;
    fail_assertion("negative array index");
    _jump77:;
    if (_11 < _9.d0)
    goto _jump78;
    fail_assertion("index too large");
    _jump78:;
    int64_t _12 = 0;
    _12 *= _9.d0;
    _12 += _11;
    _a2_int64_t _13 = _9.data[_12];
    int64_t _14 = f.a;
    if (d.d0 >= 0)
    goto _jump79;
    fail_assertion("negative array index");
    _jump79:;
    if (d.d0 < _13.d0)
    goto _jump80;
    fail_assertion("index too large");
    _jump80:;
    if (_14 >= 0)
    goto _jump81;
    fail_assertion("negative array index");
    _jump81:;
    if (_14 < _13.d1)
    goto _jump82;
    fail_assertion("index too large");
    _jump82:;
    int64_t _15 = 0;
    _15 *= _13.d0;
    _15 += d.d0;
    _15 *= _13.d1;
    _15 += _14;
    int64_t _16 = _13.data[_15];
    int64_t _17 = _16 - d.d0;
    if (_17 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    // Computing bound for h
    _a1_a _18;
    // Computing bound for g
    int64_t _19 = f.a;
    _18.d0 = _19;
    if (_19 > 0) 
    goto _jump84;
    fail_assertion("non-positive loop bound");
    _jump84:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _19;
    _20 *= sizeof(a);
    _18.data = jpl_alloc(_20);
    int64_t _21 = 0; // g
    _jump85:; // Begin body of loop
    int64_t _22 = 0;
    _22 *= _18.d0;
    _22 += _21;
    _18.data[_22] = f;
    _21++;
    if (_21 < _19)
    goto _jump85;
    // End body of loop
    int64_t _23 = 873;
    int64_t _24 = -_23;
    if (_24 >= 0)
    goto _jump86;
    fail_assertion("negative array index");
    _jump86:;
    if (_24 < _18.d0)
    goto _jump87;
    fail_assertion("index too large");
    _jump87:;
    int64_t _25 = 0;
    _25 *= _18.d0;
    _25 += _24;
    a _26 = _18.data[_25];
    int64_t _27 = _26.a;
    if (_27 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    _0 = 0;
    int64_t _28 = 0; // h
    int64_t _29 = 0; // g
    _jump89:; // Begin body of loop
    bool _30 = true;
    bool _31;
    if (!_30)
    goto _jump90;
    bool _32 = _29 >= c;
    bool _33 = !_32;
    _31 = _33;
    goto _jump91;
    _jump90:;
    bool _34 = c != c;
    bool _35 = _29 == c;
    bool _36 = _34 == _35;
    _31 = _36;
    _jump91:;
    bool _37;
    if (!_31)
    goto _jump92;
    bool _39 = true;
    bool _38 = _39;
    if (0 != _39)
    goto _jump93;
    bool _40 = false;
    _38 = _40;
    _jump93:;
    _37 = _38;
    goto _jump94;
    _jump92:;
    double _41 = 67.0;
    double _42 = -_41;
    double _43 = 38.0;
    bool _44 = _42 != _43;
    _37 = _44;
    _jump94:;
    int64_t _45;
    if (!_37)
    goto _jump95;
    _45 = _28;
    goto _jump96;
    _jump95:;
    _a3_int64_t _46;
    // Computing bound for i
    _46.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    // Computing bound for j
    _46.d1 = c;
    if (c > 0) 
    goto _jump98;
    fail_assertion("non-positive loop bound");
    _jump98:;
    // Computing bound for k
    int64_t _47 = 328;
    _46.d2 = _47;
    if (_47 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing total size of heap memory to allocate
    int64_t _48 = 1;
    _48 *= d.d0;
    _48 *= c;
    _48 *= _47;
    _48 *= sizeof(int64_t);
    _46.data = jpl_alloc(_48);
    int64_t _49 = 0; // k
    int64_t _50 = 0; // j
    int64_t _51 = 0; // i
    _jump100:; // Begin body of loop
    int64_t _52 = 0;
    _52 *= _46.d0;
    _52 += _51;
    _52 *= _46.d1;
    _52 += _50;
    _52 *= _46.d2;
    _52 += _49;
    _46.data[_52] = _50;
    _49++;
    if (_49 < _47)
    goto _jump100;
    _49 = 0;
    _50++;
    if (_50 < c)
    goto _jump100;
    _50 = 0;
    _51++;
    if (_51 < d.d0)
    goto _jump100;
    // End body of loop
    int64_t _53 = -_29;
    if (_28 >= 0)
    goto _jump101;
    fail_assertion("negative array index");
    _jump101:;
    if (_28 < _46.d0)
    goto _jump102;
    fail_assertion("index too large");
    _jump102:;
    if (_53 >= 0)
    goto _jump103;
    fail_assertion("negative array index");
    _jump103:;
    if (_53 < _46.d1)
    goto _jump104;
    fail_assertion("index too large");
    _jump104:;
    if (c >= 0)
    goto _jump105;
    fail_assertion("negative array index");
    _jump105:;
    if (c < _46.d2)
    goto _jump106;
    fail_assertion("index too large");
    _jump106:;
    int64_t _54 = 0;
    _54 *= _46.d0;
    _54 += _28;
    _54 *= _46.d1;
    _54 += _53;
    _54 *= _46.d2;
    _54 += c;
    int64_t _55 = _46.data[_54];
    bool _56 = false;
    int64_t _57;
    if (!_56)
    goto _jump107;
    _57 = _28;
    goto _jump108;
    _jump107:;
    _57 = _28;
    _jump108:;
    int64_t _58 = 416;
    int64_t _59 = _29 - _58;
    _a1_int64_t _60;
    _60.d0 = 3;
    _60.data = jpl_alloc(sizeof(int64_t) * 3);
    _60.data[0] = _57;
    _60.data[1] = _59;
    _60.data[2] = c;
    int64_t _61 = 973;
    a _62 = b(_29, d, f);
    a _63 = b(_61, d, _62);
    a _64 = b(_55, _60, _63);
    int64_t _65 = _64.a;
    _45 = _65;
    _jump96:;
    _0 += _45;
    _28++;
    if (_28 < _27)
    goto _jump89;
    _28 = 0;
    _29++;
    if (_29 < _17)
    goto _jump89;
    // End body of loop
    _a3__a3__a1_int64_t _66;
    // Computing bound for g
    _66.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump109;
    fail_assertion("non-positive loop bound");
    _jump109:;
    // Computing bound for h
    int64_t _67;
    // Computing bound for g
    int64_t _68 = f.a;
    if (_68 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    _67 = 0;
    int64_t _69 = 0; // g
    _jump111:; // Begin body of loop
    int64_t _70 = _69 * _69;
    if (_70 >= 0)
    goto _jump112;
    fail_assertion("negative array index");
    _jump112:;
    if (_70 < d.d0)
    goto _jump113;
    fail_assertion("index too large");
    _jump113:;
    int64_t _71 = 0;
    _71 *= d.d0;
    _71 += _70;
    int64_t _72 = d.data[_71];
    _67 += _72;
    _69++;
    if (_69 < _68)
    goto _jump111;
    // End body of loop
    _66.d1 = _67;
    if (_67 > 0) 
    goto _jump114;
    fail_assertion("non-positive loop bound");
    _jump114:;
    // Computing bound for i
    int64_t _73;
    // Computing bound for g
    if (c > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing bound for h
    if (c > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _73 = 0;
    int64_t _74 = 0; // h
    int64_t _75 = 0; // g
    _jump117:; // Begin body of loop
    _73 += c;
    _74++;
    if (_74 < c)
    goto _jump117;
    _74 = 0;
    _75++;
    if (_75 < c)
    goto _jump117;
    // End body of loop
    int64_t _76 = -d.d0;
    _a1_int64_t _77;
    _77.d0 = 2;
    _77.data = jpl_alloc(sizeof(int64_t) * 2);
    _77.data[0] = _73;
    _77.data[1] = _76;
    int64_t _78 = 64;
    if (_78 >= 0)
    goto _jump118;
    fail_assertion("negative array index");
    _jump118:;
    if (_78 < _77.d0)
    goto _jump119;
    fail_assertion("index too large");
    _jump119:;
    int64_t _79 = 0;
    _79 *= _77.d0;
    _79 += _78;
    int64_t _80 = _77.data[_79];
    _66.d2 = _80;
    if (_80 > 0) 
    goto _jump120;
    fail_assertion("non-positive loop bound");
    _jump120:;
    // Computing total size of heap memory to allocate
    int64_t _81 = 1;
    _81 *= d.d0;
    _81 *= _67;
    _81 *= _80;
    _81 *= sizeof(_a3__a1_int64_t);
    _66.data = jpl_alloc(_81);
    int64_t _82 = 0; // i
    int64_t _83 = 0; // h
    int64_t _84 = 0; // g
    _jump121:; // Begin body of loop
    _a3__a1_int64_t _85;
    // Computing bound for j
    int64_t _86 = -c;
    _85.d0 = _86;
    if (_86 > 0) 
    goto _jump122;
    fail_assertion("non-positive loop bound");
    _jump122:;
    // Computing bound for k
    bool _87 = false;
    int64_t _88;
    if (!_87)
    goto _jump123;
    _88 = _83;
    goto _jump124;
    _jump123:;
    _88 = c;
    _jump124:;
    _85.d1 = _88;
    if (_88 > 0) 
    goto _jump125;
    fail_assertion("non-positive loop bound");
    _jump125:;
    // Computing bound for l
    _85.d2 = c;
    if (c > 0) 
    goto _jump126;
    fail_assertion("non-positive loop bound");
    _jump126:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= _86;
    _89 *= _88;
    _89 *= c;
    _89 *= sizeof(_a1_int64_t);
    _85.data = jpl_alloc(_89);
    int64_t _90 = 0; // l
    int64_t _91 = 0; // k
    int64_t _92 = 0; // j
    _jump127:; // Begin body of loop
    int64_t _93 = _92 % _84;
    _a1_int64_t _94;
    _94.d0 = 3;
    _94.data = jpl_alloc(sizeof(int64_t) * 3);
    _94.data[0] = _82;
    _94.data[1] = c;
    _94.data[2] = _93;
    int64_t _95 = 0;
    _95 *= _85.d0;
    _95 += _92;
    _95 *= _85.d1;
    _95 += _91;
    _95 *= _85.d2;
    _95 += _90;
    _85.data[_95] = _94;
    _90++;
    if (_90 < c)
    goto _jump127;
    _90 = 0;
    _91++;
    if (_91 < _88)
    goto _jump127;
    _91 = 0;
    _92++;
    if (_92 < _86)
    goto _jump127;
    // End body of loop
    int64_t _96 = 0;
    _96 *= _66.d0;
    _96 += _84;
    _96 *= _66.d1;
    _96 += _83;
    _96 *= _66.d2;
    _96 += _82;
    _66.data[_96] = _85;
    _82++;
    if (_82 < _80)
    goto _jump121;
    _82 = 0;
    _83++;
    if (_83 < _67)
    goto _jump121;
    _83 = 0;
    _84++;
    if (_84 < d.d0)
    goto _jump121;
    // End body of loop
    void_t _97 = f.b;
    a _98 = { c, _97 };
    int64_t _99 = _98.a;
    bool _100 = d.d0 < c;
    void_t _101;
    if (!_100)
    goto _jump128;
    void_t _102 = f.b;
    _101 = _102;
    goto _jump129;
    _jump128:;
    void_t _103 = f.b;
    _101 = _103;
    _jump129:;
    a _104 = { d.d0, _101 };
    int64_t _105 = _104.a;
    void_t _106 = f.b;
    a _107 = { c, _106 };
    int64_t _108 = _107.a;
    int64_t _109 = f.a;
    int64_t _110 = _108 * _109;
    if (_99 >= 0)
    goto _jump130;
    fail_assertion("negative array index");
    _jump130:;
    if (_99 < _66.d0)
    goto _jump131;
    fail_assertion("index too large");
    _jump131:;
    if (_105 >= 0)
    goto _jump132;
    fail_assertion("negative array index");
    _jump132:;
    if (_105 < _66.d1)
    goto _jump133;
    fail_assertion("index too large");
    _jump133:;
    if (_110 >= 0)
    goto _jump134;
    fail_assertion("negative array index");
    _jump134:;
    if (_110 < _66.d2)
    goto _jump135;
    fail_assertion("index too large");
    _jump135:;
    int64_t _111 = 0;
    _111 *= _66.d0;
    _111 += _99;
    _111 *= _66.d1;
    _111 += _105;
    _111 *= _66.d2;
    _111 += _110;
    _a3__a1_int64_t _112 = _66.data[_111];
    int64_t _113;
    // Computing bound for g
    if (d.d0 > 0) 
    goto _jump136;
    fail_assertion("non-positive loop bound");
    _jump136:;
    // Computing bound for h
    if (c > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing bound for i
    int64_t _114 = 562;
    if (_114 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    _113 = 0;
    int64_t _115 = 0; // i
    int64_t _116 = 0; // h
    int64_t _117 = 0; // g
    _jump139:; // Begin body of loop
    _113 += _116;
    _115++;
    if (_115 < _114)
    goto _jump139;
    _115 = 0;
    _116++;
    if (_116 < c)
    goto _jump139;
    _116 = 0;
    _117++;
    if (_117 < d.d0)
    goto _jump139;
    // End body of loop
    _a1_int64_t _118;
    _118.d0 = 2;
    _118.data = jpl_alloc(sizeof(int64_t) * 2);
    _118.data[0] = d.d0;
    _118.data[1] = _113;
    int64_t _119 = 589;
    if (_119 >= 0)
    goto _jump140;
    fail_assertion("negative array index");
    _jump140:;
    if (_119 < _118.d0)
    goto _jump141;
    fail_assertion("index too large");
    _jump141:;
    int64_t _120 = 0;
    _120 *= _118.d0;
    _120 += _119;
    int64_t _121 = _118.data[_120];
    int64_t _122 = -_121;
    bool _124 = false;
    bool _123 = _124;
    if (0 != _124)
    goto _jump142;
    bool _125 = false;
    _123 = _125;
    _jump142:;
    a _126;
    if (!_123)
    goto _jump143;
    _a2_a _127;
    // Computing bound for g
    _127.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump144;
    fail_assertion("non-positive loop bound");
    _jump144:;
    // Computing bound for h
    int64_t _128 = 480;
    _127.d1 = _128;
    if (_128 > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= d.d0;
    _129 *= _128;
    _129 *= sizeof(a);
    _127.data = jpl_alloc(_129);
    int64_t _130 = 0; // h
    int64_t _131 = 0; // g
    _jump146:; // Begin body of loop
    int64_t _132 = 0;
    _132 *= _127.d0;
    _132 += _131;
    _132 *= _127.d1;
    _132 += _130;
    _127.data[_132] = f;
    _130++;
    if (_130 < _128)
    goto _jump146;
    _130 = 0;
    _131++;
    if (_131 < d.d0)
    goto _jump146;
    // End body of loop
    int64_t _133 = 475;
    int64_t _134 = f.a;
    if (_133 >= 0)
    goto _jump147;
    fail_assertion("negative array index");
    _jump147:;
    if (_133 < _127.d0)
    goto _jump148;
    fail_assertion("index too large");
    _jump148:;
    if (_134 >= 0)
    goto _jump149;
    fail_assertion("negative array index");
    _jump149:;
    if (_134 < _127.d1)
    goto _jump150;
    fail_assertion("index too large");
    _jump150:;
    int64_t _135 = 0;
    _135 *= _127.d0;
    _135 += _133;
    _135 *= _127.d1;
    _135 += _134;
    a _136 = _127.data[_135];
    _126 = _136;
    goto _jump151;
    _jump143:;
    bool _137 = true;
    bool _138;
    if (!_137)
    goto _jump152;
    bool _139 = true;
    _138 = _139;
    goto _jump153;
    _jump152:;
    bool _140 = false;
    _138 = _140;
    _jump153:;
    a _141;
    if (!_138)
    goto _jump154;
    _141 = f;
    goto _jump155;
    _jump154:;
    _141 = f;
    _jump155:;
    _126 = _141;
    _jump151:;
    int64_t _142 = _126.a;
    int64_t _143 = _142 * d.d0;
    int64_t _144;
    // Computing bound for g
    int64_t _145 = 383;
    if (_145 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing bound for h
    bool _146 = d.d0 < d.d0;
    bool _147 = false;
    bool _148 = _146 != _147;
    bool _149;
    if (!_148)
    goto _jump157;
    bool _150 = c == c;
    bool _151 = !_150;
    _149 = _151;
    goto _jump158;
    _jump157:;
    int64_t _152 = 386;
    bool _153 = c > _152;
    _149 = _153;
    _jump158:;
    int64_t _154;
    if (!_149)
    goto _jump159;
    int64_t _155 = 73;
    _154 = _155;
    goto _jump160;
    _jump159:;
    int64_t _156 = -c;
    _154 = _156;
    _jump160:;
    if (_154 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    _144 = 0;
    int64_t _157 = 0; // h
    int64_t _158 = 0; // g
    _jump162:; // Begin body of loop
    _144 += _157;
    _157++;
    if (_157 < _154)
    goto _jump162;
    _157 = 0;
    _158++;
    if (_158 < _145)
    goto _jump162;
    // End body of loop
    if (_122 >= 0)
    goto _jump163;
    fail_assertion("negative array index");
    _jump163:;
    if (_122 < _112.d0)
    goto _jump164;
    fail_assertion("index too large");
    _jump164:;
    if (_143 >= 0)
    goto _jump165;
    fail_assertion("negative array index");
    _jump165:;
    if (_143 < _112.d1)
    goto _jump166;
    fail_assertion("index too large");
    _jump166:;
    if (_144 >= 0)
    goto _jump167;
    fail_assertion("negative array index");
    _jump167:;
    if (_144 < _112.d2)
    goto _jump168;
    fail_assertion("index too large");
    _jump168:;
    int64_t _159 = 0;
    _159 *= _112.d0;
    _159 += _122;
    _159 *= _112.d1;
    _159 += _143;
    _159 *= _112.d2;
    _159 += _144;
    _a1_int64_t _160 = _112.data[_159];
    a _161 = b(_0, _160, f);
    return _161;
    _a3_int64_t _162;
    // Computing bound for g
    int64_t _163 = 581;
    _162.d0 = _163;
    if (_163 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    // Computing bound for h
    bool _164 = false;
    bool _165;
    if (!_164)
    goto _jump170;
    bool _166 = true;
    _165 = _166;
    goto _jump171;
    _jump170:;
    bool _167 = false;
    bool _168;
    if (!_167)
    goto _jump172;
    bool _169 = true;
    _168 = _169;
    goto _jump173;
    _jump172:;
    bool _170 = true;
    bool _171;
    if (!_170)
    goto _jump174;
    bool _172 = true;
    bool _173 = !_172;
    _171 = _173;
    goto _jump175;
    _jump174:;
    bool _174 = true;
    bool _175 = !_174;
    _171 = _175;
    _jump175:;
    _168 = _171;
    _jump173:;
    _165 = _168;
    _jump171:;
    _a3_int64_t _176;
    if (!_165)
    goto _jump176;
    _a1__a3_int64_t _177;
    // Computing bound for g
    int64_t _178 = 555;
    int64_t _179 = c * _178;
    int64_t _180 = -_179;
    _177.d0 = _180;
    if (_180 > 0) 
    goto _jump177;
    fail_assertion("non-positive loop bound");
    _jump177:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= _180;
    _181 *= sizeof(_a3_int64_t);
    _177.data = jpl_alloc(_181);
    int64_t _182 = 0; // g
    _jump178:; // Begin body of loop
    _a3_int64_t _183;
    // Computing bound for h
    int64_t _184 = 116;
    _183.d0 = _184;
    if (_184 > 0) 
    goto _jump179;
    fail_assertion("non-positive loop bound");
    _jump179:;
    // Computing bound for i
    _183.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump180;
    fail_assertion("non-positive loop bound");
    _jump180:;
    // Computing bound for j
    _183.d2 = c;
    if (c > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    // Computing total size of heap memory to allocate
    int64_t _185 = 1;
    _185 *= _184;
    _185 *= d.d0;
    _185 *= c;
    _185 *= sizeof(int64_t);
    _183.data = jpl_alloc(_185);
    int64_t _186 = 0; // j
    int64_t _187 = 0; // i
    int64_t _188 = 0; // h
    _jump182:; // Begin body of loop
    int64_t _189 = 0;
    _189 *= _183.d0;
    _189 += _188;
    _189 *= _183.d1;
    _189 += _187;
    _189 *= _183.d2;
    _189 += _186;
    _183.data[_189] = c;
    _186++;
    if (_186 < c)
    goto _jump182;
    _186 = 0;
    _187++;
    if (_187 < d.d0)
    goto _jump182;
    _187 = 0;
    _188++;
    if (_188 < _184)
    goto _jump182;
    // End body of loop
    int64_t _190 = 0;
    _190 *= _177.d0;
    _190 += _182;
    _177.data[_190] = _183;
    _182++;
    if (_182 < _180)
    goto _jump178;
    // End body of loop
    bool _191 = true;
    bool _192 = !_191;
    a _193;
    if (!_192)
    goto _jump183;
    _193 = f;
    goto _jump184;
    _jump183:;
    _193 = f;
    _jump184:;
    int64_t _194 = _193.a;
    if (_194 >= 0)
    goto _jump185;
    fail_assertion("negative array index");
    _jump185:;
    if (_194 < _177.d0)
    goto _jump186;
    fail_assertion("index too large");
    _jump186:;
    int64_t _195 = 0;
    _195 *= _177.d0;
    _195 += _194;
    _a3_int64_t _196 = _177.data[_195];
    _176 = _196;
    goto _jump187;
    _jump176:;
    bool _197 = true;
    bool _198 = !_197;
    _a1__a3_int64_t _199;
    if (!_198)
    goto _jump188;
    _a1__a3_int64_t _200;
    // Computing bound for g
    int64_t _201 = -c;
    _200.d0 = _201;
    if (_201 > 0) 
    goto _jump189;
    fail_assertion("non-positive loop bound");
    _jump189:;
    // Computing total size of heap memory to allocate
    int64_t _202 = 1;
    _202 *= _201;
    _202 *= sizeof(_a3_int64_t);
    _200.data = jpl_alloc(_202);
    int64_t _203 = 0; // g
    _jump190:; // Begin body of loop
    _a3_int64_t _204;
    // Computing bound for h
    _204.d0 = c;
    if (c > 0) 
    goto _jump191;
    fail_assertion("non-positive loop bound");
    _jump191:;
    // Computing bound for i
    _204.d1 = _203;
    if (_203 > 0) 
    goto _jump192;
    fail_assertion("non-positive loop bound");
    _jump192:;
    // Computing bound for j
    int64_t _205 = 548;
    _204.d2 = _205;
    if (_205 > 0) 
    goto _jump193;
    fail_assertion("non-positive loop bound");
    _jump193:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= c;
    _206 *= _203;
    _206 *= _205;
    _206 *= sizeof(int64_t);
    _204.data = jpl_alloc(_206);
    int64_t _207 = 0; // j
    int64_t _208 = 0; // i
    int64_t _209 = 0; // h
    _jump194:; // Begin body of loop
    int64_t _210 = 0;
    _210 *= _204.d0;
    _210 += _209;
    _210 *= _204.d1;
    _210 += _208;
    _210 *= _204.d2;
    _210 += _207;
    _204.data[_210] = _209;
    _207++;
    if (_207 < _205)
    goto _jump194;
    _207 = 0;
    _208++;
    if (_208 < _203)
    goto _jump194;
    _208 = 0;
    _209++;
    if (_209 < c)
    goto _jump194;
    // End body of loop
    int64_t _211 = 0;
    _211 *= _200.d0;
    _211 += _203;
    _200.data[_211] = _204;
    _203++;
    if (_203 < _201)
    goto _jump190;
    // End body of loop
    _199 = _200;
    goto _jump195;
    _jump188:;
    _a1__a3_int64_t _212;
    // Computing bound for g
    int64_t _213 = d.d0 * c;
    _212.d0 = _213;
    if (_213 > 0) 
    goto _jump196;
    fail_assertion("non-positive loop bound");
    _jump196:;
    // Computing total size of heap memory to allocate
    int64_t _214 = 1;
    _214 *= _213;
    _214 *= sizeof(_a3_int64_t);
    _212.data = jpl_alloc(_214);
    int64_t _215 = 0; // g
    _jump197:; // Begin body of loop
    _a3_int64_t _216;
    // Computing bound for h
    _216.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    // Computing bound for i
    _216.d1 = _215;
    if (_215 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    // Computing bound for j
    int64_t _217 = 457;
    _216.d2 = _217;
    if (_217 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    // Computing total size of heap memory to allocate
    int64_t _218 = 1;
    _218 *= d.d0;
    _218 *= _215;
    _218 *= _217;
    _218 *= sizeof(int64_t);
    _216.data = jpl_alloc(_218);
    int64_t _219 = 0; // j
    int64_t _220 = 0; // i
    int64_t _221 = 0; // h
    _jump201:; // Begin body of loop
    int64_t _222 = 0;
    _222 *= _216.d0;
    _222 += _221;
    _222 *= _216.d1;
    _222 += _220;
    _222 *= _216.d2;
    _222 += _219;
    _216.data[_222] = _220;
    _219++;
    if (_219 < _217)
    goto _jump201;
    _219 = 0;
    _220++;
    if (_220 < _215)
    goto _jump201;
    _220 = 0;
    _221++;
    if (_221 < d.d0)
    goto _jump201;
    // End body of loop
    int64_t _223 = 0;
    _223 *= _212.d0;
    _223 += _215;
    _212.data[_223] = _216;
    _215++;
    if (_215 < _213)
    goto _jump197;
    // End body of loop
    _199 = _212;
    _jump195:;
    int64_t _224 = 565;
    if (_224 >= 0)
    goto _jump202;
    fail_assertion("negative array index");
    _jump202:;
    if (_224 < _199.d0)
    goto _jump203;
    fail_assertion("index too large");
    _jump203:;
    int64_t _225 = 0;
    _225 *= _199.d0;
    _225 += _224;
    _a3_int64_t _226 = _199.data[_225];
    _176 = _226;
    _jump187:;
    int64_t _227 = 78;
    int64_t _228;
    // Computing bound for g
    if (c > 0) 
    goto _jump204;
    fail_assertion("non-positive loop bound");
    _jump204:;
    // Computing bound for h
    if (c > 0) 
    goto _jump205;
    fail_assertion("non-positive loop bound");
    _jump205:;
    _228 = 0;
    int64_t _229 = 0; // h
    int64_t _230 = 0; // g
    _jump206:; // Begin body of loop
    _228 += c;
    _229++;
    if (_229 < c)
    goto _jump206;
    _229 = 0;
    _230++;
    if (_230 < c)
    goto _jump206;
    // End body of loop
    int64_t _231 = _227 * _228;
    int64_t _232 = -_231;
    _a2_void_t _233;
    // Computing bound for g
    int64_t _234;
    // Computing bound for g
    int64_t _235 = 602;
    if (_235 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing bound for h
    int64_t _236 = 439;
    if (_236 > 0) 
    goto _jump208;
    fail_assertion("non-positive loop bound");
    _jump208:;
    // Computing bound for i
    if (c > 0) 
    goto _jump209;
    fail_assertion("non-positive loop bound");
    _jump209:;
    _234 = 0;
    int64_t _237 = 0; // i
    int64_t _238 = 0; // h
    int64_t _239 = 0; // g
    _jump210:; // Begin body of loop
    _234 += _238;
    _237++;
    if (_237 < c)
    goto _jump210;
    _237 = 0;
    _238++;
    if (_238 < _236)
    goto _jump210;
    _238 = 0;
    _239++;
    if (_239 < _235)
    goto _jump210;
    // End body of loop
    _233.d0 = _234;
    if (_234 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for h
    int64_t _240 = -c;
    _233.d1 = _240;
    if (_240 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing total size of heap memory to allocate
    int64_t _241 = 1;
    _241 *= _234;
    _241 *= _240;
    _241 *= sizeof(void_t);
    _233.data = jpl_alloc(_241);
    int64_t _242 = 0; // h
    int64_t _243 = 0; // g
    _jump213:; // Begin body of loop
    void_t _244 = f.b;
    int64_t _245 = 0;
    _245 *= _233.d0;
    _245 += _243;
    _245 *= _233.d1;
    _245 += _242;
    _233.data[_245] = _244;
    _242++;
    if (_242 < _240)
    goto _jump213;
    _242 = 0;
    _243++;
    if (_243 < _234)
    goto _jump213;
    // End body of loop
    int64_t _246;
    // Computing bound for g
    int64_t _247 = 679;
    if (_247 > 0) 
    goto _jump214;
    fail_assertion("non-positive loop bound");
    _jump214:;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    _246 = 0;
    int64_t _248 = 0; // h
    int64_t _249 = 0; // g
    _jump216:; // Begin body of loop
    _246 += c;
    _248++;
    if (_248 < d.d0)
    goto _jump216;
    _248 = 0;
    _249++;
    if (_249 < _247)
    goto _jump216;
    // End body of loop
    bool _250 = true;
    a _251;
    if (!_250)
    goto _jump217;
    _251 = f;
    goto _jump218;
    _jump217:;
    _251 = f;
    _jump218:;
    int64_t _252 = _251.a;
    if (_246 >= 0)
    goto _jump219;
    fail_assertion("negative array index");
    _jump219:;
    if (_246 < _233.d0)
    goto _jump220;
    fail_assertion("index too large");
    _jump220:;
    if (_252 >= 0)
    goto _jump221;
    fail_assertion("negative array index");
    _jump221:;
    if (_252 < _233.d1)
    goto _jump222;
    fail_assertion("index too large");
    _jump222:;
    int64_t _253 = 0;
    _253 *= _233.d0;
    _253 += _246;
    _253 *= _233.d1;
    _253 += _252;
    void_t _254 = _233.data[_253];
    a _255 = { _232, _254 };
    int64_t _256 = _255.a;
    int64_t _257 = f.a;
    int64_t _258 = c * _257;
    if (c >= 0)
    goto _jump223;
    fail_assertion("negative array index");
    _jump223:;
    if (c < _176.d0)
    goto _jump224;
    fail_assertion("index too large");
    _jump224:;
    if (_256 >= 0)
    goto _jump225;
    fail_assertion("negative array index");
    _jump225:;
    if (_256 < _176.d1)
    goto _jump226;
    fail_assertion("index too large");
    _jump226:;
    if (_258 >= 0)
    goto _jump227;
    fail_assertion("negative array index");
    _jump227:;
    if (_258 < _176.d2)
    goto _jump228;
    fail_assertion("index too large");
    _jump228:;
    int64_t _259 = 0;
    _259 *= _176.d0;
    _259 += c;
    _259 *= _176.d1;
    _259 += _256;
    _259 *= _176.d2;
    _259 += _258;
    int64_t _260 = _176.data[_259];
    _162.d1 = _260;
    if (_260 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for i
    int64_t _261;
    // Computing bound for g
    int64_t _262;
    // Computing bound for g
    int64_t _263;
    // Computing bound for g
    int64_t _264 = 761;
    if (_264 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for h
    int64_t _265 = 684;
    if (_265 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    _263 = 0;
    int64_t _266 = 0; // h
    int64_t _267 = 0; // g
    _jump232:; // Begin body of loop
    _263 += _266;
    _266++;
    if (_266 < _265)
    goto _jump232;
    _266 = 0;
    _267++;
    if (_267 < _264)
    goto _jump232;
    // End body of loop
    if (_263 > 0) 
    goto _jump233;
    fail_assertion("non-positive loop bound");
    _jump233:;
    // Computing bound for h
    if (c > 0) 
    goto _jump234;
    fail_assertion("non-positive loop bound");
    _jump234:;
    _262 = 0;
    int64_t _268 = 0; // h
    int64_t _269 = 0; // g
    _jump235:; // Begin body of loop
    int64_t _270 = 512;
    _262 += _270;
    _268++;
    if (_268 < c)
    goto _jump235;
    _268 = 0;
    _269++;
    if (_269 < _263)
    goto _jump235;
    // End body of loop
    if (_262 > 0) 
    goto _jump236;
    fail_assertion("non-positive loop bound");
    _jump236:;
    // Computing bound for h
    int64_t _271 = f.a;
    int64_t _272 = -_271;
    if (_272 > 0) 
    goto _jump237;
    fail_assertion("non-positive loop bound");
    _jump237:;
    _261 = 0;
    int64_t _273 = 0; // h
    int64_t _274 = 0; // g
    _jump238:; // Begin body of loop
    int64_t _275;
    // Computing bound for i
    if (d.d0 > 0) 
    goto _jump239;
    fail_assertion("non-positive loop bound");
    _jump239:;
    _275 = 0;
    int64_t _276 = 0; // i
    _jump240:; // Begin body of loop
    _275 += _273;
    _276++;
    if (_276 < d.d0)
    goto _jump240;
    // End body of loop
    int64_t _277 = -_275;
    _261 += _277;
    _273++;
    if (_273 < _272)
    goto _jump238;
    _273 = 0;
    _274++;
    if (_274 < _262)
    goto _jump238;
    // End body of loop
    bool _278 = false;
    bool _279 = !_278;
    int64_t _280;
    if (!_279)
    goto _jump241;
    _280 = c;
    goto _jump242;
    _jump241:;
    int64_t _281 = 284;
    _280 = _281;
    _jump242:;
    bool _282 = _261 != _280;
    _a1_int64_t _283;
    if (!_282)
    goto _jump243;
    _a2__a1_int64_t _284;
    // Computing bound for g
    _284.d0 = c;
    if (c > 0) 
    goto _jump244;
    fail_assertion("non-positive loop bound");
    _jump244:;
    // Computing bound for h
    _284.d1 = c;
    if (c > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _285 = 1;
    _285 *= c;
    _285 *= c;
    _285 *= sizeof(_a1_int64_t);
    _284.data = jpl_alloc(_285);
    int64_t _286 = 0; // h
    int64_t _287 = 0; // g
    _jump246:; // Begin body of loop
    int64_t _288 = 0;
    _288 *= _284.d0;
    _288 += _287;
    _288 *= _284.d1;
    _288 += _286;
    _284.data[_288] = d;
    _286++;
    if (_286 < c)
    goto _jump246;
    _286 = 0;
    _287++;
    if (_287 < c)
    goto _jump246;
    // End body of loop
    int64_t _289 = 446;
    int64_t _290 = -_289;
    if (_290 >= 0)
    goto _jump247;
    fail_assertion("negative array index");
    _jump247:;
    if (_290 < _284.d0)
    goto _jump248;
    fail_assertion("index too large");
    _jump248:;
    if (d.d0 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (d.d0 < _284.d1)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    int64_t _291 = 0;
    _291 *= _284.d0;
    _291 += _290;
    _291 *= _284.d1;
    _291 += d.d0;
    _a1_int64_t _292 = _284.data[_291];
    _283 = _292;
    goto _jump251;
    _jump243:;
    _a3__a1_int64_t _293;
    // Computing bound for g
    int64_t _294 = -c;
    int64_t _295 = 112;
    int64_t _296 = _294 + _295;
    _293.d0 = _296;
    if (_296 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for h
    int64_t _297;
    // Computing bound for g
    if (d.d0 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    _297 = 0;
    int64_t _298 = 0; // g
    _jump254:; // Begin body of loop
    _297 += c;
    _298++;
    if (_298 < d.d0)
    goto _jump254;
    // End body of loop
    _293.d1 = _297;
    if (_297 > 0) 
    goto _jump255;
    fail_assertion("non-positive loop bound");
    _jump255:;
    // Computing bound for i
    int64_t _299 = 872;
    _293.d2 = _299;
    if (_299 > 0) 
    goto _jump256;
    fail_assertion("non-positive loop bound");
    _jump256:;
    // Computing total size of heap memory to allocate
    int64_t _300 = 1;
    _300 *= _296;
    _300 *= _297;
    _300 *= _299;
    _300 *= sizeof(_a1_int64_t);
    _293.data = jpl_alloc(_300);
    int64_t _301 = 0; // i
    int64_t _302 = 0; // h
    int64_t _303 = 0; // g
    _jump257:; // Begin body of loop
    int64_t _304 = _301 % c;
    int64_t _305 = -_303;
    _a1_int64_t _306;
    _306.d0 = 3;
    _306.data = jpl_alloc(sizeof(int64_t) * 3);
    _306.data[0] = d.d0;
    _306.data[1] = _304;
    _306.data[2] = _305;
    int64_t _307 = 0;
    _307 *= _293.d0;
    _307 += _303;
    _307 *= _293.d1;
    _307 += _302;
    _307 *= _293.d2;
    _307 += _301;
    _293.data[_307] = _306;
    _301++;
    if (_301 < _299)
    goto _jump257;
    _301 = 0;
    _302++;
    if (_302 < _297)
    goto _jump257;
    _302 = 0;
    _303++;
    if (_303 < _296)
    goto _jump257;
    // End body of loop
    int64_t _308 = f.a;
    _a1_int64_t _309;
    // Computing bound for g
    int64_t _310 = 807;
    int64_t _311 = -_310;
    _309.d0 = _311;
    if (_311 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    // Computing total size of heap memory to allocate
    int64_t _312 = 1;
    _312 *= _311;
    _312 *= sizeof(int64_t);
    _309.data = jpl_alloc(_312);
    int64_t _313 = 0; // g
    _jump259:; // Begin body of loop
    int64_t _314 = 0;
    _314 *= _309.d0;
    _314 += _313;
    _309.data[_314] = c;
    _313++;
    if (_313 < _311)
    goto _jump259;
    // End body of loop
    if (d.d0 >= 0)
    goto _jump260;
    fail_assertion("negative array index");
    _jump260:;
    if (d.d0 < _309.d0)
    goto _jump261;
    fail_assertion("index too large");
    _jump261:;
    int64_t _315 = 0;
    _315 *= _309.d0;
    _315 += d.d0;
    int64_t _316 = _309.data[_315];
    if (_308 >= 0)
    goto _jump262;
    fail_assertion("negative array index");
    _jump262:;
    if (_308 < _293.d0)
    goto _jump263;
    fail_assertion("index too large");
    _jump263:;
    if (d.d0 >= 0)
    goto _jump264;
    fail_assertion("negative array index");
    _jump264:;
    if (d.d0 < _293.d1)
    goto _jump265;
    fail_assertion("index too large");
    _jump265:;
    if (_316 >= 0)
    goto _jump266;
    fail_assertion("negative array index");
    _jump266:;
    if (_316 < _293.d2)
    goto _jump267;
    fail_assertion("index too large");
    _jump267:;
    int64_t _317 = 0;
    _317 *= _293.d0;
    _317 += _308;
    _317 *= _293.d1;
    _317 += d.d0;
    _317 *= _293.d2;
    _317 += _316;
    _a1_int64_t _318 = _293.data[_317];
    _283 = _318;
    _jump251:;
    int64_t _319;
    // Computing bound for g
    int64_t _320;
    // Computing bound for g
    if (c > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for h
    bool _321 = false;
    bool _322 = !_321;
    _a1_int64_t _323;
    if (!_322)
    goto _jump269;
    _323 = d;
    goto _jump270;
    _jump269:;
    bool _324 = false;
    _a1_int64_t _325;
    if (!_324)
    goto _jump271;
    _325 = d;
    goto _jump272;
    _jump271:;
    _325 = d;
    _jump272:;
    _323 = _325;
    _jump270:;
    int64_t _326;
    // Computing bound for g
    int64_t _327 = 146;
    if (_327 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    _326 = 0;
    int64_t _328 = 0; // g
    _jump274:; // Begin body of loop
    _326 += d.d0;
    _328++;
    if (_328 < _327)
    goto _jump274;
    // End body of loop
    if (_326 >= 0)
    goto _jump275;
    fail_assertion("negative array index");
    _jump275:;
    if (_326 < _323.d0)
    goto _jump276;
    fail_assertion("index too large");
    _jump276:;
    int64_t _329 = 0;
    _329 *= _323.d0;
    _329 += _326;
    int64_t _330 = _323.data[_329];
    if (_330 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    _320 = 0;
    int64_t _331 = 0; // h
    int64_t _332 = 0; // g
    _jump278:; // Begin body of loop
    int64_t _333 = f.a;
    _320 += _333;
    _331++;
    if (_331 < _330)
    goto _jump278;
    _331 = 0;
    _332++;
    if (_332 < c)
    goto _jump278;
    // End body of loop
    if (_320 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    _319 = 0;
    int64_t _334 = 0; // g
    _jump280:; // Begin body of loop
    _a3_a _335;
    // Computing bound for h
    int64_t _336;
    // Computing bound for h
    if (_334 > 0) 
    goto _jump281;
    fail_assertion("non-positive loop bound");
    _jump281:;
    // Computing bound for i
    if (_334 > 0) 
    goto _jump282;
    fail_assertion("non-positive loop bound");
    _jump282:;
    // Computing bound for j
    if (c > 0) 
    goto _jump283;
    fail_assertion("non-positive loop bound");
    _jump283:;
    _336 = 0;
    int64_t _337 = 0; // j
    int64_t _338 = 0; // i
    int64_t _339 = 0; // h
    _jump284:; // Begin body of loop
    _336 += _337;
    _337++;
    if (_337 < c)
    goto _jump284;
    _337 = 0;
    _338++;
    if (_338 < _334)
    goto _jump284;
    _338 = 0;
    _339++;
    if (_339 < _334)
    goto _jump284;
    // End body of loop
    _335.d0 = _336;
    if (_336 > 0) 
    goto _jump285;
    fail_assertion("non-positive loop bound");
    _jump285:;
    // Computing bound for i
    int64_t _340 = 695;
    _335.d1 = _340;
    if (_340 > 0) 
    goto _jump286;
    fail_assertion("non-positive loop bound");
    _jump286:;
    // Computing bound for j
    int64_t _341 = 840;
    _335.d2 = _341;
    if (_341 > 0) 
    goto _jump287;
    fail_assertion("non-positive loop bound");
    _jump287:;
    // Computing total size of heap memory to allocate
    int64_t _342 = 1;
    _342 *= _336;
    _342 *= _340;
    _342 *= _341;
    _342 *= sizeof(a);
    _335.data = jpl_alloc(_342);
    int64_t _343 = 0; // j
    int64_t _344 = 0; // i
    int64_t _345 = 0; // h
    _jump288:; // Begin body of loop
    int64_t _346 = 0;
    _346 *= _335.d0;
    _346 += _345;
    _346 *= _335.d1;
    _346 += _344;
    _346 *= _335.d2;
    _346 += _343;
    _335.data[_346] = f;
    _343++;
    if (_343 < _341)
    goto _jump288;
    _343 = 0;
    _344++;
    if (_344 < _340)
    goto _jump288;
    _344 = 0;
    _345++;
    if (_345 < _336)
    goto _jump288;
    // End body of loop
    _a1_int64_t _347;
    _347.d0 = 2;
    _347.data = jpl_alloc(sizeof(int64_t) * 2);
    _347.data[0] = d.d0;
    _347.data[1] = c;
    int64_t _348 = 887;
    if (_348 >= 0)
    goto _jump289;
    fail_assertion("negative array index");
    _jump289:;
    if (_348 < d.d0)
    goto _jump290;
    fail_assertion("index too large");
    _jump290:;
    int64_t _349 = 0;
    _349 *= d.d0;
    _349 += _348;
    int64_t _350 = d.data[_349];
    if (_350 >= 0)
    goto _jump291;
    fail_assertion("negative array index");
    _jump291:;
    if (_350 < _347.d0)
    goto _jump292;
    fail_assertion("index too large");
    _jump292:;
    int64_t _351 = 0;
    _351 *= _347.d0;
    _351 += _350;
    int64_t _352 = _347.data[_351];
    int64_t _353 = f.a;
    int64_t _354 = 566;
    int64_t _355 = -_354;
    int64_t _356 = _353 - _355;
    int64_t _357 = c - c;
    if (_352 >= 0)
    goto _jump293;
    fail_assertion("negative array index");
    _jump293:;
    if (_352 < _335.d0)
    goto _jump294;
    fail_assertion("index too large");
    _jump294:;
    if (_356 >= 0)
    goto _jump295;
    fail_assertion("negative array index");
    _jump295:;
    if (_356 < _335.d1)
    goto _jump296;
    fail_assertion("index too large");
    _jump296:;
    if (_357 >= 0)
    goto _jump297;
    fail_assertion("negative array index");
    _jump297:;
    if (_357 < _335.d2)
    goto _jump298;
    fail_assertion("index too large");
    _jump298:;
    int64_t _358 = 0;
    _358 *= _335.d0;
    _358 += _352;
    _358 *= _335.d1;
    _358 += _356;
    _358 *= _335.d2;
    _358 += _357;
    a _359 = _335.data[_358];
    int64_t _360 = _359.a;
    _319 += _360;
    _334++;
    if (_334 < _320)
    goto _jump280;
    // End body of loop
    if (_319 >= 0)
    goto _jump299;
    fail_assertion("negative array index");
    _jump299:;
    if (_319 < _283.d0)
    goto _jump300;
    fail_assertion("index too large");
    _jump300:;
    int64_t _361 = 0;
    _361 *= _283.d0;
    _361 += _319;
    int64_t _362 = _283.data[_361];
    _162.d2 = _362;
    if (_362 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing total size of heap memory to allocate
    int64_t _363 = 1;
    _363 *= _163;
    _363 *= _260;
    _363 *= _362;
    _363 *= sizeof(int64_t);
    _162.data = jpl_alloc(_363);
    int64_t _364 = 0; // i
    int64_t _365 = 0; // h
    int64_t _366 = 0; // g
    _jump302:; // Begin body of loop
    _a1_int64_t _367;
    // Computing bound for j
    _367.d0 = _364;
    if (_364 > 0) 
    goto _jump303;
    fail_assertion("non-positive loop bound");
    _jump303:;
    // Computing total size of heap memory to allocate
    int64_t _368 = 1;
    _368 *= _364;
    _368 *= sizeof(int64_t);
    _367.data = jpl_alloc(_368);
    int64_t _369 = 0; // j
    _jump304:; // Begin body of loop
    int64_t _370 = 0;
    _370 *= _367.d0;
    _370 += _369;
    _367.data[_370] = _364;
    _369++;
    if (_369 < _364)
    goto _jump304;
    // End body of loop
    int64_t _371 = -_364;
    if (_371 >= 0)
    goto _jump305;
    fail_assertion("negative array index");
    _jump305:;
    if (_371 < _367.d0)
    goto _jump306;
    fail_assertion("index too large");
    _jump306:;
    int64_t _372 = 0;
    _372 *= _367.d0;
    _372 += _371;
    int64_t _373 = _367.data[_372];
    _a1_int64_t _374;
    _374.d0 = 3;
    _374.data = jpl_alloc(sizeof(int64_t) * 3);
    _374.data[0] = _364;
    _374.data[1] = _366;
    _374.data[2] = _373;
    if (d.d0 >= 0)
    goto _jump307;
    fail_assertion("negative array index");
    _jump307:;
    if (d.d0 < _374.d0)
    goto _jump308;
    fail_assertion("index too large");
    _jump308:;
    int64_t _375 = 0;
    _375 *= _374.d0;
    _375 += d.d0;
    int64_t _376 = _374.data[_375];
    _a2_a _377;
    // Computing bound for j
    _377.d0 = c;
    if (c > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for k
    _377.d1 = _366;
    if (_366 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    // Computing total size of heap memory to allocate
    int64_t _378 = 1;
    _378 *= c;
    _378 *= _366;
    _378 *= sizeof(a);
    _377.data = jpl_alloc(_378);
    int64_t _379 = 0; // k
    int64_t _380 = 0; // j
    _jump311:; // Begin body of loop
    int64_t _381 = 0;
    _381 *= _377.d0;
    _381 += _380;
    _381 *= _377.d1;
    _381 += _379;
    _377.data[_381] = f;
    _379++;
    if (_379 < _366)
    goto _jump311;
    _379 = 0;
    _380++;
    if (_380 < c)
    goto _jump311;
    // End body of loop
    int64_t _382;
    // Computing bound for j
    if (_364 > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for k
    if (d.d0 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    // Computing bound for l
    int64_t _383 = 659;
    int64_t _384 = -_383;
    if (_384 > 0) 
    goto _jump314;
    fail_assertion("non-positive loop bound");
    _jump314:;
    _382 = 0;
    int64_t _385 = 0; // l
    int64_t _386 = 0; // k
    int64_t _387 = 0; // j
    _jump315:; // Begin body of loop
    int64_t _388 = 523;
    _382 += _388;
    _385++;
    if (_385 < _384)
    goto _jump315;
    _385 = 0;
    _386++;
    if (_386 < d.d0)
    goto _jump315;
    _386 = 0;
    _387++;
    if (_387 < _364)
    goto _jump315;
    // End body of loop
    int64_t _389 = _366 + _382;
    if (_366 >= 0)
    goto _jump316;
    fail_assertion("negative array index");
    _jump316:;
    if (_366 < _377.d0)
    goto _jump317;
    fail_assertion("index too large");
    _jump317:;
    if (_389 >= 0)
    goto _jump318;
    fail_assertion("negative array index");
    _jump318:;
    if (_389 < _377.d1)
    goto _jump319;
    fail_assertion("index too large");
    _jump319:;
    int64_t _390 = 0;
    _390 *= _377.d0;
    _390 += _366;
    _390 *= _377.d1;
    _390 += _389;
    a _391 = _377.data[_390];
    a _392 = b(_376, d, _391);
    int64_t _393 = _392.a;
    int64_t _394 = 0;
    _394 *= _162.d0;
    _394 += _366;
    _394 *= _162.d1;
    _394 += _365;
    _394 *= _162.d2;
    _394 += _364;
    _162.data[_394] = _393;
    _364++;
    if (_364 < _362)
    goto _jump302;
    _364 = 0;
    _365++;
    if (_365 < _260)
    goto _jump302;
    _365 = 0;
    _366++;
    if (_366 < _163)
    goto _jump302;
    // End body of loop
    _a2_bool _395;
    // Computing bound for h
    _395.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump320;
    fail_assertion("non-positive loop bound");
    _jump320:;
    // Computing bound for i
    _395.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing total size of heap memory to allocate
    int64_t _396 = 1;
    _396 *= d.d0;
    _396 *= d.d0;
    _396 *= sizeof(bool);
    _395.data = jpl_alloc(_396);
    int64_t _397 = 0; // i
    int64_t _398 = 0; // h
    _jump322:; // Begin body of loop
    bool _399 = true;
    int64_t _400;
    if (!_399)
    goto _jump323;
    _400 = _398;
    goto _jump324;
    _jump323:;
    _400 = c;
    _jump324:;
    bool _401 = d.d0 == _400;
    int64_t _402 = 0;
    _402 *= _395.d0;
    _402 += _398;
    _402 *= _395.d1;
    _402 += _397;
    _395.data[_402] = _401;
    _397++;
    if (_397 < d.d0)
    goto _jump322;
    _397 = 0;
    _398++;
    if (_398 < d.d0)
    goto _jump322;
    // End body of loop
    _a2_bool _403;
    // Computing bound for h
    int64_t _404 = f.a;
    _403.d0 = _404;
    if (_404 > 0) 
    goto _jump325;
    fail_assertion("non-positive loop bound");
    _jump325:;
    // Computing bound for i
    int64_t _405 = f.a;
    _403.d1 = _405;
    if (_405 > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing total size of heap memory to allocate
    int64_t _406 = 1;
    _406 *= _404;
    _406 *= _405;
    _406 *= sizeof(bool);
    _403.data = jpl_alloc(_406);
    int64_t _407 = 0; // i
    int64_t _408 = 0; // h
    _jump327:; // Begin body of loop
    bool _409 = true;
    int64_t _410 = 0;
    _410 *= _403.d0;
    _410 += _408;
    _410 *= _403.d1;
    _410 += _407;
    _403.data[_410] = _409;
    _407++;
    if (_407 < _405)
    goto _jump327;
    _407 = 0;
    _408++;
    if (_408 < _404)
    goto _jump327;
    // End body of loop
    _a2_bool _411;
    // Computing bound for h
    int64_t _412 = f.a;
    _411.d0 = _412;
    if (_412 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    // Computing bound for i
    _a2_int64_t _413;
    // Computing bound for h
    _413.d0 = c;
    if (c > 0) 
    goto _jump329;
    fail_assertion("non-positive loop bound");
    _jump329:;
    // Computing bound for i
    _413.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump330;
    fail_assertion("non-positive loop bound");
    _jump330:;
    // Computing total size of heap memory to allocate
    int64_t _414 = 1;
    _414 *= c;
    _414 *= d.d0;
    _414 *= sizeof(int64_t);
    _413.data = jpl_alloc(_414);
    int64_t _415 = 0; // i
    int64_t _416 = 0; // h
    _jump331:; // Begin body of loop
    int64_t _417 = 0;
    _417 *= _413.d0;
    _417 += _416;
    _417 *= _413.d1;
    _417 += _415;
    _413.data[_417] = d.d0;
    _415++;
    if (_415 < d.d0)
    goto _jump331;
    _415 = 0;
    _416++;
    if (_416 < c)
    goto _jump331;
    // End body of loop
    int64_t _418 = 206;
    if (_418 >= 0)
    goto _jump332;
    fail_assertion("negative array index");
    _jump332:;
    if (_418 < _413.d0)
    goto _jump333;
    fail_assertion("index too large");
    _jump333:;
    if (d.d0 >= 0)
    goto _jump334;
    fail_assertion("negative array index");
    _jump334:;
    if (d.d0 < _413.d1)
    goto _jump335;
    fail_assertion("index too large");
    _jump335:;
    int64_t _419 = 0;
    _419 *= _413.d0;
    _419 += _418;
    _419 *= _413.d1;
    _419 += d.d0;
    int64_t _420 = _413.data[_419];
    _411.d1 = _420;
    if (_420 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    // Computing total size of heap memory to allocate
    int64_t _421 = 1;
    _421 *= _412;
    _421 *= _420;
    _421 *= sizeof(bool);
    _411.data = jpl_alloc(_421);
    int64_t _422 = 0; // i
    int64_t _423 = 0; // h
    _jump337:; // Begin body of loop
    bool _424 = true;
    int64_t _425 = 0;
    _425 *= _411.d0;
    _425 += _423;
    _425 *= _411.d1;
    _425 += _422;
    _411.data[_425] = _424;
    _422++;
    if (_422 < _420)
    goto _jump337;
    _422 = 0;
    _423++;
    if (_423 < _412)
    goto _jump337;
    // End body of loop
    _a1__a2_bool _426;
    _426.d0 = 3;
    _426.data = jpl_alloc(sizeof(_a2_bool) * 3);
    _426.data[0] = _395;
    _426.data[1] = _403;
    _426.data[2] = _411;
    int64_t _427 = -d.d0;
    if (_427 >= 0)
    goto _jump338;
    fail_assertion("negative array index");
    _jump338:;
    if (_427 < _426.d0)
    goto _jump339;
    fail_assertion("index too large");
    _jump339:;
    int64_t _428 = 0;
    _428 *= _426.d0;
    _428 += _427;
    _a2_bool _429 = _426.data[_428];
    bool _430 = false;
    int64_t _431;
    if (!_430)
    goto _jump340;
    int64_t _432 = -c;
    _431 = _432;
    goto _jump341;
    _jump340:;
    int64_t _433 = 938;
    _431 = _433;
    _jump341:;
    if (c >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (c < _429.d0)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    if (_431 >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (_431 < _429.d1)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    int64_t _434 = 0;
    _434 *= _429.d0;
    _434 += c;
    _434 *= _429.d1;
    _434 += _431;
    bool _435 = _429.data[_434];
    _a2__a3_int64_t _436;
    if (!_435)
    goto _jump346;
    int64_t _438 = f.a;
    bool _439 = d.d0 > _438;
    bool _440 = !_439;
    bool _437 = _440;
    if (0 != _440)
    goto _jump347;
    _a2_bool _442;
    // Computing bound for h
    _442.d0 = c;
    if (c > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing bound for i
    _442.d1 = c;
    if (c > 0) 
    goto _jump349;
    fail_assertion("non-positive loop bound");
    _jump349:;
    // Computing total size of heap memory to allocate
    int64_t _443 = 1;
    _443 *= c;
    _443 *= c;
    _443 *= sizeof(bool);
    _442.data = jpl_alloc(_443);
    int64_t _444 = 0; // i
    int64_t _445 = 0; // h
    _jump350:; // Begin body of loop
    bool _446 = true;
    bool _447 = !_446;
    int64_t _448 = 0;
    _448 *= _442.d0;
    _448 += _445;
    _448 *= _442.d1;
    _448 += _444;
    _442.data[_448] = _447;
    _444++;
    if (_444 < c)
    goto _jump350;
    _444 = 0;
    _445++;
    if (_445 < c)
    goto _jump350;
    // End body of loop
    if (d.d0 >= 0)
    goto _jump351;
    fail_assertion("negative array index");
    _jump351:;
    if (d.d0 < _442.d0)
    goto _jump352;
    fail_assertion("index too large");
    _jump352:;
    if (d.d0 >= 0)
    goto _jump353;
    fail_assertion("negative array index");
    _jump353:;
    if (d.d0 < _442.d1)
    goto _jump354;
    fail_assertion("index too large");
    _jump354:;
    int64_t _449 = 0;
    _449 *= _442.d0;
    _449 += d.d0;
    _449 *= _442.d1;
    _449 += d.d0;
    bool _450 = _442.data[_449];
    bool _441 = _450;
    if (0 == _450)
    goto _jump355;
    bool _452 = true;
    bool _451 = _452;
    if (0 == _452)
    goto _jump356;
    bool _453 = false;
    bool _454 = !_453;
    _451 = _454;
    _jump356:;
    double _455 = 73.0;
    double _456 = -_455;
    double _457 = 77.0;
    bool _458 = _456 != _457;
    bool _459 = _451 == _458;
    _441 = _459;
    _jump355:;
    _437 = _441;
    _jump347:;
    _a2__a3_int64_t _460;
    if (!_437)
    goto _jump357;
    int64_t _461 = 375;
    bool _462 = c == _461;
    bool _463 = !_462;
    _a2__a3_int64_t _464;
    if (!_463)
    goto _jump358;
    _a2__a3_int64_t _465;
    // Computing bound for h
    int64_t _466 = 285;
    int64_t _467 = -_466;
    int64_t _468 = f.a;
    int64_t _469 = _467 * _468;
    _465.d0 = _469;
    if (_469 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    // Computing bound for i
    int64_t _470;
    // Computing bound for h
    int64_t _471 = 355;
    if (_471 > 0) 
    goto _jump360;
    fail_assertion("non-positive loop bound");
    _jump360:;
    _470 = 0;
    int64_t _472 = 0; // h
    _jump361:; // Begin body of loop
    _470 += d.d0;
    _472++;
    if (_472 < _471)
    goto _jump361;
    // End body of loop
    _465.d1 = _470;
    if (_470 > 0) 
    goto _jump362;
    fail_assertion("non-positive loop bound");
    _jump362:;
    // Computing total size of heap memory to allocate
    int64_t _473 = 1;
    _473 *= _469;
    _473 *= _470;
    _473 *= sizeof(_a3_int64_t);
    _465.data = jpl_alloc(_473);
    int64_t _474 = 0; // i
    int64_t _475 = 0; // h
    _jump363:; // Begin body of loop
    int64_t _476 = 0;
    _476 *= _465.d0;
    _476 += _475;
    _476 *= _465.d1;
    _476 += _474;
    _465.data[_476] = _162;
    _474++;
    if (_474 < _470)
    goto _jump363;
    _474 = 0;
    _475++;
    if (_475 < _469)
    goto _jump363;
    // End body of loop
    _464 = _465;
    goto _jump364;
    _jump358:;
    bool _477 = false;
    _a2__a3_int64_t _478;
    if (!_477)
    goto _jump365;
    _a2__a3_int64_t _479;
    // Computing bound for h
    int64_t _480;
    // Computing bound for h
    int64_t _481 = c - c;
    if (_481 > 0) 
    goto _jump366;
    fail_assertion("non-positive loop bound");
    _jump366:;
    // Computing bound for i
    bool _482 = true;
    int64_t _483;
    if (!_482)
    goto _jump367;
    _483 = d.d0;
    goto _jump368;
    _jump367:;
    _483 = c;
    _jump368:;
    if (_483 > 0) 
    goto _jump369;
    fail_assertion("non-positive loop bound");
    _jump369:;
    _480 = 0;
    int64_t _484 = 0; // i
    int64_t _485 = 0; // h
    _jump370:; // Begin body of loop
    _480 += _484;
    _484++;
    if (_484 < _483)
    goto _jump370;
    _484 = 0;
    _485++;
    if (_485 < _481)
    goto _jump370;
    // End body of loop
    _479.d0 = _480;
    if (_480 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing bound for i
    int64_t _486;
    // Computing bound for h
    int64_t _487;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    _487 = 0;
    int64_t _488 = 0; // h
    _jump373:; // Begin body of loop
    _487 += c;
    _488++;
    if (_488 < d.d0)
    goto _jump373;
    // End body of loop
    if (_487 > 0) 
    goto _jump374;
    fail_assertion("non-positive loop bound");
    _jump374:;
    // Computing bound for i
    if (c > 0) 
    goto _jump375;
    fail_assertion("non-positive loop bound");
    _jump375:;
    // Computing bound for j
    int64_t _489 = 595;
    int64_t _490 = _489 / d.d0;
    if (_490 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    _486 = 0;
    int64_t _491 = 0; // j
    int64_t _492 = 0; // i
    int64_t _493 = 0; // h
    _jump377:; // Begin body of loop
    _486 += _492;
    _491++;
    if (_491 < _490)
    goto _jump377;
    _491 = 0;
    _492++;
    if (_492 < c)
    goto _jump377;
    _492 = 0;
    _493++;
    if (_493 < _487)
    goto _jump377;
    // End body of loop
    _479.d1 = _486;
    if (_486 > 0) 
    goto _jump378;
    fail_assertion("non-positive loop bound");
    _jump378:;
    // Computing total size of heap memory to allocate
    int64_t _494 = 1;
    _494 *= _480;
    _494 *= _486;
    _494 *= sizeof(_a3_int64_t);
    _479.data = jpl_alloc(_494);
    int64_t _495 = 0; // i
    int64_t _496 = 0; // h
    _jump379:; // Begin body of loop
    _a2__a3_int64_t _497;
    // Computing bound for j
    _497.d0 = _495;
    if (_495 > 0) 
    goto _jump380;
    fail_assertion("non-positive loop bound");
    _jump380:;
    // Computing bound for k
    _497.d1 = _495;
    if (_495 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing total size of heap memory to allocate
    int64_t _498 = 1;
    _498 *= _495;
    _498 *= _495;
    _498 *= sizeof(_a3_int64_t);
    _497.data = jpl_alloc(_498);
    int64_t _499 = 0; // k
    int64_t _500 = 0; // j
    _jump382:; // Begin body of loop
    int64_t _501 = 0;
    _501 *= _497.d0;
    _501 += _500;
    _501 *= _497.d1;
    _501 += _499;
    _497.data[_501] = _162;
    _499++;
    if (_499 < _495)
    goto _jump382;
    _499 = 0;
    _500++;
    if (_500 < _495)
    goto _jump382;
    // End body of loop
    int64_t _502;
    // Computing bound for j
    if (d.d0 > 0) 
    goto _jump383;
    fail_assertion("non-positive loop bound");
    _jump383:;
    // Computing bound for k
    if (_495 > 0) 
    goto _jump384;
    fail_assertion("non-positive loop bound");
    _jump384:;
    _502 = 0;
    int64_t _503 = 0; // k
    int64_t _504 = 0; // j
    _jump385:; // Begin body of loop
    _502 += c;
    _503++;
    if (_503 < _495)
    goto _jump385;
    _503 = 0;
    _504++;
    if (_504 < d.d0)
    goto _jump385;
    // End body of loop
    int64_t _505 = 896;
    if (_502 >= 0)
    goto _jump386;
    fail_assertion("negative array index");
    _jump386:;
    if (_502 < _497.d0)
    goto _jump387;
    fail_assertion("index too large");
    _jump387:;
    if (_505 >= 0)
    goto _jump388;
    fail_assertion("negative array index");
    _jump388:;
    if (_505 < _497.d1)
    goto _jump389;
    fail_assertion("index too large");
    _jump389:;
    int64_t _506 = 0;
    _506 *= _497.d0;
    _506 += _502;
    _506 *= _497.d1;
    _506 += _505;
    _a3_int64_t _507 = _497.data[_506];
    int64_t _508 = 0;
    _508 *= _479.d0;
    _508 += _496;
    _508 *= _479.d1;
    _508 += _495;
    _479.data[_508] = _507;
    _495++;
    if (_495 < _486)
    goto _jump379;
    _495 = 0;
    _496++;
    if (_496 < _480)
    goto _jump379;
    // End body of loop
    _478 = _479;
    goto _jump390;
    _jump365:;
    _a2__a3_int64_t _509;
    // Computing bound for h
    _509.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for i
    int64_t _510 = 131;
    int64_t _511 = d.d0 + c;
    int64_t _512 = _510 % _511;
    _509.d1 = _512;
    if (_512 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing total size of heap memory to allocate
    int64_t _513 = 1;
    _513 *= d.d0;
    _513 *= _512;
    _513 *= sizeof(_a3_int64_t);
    _509.data = jpl_alloc(_513);
    int64_t _514 = 0; // i
    int64_t _515 = 0; // h
    _jump393:; // Begin body of loop
    bool _516 = true;
    _a3_int64_t _517;
    if (!_516)
    goto _jump394;
    bool _518 = false;
    _a3_int64_t _519;
    if (!_518)
    goto _jump395;
    _519 = _162;
    goto _jump396;
    _jump395:;
    _519 = _162;
    _jump396:;
    _517 = _519;
    goto _jump397;
    _jump394:;
    _a3_int64_t _520;
    // Computing bound for j
    _520.d0 = _514;
    if (_514 > 0) 
    goto _jump398;
    fail_assertion("non-positive loop bound");
    _jump398:;
    // Computing bound for k
    _520.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump399;
    fail_assertion("non-positive loop bound");
    _jump399:;
    // Computing bound for l
    _520.d2 = _515;
    if (_515 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing total size of heap memory to allocate
    int64_t _521 = 1;
    _521 *= _514;
    _521 *= d.d0;
    _521 *= _515;
    _521 *= sizeof(int64_t);
    _520.data = jpl_alloc(_521);
    int64_t _522 = 0; // l
    int64_t _523 = 0; // k
    int64_t _524 = 0; // j
    _jump401:; // Begin body of loop
    int64_t _525 = 0;
    _525 *= _520.d0;
    _525 += _524;
    _525 *= _520.d1;
    _525 += _523;
    _525 *= _520.d2;
    _525 += _522;
    _520.data[_525] = _514;
    _522++;
    if (_522 < _515)
    goto _jump401;
    _522 = 0;
    _523++;
    if (_523 < d.d0)
    goto _jump401;
    _523 = 0;
    _524++;
    if (_524 < _514)
    goto _jump401;
    // End body of loop
    _517 = _520;
    _jump397:;
    int64_t _526 = 0;
    _526 *= _509.d0;
    _526 += _515;
    _526 *= _509.d1;
    _526 += _514;
    _509.data[_526] = _517;
    _514++;
    if (_514 < _512)
    goto _jump393;
    _514 = 0;
    _515++;
    if (_515 < d.d0)
    goto _jump393;
    // End body of loop
    _478 = _509;
    _jump390:;
    _464 = _478;
    _jump364:;
    _460 = _464;
    goto _jump402;
    _jump357:;
    _a2__a3_int64_t _527;
    // Computing bound for h
    int64_t _528;
    // Computing bound for h
    if (c > 0) 
    goto _jump403;
    fail_assertion("non-positive loop bound");
    _jump403:;
    // Computing bound for i
    int64_t _529 = 661;
    if (_529 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    _528 = 0;
    int64_t _530 = 0; // i
    int64_t _531 = 0; // h
    _jump405:; // Begin body of loop
    _528 += c;
    _530++;
    if (_530 < _529)
    goto _jump405;
    _530 = 0;
    _531++;
    if (_531 < c)
    goto _jump405;
    // End body of loop
    _527.d0 = _528;
    if (_528 > 0) 
    goto _jump406;
    fail_assertion("non-positive loop bound");
    _jump406:;
    // Computing bound for i
    int64_t _532 = f.a;
    _a1_int64_t _533;
    // Computing bound for h
    _533.d0 = c;
    if (c > 0) 
    goto _jump407;
    fail_assertion("non-positive loop bound");
    _jump407:;
    // Computing total size of heap memory to allocate
    int64_t _534 = 1;
    _534 *= c;
    _534 *= sizeof(int64_t);
    _533.data = jpl_alloc(_534);
    int64_t _535 = 0; // h
    _jump408:; // Begin body of loop
    int64_t _536 = 0;
    _536 *= _533.d0;
    _536 += _535;
    _533.data[_536] = c;
    _535++;
    if (_535 < c)
    goto _jump408;
    // End body of loop
    a _537 = b(_532, _533, f);
    int64_t _538 = _537.a;
    _527.d1 = _538;
    if (_538 > 0) 
    goto _jump409;
    fail_assertion("non-positive loop bound");
    _jump409:;
    // Computing total size of heap memory to allocate
    int64_t _539 = 1;
    _539 *= _528;
    _539 *= _538;
    _539 *= sizeof(_a3_int64_t);
    _527.data = jpl_alloc(_539);
    int64_t _540 = 0; // i
    int64_t _541 = 0; // h
    _jump410:; // Begin body of loop
    double _542 = 53.0;
    double _543 = 73.0;
    double _544 = -_543;
    bool _545 = _542 == _544;
    _a3_int64_t _546;
    if (!_545)
    goto _jump411;
    bool _547 = false;
    _a3_int64_t _548;
    if (!_547)
    goto _jump412;
    _a3_int64_t _549;
    // Computing bound for j
    int64_t _550 = f.a;
    _549.d0 = _550;
    if (_550 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing bound for k
    int64_t _551;
    // Computing bound for j
    int64_t _552 = 941;
    if (_552 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    // Computing bound for k
    if (c > 0) 
    goto _jump415;
    fail_assertion("non-positive loop bound");
    _jump415:;
    // Computing bound for l
    if (c > 0) 
    goto _jump416;
    fail_assertion("non-positive loop bound");
    _jump416:;
    _551 = 0;
    int64_t _553 = 0; // l
    int64_t _554 = 0; // k
    int64_t _555 = 0; // j
    _jump417:; // Begin body of loop
    _551 += _540;
    _553++;
    if (_553 < c)
    goto _jump417;
    _553 = 0;
    _554++;
    if (_554 < c)
    goto _jump417;
    _554 = 0;
    _555++;
    if (_555 < _552)
    goto _jump417;
    // End body of loop
    _549.d1 = _551;
    if (_551 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing bound for l
    int64_t _556 = 183;
    _549.d2 = _556;
    if (_556 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    // Computing total size of heap memory to allocate
    int64_t _557 = 1;
    _557 *= _550;
    _557 *= _551;
    _557 *= _556;
    _557 *= sizeof(int64_t);
    _549.data = jpl_alloc(_557);
    int64_t _558 = 0; // l
    int64_t _559 = 0; // k
    int64_t _560 = 0; // j
    _jump420:; // Begin body of loop
    int64_t _561 = 0;
    _561 *= _549.d0;
    _561 += _560;
    _561 *= _549.d1;
    _561 += _559;
    _561 *= _549.d2;
    _561 += _558;
    _549.data[_561] = _558;
    _558++;
    if (_558 < _556)
    goto _jump420;
    _558 = 0;
    _559++;
    if (_559 < _551)
    goto _jump420;
    _559 = 0;
    _560++;
    if (_560 < _550)
    goto _jump420;
    // End body of loop
    _548 = _549;
    goto _jump421;
    _jump412:;
    _a3_int64_t _562;
    // Computing bound for j
    _562.d0 = c;
    if (c > 0) 
    goto _jump422;
    fail_assertion("non-positive loop bound");
    _jump422:;
    // Computing bound for k
    int64_t _563 = 136;
    _562.d1 = _563;
    if (_563 > 0) 
    goto _jump423;
    fail_assertion("non-positive loop bound");
    _jump423:;
    // Computing bound for l
    int64_t _564 = 619;
    int64_t _565 = d.d0 % _564;
    _562.d2 = _565;
    if (_565 > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing total size of heap memory to allocate
    int64_t _566 = 1;
    _566 *= c;
    _566 *= _563;
    _566 *= _565;
    _566 *= sizeof(int64_t);
    _562.data = jpl_alloc(_566);
    int64_t _567 = 0; // l
    int64_t _568 = 0; // k
    int64_t _569 = 0; // j
    _jump425:; // Begin body of loop
    int64_t _570 = 0;
    _570 *= _562.d0;
    _570 += _569;
    _570 *= _562.d1;
    _570 += _568;
    _570 *= _562.d2;
    _570 += _567;
    _562.data[_570] = _541;
    _567++;
    if (_567 < _565)
    goto _jump425;
    _567 = 0;
    _568++;
    if (_568 < _563)
    goto _jump425;
    _568 = 0;
    _569++;
    if (_569 < c)
    goto _jump425;
    // End body of loop
    _548 = _562;
    _jump421:;
    _546 = _548;
    goto _jump426;
    _jump411:;
    bool _572 = false;
    bool _571 = _572;
    if (0 != _572)
    goto _jump427;
    bool _573 = true;
    _571 = _573;
    _jump427:;
    bool _574;
    if (!_571)
    goto _jump428;
    bool _575 = false;
    _574 = _575;
    goto _jump429;
    _jump428:;
    bool _576 = false;
    bool _577 = !_576;
    _574 = _577;
    _jump429:;
    _a3_int64_t _578;
    if (!_574)
    goto _jump430;
    _578 = _162;
    goto _jump431;
    _jump430:;
    _578 = _162;
    _jump431:;
    _546 = _578;
    _jump426:;
    int64_t _579 = 0;
    _579 *= _527.d0;
    _579 += _541;
    _579 *= _527.d1;
    _579 += _540;
    _527.data[_579] = _546;
    _540++;
    if (_540 < _538)
    goto _jump410;
    _540 = 0;
    _541++;
    if (_541 < _528)
    goto _jump410;
    // End body of loop
    _460 = _527;
    _jump402:;
    _436 = _460;
    goto _jump432;
    _jump346:;
    bool _580 = true;
    _a2__a3_int64_t _581;
    if (!_580)
    goto _jump433;
    _a2__a3_int64_t _582;
    // Computing bound for h
    bool _583 = false;
    bool _584 = !_583;
    bool _585 = !_584;
    bool _586 = false;
    bool _587 = _585 == _586;
    int64_t _588;
    if (!_587)
    goto _jump434;
    int64_t _589 = -d.d0;
    int64_t _590 = -_589;
    int64_t _591;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump435;
    fail_assertion("non-positive loop bound");
    _jump435:;
    _591 = 0;
    int64_t _592 = 0; // h
    _jump436:; // Begin body of loop
    _591 += d.d0;
    _592++;
    if (_592 < d.d0)
    goto _jump436;
    // End body of loop
    int64_t _593 = _590 + _591;
    _588 = _593;
    goto _jump437;
    _jump434:;
    int64_t _594 = -c;
    if (c >= 0)
    goto _jump438;
    fail_assertion("negative array index");
    _jump438:;
    if (c < d.d0)
    goto _jump439;
    fail_assertion("index too large");
    _jump439:;
    int64_t _595 = 0;
    _595 *= d.d0;
    _595 += c;
    int64_t _596 = d.data[_595];
    int64_t _597 = -_596;
    if (_594 >= 0)
    goto _jump440;
    fail_assertion("negative array index");
    _jump440:;
    if (_594 < _162.d0)
    goto _jump441;
    fail_assertion("index too large");
    _jump441:;
    if (d.d0 >= 0)
    goto _jump442;
    fail_assertion("negative array index");
    _jump442:;
    if (d.d0 < _162.d1)
    goto _jump443;
    fail_assertion("index too large");
    _jump443:;
    if (_597 >= 0)
    goto _jump444;
    fail_assertion("negative array index");
    _jump444:;
    if (_597 < _162.d2)
    goto _jump445;
    fail_assertion("index too large");
    _jump445:;
    int64_t _598 = 0;
    _598 *= _162.d0;
    _598 += _594;
    _598 *= _162.d1;
    _598 += d.d0;
    _598 *= _162.d2;
    _598 += _597;
    int64_t _599 = _162.data[_598];
    _588 = _599;
    _jump437:;
    _582.d0 = _588;
    if (_588 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing bound for i
    int64_t _600 = 315;
    bool _601 = d.d0 >= _600;
    int64_t _602;
    if (!_601)
    goto _jump447;
    int64_t _603 = 791;
    int64_t _604 = -_603;
    _602 = _604;
    goto _jump448;
    _jump447:;
    int64_t _605;
    // Computing bound for h
    if (d.d0 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for i
    int64_t _606 = 981;
    if (_606 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    _605 = 0;
    int64_t _607 = 0; // i
    int64_t _608 = 0; // h
    _jump451:; // Begin body of loop
    _605 += d.d0;
    _607++;
    if (_607 < _606)
    goto _jump451;
    _607 = 0;
    _608++;
    if (_608 < d.d0)
    goto _jump451;
    // End body of loop
    if (_605 >= 0)
    goto _jump452;
    fail_assertion("negative array index");
    _jump452:;
    if (_605 < d.d0)
    goto _jump453;
    fail_assertion("index too large");
    _jump453:;
    int64_t _609 = 0;
    _609 *= d.d0;
    _609 += _605;
    int64_t _610 = d.data[_609];
    _602 = _610;
    _jump448:;
    int64_t _611 = d.d0 / _602;
    _582.d1 = _611;
    if (_611 > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    // Computing total size of heap memory to allocate
    int64_t _612 = 1;
    _612 *= _588;
    _612 *= _611;
    _612 *= sizeof(_a3_int64_t);
    _582.data = jpl_alloc(_612);
    int64_t _613 = 0; // i
    int64_t _614 = 0; // h
    _jump455:; // Begin body of loop
    _a2__a3_int64_t _615;
    // Computing bound for j
    int64_t _616 = d.d0 - c;
    int64_t _617 = c - _616;
    _615.d0 = _617;
    if (_617 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing bound for k
    int64_t _618 = f.a;
    _615.d1 = _618;
    if (_618 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    // Computing total size of heap memory to allocate
    int64_t _619 = 1;
    _619 *= _617;
    _619 *= _618;
    _619 *= sizeof(_a3_int64_t);
    _615.data = jpl_alloc(_619);
    int64_t _620 = 0; // k
    int64_t _621 = 0; // j
    _jump458:; // Begin body of loop
    bool _622 = _621 <= _620;
    _a3_int64_t _623;
    if (!_622)
    goto _jump459;
    _623 = _162;
    goto _jump460;
    _jump459:;
    _a3_int64_t _624;
    // Computing bound for l
    _624.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump461;
    fail_assertion("non-positive loop bound");
    _jump461:;
    // Computing bound for m
    _624.d1 = _621;
    if (_621 > 0) 
    goto _jump462;
    fail_assertion("non-positive loop bound");
    _jump462:;
    // Computing bound for n
    _624.d2 = c;
    if (c > 0) 
    goto _jump463;
    fail_assertion("non-positive loop bound");
    _jump463:;
    // Computing total size of heap memory to allocate
    int64_t _625 = 1;
    _625 *= d.d0;
    _625 *= _621;
    _625 *= c;
    _625 *= sizeof(int64_t);
    _624.data = jpl_alloc(_625);
    int64_t _626 = 0; // n
    int64_t _627 = 0; // m
    int64_t _628 = 0; // l
    _jump464:; // Begin body of loop
    int64_t _629 = 0;
    _629 *= _624.d0;
    _629 += _628;
    _629 *= _624.d1;
    _629 += _627;
    _629 *= _624.d2;
    _629 += _626;
    _624.data[_629] = _627;
    _626++;
    if (_626 < c)
    goto _jump464;
    _626 = 0;
    _627++;
    if (_627 < _621)
    goto _jump464;
    _627 = 0;
    _628++;
    if (_628 < d.d0)
    goto _jump464;
    // End body of loop
    _623 = _624;
    _jump460:;
    int64_t _630 = 0;
    _630 *= _615.d0;
    _630 += _621;
    _630 *= _615.d1;
    _630 += _620;
    _615.data[_630] = _623;
    _620++;
    if (_620 < _618)
    goto _jump458;
    _620 = 0;
    _621++;
    if (_621 < _617)
    goto _jump458;
    // End body of loop
    int64_t _631 = 764;
    int64_t _632 = -_631;
    if (_632 >= 0)
    goto _jump465;
    fail_assertion("negative array index");
    _jump465:;
    if (_632 < _615.d0)
    goto _jump466;
    fail_assertion("index too large");
    _jump466:;
    if (d.d0 >= 0)
    goto _jump467;
    fail_assertion("negative array index");
    _jump467:;
    if (d.d0 < _615.d1)
    goto _jump468;
    fail_assertion("index too large");
    _jump468:;
    int64_t _633 = 0;
    _633 *= _615.d0;
    _633 += _632;
    _633 *= _615.d1;
    _633 += d.d0;
    _a3_int64_t _634 = _615.data[_633];
    int64_t _635 = 0;
    _635 *= _582.d0;
    _635 += _614;
    _635 *= _582.d1;
    _635 += _613;
    _582.data[_635] = _634;
    _613++;
    if (_613 < _611)
    goto _jump455;
    _613 = 0;
    _614++;
    if (_614 < _588)
    goto _jump455;
    // End body of loop
    _581 = _582;
    goto _jump469;
    _jump433:;
    _a2__a3_int64_t _636;
    // Computing bound for h
    _a2__a3_int64_t _637;
    // Computing bound for h
    bool _638 = true;
    int64_t _639;
    if (!_638)
    goto _jump470;
    _639 = d.d0;
    goto _jump471;
    _jump470:;
    int64_t _640 = 751;
    _639 = _640;
    _jump471:;
    _637.d0 = _639;
    if (_639 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for i
    _637.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    // Computing total size of heap memory to allocate
    int64_t _641 = 1;
    _641 *= _639;
    _641 *= d.d0;
    _641 *= sizeof(_a3_int64_t);
    _637.data = jpl_alloc(_641);
    int64_t _642 = 0; // i
    int64_t _643 = 0; // h
    _jump474:; // Begin body of loop
    _a3_int64_t _644;
    // Computing bound for j
    _644.d0 = c;
    if (c > 0) 
    goto _jump475;
    fail_assertion("non-positive loop bound");
    _jump475:;
    // Computing bound for k
    _644.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump476;
    fail_assertion("non-positive loop bound");
    _jump476:;
    // Computing bound for l
    _644.d2 = _642;
    if (_642 > 0) 
    goto _jump477;
    fail_assertion("non-positive loop bound");
    _jump477:;
    // Computing total size of heap memory to allocate
    int64_t _645 = 1;
    _645 *= c;
    _645 *= d.d0;
    _645 *= _642;
    _645 *= sizeof(int64_t);
    _644.data = jpl_alloc(_645);
    int64_t _646 = 0; // l
    int64_t _647 = 0; // k
    int64_t _648 = 0; // j
    _jump478:; // Begin body of loop
    int64_t _649 = 408;
    int64_t _650 = 0;
    _650 *= _644.d0;
    _650 += _648;
    _650 *= _644.d1;
    _650 += _647;
    _650 *= _644.d2;
    _650 += _646;
    _644.data[_650] = _649;
    _646++;
    if (_646 < _642)
    goto _jump478;
    _646 = 0;
    _647++;
    if (_647 < d.d0)
    goto _jump478;
    _647 = 0;
    _648++;
    if (_648 < c)
    goto _jump478;
    // End body of loop
    int64_t _651 = 0;
    _651 *= _637.d0;
    _651 += _643;
    _651 *= _637.d1;
    _651 += _642;
    _637.data[_651] = _644;
    _642++;
    if (_642 < d.d0)
    goto _jump474;
    _642 = 0;
    _643++;
    if (_643 < _639)
    goto _jump474;
    // End body of loop
    int64_t _652 = -d.d0;
    int64_t _653 = d.d0 + d.d0;
    if (c >= 0)
    goto _jump479;
    fail_assertion("negative array index");
    _jump479:;
    if (c < _162.d0)
    goto _jump480;
    fail_assertion("index too large");
    _jump480:;
    if (_652 >= 0)
    goto _jump481;
    fail_assertion("negative array index");
    _jump481:;
    if (_652 < _162.d1)
    goto _jump482;
    fail_assertion("index too large");
    _jump482:;
    if (_653 >= 0)
    goto _jump483;
    fail_assertion("negative array index");
    _jump483:;
    if (_653 < _162.d2)
    goto _jump484;
    fail_assertion("index too large");
    _jump484:;
    int64_t _654 = 0;
    _654 *= _162.d0;
    _654 += c;
    _654 *= _162.d1;
    _654 += _652;
    _654 *= _162.d2;
    _654 += _653;
    int64_t _655 = _162.data[_654];
    bool _656 = true;
    int64_t _657;
    if (!_656)
    goto _jump485;
    _657 = c;
    goto _jump486;
    _jump485:;
    int64_t _658 = 308;
    int64_t _659 = 818;
    int64_t _660 = _658 % _659;
    _657 = _660;
    _jump486:;
    if (_655 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_655 < _637.d0)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (_657 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_657 < _637.d1)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _661 = 0;
    _661 *= _637.d0;
    _661 += _655;
    _661 *= _637.d1;
    _661 += _657;
    _a3_int64_t _662 = _637.data[_661];
    int64_t _663 = f.a;
    int64_t _664 = f.a;
    int64_t _665 = 254;
    int64_t _666 = d.d0 / _665;
    int64_t _667 = -_666;
    int64_t _668 = -c;
    int64_t _669 = _667 - _668;
    if (_663 >= 0)
    goto _jump491;
    fail_assertion("negative array index");
    _jump491:;
    if (_663 < _662.d0)
    goto _jump492;
    fail_assertion("index too large");
    _jump492:;
    if (_664 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_664 < _662.d1)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    if (_669 >= 0)
    goto _jump495;
    fail_assertion("negative array index");
    _jump495:;
    if (_669 < _662.d2)
    goto _jump496;
    fail_assertion("index too large");
    _jump496:;
    int64_t _670 = 0;
    _670 *= _662.d0;
    _670 += _663;
    _670 *= _662.d1;
    _670 += _664;
    _670 *= _662.d2;
    _670 += _669;
    int64_t _671 = _662.data[_670];
    _636.d0 = _671;
    if (_671 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing bound for i
    _636.d1 = d.d0;
    if (d.d0 > 0) 
    goto _jump498;
    fail_assertion("non-positive loop bound");
    _jump498:;
    // Computing total size of heap memory to allocate
    int64_t _672 = 1;
    _672 *= _671;
    _672 *= d.d0;
    _672 *= sizeof(_a3_int64_t);
    _636.data = jpl_alloc(_672);
    int64_t _673 = 0; // i
    int64_t _674 = 0; // h
    _jump499:; // Begin body of loop
    _a3_int64_t _675;
    // Computing bound for j
    _675.d0 = _673;
    if (_673 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    // Computing bound for k
    bool _676 = false;
    int64_t _677;
    if (!_676)
    goto _jump501;
    int64_t _678 = 337;
    _677 = _678;
    goto _jump502;
    _jump501:;
    int64_t _679 = 853;
    _677 = _679;
    _jump502:;
    _675.d1 = _677;
    if (_677 > 0) 
    goto _jump503;
    fail_assertion("non-positive loop bound");
    _jump503:;
    // Computing bound for l
    _675.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump504;
    fail_assertion("non-positive loop bound");
    _jump504:;
    // Computing total size of heap memory to allocate
    int64_t _680 = 1;
    _680 *= _673;
    _680 *= _677;
    _680 *= d.d0;
    _680 *= sizeof(int64_t);
    _675.data = jpl_alloc(_680);
    int64_t _681 = 0; // l
    int64_t _682 = 0; // k
    int64_t _683 = 0; // j
    _jump505:; // Begin body of loop
    int64_t _684 = 0;
    _684 *= _675.d0;
    _684 += _683;
    _684 *= _675.d1;
    _684 += _682;
    _684 *= _675.d2;
    _684 += _681;
    _675.data[_684] = _683;
    _681++;
    if (_681 < d.d0)
    goto _jump505;
    _681 = 0;
    _682++;
    if (_682 < _677)
    goto _jump505;
    _682 = 0;
    _683++;
    if (_683 < _673)
    goto _jump505;
    // End body of loop
    int64_t _685 = 0;
    _685 *= _636.d0;
    _685 += _674;
    _685 *= _636.d1;
    _685 += _673;
    _636.data[_685] = _675;
    _673++;
    if (_673 < d.d0)
    goto _jump499;
    _673 = 0;
    _674++;
    if (_674 < _671)
    goto _jump499;
    // End body of loop
    _581 = _636;
    _jump469:;
    _436 = _581;
    _jump432:;
    _a2__a1_bool _686;
    // Computing bound for k
    int64_t _687 = d.d0 / _436.d1;
    _686.d0 = _687;
    if (_687 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    // Computing bound for l
    _686.d1 = c;
    if (c > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing total size of heap memory to allocate
    int64_t _688 = 1;
    _688 *= _687;
    _688 *= c;
    _688 *= sizeof(_a1_bool);
    _686.data = jpl_alloc(_688);
    int64_t _689 = 0; // l
    int64_t _690 = 0; // k
    _jump508:; // Begin body of loop
    _a1_bool _691;
    // Computing bound for m
    _691.d0 = d.d0;
    if (d.d0 > 0) 
    goto _jump509;
    fail_assertion("non-positive loop bound");
    _jump509:;
    // Computing total size of heap memory to allocate
    int64_t _692 = 1;
    _692 *= d.d0;
    _692 *= sizeof(bool);
    _691.data = jpl_alloc(_692);
    int64_t _693 = 0; // m
    _jump510:; // Begin body of loop
    bool _694 = false;
    bool _695 = !_694;
    int64_t _696 = 0;
    _696 *= _691.d0;
    _696 += _693;
    _691.data[_696] = _695;
    _693++;
    if (_693 < d.d0)
    goto _jump510;
    // End body of loop
    int64_t _697 = 0;
    _697 *= _686.d0;
    _697 += _690;
    _697 *= _686.d1;
    _697 += _689;
    _686.data[_697] = _691;
    _689++;
    if (_689 < c)
    goto _jump508;
    _689 = 0;
    _690++;
    if (_690 < _687)
    goto _jump508;
    // End body of loop
    int64_t _698 = 715;
    int64_t _699 = f.a;
    if (_698 >= 0)
    goto _jump511;
    fail_assertion("negative array index");
    _jump511:;
    if (_698 < _686.d0)
    goto _jump512;
    fail_assertion("index too large");
    _jump512:;
    if (_699 >= 0)
    goto _jump513;
    fail_assertion("negative array index");
    _jump513:;
    if (_699 < _686.d1)
    goto _jump514;
    fail_assertion("index too large");
    _jump514:;
    int64_t _700 = 0;
    _700 *= _686.d0;
    _700 += _698;
    _700 *= _686.d1;
    _700 += _699;
    _a1_bool _701 = _686.data[_700];
    _a3_int64_t _702;
    // Computing bound for k
    _702.d0 = _436.d1;
    if (_436.d1 > 0) 
    goto _jump515;
    fail_assertion("non-positive loop bound");
    _jump515:;
    // Computing bound for l
    int64_t _703 = -_436.d0;
    _702.d1 = _703;
    if (_703 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for m
    _702.d2 = d.d0;
    if (d.d0 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing total size of heap memory to allocate
    int64_t _704 = 1;
    _704 *= _436.d1;
    _704 *= _703;
    _704 *= d.d0;
    _704 *= sizeof(int64_t);
    _702.data = jpl_alloc(_704);
    int64_t _705 = 0; // m
    int64_t _706 = 0; // l
    int64_t _707 = 0; // k
    _jump518:; // Begin body of loop
    bool _708 = false;
    int64_t _709;
    if (!_708)
    goto _jump519;
    int64_t _710 = 114;
    _709 = _710;
    goto _jump520;
    _jump519:;
    _709 = c;
    _jump520:;
    int64_t _711 = 0;
    _711 *= _702.d0;
    _711 += _707;
    _711 *= _702.d1;
    _711 += _706;
    _711 *= _702.d2;
    _711 += _705;
    _702.data[_711] = _709;
    _705++;
    if (_705 < d.d0)
    goto _jump518;
    _705 = 0;
    _706++;
    if (_706 < _703)
    goto _jump518;
    _706 = 0;
    _707++;
    if (_707 < _436.d1)
    goto _jump518;
    // End body of loop
    if (c >= 0)
    goto _jump521;
    fail_assertion("negative array index");
    _jump521:;
    if (c < _702.d0)
    goto _jump522;
    fail_assertion("index too large");
    _jump522:;
    if (_436.d1 >= 0)
    goto _jump523;
    fail_assertion("negative array index");
    _jump523:;
    if (_436.d1 < _702.d1)
    goto _jump524;
    fail_assertion("index too large");
    _jump524:;
    if (c >= 0)
    goto _jump525;
    fail_assertion("negative array index");
    _jump525:;
    if (c < _702.d2)
    goto _jump526;
    fail_assertion("index too large");
    _jump526:;
    int64_t _712 = 0;
    _712 *= _702.d0;
    _712 += c;
    _712 *= _702.d1;
    _712 += _436.d1;
    _712 *= _702.d2;
    _712 += c;
    int64_t _713 = _702.data[_712];
    if (_713 >= 0)
    goto _jump527;
    fail_assertion("negative array index");
    _jump527:;
    if (_713 < _162.d0)
    goto _jump528;
    fail_assertion("index too large");
    _jump528:;
    if (_436.d0 >= 0)
    goto _jump529;
    fail_assertion("negative array index");
    _jump529:;
    if (_436.d0 < _162.d1)
    goto _jump530;
    fail_assertion("index too large");
    _jump530:;
    if (d.d0 >= 0)
    goto _jump531;
    fail_assertion("negative array index");
    _jump531:;
    if (d.d0 < _162.d2)
    goto _jump532;
    fail_assertion("index too large");
    _jump532:;
    int64_t _714 = 0;
    _714 *= _162.d0;
    _714 += _713;
    _714 *= _162.d1;
    _714 += _436.d0;
    _714 *= _162.d2;
    _714 += d.d0;
    int64_t _715 = _162.data[_714];
    if (_715 >= 0)
    goto _jump533;
    fail_assertion("negative array index");
    _jump533:;
    if (_715 < _701.d0)
    goto _jump534;
    fail_assertion("index too large");
    _jump534:;
    int64_t _716 = 0;
    _716 *= _701.d0;
    _716 += _715;
    bool _717 = _701.data[_716];
    bool _718;
    if (!_717)
    goto _jump535;
    int64_t _719 = 426;
    int64_t _720 = -_436.d0;
    int64_t _721 = _720 / _436.d0;
    int64_t _722 = -_721;
    bool _723 = _719 > _722;
    _718 = _723;
    goto _jump536;
    _jump535:;
    double _724 = 53.0;
    double _725 = -_724;
    _a2_bool _726;
    // Computing bound for k
    int64_t _727 = 721;
    _726.d0 = _727;
    if (_727 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for l
    _726.d1 = c;
    if (c > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    // Computing total size of heap memory to allocate
    int64_t _728 = 1;
    _728 *= _727;
    _728 *= c;
    _728 *= sizeof(bool);
    _726.data = jpl_alloc(_728);
    int64_t _729 = 0; // l
    int64_t _730 = 0; // k
    _jump539:; // Begin body of loop
    bool _731 = true;
    int64_t _732 = 0;
    _732 *= _726.d0;
    _732 += _730;
    _732 *= _726.d1;
    _732 += _729;
    _726.data[_732] = _731;
    _729++;
    if (_729 < c)
    goto _jump539;
    _729 = 0;
    _730++;
    if (_730 < _727)
    goto _jump539;
    // End body of loop
    if (d.d0 >= 0)
    goto _jump540;
    fail_assertion("negative array index");
    _jump540:;
    if (d.d0 < _726.d0)
    goto _jump541;
    fail_assertion("index too large");
    _jump541:;
    if (c >= 0)
    goto _jump542;
    fail_assertion("negative array index");
    _jump542:;
    if (c < _726.d1)
    goto _jump543;
    fail_assertion("index too large");
    _jump543:;
    int64_t _733 = 0;
    _733 *= _726.d0;
    _733 += d.d0;
    _733 *= _726.d1;
    _733 += c;
    bool _734 = _726.data[_733];
    bool _735 = !_734;
    double _736;
    if (!_735)
    goto _jump544;
    double _737 = 44.0;
    bool _738 = _436.d0 != c;
    double _739;
    if (!_738)
    goto _jump545;
    double _740 = 86.0;
    double _741 = -_740;
    _739 = _741;
    goto _jump546;
    _jump545:;
    double _742 = 76.0;
    double _743 = -_742;
    _739 = _743;
    _jump546:;
    double _744 = _737 + _739;
    _736 = _744;
    goto _jump547;
    _jump544:;
    double _745 = 54.0;
    double _746 = -_745;
    _736 = _746;
    _jump547:;
    bool _747 = _725 != _736;
    _718 = _747;
    _jump536:;
    _a1_bool _748;
    if (!_718)
    goto _jump548;
    _a1_bool _749;
    // Computing bound for k
    _749.d0 = c;
    if (c > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    // Computing total size of heap memory to allocate
    int64_t _750 = 1;
    _750 *= c;
    _750 *= sizeof(bool);
    _749.data = jpl_alloc(_750);
    int64_t _751 = 0; // k
    _jump550:; // Begin body of loop
    double _752 = 9.0;
    double _753 = -_752;
    double _754 = 96.0;
    double _755 = 35.0;
    double _756 = -_755;
    double _757 = fmod(_754, _756);
    double _758 = _753 / _757;
    double _759;
    // Computing bound for l
    bool _760 = _436.d1 > _436.d1;
    int64_t _761;
    if (!_760)
    goto _jump551;
    _761 = c;
    goto _jump552;
    _jump551:;
    _761 = _436.d1;
    _jump552:;
    if (_761 > 0) 
    goto _jump553;
    fail_assertion("non-positive loop bound");
    _jump553:;
    // Computing bound for m
    if (_436.d0 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    _759 = 0;
    int64_t _762 = 0; // m
    int64_t _763 = 0; // l
    _jump555:; // Begin body of loop
    double _764 = 52.0;
    _759 += _764;
    _762++;
    if (_762 < _436.d0)
    goto _jump555;
    _762 = 0;
    _763++;
    if (_763 < _761)
    goto _jump555;
    // End body of loop
    double _765 = -_759;
    bool _766 = _758 > _765;
    int64_t _767 = 0;
    _767 *= _749.d0;
    _767 += _751;
    _749.data[_767] = _766;
    _751++;
    if (_751 < c)
    goto _jump550;
    // End body of loop
    _748 = _749;
    goto _jump556;
    _jump548:;
    _a1_bool _768;
    // Computing bound for k
    _768.d0 = c;
    if (c > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    // Computing total size of heap memory to allocate
    int64_t _769 = 1;
    _769 *= c;
    _769 *= sizeof(bool);
    _768.data = jpl_alloc(_769);
    int64_t _770 = 0; // k
    _jump558:; // Begin body of loop
    bool _772 = false;
    bool _771 = _772;
    if (0 != _772)
    goto _jump559;
    bool _775 = false;
    bool _776 = !_775;
    bool _774 = _776;
    if (0 == _776)
    goto _jump560;
    bool _777 = false;
    bool _778 = !_777;
    _774 = _778;
    _jump560:;
    bool _779;
    if (!_774)
    goto _jump561;
    bool _781 = true;
    bool _780 = _781;
    if (0 != _781)
    goto _jump562;
    bool _783 = true;
    bool _782 = _783;
    if (0 == _783)
    goto _jump563;
    bool _784 = true;
    _782 = _784;
    _jump563:;
    _780 = _782;
    _jump562:;
    _779 = _780;
    goto _jump564;
    _jump561:;
    double _785 = 47.0;
    double _786 = 13.0;
    bool _787 = _785 == _786;
    bool _788 = !_787;
    _779 = _788;
    _jump564:;
    bool _773 = _779;
    if (0 == _779)
    goto _jump565;
    int64_t _789 = -d.d0;
    bool _790 = _789 <= d.d0;
    _773 = _790;
    _jump565:;
    _771 = _773;
    _jump559:;
    int64_t _791 = 0;
    _791 *= _768.d0;
    _791 += _770;
    _768.data[_791] = _771;
    _770++;
    if (_770 < c)
    goto _jump558;
    // End body of loop
    _748 = _768;
    _jump556:;
    bool _794 = true;
    bool _793 = _794;
    if (0 != _794)
    goto _jump566;
    int64_t _795 = 156;
    bool _796 = _795 == _748.d0;
    _793 = _796;
    _jump566:;
    bool _792 = _793;
    if (0 == _793)
    goto _jump567;
    bool _797 = true;
    bool _798 = false;
    _a1_bool _799;
    _799.d0 = 2;
    _799.data = jpl_alloc(sizeof(bool) * 2);
    _799.data[0] = _797;
    _799.data[1] = _798;
    if (c >= 0)
    goto _jump568;
    fail_assertion("negative array index");
    _jump568:;
    if (c < _799.d0)
    goto _jump569;
    fail_assertion("index too large");
    _jump569:;
    int64_t _800 = 0;
    _800 *= _799.d0;
    _800 += c;
    bool _801 = _799.data[_800];
    _792 = _801;
    _jump567:;
    a _802;
    if (!_792)
    goto _jump570;
    _a1__a1_int64_t _803;
    // Computing bound for m
    int64_t _804 = 899;
    _803.d0 = _804;
    if (_804 > 0) 
    goto _jump571;
    fail_assertion("non-positive loop bound");
    _jump571:;
    // Computing total size of heap memory to allocate
    int64_t _805 = 1;
    _805 *= _804;
    _805 *= sizeof(_a1_int64_t);
    _803.data = jpl_alloc(_805);
    int64_t _806 = 0; // m
    _jump572:; // Begin body of loop
    int64_t _807 = 0;
    _807 *= _803.d0;
    _807 += _806;
    _803.data[_807] = d;
    _806++;
    if (_806 < _804)
    goto _jump572;
    // End body of loop
    if (d.d0 >= 0)
    goto _jump573;
    fail_assertion("negative array index");
    _jump573:;
    if (d.d0 < _803.d0)
    goto _jump574;
    fail_assertion("index too large");
    _jump574:;
    int64_t _808 = 0;
    _808 *= _803.d0;
    _808 += d.d0;
    _a1_int64_t _809 = _803.data[_808];
    if (d.d0 >= 0)
    goto _jump575;
    fail_assertion("negative array index");
    _jump575:;
    if (d.d0 < _809.d0)
    goto _jump576;
    fail_assertion("index too large");
    _jump576:;
    int64_t _810 = 0;
    _810 *= _809.d0;
    _810 += d.d0;
    int64_t _811 = _809.data[_810];
    _a1_int64_t _812;
    _812.d0 = 1;
    _812.data = jpl_alloc(sizeof(int64_t) * 1);
    _812.data[0] = _811;
    _a1__a1_int64_t _813;
    _813.d0 = 2;
    _813.data = jpl_alloc(sizeof(_a1_int64_t) * 2);
    _813.data[0] = d;
    _813.data[1] = d;
    int64_t _814 = -c;
    if (_814 >= 0)
    goto _jump577;
    fail_assertion("negative array index");
    _jump577:;
    if (_814 < _813.d0)
    goto _jump578;
    fail_assertion("index too large");
    _jump578:;
    int64_t _815 = 0;
    _815 *= _813.d0;
    _815 += _814;
    _a1_int64_t _816 = _813.data[_815];
    int64_t _817 = 331;
    if (_817 >= 0)
    goto _jump579;
    fail_assertion("negative array index");
    _jump579:;
    if (_817 < _816.d0)
    goto _jump580;
    fail_assertion("index too large");
    _jump580:;
    int64_t _818 = 0;
    _818 *= _816.d0;
    _818 += _817;
    int64_t _819 = _816.data[_818];
    void_t _820 = f.b;
    _a1_void_t _821;
    _821.d0 = 1;
    _821.data = jpl_alloc(sizeof(void_t) * 1);
    _821.data[0] = _820;
    if (c >= 0)
    goto _jump581;
    fail_assertion("negative array index");
    _jump581:;
    if (c < _821.d0)
    goto _jump582;
    fail_assertion("index too large");
    _jump582:;
    int64_t _822 = 0;
    _822 *= _821.d0;
    _822 += c;
    void_t _823 = _821.data[_822];
    a _824 = { _819, _823 };
    a _825 = b(c, _812, _824);
    _802 = _825;
    goto _jump583;
    _jump570:;
    bool _826 = true;
    bool _827 = true;
    bool _828 = false;
    bool _829;
    if (!_828)
    goto _jump584;
    bool _830 = true;
    _829 = _830;
    goto _jump585;
    _jump584:;
    bool _831 = true;
    _829 = _831;
    _jump585:;
    bool _832 = _827 == _829;
    bool _833 = _826 == _832;
    a _834;
    if (!_833)
    goto _jump586;
    _834 = f;
    goto _jump587;
    _jump586:;
    _a2_a _835;
    // Computing bound for m
    _835.d0 = _436.d1;
    if (_436.d1 > 0) 
    goto _jump588;
    fail_assertion("non-positive loop bound");
    _jump588:;
    // Computing bound for n
    int64_t _836;
    // Computing bound for m
    if (_436.d0 > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    _836 = 0;
    int64_t _837 = 0; // m
    _jump590:; // Begin body of loop
    int64_t _838 = 160;
    _836 += _838;
    _837++;
    if (_837 < _436.d0)
    goto _jump590;
    // End body of loop
    _835.d1 = _836;
    if (_836 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing total size of heap memory to allocate
    int64_t _839 = 1;
    _839 *= _436.d1;
    _839 *= _836;
    _839 *= sizeof(a);
    _835.data = jpl_alloc(_839);
    int64_t _840 = 0; // n
    int64_t _841 = 0; // m
    _jump592:; // Begin body of loop
    int64_t _842 = -_436.d1;
    void_t _843 = f.b;
    a _844 = { _842, _843 };
    int64_t _845 = 0;
    _845 *= _835.d0;
    _845 += _841;
    _845 *= _835.d1;
    _845 += _840;
    _835.data[_845] = _844;
    _840++;
    if (_840 < _836)
    goto _jump592;
    _840 = 0;
    _841++;
    if (_841 < _436.d1)
    goto _jump592;
    // End body of loop
    int64_t _846 = 243;
    double _847 = 48.0;
    double _848 = 29.0;
    bool _849 = _847 != _848;
    int64_t _850;
    if (!_849)
    goto _jump593;
    _850 = _748.d0;
    goto _jump594;
    _jump593:;
    bool _851 = true;
    bool _852 = !_851;
    int64_t _853;
    if (!_852)
    goto _jump595;
    _853 = _436.d1;
    goto _jump596;
    _jump595:;
    _853 = _436.d0;
    _jump596:;
    _850 = _853;
    _jump594:;
    if (_846 >= 0)
    goto _jump597;
    fail_assertion("negative array index");
    _jump597:;
    if (_846 < _835.d0)
    goto _jump598;
    fail_assertion("index too large");
    _jump598:;
    if (_850 >= 0)
    goto _jump599;
    fail_assertion("negative array index");
    _jump599:;
    if (_850 < _835.d1)
    goto _jump600;
    fail_assertion("index too large");
    _jump600:;
    int64_t _854 = 0;
    _854 *= _835.d0;
    _854 += _846;
    _854 *= _835.d1;
    _854 += _850;
    a _855 = _835.data[_854];
    _834 = _855;
    _jump587:;
    _802 = _834;
    _jump583:;
    void_t _856 = _802.b;
    int64_t _857 = d.d0 / _436.d0;
    _a2__a2__a1_int64_t _858;
    // Computing bound for n
    int64_t _859 = 499;
    int64_t _860 = 953;
    int64_t _861 = _859 % _860;
    _858.d0 = _861;
    if (_861 > 0) 
    goto _jump601;
    fail_assertion("non-positive loop bound");
    _jump601:;
    // Computing bound for o
    _858.d1 = c;
    if (c > 0) 
    goto _jump602;
    fail_assertion("non-positive loop bound");
    _jump602:;
    // Computing total size of heap memory to allocate
    int64_t _862 = 1;
    _862 *= _861;
    _862 *= c;
    _862 *= sizeof(_a2__a1_int64_t);
    _858.data = jpl_alloc(_862);
    int64_t _863 = 0; // o
    int64_t _864 = 0; // n
    _jump603:; // Begin body of loop
    _a2__a1_int64_t _865;
    // Computing bound for p
    _865.d0 = _436.d1;
    if (_436.d1 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    // Computing bound for q
    _865.d1 = _436.d1;
    if (_436.d1 > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing total size of heap memory to allocate
    int64_t _866 = 1;
    _866 *= _436.d1;
    _866 *= _436.d1;
    _866 *= sizeof(_a1_int64_t);
    _865.data = jpl_alloc(_866);
    int64_t _867 = 0; // q
    int64_t _868 = 0; // p
    _jump606:; // Begin body of loop
    int64_t _869 = 0;
    _869 *= _865.d0;
    _869 += _868;
    _869 *= _865.d1;
    _869 += _867;
    _865.data[_869] = d;
    _867++;
    if (_867 < _436.d1)
    goto _jump606;
    _867 = 0;
    _868++;
    if (_868 < _436.d1)
    goto _jump606;
    // End body of loop
    int64_t _870 = 0;
    _870 *= _858.d0;
    _870 += _864;
    _870 *= _858.d1;
    _870 += _863;
    _858.data[_870] = _865;
    _863++;
    if (_863 < c)
    goto _jump603;
    _863 = 0;
    _864++;
    if (_864 < _861)
    goto _jump603;
    // End body of loop
    if (_748.d0 >= 0)
    goto _jump607;
    fail_assertion("negative array index");
    _jump607:;
    if (_748.d0 < _858.d0)
    goto _jump608;
    fail_assertion("index too large");
    _jump608:;
    if (_436.d0 >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (_436.d0 < _858.d1)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _871 = 0;
    _871 *= _858.d0;
    _871 += _748.d0;
    _871 *= _858.d1;
    _871 += _436.d0;
    _a2__a1_int64_t _872 = _858.data[_871];
    int64_t _873 = 842;
    int64_t _874 = f.a;
    int64_t _875 = -_874;
    int64_t _876 = _873 % _875;
    if (_876 >= 0)
    goto _jump611;
    fail_assertion("negative array index");
    _jump611:;
    if (_876 < _872.d0)
    goto _jump612;
    fail_assertion("index too large");
    _jump612:;
    if (d.d0 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (d.d0 < _872.d1)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    int64_t _877 = 0;
    _877 *= _872.d0;
    _877 += _876;
    _877 *= _872.d1;
    _877 += d.d0;
    _a1_int64_t _878 = _872.data[_877];
    if (_436.d1 >= 0)
    goto _jump615;
    fail_assertion("negative array index");
    _jump615:;
    if (_436.d1 < _878.d0)
    goto _jump616;
    fail_assertion("index too large");
    _jump616:;
    int64_t _879 = 0;
    _879 *= _878.d0;
    _879 += _436.d1;
    int64_t _880 = _878.data[_879];
    int64_t _881 = _857 - _880;
    bool _882 = c == _881;
    if (0 != _882)
    goto _jump617;
    fail_assertion("n");
    _jump617:;
    int64_t _883 = 43;
    int64_t _884;
    // Computing bound for n
    int64_t _885 = d.d0 + _436.d1;
    int64_t _886 = -_885;
    if (_886 > 0) 
    goto _jump618;
    fail_assertion("non-positive loop bound");
    _jump618:;
    // Computing bound for o
    bool _888 = true;
    bool _887 = _888;
    if (0 == _888)
    goto _jump619;
    bool _889 = true;
    int64_t _890;
    if (!_889)
    goto _jump620;
    _890 = _436.d0;
    goto _jump621;
    _jump620:;
    _890 = d.d0;
    _jump621:;
    bool _891 = c >= _890;
    _887 = _891;
    _jump619:;
    int64_t _892;
    if (!_887)
    goto _jump622;
    bool _893 = false;
    bool _894 = !_893;
    int64_t _895;
    if (!_894)
    goto _jump623;
    _895 = _436.d1;
    goto _jump624;
    _jump623:;
    int64_t _896 = -_436.d1;
    _895 = _896;
    _jump624:;
    int64_t _897 = 49;
    int64_t _898 = _895 % _897;
    _892 = _898;
    goto _jump625;
    _jump622:;
    _892 = _748.d0;
    _jump625:;
    if (_892 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    _884 = 0;
    int64_t _899 = 0; // o
    int64_t _900 = 0; // n
    _jump627:; // Begin body of loop
    _884 += _748.d0;
    _899++;
    if (_899 < _892)
    goto _jump627;
    _899 = 0;
    _900++;
    if (_900 < _886)
    goto _jump627;
    // End body of loop
    int64_t _901 = _883 + _884;
    a _902 = { _901, _856 };
    return _902;
}

a f(void_t g, int64_t h, _a3_bool i) {
    bool _1 = false;
    bool _0 = _1;
    if (0 == _1)
    goto _jump644;
    bool _2 = false;
    double _3;
    if (!_2)
    goto _jump645;
    double _4 = 65.0;
    _3 = _4;
    goto _jump646;
    _jump645:;
    double _5;
    // Computing bound for m
    int64_t _6 = 412;
    if (_6 > 0) 
    goto _jump647;
    fail_assertion("non-positive loop bound");
    _jump647:;
    // Computing bound for n
    int64_t _7 = 814;
    if (_7 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    _5 = 0;
    int64_t _8 = 0; // n
    int64_t _9 = 0; // m
    _jump649:; // Begin body of loop
    double _10;
    // Computing bound for o
    if (i.d0 > 0) 
    goto _jump650;
    fail_assertion("non-positive loop bound");
    _jump650:;
    _10 = 0;
    int64_t _11 = 0; // o
    _jump651:; // Begin body of loop
    double _12 = 60.0;
    _10 += _12;
    _11++;
    if (_11 < i.d0)
    goto _jump651;
    // End body of loop
    _5 += _10;
    _8++;
    if (_8 < _7)
    goto _jump649;
    _8 = 0;
    _9++;
    if (_9 < _6)
    goto _jump649;
    // End body of loop
    _3 = _5;
    _jump646:;
    double _13 = 97.0;
    bool _14 = _3 > _13;
    bool _15;
    if (!_14)
    goto _jump652;
    bool _16 = i.d2 != i.d0;
    int64_t _17;
    // Computing bound for m
    if (d > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    _17 = 0;
    int64_t _18 = 0; // m
    _jump654:; // Begin body of loop
    bool _19 = false;
    int64_t _20;
    if (!_19)
    goto _jump655;
    _20 = i.d2;
    goto _jump656;
    _jump655:;
    _20 = i.d0;
    _jump656:;
    _17 += _20;
    _18++;
    if (_18 < d)
    goto _jump654;
    // End body of loop
    bool _21 = _17 == i.d0;
    bool _22 = _16 == _21;
    _15 = _22;
    goto _jump657;
    _jump652:;
    int64_t _23;
    // Computing bound for m
    if (i.d0 > 0) 
    goto _jump658;
    fail_assertion("non-positive loop bound");
    _jump658:;
    _23 = 0;
    int64_t _24 = 0; // m
    _jump659:; // Begin body of loop
    bool _26 = false;
    bool _25 = _26;
    if (0 == _26)
    goto _jump660;
    bool _27 = true;
    _25 = _27;
    _jump660:;
    int64_t _28;
    if (!_25)
    goto _jump661;
    int64_t _29;
    // Computing bound for n
    int64_t _30 = 865;
    if (_30 > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    _29 = 0;
    int64_t _31 = 0; // n
    _jump663:; // Begin body of loop
    _29 += _24;
    _31++;
    if (_31 < _30)
    goto _jump663;
    // End body of loop
    _28 = _29;
    goto _jump664;
    _jump661:;
    _28 = i.d1;
    _jump664:;
    _23 += _28;
    _24++;
    if (_24 < i.d0)
    goto _jump659;
    // End body of loop
    bool _32 = _23 >= i.d0;
    _15 = _32;
    _jump657:;
    bool _33;
    if (!_15)
    goto _jump665;
    double _34 = 45.0;
    double _35 = 39.0;
    double _36 = _34 + _35;
    double _37;
    // Computing bound for m
    int64_t _38 = 897;
    int64_t _39 = d + _38;
    if (_39 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing bound for n
    if (i.d1 > 0) 
    goto _jump667;
    fail_assertion("non-positive loop bound");
    _jump667:;
    _37 = 0;
    int64_t _40 = 0; // n
    int64_t _41 = 0; // m
    _jump668:; // Begin body of loop
    double _42 = 85.0;
    double _43 = 2.0;
    double _44 = _42 - _43;
    _37 += _44;
    _40++;
    if (_40 < i.d1)
    goto _jump668;
    _40 = 0;
    _41++;
    if (_41 < _39)
    goto _jump668;
    // End body of loop
    bool _45 = _36 > _37;
    bool _46 = !_45;
    bool _47;
    if (!_46)
    goto _jump669;
    bool _48 = true;
    _47 = _48;
    goto _jump670;
    _jump669:;
    int64_t _49 = -i.d0;
    int64_t _50 = _49 + i.d1;
    int64_t _51 = -_50;
    bool _52 = false;
    _a3_int64_t _53;
    if (!_52)
    goto _jump671;
    _a3_int64_t _54;
    // Computing bound for m
    _54.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing bound for n
    _54.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    // Computing bound for o
    _54.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing total size of heap memory to allocate
    int64_t _55 = 1;
    _55 *= i.d1;
    _55 *= i.d2;
    _55 *= i.d0;
    _55 *= sizeof(int64_t);
    _54.data = jpl_alloc(_55);
    int64_t _56 = 0; // o
    int64_t _57 = 0; // n
    int64_t _58 = 0; // m
    _jump675:; // Begin body of loop
    int64_t _59 = 0;
    _59 *= _54.d0;
    _59 += _58;
    _59 *= _54.d1;
    _59 += _57;
    _59 *= _54.d2;
    _59 += _56;
    _54.data[_59] = _58;
    _56++;
    if (_56 < i.d0)
    goto _jump675;
    _56 = 0;
    _57++;
    if (_57 < i.d2)
    goto _jump675;
    _57 = 0;
    _58++;
    if (_58 < i.d1)
    goto _jump675;
    // End body of loop
    _53 = _54;
    goto _jump676;
    _jump671:;
    _a3_int64_t _60;
    // Computing bound for m
    _60.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    // Computing bound for n
    _60.d1 = d;
    if (d > 0) 
    goto _jump678;
    fail_assertion("non-positive loop bound");
    _jump678:;
    // Computing bound for o
    _60.d2 = h;
    if (h > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing total size of heap memory to allocate
    int64_t _61 = 1;
    _61 *= i.d1;
    _61 *= d;
    _61 *= h;
    _61 *= sizeof(int64_t);
    _60.data = jpl_alloc(_61);
    int64_t _62 = 0; // o
    int64_t _63 = 0; // n
    int64_t _64 = 0; // m
    _jump680:; // Begin body of loop
    int64_t _65 = 0;
    _65 *= _60.d0;
    _65 += _64;
    _65 *= _60.d1;
    _65 += _63;
    _65 *= _60.d2;
    _65 += _62;
    _60.data[_65] = i.d0;
    _62++;
    if (_62 < h)
    goto _jump680;
    _62 = 0;
    _63++;
    if (_63 < d)
    goto _jump680;
    _63 = 0;
    _64++;
    if (_64 < i.d1)
    goto _jump680;
    // End body of loop
    _53 = _60;
    _jump676:;
    int64_t _66 = -i.d1;
    if (i.d0 >= 0)
    goto _jump681;
    fail_assertion("negative array index");
    _jump681:;
    if (i.d0 < _53.d0)
    goto _jump682;
    fail_assertion("index too large");
    _jump682:;
    if (i.d1 >= 0)
    goto _jump683;
    fail_assertion("negative array index");
    _jump683:;
    if (i.d1 < _53.d1)
    goto _jump684;
    fail_assertion("index too large");
    _jump684:;
    if (_66 >= 0)
    goto _jump685;
    fail_assertion("negative array index");
    _jump685:;
    if (_66 < _53.d2)
    goto _jump686;
    fail_assertion("index too large");
    _jump686:;
    int64_t _67 = 0;
    _67 *= _53.d0;
    _67 += i.d0;
    _67 *= _53.d1;
    _67 += i.d1;
    _67 *= _53.d2;
    _67 += _66;
    int64_t _68 = _53.data[_67];
    bool _69 = _51 == _68;
    _47 = _69;
    _jump670:;
    _33 = _47;
    goto _jump687;
    _jump665:;
    bool _73 = true;
    bool _72 = _73;
    if (0 != _73)
    goto _jump688;
    bool _74 = h == h;
    _72 = _74;
    _jump688:;
    bool _71 = _72;
    if (0 != _72)
    goto _jump689;
    int64_t _75 = h * h;
    bool _76 = _75 != h;
    _71 = _76;
    _jump689:;
    bool _77 = false;
    _a2_bool _78;
    if (!_77)
    goto _jump690;
    _a2_bool _79;
    // Computing bound for m
    _79.d0 = h;
    if (h > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing bound for n
    _79.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump692;
    fail_assertion("non-positive loop bound");
    _jump692:;
    // Computing total size of heap memory to allocate
    int64_t _80 = 1;
    _80 *= h;
    _80 *= i.d1;
    _80 *= sizeof(bool);
    _79.data = jpl_alloc(_80);
    int64_t _81 = 0; // n
    int64_t _82 = 0; // m
    _jump693:; // Begin body of loop
    bool _83 = true;
    int64_t _84 = 0;
    _84 *= _79.d0;
    _84 += _82;
    _84 *= _79.d1;
    _84 += _81;
    _79.data[_84] = _83;
    _81++;
    if (_81 < i.d1)
    goto _jump693;
    _81 = 0;
    _82++;
    if (_82 < h)
    goto _jump693;
    // End body of loop
    _78 = _79;
    goto _jump694;
    _jump690:;
    _a2_bool _85;
    // Computing bound for m
    _85.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for n
    _85.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= i.d1;
    _86 *= i.d1;
    _86 *= sizeof(bool);
    _85.data = jpl_alloc(_86);
    int64_t _87 = 0; // n
    int64_t _88 = 0; // m
    _jump697:; // Begin body of loop
    bool _89 = false;
    int64_t _90 = 0;
    _90 *= _85.d0;
    _90 += _88;
    _90 *= _85.d1;
    _90 += _87;
    _85.data[_90] = _89;
    _87++;
    if (_87 < i.d1)
    goto _jump697;
    _87 = 0;
    _88++;
    if (_88 < i.d1)
    goto _jump697;
    // End body of loop
    _78 = _85;
    _jump694:;
    int64_t _91 = 33;
    if (_91 >= 0)
    goto _jump698;
    fail_assertion("negative array index");
    _jump698:;
    if (_91 < _78.d0)
    goto _jump699;
    fail_assertion("index too large");
    _jump699:;
    if (i.d0 >= 0)
    goto _jump700;
    fail_assertion("negative array index");
    _jump700:;
    if (i.d0 < _78.d1)
    goto _jump701;
    fail_assertion("index too large");
    _jump701:;
    int64_t _92 = 0;
    _92 *= _78.d0;
    _92 += _91;
    _92 *= _78.d1;
    _92 += i.d0;
    bool _93 = _78.data[_92];
    bool _94 = _71 == _93;
    bool _70 = _94;
    if (0 == _94)
    goto _jump702;
    int64_t _95 = 254;
    bool _96 = true;
    int64_t _97;
    if (!_96)
    goto _jump703;
    _97 = i.d1;
    goto _jump704;
    _jump703:;
    _97 = i.d0;
    _jump704:;
    int64_t _98 = 950;
    if (_97 >= 0)
    goto _jump705;
    fail_assertion("negative array index");
    _jump705:;
    if (_97 < i.d0)
    goto _jump706;
    fail_assertion("index too large");
    _jump706:;
    if (_98 >= 0)
    goto _jump707;
    fail_assertion("negative array index");
    _jump707:;
    if (_98 < i.d1)
    goto _jump708;
    fail_assertion("index too large");
    _jump708:;
    if (i.d1 >= 0)
    goto _jump709;
    fail_assertion("negative array index");
    _jump709:;
    if (i.d1 < i.d2)
    goto _jump710;
    fail_assertion("index too large");
    _jump710:;
    int64_t _99 = 0;
    _99 *= i.d0;
    _99 += _97;
    _99 *= i.d1;
    _99 += _98;
    _99 *= i.d2;
    _99 += i.d1;
    bool _100 = i.data[_99];
    int64_t _101;
    if (!_100)
    goto _jump711;
    int64_t _102 = -i.d1;
    _101 = _102;
    goto _jump712;
    _jump711:;
    int64_t _103;
    // Computing bound for m
    int64_t _104 = 703;
    int64_t _105 = i.d0 * _104;
    if (_105 > 0) 
    goto _jump713;
    fail_assertion("non-positive loop bound");
    _jump713:;
    // Computing bound for n
    int64_t _106 = -i.d1;
    if (_106 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    _103 = 0;
    int64_t _107 = 0; // n
    int64_t _108 = 0; // m
    _jump715:; // Begin body of loop
    int64_t _109 = 781;
    _103 += _109;
    _107++;
    if (_107 < _106)
    goto _jump715;
    _107 = 0;
    _108++;
    if (_108 < _105)
    goto _jump715;
    // End body of loop
    _101 = _103;
    _jump712:;
    bool _110 = _95 > _101;
    _70 = _110;
    _jump702:;
    _33 = _70;
    _jump687:;
    _0 = _33;
    _jump644:;
    if (0 != _0)
    goto _jump716;
    fail_assertion("m");
    _jump716:;
    _a3__a3__a3_bool _111;
    // Computing bound for m
    int64_t _112 = 359;
    int64_t _113 = -_112;
    int64_t _114 = i.d2 / _113;
    int64_t _115 = i.d0 % _114;
    _111.d0 = _115;
    if (_115 > 0) 
    goto _jump717;
    fail_assertion("non-positive loop bound");
    _jump717:;
    // Computing bound for n
    int64_t _116;
    // Computing bound for m
    if (h > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for n
    if (h > 0) 
    goto _jump719;
    fail_assertion("non-positive loop bound");
    _jump719:;
    // Computing bound for o
    int64_t _117;
    // Computing bound for m
    if (h > 0) 
    goto _jump720;
    fail_assertion("non-positive loop bound");
    _jump720:;
    _117 = 0;
    int64_t _118 = 0; // m
    _jump721:; // Begin body of loop
    _117 += i.d2;
    _118++;
    if (_118 < h)
    goto _jump721;
    // End body of loop
    if (_117 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    _116 = 0;
    int64_t _119 = 0; // o
    int64_t _120 = 0; // n
    int64_t _121 = 0; // m
    _jump723:; // Begin body of loop
    _116 += i.d2;
    _119++;
    if (_119 < _117)
    goto _jump723;
    _119 = 0;
    _120++;
    if (_120 < h)
    goto _jump723;
    _120 = 0;
    _121++;
    if (_121 < h)
    goto _jump723;
    // End body of loop
    _111.d1 = _116;
    if (_116 > 0) 
    goto _jump724;
    fail_assertion("non-positive loop bound");
    _jump724:;
    // Computing bound for o
    _111.d2 = d;
    if (d > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _115;
    _122 *= _116;
    _122 *= d;
    _122 *= sizeof(_a3__a3_bool);
    _111.data = jpl_alloc(_122);
    int64_t _123 = 0; // o
    int64_t _124 = 0; // n
    int64_t _125 = 0; // m
    _jump726:; // Begin body of loop
    _a3__a3_bool _126;
    // Computing bound for p
    _126.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump727;
    fail_assertion("non-positive loop bound");
    _jump727:;
    // Computing bound for q
    _126.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for r
    if (i.d2 >= 0)
    goto _jump729;
    fail_assertion("negative array index");
    _jump729:;
    if (i.d2 < i.d0)
    goto _jump730;
    fail_assertion("index too large");
    _jump730:;
    if (_123 >= 0)
    goto _jump731;
    fail_assertion("negative array index");
    _jump731:;
    if (_123 < i.d1)
    goto _jump732;
    fail_assertion("index too large");
    _jump732:;
    if (_124 >= 0)
    goto _jump733;
    fail_assertion("negative array index");
    _jump733:;
    if (_124 < i.d2)
    goto _jump734;
    fail_assertion("index too large");
    _jump734:;
    int64_t _127 = 0;
    _127 *= i.d0;
    _127 += i.d2;
    _127 *= i.d1;
    _127 += _123;
    _127 *= i.d2;
    _127 += _124;
    bool _128 = i.data[_127];
    int64_t _129;
    if (!_128)
    goto _jump735;
    _129 = i.d2;
    goto _jump736;
    _jump735:;
    _129 = _124;
    _jump736:;
    _126.d2 = _129;
    if (_129 > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    // Computing total size of heap memory to allocate
    int64_t _130 = 1;
    _130 *= i.d1;
    _130 *= i.d1;
    _130 *= _129;
    _130 *= sizeof(_a3_bool);
    _126.data = jpl_alloc(_130);
    int64_t _131 = 0; // r
    int64_t _132 = 0; // q
    int64_t _133 = 0; // p
    _jump738:; // Begin body of loop
    _a3_bool _134;
    // Computing bound for s
    _134.d0 = _123;
    if (_123 > 0) 
    goto _jump739;
    fail_assertion("non-positive loop bound");
    _jump739:;
    // Computing bound for t
    int64_t _135 = -i.d0;
    _134.d1 = _135;
    if (_135 > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    // Computing bound for u
    _134.d2 = h;
    if (h > 0) 
    goto _jump741;
    fail_assertion("non-positive loop bound");
    _jump741:;
    // Computing total size of heap memory to allocate
    int64_t _136 = 1;
    _136 *= _123;
    _136 *= _135;
    _136 *= h;
    _136 *= sizeof(bool);
    _134.data = jpl_alloc(_136);
    int64_t _137 = 0; // u
    int64_t _138 = 0; // t
    int64_t _139 = 0; // s
    _jump742:; // Begin body of loop
    if (i.d2 >= 0)
    goto _jump743;
    fail_assertion("negative array index");
    _jump743:;
    if (i.d2 < c.d0)
    goto _jump744;
    fail_assertion("index too large");
    _jump744:;
    int64_t _140 = 0;
    _140 *= c.d0;
    _140 += i.d2;
    bool _141 = c.data[_140];
    int64_t _142 = 0;
    _142 *= _134.d0;
    _142 += _139;
    _142 *= _134.d1;
    _142 += _138;
    _142 *= _134.d2;
    _142 += _137;
    _134.data[_142] = _141;
    _137++;
    if (_137 < h)
    goto _jump742;
    _137 = 0;
    _138++;
    if (_138 < _135)
    goto _jump742;
    _138 = 0;
    _139++;
    if (_139 < _123)
    goto _jump742;
    // End body of loop
    int64_t _143 = 0;
    _143 *= _126.d0;
    _143 += _133;
    _143 *= _126.d1;
    _143 += _132;
    _143 *= _126.d2;
    _143 += _131;
    _126.data[_143] = _134;
    _131++;
    if (_131 < _129)
    goto _jump738;
    _131 = 0;
    _132++;
    if (_132 < i.d1)
    goto _jump738;
    _132 = 0;
    _133++;
    if (_133 < i.d1)
    goto _jump738;
    // End body of loop
    int64_t _144 = 0;
    _144 *= _111.d0;
    _144 += _125;
    _144 *= _111.d1;
    _144 += _124;
    _144 *= _111.d2;
    _144 += _123;
    _111.data[_144] = _126;
    _123++;
    if (_123 < d)
    goto _jump726;
    _123 = 0;
    _124++;
    if (_124 < _116)
    goto _jump726;
    _124 = 0;
    _125++;
    if (_125 < _115)
    goto _jump726;
    // End body of loop
    int64_t _145 = -i.d2;
    int64_t _146 = 146;
    int64_t _147 = -_146;
    if (_147 >= 0)
    goto _jump745;
    fail_assertion("negative array index");
    _jump745:;
    if (_147 < i.d0)
    goto _jump746;
    fail_assertion("index too large");
    _jump746:;
    if (d >= 0)
    goto _jump747;
    fail_assertion("negative array index");
    _jump747:;
    if (d < i.d1)
    goto _jump748;
    fail_assertion("index too large");
    _jump748:;
    if (i.d0 >= 0)
    goto _jump749;
    fail_assertion("negative array index");
    _jump749:;
    if (i.d0 < i.d2)
    goto _jump750;
    fail_assertion("index too large");
    _jump750:;
    int64_t _148 = 0;
    _148 *= i.d0;
    _148 += _147;
    _148 *= i.d1;
    _148 += d;
    _148 *= i.d2;
    _148 += i.d0;
    bool _149 = i.data[_148];
    _a2_int64_t _150;
    if (!_149)
    goto _jump751;
    bool _151 = false;
    _a2_int64_t _152;
    if (!_151)
    goto _jump752;
    _a2_int64_t _153;
    // Computing bound for m
    _153.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing bound for n
    _153.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump754;
    fail_assertion("non-positive loop bound");
    _jump754:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= i.d2;
    _154 *= i.d2;
    _154 *= sizeof(int64_t);
    _153.data = jpl_alloc(_154);
    int64_t _155 = 0; // n
    int64_t _156 = 0; // m
    _jump755:; // Begin body of loop
    int64_t _157 = 0;
    _157 *= _153.d0;
    _157 += _156;
    _157 *= _153.d1;
    _157 += _155;
    _153.data[_157] = d;
    _155++;
    if (_155 < i.d2)
    goto _jump755;
    _155 = 0;
    _156++;
    if (_156 < i.d2)
    goto _jump755;
    // End body of loop
    _152 = _153;
    goto _jump756;
    _jump752:;
    _a2_int64_t _158;
    // Computing bound for m
    _158.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump757;
    fail_assertion("non-positive loop bound");
    _jump757:;
    // Computing bound for n
    _158.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump758;
    fail_assertion("non-positive loop bound");
    _jump758:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= i.d0;
    _159 *= i.d0;
    _159 *= sizeof(int64_t);
    _158.data = jpl_alloc(_159);
    int64_t _160 = 0; // n
    int64_t _161 = 0; // m
    _jump759:; // Begin body of loop
    int64_t _162 = 0;
    _162 *= _158.d0;
    _162 += _161;
    _162 *= _158.d1;
    _162 += _160;
    _158.data[_162] = i.d0;
    _160++;
    if (_160 < i.d0)
    goto _jump759;
    _160 = 0;
    _161++;
    if (_161 < i.d0)
    goto _jump759;
    // End body of loop
    _152 = _158;
    _jump756:;
    _150 = _152;
    goto _jump760;
    _jump751:;
    _a2_int64_t _163;
    // Computing bound for m
    _163.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump761;
    fail_assertion("non-positive loop bound");
    _jump761:;
    // Computing bound for n
    _163.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing total size of heap memory to allocate
    int64_t _164 = 1;
    _164 *= i.d0;
    _164 *= i.d2;
    _164 *= sizeof(int64_t);
    _163.data = jpl_alloc(_164);
    int64_t _165 = 0; // n
    int64_t _166 = 0; // m
    _jump763:; // Begin body of loop
    int64_t _167 = -i.d2;
    int64_t _168 = 0;
    _168 *= _163.d0;
    _168 += _166;
    _168 *= _163.d1;
    _168 += _165;
    _163.data[_168] = _167;
    _165++;
    if (_165 < i.d2)
    goto _jump763;
    _165 = 0;
    _166++;
    if (_166 < i.d0)
    goto _jump763;
    // End body of loop
    _150 = _163;
    _jump760:;
    int64_t _169;
    // Computing bound for m
    if (d > 0) 
    goto _jump764;
    fail_assertion("non-positive loop bound");
    _jump764:;
    // Computing bound for n
    int64_t _170;
    // Computing bound for m
    if (i.d0 > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    _170 = 0;
    int64_t _171 = 0; // m
    _jump766:; // Begin body of loop
    _170 += _171;
    _171++;
    if (_171 < i.d0)
    goto _jump766;
    // End body of loop
    if (_170 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    // Computing bound for o
    int64_t _172 = -h;
    if (_172 > 0) 
    goto _jump768;
    fail_assertion("non-positive loop bound");
    _jump768:;
    _169 = 0;
    int64_t _173 = 0; // o
    int64_t _174 = 0; // n
    int64_t _175 = 0; // m
    _jump769:; // Begin body of loop
    _169 += _175;
    _173++;
    if (_173 < _172)
    goto _jump769;
    _173 = 0;
    _174++;
    if (_174 < _170)
    goto _jump769;
    _174 = 0;
    _175++;
    if (_175 < d)
    goto _jump769;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump770;
    fail_assertion("negative array index");
    _jump770:;
    if (i.d0 < _150.d0)
    goto _jump771;
    fail_assertion("index too large");
    _jump771:;
    if (_169 >= 0)
    goto _jump772;
    fail_assertion("negative array index");
    _jump772:;
    if (_169 < _150.d1)
    goto _jump773;
    fail_assertion("index too large");
    _jump773:;
    int64_t _176 = 0;
    _176 *= _150.d0;
    _176 += i.d0;
    _176 *= _150.d1;
    _176 += _169;
    int64_t _177 = _150.data[_176];
    if (h >= 0)
    goto _jump774;
    fail_assertion("negative array index");
    _jump774:;
    if (h < _111.d0)
    goto _jump775;
    fail_assertion("index too large");
    _jump775:;
    if (_145 >= 0)
    goto _jump776;
    fail_assertion("negative array index");
    _jump776:;
    if (_145 < _111.d1)
    goto _jump777;
    fail_assertion("index too large");
    _jump777:;
    if (_177 >= 0)
    goto _jump778;
    fail_assertion("negative array index");
    _jump778:;
    if (_177 < _111.d2)
    goto _jump779;
    fail_assertion("index too large");
    _jump779:;
    int64_t _178 = 0;
    _178 *= _111.d0;
    _178 += h;
    _178 *= _111.d1;
    _178 += _145;
    _178 *= _111.d2;
    _178 += _177;
    _a3__a3_bool _179 = _111.data[_178];
    int64_t _180 = -i.d0;
    _a2_int64_t _181;
    // Computing bound for m
    _a3_int64_t _182;
    // Computing bound for m
    _182.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump780;
    fail_assertion("non-positive loop bound");
    _jump780:;
    // Computing bound for n
    _182.d1 = h;
    if (h > 0) 
    goto _jump781;
    fail_assertion("non-positive loop bound");
    _jump781:;
    // Computing bound for o
    int64_t _183 = 827;
    _182.d2 = _183;
    if (_183 > 0) 
    goto _jump782;
    fail_assertion("non-positive loop bound");
    _jump782:;
    // Computing total size of heap memory to allocate
    int64_t _184 = 1;
    _184 *= i.d1;
    _184 *= h;
    _184 *= _183;
    _184 *= sizeof(int64_t);
    _182.data = jpl_alloc(_184);
    int64_t _185 = 0; // o
    int64_t _186 = 0; // n
    int64_t _187 = 0; // m
    _jump783:; // Begin body of loop
    int64_t _188 = 0;
    _188 *= _182.d0;
    _188 += _187;
    _188 *= _182.d1;
    _188 += _186;
    _188 *= _182.d2;
    _188 += _185;
    _182.data[_188] = d;
    _185++;
    if (_185 < _183)
    goto _jump783;
    _185 = 0;
    _186++;
    if (_186 < h)
    goto _jump783;
    _186 = 0;
    _187++;
    if (_187 < i.d1)
    goto _jump783;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump784;
    fail_assertion("negative array index");
    _jump784:;
    if (i.d0 < _182.d0)
    goto _jump785;
    fail_assertion("index too large");
    _jump785:;
    if (i.d0 >= 0)
    goto _jump786;
    fail_assertion("negative array index");
    _jump786:;
    if (i.d0 < _182.d1)
    goto _jump787;
    fail_assertion("index too large");
    _jump787:;
    if (i.d1 >= 0)
    goto _jump788;
    fail_assertion("negative array index");
    _jump788:;
    if (i.d1 < _182.d2)
    goto _jump789;
    fail_assertion("index too large");
    _jump789:;
    int64_t _189 = 0;
    _189 *= _182.d0;
    _189 += i.d0;
    _189 *= _182.d1;
    _189 += i.d0;
    _189 *= _182.d2;
    _189 += i.d1;
    int64_t _190 = _182.data[_189];
    _181.d0 = _190;
    if (_190 > 0) 
    goto _jump790;
    fail_assertion("non-positive loop bound");
    _jump790:;
    // Computing bound for n
    int64_t _191 = 600;
    _181.d1 = _191;
    if (_191 > 0) 
    goto _jump791;
    fail_assertion("non-positive loop bound");
    _jump791:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= _190;
    _192 *= _191;
    _192 *= sizeof(int64_t);
    _181.data = jpl_alloc(_192);
    int64_t _193 = 0; // n
    int64_t _194 = 0; // m
    _jump792:; // Begin body of loop
    int64_t _195 = 471;
    int64_t _196 = 0;
    _196 *= _181.d0;
    _196 += _194;
    _196 *= _181.d1;
    _196 += _193;
    _181.data[_196] = _195;
    _193++;
    if (_193 < _191)
    goto _jump792;
    _193 = 0;
    _194++;
    if (_194 < _190)
    goto _jump792;
    // End body of loop
    int64_t _197 = -i.d1;
    int64_t _198 = -_197;
    _a1__a1_int64_t _199;
    // Computing bound for m
    int64_t _200;
    // Computing bound for m
    if (i.d2 > 0) 
    goto _jump793;
    fail_assertion("non-positive loop bound");
    _jump793:;
    // Computing bound for n
    if (h > 0) 
    goto _jump794;
    fail_assertion("non-positive loop bound");
    _jump794:;
    _200 = 0;
    int64_t _201 = 0; // n
    int64_t _202 = 0; // m
    _jump795:; // Begin body of loop
    _200 += i.d1;
    _201++;
    if (_201 < h)
    goto _jump795;
    _201 = 0;
    _202++;
    if (_202 < i.d2)
    goto _jump795;
    // End body of loop
    _199.d0 = _200;
    if (_200 > 0) 
    goto _jump796;
    fail_assertion("non-positive loop bound");
    _jump796:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _200;
    _203 *= sizeof(_a1_int64_t);
    _199.data = jpl_alloc(_203);
    int64_t _204 = 0; // m
    _jump797:; // Begin body of loop
    _a1_int64_t _205;
    // Computing bound for n
    _205.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing total size of heap memory to allocate
    int64_t _206 = 1;
    _206 *= i.d2;
    _206 *= sizeof(int64_t);
    _205.data = jpl_alloc(_206);
    int64_t _207 = 0; // n
    _jump799:; // Begin body of loop
    int64_t _208 = 0;
    _208 *= _205.d0;
    _208 += _207;
    _205.data[_208] = _207;
    _207++;
    if (_207 < i.d2)
    goto _jump799;
    // End body of loop
    int64_t _209 = 0;
    _209 *= _199.d0;
    _209 += _204;
    _199.data[_209] = _205;
    _204++;
    if (_204 < _200)
    goto _jump797;
    // End body of loop
    if (h >= 0)
    goto _jump800;
    fail_assertion("negative array index");
    _jump800:;
    if (h < _199.d0)
    goto _jump801;
    fail_assertion("index too large");
    _jump801:;
    int64_t _210 = 0;
    _210 *= _199.d0;
    _210 += h;
    _a1_int64_t _211 = _199.data[_210];
    int64_t _212;
    // Computing bound for m
    if (i.d1 > 0) 
    goto _jump802;
    fail_assertion("non-positive loop bound");
    _jump802:;
    // Computing bound for n
    if (d > 0) 
    goto _jump803;
    fail_assertion("non-positive loop bound");
    _jump803:;
    _212 = 0;
    int64_t _213 = 0; // n
    int64_t _214 = 0; // m
    _jump804:; // Begin body of loop
    _212 += d;
    _213++;
    if (_213 < d)
    goto _jump804;
    _213 = 0;
    _214++;
    if (_214 < i.d1)
    goto _jump804;
    // End body of loop
    int64_t _215 = -_212;
    if (_215 >= 0)
    goto _jump805;
    fail_assertion("negative array index");
    _jump805:;
    if (_215 < _211.d0)
    goto _jump806;
    fail_assertion("index too large");
    _jump806:;
    int64_t _216 = 0;
    _216 *= _211.d0;
    _216 += _215;
    int64_t _217 = _211.data[_216];
    if (_198 >= 0)
    goto _jump807;
    fail_assertion("negative array index");
    _jump807:;
    if (_198 < _181.d0)
    goto _jump808;
    fail_assertion("index too large");
    _jump808:;
    if (_217 >= 0)
    goto _jump809;
    fail_assertion("negative array index");
    _jump809:;
    if (_217 < _181.d1)
    goto _jump810;
    fail_assertion("index too large");
    _jump810:;
    int64_t _218 = 0;
    _218 *= _181.d0;
    _218 += _198;
    _218 *= _181.d1;
    _218 += _217;
    int64_t _219 = _181.data[_218];
    if (_180 >= 0)
    goto _jump811;
    fail_assertion("negative array index");
    _jump811:;
    if (_180 < _179.d0)
    goto _jump812;
    fail_assertion("index too large");
    _jump812:;
    if (_219 >= 0)
    goto _jump813;
    fail_assertion("negative array index");
    _jump813:;
    if (_219 < _179.d1)
    goto _jump814;
    fail_assertion("index too large");
    _jump814:;
    if (i.d2 >= 0)
    goto _jump815;
    fail_assertion("negative array index");
    _jump815:;
    if (i.d2 < _179.d2)
    goto _jump816;
    fail_assertion("index too large");
    _jump816:;
    int64_t _220 = 0;
    _220 *= _179.d0;
    _220 += _180;
    _220 *= _179.d1;
    _220 += _219;
    _220 *= _179.d2;
    _220 += i.d2;
    _a3_bool _221 = _179.data[_220];
    bool _222 = false;
    int64_t _223;
    if (!_222)
    goto _jump817;
    _223 = d;
    goto _jump818;
    _jump817:;
    int64_t _224;
    // Computing bound for m
    if (h > 0) 
    goto _jump819;
    fail_assertion("non-positive loop bound");
    _jump819:;
    _224 = 0;
    int64_t _225 = 0; // m
    _jump820:; // Begin body of loop
    _224 += d;
    _225++;
    if (_225 < h)
    goto _jump820;
    // End body of loop
    _223 = _224;
    _jump818:;
    a _226 = { _223, g };
    int64_t _227 = _226.a;
    _a1_int64_t _228;
    _228.d0 = 1;
    _228.data = jpl_alloc(sizeof(int64_t) * 1);
    _228.data[0] = _227;
    int64_t _229;
    // Computing bound for m
    bool _230 = true;
    int64_t _231;
    if (!_230)
    goto _jump821;
    _231 = i.d0;
    goto _jump822;
    _jump821:;
    int64_t _232 = i.d2 % h;
    _231 = _232;
    _jump822:;
    int64_t _233 = -_231;
    if (_233 > 0) 
    goto _jump823;
    fail_assertion("non-positive loop bound");
    _jump823:;
    // Computing bound for n
    if (h > 0) 
    goto _jump824;
    fail_assertion("non-positive loop bound");
    _jump824:;
    _229 = 0;
    int64_t _234 = 0; // n
    int64_t _235 = 0; // m
    _jump825:; // Begin body of loop
    _229 += i.d2;
    _234++;
    if (_234 < h)
    goto _jump825;
    _234 = 0;
    _235++;
    if (_235 < _233)
    goto _jump825;
    // End body of loop
    if (_229 >= 0)
    goto _jump826;
    fail_assertion("negative array index");
    _jump826:;
    if (_229 < _228.d0)
    goto _jump827;
    fail_assertion("index too large");
    _jump827:;
    int64_t _236 = 0;
    _236 *= _228.d0;
    _236 += _229;
    int64_t _237 = _228.data[_236];
    if (i.d2 >= 0)
    goto _jump828;
    fail_assertion("negative array index");
    _jump828:;
    if (i.d2 < _221.d0)
    goto _jump829;
    fail_assertion("index too large");
    _jump829:;
    if (h >= 0)
    goto _jump830;
    fail_assertion("negative array index");
    _jump830:;
    if (h < _221.d1)
    goto _jump831;
    fail_assertion("index too large");
    _jump831:;
    if (_237 >= 0)
    goto _jump832;
    fail_assertion("negative array index");
    _jump832:;
    if (_237 < _221.d2)
    goto _jump833;
    fail_assertion("index too large");
    _jump833:;
    int64_t _238 = 0;
    _238 *= _221.d0;
    _238 += i.d2;
    _238 *= _221.d1;
    _238 += h;
    _238 *= _221.d2;
    _238 += _237;
    bool _239 = _221.data[_238];
    if (0 != _239)
    goto _jump834;
    fail_assertion("m");
    _jump834:;
    _a3_bool _240;
    // Computing bound for m
    int64_t _241 = 654;
    _240.d0 = _241;
    if (_241 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing bound for n
    int64_t _242 = 570;
    _240.d1 = _242;
    if (_242 > 0) 
    goto _jump836;
    fail_assertion("non-positive loop bound");
    _jump836:;
    // Computing bound for o
    int64_t _243;
    // Computing bound for m
    if (d > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for n
    int64_t _244 = 26;
    if (_244 > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing bound for o
    bool _245 = false;
    int64_t _246;
    if (!_245)
    goto _jump839;
    int64_t _247 = -i.d1;
    int64_t _248 = _247 + i.d2;
    _246 = _248;
    goto _jump840;
    _jump839:;
    _246 = h;
    _jump840:;
    if (_246 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    _243 = 0;
    int64_t _249 = 0; // o
    int64_t _250 = 0; // n
    int64_t _251 = 0; // m
    _jump842:; // Begin body of loop
    int64_t _252 = -i.d2;
    _243 += _252;
    _249++;
    if (_249 < _246)
    goto _jump842;
    _249 = 0;
    _250++;
    if (_250 < _244)
    goto _jump842;
    _250 = 0;
    _251++;
    if (_251 < d)
    goto _jump842;
    // End body of loop
    _240.d2 = _243;
    if (_243 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    // Computing total size of heap memory to allocate
    int64_t _253 = 1;
    _253 *= _241;
    _253 *= _242;
    _253 *= _243;
    _253 *= sizeof(bool);
    _240.data = jpl_alloc(_253);
    int64_t _254 = 0; // o
    int64_t _255 = 0; // n
    int64_t _256 = 0; // m
    _jump844:; // Begin body of loop
    bool _257 = false;
    bool _258 = _256 >= i.d2;
    bool _259 = !_258;
    _a3_bool _260;
    if (!_259)
    goto _jump845;
    _a3_bool _261;
    // Computing bound for p
    _261.d0 = _254;
    if (_254 > 0) 
    goto _jump846;
    fail_assertion("non-positive loop bound");
    _jump846:;
    // Computing bound for q
    _261.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump847;
    fail_assertion("non-positive loop bound");
    _jump847:;
    // Computing bound for r
    int64_t _262 = -_254;
    _261.d2 = _262;
    if (_262 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= _254;
    _263 *= i.d2;
    _263 *= _262;
    _263 *= sizeof(bool);
    _261.data = jpl_alloc(_263);
    int64_t _264 = 0; // r
    int64_t _265 = 0; // q
    int64_t _266 = 0; // p
    _jump849:; // Begin body of loop
    bool _267 = i.d2 > _264;
    int64_t _268 = 0;
    _268 *= _261.d0;
    _268 += _266;
    _268 *= _261.d1;
    _268 += _265;
    _268 *= _261.d2;
    _268 += _264;
    _261.data[_268] = _267;
    _264++;
    if (_264 < _262)
    goto _jump849;
    _264 = 0;
    _265++;
    if (_265 < i.d2)
    goto _jump849;
    _265 = 0;
    _266++;
    if (_266 < _254)
    goto _jump849;
    // End body of loop
    _260 = _261;
    goto _jump850;
    _jump845:;
    _a3__a3_bool _269;
    // Computing bound for p
    _269.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump851;
    fail_assertion("non-positive loop bound");
    _jump851:;
    // Computing bound for q
    int64_t _270 = 833;
    _269.d1 = _270;
    if (_270 > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing bound for r
    _269.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump853;
    fail_assertion("non-positive loop bound");
    _jump853:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= i.d0;
    _271 *= _270;
    _271 *= i.d1;
    _271 *= sizeof(_a3_bool);
    _269.data = jpl_alloc(_271);
    int64_t _272 = 0; // r
    int64_t _273 = 0; // q
    int64_t _274 = 0; // p
    _jump854:; // Begin body of loop
    int64_t _275 = 0;
    _275 *= _269.d0;
    _275 += _274;
    _275 *= _269.d1;
    _275 += _273;
    _275 *= _269.d2;
    _275 += _272;
    _269.data[_275] = i;
    _272++;
    if (_272 < i.d1)
    goto _jump854;
    _272 = 0;
    _273++;
    if (_273 < _270)
    goto _jump854;
    _273 = 0;
    _274++;
    if (_274 < i.d0)
    goto _jump854;
    // End body of loop
    int64_t _276 = -i.d1;
    int64_t _277 = -i.d2;
    if (_276 >= 0)
    goto _jump855;
    fail_assertion("negative array index");
    _jump855:;
    if (_276 < _269.d0)
    goto _jump856;
    fail_assertion("index too large");
    _jump856:;
    if (d >= 0)
    goto _jump857;
    fail_assertion("negative array index");
    _jump857:;
    if (d < _269.d1)
    goto _jump858;
    fail_assertion("index too large");
    _jump858:;
    if (_277 >= 0)
    goto _jump859;
    fail_assertion("negative array index");
    _jump859:;
    if (_277 < _269.d2)
    goto _jump860;
    fail_assertion("index too large");
    _jump860:;
    int64_t _278 = 0;
    _278 *= _269.d0;
    _278 += _276;
    _278 *= _269.d1;
    _278 += d;
    _278 *= _269.d2;
    _278 += _277;
    _a3_bool _279 = _269.data[_278];
    _260 = _279;
    _jump850:;
    int64_t _280 = -h;
    if (_280 >= 0)
    goto _jump861;
    fail_assertion("negative array index");
    _jump861:;
    if (_280 < _260.d0)
    goto _jump862;
    fail_assertion("index too large");
    _jump862:;
    if (_254 >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (_254 < _260.d1)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    if (_254 >= 0)
    goto _jump865;
    fail_assertion("negative array index");
    _jump865:;
    if (_254 < _260.d2)
    goto _jump866;
    fail_assertion("index too large");
    _jump866:;
    int64_t _281 = 0;
    _281 *= _260.d0;
    _281 += _280;
    _281 *= _260.d1;
    _281 += _254;
    _281 *= _260.d2;
    _281 += _254;
    bool _282 = _260.data[_281];
    bool _283 = _257 != _282;
    int64_t _284 = 0;
    _284 *= _240.d0;
    _284 += _256;
    _284 *= _240.d1;
    _284 += _255;
    _284 *= _240.d2;
    _284 += _254;
    _240.data[_284] = _283;
    _254++;
    if (_254 < _243)
    goto _jump844;
    _254 = 0;
    _255++;
    if (_255 < _242)
    goto _jump844;
    _255 = 0;
    _256++;
    if (_256 < _241)
    goto _jump844;
    // End body of loop
    int64_t _285;
    // Computing bound for m
    if (i.d1 > 0) 
    goto _jump867;
    fail_assertion("non-positive loop bound");
    _jump867:;
    // Computing bound for n
    int64_t _286 = -i.d1;
    int64_t _287 = -_286;
    if (_287 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing bound for o
    if (d > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    _285 = 0;
    int64_t _288 = 0; // o
    int64_t _289 = 0; // n
    int64_t _290 = 0; // m
    _jump870:; // Begin body of loop
    int64_t _291;
    // Computing bound for p
    int64_t _292;
    // Computing bound for p
    if (d > 0) 
    goto _jump871;
    fail_assertion("non-positive loop bound");
    _jump871:;
    // Computing bound for q
    _a1_int64_t _293;
    // Computing bound for p
    _293.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    // Computing total size of heap memory to allocate
    int64_t _294 = 1;
    _294 *= i.d2;
    _294 *= sizeof(int64_t);
    _293.data = jpl_alloc(_294);
    int64_t _295 = 0; // p
    _jump873:; // Begin body of loop
    int64_t _296 = 0;
    _296 *= _293.d0;
    _296 += _295;
    _293.data[_296] = i.d1;
    _295++;
    if (_295 < i.d2)
    goto _jump873;
    // End body of loop
    if (_290 >= 0)
    goto _jump874;
    fail_assertion("negative array index");
    _jump874:;
    if (_290 < _293.d0)
    goto _jump875;
    fail_assertion("index too large");
    _jump875:;
    int64_t _297 = 0;
    _297 *= _293.d0;
    _297 += _290;
    int64_t _298 = _293.data[_297];
    if (_298 > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing bound for r
    if (i.d0 > 0) 
    goto _jump877;
    fail_assertion("non-positive loop bound");
    _jump877:;
    _292 = 0;
    int64_t _299 = 0; // r
    int64_t _300 = 0; // q
    int64_t _301 = 0; // p
    _jump878:; // Begin body of loop
    int64_t _302;
    // Computing bound for s
    int64_t _303;
    // Computing bound for s
    if (_289 > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    _303 = 0;
    int64_t _304 = 0; // s
    _jump880:; // Begin body of loop
    _303 += _290;
    _304++;
    if (_304 < _289)
    goto _jump880;
    // End body of loop
    if (_303 > 0) 
    goto _jump881;
    fail_assertion("non-positive loop bound");
    _jump881:;
    // Computing bound for t
    if (i.d0 > 0) 
    goto _jump882;
    fail_assertion("non-positive loop bound");
    _jump882:;
    // Computing bound for u
    if (_301 > 0) 
    goto _jump883;
    fail_assertion("non-positive loop bound");
    _jump883:;
    _302 = 0;
    int64_t _305 = 0; // u
    int64_t _306 = 0; // t
    int64_t _307 = 0; // s
    _jump884:; // Begin body of loop
    _302 += h;
    _305++;
    if (_305 < _301)
    goto _jump884;
    _305 = 0;
    _306++;
    if (_306 < i.d0)
    goto _jump884;
    _306 = 0;
    _307++;
    if (_307 < _303)
    goto _jump884;
    // End body of loop
    _292 += _302;
    _299++;
    if (_299 < i.d0)
    goto _jump878;
    _299 = 0;
    _300++;
    if (_300 < _298)
    goto _jump878;
    _300 = 0;
    _301++;
    if (_301 < d)
    goto _jump878;
    // End body of loop
    if (_292 > 0) 
    goto _jump885;
    fail_assertion("non-positive loop bound");
    _jump885:;
    // Computing bound for q
    if (_290 > 0) 
    goto _jump886;
    fail_assertion("non-positive loop bound");
    _jump886:;
    // Computing bound for r
    int64_t _308;
    // Computing bound for p
    if (_288 > 0) 
    goto _jump887;
    fail_assertion("non-positive loop bound");
    _jump887:;
    _308 = 0;
    int64_t _309 = 0; // p
    _jump888:; // Begin body of loop
    _308 += _309;
    _309++;
    if (_309 < _288)
    goto _jump888;
    // End body of loop
    if (_308 > 0) 
    goto _jump889;
    fail_assertion("non-positive loop bound");
    _jump889:;
    _291 = 0;
    int64_t _310 = 0; // r
    int64_t _311 = 0; // q
    int64_t _312 = 0; // p
    _jump890:; // Begin body of loop
    _291 += _310;
    _310++;
    if (_310 < _308)
    goto _jump890;
    _310 = 0;
    _311++;
    if (_311 < _290)
    goto _jump890;
    _311 = 0;
    _312++;
    if (_312 < _292)
    goto _jump890;
    // End body of loop
    int64_t _313 = -_291;
    _285 += _313;
    _288++;
    if (_288 < d)
    goto _jump870;
    _288 = 0;
    _289++;
    if (_289 < _287)
    goto _jump870;
    _289 = 0;
    _290++;
    if (_290 < i.d1)
    goto _jump870;
    // End body of loop
    int64_t _314;
    // Computing bound for m
    int64_t _315;
    // Computing bound for m
    _a3_int64_t _316;
    // Computing bound for m
    int64_t _317 = i.d0 - i.d0;
    _316.d0 = _317;
    if (_317 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing bound for n
    _316.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump892;
    fail_assertion("non-positive loop bound");
    _jump892:;
    // Computing bound for o
    bool _318 = true;
    int64_t _319;
    if (!_318)
    goto _jump893;
    int64_t _320;
    // Computing bound for m
    if (i.d1 > 0) 
    goto _jump894;
    fail_assertion("non-positive loop bound");
    _jump894:;
    // Computing bound for n
    if (h > 0) 
    goto _jump895;
    fail_assertion("non-positive loop bound");
    _jump895:;
    _320 = 0;
    int64_t _321 = 0; // n
    int64_t _322 = 0; // m
    _jump896:; // Begin body of loop
    _320 += d;
    _321++;
    if (_321 < h)
    goto _jump896;
    _321 = 0;
    _322++;
    if (_322 < i.d1)
    goto _jump896;
    // End body of loop
    _319 = _320;
    goto _jump897;
    _jump893:;
    _319 = d;
    _jump897:;
    _316.d2 = _319;
    if (_319 > 0) 
    goto _jump898;
    fail_assertion("non-positive loop bound");
    _jump898:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= _317;
    _323 *= i.d2;
    _323 *= _319;
    _323 *= sizeof(int64_t);
    _316.data = jpl_alloc(_323);
    int64_t _324 = 0; // o
    int64_t _325 = 0; // n
    int64_t _326 = 0; // m
    _jump899:; // Begin body of loop
    int64_t _327 = 0;
    _327 *= _316.d0;
    _327 += _326;
    _327 *= _316.d1;
    _327 += _325;
    _327 *= _316.d2;
    _327 += _324;
    _316.data[_327] = i.d2;
    _324++;
    if (_324 < _319)
    goto _jump899;
    _324 = 0;
    _325++;
    if (_325 < i.d2)
    goto _jump899;
    _325 = 0;
    _326++;
    if (_326 < _317)
    goto _jump899;
    // End body of loop
    int64_t _328;
    // Computing bound for m
    if (h > 0) 
    goto _jump900;
    fail_assertion("non-positive loop bound");
    _jump900:;
    // Computing bound for n
    int64_t _329 = 468;
    if (_329 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing bound for o
    int64_t _330 = -i.d2;
    if (_330 > 0) 
    goto _jump902;
    fail_assertion("non-positive loop bound");
    _jump902:;
    _328 = 0;
    int64_t _331 = 0; // o
    int64_t _332 = 0; // n
    int64_t _333 = 0; // m
    _jump903:; // Begin body of loop
    _328 += _331;
    _331++;
    if (_331 < _330)
    goto _jump903;
    _331 = 0;
    _332++;
    if (_332 < _329)
    goto _jump903;
    _332 = 0;
    _333++;
    if (_333 < h)
    goto _jump903;
    // End body of loop
    if (h >= 0)
    goto _jump904;
    fail_assertion("negative array index");
    _jump904:;
    if (h < _316.d0)
    goto _jump905;
    fail_assertion("index too large");
    _jump905:;
    if (_328 >= 0)
    goto _jump906;
    fail_assertion("negative array index");
    _jump906:;
    if (_328 < _316.d1)
    goto _jump907;
    fail_assertion("index too large");
    _jump907:;
    if (i.d2 >= 0)
    goto _jump908;
    fail_assertion("negative array index");
    _jump908:;
    if (i.d2 < _316.d2)
    goto _jump909;
    fail_assertion("index too large");
    _jump909:;
    int64_t _334 = 0;
    _334 *= _316.d0;
    _334 += h;
    _334 *= _316.d1;
    _334 += _328;
    _334 *= _316.d2;
    _334 += i.d2;
    int64_t _335 = _316.data[_334];
    if (_335 > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for n
    if (i.d2 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    _315 = 0;
    int64_t _336 = 0; // n
    int64_t _337 = 0; // m
    _jump912:; // Begin body of loop
    _a3_int64_t _338;
    // Computing bound for o
    int64_t _339;
    // Computing bound for o
    int64_t _340;
    // Computing bound for o
    if (d > 0) 
    goto _jump913;
    fail_assertion("non-positive loop bound");
    _jump913:;
    // Computing bound for p
    if (h > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    _340 = 0;
    int64_t _341 = 0; // p
    int64_t _342 = 0; // o
    _jump915:; // Begin body of loop
    int64_t _343 = 542;
    _340 += _343;
    _341++;
    if (_341 < h)
    goto _jump915;
    _341 = 0;
    _342++;
    if (_342 < d)
    goto _jump915;
    // End body of loop
    if (_340 > 0) 
    goto _jump916;
    fail_assertion("non-positive loop bound");
    _jump916:;
    // Computing bound for p
    if (i.d2 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for q
    if (i.d1 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    _339 = 0;
    int64_t _344 = 0; // q
    int64_t _345 = 0; // p
    int64_t _346 = 0; // o
    _jump919:; // Begin body of loop
    _339 += _337;
    _344++;
    if (_344 < i.d1)
    goto _jump919;
    _344 = 0;
    _345++;
    if (_345 < i.d2)
    goto _jump919;
    _345 = 0;
    _346++;
    if (_346 < _340)
    goto _jump919;
    // End body of loop
    _338.d0 = _339;
    if (_339 > 0) 
    goto _jump920;
    fail_assertion("non-positive loop bound");
    _jump920:;
    // Computing bound for p
    bool _347 = true;
    bool _348 = !_347;
    int64_t _349;
    if (!_348)
    goto _jump921;
    _349 = _337;
    goto _jump922;
    _jump921:;
    int64_t _350;
    // Computing bound for o
    if (d > 0) 
    goto _jump923;
    fail_assertion("non-positive loop bound");
    _jump923:;
    _350 = 0;
    int64_t _351 = 0; // o
    _jump924:; // Begin body of loop
    _350 += i.d2;
    _351++;
    if (_351 < d)
    goto _jump924;
    // End body of loop
    _349 = _350;
    _jump922:;
    _338.d1 = _349;
    if (_349 > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    // Computing bound for q
    _338.d2 = d;
    if (d > 0) 
    goto _jump926;
    fail_assertion("non-positive loop bound");
    _jump926:;
    // Computing total size of heap memory to allocate
    int64_t _352 = 1;
    _352 *= _339;
    _352 *= _349;
    _352 *= d;
    _352 *= sizeof(int64_t);
    _338.data = jpl_alloc(_352);
    int64_t _353 = 0; // q
    int64_t _354 = 0; // p
    int64_t _355 = 0; // o
    _jump927:; // Begin body of loop
    bool _356 = false;
    bool _357 = !_356;
    int64_t _358;
    if (!_357)
    goto _jump928;
    _358 = _353;
    goto _jump929;
    _jump928:;
    _358 = _337;
    _jump929:;
    int64_t _359 = 0;
    _359 *= _338.d0;
    _359 += _355;
    _359 *= _338.d1;
    _359 += _354;
    _359 *= _338.d2;
    _359 += _353;
    _338.data[_359] = _358;
    _353++;
    if (_353 < d)
    goto _jump927;
    _353 = 0;
    _354++;
    if (_354 < _349)
    goto _jump927;
    _354 = 0;
    _355++;
    if (_355 < _339)
    goto _jump927;
    // End body of loop
    int64_t _360;
    // Computing bound for o
    int64_t _361 = -d;
    if (_361 > 0) 
    goto _jump930;
    fail_assertion("non-positive loop bound");
    _jump930:;
    // Computing bound for p
    if (h > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    _360 = 0;
    int64_t _362 = 0; // p
    int64_t _363 = 0; // o
    _jump932:; // Begin body of loop
    bool _364 = d == d;
    int64_t _365;
    if (!_364)
    goto _jump933;
    _365 = _362;
    goto _jump934;
    _jump933:;
    _365 = i.d1;
    _jump934:;
    _360 += _365;
    _362++;
    if (_362 < h)
    goto _jump932;
    _362 = 0;
    _363++;
    if (_363 < _361)
    goto _jump932;
    // End body of loop
    int64_t _366 = -i.d2;
    if (_360 >= 0)
    goto _jump935;
    fail_assertion("negative array index");
    _jump935:;
    if (_360 < _338.d0)
    goto _jump936;
    fail_assertion("index too large");
    _jump936:;
    if (_366 >= 0)
    goto _jump937;
    fail_assertion("negative array index");
    _jump937:;
    if (_366 < _338.d1)
    goto _jump938;
    fail_assertion("index too large");
    _jump938:;
    if (i.d0 >= 0)
    goto _jump939;
    fail_assertion("negative array index");
    _jump939:;
    if (i.d0 < _338.d2)
    goto _jump940;
    fail_assertion("index too large");
    _jump940:;
    int64_t _367 = 0;
    _367 *= _338.d0;
    _367 += _360;
    _367 *= _338.d1;
    _367 += _366;
    _367 *= _338.d2;
    _367 += i.d0;
    int64_t _368 = _338.data[_367];
    _315 += _368;
    _336++;
    if (_336 < i.d2)
    goto _jump912;
    _336 = 0;
    _337++;
    if (_337 < _335)
    goto _jump912;
    // End body of loop
    if (_315 > 0) 
    goto _jump941;
    fail_assertion("non-positive loop bound");
    _jump941:;
    _314 = 0;
    int64_t _369 = 0; // m
    _jump942:; // Begin body of loop
    _314 += h;
    _369++;
    if (_369 < _315)
    goto _jump942;
    // End body of loop
    _a3_int64_t _370;
    // Computing bound for m
    _370.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    // Computing bound for n
    _a3_int64_t _371;
    // Computing bound for m
    _371.d0 = h;
    if (h > 0) 
    goto _jump944;
    fail_assertion("non-positive loop bound");
    _jump944:;
    // Computing bound for n
    _371.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    // Computing bound for o
    int64_t _372 = 263;
    if (i.d2 >= 0)
    goto _jump946;
    fail_assertion("negative array index");
    _jump946:;
    if (i.d2 < i.d0)
    goto _jump947;
    fail_assertion("index too large");
    _jump947:;
    if (i.d1 >= 0)
    goto _jump948;
    fail_assertion("negative array index");
    _jump948:;
    if (i.d1 < i.d1)
    goto _jump949;
    fail_assertion("index too large");
    _jump949:;
    if (_372 >= 0)
    goto _jump950;
    fail_assertion("negative array index");
    _jump950:;
    if (_372 < i.d2)
    goto _jump951;
    fail_assertion("index too large");
    _jump951:;
    int64_t _373 = 0;
    _373 *= i.d0;
    _373 += i.d2;
    _373 *= i.d1;
    _373 += i.d1;
    _373 *= i.d2;
    _373 += _372;
    bool _374 = i.data[_373];
    int64_t _375;
    if (!_374)
    goto _jump952;
    _375 = i.d1;
    goto _jump953;
    _jump952:;
    _375 = i.d1;
    _jump953:;
    _371.d2 = _375;
    if (_375 > 0) 
    goto _jump954;
    fail_assertion("non-positive loop bound");
    _jump954:;
    // Computing total size of heap memory to allocate
    int64_t _376 = 1;
    _376 *= h;
    _376 *= i.d0;
    _376 *= _375;
    _376 *= sizeof(int64_t);
    _371.data = jpl_alloc(_376);
    int64_t _377 = 0; // o
    int64_t _378 = 0; // n
    int64_t _379 = 0; // m
    _jump955:; // Begin body of loop
    a _380 = { i.d1, g };
    int64_t _381 = _380.a;
    int64_t _382 = 0;
    _382 *= _371.d0;
    _382 += _379;
    _382 *= _371.d1;
    _382 += _378;
    _382 *= _371.d2;
    _382 += _377;
    _371.data[_382] = _381;
    _377++;
    if (_377 < _375)
    goto _jump955;
    _377 = 0;
    _378++;
    if (_378 < i.d0)
    goto _jump955;
    _378 = 0;
    _379++;
    if (_379 < h)
    goto _jump955;
    // End body of loop
    int64_t _383 = -i.d2;
    if (_383 >= 0)
    goto _jump956;
    fail_assertion("negative array index");
    _jump956:;
    if (_383 < _371.d0)
    goto _jump957;
    fail_assertion("index too large");
    _jump957:;
    if (d >= 0)
    goto _jump958;
    fail_assertion("negative array index");
    _jump958:;
    if (d < _371.d1)
    goto _jump959;
    fail_assertion("index too large");
    _jump959:;
    if (i.d1 >= 0)
    goto _jump960;
    fail_assertion("negative array index");
    _jump960:;
    if (i.d1 < _371.d2)
    goto _jump961;
    fail_assertion("index too large");
    _jump961:;
    int64_t _384 = 0;
    _384 *= _371.d0;
    _384 += _383;
    _384 *= _371.d1;
    _384 += d;
    _384 *= _371.d2;
    _384 += i.d1;
    int64_t _385 = _371.data[_384];
    _370.d1 = _385;
    if (_385 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing bound for o
    _a3_int64_t _386;
    // Computing bound for m
    bool _387 = i.d1 <= i.d2;
    int64_t _388;
    if (!_387)
    goto _jump963;
    int64_t _389 = 72;
    int64_t _390 = -_389;
    _388 = _390;
    goto _jump964;
    _jump963:;
    int64_t _391 = 802;
    _388 = _391;
    _jump964:;
    _386.d0 = _388;
    if (_388 > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    // Computing bound for n
    _386.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump966;
    fail_assertion("non-positive loop bound");
    _jump966:;
    // Computing bound for o
    _386.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump967;
    fail_assertion("non-positive loop bound");
    _jump967:;
    // Computing total size of heap memory to allocate
    int64_t _392 = 1;
    _392 *= _388;
    _392 *= i.d2;
    _392 *= i.d0;
    _392 *= sizeof(int64_t);
    _386.data = jpl_alloc(_392);
    int64_t _393 = 0; // o
    int64_t _394 = 0; // n
    int64_t _395 = 0; // m
    _jump968:; // Begin body of loop
    int64_t _396;
    // Computing bound for p
    if (d > 0) 
    goto _jump969;
    fail_assertion("non-positive loop bound");
    _jump969:;
    // Computing bound for q
    if (i.d2 > 0) 
    goto _jump970;
    fail_assertion("non-positive loop bound");
    _jump970:;
    // Computing bound for r
    if (i.d2 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    _396 = 0;
    int64_t _397 = 0; // r
    int64_t _398 = 0; // q
    int64_t _399 = 0; // p
    _jump972:; // Begin body of loop
    int64_t _400 = 447;
    _396 += _400;
    _397++;
    if (_397 < i.d2)
    goto _jump972;
    _397 = 0;
    _398++;
    if (_398 < i.d2)
    goto _jump972;
    _398 = 0;
    _399++;
    if (_399 < d)
    goto _jump972;
    // End body of loop
    int64_t _401 = -_396;
    int64_t _402 = 0;
    _402 *= _386.d0;
    _402 += _395;
    _402 *= _386.d1;
    _402 += _394;
    _402 *= _386.d2;
    _402 += _393;
    _386.data[_402] = _401;
    _393++;
    if (_393 < i.d0)
    goto _jump968;
    _393 = 0;
    _394++;
    if (_394 < i.d2)
    goto _jump968;
    _394 = 0;
    _395++;
    if (_395 < _388)
    goto _jump968;
    // End body of loop
    int64_t _403 = 365;
    _a3_int64_t _404;
    // Computing bound for m
    _404.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for n
    _404.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing bound for o
    _404.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump975;
    fail_assertion("non-positive loop bound");
    _jump975:;
    // Computing total size of heap memory to allocate
    int64_t _405 = 1;
    _405 *= i.d2;
    _405 *= i.d2;
    _405 *= i.d0;
    _405 *= sizeof(int64_t);
    _404.data = jpl_alloc(_405);
    int64_t _406 = 0; // o
    int64_t _407 = 0; // n
    int64_t _408 = 0; // m
    _jump976:; // Begin body of loop
    int64_t _409 = 0;
    _409 *= _404.d0;
    _409 += _408;
    _409 *= _404.d1;
    _409 += _407;
    _409 *= _404.d2;
    _409 += _406;
    _404.data[_409] = i.d1;
    _406++;
    if (_406 < i.d0)
    goto _jump976;
    _406 = 0;
    _407++;
    if (_407 < i.d2)
    goto _jump976;
    _407 = 0;
    _408++;
    if (_408 < i.d2)
    goto _jump976;
    // End body of loop
    int64_t _410 = d % i.d1;
    int64_t _411 = 134;
    int64_t _412 = 408;
    int64_t _413 = i.d2 * _412;
    if (_410 >= 0)
    goto _jump977;
    fail_assertion("negative array index");
    _jump977:;
    if (_410 < _404.d0)
    goto _jump978;
    fail_assertion("index too large");
    _jump978:;
    if (_411 >= 0)
    goto _jump979;
    fail_assertion("negative array index");
    _jump979:;
    if (_411 < _404.d1)
    goto _jump980;
    fail_assertion("index too large");
    _jump980:;
    if (_413 >= 0)
    goto _jump981;
    fail_assertion("negative array index");
    _jump981:;
    if (_413 < _404.d2)
    goto _jump982;
    fail_assertion("index too large");
    _jump982:;
    int64_t _414 = 0;
    _414 *= _404.d0;
    _414 += _410;
    _414 *= _404.d1;
    _414 += _411;
    _414 *= _404.d2;
    _414 += _413;
    int64_t _415 = _404.data[_414];
    if (i.d0 >= 0)
    goto _jump983;
    fail_assertion("negative array index");
    _jump983:;
    if (i.d0 < _386.d0)
    goto _jump984;
    fail_assertion("index too large");
    _jump984:;
    if (_403 >= 0)
    goto _jump985;
    fail_assertion("negative array index");
    _jump985:;
    if (_403 < _386.d1)
    goto _jump986;
    fail_assertion("index too large");
    _jump986:;
    if (_415 >= 0)
    goto _jump987;
    fail_assertion("negative array index");
    _jump987:;
    if (_415 < _386.d2)
    goto _jump988;
    fail_assertion("index too large");
    _jump988:;
    int64_t _416 = 0;
    _416 *= _386.d0;
    _416 += i.d0;
    _416 *= _386.d1;
    _416 += _403;
    _416 *= _386.d2;
    _416 += _415;
    int64_t _417 = _386.data[_416];
    _370.d2 = _417;
    if (_417 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing total size of heap memory to allocate
    int64_t _418 = 1;
    _418 *= i.d2;
    _418 *= _385;
    _418 *= _417;
    _418 *= sizeof(int64_t);
    _370.data = jpl_alloc(_418);
    int64_t _419 = 0; // o
    int64_t _420 = 0; // n
    int64_t _421 = 0; // m
    _jump990:; // Begin body of loop
    bool _422 = true;
    int64_t _423;
    if (!_422)
    goto _jump991;
    _423 = h;
    goto _jump992;
    _jump991:;
    _423 = h;
    _jump992:;
    int64_t _424 = i.d2 / _423;
    int64_t _425 = 0;
    _425 *= _370.d0;
    _425 += _421;
    _425 *= _370.d1;
    _425 += _420;
    _425 *= _370.d2;
    _425 += _419;
    _370.data[_425] = _424;
    _419++;
    if (_419 < _417)
    goto _jump990;
    _419 = 0;
    _420++;
    if (_420 < _385)
    goto _jump990;
    _420 = 0;
    _421++;
    if (_421 < i.d2)
    goto _jump990;
    // End body of loop
    int64_t _427 = 277;
    bool _428 = _427 != i.d0;
    bool _426 = _428;
    if (0 == _428)
    goto _jump993;
    int64_t _429 = 589;
    bool _430 = i.d0 < _429;
    _426 = _430;
    _jump993:;
    _a2_bool _431;
    if (!_426)
    goto _jump994;
    _a2_bool _432;
    // Computing bound for m
    int64_t _433 = i.d2 % i.d1;
    _432.d0 = _433;
    if (_433 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    // Computing bound for n
    _432.d1 = h;
    if (h > 0) 
    goto _jump996;
    fail_assertion("non-positive loop bound");
    _jump996:;
    // Computing total size of heap memory to allocate
    int64_t _434 = 1;
    _434 *= _433;
    _434 *= h;
    _434 *= sizeof(bool);
    _432.data = jpl_alloc(_434);
    int64_t _435 = 0; // n
    int64_t _436 = 0; // m
    _jump997:; // Begin body of loop
    bool _437 = false;
    int64_t _438 = 0;
    _438 *= _432.d0;
    _438 += _436;
    _438 *= _432.d1;
    _438 += _435;
    _432.data[_438] = _437;
    _435++;
    if (_435 < h)
    goto _jump997;
    _435 = 0;
    _436++;
    if (_436 < _433)
    goto _jump997;
    // End body of loop
    _431 = _432;
    goto _jump998;
    _jump994:;
    _a2_bool _439;
    // Computing bound for m
    _439.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump999;
    fail_assertion("non-positive loop bound");
    _jump999:;
    // Computing bound for n
    _439.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing total size of heap memory to allocate
    int64_t _440 = 1;
    _440 *= i.d1;
    _440 *= i.d0;
    _440 *= sizeof(bool);
    _439.data = jpl_alloc(_440);
    int64_t _441 = 0; // n
    int64_t _442 = 0; // m
    _jump1001:; // Begin body of loop
    bool _443 = i.d0 >= i.d0;
    int64_t _444 = 0;
    _444 *= _439.d0;
    _444 += _442;
    _444 *= _439.d1;
    _444 += _441;
    _439.data[_444] = _443;
    _441++;
    if (_441 < i.d0)
    goto _jump1001;
    _441 = 0;
    _442++;
    if (_442 < i.d1)
    goto _jump1001;
    // End body of loop
    _431 = _439;
    _jump998:;
    _a2_int64_t _445;
    // Computing bound for m
    _445.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1002;
    fail_assertion("non-positive loop bound");
    _jump1002:;
    // Computing bound for n
    int64_t _446 = 752;
    _445.d1 = _446;
    if (_446 > 0) 
    goto _jump1003;
    fail_assertion("non-positive loop bound");
    _jump1003:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= i.d1;
    _447 *= _446;
    _447 *= sizeof(int64_t);
    _445.data = jpl_alloc(_447);
    int64_t _448 = 0; // n
    int64_t _449 = 0; // m
    _jump1004:; // Begin body of loop
    int64_t _450 = 0;
    _450 *= _445.d0;
    _450 += _449;
    _450 *= _445.d1;
    _450 += _448;
    _445.data[_450] = i.d0;
    _448++;
    if (_448 < _446)
    goto _jump1004;
    _448 = 0;
    _449++;
    if (_449 < i.d1)
    goto _jump1004;
    // End body of loop
    int64_t _451 = 589;
    _a3_int64_t _452;
    // Computing bound for m
    _452.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing bound for n
    _452.d1 = d;
    if (d > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    // Computing bound for o
    int64_t _453 = 122;
    _452.d2 = _453;
    if (_453 > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing total size of heap memory to allocate
    int64_t _454 = 1;
    _454 *= i.d2;
    _454 *= d;
    _454 *= _453;
    _454 *= sizeof(int64_t);
    _452.data = jpl_alloc(_454);
    int64_t _455 = 0; // o
    int64_t _456 = 0; // n
    int64_t _457 = 0; // m
    _jump1008:; // Begin body of loop
    int64_t _458 = 0;
    _458 *= _452.d0;
    _458 += _457;
    _458 *= _452.d1;
    _458 += _456;
    _458 *= _452.d2;
    _458 += _455;
    _452.data[_458] = _457;
    _455++;
    if (_455 < _453)
    goto _jump1008;
    _455 = 0;
    _456++;
    if (_456 < d)
    goto _jump1008;
    _456 = 0;
    _457++;
    if (_457 < i.d2)
    goto _jump1008;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump1009;
    fail_assertion("negative array index");
    _jump1009:;
    if (i.d0 < _452.d0)
    goto _jump1010;
    fail_assertion("index too large");
    _jump1010:;
    if (i.d2 >= 0)
    goto _jump1011;
    fail_assertion("negative array index");
    _jump1011:;
    if (i.d2 < _452.d1)
    goto _jump1012;
    fail_assertion("index too large");
    _jump1012:;
    if (d >= 0)
    goto _jump1013;
    fail_assertion("negative array index");
    _jump1013:;
    if (d < _452.d2)
    goto _jump1014;
    fail_assertion("index too large");
    _jump1014:;
    int64_t _459 = 0;
    _459 *= _452.d0;
    _459 += i.d0;
    _459 *= _452.d1;
    _459 += i.d2;
    _459 *= _452.d2;
    _459 += d;
    int64_t _460 = _452.data[_459];
    if (_451 >= 0)
    goto _jump1015;
    fail_assertion("negative array index");
    _jump1015:;
    if (_451 < _445.d0)
    goto _jump1016;
    fail_assertion("index too large");
    _jump1016:;
    if (_460 >= 0)
    goto _jump1017;
    fail_assertion("negative array index");
    _jump1017:;
    if (_460 < _445.d1)
    goto _jump1018;
    fail_assertion("index too large");
    _jump1018:;
    int64_t _461 = 0;
    _461 *= _445.d0;
    _461 += _451;
    _461 *= _445.d1;
    _461 += _460;
    int64_t _462 = _445.data[_461];
    if (i.d1 >= 0)
    goto _jump1019;
    fail_assertion("negative array index");
    _jump1019:;
    if (i.d1 < _431.d0)
    goto _jump1020;
    fail_assertion("index too large");
    _jump1020:;
    if (_462 >= 0)
    goto _jump1021;
    fail_assertion("negative array index");
    _jump1021:;
    if (_462 < _431.d1)
    goto _jump1022;
    fail_assertion("index too large");
    _jump1022:;
    int64_t _463 = 0;
    _463 *= _431.d0;
    _463 += i.d1;
    _463 *= _431.d1;
    _463 += _462;
    bool _464 = _431.data[_463];
    int64_t _465;
    if (!_464)
    goto _jump1023;
    int64_t _466 = -i.d0;
    if (_466 >= 0)
    goto _jump1024;
    fail_assertion("negative array index");
    _jump1024:;
    if (_466 < i.d0)
    goto _jump1025;
    fail_assertion("index too large");
    _jump1025:;
    if (i.d2 >= 0)
    goto _jump1026;
    fail_assertion("negative array index");
    _jump1026:;
    if (i.d2 < i.d1)
    goto _jump1027;
    fail_assertion("index too large");
    _jump1027:;
    if (d >= 0)
    goto _jump1028;
    fail_assertion("negative array index");
    _jump1028:;
    if (d < i.d2)
    goto _jump1029;
    fail_assertion("index too large");
    _jump1029:;
    int64_t _467 = 0;
    _467 *= i.d0;
    _467 += _466;
    _467 *= i.d1;
    _467 += i.d2;
    _467 *= i.d2;
    _467 += d;
    bool _468 = i.data[_467];
    int64_t _469;
    if (!_468)
    goto _jump1030;
    _469 = i.d1;
    goto _jump1031;
    _jump1030:;
    _469 = i.d1;
    _jump1031:;
    int64_t _470 = -_469;
    _465 = _470;
    goto _jump1032;
    _jump1023:;
    int64_t _471 = -i.d0;
    _465 = _471;
    _jump1032:;
    _a1_void_t _472;
    // Computing bound for m
    _472.d0 = h;
    if (h > 0) 
    goto _jump1033;
    fail_assertion("non-positive loop bound");
    _jump1033:;
    // Computing total size of heap memory to allocate
    int64_t _473 = 1;
    _473 *= h;
    _473 *= sizeof(void_t);
    _472.data = jpl_alloc(_473);
    int64_t _474 = 0; // m
    _jump1034:; // Begin body of loop
    int64_t _475 = 0;
    _475 *= _472.d0;
    _475 += _474;
    _472.data[_475] = g;
    _474++;
    if (_474 < h)
    goto _jump1034;
    // End body of loop
    if (i.d1 >= 0)
    goto _jump1035;
    fail_assertion("negative array index");
    _jump1035:;
    if (i.d1 < _472.d0)
    goto _jump1036;
    fail_assertion("index too large");
    _jump1036:;
    int64_t _476 = 0;
    _476 *= _472.d0;
    _476 += i.d1;
    void_t _477 = _472.data[_476];
    _a3_bool _478;
    // Computing bound for m
    _478.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump1037;
    fail_assertion("non-positive loop bound");
    _jump1037:;
    // Computing bound for n
    int64_t _479 = i.d1 * h;
    int64_t _480 = d / _479;
    _478.d1 = _480;
    if (_480 > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    // Computing bound for o
    int64_t _481 = 994;
    if (d >= 0)
    goto _jump1039;
    fail_assertion("negative array index");
    _jump1039:;
    if (d < i.d0)
    goto _jump1040;
    fail_assertion("index too large");
    _jump1040:;
    if (_481 >= 0)
    goto _jump1041;
    fail_assertion("negative array index");
    _jump1041:;
    if (_481 < i.d1)
    goto _jump1042;
    fail_assertion("index too large");
    _jump1042:;
    if (h >= 0)
    goto _jump1043;
    fail_assertion("negative array index");
    _jump1043:;
    if (h < i.d2)
    goto _jump1044;
    fail_assertion("index too large");
    _jump1044:;
    int64_t _482 = 0;
    _482 *= i.d0;
    _482 += d;
    _482 *= i.d1;
    _482 += _481;
    _482 *= i.d2;
    _482 += h;
    bool _483 = i.data[_482];
    int64_t _484;
    if (!_483)
    goto _jump1045;
    _484 = i.d0;
    goto _jump1046;
    _jump1045:;
    _484 = d;
    _jump1046:;
    _478.d2 = _484;
    if (_484 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    // Computing total size of heap memory to allocate
    int64_t _485 = 1;
    _485 *= i.d2;
    _485 *= _480;
    _485 *= _484;
    _485 *= sizeof(bool);
    _478.data = jpl_alloc(_485);
    int64_t _486 = 0; // o
    int64_t _487 = 0; // n
    int64_t _488 = 0; // m
    _jump1048:; // Begin body of loop
    bool _489 = true;
    int64_t _490;
    if (!_489)
    goto _jump1049;
    _490 = i.d1;
    goto _jump1050;
    _jump1049:;
    _490 = _486;
    _jump1050:;
    bool _491 = _486 >= _490;
    int64_t _492 = 0;
    _492 *= _478.d0;
    _492 += _488;
    _492 *= _478.d1;
    _492 += _487;
    _492 *= _478.d2;
    _492 += _486;
    _478.data[_492] = _491;
    _486++;
    if (_486 < _484)
    goto _jump1048;
    _486 = 0;
    _487++;
    if (_487 < _480)
    goto _jump1048;
    _487 = 0;
    _488++;
    if (_488 < i.d2)
    goto _jump1048;
    // End body of loop
    a _493 = f(_477, i.d2, _478);
    int64_t _494 = _493.a;
    if (_465 >= 0)
    goto _jump1051;
    fail_assertion("negative array index");
    _jump1051:;
    if (_465 < _370.d0)
    goto _jump1052;
    fail_assertion("index too large");
    _jump1052:;
    if (i.d2 >= 0)
    goto _jump1053;
    fail_assertion("negative array index");
    _jump1053:;
    if (i.d2 < _370.d1)
    goto _jump1054;
    fail_assertion("index too large");
    _jump1054:;
    if (_494 >= 0)
    goto _jump1055;
    fail_assertion("negative array index");
    _jump1055:;
    if (_494 < _370.d2)
    goto _jump1056;
    fail_assertion("index too large");
    _jump1056:;
    int64_t _495 = 0;
    _495 *= _370.d0;
    _495 += _465;
    _495 *= _370.d1;
    _495 += i.d2;
    _495 *= _370.d2;
    _495 += _494;
    int64_t _496 = _370.data[_495];
    if (_285 >= 0)
    goto _jump1057;
    fail_assertion("negative array index");
    _jump1057:;
    if (_285 < _240.d0)
    goto _jump1058;
    fail_assertion("index too large");
    _jump1058:;
    if (_314 >= 0)
    goto _jump1059;
    fail_assertion("negative array index");
    _jump1059:;
    if (_314 < _240.d1)
    goto _jump1060;
    fail_assertion("index too large");
    _jump1060:;
    if (_496 >= 0)
    goto _jump1061;
    fail_assertion("negative array index");
    _jump1061:;
    if (_496 < _240.d2)
    goto _jump1062;
    fail_assertion("index too large");
    _jump1062:;
    int64_t _497 = 0;
    _497 *= _240.d0;
    _497 += _285;
    _497 *= _240.d1;
    _497 += _314;
    _497 *= _240.d2;
    _497 += _496;
    bool _498 = _240.data[_497];
    if (0 != _498)
    goto _jump1063;
    fail_assertion("m");
    _jump1063:;
    double _499 = 92.0;
    bool _500 = true;
    _a2_double _501;
    if (!_500)
    goto _jump1064;
    _a2_double _502;
    // Computing bound for m
    int64_t _503;
    // Computing bound for m
    if (i.d2 > 0) 
    goto _jump1065;
    fail_assertion("non-positive loop bound");
    _jump1065:;
    // Computing bound for n
    if (i.d0 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    _503 = 0;
    int64_t _504 = 0; // n
    int64_t _505 = 0; // m
    _jump1067:; // Begin body of loop
    int64_t _506;
    // Computing bound for o
    if (h > 0) 
    goto _jump1068;
    fail_assertion("non-positive loop bound");
    _jump1068:;
    // Computing bound for p
    int64_t _507 = 103;
    int64_t _508 = -_507;
    if (_508 > 0) 
    goto _jump1069;
    fail_assertion("non-positive loop bound");
    _jump1069:;
    _506 = 0;
    int64_t _509 = 0; // p
    int64_t _510 = 0; // o
    _jump1070:; // Begin body of loop
    _506 += _509;
    _509++;
    if (_509 < _508)
    goto _jump1070;
    _509 = 0;
    _510++;
    if (_510 < h)
    goto _jump1070;
    // End body of loop
    _503 += _506;
    _504++;
    if (_504 < i.d0)
    goto _jump1067;
    _504 = 0;
    _505++;
    if (_505 < i.d2)
    goto _jump1067;
    // End body of loop
    _502.d0 = _503;
    if (_503 > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing bound for n
    int64_t _511 = 216;
    _502.d1 = _511;
    if (_511 > 0) 
    goto _jump1072;
    fail_assertion("non-positive loop bound");
    _jump1072:;
    // Computing total size of heap memory to allocate
    int64_t _512 = 1;
    _512 *= _503;
    _512 *= _511;
    _512 *= sizeof(double);
    _502.data = jpl_alloc(_512);
    int64_t _513 = 0; // n
    int64_t _514 = 0; // m
    _jump1073:; // Begin body of loop
    double _515 = 6.0;
    double _516 = -_515;
    double _517;
    // Computing bound for o
    bool _518 = false;
    int64_t _519;
    if (!_518)
    goto _jump1074;
    _519 = i.d1;
    goto _jump1075;
    _jump1074:;
    _519 = _513;
    _jump1075:;
    if (_519 > 0) 
    goto _jump1076;
    fail_assertion("non-positive loop bound");
    _jump1076:;
    // Computing bound for p
    int64_t _520 = -i.d1;
    if (_520 > 0) 
    goto _jump1077;
    fail_assertion("non-positive loop bound");
    _jump1077:;
    // Computing bound for q
    int64_t _521;
    // Computing bound for o
    if (i.d2 > 0) 
    goto _jump1078;
    fail_assertion("non-positive loop bound");
    _jump1078:;
    // Computing bound for p
    if (_513 > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    _521 = 0;
    int64_t _522 = 0; // p
    int64_t _523 = 0; // o
    _jump1080:; // Begin body of loop
    _521 += d;
    _522++;
    if (_522 < _513)
    goto _jump1080;
    _522 = 0;
    _523++;
    if (_523 < i.d2)
    goto _jump1080;
    // End body of loop
    if (_521 > 0) 
    goto _jump1081;
    fail_assertion("non-positive loop bound");
    _jump1081:;
    _517 = 0;
    int64_t _524 = 0; // q
    int64_t _525 = 0; // p
    int64_t _526 = 0; // o
    _jump1082:; // Begin body of loop
    double _527 = 21.0;
    _517 += _527;
    _524++;
    if (_524 < _521)
    goto _jump1082;
    _524 = 0;
    _525++;
    if (_525 < _520)
    goto _jump1082;
    _525 = 0;
    _526++;
    if (_526 < _519)
    goto _jump1082;
    // End body of loop
    double _528 = fmod(_516, _517);
    int64_t _529 = 0;
    _529 *= _502.d0;
    _529 += _514;
    _529 *= _502.d1;
    _529 += _513;
    _502.data[_529] = _528;
    _513++;
    if (_513 < _511)
    goto _jump1073;
    _513 = 0;
    _514++;
    if (_514 < _503)
    goto _jump1073;
    // End body of loop
    _501 = _502;
    goto _jump1083;
    _jump1064:;
    _a3_bool _531;
    // Computing bound for m
    int64_t _532 = 842;
    _531.d0 = _532;
    if (_532 > 0) 
    goto _jump1084;
    fail_assertion("non-positive loop bound");
    _jump1084:;
    // Computing bound for n
    _531.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1085;
    fail_assertion("non-positive loop bound");
    _jump1085:;
    // Computing bound for o
    _531.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1086;
    fail_assertion("non-positive loop bound");
    _jump1086:;
    // Computing total size of heap memory to allocate
    int64_t _533 = 1;
    _533 *= _532;
    _533 *= i.d1;
    _533 *= i.d0;
    _533 *= sizeof(bool);
    _531.data = jpl_alloc(_533);
    int64_t _534 = 0; // o
    int64_t _535 = 0; // n
    int64_t _536 = 0; // m
    _jump1087:; // Begin body of loop
    bool _537 = true;
    int64_t _538 = 0;
    _538 *= _531.d0;
    _538 += _536;
    _538 *= _531.d1;
    _538 += _535;
    _538 *= _531.d2;
    _538 += _534;
    _531.data[_538] = _537;
    _534++;
    if (_534 < i.d0)
    goto _jump1087;
    _534 = 0;
    _535++;
    if (_535 < i.d1)
    goto _jump1087;
    _535 = 0;
    _536++;
    if (_536 < _532)
    goto _jump1087;
    // End body of loop
    if (i.d1 >= 0)
    goto _jump1088;
    fail_assertion("negative array index");
    _jump1088:;
    if (i.d1 < _531.d0)
    goto _jump1089;
    fail_assertion("index too large");
    _jump1089:;
    if (i.d0 >= 0)
    goto _jump1090;
    fail_assertion("negative array index");
    _jump1090:;
    if (i.d0 < _531.d1)
    goto _jump1091;
    fail_assertion("index too large");
    _jump1091:;
    if (d >= 0)
    goto _jump1092;
    fail_assertion("negative array index");
    _jump1092:;
    if (d < _531.d2)
    goto _jump1093;
    fail_assertion("index too large");
    _jump1093:;
    int64_t _539 = 0;
    _539 *= _531.d0;
    _539 += i.d1;
    _539 *= _531.d1;
    _539 += i.d0;
    _539 *= _531.d2;
    _539 += d;
    bool _540 = _531.data[_539];
    bool _530 = _540;
    if (0 != _540)
    goto _jump1094;
    bool _541 = true;
    int64_t _542;
    if (!_541)
    goto _jump1095;
    _542 = i.d1;
    goto _jump1096;
    _jump1095:;
    _542 = h;
    _jump1096:;
    int64_t _543;
    // Computing bound for m
    if (d > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    _543 = 0;
    int64_t _544 = 0; // m
    _jump1098:; // Begin body of loop
    _543 += _544;
    _544++;
    if (_544 < d)
    goto _jump1098;
    // End body of loop
    if (_542 >= 0)
    goto _jump1099;
    fail_assertion("negative array index");
    _jump1099:;
    if (_542 < i.d0)
    goto _jump1100;
    fail_assertion("index too large");
    _jump1100:;
    if (i.d2 >= 0)
    goto _jump1101;
    fail_assertion("negative array index");
    _jump1101:;
    if (i.d2 < i.d1)
    goto _jump1102;
    fail_assertion("index too large");
    _jump1102:;
    if (_543 >= 0)
    goto _jump1103;
    fail_assertion("negative array index");
    _jump1103:;
    if (_543 < i.d2)
    goto _jump1104;
    fail_assertion("index too large");
    _jump1104:;
    int64_t _545 = 0;
    _545 *= i.d0;
    _545 += _542;
    _545 *= i.d1;
    _545 += i.d2;
    _545 *= i.d2;
    _545 += _543;
    bool _546 = i.data[_545];
    _530 = _546;
    _jump1094:;
    _a2_double _547;
    if (!_530)
    goto _jump1105;
    bool _548 = true;
    bool _549;
    if (!_548)
    goto _jump1106;
    bool _550 = d == i.d0;
    _549 = _550;
    goto _jump1107;
    _jump1106:;
    bool _551 = true;
    _549 = _551;
    _jump1107:;
    _a2_double _552;
    if (!_549)
    goto _jump1108;
    _a2_double _553;
    // Computing bound for m
    int64_t _554 = 776;
    _553.d0 = _554;
    if (_554 > 0) 
    goto _jump1109;
    fail_assertion("non-positive loop bound");
    _jump1109:;
    // Computing bound for n
    _553.d1 = h;
    if (h > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing total size of heap memory to allocate
    int64_t _555 = 1;
    _555 *= _554;
    _555 *= h;
    _555 *= sizeof(double);
    _553.data = jpl_alloc(_555);
    int64_t _556 = 0; // n
    int64_t _557 = 0; // m
    _jump1111:; // Begin body of loop
    double _558 = 65.0;
    double _559 = -_558;
    int64_t _560 = 0;
    _560 *= _553.d0;
    _560 += _557;
    _560 *= _553.d1;
    _560 += _556;
    _553.data[_560] = _559;
    _556++;
    if (_556 < h)
    goto _jump1111;
    _556 = 0;
    _557++;
    if (_557 < _554)
    goto _jump1111;
    // End body of loop
    _552 = _553;
    goto _jump1112;
    _jump1108:;
    _a2_double _561;
    // Computing bound for m
    _561.d0 = d;
    if (d > 0) 
    goto _jump1113;
    fail_assertion("non-positive loop bound");
    _jump1113:;
    // Computing bound for n
    _561.d1 = h;
    if (h > 0) 
    goto _jump1114;
    fail_assertion("non-positive loop bound");
    _jump1114:;
    // Computing total size of heap memory to allocate
    int64_t _562 = 1;
    _562 *= d;
    _562 *= h;
    _562 *= sizeof(double);
    _561.data = jpl_alloc(_562);
    int64_t _563 = 0; // n
    int64_t _564 = 0; // m
    _jump1115:; // Begin body of loop
    double _565 = 69.0;
    int64_t _566 = 0;
    _566 *= _561.d0;
    _566 += _564;
    _566 *= _561.d1;
    _566 += _563;
    _561.data[_566] = _565;
    _563++;
    if (_563 < h)
    goto _jump1115;
    _563 = 0;
    _564++;
    if (_564 < d)
    goto _jump1115;
    // End body of loop
    _552 = _561;
    _jump1112:;
    _547 = _552;
    goto _jump1116;
    _jump1105:;
    _a2_double _567;
    // Computing bound for m
    _567.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for n
    _a3_int64_t _568;
    // Computing bound for m
    _568.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    // Computing bound for n
    _568.d1 = h;
    if (h > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing bound for o
    _568.d2 = d;
    if (d > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing total size of heap memory to allocate
    int64_t _569 = 1;
    _569 *= i.d1;
    _569 *= h;
    _569 *= d;
    _569 *= sizeof(int64_t);
    _568.data = jpl_alloc(_569);
    int64_t _570 = 0; // o
    int64_t _571 = 0; // n
    int64_t _572 = 0; // m
    _jump1121:; // Begin body of loop
    int64_t _573 = 0;
    _573 *= _568.d0;
    _573 += _572;
    _573 *= _568.d1;
    _573 += _571;
    _573 *= _568.d2;
    _573 += _570;
    _568.data[_573] = _571;
    _570++;
    if (_570 < d)
    goto _jump1121;
    _570 = 0;
    _571++;
    if (_571 < h)
    goto _jump1121;
    _571 = 0;
    _572++;
    if (_572 < i.d1)
    goto _jump1121;
    // End body of loop
    int64_t _574;
    // Computing bound for m
    if (i.d1 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    // Computing bound for n
    if (h > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    // Computing bound for o
    if (i.d1 > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    _574 = 0;
    int64_t _575 = 0; // o
    int64_t _576 = 0; // n
    int64_t _577 = 0; // m
    _jump1125:; // Begin body of loop
    _574 += i.d0;
    _575++;
    if (_575 < i.d1)
    goto _jump1125;
    _575 = 0;
    _576++;
    if (_576 < h)
    goto _jump1125;
    _576 = 0;
    _577++;
    if (_577 < i.d1)
    goto _jump1125;
    // End body of loop
    int64_t _578 = 712;
    int64_t _579 = -h;
    if (_574 >= 0)
    goto _jump1126;
    fail_assertion("negative array index");
    _jump1126:;
    if (_574 < _568.d0)
    goto _jump1127;
    fail_assertion("index too large");
    _jump1127:;
    if (_578 >= 0)
    goto _jump1128;
    fail_assertion("negative array index");
    _jump1128:;
    if (_578 < _568.d1)
    goto _jump1129;
    fail_assertion("index too large");
    _jump1129:;
    if (_579 >= 0)
    goto _jump1130;
    fail_assertion("negative array index");
    _jump1130:;
    if (_579 < _568.d2)
    goto _jump1131;
    fail_assertion("index too large");
    _jump1131:;
    int64_t _580 = 0;
    _580 *= _568.d0;
    _580 += _574;
    _580 *= _568.d1;
    _580 += _578;
    _580 *= _568.d2;
    _580 += _579;
    int64_t _581 = _568.data[_580];
    _567.d1 = _581;
    if (_581 > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing total size of heap memory to allocate
    int64_t _582 = 1;
    _582 *= i.d1;
    _582 *= _581;
    _582 *= sizeof(double);
    _567.data = jpl_alloc(_582);
    int64_t _583 = 0; // n
    int64_t _584 = 0; // m
    _jump1133:; // Begin body of loop
    double _585 = 35.0;
    int64_t _586 = 0;
    _586 *= _567.d0;
    _586 += _584;
    _586 *= _567.d1;
    _586 += _583;
    _567.data[_586] = _585;
    _583++;
    if (_583 < _581)
    goto _jump1133;
    _583 = 0;
    _584++;
    if (_584 < i.d1)
    goto _jump1133;
    // End body of loop
    _547 = _567;
    _jump1116:;
    _501 = _547;
    _jump1083:;
    int64_t _587 = 50;
    int64_t _588 = -_587;
    int64_t _589;
    // Computing bound for m
    if (d > 0) 
    goto _jump1134;
    fail_assertion("non-positive loop bound");
    _jump1134:;
    // Computing bound for n
    int64_t _590 = 121;
    if (_590 > 0) 
    goto _jump1135;
    fail_assertion("non-positive loop bound");
    _jump1135:;
    _589 = 0;
    int64_t _591 = 0; // n
    int64_t _592 = 0; // m
    _jump1136:; // Begin body of loop
    int64_t _593 = 171;
    _589 += _593;
    _591++;
    if (_591 < _590)
    goto _jump1136;
    _591 = 0;
    _592++;
    if (_592 < d)
    goto _jump1136;
    // End body of loop
    int64_t _594 = -_589;
    _a1_int64_t _595;
    _595.d0 = 2;
    _595.data = jpl_alloc(sizeof(int64_t) * 2);
    _595.data[0] = i.d0;
    _595.data[1] = d;
    _a1_int64_t _596;
    _596.d0 = 1;
    _596.data = jpl_alloc(sizeof(int64_t) * 1);
    _596.data[0] = i.d0;
    a _597 = f(g, i.d0, i);
    a _598 = b(i.d2, _596, _597);
    a _599 = b(_594, _595, _598);
    int64_t _600 = _599.a;
    int64_t _601;
    // Computing bound for m
    int64_t _602 = 572;
    if (_602 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    // Computing bound for n
    if (h > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing bound for o
    int64_t _603 = 230;
    int64_t _604 = -_603;
    _a1_int64_t _605;
    _605.d0 = 2;
    _605.data = jpl_alloc(sizeof(int64_t) * 2);
    _605.data[0] = i.d1;
    _605.data[1] = i.d1;
    a _606 = { i.d0, g };
    a _607 = b(_604, _605, _606);
    int64_t _608 = _607.a;
    if (_608 > 0) 
    goto _jump1139;
    fail_assertion("non-positive loop bound");
    _jump1139:;
    _601 = 0;
    int64_t _609 = 0; // o
    int64_t _610 = 0; // n
    int64_t _611 = 0; // m
    _jump1140:; // Begin body of loop
    _601 += i.d2;
    _609++;
    if (_609 < _608)
    goto _jump1140;
    _609 = 0;
    _610++;
    if (_610 < h)
    goto _jump1140;
    _610 = 0;
    _611++;
    if (_611 < _602)
    goto _jump1140;
    // End body of loop
    int64_t _612 = _600 / _601;
    if (_588 >= 0)
    goto _jump1141;
    fail_assertion("negative array index");
    _jump1141:;
    if (_588 < _501.d0)
    goto _jump1142;
    fail_assertion("index too large");
    _jump1142:;
    if (_612 >= 0)
    goto _jump1143;
    fail_assertion("negative array index");
    _jump1143:;
    if (_612 < _501.d1)
    goto _jump1144;
    fail_assertion("index too large");
    _jump1144:;
    int64_t _613 = 0;
    _613 *= _501.d0;
    _613 += _588;
    _613 *= _501.d1;
    _613 += _612;
    double _614 = _501.data[_613];
    double _615 = 79.0;
    _a2_int64_t _617;
    // Computing bound for m
    int64_t _618 = 788;
    _617.d0 = _618;
    if (_618 > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing bound for n
    _617.d1 = h;
    if (h > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing total size of heap memory to allocate
    int64_t _619 = 1;
    _619 *= _618;
    _619 *= h;
    _619 *= sizeof(int64_t);
    _617.data = jpl_alloc(_619);
    int64_t _620 = 0; // n
    int64_t _621 = 0; // m
    _jump1147:; // Begin body of loop
    int64_t _622 = 0;
    _622 *= _617.d0;
    _622 += _621;
    _622 *= _617.d1;
    _622 += _620;
    _617.data[_622] = i.d1;
    _620++;
    if (_620 < h)
    goto _jump1147;
    _620 = 0;
    _621++;
    if (_621 < _618)
    goto _jump1147;
    // End body of loop
    if (i.d2 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (i.d2 < _617.d0)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    if (d >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (d < _617.d1)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _623 = 0;
    _623 *= _617.d0;
    _623 += i.d2;
    _623 *= _617.d1;
    _623 += d;
    int64_t _624 = _617.data[_623];
    bool _625 = true;
    int64_t _626;
    if (!_625)
    goto _jump1152;
    _626 = i.d1;
    goto _jump1153;
    _jump1152:;
    _626 = i.d1;
    _jump1153:;
    bool _627 = _624 > _626;
    bool _616 = _627;
    if (0 != _627)
    goto _jump1154;
    bool _628 = i.d1 <= h;
    bool _629 = !_628;
    bool _630 = !_629;
    _616 = _630;
    _jump1154:;
    _a2_double _631;
    if (!_616)
    goto _jump1155;
    bool _632 = true;
    bool _633;
    if (!_632)
    goto _jump1156;
    bool _634 = false;
    _633 = _634;
    goto _jump1157;
    _jump1156:;
    bool _635 = false;
    bool _636 = !_635;
    _633 = _636;
    _jump1157:;
    bool _637;
    if (!_633)
    goto _jump1158;
    _a3_bool _638;
    // Computing bound for m
    _638.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    // Computing bound for n
    _638.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing bound for o
    _638.d2 = i.d2;
    if (i.d2 > 0) 
    goto _jump1161;
    fail_assertion("non-positive loop bound");
    _jump1161:;
    // Computing total size of heap memory to allocate
    int64_t _639 = 1;
    _639 *= i.d0;
    _639 *= i.d1;
    _639 *= i.d2;
    _639 *= sizeof(bool);
    _638.data = jpl_alloc(_639);
    int64_t _640 = 0; // o
    int64_t _641 = 0; // n
    int64_t _642 = 0; // m
    _jump1162:; // Begin body of loop
    bool _643 = false;
    int64_t _644 = 0;
    _644 *= _638.d0;
    _644 += _642;
    _644 *= _638.d1;
    _644 += _641;
    _644 *= _638.d2;
    _644 += _640;
    _638.data[_644] = _643;
    _640++;
    if (_640 < i.d2)
    goto _jump1162;
    _640 = 0;
    _641++;
    if (_641 < i.d1)
    goto _jump1162;
    _641 = 0;
    _642++;
    if (_642 < i.d0)
    goto _jump1162;
    // End body of loop
    int64_t _645 = 558;
    int64_t _646 = h / _645;
    int64_t _647 = i.d1 / i.d2;
    int64_t _648;
    // Computing bound for m
    if (i.d0 > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing bound for n
    if (h > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    _648 = 0;
    int64_t _649 = 0; // n
    int64_t _650 = 0; // m
    _jump1165:; // Begin body of loop
    _648 += _649;
    _649++;
    if (_649 < h)
    goto _jump1165;
    _649 = 0;
    _650++;
    if (_650 < i.d0)
    goto _jump1165;
    // End body of loop
    if (_646 >= 0)
    goto _jump1166;
    fail_assertion("negative array index");
    _jump1166:;
    if (_646 < _638.d0)
    goto _jump1167;
    fail_assertion("index too large");
    _jump1167:;
    if (_647 >= 0)
    goto _jump1168;
    fail_assertion("negative array index");
    _jump1168:;
    if (_647 < _638.d1)
    goto _jump1169;
    fail_assertion("index too large");
    _jump1169:;
    if (_648 >= 0)
    goto _jump1170;
    fail_assertion("negative array index");
    _jump1170:;
    if (_648 < _638.d2)
    goto _jump1171;
    fail_assertion("index too large");
    _jump1171:;
    int64_t _651 = 0;
    _651 *= _638.d0;
    _651 += _646;
    _651 *= _638.d1;
    _651 += _647;
    _651 *= _638.d2;
    _651 += _648;
    bool _652 = _638.data[_651];
    _637 = _652;
    goto _jump1172;
    _jump1158:;
    bool _653 = false;
    bool _654 = !_653;
    bool _655 = !_654;
    _637 = _655;
    _jump1172:;
    _a2_double _656;
    if (!_637)
    goto _jump1173;
    _a2_double _657;
    // Computing bound for m
    bool _658 = false;
    bool _659 = !_658;
    int64_t _660;
    if (!_659)
    goto _jump1174;
    _660 = d;
    goto _jump1175;
    _jump1174:;
    int64_t _661 = 24;
    _660 = _661;
    _jump1175:;
    _657.d0 = _660;
    if (_660 > 0) 
    goto _jump1176;
    fail_assertion("non-positive loop bound");
    _jump1176:;
    // Computing bound for n
    int64_t _662 = 184;
    _657.d1 = _662;
    if (_662 > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing total size of heap memory to allocate
    int64_t _663 = 1;
    _663 *= _660;
    _663 *= _662;
    _663 *= sizeof(double);
    _657.data = jpl_alloc(_663);
    int64_t _664 = 0; // n
    int64_t _665 = 0; // m
    _jump1178:; // Begin body of loop
    double _666;
    // Computing bound for o
    if (i.d1 > 0) 
    goto _jump1179;
    fail_assertion("non-positive loop bound");
    _jump1179:;
    _666 = 0;
    int64_t _667 = 0; // o
    _jump1180:; // Begin body of loop
    double _668 = 38.0;
    _666 += _668;
    _667++;
    if (_667 < i.d1)
    goto _jump1180;
    // End body of loop
    double _669 = -_666;
    int64_t _670 = 0;
    _670 *= _657.d0;
    _670 += _665;
    _670 *= _657.d1;
    _670 += _664;
    _657.data[_670] = _669;
    _664++;
    if (_664 < _662)
    goto _jump1178;
    _664 = 0;
    _665++;
    if (_665 < _660)
    goto _jump1178;
    // End body of loop
    _656 = _657;
    goto _jump1181;
    _jump1173:;
    bool _671 = i.d2 == d;
    bool _672 = true;
    bool _673 = _671 == _672;
    _a2_double _674;
    if (!_673)
    goto _jump1182;
    double _675 = 95.0;
    double _676 = 49.0;
    bool _677 = _675 != _676;
    _a2_double _678;
    if (!_677)
    goto _jump1183;
    _a2_double _679;
    // Computing bound for m
    _679.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1184;
    fail_assertion("non-positive loop bound");
    _jump1184:;
    // Computing bound for n
    _679.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump1185;
    fail_assertion("non-positive loop bound");
    _jump1185:;
    // Computing total size of heap memory to allocate
    int64_t _680 = 1;
    _680 *= i.d0;
    _680 *= i.d2;
    _680 *= sizeof(double);
    _679.data = jpl_alloc(_680);
    int64_t _681 = 0; // n
    int64_t _682 = 0; // m
    _jump1186:; // Begin body of loop
    double _683 = 14.0;
    int64_t _684 = 0;
    _684 *= _679.d0;
    _684 += _682;
    _684 *= _679.d1;
    _684 += _681;
    _679.data[_684] = _683;
    _681++;
    if (_681 < i.d2)
    goto _jump1186;
    _681 = 0;
    _682++;
    if (_682 < i.d0)
    goto _jump1186;
    // End body of loop
    _678 = _679;
    goto _jump1187;
    _jump1183:;
    _a2_double _685;
    // Computing bound for m
    _685.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump1188;
    fail_assertion("non-positive loop bound");
    _jump1188:;
    // Computing bound for n
    int64_t _686 = 372;
    _685.d1 = _686;
    if (_686 > 0) 
    goto _jump1189;
    fail_assertion("non-positive loop bound");
    _jump1189:;
    // Computing total size of heap memory to allocate
    int64_t _687 = 1;
    _687 *= i.d2;
    _687 *= _686;
    _687 *= sizeof(double);
    _685.data = jpl_alloc(_687);
    int64_t _688 = 0; // n
    int64_t _689 = 0; // m
    _jump1190:; // Begin body of loop
    double _690 = 75.0;
    int64_t _691 = 0;
    _691 *= _685.d0;
    _691 += _689;
    _691 *= _685.d1;
    _691 += _688;
    _685.data[_691] = _690;
    _688++;
    if (_688 < _686)
    goto _jump1190;
    _688 = 0;
    _689++;
    if (_689 < i.d2)
    goto _jump1190;
    // End body of loop
    _678 = _685;
    _jump1187:;
    _674 = _678;
    goto _jump1191;
    _jump1182:;
    _a2_double _692;
    // Computing bound for m
    _692.d0 = h;
    if (h > 0) 
    goto _jump1192;
    fail_assertion("non-positive loop bound");
    _jump1192:;
    // Computing bound for n
    _692.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump1193;
    fail_assertion("non-positive loop bound");
    _jump1193:;
    // Computing total size of heap memory to allocate
    int64_t _693 = 1;
    _693 *= h;
    _693 *= i.d2;
    _693 *= sizeof(double);
    _692.data = jpl_alloc(_693);
    int64_t _694 = 0; // n
    int64_t _695 = 0; // m
    _jump1194:; // Begin body of loop
    double _696 = 58.0;
    int64_t _697 = 0;
    _697 *= _692.d0;
    _697 += _695;
    _697 *= _692.d1;
    _697 += _694;
    _692.data[_697] = _696;
    _694++;
    if (_694 < i.d2)
    goto _jump1194;
    _694 = 0;
    _695++;
    if (_695 < h)
    goto _jump1194;
    // End body of loop
    _674 = _692;
    _jump1191:;
    _656 = _674;
    _jump1181:;
    _631 = _656;
    goto _jump1195;
    _jump1155:;
    bool _698 = true;
    _a2_double _699;
    if (!_698)
    goto _jump1196;
    _a2_double _700;
    // Computing bound for m
    int64_t _701 = 478;
    int64_t _702 = -_701;
    _700.d0 = _702;
    if (_702 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing bound for n
    _700.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1198;
    fail_assertion("non-positive loop bound");
    _jump1198:;
    // Computing total size of heap memory to allocate
    int64_t _703 = 1;
    _703 *= _702;
    _703 *= i.d1;
    _703 *= sizeof(double);
    _700.data = jpl_alloc(_703);
    int64_t _704 = 0; // n
    int64_t _705 = 0; // m
    _jump1199:; // Begin body of loop
    _a1_double _706;
    // Computing bound for o
    _706.d0 = _704;
    if (_704 > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    // Computing total size of heap memory to allocate
    int64_t _707 = 1;
    _707 *= _704;
    _707 *= sizeof(double);
    _706.data = jpl_alloc(_707);
    int64_t _708 = 0; // o
    _jump1201:; // Begin body of loop
    double _709 = 76.0;
    int64_t _710 = 0;
    _710 *= _706.d0;
    _710 += _708;
    _706.data[_710] = _709;
    _708++;
    if (_708 < _704)
    goto _jump1201;
    // End body of loop
    int64_t _711 = 32;
    if (_711 >= 0)
    goto _jump1202;
    fail_assertion("negative array index");
    _jump1202:;
    if (_711 < _706.d0)
    goto _jump1203;
    fail_assertion("index too large");
    _jump1203:;
    int64_t _712 = 0;
    _712 *= _706.d0;
    _712 += _711;
    double _713 = _706.data[_712];
    int64_t _714 = 0;
    _714 *= _700.d0;
    _714 += _705;
    _714 *= _700.d1;
    _714 += _704;
    _700.data[_714] = _713;
    _704++;
    if (_704 < i.d1)
    goto _jump1199;
    _704 = 0;
    _705++;
    if (_705 < _702)
    goto _jump1199;
    // End body of loop
    _699 = _700;
    goto _jump1204;
    _jump1196:;
    _a2__a2_double _715;
    // Computing bound for m
    _715.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1205;
    fail_assertion("non-positive loop bound");
    _jump1205:;
    // Computing bound for n
    _715.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump1206;
    fail_assertion("non-positive loop bound");
    _jump1206:;
    // Computing total size of heap memory to allocate
    int64_t _716 = 1;
    _716 *= i.d0;
    _716 *= i.d2;
    _716 *= sizeof(_a2_double);
    _715.data = jpl_alloc(_716);
    int64_t _717 = 0; // n
    int64_t _718 = 0; // m
    _jump1207:; // Begin body of loop
    _a2_double _719;
    // Computing bound for o
    _719.d0 = d;
    if (d > 0) 
    goto _jump1208;
    fail_assertion("non-positive loop bound");
    _jump1208:;
    // Computing bound for p
    _719.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing total size of heap memory to allocate
    int64_t _720 = 1;
    _720 *= d;
    _720 *= i.d0;
    _720 *= sizeof(double);
    _719.data = jpl_alloc(_720);
    int64_t _721 = 0; // p
    int64_t _722 = 0; // o
    _jump1210:; // Begin body of loop
    double _723 = 47.0;
    int64_t _724 = 0;
    _724 *= _719.d0;
    _724 += _722;
    _724 *= _719.d1;
    _724 += _721;
    _719.data[_724] = _723;
    _721++;
    if (_721 < i.d0)
    goto _jump1210;
    _721 = 0;
    _722++;
    if (_722 < d)
    goto _jump1210;
    // End body of loop
    int64_t _725 = 0;
    _725 *= _715.d0;
    _725 += _718;
    _725 *= _715.d1;
    _725 += _717;
    _715.data[_725] = _719;
    _717++;
    if (_717 < i.d2)
    goto _jump1207;
    _717 = 0;
    _718++;
    if (_718 < i.d0)
    goto _jump1207;
    // End body of loop
    int64_t _726 = 918;
    int64_t _727 = 600;
    int64_t _728 = -_727;
    if (_726 >= 0)
    goto _jump1211;
    fail_assertion("negative array index");
    _jump1211:;
    if (_726 < _715.d0)
    goto _jump1212;
    fail_assertion("index too large");
    _jump1212:;
    if (_728 >= 0)
    goto _jump1213;
    fail_assertion("negative array index");
    _jump1213:;
    if (_728 < _715.d1)
    goto _jump1214;
    fail_assertion("index too large");
    _jump1214:;
    int64_t _729 = 0;
    _729 *= _715.d0;
    _729 += _726;
    _729 *= _715.d1;
    _729 += _728;
    _a2_double _730 = _715.data[_729];
    _699 = _730;
    _jump1204:;
    _631 = _699;
    _jump1195:;
    double _731 = 28.0;
    double _732 = -_731;
    double _733 = 88.0;
    double _734 = -_733;
    bool _735 = _732 > _734;
    a _736;
    if (!_735)
    goto _jump1215;
    _a3_a _737;
    // Computing bound for m
    int64_t _738 = 924;
    _737.d0 = _738;
    if (_738 > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing bound for n
    _737.d1 = d;
    if (d > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    // Computing bound for o
    _737.d2 = d;
    if (d > 0) 
    goto _jump1218;
    fail_assertion("non-positive loop bound");
    _jump1218:;
    // Computing total size of heap memory to allocate
    int64_t _739 = 1;
    _739 *= _738;
    _739 *= d;
    _739 *= d;
    _739 *= sizeof(a);
    _737.data = jpl_alloc(_739);
    int64_t _740 = 0; // o
    int64_t _741 = 0; // n
    int64_t _742 = 0; // m
    _jump1219:; // Begin body of loop
    a _743 = f(g, _740, i);
    int64_t _744 = 0;
    _744 *= _737.d0;
    _744 += _742;
    _744 *= _737.d1;
    _744 += _741;
    _744 *= _737.d2;
    _744 += _740;
    _737.data[_744] = _743;
    _740++;
    if (_740 < d)
    goto _jump1219;
    _740 = 0;
    _741++;
    if (_741 < d)
    goto _jump1219;
    _741 = 0;
    _742++;
    if (_742 < _738)
    goto _jump1219;
    // End body of loop
    int64_t _745 = 564;
    int64_t _746 = i.d1 / i.d1;
    if (i.d0 >= 0)
    goto _jump1220;
    fail_assertion("negative array index");
    _jump1220:;
    if (i.d0 < _737.d0)
    goto _jump1221;
    fail_assertion("index too large");
    _jump1221:;
    if (_745 >= 0)
    goto _jump1222;
    fail_assertion("negative array index");
    _jump1222:;
    if (_745 < _737.d1)
    goto _jump1223;
    fail_assertion("index too large");
    _jump1223:;
    if (_746 >= 0)
    goto _jump1224;
    fail_assertion("negative array index");
    _jump1224:;
    if (_746 < _737.d2)
    goto _jump1225;
    fail_assertion("index too large");
    _jump1225:;
    int64_t _747 = 0;
    _747 *= _737.d0;
    _747 += i.d0;
    _747 *= _737.d1;
    _747 += _745;
    _747 *= _737.d2;
    _747 += _746;
    a _748 = _737.data[_747];
    _736 = _748;
    goto _jump1226;
    _jump1215:;
    a _749 = f(g, i.d2, i);
    void_t _750 = _749.b;
    int64_t _751 = 552;
    _a3_bool _752;
    // Computing bound for m
    bool _753 = false;
    int64_t _754;
    if (!_753)
    goto _jump1227;
    _754 = i.d2;
    goto _jump1228;
    _jump1227:;
    _754 = i.d2;
    _jump1228:;
    _752.d0 = _754;
    if (_754 > 0) 
    goto _jump1229;
    fail_assertion("non-positive loop bound");
    _jump1229:;
    // Computing bound for n
    _752.d1 = d;
    if (d > 0) 
    goto _jump1230;
    fail_assertion("non-positive loop bound");
    _jump1230:;
    // Computing bound for o
    bool _755 = false;
    int64_t _756;
    if (!_755)
    goto _jump1231;
    _756 = d;
    goto _jump1232;
    _jump1231:;
    _756 = i.d0;
    _jump1232:;
    _752.d2 = _756;
    if (_756 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing total size of heap memory to allocate
    int64_t _757 = 1;
    _757 *= _754;
    _757 *= d;
    _757 *= _756;
    _757 *= sizeof(bool);
    _752.data = jpl_alloc(_757);
    int64_t _758 = 0; // o
    int64_t _759 = 0; // n
    int64_t _760 = 0; // m
    _jump1234:; // Begin body of loop
    bool _761 = i.d0 <= h;
    int64_t _762 = 0;
    _762 *= _752.d0;
    _762 += _760;
    _762 *= _752.d1;
    _762 += _759;
    _762 *= _752.d2;
    _762 += _758;
    _752.data[_762] = _761;
    _758++;
    if (_758 < _756)
    goto _jump1234;
    _758 = 0;
    _759++;
    if (_759 < d)
    goto _jump1234;
    _759 = 0;
    _760++;
    if (_760 < _754)
    goto _jump1234;
    // End body of loop
    a _763 = f(_750, _751, _752);
    _736 = _763;
    _jump1226:;
    int64_t _764 = _736.a;
    int64_t _765;
    // Computing bound for m
    int64_t _766 = 532;
    if (_766 > 0) 
    goto _jump1235;
    fail_assertion("non-positive loop bound");
    _jump1235:;
    // Computing bound for n
    if (i.d0 > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing bound for o
    if (d > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    _765 = 0;
    int64_t _767 = 0; // o
    int64_t _768 = 0; // n
    int64_t _769 = 0; // m
    _jump1238:; // Begin body of loop
    int64_t _770 = i.d1 - i.d0;
    int64_t _771 = _770 * i.d1;
    _765 += _771;
    _767++;
    if (_767 < d)
    goto _jump1238;
    _767 = 0;
    _768++;
    if (_768 < i.d0)
    goto _jump1238;
    _768 = 0;
    _769++;
    if (_769 < _766)
    goto _jump1238;
    // End body of loop
    if (_764 >= 0)
    goto _jump1239;
    fail_assertion("negative array index");
    _jump1239:;
    if (_764 < _631.d0)
    goto _jump1240;
    fail_assertion("index too large");
    _jump1240:;
    if (_765 >= 0)
    goto _jump1241;
    fail_assertion("negative array index");
    _jump1241:;
    if (_765 < _631.d1)
    goto _jump1242;
    fail_assertion("index too large");
    _jump1242:;
    int64_t _772 = 0;
    _772 *= _631.d0;
    _772 += _764;
    _772 *= _631.d1;
    _772 += _765;
    double _773 = _631.data[_772];
    rgba _774 = { _499, _614, _615, _773 };
    bool _775 = false;
    _a3__a2_int64_t _776;
    if (!_775)
    goto _jump1243;
    bool _777 = false;
    bool _778;
    if (!_777)
    goto _jump1244;
    _a1_bool _779;
    // Computing bound for n
    _779.d0 = h;
    if (h > 0) 
    goto _jump1245;
    fail_assertion("non-positive loop bound");
    _jump1245:;
    // Computing total size of heap memory to allocate
    int64_t _780 = 1;
    _780 *= h;
    _780 *= sizeof(bool);
    _779.data = jpl_alloc(_780);
    int64_t _781 = 0; // n
    _jump1246:; // Begin body of loop
    bool _782 = true;
    int64_t _783 = 0;
    _783 *= _779.d0;
    _783 += _781;
    _779.data[_783] = _782;
    _781++;
    if (_781 < h)
    goto _jump1246;
    // End body of loop
    if (i.d2 >= 0)
    goto _jump1247;
    fail_assertion("negative array index");
    _jump1247:;
    if (i.d2 < _779.d0)
    goto _jump1248;
    fail_assertion("index too large");
    _jump1248:;
    int64_t _784 = 0;
    _784 *= _779.d0;
    _784 += i.d2;
    bool _785 = _779.data[_784];
    bool _786 = !_785;
    _778 = _786;
    goto _jump1249;
    _jump1244:;
    double _787 = 71.0;
    double _788;
    // Computing bound for n
    if (i.d0 > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing bound for o
    int64_t _789 = 958;
    if (_789 > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    _788 = 0;
    int64_t _790 = 0; // o
    int64_t _791 = 0; // n
    _jump1252:; // Begin body of loop
    double _792 = 35.0;
    _788 += _792;
    _790++;
    if (_790 < _789)
    goto _jump1252;
    _790 = 0;
    _791++;
    if (_791 < i.d0)
    goto _jump1252;
    // End body of loop
    bool _793 = _787 > _788;
    _778 = _793;
    _jump1249:;
    _a3__a2_int64_t _794;
    if (!_778)
    goto _jump1253;
    double _795 = 9.0;
    double _796 = 48.0;
    double _797 = 65.0;
    double _798 = fmod(_796, _797);
    bool _799 = _795 <= _798;
    _a3__a2_int64_t _800;
    if (!_799)
    goto _jump1254;
    bool _801 = false;
    int64_t _802;
    if (!_801)
    goto _jump1255;
    _802 = i.d1;
    goto _jump1256;
    _jump1255:;
    int64_t _803 = 438;
    _802 = _803;
    _jump1256:;
    bool _804 = d == _802;
    _a3__a2_int64_t _805;
    if (!_804)
    goto _jump1257;
    _a3__a2_int64_t _806;
    // Computing bound for n
    _806.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    // Computing bound for o
    _806.d1 = d;
    if (d > 0) 
    goto _jump1259;
    fail_assertion("non-positive loop bound");
    _jump1259:;
    // Computing bound for p
    _806.d2 = i.d2;
    if (i.d2 > 0) 
    goto _jump1260;
    fail_assertion("non-positive loop bound");
    _jump1260:;
    // Computing total size of heap memory to allocate
    int64_t _807 = 1;
    _807 *= i.d0;
    _807 *= d;
    _807 *= i.d2;
    _807 *= sizeof(_a2_int64_t);
    _806.data = jpl_alloc(_807);
    int64_t _808 = 0; // p
    int64_t _809 = 0; // o
    int64_t _810 = 0; // n
    _jump1261:; // Begin body of loop
    _a2_int64_t _811;
    // Computing bound for q
    _811.d0 = _808;
    if (_808 > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    // Computing bound for r
    _811.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1263;
    fail_assertion("non-positive loop bound");
    _jump1263:;
    // Computing total size of heap memory to allocate
    int64_t _812 = 1;
    _812 *= _808;
    _812 *= i.d0;
    _812 *= sizeof(int64_t);
    _811.data = jpl_alloc(_812);
    int64_t _813 = 0; // r
    int64_t _814 = 0; // q
    _jump1264:; // Begin body of loop
    int64_t _815 = 0;
    _815 *= _811.d0;
    _815 += _814;
    _815 *= _811.d1;
    _815 += _813;
    _811.data[_815] = i.d2;
    _813++;
    if (_813 < i.d0)
    goto _jump1264;
    _813 = 0;
    _814++;
    if (_814 < _808)
    goto _jump1264;
    // End body of loop
    int64_t _816 = 0;
    _816 *= _806.d0;
    _816 += _810;
    _816 *= _806.d1;
    _816 += _809;
    _816 *= _806.d2;
    _816 += _808;
    _806.data[_816] = _811;
    _808++;
    if (_808 < i.d2)
    goto _jump1261;
    _808 = 0;
    _809++;
    if (_809 < d)
    goto _jump1261;
    _809 = 0;
    _810++;
    if (_810 < i.d0)
    goto _jump1261;
    // End body of loop
    _805 = _806;
    goto _jump1265;
    _jump1257:;
    _a3__a2_int64_t _817;
    // Computing bound for n
    int64_t _818 = -h;
    _817.d0 = _818;
    if (_818 > 0) 
    goto _jump1266;
    fail_assertion("non-positive loop bound");
    _jump1266:;
    // Computing bound for o
    int64_t _819 = i.d2 % i.d2;
    _817.d1 = _819;
    if (_819 > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    // Computing bound for p
    _817.d2 = i.d1;
    if (i.d1 > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    // Computing total size of heap memory to allocate
    int64_t _820 = 1;
    _820 *= _818;
    _820 *= _819;
    _820 *= i.d1;
    _820 *= sizeof(_a2_int64_t);
    _817.data = jpl_alloc(_820);
    int64_t _821 = 0; // p
    int64_t _822 = 0; // o
    int64_t _823 = 0; // n
    _jump1269:; // Begin body of loop
    _a2_int64_t _824;
    // Computing bound for q
    int64_t _825 = 666;
    _824.d0 = _825;
    if (_825 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    // Computing bound for r
    _824.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump1271;
    fail_assertion("non-positive loop bound");
    _jump1271:;
    // Computing total size of heap memory to allocate
    int64_t _826 = 1;
    _826 *= _825;
    _826 *= i.d2;
    _826 *= sizeof(int64_t);
    _824.data = jpl_alloc(_826);
    int64_t _827 = 0; // r
    int64_t _828 = 0; // q
    _jump1272:; // Begin body of loop
    int64_t _829 = 0;
    _829 *= _824.d0;
    _829 += _828;
    _829 *= _824.d1;
    _829 += _827;
    _824.data[_829] = _827;
    _827++;
    if (_827 < i.d2)
    goto _jump1272;
    _827 = 0;
    _828++;
    if (_828 < _825)
    goto _jump1272;
    // End body of loop
    int64_t _830 = 0;
    _830 *= _817.d0;
    _830 += _823;
    _830 *= _817.d1;
    _830 += _822;
    _830 *= _817.d2;
    _830 += _821;
    _817.data[_830] = _824;
    _821++;
    if (_821 < i.d1)
    goto _jump1269;
    _821 = 0;
    _822++;
    if (_822 < _819)
    goto _jump1269;
    _822 = 0;
    _823++;
    if (_823 < _818)
    goto _jump1269;
    // End body of loop
    _805 = _817;
    _jump1265:;
    _800 = _805;
    goto _jump1273;
    _jump1254:;
    _a3__a2_int64_t _831;
    // Computing bound for n
    _831.d0 = h;
    if (h > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    // Computing bound for o
    _831.d1 = d;
    if (d > 0) 
    goto _jump1275;
    fail_assertion("non-positive loop bound");
    _jump1275:;
    // Computing bound for p
    _831.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1276;
    fail_assertion("non-positive loop bound");
    _jump1276:;
    // Computing total size of heap memory to allocate
    int64_t _832 = 1;
    _832 *= h;
    _832 *= d;
    _832 *= i.d0;
    _832 *= sizeof(_a2_int64_t);
    _831.data = jpl_alloc(_832);
    int64_t _833 = 0; // p
    int64_t _834 = 0; // o
    int64_t _835 = 0; // n
    _jump1277:; // Begin body of loop
    _a2_int64_t _836;
    // Computing bound for q
    _836.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump1278;
    fail_assertion("non-positive loop bound");
    _jump1278:;
    // Computing bound for r
    int64_t _837 = _835 - _833;
    _836.d1 = _837;
    if (_837 > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing total size of heap memory to allocate
    int64_t _838 = 1;
    _838 *= i.d2;
    _838 *= _837;
    _838 *= sizeof(int64_t);
    _836.data = jpl_alloc(_838);
    int64_t _839 = 0; // r
    int64_t _840 = 0; // q
    _jump1280:; // Begin body of loop
    int64_t _841 = i.d1 / _839;
    int64_t _842 = 0;
    _842 *= _836.d0;
    _842 += _840;
    _842 *= _836.d1;
    _842 += _839;
    _836.data[_842] = _841;
    _839++;
    if (_839 < _837)
    goto _jump1280;
    _839 = 0;
    _840++;
    if (_840 < i.d2)
    goto _jump1280;
    // End body of loop
    int64_t _843 = 0;
    _843 *= _831.d0;
    _843 += _835;
    _843 *= _831.d1;
    _843 += _834;
    _843 *= _831.d2;
    _843 += _833;
    _831.data[_843] = _836;
    _833++;
    if (_833 < i.d0)
    goto _jump1277;
    _833 = 0;
    _834++;
    if (_834 < d)
    goto _jump1277;
    _834 = 0;
    _835++;
    if (_835 < h)
    goto _jump1277;
    // End body of loop
    _800 = _831;
    _jump1273:;
    _794 = _800;
    goto _jump1281;
    _jump1253:;
    _a3__a2_int64_t _844;
    // Computing bound for n
    int64_t _845 = h - i.d0;
    bool _846 = _845 != i.d2;
    int64_t _847;
    if (!_846)
    goto _jump1282;
    _847 = i.d1;
    goto _jump1283;
    _jump1282:;
    _a3_int64_t _848;
    // Computing bound for n
    _848.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1284;
    fail_assertion("non-positive loop bound");
    _jump1284:;
    // Computing bound for o
    int64_t _849 = 23;
    _848.d1 = _849;
    if (_849 > 0) 
    goto _jump1285;
    fail_assertion("non-positive loop bound");
    _jump1285:;
    // Computing bound for p
    _848.d2 = i.d2;
    if (i.d2 > 0) 
    goto _jump1286;
    fail_assertion("non-positive loop bound");
    _jump1286:;
    // Computing total size of heap memory to allocate
    int64_t _850 = 1;
    _850 *= i.d0;
    _850 *= _849;
    _850 *= i.d2;
    _850 *= sizeof(int64_t);
    _848.data = jpl_alloc(_850);
    int64_t _851 = 0; // p
    int64_t _852 = 0; // o
    int64_t _853 = 0; // n
    _jump1287:; // Begin body of loop
    int64_t _854 = 0;
    _854 *= _848.d0;
    _854 += _853;
    _854 *= _848.d1;
    _854 += _852;
    _854 *= _848.d2;
    _854 += _851;
    _848.data[_854] = i.d1;
    _851++;
    if (_851 < i.d2)
    goto _jump1287;
    _851 = 0;
    _852++;
    if (_852 < _849)
    goto _jump1287;
    _852 = 0;
    _853++;
    if (_853 < i.d0)
    goto _jump1287;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump1288;
    fail_assertion("negative array index");
    _jump1288:;
    if (i.d0 < _848.d0)
    goto _jump1289;
    fail_assertion("index too large");
    _jump1289:;
    if (i.d2 >= 0)
    goto _jump1290;
    fail_assertion("negative array index");
    _jump1290:;
    if (i.d2 < _848.d1)
    goto _jump1291;
    fail_assertion("index too large");
    _jump1291:;
    if (d >= 0)
    goto _jump1292;
    fail_assertion("negative array index");
    _jump1292:;
    if (d < _848.d2)
    goto _jump1293;
    fail_assertion("index too large");
    _jump1293:;
    int64_t _855 = 0;
    _855 *= _848.d0;
    _855 += i.d0;
    _855 *= _848.d1;
    _855 += i.d2;
    _855 *= _848.d2;
    _855 += d;
    int64_t _856 = _848.data[_855];
    _847 = _856;
    _jump1283:;
    _844.d0 = _847;
    if (_847 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    // Computing bound for o
    int64_t _857 = 475;
    int64_t _858 = -_857;
    int64_t _859 = -i.d2;
    int64_t _860 = _858 % _859;
    int64_t _861 = i.d0 - _860;
    _844.d1 = _861;
    if (_861 > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing bound for p
    _844.d2 = d;
    if (d > 0) 
    goto _jump1296;
    fail_assertion("non-positive loop bound");
    _jump1296:;
    // Computing total size of heap memory to allocate
    int64_t _862 = 1;
    _862 *= _847;
    _862 *= _861;
    _862 *= d;
    _862 *= sizeof(_a2_int64_t);
    _844.data = jpl_alloc(_862);
    int64_t _863 = 0; // p
    int64_t _864 = 0; // o
    int64_t _865 = 0; // n
    _jump1297:; // Begin body of loop
    int64_t _866 = 761;
    if (i.d0 >= 0)
    goto _jump1298;
    fail_assertion("negative array index");
    _jump1298:;
    if (i.d0 < i.d0)
    goto _jump1299;
    fail_assertion("index too large");
    _jump1299:;
    if (_866 >= 0)
    goto _jump1300;
    fail_assertion("negative array index");
    _jump1300:;
    if (_866 < i.d1)
    goto _jump1301;
    fail_assertion("index too large");
    _jump1301:;
    if (i.d0 >= 0)
    goto _jump1302;
    fail_assertion("negative array index");
    _jump1302:;
    if (i.d0 < i.d2)
    goto _jump1303;
    fail_assertion("index too large");
    _jump1303:;
    int64_t _867 = 0;
    _867 *= i.d0;
    _867 += i.d0;
    _867 *= i.d1;
    _867 += _866;
    _867 *= i.d2;
    _867 += i.d0;
    bool _868 = i.data[_867];
    bool _869;
    if (!_868)
    goto _jump1304;
    bool _870 = true;
    _869 = _870;
    goto _jump1305;
    _jump1304:;
    bool _871 = h == i.d0;
    _869 = _871;
    _jump1305:;
    _a2_int64_t _872;
    if (!_869)
    goto _jump1306;
    _a2_int64_t _873;
    // Computing bound for q
    _873.d0 = _865;
    if (_865 > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing bound for r
    _873.d1 = _863;
    if (_863 > 0) 
    goto _jump1308;
    fail_assertion("non-positive loop bound");
    _jump1308:;
    // Computing total size of heap memory to allocate
    int64_t _874 = 1;
    _874 *= _865;
    _874 *= _863;
    _874 *= sizeof(int64_t);
    _873.data = jpl_alloc(_874);
    int64_t _875 = 0; // r
    int64_t _876 = 0; // q
    _jump1309:; // Begin body of loop
    int64_t _877 = 0;
    _877 *= _873.d0;
    _877 += _876;
    _877 *= _873.d1;
    _877 += _875;
    _873.data[_877] = _864;
    _875++;
    if (_875 < _863)
    goto _jump1309;
    _875 = 0;
    _876++;
    if (_876 < _865)
    goto _jump1309;
    // End body of loop
    _872 = _873;
    goto _jump1310;
    _jump1306:;
    _a2_int64_t _878;
    // Computing bound for q
    _878.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump1311;
    fail_assertion("non-positive loop bound");
    _jump1311:;
    // Computing bound for r
    _878.d1 = h;
    if (h > 0) 
    goto _jump1312;
    fail_assertion("non-positive loop bound");
    _jump1312:;
    // Computing total size of heap memory to allocate
    int64_t _879 = 1;
    _879 *= i.d2;
    _879 *= h;
    _879 *= sizeof(int64_t);
    _878.data = jpl_alloc(_879);
    int64_t _880 = 0; // r
    int64_t _881 = 0; // q
    _jump1313:; // Begin body of loop
    int64_t _882 = 0;
    _882 *= _878.d0;
    _882 += _881;
    _882 *= _878.d1;
    _882 += _880;
    _878.data[_882] = _863;
    _880++;
    if (_880 < h)
    goto _jump1313;
    _880 = 0;
    _881++;
    if (_881 < i.d2)
    goto _jump1313;
    // End body of loop
    _872 = _878;
    _jump1310:;
    int64_t _883 = 0;
    _883 *= _844.d0;
    _883 += _865;
    _883 *= _844.d1;
    _883 += _864;
    _883 *= _844.d2;
    _883 += _863;
    _844.data[_883] = _872;
    _863++;
    if (_863 < d)
    goto _jump1297;
    _863 = 0;
    _864++;
    if (_864 < _861)
    goto _jump1297;
    _864 = 0;
    _865++;
    if (_865 < _847)
    goto _jump1297;
    // End body of loop
    _794 = _844;
    _jump1281:;
    _776 = _794;
    goto _jump1314;
    _jump1243:;
    _a3__a2_int64_t _884;
    // Computing bound for n
    bool _886 = false;
    bool _885 = _886;
    if (0 != _886)
    goto _jump1315;
    bool _887 = false;
    _885 = _887;
    _jump1315:;
    _a3_int64_t _888;
    if (!_885)
    goto _jump1316;
    _a3_int64_t _889;
    // Computing bound for n
    _889.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1317;
    fail_assertion("non-positive loop bound");
    _jump1317:;
    // Computing bound for o
    _889.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for p
    _889.d2 = i.d2;
    if (i.d2 > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    // Computing total size of heap memory to allocate
    int64_t _890 = 1;
    _890 *= i.d1;
    _890 *= i.d0;
    _890 *= i.d2;
    _890 *= sizeof(int64_t);
    _889.data = jpl_alloc(_890);
    int64_t _891 = 0; // p
    int64_t _892 = 0; // o
    int64_t _893 = 0; // n
    _jump1320:; // Begin body of loop
    int64_t _894 = 0;
    _894 *= _889.d0;
    _894 += _893;
    _894 *= _889.d1;
    _894 += _892;
    _894 *= _889.d2;
    _894 += _891;
    _889.data[_894] = h;
    _891++;
    if (_891 < i.d2)
    goto _jump1320;
    _891 = 0;
    _892++;
    if (_892 < i.d0)
    goto _jump1320;
    _892 = 0;
    _893++;
    if (_893 < i.d1)
    goto _jump1320;
    // End body of loop
    _888 = _889;
    goto _jump1321;
    _jump1316:;
    _a3_int64_t _895;
    // Computing bound for n
    int64_t _896 = 454;
    _895.d0 = _896;
    if (_896 > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing bound for o
    _895.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    // Computing bound for p
    _895.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1324;
    fail_assertion("non-positive loop bound");
    _jump1324:;
    // Computing total size of heap memory to allocate
    int64_t _897 = 1;
    _897 *= _896;
    _897 *= i.d1;
    _897 *= i.d0;
    _897 *= sizeof(int64_t);
    _895.data = jpl_alloc(_897);
    int64_t _898 = 0; // p
    int64_t _899 = 0; // o
    int64_t _900 = 0; // n
    _jump1325:; // Begin body of loop
    int64_t _901 = 0;
    _901 *= _895.d0;
    _901 += _900;
    _901 *= _895.d1;
    _901 += _899;
    _901 *= _895.d2;
    _901 += _898;
    _895.data[_901] = _899;
    _898++;
    if (_898 < i.d0)
    goto _jump1325;
    _898 = 0;
    _899++;
    if (_899 < i.d1)
    goto _jump1325;
    _899 = 0;
    _900++;
    if (_900 < _896)
    goto _jump1325;
    // End body of loop
    _888 = _895;
    _jump1321:;
    _a1_int64_t _902;
    _902.d0 = 1;
    _902.data = jpl_alloc(sizeof(int64_t) * 1);
    _902.data[0] = i.d2;
    int64_t _903 = -i.d2;
    if (_903 >= 0)
    goto _jump1326;
    fail_assertion("negative array index");
    _jump1326:;
    if (_903 < _902.d0)
    goto _jump1327;
    fail_assertion("index too large");
    _jump1327:;
    int64_t _904 = 0;
    _904 *= _902.d0;
    _904 += _903;
    int64_t _905 = _902.data[_904];
    _a3_int64_t _906;
    // Computing bound for n
    _906.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1328;
    fail_assertion("non-positive loop bound");
    _jump1328:;
    // Computing bound for o
    _906.d1 = d;
    if (d > 0) 
    goto _jump1329;
    fail_assertion("non-positive loop bound");
    _jump1329:;
    // Computing bound for p
    _906.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1330;
    fail_assertion("non-positive loop bound");
    _jump1330:;
    // Computing total size of heap memory to allocate
    int64_t _907 = 1;
    _907 *= i.d1;
    _907 *= d;
    _907 *= i.d0;
    _907 *= sizeof(int64_t);
    _906.data = jpl_alloc(_907);
    int64_t _908 = 0; // p
    int64_t _909 = 0; // o
    int64_t _910 = 0; // n
    _jump1331:; // Begin body of loop
    int64_t _911 = 0;
    _911 *= _906.d0;
    _911 += _910;
    _911 *= _906.d1;
    _911 += _909;
    _911 *= _906.d2;
    _911 += _908;
    _906.data[_911] = i.d0;
    _908++;
    if (_908 < i.d0)
    goto _jump1331;
    _908 = 0;
    _909++;
    if (_909 < d)
    goto _jump1331;
    _909 = 0;
    _910++;
    if (_910 < i.d1)
    goto _jump1331;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump1332;
    fail_assertion("negative array index");
    _jump1332:;
    if (i.d0 < _906.d0)
    goto _jump1333;
    fail_assertion("index too large");
    _jump1333:;
    if (d >= 0)
    goto _jump1334;
    fail_assertion("negative array index");
    _jump1334:;
    if (d < _906.d1)
    goto _jump1335;
    fail_assertion("index too large");
    _jump1335:;
    if (i.d0 >= 0)
    goto _jump1336;
    fail_assertion("negative array index");
    _jump1336:;
    if (i.d0 < _906.d2)
    goto _jump1337;
    fail_assertion("index too large");
    _jump1337:;
    int64_t _912 = 0;
    _912 *= _906.d0;
    _912 += i.d0;
    _912 *= _906.d1;
    _912 += d;
    _912 *= _906.d2;
    _912 += i.d0;
    int64_t _913 = _906.data[_912];
    if (_905 >= 0)
    goto _jump1338;
    fail_assertion("negative array index");
    _jump1338:;
    if (_905 < _888.d0)
    goto _jump1339;
    fail_assertion("index too large");
    _jump1339:;
    if (_913 >= 0)
    goto _jump1340;
    fail_assertion("negative array index");
    _jump1340:;
    if (_913 < _888.d1)
    goto _jump1341;
    fail_assertion("index too large");
    _jump1341:;
    if (i.d2 >= 0)
    goto _jump1342;
    fail_assertion("negative array index");
    _jump1342:;
    if (i.d2 < _888.d2)
    goto _jump1343;
    fail_assertion("index too large");
    _jump1343:;
    int64_t _914 = 0;
    _914 *= _888.d0;
    _914 += _905;
    _914 *= _888.d1;
    _914 += _913;
    _914 *= _888.d2;
    _914 += i.d2;
    int64_t _915 = _888.data[_914];
    int64_t _916 = h / _915;
    _884.d0 = _916;
    if (_916 > 0) 
    goto _jump1344;
    fail_assertion("non-positive loop bound");
    _jump1344:;
    // Computing bound for o
    _884.d1 = h;
    if (h > 0) 
    goto _jump1345;
    fail_assertion("non-positive loop bound");
    _jump1345:;
    // Computing bound for p
    int64_t _917 = 757;
    _884.d2 = _917;
    if (_917 > 0) 
    goto _jump1346;
    fail_assertion("non-positive loop bound");
    _jump1346:;
    // Computing total size of heap memory to allocate
    int64_t _918 = 1;
    _918 *= _916;
    _918 *= h;
    _918 *= _917;
    _918 *= sizeof(_a2_int64_t);
    _884.data = jpl_alloc(_918);
    int64_t _919 = 0; // p
    int64_t _920 = 0; // o
    int64_t _921 = 0; // n
    _jump1347:; // Begin body of loop
    int64_t _922 = 441;
    if (_922 >= 0)
    goto _jump1348;
    fail_assertion("negative array index");
    _jump1348:;
    if (_922 < i.d0)
    goto _jump1349;
    fail_assertion("index too large");
    _jump1349:;
    if (d >= 0)
    goto _jump1350;
    fail_assertion("negative array index");
    _jump1350:;
    if (d < i.d1)
    goto _jump1351;
    fail_assertion("index too large");
    _jump1351:;
    if (d >= 0)
    goto _jump1352;
    fail_assertion("negative array index");
    _jump1352:;
    if (d < i.d2)
    goto _jump1353;
    fail_assertion("index too large");
    _jump1353:;
    int64_t _923 = 0;
    _923 *= i.d0;
    _923 += _922;
    _923 *= i.d1;
    _923 += d;
    _923 *= i.d2;
    _923 += d;
    bool _924 = i.data[_923];
    _a2_int64_t _925;
    if (!_924)
    goto _jump1354;
    _a2_int64_t _926;
    // Computing bound for q
    int64_t _927 = -_919;
    int64_t _928 = -_927;
    _926.d0 = _928;
    if (_928 > 0) 
    goto _jump1355;
    fail_assertion("non-positive loop bound");
    _jump1355:;
    // Computing bound for r
    _926.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1356;
    fail_assertion("non-positive loop bound");
    _jump1356:;
    // Computing total size of heap memory to allocate
    int64_t _929 = 1;
    _929 *= _928;
    _929 *= i.d0;
    _929 *= sizeof(int64_t);
    _926.data = jpl_alloc(_929);
    int64_t _930 = 0; // r
    int64_t _931 = 0; // q
    _jump1357:; // Begin body of loop
    int64_t _932 = 0;
    _932 *= _926.d0;
    _932 += _931;
    _932 *= _926.d1;
    _932 += _930;
    _926.data[_932] = _930;
    _930++;
    if (_930 < i.d0)
    goto _jump1357;
    _930 = 0;
    _931++;
    if (_931 < _928)
    goto _jump1357;
    // End body of loop
    _925 = _926;
    goto _jump1358;
    _jump1354:;
    _a2_int64_t _933;
    // Computing bound for q
    if (d >= 0)
    goto _jump1359;
    fail_assertion("negative array index");
    _jump1359:;
    if (d < i.d0)
    goto _jump1360;
    fail_assertion("index too large");
    _jump1360:;
    if (_919 >= 0)
    goto _jump1361;
    fail_assertion("negative array index");
    _jump1361:;
    if (_919 < i.d1)
    goto _jump1362;
    fail_assertion("index too large");
    _jump1362:;
    if (_920 >= 0)
    goto _jump1363;
    fail_assertion("negative array index");
    _jump1363:;
    if (_920 < i.d2)
    goto _jump1364;
    fail_assertion("index too large");
    _jump1364:;
    int64_t _934 = 0;
    _934 *= i.d0;
    _934 += d;
    _934 *= i.d1;
    _934 += _919;
    _934 *= i.d2;
    _934 += _920;
    bool _935 = i.data[_934];
    int64_t _936;
    if (!_935)
    goto _jump1365;
    _936 = _919;
    goto _jump1366;
    _jump1365:;
    _936 = i.d1;
    _jump1366:;
    _933.d0 = _936;
    if (_936 > 0) 
    goto _jump1367;
    fail_assertion("non-positive loop bound");
    _jump1367:;
    // Computing bound for r
    _933.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1368;
    fail_assertion("non-positive loop bound");
    _jump1368:;
    // Computing total size of heap memory to allocate
    int64_t _937 = 1;
    _937 *= _936;
    _937 *= i.d1;
    _937 *= sizeof(int64_t);
    _933.data = jpl_alloc(_937);
    int64_t _938 = 0; // r
    int64_t _939 = 0; // q
    _jump1369:; // Begin body of loop
    int64_t _940 = 0;
    _940 *= _933.d0;
    _940 += _939;
    _940 *= _933.d1;
    _940 += _938;
    _933.data[_940] = d;
    _938++;
    if (_938 < i.d1)
    goto _jump1369;
    _938 = 0;
    _939++;
    if (_939 < _936)
    goto _jump1369;
    // End body of loop
    _925 = _933;
    _jump1358:;
    int64_t _941 = 0;
    _941 *= _884.d0;
    _941 += _921;
    _941 *= _884.d1;
    _941 += _920;
    _941 *= _884.d2;
    _941 += _919;
    _884.data[_941] = _925;
    _919++;
    if (_919 < _917)
    goto _jump1347;
    _919 = 0;
    _920++;
    if (_920 < h)
    goto _jump1347;
    _920 = 0;
    _921++;
    if (_921 < _916)
    goto _jump1347;
    // End body of loop
    _776 = _884;
    _jump1314:;
    int64_t _942;
    // Computing bound for n
    int64_t _943;
    // Computing bound for n
    if (i.d0 > 0) 
    goto _jump1370;
    fail_assertion("non-positive loop bound");
    _jump1370:;
    _943 = 0;
    int64_t _944 = 0; // n
    _jump1371:; // Begin body of loop
    _943 += _944;
    _944++;
    if (_944 < i.d0)
    goto _jump1371;
    // End body of loop
    if (_943 > 0) 
    goto _jump1372;
    fail_assertion("non-positive loop bound");
    _jump1372:;
    // Computing bound for o
    if (h >= 0)
    goto _jump1373;
    fail_assertion("negative array index");
    _jump1373:;
    if (h < c.d0)
    goto _jump1374;
    fail_assertion("index too large");
    _jump1374:;
    int64_t _945 = 0;
    _945 *= c.d0;
    _945 += h;
    bool _946 = c.data[_945];
    bool _947;
    if (!_946)
    goto _jump1375;
    bool _948 = true;
    bool _949 = !_948;
    _947 = _949;
    goto _jump1376;
    _jump1375:;
    bool _950 = false;
    _947 = _950;
    _jump1376:;
    int64_t _951;
    if (!_947)
    goto _jump1377;
    int64_t _952;
    // Computing bound for n
    if (d > 0) 
    goto _jump1378;
    fail_assertion("non-positive loop bound");
    _jump1378:;
    // Computing bound for o
    if (i.d2 > 0) 
    goto _jump1379;
    fail_assertion("non-positive loop bound");
    _jump1379:;
    _952 = 0;
    int64_t _953 = 0; // o
    int64_t _954 = 0; // n
    _jump1380:; // Begin body of loop
    _952 += d;
    _953++;
    if (_953 < i.d2)
    goto _jump1380;
    _953 = 0;
    _954++;
    if (_954 < d)
    goto _jump1380;
    // End body of loop
    _951 = _952;
    goto _jump1381;
    _jump1377:;
    _951 = d;
    _jump1381:;
    int64_t _955 = i.d2 - _951;
    int64_t _956 = _955 * d;
    if (_956 > 0) 
    goto _jump1382;
    fail_assertion("non-positive loop bound");
    _jump1382:;
    _942 = 0;
    int64_t _957 = 0; // o
    int64_t _958 = 0; // n
    _jump1383:; // Begin body of loop
    int64_t _959 = 70;
    _a3__a3_bool _960;
    // Computing bound for p
    int64_t _961 = _957 % _958;
    _960.d0 = _961;
    if (_961 > 0) 
    goto _jump1384;
    fail_assertion("non-positive loop bound");
    _jump1384:;
    // Computing bound for q
    int64_t _962 = 126;
    _960.d1 = _962;
    if (_962 > 0) 
    goto _jump1385;
    fail_assertion("non-positive loop bound");
    _jump1385:;
    // Computing bound for r
    int64_t _963 = -_958;
    _960.d2 = _963;
    if (_963 > 0) 
    goto _jump1386;
    fail_assertion("non-positive loop bound");
    _jump1386:;
    // Computing total size of heap memory to allocate
    int64_t _964 = 1;
    _964 *= _961;
    _964 *= _962;
    _964 *= _963;
    _964 *= sizeof(_a3_bool);
    _960.data = jpl_alloc(_964);
    int64_t _965 = 0; // r
    int64_t _966 = 0; // q
    int64_t _967 = 0; // p
    _jump1387:; // Begin body of loop
    int64_t _968 = 0;
    _968 *= _960.d0;
    _968 += _967;
    _968 *= _960.d1;
    _968 += _966;
    _968 *= _960.d2;
    _968 += _965;
    _960.data[_968] = i;
    _965++;
    if (_965 < _963)
    goto _jump1387;
    _965 = 0;
    _966++;
    if (_966 < _962)
    goto _jump1387;
    _966 = 0;
    _967++;
    if (_967 < _961)
    goto _jump1387;
    // End body of loop
    int64_t _969;
    // Computing bound for p
    if (i.d1 > 0) 
    goto _jump1388;
    fail_assertion("non-positive loop bound");
    _jump1388:;
    _969 = 0;
    int64_t _970 = 0; // p
    _jump1389:; // Begin body of loop
    int64_t _971 = -h;
    _969 += _971;
    _970++;
    if (_970 < i.d1)
    goto _jump1389;
    // End body of loop
    int64_t _972;
    // Computing bound for p
    if (i.d2 > 0) 
    goto _jump1390;
    fail_assertion("non-positive loop bound");
    _jump1390:;
    // Computing bound for q
    int64_t _973;
    // Computing bound for p
    if (h > 0) 
    goto _jump1391;
    fail_assertion("non-positive loop bound");
    _jump1391:;
    // Computing bound for q
    if (i.d1 > 0) 
    goto _jump1392;
    fail_assertion("non-positive loop bound");
    _jump1392:;
    // Computing bound for r
    if (i.d2 > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    _973 = 0;
    int64_t _974 = 0; // r
    int64_t _975 = 0; // q
    int64_t _976 = 0; // p
    _jump1394:; // Begin body of loop
    int64_t _977 = 325;
    _973 += _977;
    _974++;
    if (_974 < i.d2)
    goto _jump1394;
    _974 = 0;
    _975++;
    if (_975 < i.d1)
    goto _jump1394;
    _975 = 0;
    _976++;
    if (_976 < h)
    goto _jump1394;
    // End body of loop
    if (_973 > 0) 
    goto _jump1395;
    fail_assertion("non-positive loop bound");
    _jump1395:;
    _972 = 0;
    int64_t _978 = 0; // q
    int64_t _979 = 0; // p
    _jump1396:; // Begin body of loop
    int64_t _980;
    // Computing bound for r
    if (i.d2 > 0) 
    goto _jump1397;
    fail_assertion("non-positive loop bound");
    _jump1397:;
    // Computing bound for s
    if (i.d2 > 0) 
    goto _jump1398;
    fail_assertion("non-positive loop bound");
    _jump1398:;
    _980 = 0;
    int64_t _981 = 0; // s
    int64_t _982 = 0; // r
    _jump1399:; // Begin body of loop
    _980 += _957;
    _981++;
    if (_981 < i.d2)
    goto _jump1399;
    _981 = 0;
    _982++;
    if (_982 < i.d2)
    goto _jump1399;
    // End body of loop
    _972 += _980;
    _978++;
    if (_978 < _973)
    goto _jump1396;
    _978 = 0;
    _979++;
    if (_979 < i.d2)
    goto _jump1396;
    // End body of loop
    int64_t _983 = -d;
    if (_969 >= 0)
    goto _jump1400;
    fail_assertion("negative array index");
    _jump1400:;
    if (_969 < _960.d0)
    goto _jump1401;
    fail_assertion("index too large");
    _jump1401:;
    if (_972 >= 0)
    goto _jump1402;
    fail_assertion("negative array index");
    _jump1402:;
    if (_972 < _960.d1)
    goto _jump1403;
    fail_assertion("index too large");
    _jump1403:;
    if (_983 >= 0)
    goto _jump1404;
    fail_assertion("negative array index");
    _jump1404:;
    if (_983 < _960.d2)
    goto _jump1405;
    fail_assertion("index too large");
    _jump1405:;
    int64_t _984 = 0;
    _984 *= _960.d0;
    _984 += _969;
    _984 *= _960.d1;
    _984 += _972;
    _984 *= _960.d2;
    _984 += _983;
    _a3_bool _985 = _960.data[_984];
    a _986 = f(g, _959, _985);
    int64_t _987 = _986.a;
    _942 += _987;
    _957++;
    if (_957 < _956)
    goto _jump1383;
    _957 = 0;
    _958++;
    if (_958 < _943)
    goto _jump1383;
    // End body of loop
    bool _990 = false;
    bool _989 = _990;
    if (0 != _990)
    goto _jump1406;
    if (d >= 0)
    goto _jump1407;
    fail_assertion("negative array index");
    _jump1407:;
    if (d < c.d0)
    goto _jump1408;
    fail_assertion("index too large");
    _jump1408:;
    int64_t _991 = 0;
    _991 *= c.d0;
    _991 += d;
    bool _992 = c.data[_991];
    _989 = _992;
    _jump1406:;
    bool _988 = _989;
    if (0 != _989)
    goto _jump1409;
    bool _993 = h == i.d1;
    bool _994 = true;
    bool _995 = _993 == _994;
    _988 = _995;
    _jump1409:;
    int64_t _996;
    if (!_988)
    goto _jump1410;
    int64_t _997;
    // Computing bound for n
    int64_t _998;
    // Computing bound for n
    int64_t _999 = -i.d2;
    if (_999 > 0) 
    goto _jump1411;
    fail_assertion("non-positive loop bound");
    _jump1411:;
    _998 = 0;
    int64_t _1000 = 0; // n
    _jump1412:; // Begin body of loop
    _998 += i.d0;
    _1000++;
    if (_1000 < _999)
    goto _jump1412;
    // End body of loop
    if (_998 > 0) 
    goto _jump1413;
    fail_assertion("non-positive loop bound");
    _jump1413:;
    _997 = 0;
    int64_t _1001 = 0; // n
    _jump1414:; // Begin body of loop
    _997 += i.d2;
    _1001++;
    if (_1001 < _998)
    goto _jump1414;
    // End body of loop
    _996 = _997;
    goto _jump1415;
    _jump1410:;
    bool _1002 = true;
    bool _1003 = !_1002;
    int64_t _1004;
    if (!_1003)
    goto _jump1416;
    int64_t _1005;
    // Computing bound for n
    if (i.d1 > 0) 
    goto _jump1417;
    fail_assertion("non-positive loop bound");
    _jump1417:;
    // Computing bound for o
    int64_t _1006 = 164;
    if (_1006 > 0) 
    goto _jump1418;
    fail_assertion("non-positive loop bound");
    _jump1418:;
    _1005 = 0;
    int64_t _1007 = 0; // o
    int64_t _1008 = 0; // n
    _jump1419:; // Begin body of loop
    _1005 += _1007;
    _1007++;
    if (_1007 < _1006)
    goto _jump1419;
    _1007 = 0;
    _1008++;
    if (_1008 < i.d1)
    goto _jump1419;
    // End body of loop
    _1004 = _1005;
    goto _jump1420;
    _jump1416:;
    _1004 = i.d2;
    _jump1420:;
    _996 = _1004;
    _jump1415:;
    int64_t _1009 = i.d2 / i.d1;
    a _1010 = f(g, _1009, i);
    int64_t _1011 = _1010.a;
    int64_t _1012 = _1011 - i.d1;
    bool _1013 = _996 != _1012;
    int64_t _1014;
    if (!_1013)
    goto _jump1421;
    _1014 = i.d0;
    goto _jump1422;
    _jump1421:;
    _a2_int64_t _1015;
    // Computing bound for n
    bool _1016 = false;
    int64_t _1017;
    if (!_1016)
    goto _jump1423;
    _1017 = i.d1;
    goto _jump1424;
    _jump1423:;
    _1017 = h;
    _jump1424:;
    _1015.d0 = _1017;
    if (_1017 > 0) 
    goto _jump1425;
    fail_assertion("non-positive loop bound");
    _jump1425:;
    // Computing bound for o
    int64_t _1018 = -i.d0;
    int64_t _1019 = -h;
    int64_t _1020 = _1018 * _1019;
    _1015.d1 = _1020;
    if (_1020 > 0) 
    goto _jump1426;
    fail_assertion("non-positive loop bound");
    _jump1426:;
    // Computing total size of heap memory to allocate
    int64_t _1021 = 1;
    _1021 *= _1017;
    _1021 *= _1020;
    _1021 *= sizeof(int64_t);
    _1015.data = jpl_alloc(_1021);
    int64_t _1022 = 0; // o
    int64_t _1023 = 0; // n
    _jump1427:; // Begin body of loop
    int64_t _1024 = 0;
    _1024 *= _1015.d0;
    _1024 += _1023;
    _1024 *= _1015.d1;
    _1024 += _1022;
    _1015.data[_1024] = i.d0;
    _1022++;
    if (_1022 < _1020)
    goto _jump1427;
    _1022 = 0;
    _1023++;
    if (_1023 < _1017)
    goto _jump1427;
    // End body of loop
    _a1_int64_t _1025;
    _1025.d0 = 2;
    _1025.data = jpl_alloc(sizeof(int64_t) * 2);
    _1025.data[0] = i.d2;
    _1025.data[1] = i.d1;
    a _1026 = { i.d1, g };
    a _1027 = b(i.d1, _1025, _1026);
    int64_t _1028 = _1027.a;
    if (i.d0 >= 0)
    goto _jump1428;
    fail_assertion("negative array index");
    _jump1428:;
    if (i.d0 < _1015.d0)
    goto _jump1429;
    fail_assertion("index too large");
    _jump1429:;
    if (_1028 >= 0)
    goto _jump1430;
    fail_assertion("negative array index");
    _jump1430:;
    if (_1028 < _1015.d1)
    goto _jump1431;
    fail_assertion("index too large");
    _jump1431:;
    int64_t _1029 = 0;
    _1029 *= _1015.d0;
    _1029 += i.d0;
    _1029 *= _1015.d1;
    _1029 += _1028;
    int64_t _1030 = _1015.data[_1029];
    _1014 = _1030;
    _jump1422:;
    if (i.d1 >= 0)
    goto _jump1432;
    fail_assertion("negative array index");
    _jump1432:;
    if (i.d1 < _776.d0)
    goto _jump1433;
    fail_assertion("index too large");
    _jump1433:;
    if (_942 >= 0)
    goto _jump1434;
    fail_assertion("negative array index");
    _jump1434:;
    if (_942 < _776.d1)
    goto _jump1435;
    fail_assertion("index too large");
    _jump1435:;
    if (_1014 >= 0)
    goto _jump1436;
    fail_assertion("negative array index");
    _jump1436:;
    if (_1014 < _776.d2)
    goto _jump1437;
    fail_assertion("index too large");
    _jump1437:;
    int64_t _1031 = 0;
    _1031 *= _776.d0;
    _1031 += i.d1;
    _1031 *= _776.d1;
    _1031 += _942;
    _1031 *= _776.d2;
    _1031 += _1014;
    _a2_int64_t _1032 = _776.data[_1031];
    double _1033 = 6.0;
    double _1034 = -_1033;
    double _1035 = 99.0;
    double _1036;
    // Computing bound for q
    int64_t _1037;
    // Computing bound for q
    if (h > 0) 
    goto _jump1438;
    fail_assertion("non-positive loop bound");
    _jump1438:;
    // Computing bound for r
    if (_1032.d0 > 0) 
    goto _jump1439;
    fail_assertion("non-positive loop bound");
    _jump1439:;
    _1037 = 0;
    int64_t _1038 = 0; // r
    int64_t _1039 = 0; // q
    _jump1440:; // Begin body of loop
    _1037 += i.d1;
    _1038++;
    if (_1038 < _1032.d0)
    goto _jump1440;
    _1038 = 0;
    _1039++;
    if (_1039 < h)
    goto _jump1440;
    // End body of loop
    int64_t _1040 = -_1037;
    if (_1040 > 0) 
    goto _jump1441;
    fail_assertion("non-positive loop bound");
    _jump1441:;
    // Computing bound for r
    int64_t _1041 = i.d0 + _1032.d0;
    if (_1041 > 0) 
    goto _jump1442;
    fail_assertion("non-positive loop bound");
    _jump1442:;
    _1036 = 0;
    int64_t _1042 = 0; // r
    int64_t _1043 = 0; // q
    _jump1443:; // Begin body of loop
    _a1_double _1044;
    // Computing bound for s
    _1044.d0 = _1043;
    if (_1043 > 0) 
    goto _jump1444;
    fail_assertion("non-positive loop bound");
    _jump1444:;
    // Computing total size of heap memory to allocate
    int64_t _1045 = 1;
    _1045 *= _1043;
    _1045 *= sizeof(double);
    _1044.data = jpl_alloc(_1045);
    int64_t _1046 = 0; // s
    _jump1445:; // Begin body of loop
    double _1047 = 25.0;
    int64_t _1048 = 0;
    _1048 *= _1044.d0;
    _1048 += _1046;
    _1044.data[_1048] = _1047;
    _1046++;
    if (_1046 < _1043)
    goto _jump1445;
    // End body of loop
    if (i.d0 >= 0)
    goto _jump1446;
    fail_assertion("negative array index");
    _jump1446:;
    if (i.d0 < _1044.d0)
    goto _jump1447;
    fail_assertion("index too large");
    _jump1447:;
    int64_t _1049 = 0;
    _1049 *= _1044.d0;
    _1049 += i.d0;
    double _1050 = _1044.data[_1049];
    _1036 += _1050;
    _1042++;
    if (_1042 < _1041)
    goto _jump1443;
    _1042 = 0;
    _1043++;
    if (_1043 < _1040)
    goto _jump1443;
    // End body of loop
    double _1051 = _1035 - _1036;
    double _1052 = 44.0;
    double _1053 = 77.0;
    rgba _1054 = { _1034, _1051, _1052, _1053 };
    double _1055 = _1054.a;
    _a1_bool _1056;
    // Computing bound for q
    _1056.d0 = _1032.d1;
    if (_1032.d1 > 0) 
    goto _jump1448;
    fail_assertion("non-positive loop bound");
    _jump1448:;
    // Computing total size of heap memory to allocate
    int64_t _1057 = 1;
    _1057 *= _1032.d1;
    _1057 *= sizeof(bool);
    _1056.data = jpl_alloc(_1057);
    int64_t _1058 = 0; // q
    _jump1449:; // Begin body of loop
    bool _1059 = false;
    int64_t _1060 = 0;
    _1060 *= _1056.d0;
    _1060 += _1058;
    _1056.data[_1060] = _1059;
    _1058++;
    if (_1058 < _1032.d1)
    goto _jump1449;
    // End body of loop
    int64_t _1061;
    // Computing bound for q
    int64_t _1062 = 240;
    if (_1062 > 0) 
    goto _jump1450;
    fail_assertion("non-positive loop bound");
    _jump1450:;
    // Computing bound for r
    if (h > 0) 
    goto _jump1451;
    fail_assertion("non-positive loop bound");
    _jump1451:;
    // Computing bound for s
    if (i.d1 > 0) 
    goto _jump1452;
    fail_assertion("non-positive loop bound");
    _jump1452:;
    _1061 = 0;
    int64_t _1063 = 0; // s
    int64_t _1064 = 0; // r
    int64_t _1065 = 0; // q
    _jump1453:; // Begin body of loop
    int64_t _1066 = 305;
    _1061 += _1066;
    _1063++;
    if (_1063 < i.d1)
    goto _jump1453;
    _1063 = 0;
    _1064++;
    if (_1064 < h)
    goto _jump1453;
    _1064 = 0;
    _1065++;
    if (_1065 < _1062)
    goto _jump1453;
    // End body of loop
    if (_1061 >= 0)
    goto _jump1454;
    fail_assertion("negative array index");
    _jump1454:;
    if (_1061 < _1056.d0)
    goto _jump1455;
    fail_assertion("index too large");
    _jump1455:;
    int64_t _1067 = 0;
    _1067 *= _1056.d0;
    _1067 += _1061;
    bool _1068 = _1056.data[_1067];
    bool _1069 = !_1068;
    double _1070;
    if (!_1069)
    goto _jump1456;
    double _1071 = 15.0;
    double _1072 = -_1071;
    double _1073 = 29.0;
    double _1074 = _774.a;
    double _1075 = fmod(_1073, _1074);
    double _1076 = _1072 * _1075;
    _1070 = _1076;
    goto _jump1457;
    _jump1456:;
    double _1077 = 49.0;
    _1070 = _1077;
    _jump1457:;
    double _1078 = -_1070;
    double _1079 = -_1078;
    double _1080 = _774.a;
    _a1_double _1081;
    // Computing bound for q
    int64_t _1082;
    // Computing bound for q
    if (d > 0) 
    goto _jump1458;
    fail_assertion("non-positive loop bound");
    _jump1458:;
    // Computing bound for r
    int64_t _1083;
    // Computing bound for q
    int64_t _1084 = 589;
    if (_1084 > 0) 
    goto _jump1459;
    fail_assertion("non-positive loop bound");
    _jump1459:;
    _1083 = 0;
    int64_t _1085 = 0; // q
    _jump1460:; // Begin body of loop
    _1083 += _1032.d0;
    _1085++;
    if (_1085 < _1084)
    goto _jump1460;
    // End body of loop
    if (_1083 > 0) 
    goto _jump1461;
    fail_assertion("non-positive loop bound");
    _jump1461:;
    _1082 = 0;
    int64_t _1086 = 0; // r
    int64_t _1087 = 0; // q
    _jump1462:; // Begin body of loop
    _1082 += h;
    _1086++;
    if (_1086 < _1083)
    goto _jump1462;
    _1086 = 0;
    _1087++;
    if (_1087 < d)
    goto _jump1462;
    // End body of loop
    _1081.d0 = _1082;
    if (_1082 > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing total size of heap memory to allocate
    int64_t _1088 = 1;
    _1088 *= _1082;
    _1088 *= sizeof(double);
    _1081.data = jpl_alloc(_1088);
    int64_t _1089 = 0; // q
    _jump1464:; // Begin body of loop
    double _1090;
    // Computing bound for r
    int64_t _1091 = h + i.d1;
    int64_t _1092 = _1032.d1 * _1091;
    if (_1092 > 0) 
    goto _jump1465;
    fail_assertion("non-positive loop bound");
    _jump1465:;
    _1090 = 0;
    int64_t _1093 = 0; // r
    _jump1466:; // Begin body of loop
    double _1094;
    // Computing bound for s
    if (_1089 > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    // Computing bound for t
    if (h > 0) 
    goto _jump1468;
    fail_assertion("non-positive loop bound");
    _jump1468:;
    // Computing bound for u
    if (_1093 > 0) 
    goto _jump1469;
    fail_assertion("non-positive loop bound");
    _jump1469:;
    _1094 = 0;
    int64_t _1095 = 0; // u
    int64_t _1096 = 0; // t
    int64_t _1097 = 0; // s
    _jump1470:; // Begin body of loop
    double _1098 = 57.0;
    _1094 += _1098;
    _1095++;
    if (_1095 < _1093)
    goto _jump1470;
    _1095 = 0;
    _1096++;
    if (_1096 < h)
    goto _jump1470;
    _1096 = 0;
    _1097++;
    if (_1097 < _1089)
    goto _jump1470;
    // End body of loop
    _1090 += _1094;
    _1093++;
    if (_1093 < _1092)
    goto _jump1466;
    // End body of loop
    int64_t _1099 = 0;
    _1099 *= _1081.d0;
    _1099 += _1089;
    _1081.data[_1099] = _1090;
    _1089++;
    if (_1089 < _1082)
    goto _jump1464;
    // End body of loop
    int64_t _1100 = -i.d1;
    if (_1100 >= 0)
    goto _jump1471;
    fail_assertion("negative array index");
    _jump1471:;
    if (_1100 < _1081.d0)
    goto _jump1472;
    fail_assertion("index too large");
    _jump1472:;
    int64_t _1101 = 0;
    _1101 *= _1081.d0;
    _1101 += _1100;
    double _1102 = _1081.data[_1101];
    double _1103 = 41.0;
    double _1104 = fmod(_1102, _1103);
    rgba _1105 = { _1055, _1079, _1080, _1104 };
    double _1106 = _1105.a;
    double _1107 = 19.0;
    bool _1108 = _1106 != _1107;
    _a2_double _1109;
    if (!_1108)
    goto _jump1473;
    _a2_double _1110;
    // Computing bound for r
    _1110.d0 = _1032.d1;
    if (_1032.d1 > 0) 
    goto _jump1474;
    fail_assertion("non-positive loop bound");
    _jump1474:;
    // Computing bound for s
    int64_t _1111 = 751;
    _1110.d1 = _1111;
    if (_1111 > 0) 
    goto _jump1475;
    fail_assertion("non-positive loop bound");
    _jump1475:;
    // Computing total size of heap memory to allocate
    int64_t _1112 = 1;
    _1112 *= _1032.d1;
    _1112 *= _1111;
    _1112 *= sizeof(double);
    _1110.data = jpl_alloc(_1112);
    int64_t _1113 = 0; // s
    int64_t _1114 = 0; // r
    _jump1476:; // Begin body of loop
    double _1115;
    // Computing bound for t
    if (i.d2 > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    // Computing bound for u
    if (_1114 > 0) 
    goto _jump1478;
    fail_assertion("non-positive loop bound");
    _jump1478:;
    _1115 = 0;
    int64_t _1116 = 0; // u
    int64_t _1117 = 0; // t
    _jump1479:; // Begin body of loop
    double _1118 = 75.0;
    _1115 += _1118;
    _1116++;
    if (_1116 < _1114)
    goto _jump1479;
    _1116 = 0;
    _1117++;
    if (_1117 < i.d2)
    goto _jump1479;
    // End body of loop
    int64_t _1119 = 0;
    _1119 *= _1110.d0;
    _1119 += _1114;
    _1119 *= _1110.d1;
    _1119 += _1113;
    _1110.data[_1119] = _1115;
    _1113++;
    if (_1113 < _1111)
    goto _jump1476;
    _1113 = 0;
    _1114++;
    if (_1114 < _1032.d1)
    goto _jump1476;
    // End body of loop
    _1109 = _1110;
    goto _jump1480;
    _jump1473:;
    _a2_double _1120;
    // Computing bound for r
    int64_t _1121;
    // Computing bound for r
    if (i.d1 > 0) 
    goto _jump1481;
    fail_assertion("non-positive loop bound");
    _jump1481:;
    // Computing bound for s
    if (h > 0) 
    goto _jump1482;
    fail_assertion("non-positive loop bound");
    _jump1482:;
    _1121 = 0;
    int64_t _1122 = 0; // s
    int64_t _1123 = 0; // r
    _jump1483:; // Begin body of loop
    _1121 += _1122;
    _1122++;
    if (_1122 < h)
    goto _jump1483;
    _1122 = 0;
    _1123++;
    if (_1123 < i.d1)
    goto _jump1483;
    // End body of loop
    _1120.d0 = _1121;
    if (_1121 > 0) 
    goto _jump1484;
    fail_assertion("non-positive loop bound");
    _jump1484:;
    // Computing bound for s
    _1120.d1 = h;
    if (h > 0) 
    goto _jump1485;
    fail_assertion("non-positive loop bound");
    _jump1485:;
    // Computing total size of heap memory to allocate
    int64_t _1124 = 1;
    _1124 *= _1121;
    _1124 *= h;
    _1124 *= sizeof(double);
    _1120.data = jpl_alloc(_1124);
    int64_t _1125 = 0; // s
    int64_t _1126 = 0; // r
    _jump1486:; // Begin body of loop
    double _1127 = _1105.a;
    int64_t _1128 = 0;
    _1128 *= _1120.d0;
    _1128 += _1126;
    _1128 *= _1120.d1;
    _1128 += _1125;
    _1120.data[_1128] = _1127;
    _1125++;
    if (_1125 < h)
    goto _jump1486;
    _1125 = 0;
    _1126++;
    if (_1126 < _1121)
    goto _jump1486;
    // End body of loop
    _1109 = _1120;
    _jump1480:;
    bool _1129 = true;
    bool _1130 = !_1129;
    bool _1131;
    if (!_1130)
    goto _jump1487;
    bool _1132 = i.d2 < h;
    _1131 = _1132;
    goto _jump1488;
    _jump1487:;
    bool _1133 = false;
    bool _1134 = !_1133;
    _1131 = _1134;
    _jump1488:;
    int64_t _1135;
    if (!_1131)
    goto _jump1489;
    int64_t _1136;
    // Computing bound for r
    int64_t _1137 = 878;
    if (_1137 > 0) 
    goto _jump1490;
    fail_assertion("non-positive loop bound");
    _jump1490:;
    _1136 = 0;
    int64_t _1138 = 0; // r
    _jump1491:; // Begin body of loop
    _1136 += _1032.d1;
    _1138++;
    if (_1138 < _1137)
    goto _jump1491;
    // End body of loop
    _1135 = _1136;
    goto _jump1492;
    _jump1489:;
    int64_t _1139;
    // Computing bound for r
    if (_1032.d0 > 0) 
    goto _jump1493;
    fail_assertion("non-positive loop bound");
    _jump1493:;
    // Computing bound for s
    int64_t _1140 = _1032.d0 - _1032.d0;
    if (_1140 > 0) 
    goto _jump1494;
    fail_assertion("non-positive loop bound");
    _jump1494:;
    // Computing bound for t
    if (i.d2 > 0) 
    goto _jump1495;
    fail_assertion("non-positive loop bound");
    _jump1495:;
    _1139 = 0;
    int64_t _1141 = 0; // t
    int64_t _1142 = 0; // s
    int64_t _1143 = 0; // r
    _jump1496:; // Begin body of loop
    _1139 += _1141;
    _1141++;
    if (_1141 < i.d2)
    goto _jump1496;
    _1141 = 0;
    _1142++;
    if (_1142 < _1140)
    goto _jump1496;
    _1142 = 0;
    _1143++;
    if (_1143 < _1032.d0)
    goto _jump1496;
    // End body of loop
    _1135 = _1139;
    _jump1492:;
    if (_1135 >= 0)
    goto _jump1497;
    fail_assertion("negative array index");
    _jump1497:;
    if (_1135 < _1109.d0)
    goto _jump1498;
    fail_assertion("index too large");
    _jump1498:;
    if (_1032.d0 >= 0)
    goto _jump1499;
    fail_assertion("negative array index");
    _jump1499:;
    if (_1032.d0 < _1109.d1)
    goto _jump1500;
    fail_assertion("index too large");
    _jump1500:;
    int64_t _1144 = 0;
    _1144 *= _1109.d0;
    _1144 += _1135;
    _1144 *= _1109.d1;
    _1144 += _1032.d0;
    double _1145 = _1109.data[_1144];
    double _1146 = 96.0;
    bool _1147 = _1145 == _1146;
    _a3_a _1148;
    if (!_1147)
    goto _jump1501;
    _a3_a _1149;
    // Computing bound for r
    _1149.d0 = i.d2;
    if (i.d2 > 0) 
    goto _jump1502;
    fail_assertion("non-positive loop bound");
    _jump1502:;
    // Computing bound for s
    _1149.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1503;
    fail_assertion("non-positive loop bound");
    _jump1503:;
    // Computing bound for t
    _1149.d2 = d;
    if (d > 0) 
    goto _jump1504;
    fail_assertion("non-positive loop bound");
    _jump1504:;
    // Computing total size of heap memory to allocate
    int64_t _1150 = 1;
    _1150 *= i.d2;
    _1150 *= i.d1;
    _1150 *= d;
    _1150 *= sizeof(a);
    _1149.data = jpl_alloc(_1150);
    int64_t _1151 = 0; // t
    int64_t _1152 = 0; // s
    int64_t _1153 = 0; // r
    _jump1505:; // Begin body of loop
    a _1154 = { h, g };
    void_t _1155 = _1154.b;
    a _1156 = { _1151, _1155 };
    int64_t _1157 = 0;
    _1157 *= _1149.d0;
    _1157 += _1153;
    _1157 *= _1149.d1;
    _1157 += _1152;
    _1157 *= _1149.d2;
    _1157 += _1151;
    _1149.data[_1157] = _1156;
    _1151++;
    if (_1151 < d)
    goto _jump1505;
    _1151 = 0;
    _1152++;
    if (_1152 < i.d1)
    goto _jump1505;
    _1152 = 0;
    _1153++;
    if (_1153 < i.d2)
    goto _jump1505;
    // End body of loop
    _1148 = _1149;
    goto _jump1506;
    _jump1501:;
    bool _1158 = true;
    _a3_a _1159;
    if (!_1158)
    goto _jump1507;
    _a2__a3_a _1160;
    // Computing bound for r
    _a3_int64_t _1161;
    // Computing bound for r
    _1161.d0 = i.d0;
    if (i.d0 > 0) 
    goto _jump1508;
    fail_assertion("non-positive loop bound");
    _jump1508:;
    // Computing bound for s
    _1161.d1 = i.d1;
    if (i.d1 > 0) 
    goto _jump1509;
    fail_assertion("non-positive loop bound");
    _jump1509:;
    // Computing bound for t
    int64_t _1162 = 131;
    _1161.d2 = _1162;
    if (_1162 > 0) 
    goto _jump1510;
    fail_assertion("non-positive loop bound");
    _jump1510:;
    // Computing total size of heap memory to allocate
    int64_t _1163 = 1;
    _1163 *= i.d0;
    _1163 *= i.d1;
    _1163 *= _1162;
    _1163 *= sizeof(int64_t);
    _1161.data = jpl_alloc(_1163);
    int64_t _1164 = 0; // t
    int64_t _1165 = 0; // s
    int64_t _1166 = 0; // r
    _jump1511:; // Begin body of loop
    int64_t _1167 = 0;
    _1167 *= _1161.d0;
    _1167 += _1166;
    _1167 *= _1161.d1;
    _1167 += _1165;
    _1167 *= _1161.d2;
    _1167 += _1164;
    _1161.data[_1167] = i.d1;
    _1164++;
    if (_1164 < _1162)
    goto _jump1511;
    _1164 = 0;
    _1165++;
    if (_1165 < i.d1)
    goto _jump1511;
    _1165 = 0;
    _1166++;
    if (_1166 < i.d0)
    goto _jump1511;
    // End body of loop
    if (_1032.d1 >= 0)
    goto _jump1512;
    fail_assertion("negative array index");
    _jump1512:;
    if (_1032.d1 < _1032.d0)
    goto _jump1513;
    fail_assertion("index too large");
    _jump1513:;
    if (_1032.d1 >= 0)
    goto _jump1514;
    fail_assertion("negative array index");
    _jump1514:;
    if (_1032.d1 < _1032.d1)
    goto _jump1515;
    fail_assertion("index too large");
    _jump1515:;
    int64_t _1168 = 0;
    _1168 *= _1032.d0;
    _1168 += _1032.d1;
    _1168 *= _1032.d1;
    _1168 += _1032.d1;
    int64_t _1169 = _1032.data[_1168];
    if (i.d0 >= 0)
    goto _jump1516;
    fail_assertion("negative array index");
    _jump1516:;
    if (i.d0 < _1161.d0)
    goto _jump1517;
    fail_assertion("index too large");
    _jump1517:;
    if (_1169 >= 0)
    goto _jump1518;
    fail_assertion("negative array index");
    _jump1518:;
    if (_1169 < _1161.d1)
    goto _jump1519;
    fail_assertion("index too large");
    _jump1519:;
    if (_1032.d0 >= 0)
    goto _jump1520;
    fail_assertion("negative array index");
    _jump1520:;
    if (_1032.d0 < _1161.d2)
    goto _jump1521;
    fail_assertion("index too large");
    _jump1521:;
    int64_t _1170 = 0;
    _1170 *= _1161.d0;
    _1170 += i.d0;
    _1170 *= _1161.d1;
    _1170 += _1169;
    _1170 *= _1161.d2;
    _1170 += _1032.d0;
    int64_t _1171 = _1161.data[_1170];
    _1160.d0 = _1171;
    if (_1171 > 0) 
    goto _jump1522;
    fail_assertion("non-positive loop bound");
    _jump1522:;
    // Computing bound for s
    int64_t _1172;
    // Computing bound for r
    if (_1032.d1 > 0) 
    goto _jump1523;
    fail_assertion("non-positive loop bound");
    _jump1523:;
    // Computing bound for s
    if (i.d0 > 0) 
    goto _jump1524;
    fail_assertion("non-positive loop bound");
    _jump1524:;
    // Computing bound for t
    if (i.d2 > 0) 
    goto _jump1525;
    fail_assertion("non-positive loop bound");
    _jump1525:;
    _1172 = 0;
    int64_t _1173 = 0; // t
    int64_t _1174 = 0; // s
    int64_t _1175 = 0; // r
    _jump1526:; // Begin body of loop
    _1172 += _1032.d1;
    _1173++;
    if (_1173 < i.d2)
    goto _jump1526;
    _1173 = 0;
    _1174++;
    if (_1174 < i.d0)
    goto _jump1526;
    _1174 = 0;
    _1175++;
    if (_1175 < _1032.d1)
    goto _jump1526;
    // End body of loop
    int64_t _1176 = i.d0 + _1032.d1;
    int64_t _1177 = _1172 * _1176;
    _1160.d1 = _1177;
    if (_1177 > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing total size of heap memory to allocate
    int64_t _1178 = 1;
    _1178 *= _1171;
    _1178 *= _1177;
    _1178 *= sizeof(_a3_a);
    _1160.data = jpl_alloc(_1178);
    int64_t _1179 = 0; // s
    int64_t _1180 = 0; // r
    _jump1528:; // Begin body of loop
    _a3_a _1181;
    // Computing bound for t
    int64_t _1182 = -_1032.d0;
    _1181.d0 = _1182;
    if (_1182 > 0) 
    goto _jump1529;
    fail_assertion("non-positive loop bound");
    _jump1529:;
    // Computing bound for u
    _1181.d1 = i.d0;
    if (i.d0 > 0) 
    goto _jump1530;
    fail_assertion("non-positive loop bound");
    _jump1530:;
    // Computing bound for v
    _1181.d2 = i.d0;
    if (i.d0 > 0) 
    goto _jump1531;
    fail_assertion("non-positive loop bound");
    _jump1531:;
    // Computing total size of heap memory to allocate
    int64_t _1183 = 1;
    _1183 *= _1182;
    _1183 *= i.d0;
    _1183 *= i.d0;
    _1183 *= sizeof(a);
    _1181.data = jpl_alloc(_1183);
    int64_t _1184 = 0; // v
    int64_t _1185 = 0; // u
    int64_t _1186 = 0; // t
    _jump1532:; // Begin body of loop
    a _1187 = f(g, d, i);
    int64_t _1188 = 0;
    _1188 *= _1181.d0;
    _1188 += _1186;
    _1188 *= _1181.d1;
    _1188 += _1185;
    _1188 *= _1181.d2;
    _1188 += _1184;
    _1181.data[_1188] = _1187;
    _1184++;
    if (_1184 < i.d0)
    goto _jump1532;
    _1184 = 0;
    _1185++;
    if (_1185 < i.d0)
    goto _jump1532;
    _1185 = 0;
    _1186++;
    if (_1186 < _1182)
    goto _jump1532;
    // End body of loop
    int64_t _1189 = 0;
    _1189 *= _1160.d0;
    _1189 += _1180;
    _1189 *= _1160.d1;
    _1189 += _1179;
    _1160.data[_1189] = _1181;
    _1179++;
    if (_1179 < _1177)
    goto _jump1528;
    _1179 = 0;
    _1180++;
    if (_1180 < _1171)
    goto _jump1528;
    // End body of loop
    if (d >= 0)
    goto _jump1533;
    fail_assertion("negative array index");
    _jump1533:;
    if (d < _1160.d0)
    goto _jump1534;
    fail_assertion("index too large");
    _jump1534:;
    if (i.d1 >= 0)
    goto _jump1535;
    fail_assertion("negative array index");
    _jump1535:;
    if (i.d1 < _1160.d1)
    goto _jump1536;
    fail_assertion("index too large");
    _jump1536:;
    int64_t _1190 = 0;
    _1190 *= _1160.d0;
    _1190 += d;
    _1190 *= _1160.d1;
    _1190 += i.d1;
    _a3_a _1191 = _1160.data[_1190];
    _1159 = _1191;
    goto _jump1537;
    _jump1507:;
    _a3_a _1192;
    // Computing bound for r
    _a2_int64_t _1193;
    // Computing bound for r
    int64_t _1194 = -d;
    _1193.d0 = _1194;
    if (_1194 > 0) 
    goto _jump1538;
    fail_assertion("non-positive loop bound");
    _jump1538:;
    // Computing bound for s
    _1193.d1 = h;
    if (h > 0) 
    goto _jump1539;
    fail_assertion("non-positive loop bound");
    _jump1539:;
    // Computing total size of heap memory to allocate
    int64_t _1195 = 1;
    _1195 *= _1194;
    _1195 *= h;
    _1195 *= sizeof(int64_t);
    _1193.data = jpl_alloc(_1195);
    int64_t _1196 = 0; // s
    int64_t _1197 = 0; // r
    _jump1540:; // Begin body of loop
    int64_t _1198 = 0;
    _1198 *= _1193.d0;
    _1198 += _1197;
    _1198 *= _1193.d1;
    _1198 += _1196;
    _1193.data[_1198] = i.d2;
    _1196++;
    if (_1196 < h)
    goto _jump1540;
    _1196 = 0;
    _1197++;
    if (_1197 < _1194)
    goto _jump1540;
    // End body of loop
    int64_t _1199 = -_1032.d1;
    if (_1199 >= 0)
    goto _jump1541;
    fail_assertion("negative array index");
    _jump1541:;
    if (_1199 < _1193.d0)
    goto _jump1542;
    fail_assertion("index too large");
    _jump1542:;
    if (i.d2 >= 0)
    goto _jump1543;
    fail_assertion("negative array index");
    _jump1543:;
    if (i.d2 < _1193.d1)
    goto _jump1544;
    fail_assertion("index too large");
    _jump1544:;
    int64_t _1200 = 0;
    _1200 *= _1193.d0;
    _1200 += _1199;
    _1200 *= _1193.d1;
    _1200 += i.d2;
    int64_t _1201 = _1193.data[_1200];
    _1192.d0 = _1201;
    if (_1201 > 0) 
    goto _jump1545;
    fail_assertion("non-positive loop bound");
    _jump1545:;
    // Computing bound for s
    int64_t _1202 = -h;
    _1192.d1 = _1202;
    if (_1202 > 0) 
    goto _jump1546;
    fail_assertion("non-positive loop bound");
    _jump1546:;
    // Computing bound for t
    int64_t _1203;
    // Computing bound for r
    if (i.d0 > 0) 
    goto _jump1547;
    fail_assertion("non-positive loop bound");
    _jump1547:;
    // Computing bound for s
    int64_t _1204 = _1032.d1 % i.d1;
    int64_t _1205 = h / _1204;
    if (_1205 > 0) 
    goto _jump1548;
    fail_assertion("non-positive loop bound");
    _jump1548:;
    // Computing bound for t
    a _1206 = f(g, i.d2, i);
    int64_t _1207 = _1206.a;
    if (_1207 > 0) 
    goto _jump1549;
    fail_assertion("non-positive loop bound");
    _jump1549:;
    _1203 = 0;
    int64_t _1208 = 0; // t
    int64_t _1209 = 0; // s
    int64_t _1210 = 0; // r
    _jump1550:; // Begin body of loop
    _1203 += _1032.d0;
    _1208++;
    if (_1208 < _1207)
    goto _jump1550;
    _1208 = 0;
    _1209++;
    if (_1209 < _1205)
    goto _jump1550;
    _1209 = 0;
    _1210++;
    if (_1210 < i.d0)
    goto _jump1550;
    // End body of loop
    _1192.d2 = _1203;
    if (_1203 > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    // Computing total size of heap memory to allocate
    int64_t _1211 = 1;
    _1211 *= _1201;
    _1211 *= _1202;
    _1211 *= _1203;
    _1211 *= sizeof(a);
    _1192.data = jpl_alloc(_1211);
    int64_t _1212 = 0; // t
    int64_t _1213 = 0; // s
    int64_t _1214 = 0; // r
    _jump1552:; // Begin body of loop
    a _1215 = f(g, i.d2, i);
    int64_t _1216 = _1215.a;
    a _1217 = { _1216, g };
    int64_t _1218 = 0;
    _1218 *= _1192.d0;
    _1218 += _1214;
    _1218 *= _1192.d1;
    _1218 += _1213;
    _1218 *= _1192.d2;
    _1218 += _1212;
    _1192.data[_1218] = _1217;
    _1212++;
    if (_1212 < _1203)
    goto _jump1552;
    _1212 = 0;
    _1213++;
    if (_1213 < _1202)
    goto _jump1552;
    _1213 = 0;
    _1214++;
    if (_1214 < _1201)
    goto _jump1552;
    // End body of loop
    _1159 = _1192;
    _jump1537:;
    _1148 = _1159;
    _jump1506:;
    int64_t _1219 = 896;
    _a1_a _1220;
    // Computing bound for r
    _1220.d0 = h;
    if (h > 0) 
    goto _jump1553;
    fail_assertion("non-positive loop bound");
    _jump1553:;
    // Computing total size of heap memory to allocate
    int64_t _1221 = 1;
    _1221 *= h;
    _1221 *= sizeof(a);
    _1220.data = jpl_alloc(_1221);
    int64_t _1222 = 0; // r
    _jump1554:; // Begin body of loop
    _a1__a3_bool _1223;
    // Computing bound for s
    _1223.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1555;
    fail_assertion("non-positive loop bound");
    _jump1555:;
    // Computing total size of heap memory to allocate
    int64_t _1224 = 1;
    _1224 *= i.d1;
    _1224 *= sizeof(_a3_bool);
    _1223.data = jpl_alloc(_1224);
    int64_t _1225 = 0; // s
    _jump1556:; // Begin body of loop
    int64_t _1226 = 0;
    _1226 *= _1223.d0;
    _1226 += _1225;
    _1223.data[_1226] = i;
    _1225++;
    if (_1225 < i.d1)
    goto _jump1556;
    // End body of loop
    if (d >= 0)
    goto _jump1557;
    fail_assertion("negative array index");
    _jump1557:;
    if (d < _1223.d0)
    goto _jump1558;
    fail_assertion("index too large");
    _jump1558:;
    int64_t _1227 = 0;
    _1227 *= _1223.d0;
    _1227 += d;
    _a3_bool _1228 = _1223.data[_1227];
    a _1229 = f(g, i.d1, _1228);
    int64_t _1230 = 0;
    _1230 *= _1220.d0;
    _1230 += _1222;
    _1220.data[_1230] = _1229;
    _1222++;
    if (_1222 < h)
    goto _jump1554;
    // End body of loop
    if (d >= 0)
    goto _jump1559;
    fail_assertion("negative array index");
    _jump1559:;
    if (d < _1220.d0)
    goto _jump1560;
    fail_assertion("index too large");
    _jump1560:;
    int64_t _1231 = 0;
    _1231 *= _1220.d0;
    _1231 += d;
    a _1232 = _1220.data[_1231];
    int64_t _1233 = _1232.a;
    _a3_void_t _1234;
    // Computing bound for r
    _1234.d0 = i.d1;
    if (i.d1 > 0) 
    goto _jump1561;
    fail_assertion("non-positive loop bound");
    _jump1561:;
    // Computing bound for s
    _1234.d1 = i.d2;
    if (i.d2 > 0) 
    goto _jump1562;
    fail_assertion("non-positive loop bound");
    _jump1562:;
    // Computing bound for t
    int64_t _1235 = -i.d0;
    int64_t _1236;
    // Computing bound for r
    int64_t _1237 = 545;
    if (_1237 > 0) 
    goto _jump1563;
    fail_assertion("non-positive loop bound");
    _jump1563:;
    // Computing bound for s
    int64_t _1238 = 8;
    if (_1238 > 0) 
    goto _jump1564;
    fail_assertion("non-positive loop bound");
    _jump1564:;
    _1236 = 0;
    int64_t _1239 = 0; // s
    int64_t _1240 = 0; // r
    _jump1565:; // Begin body of loop
    _1236 += _1032.d0;
    _1239++;
    if (_1239 < _1238)
    goto _jump1565;
    _1239 = 0;
    _1240++;
    if (_1240 < _1237)
    goto _jump1565;
    // End body of loop
    int64_t _1241 = _1235 % _1236;
    _1234.d2 = _1241;
    if (_1241 > 0) 
    goto _jump1566;
    fail_assertion("non-positive loop bound");
    _jump1566:;
    // Computing total size of heap memory to allocate
    int64_t _1242 = 1;
    _1242 *= i.d1;
    _1242 *= i.d2;
    _1242 *= _1241;
    _1242 *= sizeof(void_t);
    _1234.data = jpl_alloc(_1242);
    int64_t _1243 = 0; // t
    int64_t _1244 = 0; // s
    int64_t _1245 = 0; // r
    _jump1567:; // Begin body of loop
    int64_t _1246 = 0;
    _1246 *= _1234.d0;
    _1246 += _1245;
    _1246 *= _1234.d1;
    _1246 += _1244;
    _1246 *= _1234.d2;
    _1246 += _1243;
    _1234.data[_1246] = g;
    _1243++;
    if (_1243 < _1241)
    goto _jump1567;
    _1243 = 0;
    _1244++;
    if (_1244 < i.d2)
    goto _jump1567;
    _1244 = 0;
    _1245++;
    if (_1245 < i.d1)
    goto _jump1567;
    // End body of loop
    int64_t _1247 = -_1032.d1;
    if (d >= 0)
    goto _jump1568;
    fail_assertion("negative array index");
    _jump1568:;
    if (d < _1234.d0)
    goto _jump1569;
    fail_assertion("index too large");
    _jump1569:;
    if (_1247 >= 0)
    goto _jump1570;
    fail_assertion("negative array index");
    _jump1570:;
    if (_1247 < _1234.d1)
    goto _jump1571;
    fail_assertion("index too large");
    _jump1571:;
    if (d >= 0)
    goto _jump1572;
    fail_assertion("negative array index");
    _jump1572:;
    if (d < _1234.d2)
    goto _jump1573;
    fail_assertion("index too large");
    _jump1573:;
    int64_t _1248 = 0;
    _1248 *= _1234.d0;
    _1248 += d;
    _1248 *= _1234.d1;
    _1248 += _1247;
    _1248 *= _1234.d2;
    _1248 += d;
    void_t _1249 = _1234.data[_1248];
    a _1250 = { i.d2, _1249 };
    int64_t _1251 = _1250.a;
    if (_1219 >= 0)
    goto _jump1574;
    fail_assertion("negative array index");
    _jump1574:;
    if (_1219 < _1148.d0)
    goto _jump1575;
    fail_assertion("index too large");
    _jump1575:;
    if (_1233 >= 0)
    goto _jump1576;
    fail_assertion("negative array index");
    _jump1576:;
    if (_1233 < _1148.d1)
    goto _jump1577;
    fail_assertion("index too large");
    _jump1577:;
    if (_1251 >= 0)
    goto _jump1578;
    fail_assertion("negative array index");
    _jump1578:;
    if (_1251 < _1148.d2)
    goto _jump1579;
    fail_assertion("index too large");
    _jump1579:;
    int64_t _1252 = 0;
    _1252 *= _1148.d0;
    _1252 += _1219;
    _1252 *= _1148.d1;
    _1252 += _1233;
    _1252 *= _1148.d2;
    _1252 += _1251;
    a _1253 = _1148.data[_1252];
    return _1253;
}

rgba m() {
    int64_t _0 = -k;
    int64_t _1 = -_0;
    if (_1 >= 0)
    goto _jump2024;
    fail_assertion("negative array index");
    _jump2024:;
    if (_1 < c.d0)
    goto _jump2025;
    fail_assertion("index too large");
    _jump2025:;
    int64_t _2 = 0;
    _2 *= c.d0;
    _2 += _1;
    bool _3 = c.data[_2];
    _a2_e _4;
    if (!_3)
    goto _jump2026;
    _a3__a2_e _5;
    // Computing bound for n
    _5.d0 = d;
    if (d > 0) 
    goto _jump2027;
    fail_assertion("non-positive loop bound");
    _jump2027:;
    // Computing bound for o
    _5.d1 = j;
    if (j > 0) 
    goto _jump2028;
    fail_assertion("non-positive loop bound");
    _jump2028:;
    // Computing bound for p
    _5.d2 = d;
    if (d > 0) 
    goto _jump2029;
    fail_assertion("non-positive loop bound");
    _jump2029:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= d;
    _6 *= j;
    _6 *= d;
    _6 *= sizeof(_a2_e);
    _5.data = jpl_alloc(_6);
    int64_t _7 = 0; // p
    int64_t _8 = 0; // o
    int64_t _9 = 0; // n
    _jump2030:; // Begin body of loop
    _a2_e _10;
    // Computing bound for q
    int64_t _11 = j - i;
    _10.d0 = _11;
    if (_11 > 0) 
    goto _jump2031;
    fail_assertion("non-positive loop bound");
    _jump2031:;
    // Computing bound for r
    int64_t _12;
    // Computing bound for q
    if (k > 0) 
    goto _jump2032;
    fail_assertion("non-positive loop bound");
    _jump2032:;
    // Computing bound for r
    if (k > 0) 
    goto _jump2033;
    fail_assertion("non-positive loop bound");
    _jump2033:;
    // Computing bound for s
    if (i > 0) 
    goto _jump2034;
    fail_assertion("non-positive loop bound");
    _jump2034:;
    _12 = 0;
    int64_t _13 = 0; // s
    int64_t _14 = 0; // r
    int64_t _15 = 0; // q
    _jump2035:; // Begin body of loop
    _12 += k;
    _13++;
    if (_13 < i)
    goto _jump2035;
    _13 = 0;
    _14++;
    if (_14 < k)
    goto _jump2035;
    _14 = 0;
    _15++;
    if (_15 < k)
    goto _jump2035;
    // End body of loop
    _10.d1 = _12;
    if (_12 > 0) 
    goto _jump2036;
    fail_assertion("non-positive loop bound");
    _jump2036:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _11;
    _16 *= _12;
    _16 *= sizeof(e);
    _10.data = jpl_alloc(_16);
    int64_t _17 = 0; // r
    int64_t _18 = 0; // q
    _jump2037:; // Begin body of loop
    rgba _19 = m();
    e _20 = { _19 };
    int64_t _21 = 0;
    _21 *= _10.d0;
    _21 += _18;
    _21 *= _10.d1;
    _21 += _17;
    _10.data[_21] = _20;
    _17++;
    if (_17 < _12)
    goto _jump2037;
    _17 = 0;
    _18++;
    if (_18 < _11)
    goto _jump2037;
    // End body of loop
    int64_t _22 = 0;
    _22 *= _5.d0;
    _22 += _9;
    _22 *= _5.d1;
    _22 += _8;
    _22 *= _5.d2;
    _22 += _7;
    _5.data[_22] = _10;
    _7++;
    if (_7 < d)
    goto _jump2030;
    _7 = 0;
    _8++;
    if (_8 < j)
    goto _jump2030;
    _8 = 0;
    _9++;
    if (_9 < d)
    goto _jump2030;
    // End body of loop
    double _23 = -l;
    bool _24 = l >= _23;
    int64_t _25;
    if (!_24)
    goto _jump2038;
    int64_t _26 = 352;
    int64_t _27 = -_26;
    int64_t _28 = 1000;
    int64_t _29 = j + _28;
    if (i >= 0)
    goto _jump2039;
    fail_assertion("negative array index");
    _jump2039:;
    if (i < h.d0)
    goto _jump2040;
    fail_assertion("index too large");
    _jump2040:;
    if (_27 >= 0)
    goto _jump2041;
    fail_assertion("negative array index");
    _jump2041:;
    if (_27 < h.d1)
    goto _jump2042;
    fail_assertion("index too large");
    _jump2042:;
    if (_29 >= 0)
    goto _jump2043;
    fail_assertion("negative array index");
    _jump2043:;
    if (_29 < h.d2)
    goto _jump2044;
    fail_assertion("index too large");
    _jump2044:;
    int64_t _30 = 0;
    _30 *= h.d0;
    _30 += i;
    _30 *= h.d1;
    _30 += _27;
    _30 *= h.d2;
    _30 += _29;
    int64_t _31 = h.data[_30];
    _25 = _31;
    goto _jump2045;
    _jump2038:;
    int64_t _32 = 930;
    _25 = _32;
    _jump2045:;
    int64_t _33 = -k;
    int64_t _34 = 757;
    if (_25 >= 0)
    goto _jump2046;
    fail_assertion("negative array index");
    _jump2046:;
    if (_25 < _5.d0)
    goto _jump2047;
    fail_assertion("index too large");
    _jump2047:;
    if (_33 >= 0)
    goto _jump2048;
    fail_assertion("negative array index");
    _jump2048:;
    if (_33 < _5.d1)
    goto _jump2049;
    fail_assertion("index too large");
    _jump2049:;
    if (_34 >= 0)
    goto _jump2050;
    fail_assertion("negative array index");
    _jump2050:;
    if (_34 < _5.d2)
    goto _jump2051;
    fail_assertion("index too large");
    _jump2051:;
    int64_t _35 = 0;
    _35 *= _5.d0;
    _35 += _25;
    _35 *= _5.d1;
    _35 += _33;
    _35 *= _5.d2;
    _35 += _34;
    _a2_e _36 = _5.data[_35];
    _4 = _36;
    goto _jump2052;
    _jump2026:;
    _a2_e _37;
    // Computing bound for n
    _37.d0 = j;
    if (j > 0) 
    goto _jump2053;
    fail_assertion("non-positive loop bound");
    _jump2053:;
    // Computing bound for o
    int64_t _38 = 802;
    int64_t _39 = -_38;
    _37.d1 = _39;
    if (_39 > 0) 
    goto _jump2054;
    fail_assertion("non-positive loop bound");
    _jump2054:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= j;
    _40 *= _39;
    _40 *= sizeof(e);
    _37.data = jpl_alloc(_40);
    int64_t _41 = 0; // o
    int64_t _42 = 0; // n
    _jump2055:; // Begin body of loop
    _a3_rgba _43;
    // Computing bound for p
    _43.d0 = _42;
    if (_42 > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing bound for q
    _43.d1 = _42;
    if (_42 > 0) 
    goto _jump2057;
    fail_assertion("non-positive loop bound");
    _jump2057:;
    // Computing bound for r
    _43.d2 = _41;
    if (_41 > 0) 
    goto _jump2058;
    fail_assertion("non-positive loop bound");
    _jump2058:;
    // Computing total size of heap memory to allocate
    int64_t _44 = 1;
    _44 *= _42;
    _44 *= _42;
    _44 *= _41;
    _44 *= sizeof(rgba);
    _43.data = jpl_alloc(_44);
    int64_t _45 = 0; // r
    int64_t _46 = 0; // q
    int64_t _47 = 0; // p
    _jump2059:; // Begin body of loop
    rgba _48 = m();
    int64_t _49 = 0;
    _49 *= _43.d0;
    _49 += _47;
    _49 *= _43.d1;
    _49 += _46;
    _49 *= _43.d2;
    _49 += _45;
    _43.data[_49] = _48;
    _45++;
    if (_45 < _41)
    goto _jump2059;
    _45 = 0;
    _46++;
    if (_46 < _42)
    goto _jump2059;
    _46 = 0;
    _47++;
    if (_47 < _42)
    goto _jump2059;
    // End body of loop
    int64_t _50 = -_42;
    bool _51 = true;
    int64_t _52;
    if (!_51)
    goto _jump2060;
    _52 = i;
    goto _jump2061;
    _jump2060:;
    _52 = _42;
    _jump2061:;
    if (d >= 0)
    goto _jump2062;
    fail_assertion("negative array index");
    _jump2062:;
    if (d < _43.d0)
    goto _jump2063;
    fail_assertion("index too large");
    _jump2063:;
    if (_50 >= 0)
    goto _jump2064;
    fail_assertion("negative array index");
    _jump2064:;
    if (_50 < _43.d1)
    goto _jump2065;
    fail_assertion("index too large");
    _jump2065:;
    if (_52 >= 0)
    goto _jump2066;
    fail_assertion("negative array index");
    _jump2066:;
    if (_52 < _43.d2)
    goto _jump2067;
    fail_assertion("index too large");
    _jump2067:;
    int64_t _53 = 0;
    _53 *= _43.d0;
    _53 += d;
    _53 *= _43.d1;
    _53 += _50;
    _53 *= _43.d2;
    _53 += _52;
    rgba _54 = _43.data[_53];
    e _55 = { _54 };
    int64_t _56 = 0;
    _56 *= _37.d0;
    _56 += _42;
    _56 *= _37.d1;
    _56 += _41;
    _37.data[_56] = _55;
    _41++;
    if (_41 < _39)
    goto _jump2055;
    _41 = 0;
    _42++;
    if (_42 < j)
    goto _jump2055;
    // End body of loop
    _4 = _37;
    _jump2052:;
    bool _57 = false;
    _a3_int64_t _58;
    if (!_57)
    goto _jump2068;
    _a1__a3_int64_t _59;
    _59.d0 = 1;
    _59.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _59.data[0] = h;
    if (k >= 0)
    goto _jump2069;
    fail_assertion("negative array index");
    _jump2069:;
    if (k < _59.d0)
    goto _jump2070;
    fail_assertion("index too large");
    _jump2070:;
    int64_t _60 = 0;
    _60 *= _59.d0;
    _60 += k;
    _a3_int64_t _61 = _59.data[_60];
    _58 = _61;
    goto _jump2071;
    _jump2068:;
    _a3_int64_t _62;
    // Computing bound for n
    _a3_int64_t _63;
    // Computing bound for n
    _63.d0 = k;
    if (k > 0) 
    goto _jump2072;
    fail_assertion("non-positive loop bound");
    _jump2072:;
    // Computing bound for o
    _63.d1 = j;
    if (j > 0) 
    goto _jump2073;
    fail_assertion("non-positive loop bound");
    _jump2073:;
    // Computing bound for p
    _63.d2 = i;
    if (i > 0) 
    goto _jump2074;
    fail_assertion("non-positive loop bound");
    _jump2074:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= k;
    _64 *= j;
    _64 *= i;
    _64 *= sizeof(int64_t);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // p
    int64_t _66 = 0; // o
    int64_t _67 = 0; // n
    _jump2075:; // Begin body of loop
    int64_t _68 = 0;
    _68 *= _63.d0;
    _68 += _67;
    _68 *= _63.d1;
    _68 += _66;
    _68 *= _63.d2;
    _68 += _65;
    _63.data[_68] = k;
    _65++;
    if (_65 < i)
    goto _jump2075;
    _65 = 0;
    _66++;
    if (_66 < j)
    goto _jump2075;
    _66 = 0;
    _67++;
    if (_67 < k)
    goto _jump2075;
    // End body of loop
    int64_t _69 = 771;
    int64_t _70 = -j;
    if (_69 >= 0)
    goto _jump2076;
    fail_assertion("negative array index");
    _jump2076:;
    if (_69 < _63.d0)
    goto _jump2077;
    fail_assertion("index too large");
    _jump2077:;
    if (d >= 0)
    goto _jump2078;
    fail_assertion("negative array index");
    _jump2078:;
    if (d < _63.d1)
    goto _jump2079;
    fail_assertion("index too large");
    _jump2079:;
    if (_70 >= 0)
    goto _jump2080;
    fail_assertion("negative array index");
    _jump2080:;
    if (_70 < _63.d2)
    goto _jump2081;
    fail_assertion("index too large");
    _jump2081:;
    int64_t _71 = 0;
    _71 *= _63.d0;
    _71 += _69;
    _71 *= _63.d1;
    _71 += d;
    _71 *= _63.d2;
    _71 += _70;
    int64_t _72 = _63.data[_71];
    _62.d0 = _72;
    if (_72 > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing bound for o
    _62.d1 = j;
    if (j > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing bound for p
    int64_t _73 = i + i;
    _62.d2 = _73;
    if (_73 > 0) 
    goto _jump2084;
    fail_assertion("non-positive loop bound");
    _jump2084:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= _72;
    _74 *= j;
    _74 *= _73;
    _74 *= sizeof(int64_t);
    _62.data = jpl_alloc(_74);
    int64_t _75 = 0; // p
    int64_t _76 = 0; // o
    int64_t _77 = 0; // n
    _jump2085:; // Begin body of loop
    int64_t _78 = 0;
    _78 *= _62.d0;
    _78 += _77;
    _78 *= _62.d1;
    _78 += _76;
    _78 *= _62.d2;
    _78 += _75;
    _62.data[_78] = _77;
    _75++;
    if (_75 < _73)
    goto _jump2085;
    _75 = 0;
    _76++;
    if (_76 < j)
    goto _jump2085;
    _76 = 0;
    _77++;
    if (_77 < _72)
    goto _jump2085;
    // End body of loop
    _58 = _62;
    _jump2071:;
    int64_t _79 = -j;
    if (j >= 0)
    goto _jump2086;
    fail_assertion("negative array index");
    _jump2086:;
    if (j < _58.d0)
    goto _jump2087;
    fail_assertion("index too large");
    _jump2087:;
    if (_79 >= 0)
    goto _jump2088;
    fail_assertion("negative array index");
    _jump2088:;
    if (_79 < _58.d1)
    goto _jump2089;
    fail_assertion("index too large");
    _jump2089:;
    if (i >= 0)
    goto _jump2090;
    fail_assertion("negative array index");
    _jump2090:;
    if (i < _58.d2)
    goto _jump2091;
    fail_assertion("index too large");
    _jump2091:;
    int64_t _80 = 0;
    _80 *= _58.d0;
    _80 += j;
    _80 *= _58.d1;
    _80 += _79;
    _80 *= _58.d2;
    _80 += i;
    int64_t _81 = _58.data[_80];
    if (i >= 0)
    goto _jump2092;
    fail_assertion("negative array index");
    _jump2092:;
    if (i < _4.d0)
    goto _jump2093;
    fail_assertion("index too large");
    _jump2093:;
    if (_81 >= 0)
    goto _jump2094;
    fail_assertion("negative array index");
    _jump2094:;
    if (_81 < _4.d1)
    goto _jump2095;
    fail_assertion("index too large");
    _jump2095:;
    int64_t _82 = 0;
    _82 *= _4.d0;
    _82 += i;
    _82 *= _4.d1;
    _82 += _81;
    e _83 = _4.data[_82];
    rgba _84 = _83.a;
    return _84;
    _a3_bool _85;
    // Computing bound for v
    double _86 = 93.0;
    double _87 = -_86;
    double _88 = -l;
    double _89 = _87 - _88;
    bool _90 = _89 > l;
    int64_t _91;
    if (!_90)
    goto _jump2096;
    _91 = i;
    goto _jump2097;
    _jump2096:;
    _91 = g.d0;
    _jump2097:;
    if (g.d0 >= 0)
    goto _jump2098;
    fail_assertion("negative array index");
    _jump2098:;
    if (g.d0 < c.d0)
    goto _jump2099;
    fail_assertion("index too large");
    _jump2099:;
    int64_t _92 = 0;
    _92 *= c.d0;
    _92 += g.d0;
    bool _93 = c.data[_92];
    int64_t _94;
    if (!_93)
    goto _jump2100;
    bool _96 = false;
    bool _95 = _96;
    if (0 == _96)
    goto _jump2101;
    double _97 = 15.0;
    bool _98 = l == _97;
    bool _99 = true;
    bool _100 = _98 != _99;
    _95 = _100;
    _jump2101:;
    int64_t _101;
    if (!_95)
    goto _jump2102;
    _101 = g.d0;
    goto _jump2103;
    _jump2102:;
    _101 = i;
    _jump2103:;
    _94 = _101;
    goto _jump2104;
    _jump2100:;
    int64_t _102 = -k;
    if (g.d1 >= 0)
    goto _jump2105;
    fail_assertion("negative array index");
    _jump2105:;
    if (g.d1 < h.d0)
    goto _jump2106;
    fail_assertion("index too large");
    _jump2106:;
    if (_102 >= 0)
    goto _jump2107;
    fail_assertion("negative array index");
    _jump2107:;
    if (_102 < h.d1)
    goto _jump2108;
    fail_assertion("index too large");
    _jump2108:;
    if (g.d1 >= 0)
    goto _jump2109;
    fail_assertion("negative array index");
    _jump2109:;
    if (g.d1 < h.d2)
    goto _jump2110;
    fail_assertion("index too large");
    _jump2110:;
    int64_t _103 = 0;
    _103 *= h.d0;
    _103 += g.d1;
    _103 *= h.d1;
    _103 += _102;
    _103 *= h.d2;
    _103 += g.d1;
    int64_t _104 = h.data[_103];
    _94 = _104;
    _jump2104:;
    int64_t _105 = _91 + _94;
    _85.d0 = _105;
    if (_105 > 0) 
    goto _jump2111;
    fail_assertion("non-positive loop bound");
    _jump2111:;
    // Computing bound for w
    int64_t _106 = 175;
    _85.d1 = _106;
    if (_106 > 0) 
    goto _jump2112;
    fail_assertion("non-positive loop bound");
    _jump2112:;
    // Computing bound for x
    _85.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump2113;
    fail_assertion("non-positive loop bound");
    _jump2113:;
    // Computing total size of heap memory to allocate
    int64_t _107 = 1;
    _107 *= _105;
    _107 *= _106;
    _107 *= g.d1;
    _107 *= sizeof(bool);
    _85.data = jpl_alloc(_107);
    int64_t _108 = 0; // x
    int64_t _109 = 0; // w
    int64_t _110 = 0; // v
    _jump2114:; // Begin body of loop
    double _112 = 99.0;
    double _113 = -l;
    double _114 = 10.0;
    double _115 = -_114;
    double _116 = 97.0;
    rgba _117 = { _112, _113, _115, _116 };
    double _118 = _117.b;
    double _119 = 39.0;
    double _120 = -_119;
    double _121 = 77.0;
    double _122 = _120 / _121;
    double _123 = -_122;
    bool _124 = _118 != _123;
    bool _125;
    if (!_124)
    goto _jump2115;
    _a1_bool _126;
    // Computing bound for y
    _126.d0 = i;
    if (i > 0) 
    goto _jump2116;
    fail_assertion("non-positive loop bound");
    _jump2116:;
    // Computing total size of heap memory to allocate
    int64_t _127 = 1;
    _127 *= i;
    _127 *= sizeof(bool);
    _126.data = jpl_alloc(_127);
    int64_t _128 = 0; // y
    _jump2117:; // Begin body of loop
    bool _129 = true;
    int64_t _130 = 0;
    _130 *= _126.d0;
    _130 += _128;
    _126.data[_130] = _129;
    _128++;
    if (_128 < i)
    goto _jump2117;
    // End body of loop
    if (_108 >= 0)
    goto _jump2118;
    fail_assertion("negative array index");
    _jump2118:;
    if (_108 < _126.d0)
    goto _jump2119;
    fail_assertion("index too large");
    _jump2119:;
    int64_t _131 = 0;
    _131 *= _126.d0;
    _131 += _108;
    bool _132 = _126.data[_131];
    _125 = _132;
    goto _jump2120;
    _jump2115:;
    bool _133 = false;
    bool _134;
    if (!_133)
    goto _jump2121;
    bool _135 = true;
    bool _136;
    if (!_135)
    goto _jump2122;
    int64_t _137 = 433;
    bool _138 = _137 <= g.d1;
    _136 = _138;
    goto _jump2123;
    _jump2122:;
    bool _139 = d < d;
    _136 = _139;
    _jump2123:;
    _134 = _136;
    goto _jump2124;
    _jump2121:;
    double _140 = -l;
    double _141 = 95.0;
    double _142 = -_141;
    bool _143 = _140 != _142;
    _134 = _143;
    _jump2124:;
    bool _144 = !_134;
    _125 = _144;
    _jump2120:;
    bool _111 = _125;
    if (0 != _125)
    goto _jump2125;
    bool _148 = true;
    bool _147 = _148;
    if (0 == _148)
    goto _jump2126;
    bool _149 = false;
    _147 = _149;
    _jump2126:;
    bool _146 = _147;
    if (0 == _147)
    goto _jump2127;
    bool _150 = true;
    bool _151 = false;
    bool _152 = _150 == _151;
    _146 = _152;
    _jump2127:;
    bool _153 = !_146;
    bool _145 = _153;
    if (0 == _153)
    goto _jump2128;
    double _154;
    // Computing bound for y
    if (i > 0) 
    goto _jump2129;
    fail_assertion("non-positive loop bound");
    _jump2129:;
    // Computing bound for z
    if (_109 > 0) 
    goto _jump2130;
    fail_assertion("non-positive loop bound");
    _jump2130:;
    _154 = 0;
    int64_t _155 = 0; // z
    int64_t _156 = 0; // y
    _jump2131:; // Begin body of loop
    double _157 = 83.0;
    _154 += _157;
    _155++;
    if (_155 < _109)
    goto _jump2131;
    _155 = 0;
    _156++;
    if (_156 < i)
    goto _jump2131;
    // End body of loop
    rgba _158 = m();
    double _159 = _158.a;
    bool _160 = _154 >= _159;
    _145 = _160;
    _jump2128:;
    bool _161;
    if (!_145)
    goto _jump2132;
    _a3_bool _162;
    // Computing bound for y
    _162.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump2133;
    fail_assertion("non-positive loop bound");
    _jump2133:;
    // Computing bound for z
    _162.d1 = j;
    if (j > 0) 
    goto _jump2134;
    fail_assertion("non-positive loop bound");
    _jump2134:;
    // Computing bound for A
    _162.d2 = i;
    if (i > 0) 
    goto _jump2135;
    fail_assertion("non-positive loop bound");
    _jump2135:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= g.d0;
    _163 *= j;
    _163 *= i;
    _163 *= sizeof(bool);
    _162.data = jpl_alloc(_163);
    int64_t _164 = 0; // A
    int64_t _165 = 0; // z
    int64_t _166 = 0; // y
    _jump2136:; // Begin body of loop
    bool _167 = true;
    int64_t _168 = 0;
    _168 *= _162.d0;
    _168 += _166;
    _168 *= _162.d1;
    _168 += _165;
    _168 *= _162.d2;
    _168 += _164;
    _162.data[_168] = _167;
    _164++;
    if (_164 < i)
    goto _jump2136;
    _164 = 0;
    _165++;
    if (_165 < j)
    goto _jump2136;
    _165 = 0;
    _166++;
    if (_166 < g.d0)
    goto _jump2136;
    // End body of loop
    if (k >= 0)
    goto _jump2137;
    fail_assertion("negative array index");
    _jump2137:;
    if (k < _162.d0)
    goto _jump2138;
    fail_assertion("index too large");
    _jump2138:;
    if (d >= 0)
    goto _jump2139;
    fail_assertion("negative array index");
    _jump2139:;
    if (d < _162.d1)
    goto _jump2140;
    fail_assertion("index too large");
    _jump2140:;
    if (d >= 0)
    goto _jump2141;
    fail_assertion("negative array index");
    _jump2141:;
    if (d < _162.d2)
    goto _jump2142;
    fail_assertion("index too large");
    _jump2142:;
    int64_t _169 = 0;
    _169 *= _162.d0;
    _169 += k;
    _169 *= _162.d1;
    _169 += d;
    _169 *= _162.d2;
    _169 += d;
    bool _170 = _162.data[_169];
    bool _171 = !_170;
    bool _172;
    if (!_171)
    goto _jump2143;
    double _174 = l - l;
    double _175 = 48.0;
    bool _176 = _174 < _175;
    bool _173 = _176;
    if (0 == _176)
    goto _jump2144;
    bool _177 = true;
    _173 = _177;
    _jump2144:;
    _172 = _173;
    goto _jump2145;
    _jump2143:;
    _a3_bool _178;
    // Computing bound for y
    int64_t _179 = 780;
    int64_t _180 = _109 % _179;
    _178.d0 = _180;
    if (_180 > 0) 
    goto _jump2146;
    fail_assertion("non-positive loop bound");
    _jump2146:;
    // Computing bound for z
    _178.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump2147;
    fail_assertion("non-positive loop bound");
    _jump2147:;
    // Computing bound for A
    int64_t _181 = i / g.d1;
    _178.d2 = _181;
    if (_181 > 0) 
    goto _jump2148;
    fail_assertion("non-positive loop bound");
    _jump2148:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= _180;
    _182 *= g.d0;
    _182 *= _181;
    _182 *= sizeof(bool);
    _178.data = jpl_alloc(_182);
    int64_t _183 = 0; // A
    int64_t _184 = 0; // z
    int64_t _185 = 0; // y
    _jump2149:; // Begin body of loop
    bool _186 = true;
    int64_t _187 = 0;
    _187 *= _178.d0;
    _187 += _185;
    _187 *= _178.d1;
    _187 += _184;
    _187 *= _178.d2;
    _187 += _183;
    _178.data[_187] = _186;
    _183++;
    if (_183 < _181)
    goto _jump2149;
    _183 = 0;
    _184++;
    if (_184 < g.d0)
    goto _jump2149;
    _184 = 0;
    _185++;
    if (_185 < _180)
    goto _jump2149;
    // End body of loop
    bool _188 = true;
    int64_t _189;
    if (!_188)
    goto _jump2150;
    _189 = d;
    goto _jump2151;
    _jump2150:;
    int64_t _190;
    // Computing bound for y
    if (g.d0 > 0) 
    goto _jump2152;
    fail_assertion("non-positive loop bound");
    _jump2152:;
    // Computing bound for z
    int64_t _191 = 152;
    if (_191 > 0) 
    goto _jump2153;
    fail_assertion("non-positive loop bound");
    _jump2153:;
    // Computing bound for A
    if (g.d0 > 0) 
    goto _jump2154;
    fail_assertion("non-positive loop bound");
    _jump2154:;
    _190 = 0;
    int64_t _192 = 0; // A
    int64_t _193 = 0; // z
    int64_t _194 = 0; // y
    _jump2155:; // Begin body of loop
    _190 += d;
    _192++;
    if (_192 < g.d0)
    goto _jump2155;
    _192 = 0;
    _193++;
    if (_193 < _191)
    goto _jump2155;
    _193 = 0;
    _194++;
    if (_194 < g.d0)
    goto _jump2155;
    // End body of loop
    _189 = _190;
    _jump2151:;
    int64_t _195;
    // Computing bound for y
    int64_t _196;
    // Computing bound for y
    if (g.d0 > 0) 
    goto _jump2156;
    fail_assertion("non-positive loop bound");
    _jump2156:;
    _196 = 0;
    int64_t _197 = 0; // y
    _jump2157:; // Begin body of loop
    _196 += _109;
    _197++;
    if (_197 < g.d0)
    goto _jump2157;
    // End body of loop
    if (_196 > 0) 
    goto _jump2158;
    fail_assertion("non-positive loop bound");
    _jump2158:;
    // Computing bound for z
    if (d > 0) 
    goto _jump2159;
    fail_assertion("non-positive loop bound");
    _jump2159:;
    _195 = 0;
    int64_t _198 = 0; // z
    int64_t _199 = 0; // y
    _jump2160:; // Begin body of loop
    _195 += _109;
    _198++;
    if (_198 < d)
    goto _jump2160;
    _198 = 0;
    _199++;
    if (_199 < _196)
    goto _jump2160;
    // End body of loop
    if (_189 >= 0)
    goto _jump2161;
    fail_assertion("negative array index");
    _jump2161:;
    if (_189 < _178.d0)
    goto _jump2162;
    fail_assertion("index too large");
    _jump2162:;
    if (g.d1 >= 0)
    goto _jump2163;
    fail_assertion("negative array index");
    _jump2163:;
    if (g.d1 < _178.d1)
    goto _jump2164;
    fail_assertion("index too large");
    _jump2164:;
    if (_195 >= 0)
    goto _jump2165;
    fail_assertion("negative array index");
    _jump2165:;
    if (_195 < _178.d2)
    goto _jump2166;
    fail_assertion("index too large");
    _jump2166:;
    int64_t _200 = 0;
    _200 *= _178.d0;
    _200 += _189;
    _200 *= _178.d1;
    _200 += g.d1;
    _200 *= _178.d2;
    _200 += _195;
    bool _201 = _178.data[_200];
    _172 = _201;
    _jump2145:;
    _161 = _172;
    goto _jump2167;
    _jump2132:;
    bool _203 = true;
    bool _202 = _203;
    if (0 != _203)
    goto _jump2168;
    double _204 = 91.0;
    bool _205 = l != _204;
    bool _206 = false;
    bool _207 = _205 != _206;
    bool _208 = !_207;
    _202 = _208;
    _jump2168:;
    _161 = _202;
    _jump2167:;
    _111 = _161;
    _jump2125:;
    int64_t _209 = 0;
    _209 *= _85.d0;
    _209 += _110;
    _209 *= _85.d1;
    _209 += _109;
    _209 *= _85.d2;
    _209 += _108;
    _85.data[_209] = _111;
    _108++;
    if (_108 < g.d1)
    goto _jump2114;
    _108 = 0;
    _109++;
    if (_109 < _106)
    goto _jump2114;
    _109 = 0;
    _110++;
    if (_110 < _105)
    goto _jump2114;
    // End body of loop
    rgba _210 = m();
    return _210;
}

double G(_a2_e H, e I, int64_t J) {
    bool _0 = false;
    bool _1;
    if (!_0)
    goto _jump2577;
    double _2 = -l;
    double _3;
    // Computing bound for O
    if (E > 0) 
    goto _jump2578;
    fail_assertion("non-positive loop bound");
    _jump2578:;
    // Computing bound for P
    if (C.d1 > 0) 
    goto _jump2579;
    fail_assertion("non-positive loop bound");
    _jump2579:;
    _3 = 0;
    int64_t _4 = 0; // P
    int64_t _5 = 0; // O
    _jump2580:; // Begin body of loop
    double _6;
    // Computing bound for Q
    if (E > 0) 
    goto _jump2581;
    fail_assertion("non-positive loop bound");
    _jump2581:;
    // Computing bound for R
    if (C.d0 > 0) 
    goto _jump2582;
    fail_assertion("non-positive loop bound");
    _jump2582:;
    // Computing bound for S
    int64_t _7;
    // Computing bound for Q
    if (C.d0 > 0) 
    goto _jump2583;
    fail_assertion("non-positive loop bound");
    _jump2583:;
    // Computing bound for R
    if (J > 0) 
    goto _jump2584;
    fail_assertion("non-positive loop bound");
    _jump2584:;
    _7 = 0;
    int64_t _8 = 0; // R
    int64_t _9 = 0; // Q
    _jump2585:; // Begin body of loop
    _7 += j;
    _8++;
    if (_8 < J)
    goto _jump2585;
    _8 = 0;
    _9++;
    if (_9 < C.d0)
    goto _jump2585;
    // End body of loop
    int64_t _10 = _7 - r;
    if (_10 > 0) 
    goto _jump2586;
    fail_assertion("non-positive loop bound");
    _jump2586:;
    _6 = 0;
    int64_t _11 = 0; // S
    int64_t _12 = 0; // R
    int64_t _13 = 0; // Q
    _jump2587:; // Begin body of loop
    bool _14 = r <= t;
    double _15;
    if (!_14)
    goto _jump2588;
    double _16 = 87.0;
    _15 = _16;
    goto _jump2589;
    _jump2588:;
    rgba _17 = m();
    double _18 = _17.r;
    _15 = _18;
    _jump2589:;
    _6 += _15;
    _11++;
    if (_11 < _10)
    goto _jump2587;
    _11 = 0;
    _12++;
    if (_12 < C.d0)
    goto _jump2587;
    _12 = 0;
    _13++;
    if (_13 < E)
    goto _jump2587;
    // End body of loop
    _3 += _6;
    _4++;
    if (_4 < C.d1)
    goto _jump2580;
    _4 = 0;
    _5++;
    if (_5 < E)
    goto _jump2580;
    // End body of loop
    double _19 = -_3;
    bool _20 = _2 >= _19;
    _1 = _20;
    goto _jump2590;
    _jump2577:;
    bool _21 = F != u;
    _1 = _21;
    _jump2590:;
    if (0 != _1)
    goto _jump2591;
    fail_assertion("O");
    _jump2591:;
    _a2_e _23;
    // Computing bound for O
    int64_t _24 = 495;
    _23.d0 = _24;
    if (_24 > 0) 
    goto _jump2592;
    fail_assertion("non-positive loop bound");
    _jump2592:;
    // Computing bound for P
    _23.d1 = C.d1;
    if (C.d1 > 0) 
    goto _jump2593;
    fail_assertion("non-positive loop bound");
    _jump2593:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= _24;
    _25 *= C.d1;
    _25 *= sizeof(e);
    _23.data = jpl_alloc(_25);
    int64_t _26 = 0; // P
    int64_t _27 = 0; // O
    _jump2594:; // Begin body of loop
    int64_t _28 = 0;
    _28 *= _23.d0;
    _28 += _27;
    _28 *= _23.d1;
    _28 += _26;
    _23.data[_28] = I;
    _26++;
    if (_26 < C.d1)
    goto _jump2594;
    _26 = 0;
    _27++;
    if (_27 < _24)
    goto _jump2594;
    // End body of loop
    bool _29 = false;
    e _30;
    if (!_29)
    goto _jump2595;
    _30 = I;
    goto _jump2596;
    _jump2595:;
    rgba _31 = m();
    e _32 = { _31 };
    _30 = _32;
    _jump2596:;
    double _33 = G(_23, _30, F);
    _a2_e _34;
    // Computing bound for O
    _34.d0 = i;
    if (i > 0) 
    goto _jump2597;
    fail_assertion("non-positive loop bound");
    _jump2597:;
    // Computing bound for P
    _34.d1 = u;
    if (u > 0) 
    goto _jump2598;
    fail_assertion("non-positive loop bound");
    _jump2598:;
    // Computing total size of heap memory to allocate
    int64_t _35 = 1;
    _35 *= i;
    _35 *= u;
    _35 *= sizeof(e);
    _34.data = jpl_alloc(_35);
    int64_t _36 = 0; // P
    int64_t _37 = 0; // O
    _jump2599:; // Begin body of loop
    rgba _38 = m();
    e _39 = { _38 };
    int64_t _40 = 0;
    _40 *= _34.d0;
    _40 += _37;
    _40 *= _34.d1;
    _40 += _36;
    _34.data[_40] = _39;
    _36++;
    if (_36 < u)
    goto _jump2599;
    _36 = 0;
    _37++;
    if (_37 < i)
    goto _jump2599;
    // End body of loop
    double _41 = G(_34, I, d);
    bool _42 = _33 > _41;
    bool _22 = _42;
    if (0 != _42)
    goto _jump2600;
    bool _43 = false;
    _22 = _43;
    _jump2600:;
    _a3_bool _44;
    if (!_22)
    goto _jump2601;
    _a3_bool _45;
    // Computing bound for O
    _45.d0 = C.d1;
    if (C.d1 > 0) 
    goto _jump2602;
    fail_assertion("non-positive loop bound");
    _jump2602:;
    // Computing bound for P
    _45.d1 = r;
    if (r > 0) 
    goto _jump2603;
    fail_assertion("non-positive loop bound");
    _jump2603:;
    // Computing bound for Q
    _45.d2 = d;
    if (d > 0) 
    goto _jump2604;
    fail_assertion("non-positive loop bound");
    _jump2604:;
    // Computing total size of heap memory to allocate
    int64_t _46 = 1;
    _46 *= C.d1;
    _46 *= r;
    _46 *= d;
    _46 *= sizeof(bool);
    _45.data = jpl_alloc(_46);
    int64_t _47 = 0; // Q
    int64_t _48 = 0; // P
    int64_t _49 = 0; // O
    _jump2605:; // Begin body of loop
    if (C.d1 >= 0)
    goto _jump2606;
    fail_assertion("negative array index");
    _jump2606:;
    if (C.d1 < w.d0)
    goto _jump2607;
    fail_assertion("index too large");
    _jump2607:;
    int64_t _50 = 0;
    _50 *= w.d0;
    _50 += C.d1;
    bool _51 = w.data[_50];
    bool _52 = !_51;
    int64_t _53 = 0;
    _53 *= _45.d0;
    _53 += _49;
    _53 *= _45.d1;
    _53 += _48;
    _53 *= _45.d2;
    _53 += _47;
    _45.data[_53] = _52;
    _47++;
    if (_47 < d)
    goto _jump2605;
    _47 = 0;
    _48++;
    if (_48 < r)
    goto _jump2605;
    _48 = 0;
    _49++;
    if (_49 < C.d1)
    goto _jump2605;
    // End body of loop
    _44 = _45;
    goto _jump2608;
    _jump2601:;
    _a3_bool _54;
    // Computing bound for O
    _54.d0 = E;
    if (E > 0) 
    goto _jump2609;
    fail_assertion("non-positive loop bound");
    _jump2609:;
    // Computing bound for P
    _54.d1 = E;
    if (E > 0) 
    goto _jump2610;
    fail_assertion("non-positive loop bound");
    _jump2610:;
    // Computing bound for Q
    bool _55 = F <= k;
    bool _57 = u < y;
    bool _56 = _57;
    if (0 == _57)
    goto _jump2611;
    bool _58 = true;
    bool _59 = !_58;
    _56 = _59;
    _jump2611:;
    bool _60 = _55 != _56;
    int64_t _61;
    if (!_60)
    goto _jump2612;
    int64_t _62;
    // Computing bound for O
    if (E > 0) 
    goto _jump2613;
    fail_assertion("non-positive loop bound");
    _jump2613:;
    // Computing bound for P
    if (E > 0) 
    goto _jump2614;
    fail_assertion("non-positive loop bound");
    _jump2614:;
    // Computing bound for Q
    if (J > 0) 
    goto _jump2615;
    fail_assertion("non-positive loop bound");
    _jump2615:;
    _62 = 0;
    int64_t _63 = 0; // Q
    int64_t _64 = 0; // P
    int64_t _65 = 0; // O
    _jump2616:; // Begin body of loop
    int64_t _66 = 791;
    _62 += _66;
    _63++;
    if (_63 < J)
    goto _jump2616;
    _63 = 0;
    _64++;
    if (_64 < E)
    goto _jump2616;
    _64 = 0;
    _65++;
    if (_65 < E)
    goto _jump2616;
    // End body of loop
    _61 = _62;
    goto _jump2617;
    _jump2612:;
    _61 = J;
    _jump2617:;
    _54.d2 = _61;
    if (_61 > 0) 
    goto _jump2618;
    fail_assertion("non-positive loop bound");
    _jump2618:;
    // Computing total size of heap memory to allocate
    int64_t _67 = 1;
    _67 *= E;
    _67 *= E;
    _67 *= _61;
    _67 *= sizeof(bool);
    _54.data = jpl_alloc(_67);
    int64_t _68 = 0; // Q
    int64_t _69 = 0; // P
    int64_t _70 = 0; // O
    _jump2619:; // Begin body of loop
    rgba _71 = m();
    e _72 = { _71 };
    rgba _73 = _72.a;
    double _74 = _73.a;
    double _75 = G(H, I, C.d0);
    bool _76 = _74 <= _75;
    int64_t _77 = 0;
    _77 *= _54.d0;
    _77 += _70;
    _77 *= _54.d1;
    _77 += _69;
    _77 *= _54.d2;
    _77 += _68;
    _54.data[_77] = _76;
    _68++;
    if (_68 < _61)
    goto _jump2619;
    _68 = 0;
    _69++;
    if (_69 < E)
    goto _jump2619;
    _69 = 0;
    _70++;
    if (_70 < E)
    goto _jump2619;
    // End body of loop
    _44 = _54;
    _jump2608:;
    bool _78 = x != E;
    bool _79;
    if (!_78)
    goto _jump2620;
    bool _80 = false;
    bool _81 = !_80;
    _79 = _81;
    goto _jump2621;
    _jump2620:;
    bool _82 = false;
    _79 = _82;
    _jump2621:;
    bool _84 = false;
    bool _83 = _84;
    if (0 != _84)
    goto _jump2622;
    bool _85 = false;
    _83 = _85;
    _jump2622:;
    bool _86;
    if (!_83)
    goto _jump2623;
    bool _87 = E < E;
    _86 = _87;
    goto _jump2624;
    _jump2623:;
    bool _88 = false;
    bool _89 = !_88;
    _86 = _89;
    _jump2624:;
    bool _90 = _79 == _86;
    bool _91 = !_90;
    int64_t _92;
    if (!_91)
    goto _jump2625;
    int64_t _93 = -F;
    _92 = _93;
    goto _jump2626;
    _jump2625:;
    _92 = v;
    _jump2626:;
    int64_t _94 = _92 % C.d0;
    if (j >= 0)
    goto _jump2627;
    fail_assertion("negative array index");
    _jump2627:;
    if (j < _44.d0)
    goto _jump2628;
    fail_assertion("index too large");
    _jump2628:;
    if (o >= 0)
    goto _jump2629;
    fail_assertion("negative array index");
    _jump2629:;
    if (o < _44.d1)
    goto _jump2630;
    fail_assertion("index too large");
    _jump2630:;
    if (_94 >= 0)
    goto _jump2631;
    fail_assertion("negative array index");
    _jump2631:;
    if (_94 < _44.d2)
    goto _jump2632;
    fail_assertion("index too large");
    _jump2632:;
    int64_t _95 = 0;
    _95 *= _44.d0;
    _95 += j;
    _95 *= _44.d1;
    _95 += o;
    _95 *= _44.d2;
    _95 += _94;
    bool _96 = _44.data[_95];
    if (0 != _96)
    goto _jump2633;
    fail_assertion("O");
    _jump2633:;
    double _99;
    // Computing bound for P
    int64_t _100 = 552;
    if (_100 > 0) 
    goto _jump2634;
    fail_assertion("non-positive loop bound");
    _jump2634:;
    // Computing bound for Q
    if (C.d0 > 0) 
    goto _jump2635;
    fail_assertion("non-positive loop bound");
    _jump2635:;
    _99 = 0;
    int64_t _101 = 0; // Q
    int64_t _102 = 0; // P
    _jump2636:; // Begin body of loop
    bool _103 = false;
    bool _104 = false;
    bool _105 = _103 != _104;
    double _106;
    if (!_105)
    goto _jump2637;
    double _107 = 50.0;
    _106 = _107;
    goto _jump2638;
    _jump2637:;
    _106 = l;
    _jump2638:;
    _99 += _106;
    _101++;
    if (_101 < C.d0)
    goto _jump2636;
    _101 = 0;
    _102++;
    if (_102 < _100)
    goto _jump2636;
    // End body of loop
    bool _108 = false;
    _a2_e _109;
    if (!_108)
    goto _jump2639;
    _109 = H;
    goto _jump2640;
    _jump2639:;
    _109 = H;
    _jump2640:;
    _a1_e _110;
    // Computing bound for P
    _110.d0 = A;
    if (A > 0) 
    goto _jump2641;
    fail_assertion("non-positive loop bound");
    _jump2641:;
    // Computing total size of heap memory to allocate
    int64_t _111 = 1;
    _111 *= A;
    _111 *= sizeof(e);
    _110.data = jpl_alloc(_111);
    int64_t _112 = 0; // P
    _jump2642:; // Begin body of loop
    int64_t _113 = 0;
    _113 *= _110.d0;
    _113 += _112;
    _110.data[_113] = I;
    _112++;
    if (_112 < A)
    goto _jump2642;
    // End body of loop
    if (x >= 0)
    goto _jump2643;
    fail_assertion("negative array index");
    _jump2643:;
    if (x < _110.d0)
    goto _jump2644;
    fail_assertion("index too large");
    _jump2644:;
    int64_t _114 = 0;
    _114 *= _110.d0;
    _114 += x;
    e _115 = _110.data[_114];
    double _116 = G(_109, _115, J);
    bool _117 = _99 == _116;
    bool _98 = _117;
    if (0 != _117)
    goto _jump2645;
    int64_t _118;
    // Computing bound for P
    if (o > 0) 
    goto _jump2646;
    fail_assertion("non-positive loop bound");
    _jump2646:;
    _118 = 0;
    int64_t _119 = 0; // P
    _jump2647:; // Begin body of loop
    _118 += x;
    _119++;
    if (_119 < o)
    goto _jump2647;
    // End body of loop
    bool _120 = _118 != A;
    _98 = _120;
    _jump2645:;
    bool _97 = _98;
    if (0 == _98)
    goto _jump2648;
    bool _122 = true;
    bool _121 = _122;
    if (0 == _122)
    goto _jump2649;
    _a2__a3_int64_t _123;
    // Computing bound for P
    _123.d0 = t;
    if (t > 0) 
    goto _jump2650;
    fail_assertion("non-positive loop bound");
    _jump2650:;
    // Computing bound for Q
    _123.d1 = j;
    if (j > 0) 
    goto _jump2651;
    fail_assertion("non-positive loop bound");
    _jump2651:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= t;
    _124 *= j;
    _124 *= sizeof(_a3_int64_t);
    _123.data = jpl_alloc(_124);
    int64_t _125 = 0; // Q
    int64_t _126 = 0; // P
    _jump2652:; // Begin body of loop
    int64_t _127 = 0;
    _127 *= _123.d0;
    _127 += _126;
    _127 *= _123.d1;
    _127 += _125;
    _123.data[_127] = h;
    _125++;
    if (_125 < j)
    goto _jump2652;
    _125 = 0;
    _126++;
    if (_126 < t)
    goto _jump2652;
    // End body of loop
    if (C.d1 >= 0)
    goto _jump2653;
    fail_assertion("negative array index");
    _jump2653:;
    if (C.d1 < _123.d0)
    goto _jump2654;
    fail_assertion("index too large");
    _jump2654:;
    if (C.d0 >= 0)
    goto _jump2655;
    fail_assertion("negative array index");
    _jump2655:;
    if (C.d0 < _123.d1)
    goto _jump2656;
    fail_assertion("index too large");
    _jump2656:;
    int64_t _128 = 0;
    _128 *= _123.d0;
    _128 += C.d1;
    _128 *= _123.d1;
    _128 += C.d0;
    _a3_int64_t _129 = _123.data[_128];
    double _130 = 29.0;
    bool _131 = _130 == l;
    int64_t _132;
    if (!_131)
    goto _jump2657;
    _132 = v;
    goto _jump2658;
    _jump2657:;
    _132 = C.d0;
    _jump2658:;
    if (t >= 0)
    goto _jump2659;
    fail_assertion("negative array index");
    _jump2659:;
    if (t < _129.d0)
    goto _jump2660;
    fail_assertion("index too large");
    _jump2660:;
    if (_132 >= 0)
    goto _jump2661;
    fail_assertion("negative array index");
    _jump2661:;
    if (_132 < _129.d1)
    goto _jump2662;
    fail_assertion("index too large");
    _jump2662:;
    if (F >= 0)
    goto _jump2663;
    fail_assertion("negative array index");
    _jump2663:;
    if (F < _129.d2)
    goto _jump2664;
    fail_assertion("index too large");
    _jump2664:;
    int64_t _133 = 0;
    _133 *= _129.d0;
    _133 += t;
    _133 *= _129.d1;
    _133 += _132;
    _133 *= _129.d2;
    _133 += F;
    int64_t _134 = _129.data[_133];
    bool _135 = _134 != d;
    _121 = _135;
    _jump2649:;
    _97 = _121;
    _jump2648:;
    _a2__a1_bool _136;
    if (!_97)
    goto _jump2665;
    _136 = p;
    goto _jump2666;
    _jump2665:;
    bool _137 = B != A;
    _a2__a2__a1_bool _138;
    if (!_137)
    goto _jump2667;
    _a2__a2__a1_bool _139;
    // Computing bound for P
    _139.d0 = B;
    if (B > 0) 
    goto _jump2668;
    fail_assertion("non-positive loop bound");
    _jump2668:;
    // Computing bound for Q
    _139.d1 = F;
    if (F > 0) 
    goto _jump2669;
    fail_assertion("non-positive loop bound");
    _jump2669:;
    // Computing total size of heap memory to allocate
    int64_t _140 = 1;
    _140 *= B;
    _140 *= F;
    _140 *= sizeof(_a2__a1_bool);
    _139.data = jpl_alloc(_140);
    int64_t _141 = 0; // Q
    int64_t _142 = 0; // P
    _jump2670:; // Begin body of loop
    int64_t _143 = 0;
    _143 *= _139.d0;
    _143 += _142;
    _143 *= _139.d1;
    _143 += _141;
    _139.data[_143] = p;
    _141++;
    if (_141 < F)
    goto _jump2670;
    _141 = 0;
    _142++;
    if (_142 < B)
    goto _jump2670;
    // End body of loop
    _138 = _139;
    goto _jump2671;
    _jump2667:;
    _a2__a2__a1_bool _144;
    // Computing bound for P
    _144.d0 = x;
    if (x > 0) 
    goto _jump2672;
    fail_assertion("non-positive loop bound");
    _jump2672:;
    // Computing bound for Q
    _144.d1 = t;
    if (t > 0) 
    goto _jump2673;
    fail_assertion("non-positive loop bound");
    _jump2673:;
    // Computing total size of heap memory to allocate
    int64_t _145 = 1;
    _145 *= x;
    _145 *= t;
    _145 *= sizeof(_a2__a1_bool);
    _144.data = jpl_alloc(_145);
    int64_t _146 = 0; // Q
    int64_t _147 = 0; // P
    _jump2674:; // Begin body of loop
    bool _148 = false;
    _a2__a1_bool _149;
    if (!_148)
    goto _jump2675;
    _a2__a2__a1_bool _150;
    // Computing bound for R
    _150.d0 = j;
    if (j > 0) 
    goto _jump2676;
    fail_assertion("non-positive loop bound");
    _jump2676:;
    // Computing bound for S
    _150.d1 = k;
    if (k > 0) 
    goto _jump2677;
    fail_assertion("non-positive loop bound");
    _jump2677:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= j;
    _151 *= k;
    _151 *= sizeof(_a2__a1_bool);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // S
    int64_t _153 = 0; // R
    _jump2678:; // Begin body of loop
    int64_t _154 = 0;
    _154 *= _150.d0;
    _154 += _153;
    _154 *= _150.d1;
    _154 += _152;
    _150.data[_154] = p;
    _152++;
    if (_152 < k)
    goto _jump2678;
    _152 = 0;
    _153++;
    if (_153 < j)
    goto _jump2678;
    // End body of loop
    if (F >= 0)
    goto _jump2679;
    fail_assertion("negative array index");
    _jump2679:;
    if (F < _150.d0)
    goto _jump2680;
    fail_assertion("index too large");
    _jump2680:;
    if (k >= 0)
    goto _jump2681;
    fail_assertion("negative array index");
    _jump2681:;
    if (k < _150.d1)
    goto _jump2682;
    fail_assertion("index too large");
    _jump2682:;
    int64_t _155 = 0;
    _155 *= _150.d0;
    _155 += F;
    _155 *= _150.d1;
    _155 += k;
    _a2__a1_bool _156 = _150.data[_155];
    _149 = _156;
    goto _jump2683;
    _jump2675:;
    _149 = p;
    _jump2683:;
    int64_t _157 = 0;
    _157 *= _144.d0;
    _157 += _147;
    _157 *= _144.d1;
    _157 += _146;
    _144.data[_157] = _149;
    _146++;
    if (_146 < t)
    goto _jump2674;
    _146 = 0;
    _147++;
    if (_147 < x)
    goto _jump2674;
    // End body of loop
    _138 = _144;
    _jump2671:;
    if (x >= 0)
    goto _jump2684;
    fail_assertion("negative array index");
    _jump2684:;
    if (x < _138.d0)
    goto _jump2685;
    fail_assertion("index too large");
    _jump2685:;
    if (x >= 0)
    goto _jump2686;
    fail_assertion("negative array index");
    _jump2686:;
    if (x < _138.d1)
    goto _jump2687;
    fail_assertion("index too large");
    _jump2687:;
    int64_t _158 = 0;
    _158 *= _138.d0;
    _158 += x;
    _158 *= _138.d1;
    _158 += x;
    _a2__a1_bool _159 = _138.data[_158];
    _136 = _159;
    _jump2666:;
    double _160 = 63.0;
    return _160;
}

void jpl_main(struct args args) {
    int64_t _1 = 954;
    int64_t _2;
    // Computing bound for a
    int64_t _3 = 271;
    int64_t _4 = 336;
    int64_t _5 = _3 * _4;
    int64_t _6 = -_5;
    if (_6 > 0) 
    goto _jump1;
    fail_assertion("non-positive loop bound");
    _jump1:;
    _2 = 0;
    int64_t _7 = 0; // a
    _jump2:; // Begin body of loop
    int64_t _8 = 650;
    _2 += _8;
    _7++;
    if (_7 < _6)
    goto _jump2;
    // End body of loop
    bool _9 = _1 >= _2;
    bool _0 = _9;
    if (0 == _9)
    goto _jump3;
    _a3_bool _10;
    // Computing bound for a
    int64_t _11 = 298;
    int64_t _12 = -_11;
    _10.d0 = _12;
    if (_12 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    // Computing bound for b
    bool _13 = true;
    int64_t _14;
    if (!_13)
    goto _jump5;
    int64_t _15 = 27;
    _14 = _15;
    goto _jump6;
    _jump5:;
    int64_t _16 = 682;
    int64_t _17 = 839;
    int64_t _18 = _16 / _17;
    _14 = _18;
    _jump6:;
    int64_t _19 = 845;
    int64_t _20 = _14 + _19;
    _10.d1 = _20;
    if (_20 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing bound for c
    int64_t _21;
    // Computing bound for a
    int64_t _22 = 372;
    if (_22 > 0) 
    goto _jump8;
    fail_assertion("non-positive loop bound");
    _jump8:;
    // Computing bound for b
    int64_t _23 = 393;
    if (_23 > 0) 
    goto _jump9;
    fail_assertion("non-positive loop bound");
    _jump9:;
    _21 = 0;
    int64_t _24 = 0; // b
    int64_t _25 = 0; // a
    _jump10:; // Begin body of loop
    int64_t _26 = 545;
    int64_t _27 = -_26;
    int64_t _28 = -_27;
    _21 += _28;
    _24++;
    if (_24 < _23)
    goto _jump10;
    _24 = 0;
    _25++;
    if (_25 < _22)
    goto _jump10;
    // End body of loop
    _10.d2 = _21;
    if (_21 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing total size of heap memory to allocate
    int64_t _29 = 1;
    _29 *= _12;
    _29 *= _20;
    _29 *= _21;
    _29 *= sizeof(bool);
    _10.data = jpl_alloc(_29);
    int64_t _30 = 0; // c
    int64_t _31 = 0; // b
    int64_t _32 = 0; // a
    _jump12:; // Begin body of loop
    int64_t _33 = -_31;
    int64_t _34 = 234;
    bool _35 = _33 > _34;
    int64_t _36 = 0;
    _36 *= _10.d0;
    _36 += _32;
    _36 *= _10.d1;
    _36 += _31;
    _36 *= _10.d2;
    _36 += _30;
    _10.data[_36] = _35;
    _30++;
    if (_30 < _21)
    goto _jump12;
    _30 = 0;
    _31++;
    if (_31 < _20)
    goto _jump12;
    _31 = 0;
    _32++;
    if (_32 < _12)
    goto _jump12;
    // End body of loop
    int64_t _37 = 846;
    int64_t _38 = 602;
    int64_t _39 = -_38;
    double _40;
    // Computing bound for a
    int64_t _41 = 636;
    if (_41 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    _40 = 0;
    int64_t _42 = 0; // a
    _jump14:; // Begin body of loop
    double _43 = 48.0;
    _40 += _43;
    _42++;
    if (_42 < _41)
    goto _jump14;
    // End body of loop
    double _44 = 42.0;
    bool _45 = _40 >= _44;
    int64_t _46;
    if (!_45)
    goto _jump15;
    bool _47 = false;
    int64_t _48;
    if (!_47)
    goto _jump16;
    int64_t _49 = 990;
    _48 = _49;
    goto _jump17;
    _jump16:;
    int64_t _50 = 783;
    _48 = _50;
    _jump17:;
    int64_t _51 = -_48;
    _46 = _51;
    goto _jump18;
    _jump15:;
    int64_t _52;
    // Computing bound for a
    int64_t _53 = 585;
    if (_53 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    _52 = 0;
    int64_t _54 = 0; // a
    _jump20:; // Begin body of loop
    int64_t _55 = 619;
    int64_t _56 = 101;
    int64_t _57 = _55 - _56;
    _52 += _57;
    _54++;
    if (_54 < _53)
    goto _jump20;
    // End body of loop
    _46 = _52;
    _jump18:;
    int64_t _58 = _39 - _46;
    int64_t _59;
    // Computing bound for a
    int64_t _60 = 882;
    int64_t _61 = -_60;
    if (_61 > 0) 
    goto _jump21;
    fail_assertion("non-positive loop bound");
    _jump21:;
    // Computing bound for b
    int64_t _62;
    // Computing bound for a
    int64_t _63 = 798;
    if (_63 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    // Computing bound for b
    int64_t _64;
    // Computing bound for a
    int64_t _65 = 483;
    int64_t _66 = -_65;
    if (_66 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    _64 = 0;
    int64_t _67 = 0; // a
    _jump24:; // Begin body of loop
    _64 += _67;
    _67++;
    if (_67 < _66)
    goto _jump24;
    // End body of loop
    if (_64 > 0) 
    goto _jump25;
    fail_assertion("non-positive loop bound");
    _jump25:;
    // Computing bound for c
    bool _68 = false;
    int64_t _69;
    if (!_68)
    goto _jump26;
    int64_t _70 = 331;
    _69 = _70;
    goto _jump27;
    _jump26:;
    int64_t _71 = 27;
    _69 = _71;
    _jump27:;
    int64_t _72 = 346;
    int64_t _73 = _69 / _72;
    if (_73 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    _62 = 0;
    int64_t _74 = 0; // c
    int64_t _75 = 0; // b
    int64_t _76 = 0; // a
    _jump29:; // Begin body of loop
    _62 += _76;
    _74++;
    if (_74 < _73)
    goto _jump29;
    _74 = 0;
    _75++;
    if (_75 < _64)
    goto _jump29;
    _75 = 0;
    _76++;
    if (_76 < _63)
    goto _jump29;
    // End body of loop
    if (_62 > 0) 
    goto _jump30;
    fail_assertion("non-positive loop bound");
    _jump30:;
    // Computing bound for c
    int64_t _77 = 97;
    if (_77 > 0) 
    goto _jump31;
    fail_assertion("non-positive loop bound");
    _jump31:;
    _59 = 0;
    int64_t _78 = 0; // c
    int64_t _79 = 0; // b
    int64_t _80 = 0; // a
    _jump32:; // Begin body of loop
    int64_t _81 = 887;
    _59 += _81;
    _78++;
    if (_78 < _77)
    goto _jump32;
    _78 = 0;
    _79++;
    if (_79 < _62)
    goto _jump32;
    _79 = 0;
    _80++;
    if (_80 < _61)
    goto _jump32;
    // End body of loop
    if (_37 >= 0)
    goto _jump33;
    fail_assertion("negative array index");
    _jump33:;
    if (_37 < _10.d0)
    goto _jump34;
    fail_assertion("index too large");
    _jump34:;
    if (_58 >= 0)
    goto _jump35;
    fail_assertion("negative array index");
    _jump35:;
    if (_58 < _10.d1)
    goto _jump36;
    fail_assertion("index too large");
    _jump36:;
    if (_59 >= 0)
    goto _jump37;
    fail_assertion("negative array index");
    _jump37:;
    if (_59 < _10.d2)
    goto _jump38;
    fail_assertion("index too large");
    _jump38:;
    int64_t _82 = 0;
    _82 *= _10.d0;
    _82 += _37;
    _82 *= _10.d1;
    _82 += _58;
    _82 *= _10.d2;
    _82 += _59;
    bool _83 = _10.data[_82];
    _0 = _83;
    _jump3:;
    int64_t _85;
    // Computing bound for a
    int64_t _86 = 825;
    int64_t _87;
    // Computing bound for a
    int64_t _88 = 581;
    if (_88 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    // Computing bound for b
    int64_t _89 = 648;
    if (_89 > 0) 
    goto _jump40;
    fail_assertion("non-positive loop bound");
    _jump40:;
    _87 = 0;
    int64_t _90 = 0; // b
    int64_t _91 = 0; // a
    _jump41:; // Begin body of loop
    _87 += _90;
    _90++;
    if (_90 < _89)
    goto _jump41;
    _90 = 0;
    _91++;
    if (_91 < _88)
    goto _jump41;
    // End body of loop
    int64_t _92 = _86 / _87;
    if (_92 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    // Computing bound for b
    int64_t _93 = 352;
    int64_t _94 = -_93;
    if (_94 > 0) 
    goto _jump43;
    fail_assertion("non-positive loop bound");
    _jump43:;
    _85 = 0;
    int64_t _95 = 0; // b
    int64_t _96 = 0; // a
    _jump44:; // Begin body of loop
    bool _97 = false;
    int64_t _98;
    if (!_97)
    goto _jump45;
    _98 = _96;
    goto _jump46;
    _jump45:;
    int64_t _99 = -_95;
    _98 = _99;
    _jump46:;
    _85 += _98;
    _95++;
    if (_95 < _94)
    goto _jump44;
    _95 = 0;
    _96++;
    if (_96 < _92)
    goto _jump44;
    // End body of loop
    int64_t _100 = 199;
    bool _101 = _85 != _100;
    bool _102;
    if (!_101)
    goto _jump47;
    int64_t _104 = 963;
    int64_t _105 = -_104;
    int64_t _106 = -_105;
    int64_t _107 = 756;
    int64_t _108 = 408;
    int64_t _109 = _107 - _108;
    int64_t _110 = -_109;
    bool _111 = _106 == _110;
    bool _103 = _111;
    if (0 != _111)
    goto _jump48;
    bool _112 = true;
    _103 = _112;
    _jump48:;
    _102 = _103;
    goto _jump49;
    _jump47:;
    bool _114 = false;
    bool _115;
    if (!_114)
    goto _jump50;
    bool _116 = true;
    bool _117 = !_116;
    bool _118 = false;
    bool _119 = _117 == _118;
    _115 = _119;
    goto _jump51;
    _jump50:;
    bool _120 = true;
    _115 = _120;
    _jump51:;
    bool _113 = _115;
    if (0 == _115)
    goto _jump52;
    bool _121 = false;
    bool _122 = false;
    bool _123 = true;
    _a1_bool _124;
    _124.d0 = 3;
    _124.data = jpl_alloc(sizeof(bool) * 3);
    _124.data[0] = _121;
    _124.data[1] = _122;
    _124.data[2] = _123;
    int64_t _125 = 329;
    int64_t _126 = 40;
    int64_t _127 = _125 % _126;
    if (_127 >= 0)
    goto _jump53;
    fail_assertion("negative array index");
    _jump53:;
    if (_127 < _124.d0)
    goto _jump54;
    fail_assertion("index too large");
    _jump54:;
    int64_t _128 = 0;
    _128 *= _124.d0;
    _128 += _127;
    bool _129 = _124.data[_128];
    bool _130;
    if (!_129)
    goto _jump55;
    bool _132 = true;
    bool _133 = false;
    bool _134 = _132 != _133;
    bool _131 = _134;
    if (0 != _134)
    goto _jump56;
    bool _135 = false;
    _131 = _135;
    _jump56:;
    _130 = _131;
    goto _jump57;
    _jump55:;
    bool _136 = false;
    _130 = _136;
    _jump57:;
    _113 = _130;
    _jump52:;
    _102 = _113;
    _jump49:;
    bool _84 = _102;
    if (0 == _102)
    goto _jump58;
    double _138;
    // Computing bound for a
    int64_t _139 = 205;
    if (_139 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    // Computing bound for b
    int64_t _140;
    // Computing bound for a
    int64_t _141 = 195;
    if (_141 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    _140 = 0;
    int64_t _142 = 0; // a
    _jump61:; // Begin body of loop
    _140 += _142;
    _142++;
    if (_142 < _141)
    goto _jump61;
    // End body of loop
    if (_140 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    _138 = 0;
    int64_t _143 = 0; // b
    int64_t _144 = 0; // a
    _jump63:; // Begin body of loop
    double _145 = 75.0;
    double _146 = -_145;
    _138 += _146;
    _143++;
    if (_143 < _140)
    goto _jump63;
    _143 = 0;
    _144++;
    if (_144 < _139)
    goto _jump63;
    // End body of loop
    double _147 = 45.0;
    double _148 = -_147;
    bool _149 = _138 == _148;
    bool _137 = _149;
    if (0 == _149)
    goto _jump64;
    double _151 = 24.0;
    double _152 = -_151;
    double _153 = 25.0;
    bool _154 = _152 >= _153;
    bool _155;
    if (!_154)
    goto _jump65;
    double _156 = 82.0;
    double _157 = 64.0;
    bool _158 = _156 == _157;
    bool _159;
    if (!_158)
    goto _jump66;
    int64_t _160 = 72;
    int64_t _161 = 581;
    bool _162 = _160 >= _161;
    _159 = _162;
    goto _jump67;
    _jump66:;
    int64_t _163 = 836;
    int64_t _164 = 579;
    bool _165 = _163 >= _164;
    _159 = _165;
    _jump67:;
    _155 = _159;
    goto _jump68;
    _jump65:;
    bool _166 = true;
    bool _167 = !_166;
    bool _168;
    if (!_167)
    goto _jump69;
    bool _169 = true;
    _168 = _169;
    goto _jump70;
    _jump69:;
    int64_t _170 = 902;
    int64_t _171 = 316;
    bool _172 = _170 >= _171;
    _168 = _172;
    _jump70:;
    _155 = _168;
    _jump68:;
    bool _150 = _155;
    if (0 == _155)
    goto _jump71;
    int64_t _173;
    // Computing bound for a
    int64_t _174 = 540;
    if (_174 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    _173 = 0;
    int64_t _175 = 0; // a
    _jump73:; // Begin body of loop
    _173 += _175;
    _175++;
    if (_175 < _174)
    goto _jump73;
    // End body of loop
    int64_t _176 = -_173;
    int64_t _177 = 306;
    int64_t _178 = 433;
    int64_t _179 = _177 - _178;
    int64_t _180 = -_179;
    bool _181 = _176 > _180;
    _150 = _181;
    _jump71:;
    _137 = _150;
    _jump64:;
    _84 = _137;
    _jump58:;
    bool _182 = _0 == _84;
    show("(BoolType)", &_182);
    print("a");
    _a1_bool _183;
    // Computing bound for c
    _a1__a2_int64_t _184;
    // Computing bound for c
    int64_t _185 = 82;
    _184.d0 = _185;
    if (_185 > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    // Computing total size of heap memory to allocate
    int64_t _186 = 1;
    _186 *= _185;
    _186 *= sizeof(_a2_int64_t);
    _184.data = jpl_alloc(_186);
    int64_t _187 = 0; // c
    _jump629:; // Begin body of loop
    _a2_int64_t _188;
    // Computing bound for d
    _188.d0 = _187;
    if (_187 > 0) 
    goto _jump630;
    fail_assertion("non-positive loop bound");
    _jump630:;
    // Computing bound for e
    int64_t _189 = 415;
    _188.d1 = _189;
    if (_189 > 0) 
    goto _jump631;
    fail_assertion("non-positive loop bound");
    _jump631:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= _187;
    _190 *= _189;
    _190 *= sizeof(int64_t);
    _188.data = jpl_alloc(_190);
    int64_t _191 = 0; // e
    int64_t _192 = 0; // d
    _jump632:; // Begin body of loop
    int64_t _193 = 775;
    int64_t _194 = 0;
    _194 *= _188.d0;
    _194 += _192;
    _194 *= _188.d1;
    _194 += _191;
    _188.data[_194] = _193;
    _191++;
    if (_191 < _189)
    goto _jump632;
    _191 = 0;
    _192++;
    if (_192 < _187)
    goto _jump632;
    // End body of loop
    int64_t _195 = 0;
    _195 *= _184.d0;
    _195 += _187;
    _184.data[_195] = _188;
    _187++;
    if (_187 < _185)
    goto _jump629;
    // End body of loop
    int64_t _196 = 429;
    if (_196 >= 0)
    goto _jump633;
    fail_assertion("negative array index");
    _jump633:;
    if (_196 < _184.d0)
    goto _jump634;
    fail_assertion("index too large");
    _jump634:;
    int64_t _197 = 0;
    _197 *= _184.d0;
    _197 += _196;
    _a2_int64_t _198 = _184.data[_197];
    int64_t _199 = 532;
    int64_t _200 = 992;
    int64_t _201 = _199 % _200;
    int64_t _202 = -_201;
    bool _204 = true;
    bool _205 = !_204;
    bool _203 = _205;
    if (0 != _205)
    goto _jump635;
    bool _206 = false;
    bool _207 = !_206;
    _203 = _207;
    _jump635:;
    bool _208 = true;
    bool _209 = true;
    bool _210 = _208 != _209;
    bool _211 = _203 == _210;
    int64_t _212;
    if (!_211)
    goto _jump636;
    int64_t _213 = 134;
    int64_t _214 = 901;
    int64_t _215 = _213 * _214;
    _212 = _215;
    goto _jump637;
    _jump636:;
    int64_t _216 = 535;
    int64_t _217 = 981;
    int64_t _218 = _216 * _217;
    _212 = _218;
    _jump637:;
    if (_202 >= 0)
    goto _jump638;
    fail_assertion("negative array index");
    _jump638:;
    if (_202 < _198.d0)
    goto _jump639;
    fail_assertion("index too large");
    _jump639:;
    if (_212 >= 0)
    goto _jump640;
    fail_assertion("negative array index");
    _jump640:;
    if (_212 < _198.d1)
    goto _jump641;
    fail_assertion("index too large");
    _jump641:;
    int64_t _219 = 0;
    _219 *= _198.d0;
    _219 += _202;
    _219 *= _198.d1;
    _219 += _212;
    int64_t _220 = _198.data[_219];
    int64_t _221 = -_220;
    _183.d0 = _221;
    if (_221 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    // Computing total size of heap memory to allocate
    int64_t _222 = 1;
    _222 *= _221;
    _222 *= sizeof(bool);
    _183.data = jpl_alloc(_222);
    int64_t _223 = 0; // c
    _jump643:; // Begin body of loop
    int64_t _224 = 135;
    int64_t _225 = 459;
    bool _226 = _224 == _225;
    int64_t _227 = 0;
    _227 *= _183.d0;
    _227 += _223;
    _183.data[_227] = _226;
    _223++;
    if (_223 < _221)
    goto _jump643;
    // End body of loop
    bool _229 = true;
    bool _228 = _229;
    if (0 != _229)
    goto _jump1580;
    int64_t _231 = 236;
    int64_t _232 = 289;
    int64_t _233 = _231 * _232;
    if (_233 >= 0)
    goto _jump1581;
    fail_assertion("negative array index");
    _jump1581:;
    if (_233 < _183.d0)
    goto _jump1582;
    fail_assertion("index too large");
    _jump1582:;
    int64_t _234 = 0;
    _234 *= _183.d0;
    _234 += _233;
    bool _235 = _183.data[_234];
    bool _230 = _235;
    if (0 != _235)
    goto _jump1583;
    bool _236 = true;
    bool _237 = !_236;
    _230 = _237;
    _jump1583:;
    _a3_bool _238;
    if (!_230)
    goto _jump1584;
    _a3_bool _239;
    // Computing bound for g
    int64_t _240 = 945;
    _a1_int64_t _241;
    _241.d0 = 1;
    _241.data = jpl_alloc(sizeof(int64_t) * 1);
    _241.data[0] = _240;
    int64_t _242 = 908;
    if (_242 >= 0)
    goto _jump1585;
    fail_assertion("negative array index");
    _jump1585:;
    if (_242 < _241.d0)
    goto _jump1586;
    fail_assertion("index too large");
    _jump1586:;
    int64_t _243 = 0;
    _243 *= _241.d0;
    _243 += _242;
    int64_t _244 = _241.data[_243];
    _239.d0 = _244;
    if (_244 > 0) 
    goto _jump1587;
    fail_assertion("non-positive loop bound");
    _jump1587:;
    // Computing bound for h
    int64_t _245 = 982;
    _239.d1 = _245;
    if (_245 > 0) 
    goto _jump1588;
    fail_assertion("non-positive loop bound");
    _jump1588:;
    // Computing bound for i
    int64_t _246 = 981;
    _239.d2 = _246;
    if (_246 > 0) 
    goto _jump1589;
    fail_assertion("non-positive loop bound");
    _jump1589:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= _244;
    _247 *= _245;
    _247 *= _246;
    _247 *= sizeof(bool);
    _239.data = jpl_alloc(_247);
    int64_t _248 = 0; // i
    int64_t _249 = 0; // h
    int64_t _250 = 0; // g
    _jump1590:; // Begin body of loop
    bool _252 = false;
    bool _251 = _252;
    if (0 == _252)
    goto _jump1591;
    bool _253 = false;
    _251 = _253;
    _jump1591:;
    int64_t _254 = 0;
    _254 *= _239.d0;
    _254 += _250;
    _254 *= _239.d1;
    _254 += _249;
    _254 *= _239.d2;
    _254 += _248;
    _239.data[_254] = _251;
    _248++;
    if (_248 < _246)
    goto _jump1590;
    _248 = 0;
    _249++;
    if (_249 < _245)
    goto _jump1590;
    _249 = 0;
    _250++;
    if (_250 < _244)
    goto _jump1590;
    // End body of loop
    _238 = _239;
    goto _jump1592;
    _jump1584:;
    _a3_bool _255;
    // Computing bound for g
    _255.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1593;
    fail_assertion("non-positive loop bound");
    _jump1593:;
    // Computing bound for h
    int64_t _256;
    // Computing bound for g
    if (_183.d0 > 0) 
    goto _jump1594;
    fail_assertion("non-positive loop bound");
    _jump1594:;
    // Computing bound for h
    int64_t _257 = 133;
    int64_t _258 = -_257;
    if (_258 > 0) 
    goto _jump1595;
    fail_assertion("non-positive loop bound");
    _jump1595:;
    // Computing bound for i
    int64_t _259;
    // Computing bound for g
    int64_t _260 = 765;
    if (_260 > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    _259 = 0;
    int64_t _261 = 0; // g
    _jump1597:; // Begin body of loop
    _259 += _261;
    _261++;
    if (_261 < _260)
    goto _jump1597;
    // End body of loop
    if (_259 > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    _256 = 0;
    int64_t _262 = 0; // i
    int64_t _263 = 0; // h
    int64_t _264 = 0; // g
    _jump1599:; // Begin body of loop
    _256 += _263;
    _262++;
    if (_262 < _259)
    goto _jump1599;
    _262 = 0;
    _263++;
    if (_263 < _258)
    goto _jump1599;
    _263 = 0;
    _264++;
    if (_264 < _183.d0)
    goto _jump1599;
    // End body of loop
    _255.d1 = _256;
    if (_256 > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing bound for i
    _255.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1601;
    fail_assertion("non-positive loop bound");
    _jump1601:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= _183.d0;
    _265 *= _256;
    _265 *= _183.d0;
    _265 *= sizeof(bool);
    _255.data = jpl_alloc(_265);
    int64_t _266 = 0; // i
    int64_t _267 = 0; // h
    int64_t _268 = 0; // g
    _jump1602:; // Begin body of loop
    int64_t _269;
    // Computing bound for j
    if (_268 > 0) 
    goto _jump1603;
    fail_assertion("non-positive loop bound");
    _jump1603:;
    _269 = 0;
    int64_t _270 = 0; // j
    _jump1604:; // Begin body of loop
    int64_t _271 = 832;
    _269 += _271;
    _270++;
    if (_270 < _268)
    goto _jump1604;
    // End body of loop
    if (_269 >= 0)
    goto _jump1605;
    fail_assertion("negative array index");
    _jump1605:;
    if (_269 < _183.d0)
    goto _jump1606;
    fail_assertion("index too large");
    _jump1606:;
    int64_t _272 = 0;
    _272 *= _183.d0;
    _272 += _269;
    bool _273 = _183.data[_272];
    int64_t _274 = 0;
    _274 *= _255.d0;
    _274 += _268;
    _274 *= _255.d1;
    _274 += _267;
    _274 *= _255.d2;
    _274 += _266;
    _255.data[_274] = _273;
    _266++;
    if (_266 < _183.d0)
    goto _jump1602;
    _266 = 0;
    _267++;
    if (_267 < _256)
    goto _jump1602;
    _267 = 0;
    _268++;
    if (_268 < _183.d0)
    goto _jump1602;
    // End body of loop
    _238 = _255;
    _jump1592:;
    int64_t _275;
    // Computing bound for g
    if (_183.d0 > 0) 
    goto _jump1607;
    fail_assertion("non-positive loop bound");
    _jump1607:;
    _275 = 0;
    int64_t _276 = 0; // g
    _jump1608:; // Begin body of loop
    int64_t _277 = 869;
    int64_t _278 = -_277;
    _275 += _278;
    _276++;
    if (_276 < _183.d0)
    goto _jump1608;
    // End body of loop
    int64_t _279 = 230;
    int64_t _280 = -_279;
    int64_t _281 = _275 + _280;
    int64_t _282;
    // Computing bound for g
    int64_t _283 = -_183.d0;
    if (_283 > 0) 
    goto _jump1609;
    fail_assertion("non-positive loop bound");
    _jump1609:;
    _282 = 0;
    int64_t _284 = 0; // g
    _jump1610:; // Begin body of loop
    int64_t _285;
    // Computing bound for h
    bool _286 = false;
    int64_t _287;
    if (!_286)
    goto _jump1611;
    _287 = _183.d0;
    goto _jump1612;
    _jump1611:;
    _287 = _183.d0;
    _jump1612:;
    int64_t _288 = -_287;
    if (_288 > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1614;
    fail_assertion("non-positive loop bound");
    _jump1614:;
    // Computing bound for j
    if (_183.d0 > 0) 
    goto _jump1615;
    fail_assertion("non-positive loop bound");
    _jump1615:;
    _285 = 0;
    int64_t _289 = 0; // j
    int64_t _290 = 0; // i
    int64_t _291 = 0; // h
    _jump1616:; // Begin body of loop
    int64_t _292;
    // Computing bound for k
    if (_284 > 0) 
    goto _jump1617;
    fail_assertion("non-positive loop bound");
    _jump1617:;
    _292 = 0;
    int64_t _293 = 0; // k
    _jump1618:; // Begin body of loop
    _292 += _289;
    _293++;
    if (_293 < _284)
    goto _jump1618;
    // End body of loop
    _285 += _292;
    _289++;
    if (_289 < _183.d0)
    goto _jump1616;
    _289 = 0;
    _290++;
    if (_290 < _183.d0)
    goto _jump1616;
    _290 = 0;
    _291++;
    if (_291 < _288)
    goto _jump1616;
    // End body of loop
    _282 += _285;
    _284++;
    if (_284 < _283)
    goto _jump1610;
    // End body of loop
    int64_t _294;
    // Computing bound for g
    bool _295 = false;
    int64_t _296;
    if (!_295)
    goto _jump1619;
    int64_t _297 = -_183.d0;
    _296 = _297;
    goto _jump1620;
    _jump1619:;
    int64_t _298 = 848;
    int64_t _299 = _183.d0 - _298;
    int64_t _300 = -_299;
    _296 = _300;
    _jump1620:;
    if (_296 > 0) 
    goto _jump1621;
    fail_assertion("non-positive loop bound");
    _jump1621:;
    // Computing bound for h
    if (_183.d0 >= 0)
    goto _jump1622;
    fail_assertion("negative array index");
    _jump1622:;
    if (_183.d0 < _183.d0)
    goto _jump1623;
    fail_assertion("index too large");
    _jump1623:;
    int64_t _301 = 0;
    _301 *= _183.d0;
    _301 += _183.d0;
    bool _302 = _183.data[_301];
    int64_t _303;
    if (!_302)
    goto _jump1624;
    int64_t _304 = 970;
    int64_t _305 = -_304;
    _303 = _305;
    goto _jump1625;
    _jump1624:;
    _303 = _183.d0;
    _jump1625:;
    int64_t _306 = -_303;
    if (_306 > 0) 
    goto _jump1626;
    fail_assertion("non-positive loop bound");
    _jump1626:;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1627;
    fail_assertion("non-positive loop bound");
    _jump1627:;
    _294 = 0;
    int64_t _307 = 0; // i
    int64_t _308 = 0; // h
    int64_t _309 = 0; // g
    _jump1628:; // Begin body of loop
    int64_t _310;
    // Computing bound for j
    _a2_int64_t _311;
    // Computing bound for j
    _311.d0 = _308;
    if (_308 > 0) 
    goto _jump1629;
    fail_assertion("non-positive loop bound");
    _jump1629:;
    // Computing bound for k
    _311.d1 = _309;
    if (_309 > 0) 
    goto _jump1630;
    fail_assertion("non-positive loop bound");
    _jump1630:;
    // Computing total size of heap memory to allocate
    int64_t _312 = 1;
    _312 *= _308;
    _312 *= _309;
    _312 *= sizeof(int64_t);
    _311.data = jpl_alloc(_312);
    int64_t _313 = 0; // k
    int64_t _314 = 0; // j
    _jump1631:; // Begin body of loop
    int64_t _315 = 0;
    _315 *= _311.d0;
    _315 += _314;
    _315 *= _311.d1;
    _315 += _313;
    _311.data[_315] = _308;
    _313++;
    if (_313 < _309)
    goto _jump1631;
    _313 = 0;
    _314++;
    if (_314 < _308)
    goto _jump1631;
    // End body of loop
    if (_183.d0 >= 0)
    goto _jump1632;
    fail_assertion("negative array index");
    _jump1632:;
    if (_183.d0 < _311.d0)
    goto _jump1633;
    fail_assertion("index too large");
    _jump1633:;
    if (_309 >= 0)
    goto _jump1634;
    fail_assertion("negative array index");
    _jump1634:;
    if (_309 < _311.d1)
    goto _jump1635;
    fail_assertion("index too large");
    _jump1635:;
    int64_t _316 = 0;
    _316 *= _311.d0;
    _316 += _183.d0;
    _316 *= _311.d1;
    _316 += _309;
    int64_t _317 = _311.data[_316];
    if (_317 > 0) 
    goto _jump1636;
    fail_assertion("non-positive loop bound");
    _jump1636:;
    // Computing bound for k
    if (_309 > 0) 
    goto _jump1637;
    fail_assertion("non-positive loop bound");
    _jump1637:;
    _310 = 0;
    int64_t _318 = 0; // k
    int64_t _319 = 0; // j
    _jump1638:; // Begin body of loop
    int64_t _320;
    // Computing bound for l
    if (_183.d0 > 0) 
    goto _jump1639;
    fail_assertion("non-positive loop bound");
    _jump1639:;
    _320 = 0;
    int64_t _321 = 0; // l
    _jump1640:; // Begin body of loop
    _320 += _318;
    _321++;
    if (_321 < _183.d0)
    goto _jump1640;
    // End body of loop
    _310 += _320;
    _318++;
    if (_318 < _309)
    goto _jump1638;
    _318 = 0;
    _319++;
    if (_319 < _317)
    goto _jump1638;
    // End body of loop
    _294 += _310;
    _307++;
    if (_307 < _183.d0)
    goto _jump1628;
    _307 = 0;
    _308++;
    if (_308 < _306)
    goto _jump1628;
    _308 = 0;
    _309++;
    if (_309 < _296)
    goto _jump1628;
    // End body of loop
    if (_281 >= 0)
    goto _jump1641;
    fail_assertion("negative array index");
    _jump1641:;
    if (_281 < _238.d0)
    goto _jump1642;
    fail_assertion("index too large");
    _jump1642:;
    if (_282 >= 0)
    goto _jump1643;
    fail_assertion("negative array index");
    _jump1643:;
    if (_282 < _238.d1)
    goto _jump1644;
    fail_assertion("index too large");
    _jump1644:;
    if (_294 >= 0)
    goto _jump1645;
    fail_assertion("negative array index");
    _jump1645:;
    if (_294 < _238.d2)
    goto _jump1646;
    fail_assertion("index too large");
    _jump1646:;
    int64_t _322 = 0;
    _322 *= _238.d0;
    _322 += _281;
    _322 *= _238.d1;
    _322 += _282;
    _322 *= _238.d2;
    _322 += _294;
    bool _323 = _238.data[_322];
    _228 = _323;
    _jump1580:;
    _a2_rgba _324;
    if (!_228)
    goto _jump1647;
    bool _325 = false;
    bool _326 = !_325;
    bool _327;
    if (!_326)
    goto _jump1648;
    bool _328 = true;
    _327 = _328;
    goto _jump1649;
    _jump1648:;
    _a2_int64_t _330;
    // Computing bound for g
    int64_t _331 = 530;
    _330.d0 = _331;
    if (_331 > 0) 
    goto _jump1650;
    fail_assertion("non-positive loop bound");
    _jump1650:;
    // Computing bound for h
    _330.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1651;
    fail_assertion("non-positive loop bound");
    _jump1651:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= _331;
    _332 *= _183.d0;
    _332 *= sizeof(int64_t);
    _330.data = jpl_alloc(_332);
    int64_t _333 = 0; // h
    int64_t _334 = 0; // g
    _jump1652:; // Begin body of loop
    int64_t _335 = 0;
    _335 *= _330.d0;
    _335 += _334;
    _335 *= _330.d1;
    _335 += _333;
    _330.data[_335] = _334;
    _333++;
    if (_333 < _183.d0)
    goto _jump1652;
    _333 = 0;
    _334++;
    if (_334 < _331)
    goto _jump1652;
    // End body of loop
    int64_t _336 = -_183.d0;
    int64_t _337 = -_183.d0;
    if (_336 >= 0)
    goto _jump1653;
    fail_assertion("negative array index");
    _jump1653:;
    if (_336 < _330.d0)
    goto _jump1654;
    fail_assertion("index too large");
    _jump1654:;
    if (_337 >= 0)
    goto _jump1655;
    fail_assertion("negative array index");
    _jump1655:;
    if (_337 < _330.d1)
    goto _jump1656;
    fail_assertion("index too large");
    _jump1656:;
    int64_t _338 = 0;
    _338 *= _330.d0;
    _338 += _336;
    _338 *= _330.d1;
    _338 += _337;
    int64_t _339 = _330.data[_338];
    bool _340 = true;
    int64_t _341;
    if (!_340)
    goto _jump1657;
    int64_t _342 = 373;
    _341 = _342;
    goto _jump1658;
    _jump1657:;
    bool _343 = true;
    int64_t _344;
    if (!_343)
    goto _jump1659;
    int64_t _345 = 89;
    _344 = _345;
    goto _jump1660;
    _jump1659:;
    int64_t _346 = 181;
    _344 = _346;
    _jump1660:;
    _341 = _344;
    _jump1658:;
    bool _347 = _339 >= _341;
    bool _329 = _347;
    if (0 != _347)
    goto _jump1661;
    double _349;
    // Computing bound for g
    int64_t _350 = 450;
    if (_350 > 0) 
    goto _jump1662;
    fail_assertion("non-positive loop bound");
    _jump1662:;
    // Computing bound for h
    if (_183.d0 > 0) 
    goto _jump1663;
    fail_assertion("non-positive loop bound");
    _jump1663:;
    _349 = 0;
    int64_t _351 = 0; // h
    int64_t _352 = 0; // g
    _jump1664:; // Begin body of loop
    double _353 = 82.0;
    _349 += _353;
    _351++;
    if (_351 < _183.d0)
    goto _jump1664;
    _351 = 0;
    _352++;
    if (_352 < _350)
    goto _jump1664;
    // End body of loop
    double _354 = 33.0;
    bool _355 = _349 > _354;
    bool _348 = _355;
    if (0 == _355)
    goto _jump1665;
    bool _356 = true;
    bool _357;
    if (!_356)
    goto _jump1666;
    bool _358 = true;
    bool _359 = !_358;
    _357 = _359;
    goto _jump1667;
    _jump1666:;
    bool _360 = false;
    bool _361 = !_360;
    _357 = _361;
    _jump1667:;
    _348 = _357;
    _jump1665:;
    _329 = _348;
    _jump1661:;
    _327 = _329;
    _jump1649:;
    _a2_rgba _362;
    if (!_327)
    goto _jump1668;
    _a2_rgba _363;
    // Computing bound for g
    int64_t _364;
    // Computing bound for g
    bool _365 = false;
    int64_t _366;
    if (!_365)
    goto _jump1669;
    int64_t _367 = 852;
    _366 = _367;
    goto _jump1670;
    _jump1669:;
    _366 = _183.d0;
    _jump1670:;
    int64_t _368 = -_366;
    int64_t _369 = -_368;
    if (_369 > 0) 
    goto _jump1671;
    fail_assertion("non-positive loop bound");
    _jump1671:;
    // Computing bound for h
    int64_t _370 = 102;
    if (_370 > 0) 
    goto _jump1672;
    fail_assertion("non-positive loop bound");
    _jump1672:;
    _364 = 0;
    int64_t _371 = 0; // h
    int64_t _372 = 0; // g
    _jump1673:; // Begin body of loop
    int64_t _373 = _371 / _372;
    int64_t _374 = _371 - _373;
    bool _375 = true;
    int64_t _376;
    if (!_375)
    goto _jump1674;
    _376 = _372;
    goto _jump1675;
    _jump1674:;
    int64_t _377;
    // Computing bound for i
    int64_t _378 = 725;
    if (_378 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing bound for j
    if (_372 > 0) 
    goto _jump1677;
    fail_assertion("non-positive loop bound");
    _jump1677:;
    // Computing bound for k
    if (_371 > 0) 
    goto _jump1678;
    fail_assertion("non-positive loop bound");
    _jump1678:;
    _377 = 0;
    int64_t _379 = 0; // k
    int64_t _380 = 0; // j
    int64_t _381 = 0; // i
    _jump1679:; // Begin body of loop
    _377 += _379;
    _379++;
    if (_379 < _371)
    goto _jump1679;
    _379 = 0;
    _380++;
    if (_380 < _372)
    goto _jump1679;
    _380 = 0;
    _381++;
    if (_381 < _378)
    goto _jump1679;
    // End body of loop
    _376 = _377;
    _jump1675:;
    int64_t _382 = _374 / _376;
    _364 += _382;
    _371++;
    if (_371 < _370)
    goto _jump1673;
    _371 = 0;
    _372++;
    if (_372 < _369)
    goto _jump1673;
    // End body of loop
    _363.d0 = _364;
    if (_364 > 0) 
    goto _jump1680;
    fail_assertion("non-positive loop bound");
    _jump1680:;
    // Computing bound for h
    bool _383 = true;
    bool _384 = !_383;
    _a2_int64_t _385;
    if (!_384)
    goto _jump1681;
    _a2_int64_t _386;
    // Computing bound for g
    _386.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1682;
    fail_assertion("non-positive loop bound");
    _jump1682:;
    // Computing bound for h
    int64_t _387 = 890;
    _386.d1 = _387;
    if (_387 > 0) 
    goto _jump1683;
    fail_assertion("non-positive loop bound");
    _jump1683:;
    // Computing total size of heap memory to allocate
    int64_t _388 = 1;
    _388 *= _183.d0;
    _388 *= _387;
    _388 *= sizeof(int64_t);
    _386.data = jpl_alloc(_388);
    int64_t _389 = 0; // h
    int64_t _390 = 0; // g
    _jump1684:; // Begin body of loop
    int64_t _391 = 0;
    _391 *= _386.d0;
    _391 += _390;
    _391 *= _386.d1;
    _391 += _389;
    _386.data[_391] = _183.d0;
    _389++;
    if (_389 < _387)
    goto _jump1684;
    _389 = 0;
    _390++;
    if (_390 < _183.d0)
    goto _jump1684;
    // End body of loop
    _385 = _386;
    goto _jump1685;
    _jump1681:;
    _a2_int64_t _392;
    // Computing bound for g
    int64_t _393 = 725;
    int64_t _394 = -_393;
    _392.d0 = _394;
    if (_394 > 0) 
    goto _jump1686;
    fail_assertion("non-positive loop bound");
    _jump1686:;
    // Computing bound for h
    int64_t _395 = _183.d0 - _183.d0;
    _392.d1 = _395;
    if (_395 > 0) 
    goto _jump1687;
    fail_assertion("non-positive loop bound");
    _jump1687:;
    // Computing total size of heap memory to allocate
    int64_t _396 = 1;
    _396 *= _394;
    _396 *= _395;
    _396 *= sizeof(int64_t);
    _392.data = jpl_alloc(_396);
    int64_t _397 = 0; // h
    int64_t _398 = 0; // g
    _jump1688:; // Begin body of loop
    int64_t _399 = 0;
    _399 *= _392.d0;
    _399 += _398;
    _399 *= _392.d1;
    _399 += _397;
    _392.data[_399] = _183.d0;
    _397++;
    if (_397 < _395)
    goto _jump1688;
    _397 = 0;
    _398++;
    if (_398 < _394)
    goto _jump1688;
    // End body of loop
    _385 = _392;
    _jump1685:;
    int64_t _400 = 286;
    bool _401 = false;
    int64_t _402;
    if (!_401)
    goto _jump1689;
    int64_t _403 = 796;
    _402 = _403;
    goto _jump1690;
    _jump1689:;
    int64_t _404 = 121;
    _402 = _404;
    _jump1690:;
    int64_t _405 = _183.d0 + _402;
    int64_t _406 = _400 - _405;
    bool _407 = true;
    int64_t _408;
    if (!_407)
    goto _jump1691;
    int64_t _409 = 972;
    _408 = _409;
    goto _jump1692;
    _jump1691:;
    int64_t _410 = 255;
    _408 = _410;
    _jump1692:;
    if (_408 >= 0)
    goto _jump1693;
    fail_assertion("negative array index");
    _jump1693:;
    if (_408 < _183.d0)
    goto _jump1694;
    fail_assertion("index too large");
    _jump1694:;
    int64_t _411 = 0;
    _411 *= _183.d0;
    _411 += _408;
    bool _412 = _183.data[_411];
    int64_t _413;
    if (!_412)
    goto _jump1695;
    int64_t _414;
    // Computing bound for g
    if (_183.d0 > 0) 
    goto _jump1696;
    fail_assertion("non-positive loop bound");
    _jump1696:;
    _414 = 0;
    int64_t _415 = 0; // g
    _jump1697:; // Begin body of loop
    int64_t _416 = 896;
    _414 += _416;
    _415++;
    if (_415 < _183.d0)
    goto _jump1697;
    // End body of loop
    _413 = _414;
    goto _jump1698;
    _jump1695:;
    int64_t _417 = -_183.d0;
    _413 = _417;
    _jump1698:;
    if (_406 >= 0)
    goto _jump1699;
    fail_assertion("negative array index");
    _jump1699:;
    if (_406 < _385.d0)
    goto _jump1700;
    fail_assertion("index too large");
    _jump1700:;
    if (_413 >= 0)
    goto _jump1701;
    fail_assertion("negative array index");
    _jump1701:;
    if (_413 < _385.d1)
    goto _jump1702;
    fail_assertion("index too large");
    _jump1702:;
    int64_t _418 = 0;
    _418 *= _385.d0;
    _418 += _406;
    _418 *= _385.d1;
    _418 += _413;
    int64_t _419 = _385.data[_418];
    _363.d1 = _419;
    if (_419 > 0) 
    goto _jump1703;
    fail_assertion("non-positive loop bound");
    _jump1703:;
    // Computing total size of heap memory to allocate
    int64_t _420 = 1;
    _420 *= _364;
    _420 *= _419;
    _420 *= sizeof(rgba);
    _363.data = jpl_alloc(_420);
    int64_t _421 = 0; // h
    int64_t _422 = 0; // g
    _jump1704:; // Begin body of loop
    double _423;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1705;
    fail_assertion("non-positive loop bound");
    _jump1705:;
    // Computing bound for j
    int64_t _424 = 695;
    bool _425 = _424 < _421;
    int64_t _426;
    if (!_425)
    goto _jump1706;
    _426 = _421;
    goto _jump1707;
    _jump1706:;
    int64_t _427;
    // Computing bound for i
    if (_421 > 0) 
    goto _jump1708;
    fail_assertion("non-positive loop bound");
    _jump1708:;
    // Computing bound for j
    int64_t _428 = 128;
    if (_428 > 0) 
    goto _jump1709;
    fail_assertion("non-positive loop bound");
    _jump1709:;
    _427 = 0;
    int64_t _429 = 0; // j
    int64_t _430 = 0; // i
    _jump1710:; // Begin body of loop
    _427 += _429;
    _429++;
    if (_429 < _428)
    goto _jump1710;
    _429 = 0;
    _430++;
    if (_430 < _421)
    goto _jump1710;
    // End body of loop
    _426 = _427;
    _jump1707:;
    if (_426 > 0) 
    goto _jump1711;
    fail_assertion("non-positive loop bound");
    _jump1711:;
    _423 = 0;
    int64_t _431 = 0; // j
    int64_t _432 = 0; // i
    _jump1712:; // Begin body of loop
    double _433 = 31.0;
    _423 += _433;
    _431++;
    if (_431 < _426)
    goto _jump1712;
    _431 = 0;
    _432++;
    if (_432 < _183.d0)
    goto _jump1712;
    // End body of loop
    double _434 = 72.0;
    double _435;
    // Computing bound for i
    if (_421 > 0) 
    goto _jump1713;
    fail_assertion("non-positive loop bound");
    _jump1713:;
    _435 = 0;
    int64_t _436 = 0; // i
    _jump1714:; // Begin body of loop
    double _437 = 54.0;
    _435 += _437;
    _436++;
    if (_436 < _421)
    goto _jump1714;
    // End body of loop
    double _438;
    // Computing bound for i
    if (_422 > 0) 
    goto _jump1715;
    fail_assertion("non-positive loop bound");
    _jump1715:;
    _438 = 0;
    int64_t _439 = 0; // i
    _jump1716:; // Begin body of loop
    double _440 = 41.0;
    _438 += _440;
    _439++;
    if (_439 < _422)
    goto _jump1716;
    // End body of loop
    double _441 = _435 - _438;
    double _442 = 1.0;
    rgba _443 = { _423, _434, _441, _442 };
    int64_t _444 = 0;
    _444 *= _363.d0;
    _444 += _422;
    _444 *= _363.d1;
    _444 += _421;
    _363.data[_444] = _443;
    _421++;
    if (_421 < _419)
    goto _jump1704;
    _421 = 0;
    _422++;
    if (_422 < _364)
    goto _jump1704;
    // End body of loop
    _362 = _363;
    goto _jump1717;
    _jump1668:;
    _a2_rgba _445;
    // Computing bound for g
    _a1_int64_t _446;
    // Computing bound for g
    _446.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1718;
    fail_assertion("non-positive loop bound");
    _jump1718:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= _183.d0;
    _447 *= sizeof(int64_t);
    _446.data = jpl_alloc(_447);
    int64_t _448 = 0; // g
    _jump1719:; // Begin body of loop
    int64_t _449 = 0;
    _449 *= _446.d0;
    _449 += _448;
    _446.data[_449] = _183.d0;
    _448++;
    if (_448 < _183.d0)
    goto _jump1719;
    // End body of loop
    int64_t _450 = 494;
    if (_450 >= 0)
    goto _jump1720;
    fail_assertion("negative array index");
    _jump1720:;
    if (_450 < _446.d0)
    goto _jump1721;
    fail_assertion("index too large");
    _jump1721:;
    int64_t _451 = 0;
    _451 *= _446.d0;
    _451 += _450;
    int64_t _452 = _446.data[_451];
    int64_t _453 = -_452;
    _445.d0 = _453;
    if (_453 > 0) 
    goto _jump1722;
    fail_assertion("non-positive loop bound");
    _jump1722:;
    // Computing bound for h
    int64_t _454;
    // Computing bound for g
    int64_t _455 = 579;
    bool _456 = _183.d0 == _455;
    int64_t _457;
    if (!_456)
    goto _jump1723;
    int64_t _458 = 431;
    _457 = _458;
    goto _jump1724;
    _jump1723:;
    int64_t _459 = 553;
    _457 = _459;
    _jump1724:;
    if (_457 > 0) 
    goto _jump1725;
    fail_assertion("non-positive loop bound");
    _jump1725:;
    _454 = 0;
    int64_t _460 = 0; // g
    _jump1726:; // Begin body of loop
    bool _462 = true;
    bool _461 = _462;
    if (0 != _462)
    goto _jump1727;
    if (_183.d0 >= 0)
    goto _jump1728;
    fail_assertion("negative array index");
    _jump1728:;
    if (_183.d0 < _183.d0)
    goto _jump1729;
    fail_assertion("index too large");
    _jump1729:;
    int64_t _463 = 0;
    _463 *= _183.d0;
    _463 += _183.d0;
    bool _464 = _183.data[_463];
    _461 = _464;
    _jump1727:;
    int64_t _465;
    if (!_461)
    goto _jump1730;
    int64_t _466 = -_460;
    _465 = _466;
    goto _jump1731;
    _jump1730:;
    bool _467 = true;
    int64_t _468;
    if (!_467)
    goto _jump1732;
    _468 = _183.d0;
    goto _jump1733;
    _jump1732:;
    int64_t _469 = 160;
    _468 = _469;
    _jump1733:;
    _465 = _468;
    _jump1731:;
    _454 += _465;
    _460++;
    if (_460 < _457)
    goto _jump1726;
    // End body of loop
    _445.d1 = _454;
    if (_454 > 0) 
    goto _jump1734;
    fail_assertion("non-positive loop bound");
    _jump1734:;
    // Computing total size of heap memory to allocate
    int64_t _470 = 1;
    _470 *= _453;
    _470 *= _454;
    _470 *= sizeof(rgba);
    _445.data = jpl_alloc(_470);
    int64_t _471 = 0; // h
    int64_t _472 = 0; // g
    _jump1735:; // Begin body of loop
    double _473;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1736;
    fail_assertion("non-positive loop bound");
    _jump1736:;
    _473 = 0;
    int64_t _474 = 0; // i
    _jump1737:; // Begin body of loop
    double _475 = 38.0;
    _473 += _475;
    _474++;
    if (_474 < _183.d0)
    goto _jump1737;
    // End body of loop
    double _476;
    // Computing bound for i
    bool _477 = true;
    int64_t _478;
    if (!_477)
    goto _jump1738;
    int64_t _479 = 789;
    int64_t _480 = -_479;
    _478 = _480;
    goto _jump1739;
    _jump1738:;
    int64_t _481 = _183.d0 / _471;
    _478 = _481;
    _jump1739:;
    if (_478 > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing bound for j
    int64_t _482;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1741;
    fail_assertion("non-positive loop bound");
    _jump1741:;
    // Computing bound for j
    if (_472 > 0) 
    goto _jump1742;
    fail_assertion("non-positive loop bound");
    _jump1742:;
    _482 = 0;
    int64_t _483 = 0; // j
    int64_t _484 = 0; // i
    _jump1743:; // Begin body of loop
    _482 += _484;
    _483++;
    if (_483 < _472)
    goto _jump1743;
    _483 = 0;
    _484++;
    if (_484 < _183.d0)
    goto _jump1743;
    // End body of loop
    int64_t _485 = -_482;
    if (_485 > 0) 
    goto _jump1744;
    fail_assertion("non-positive loop bound");
    _jump1744:;
    _476 = 0;
    int64_t _486 = 0; // j
    int64_t _487 = 0; // i
    _jump1745:; // Begin body of loop
    double _488;
    // Computing bound for k
    if (_487 > 0) 
    goto _jump1746;
    fail_assertion("non-positive loop bound");
    _jump1746:;
    _488 = 0;
    int64_t _489 = 0; // k
    _jump1747:; // Begin body of loop
    double _490 = 54.0;
    _488 += _490;
    _489++;
    if (_489 < _487)
    goto _jump1747;
    // End body of loop
    double _491 = 4.0;
    double _492 = _488 + _491;
    _476 += _492;
    _486++;
    if (_486 < _485)
    goto _jump1745;
    _486 = 0;
    _487++;
    if (_487 < _478)
    goto _jump1745;
    // End body of loop
    double _493;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1748;
    fail_assertion("non-positive loop bound");
    _jump1748:;
    // Computing bound for j
    int64_t _494 = 265;
    int64_t _495 = _494 + _471;
    if (_495 > 0) 
    goto _jump1749;
    fail_assertion("non-positive loop bound");
    _jump1749:;
    _493 = 0;
    int64_t _496 = 0; // j
    int64_t _497 = 0; // i
    _jump1750:; // Begin body of loop
    double _498 = 54.0;
    double _499 = 95.0;
    double _500 = _498 / _499;
    double _501 = -_500;
    _493 += _501;
    _496++;
    if (_496 < _495)
    goto _jump1750;
    _496 = 0;
    _497++;
    if (_497 < _183.d0)
    goto _jump1750;
    // End body of loop
    double _502 = 36.0;
    double _503 = 26.0;
    double _504 = _502 / _503;
    double _505;
    // Computing bound for i
    if (_472 > 0) 
    goto _jump1751;
    fail_assertion("non-positive loop bound");
    _jump1751:;
    // Computing bound for j
    if (_471 > 0) 
    goto _jump1752;
    fail_assertion("non-positive loop bound");
    _jump1752:;
    _505 = 0;
    int64_t _506 = 0; // j
    int64_t _507 = 0; // i
    _jump1753:; // Begin body of loop
    double _508 = 14.0;
    _505 += _508;
    _506++;
    if (_506 < _471)
    goto _jump1753;
    _506 = 0;
    _507++;
    if (_507 < _472)
    goto _jump1753;
    // End body of loop
    double _509 = 59.0;
    double _510 = 99.0;
    rgba _511 = { _504, _505, _509, _510 };
    double _512 = _511.g;
    rgba _513 = { _473, _476, _493, _512 };
    int64_t _514 = 0;
    _514 *= _445.d0;
    _514 += _472;
    _514 *= _445.d1;
    _514 += _471;
    _445.data[_514] = _513;
    _471++;
    if (_471 < _454)
    goto _jump1735;
    _471 = 0;
    _472++;
    if (_472 < _453)
    goto _jump1735;
    // End body of loop
    _362 = _445;
    _jump1717:;
    _324 = _362;
    goto _jump1754;
    _jump1647:;
    _a2_rgba _515;
    // Computing bound for g
    _a2_int64_t _516;
    // Computing bound for g
    int64_t _517 = 180;
    _516.d0 = _517;
    if (_517 > 0) 
    goto _jump1755;
    fail_assertion("non-positive loop bound");
    _jump1755:;
    // Computing bound for h
    bool _518 = false;
    int64_t _519;
    if (!_518)
    goto _jump1756;
    int64_t _520 = 227;
    _519 = _520;
    goto _jump1757;
    _jump1756:;
    int64_t _521 = 32;
    int64_t _522 = _183.d0 / _521;
    _519 = _522;
    _jump1757:;
    _516.d1 = _519;
    if (_519 > 0) 
    goto _jump1758;
    fail_assertion("non-positive loop bound");
    _jump1758:;
    // Computing total size of heap memory to allocate
    int64_t _523 = 1;
    _523 *= _517;
    _523 *= _519;
    _523 *= sizeof(int64_t);
    _516.data = jpl_alloc(_523);
    int64_t _524 = 0; // h
    int64_t _525 = 0; // g
    _jump1759:; // Begin body of loop
    int64_t _526 = 0;
    _526 *= _516.d0;
    _526 += _525;
    _526 *= _516.d1;
    _526 += _524;
    _516.data[_526] = _524;
    _524++;
    if (_524 < _519)
    goto _jump1759;
    _524 = 0;
    _525++;
    if (_525 < _517)
    goto _jump1759;
    // End body of loop
    int64_t _527 = 108;
    if (_183.d0 >= 0)
    goto _jump1760;
    fail_assertion("negative array index");
    _jump1760:;
    if (_183.d0 < _516.d0)
    goto _jump1761;
    fail_assertion("index too large");
    _jump1761:;
    if (_527 >= 0)
    goto _jump1762;
    fail_assertion("negative array index");
    _jump1762:;
    if (_527 < _516.d1)
    goto _jump1763;
    fail_assertion("index too large");
    _jump1763:;
    int64_t _528 = 0;
    _528 *= _516.d0;
    _528 += _183.d0;
    _528 *= _516.d1;
    _528 += _527;
    int64_t _529 = _516.data[_528];
    _515.d0 = _529;
    if (_529 > 0) 
    goto _jump1764;
    fail_assertion("non-positive loop bound");
    _jump1764:;
    // Computing bound for h
    int64_t _530;
    // Computing bound for g
    _a3_int64_t _531;
    // Computing bound for g
    _531.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1765;
    fail_assertion("non-positive loop bound");
    _jump1765:;
    // Computing bound for h
    int64_t _532 = 443;
    _531.d1 = _532;
    if (_532 > 0) 
    goto _jump1766;
    fail_assertion("non-positive loop bound");
    _jump1766:;
    // Computing bound for i
    _531.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1767;
    fail_assertion("non-positive loop bound");
    _jump1767:;
    // Computing total size of heap memory to allocate
    int64_t _533 = 1;
    _533 *= _183.d0;
    _533 *= _532;
    _533 *= _183.d0;
    _533 *= sizeof(int64_t);
    _531.data = jpl_alloc(_533);
    int64_t _534 = 0; // i
    int64_t _535 = 0; // h
    int64_t _536 = 0; // g
    _jump1768:; // Begin body of loop
    int64_t _537 = 0;
    _537 *= _531.d0;
    _537 += _536;
    _537 *= _531.d1;
    _537 += _535;
    _537 *= _531.d2;
    _537 += _534;
    _531.data[_537] = _183.d0;
    _534++;
    if (_534 < _183.d0)
    goto _jump1768;
    _534 = 0;
    _535++;
    if (_535 < _532)
    goto _jump1768;
    _535 = 0;
    _536++;
    if (_536 < _183.d0)
    goto _jump1768;
    // End body of loop
    int64_t _538 = -_183.d0;
    int64_t _539 = 421;
    if (_183.d0 >= 0)
    goto _jump1769;
    fail_assertion("negative array index");
    _jump1769:;
    if (_183.d0 < _531.d0)
    goto _jump1770;
    fail_assertion("index too large");
    _jump1770:;
    if (_538 >= 0)
    goto _jump1771;
    fail_assertion("negative array index");
    _jump1771:;
    if (_538 < _531.d1)
    goto _jump1772;
    fail_assertion("index too large");
    _jump1772:;
    if (_539 >= 0)
    goto _jump1773;
    fail_assertion("negative array index");
    _jump1773:;
    if (_539 < _531.d2)
    goto _jump1774;
    fail_assertion("index too large");
    _jump1774:;
    int64_t _540 = 0;
    _540 *= _531.d0;
    _540 += _183.d0;
    _540 *= _531.d1;
    _540 += _538;
    _540 *= _531.d2;
    _540 += _539;
    int64_t _541 = _531.data[_540];
    if (_541 > 0) 
    goto _jump1775;
    fail_assertion("non-positive loop bound");
    _jump1775:;
    // Computing bound for h
    int64_t _542 = 782;
    int64_t _543 = -_542;
    int64_t _544 = _183.d0 % _543;
    if (_544 > 0) 
    goto _jump1776;
    fail_assertion("non-positive loop bound");
    _jump1776:;
    _530 = 0;
    int64_t _545 = 0; // h
    int64_t _546 = 0; // g
    _jump1777:; // Begin body of loop
    int64_t _547 = -_545;
    _530 += _547;
    _545++;
    if (_545 < _544)
    goto _jump1777;
    _545 = 0;
    _546++;
    if (_546 < _541)
    goto _jump1777;
    // End body of loop
    int64_t _548 = -_530;
    bool _549 = true;
    int64_t _550;
    if (!_549)
    goto _jump1778;
    _a2_int64_t _551;
    // Computing bound for g
    _551.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    // Computing bound for h
    int64_t _552 = -_183.d0;
    _551.d1 = _552;
    if (_552 > 0) 
    goto _jump1780;
    fail_assertion("non-positive loop bound");
    _jump1780:;
    // Computing total size of heap memory to allocate
    int64_t _553 = 1;
    _553 *= _183.d0;
    _553 *= _552;
    _553 *= sizeof(int64_t);
    _551.data = jpl_alloc(_553);
    int64_t _554 = 0; // h
    int64_t _555 = 0; // g
    _jump1781:; // Begin body of loop
    int64_t _556 = 0;
    _556 *= _551.d0;
    _556 += _555;
    _556 *= _551.d1;
    _556 += _554;
    _551.data[_556] = _183.d0;
    _554++;
    if (_554 < _552)
    goto _jump1781;
    _554 = 0;
    _555++;
    if (_555 < _183.d0)
    goto _jump1781;
    // End body of loop
    bool _557 = true;
    int64_t _558;
    if (!_557)
    goto _jump1782;
    _558 = _183.d0;
    goto _jump1783;
    _jump1782:;
    int64_t _559 = 688;
    _558 = _559;
    _jump1783:;
    int64_t _560 = -_558;
    int64_t _561 = 947;
    if (_560 >= 0)
    goto _jump1784;
    fail_assertion("negative array index");
    _jump1784:;
    if (_560 < _551.d0)
    goto _jump1785;
    fail_assertion("index too large");
    _jump1785:;
    if (_561 >= 0)
    goto _jump1786;
    fail_assertion("negative array index");
    _jump1786:;
    if (_561 < _551.d1)
    goto _jump1787;
    fail_assertion("index too large");
    _jump1787:;
    int64_t _562 = 0;
    _562 *= _551.d0;
    _562 += _560;
    _562 *= _551.d1;
    _562 += _561;
    int64_t _563 = _551.data[_562];
    _550 = _563;
    goto _jump1788;
    _jump1778:;
    double _564 = 97.0;
    double _565 = 78.0;
    bool _566 = _564 == _565;
    bool _567 = !_566;
    int64_t _568;
    if (!_567)
    goto _jump1789;
    _568 = _183.d0;
    goto _jump1790;
    _jump1789:;
    int64_t _569;
    // Computing bound for g
    if (_183.d0 > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    _569 = 0;
    int64_t _570 = 0; // g
    _jump1792:; // Begin body of loop
    int64_t _571 = 390;
    int64_t _572 = -_571;
    _569 += _572;
    _570++;
    if (_570 < _183.d0)
    goto _jump1792;
    // End body of loop
    _568 = _569;
    _jump1790:;
    _550 = _568;
    _jump1788:;
    int64_t _573 = _548 + _550;
    _515.d1 = _573;
    if (_573 > 0) 
    goto _jump1793;
    fail_assertion("non-positive loop bound");
    _jump1793:;
    // Computing total size of heap memory to allocate
    int64_t _574 = 1;
    _574 *= _529;
    _574 *= _573;
    _574 *= sizeof(rgba);
    _515.data = jpl_alloc(_574);
    int64_t _575 = 0; // h
    int64_t _576 = 0; // g
    _jump1794:; // Begin body of loop
    double _577;
    // Computing bound for i
    int64_t _578 = 382;
    bool _579 = _578 == _183.d0;
    int64_t _580;
    if (!_579)
    goto _jump1795;
    _580 = _575;
    goto _jump1796;
    _jump1795:;
    _580 = _576;
    _jump1796:;
    if (_580 > 0) 
    goto _jump1797;
    fail_assertion("non-positive loop bound");
    _jump1797:;
    // Computing bound for j
    int64_t _581 = -_575;
    if (_581 > 0) 
    goto _jump1798;
    fail_assertion("non-positive loop bound");
    _jump1798:;
    _577 = 0;
    int64_t _582 = 0; // j
    int64_t _583 = 0; // i
    _jump1799:; // Begin body of loop
    double _584 = 91.0;
    _577 += _584;
    _582++;
    if (_582 < _581)
    goto _jump1799;
    _582 = 0;
    _583++;
    if (_583 < _580)
    goto _jump1799;
    // End body of loop
    double _585 = 57.0;
    double _586;
    // Computing bound for i
    if (_575 > 0) 
    goto _jump1800;
    fail_assertion("non-positive loop bound");
    _jump1800:;
    // Computing bound for j
    if (_576 > 0) 
    goto _jump1801;
    fail_assertion("non-positive loop bound");
    _jump1801:;
    _586 = 0;
    int64_t _587 = 0; // j
    int64_t _588 = 0; // i
    _jump1802:; // Begin body of loop
    double _589;
    // Computing bound for k
    int64_t _590 = 209;
    if (_590 > 0) 
    goto _jump1803;
    fail_assertion("non-positive loop bound");
    _jump1803:;
    // Computing bound for l
    if (_183.d0 > 0) 
    goto _jump1804;
    fail_assertion("non-positive loop bound");
    _jump1804:;
    // Computing bound for m
    int64_t _591 = 76;
    if (_591 > 0) 
    goto _jump1805;
    fail_assertion("non-positive loop bound");
    _jump1805:;
    _589 = 0;
    int64_t _592 = 0; // m
    int64_t _593 = 0; // l
    int64_t _594 = 0; // k
    _jump1806:; // Begin body of loop
    double _595 = 8.0;
    _589 += _595;
    _592++;
    if (_592 < _591)
    goto _jump1806;
    _592 = 0;
    _593++;
    if (_593 < _183.d0)
    goto _jump1806;
    _593 = 0;
    _594++;
    if (_594 < _590)
    goto _jump1806;
    // End body of loop
    _586 += _589;
    _587++;
    if (_587 < _576)
    goto _jump1802;
    _587 = 0;
    _588++;
    if (_588 < _575)
    goto _jump1802;
    // End body of loop
    double _596 = fmod(_585, _586);
    bool _597 = _577 == _596;
    rgba _598;
    if (!_597)
    goto _jump1807;
    _a3_rgba _599;
    // Computing bound for i
    _599.d0 = _576;
    if (_576 > 0) 
    goto _jump1808;
    fail_assertion("non-positive loop bound");
    _jump1808:;
    // Computing bound for j
    _599.d1 = _576;
    if (_576 > 0) 
    goto _jump1809;
    fail_assertion("non-positive loop bound");
    _jump1809:;
    // Computing bound for k
    int64_t _600;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1810;
    fail_assertion("non-positive loop bound");
    _jump1810:;
    _600 = 0;
    int64_t _601 = 0; // i
    _jump1811:; // Begin body of loop
    int64_t _602 = 395;
    _600 += _602;
    _601++;
    if (_601 < _183.d0)
    goto _jump1811;
    // End body of loop
    _599.d2 = _600;
    if (_600 > 0) 
    goto _jump1812;
    fail_assertion("non-positive loop bound");
    _jump1812:;
    // Computing total size of heap memory to allocate
    int64_t _603 = 1;
    _603 *= _576;
    _603 *= _576;
    _603 *= _600;
    _603 *= sizeof(rgba);
    _599.data = jpl_alloc(_603);
    int64_t _604 = 0; // k
    int64_t _605 = 0; // j
    int64_t _606 = 0; // i
    _jump1813:; // Begin body of loop
    double _607 = 29.0;
    double _608 = 91.0;
    double _609 = _607 * _608;
    double _610 = 88.0;
    double _611 = 29.0;
    double _612 = 94.0;
    rgba _613 = { _609, _610, _611, _612 };
    int64_t _614 = 0;
    _614 *= _599.d0;
    _614 += _606;
    _614 *= _599.d1;
    _614 += _605;
    _614 *= _599.d2;
    _614 += _604;
    _599.data[_614] = _613;
    _604++;
    if (_604 < _600)
    goto _jump1813;
    _604 = 0;
    _605++;
    if (_605 < _576)
    goto _jump1813;
    _605 = 0;
    _606++;
    if (_606 < _576)
    goto _jump1813;
    // End body of loop
    int64_t _615 = -_576;
    int64_t _616;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1814;
    fail_assertion("non-positive loop bound");
    _jump1814:;
    // Computing bound for j
    int64_t _617 = 917;
    if (_617 > 0) 
    goto _jump1815;
    fail_assertion("non-positive loop bound");
    _jump1815:;
    _616 = 0;
    int64_t _618 = 0; // j
    int64_t _619 = 0; // i
    _jump1816:; // Begin body of loop
    _616 += _183.d0;
    _618++;
    if (_618 < _617)
    goto _jump1816;
    _618 = 0;
    _619++;
    if (_619 < _183.d0)
    goto _jump1816;
    // End body of loop
    if (_615 >= 0)
    goto _jump1817;
    fail_assertion("negative array index");
    _jump1817:;
    if (_615 < _599.d0)
    goto _jump1818;
    fail_assertion("index too large");
    _jump1818:;
    if (_616 >= 0)
    goto _jump1819;
    fail_assertion("negative array index");
    _jump1819:;
    if (_616 < _599.d1)
    goto _jump1820;
    fail_assertion("index too large");
    _jump1820:;
    if (_576 >= 0)
    goto _jump1821;
    fail_assertion("negative array index");
    _jump1821:;
    if (_576 < _599.d2)
    goto _jump1822;
    fail_assertion("index too large");
    _jump1822:;
    int64_t _620 = 0;
    _620 *= _599.d0;
    _620 += _615;
    _620 *= _599.d1;
    _620 += _616;
    _620 *= _599.d2;
    _620 += _576;
    rgba _621 = _599.data[_620];
    _598 = _621;
    goto _jump1823;
    _jump1807:;
    bool _623 = false;
    bool _622 = _623;
    if (0 != _623)
    goto _jump1824;
    int64_t _624;
    // Computing bound for i
    if (_576 > 0) 
    goto _jump1825;
    fail_assertion("non-positive loop bound");
    _jump1825:;
    // Computing bound for j
    if (_183.d0 > 0) 
    goto _jump1826;
    fail_assertion("non-positive loop bound");
    _jump1826:;
    // Computing bound for k
    if (_576 > 0) 
    goto _jump1827;
    fail_assertion("non-positive loop bound");
    _jump1827:;
    _624 = 0;
    int64_t _625 = 0; // k
    int64_t _626 = 0; // j
    int64_t _627 = 0; // i
    _jump1828:; // Begin body of loop
    _624 += _183.d0;
    _625++;
    if (_625 < _576)
    goto _jump1828;
    _625 = 0;
    _626++;
    if (_626 < _183.d0)
    goto _jump1828;
    _626 = 0;
    _627++;
    if (_627 < _576)
    goto _jump1828;
    // End body of loop
    if (_624 >= 0)
    goto _jump1829;
    fail_assertion("negative array index");
    _jump1829:;
    if (_624 < _183.d0)
    goto _jump1830;
    fail_assertion("index too large");
    _jump1830:;
    int64_t _628 = 0;
    _628 *= _183.d0;
    _628 += _624;
    bool _629 = _183.data[_628];
    _622 = _629;
    _jump1824:;
    rgba _630;
    if (!_622)
    goto _jump1831;
    _a1_double _631;
    // Computing bound for i
    int64_t _632 = 238;
    _631.d0 = _632;
    if (_632 > 0) 
    goto _jump1832;
    fail_assertion("non-positive loop bound");
    _jump1832:;
    // Computing total size of heap memory to allocate
    int64_t _633 = 1;
    _633 *= _632;
    _633 *= sizeof(double);
    _631.data = jpl_alloc(_633);
    int64_t _634 = 0; // i
    _jump1833:; // Begin body of loop
    double _635 = 49.0;
    int64_t _636 = 0;
    _636 *= _631.d0;
    _636 += _634;
    _631.data[_636] = _635;
    _634++;
    if (_634 < _632)
    goto _jump1833;
    // End body of loop
    if (_183.d0 >= 0)
    goto _jump1834;
    fail_assertion("negative array index");
    _jump1834:;
    if (_183.d0 < _631.d0)
    goto _jump1835;
    fail_assertion("index too large");
    _jump1835:;
    int64_t _637 = 0;
    _637 *= _631.d0;
    _637 += _183.d0;
    double _638 = _631.data[_637];
    double _639 = 91.0;
    double _640 = 58.0;
    double _641 = _639 * _640;
    double _642 = -_641;
    double _643;
    // Computing bound for i
    if (_575 > 0) 
    goto _jump1836;
    fail_assertion("non-positive loop bound");
    _jump1836:;
    // Computing bound for j
    int64_t _644 = _576 % _183.d0;
    if (_644 > 0) 
    goto _jump1837;
    fail_assertion("non-positive loop bound");
    _jump1837:;
    // Computing bound for k
    int64_t _645 = -_183.d0;
    if (_645 > 0) 
    goto _jump1838;
    fail_assertion("non-positive loop bound");
    _jump1838:;
    _643 = 0;
    int64_t _646 = 0; // k
    int64_t _647 = 0; // j
    int64_t _648 = 0; // i
    _jump1839:; // Begin body of loop
    double _649;
    // Computing bound for l
    if (_576 > 0) 
    goto _jump1840;
    fail_assertion("non-positive loop bound");
    _jump1840:;
    // Computing bound for m
    if (_646 > 0) 
    goto _jump1841;
    fail_assertion("non-positive loop bound");
    _jump1841:;
    _649 = 0;
    int64_t _650 = 0; // m
    int64_t _651 = 0; // l
    _jump1842:; // Begin body of loop
    double _652 = 26.0;
    _649 += _652;
    _650++;
    if (_650 < _646)
    goto _jump1842;
    _650 = 0;
    _651++;
    if (_651 < _576)
    goto _jump1842;
    // End body of loop
    _643 += _649;
    _646++;
    if (_646 < _645)
    goto _jump1839;
    _646 = 0;
    _647++;
    if (_647 < _644)
    goto _jump1839;
    _647 = 0;
    _648++;
    if (_648 < _575)
    goto _jump1839;
    // End body of loop
    double _653 = 5.0;
    double _654 = -_653;
    double _655 = -_654;
    rgba _656 = { _638, _642, _643, _655 };
    _630 = _656;
    goto _jump1843;
    _jump1831:;
    double _657 = 31.0;
    double _658;
    // Computing bound for i
    int64_t _659 = 119;
    if (_659 > 0) 
    goto _jump1844;
    fail_assertion("non-positive loop bound");
    _jump1844:;
    // Computing bound for j
    if (_576 > 0) 
    goto _jump1845;
    fail_assertion("non-positive loop bound");
    _jump1845:;
    _658 = 0;
    int64_t _660 = 0; // j
    int64_t _661 = 0; // i
    _jump1846:; // Begin body of loop
    double _662 = 24.0;
    _658 += _662;
    _660++;
    if (_660 < _576)
    goto _jump1846;
    _660 = 0;
    _661++;
    if (_661 < _659)
    goto _jump1846;
    // End body of loop
    double _663 = 84.0;
    double _664 = 5.0;
    double _665 = -_664;
    rgba _666 = { _657, _658, _663, _665 };
    _630 = _666;
    _jump1843:;
    _598 = _630;
    _jump1823:;
    int64_t _667 = 0;
    _667 *= _515.d0;
    _667 += _576;
    _667 *= _515.d1;
    _667 += _575;
    _515.data[_667] = _598;
    _575++;
    if (_575 < _573)
    goto _jump1794;
    _575 = 0;
    _576++;
    if (_576 < _529)
    goto _jump1794;
    // End body of loop
    _324 = _515;
    _jump1754:;
    write_image(_324, "g.png");
    _a2_rgba _668 = read_image("g.png");
    _a1__a3_int64_t _669;
    // Computing bound for h
    bool _671 = true;
    bool _670 = _671;
    if (0 != _671)
    goto _jump1847;
    int64_t _673 = 868;
    if (_673 >= 0)
    goto _jump1848;
    fail_assertion("negative array index");
    _jump1848:;
    if (_673 < _183.d0)
    goto _jump1849;
    fail_assertion("index too large");
    _jump1849:;
    int64_t _674 = 0;
    _674 *= _183.d0;
    _674 += _673;
    bool _675 = _183.data[_674];
    bool _676 = !_675;
    bool _672 = _676;
    if (0 != _676)
    goto _jump1850;
    bool _677 = false;
    _672 = _677;
    _jump1850:;
    _670 = _672;
    _jump1847:;
    int64_t _678;
    if (!_670)
    goto _jump1851;
    bool _679 = true;
    bool _680;
    if (!_679)
    goto _jump1852;
    int64_t _681;
    // Computing bound for h
    int64_t _682 = 721;
    if (_682 > 0) 
    goto _jump1853;
    fail_assertion("non-positive loop bound");
    _jump1853:;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1854;
    fail_assertion("non-positive loop bound");
    _jump1854:;
    _681 = 0;
    int64_t _683 = 0; // i
    int64_t _684 = 0; // h
    _jump1855:; // Begin body of loop
    int64_t _685 = 666;
    _681 += _685;
    _683++;
    if (_683 < _183.d0)
    goto _jump1855;
    _683 = 0;
    _684++;
    if (_684 < _682)
    goto _jump1855;
    // End body of loop
    bool _686 = _183.d0 > _681;
    _680 = _686;
    goto _jump1856;
    _jump1852:;
    int64_t _687 = 377;
    int64_t _688 = _183.d0 % _687;
    bool _689 = _688 != _183.d0;
    _680 = _689;
    _jump1856:;
    int64_t _690;
    if (!_680)
    goto _jump1857;
    bool _691 = true;
    int64_t _692;
    if (!_691)
    goto _jump1858;
    int64_t _693 = 505;
    int64_t _694 = _693 + _183.d0;
    int64_t _695 = -_694;
    _692 = _695;
    goto _jump1859;
    _jump1858:;
    _692 = _183.d0;
    _jump1859:;
    _690 = _692;
    goto _jump1860;
    _jump1857:;
    int64_t _696 = 980;
    int64_t _697 = -_696;
    _690 = _697;
    _jump1860:;
    _678 = _690;
    goto _jump1861;
    _jump1851:;
    bool _699 = false;
    bool _698 = _699;
    if (0 != _699)
    goto _jump1862;
    bool _700 = false;
    _698 = _700;
    _jump1862:;
    int64_t _701;
    if (!_698)
    goto _jump1863;
    int64_t _702 = -_183.d0;
    bool _703 = _702 > _183.d0;
    int64_t _704;
    if (!_703)
    goto _jump1864;
    _704 = _183.d0;
    goto _jump1865;
    _jump1864:;
    int64_t _705 = -_183.d0;
    _704 = _705;
    _jump1865:;
    _701 = _704;
    goto _jump1866;
    _jump1863:;
    double _706 = 93.0;
    double _707;
    // Computing bound for h
    int64_t _708 = 930;
    if (_708 > 0) 
    goto _jump1867;
    fail_assertion("non-positive loop bound");
    _jump1867:;
    _707 = 0;
    int64_t _709 = 0; // h
    _jump1868:; // Begin body of loop
    double _710 = 56.0;
    _707 += _710;
    _709++;
    if (_709 < _708)
    goto _jump1868;
    // End body of loop
    bool _711 = _706 != _707;
    int64_t _712;
    if (!_711)
    goto _jump1869;
    int64_t _713;
    // Computing bound for h
    int64_t _714 = _183.d0 * _183.d0;
    if (_714 > 0) 
    goto _jump1870;
    fail_assertion("non-positive loop bound");
    _jump1870:;
    // Computing bound for i
    int64_t _715 = 42;
    int64_t _716 = 201;
    int64_t _717 = _715 % _716;
    if (_717 > 0) 
    goto _jump1871;
    fail_assertion("non-positive loop bound");
    _jump1871:;
    _713 = 0;
    int64_t _718 = 0; // i
    int64_t _719 = 0; // h
    _jump1872:; // Begin body of loop
    _713 += _718;
    _718++;
    if (_718 < _717)
    goto _jump1872;
    _718 = 0;
    _719++;
    if (_719 < _714)
    goto _jump1872;
    // End body of loop
    _712 = _713;
    goto _jump1873;
    _jump1869:;
    _712 = _183.d0;
    _jump1873:;
    _701 = _712;
    _jump1866:;
    _678 = _701;
    _jump1861:;
    _669.d0 = _678;
    if (_678 > 0) 
    goto _jump1874;
    fail_assertion("non-positive loop bound");
    _jump1874:;
    // Computing total size of heap memory to allocate
    int64_t _720 = 1;
    _720 *= _678;
    _720 *= sizeof(_a3_int64_t);
    _669.data = jpl_alloc(_720);
    int64_t _721 = 0; // h
    _jump1875:; // Begin body of loop
    _a3__a3_int64_t _722;
    // Computing bound for i
    _722.d0 = _721;
    if (_721 > 0) 
    goto _jump1876;
    fail_assertion("non-positive loop bound");
    _jump1876:;
    // Computing bound for j
    _a2_int64_t _723;
    // Computing bound for i
    int64_t _724 = -_183.d0;
    _723.d0 = _724;
    if (_724 > 0) 
    goto _jump1877;
    fail_assertion("non-positive loop bound");
    _jump1877:;
    // Computing bound for j
    int64_t _725 = 492;
    _723.d1 = _725;
    if (_725 > 0) 
    goto _jump1878;
    fail_assertion("non-positive loop bound");
    _jump1878:;
    // Computing total size of heap memory to allocate
    int64_t _726 = 1;
    _726 *= _724;
    _726 *= _725;
    _726 *= sizeof(int64_t);
    _723.data = jpl_alloc(_726);
    int64_t _727 = 0; // j
    int64_t _728 = 0; // i
    _jump1879:; // Begin body of loop
    int64_t _729 = -_727;
    int64_t _730 = 0;
    _730 *= _723.d0;
    _730 += _728;
    _730 *= _723.d1;
    _730 += _727;
    _723.data[_730] = _729;
    _727++;
    if (_727 < _725)
    goto _jump1879;
    _727 = 0;
    _728++;
    if (_728 < _724)
    goto _jump1879;
    // End body of loop
    int64_t _731;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1880;
    fail_assertion("non-positive loop bound");
    _jump1880:;
    // Computing bound for j
    int64_t _732;
    // Computing bound for i
    int64_t _733 = 863;
    if (_733 > 0) 
    goto _jump1881;
    fail_assertion("non-positive loop bound");
    _jump1881:;
    _732 = 0;
    int64_t _734 = 0; // i
    _jump1882:; // Begin body of loop
    _732 += _183.d0;
    _734++;
    if (_734 < _733)
    goto _jump1882;
    // End body of loop
    if (_732 > 0) 
    goto _jump1883;
    fail_assertion("non-positive loop bound");
    _jump1883:;
    _731 = 0;
    int64_t _735 = 0; // j
    int64_t _736 = 0; // i
    _jump1884:; // Begin body of loop
    _731 += _721;
    _735++;
    if (_735 < _732)
    goto _jump1884;
    _735 = 0;
    _736++;
    if (_736 < _183.d0)
    goto _jump1884;
    // End body of loop
    if (_183.d0 >= 0)
    goto _jump1885;
    fail_assertion("negative array index");
    _jump1885:;
    if (_183.d0 < _723.d0)
    goto _jump1886;
    fail_assertion("index too large");
    _jump1886:;
    if (_731 >= 0)
    goto _jump1887;
    fail_assertion("negative array index");
    _jump1887:;
    if (_731 < _723.d1)
    goto _jump1888;
    fail_assertion("index too large");
    _jump1888:;
    int64_t _737 = 0;
    _737 *= _723.d0;
    _737 += _183.d0;
    _737 *= _723.d1;
    _737 += _731;
    int64_t _738 = _723.data[_737];
    _722.d1 = _738;
    if (_738 > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    // Computing bound for k
    int64_t _739;
    // Computing bound for i
    if (_721 > 0) 
    goto _jump1890;
    fail_assertion("non-positive loop bound");
    _jump1890:;
    // Computing bound for j
    int64_t _740 = -_183.d0;
    if (_740 > 0) 
    goto _jump1891;
    fail_assertion("non-positive loop bound");
    _jump1891:;
    // Computing bound for k
    int64_t _741 = -_721;
    if (_741 > 0) 
    goto _jump1892;
    fail_assertion("non-positive loop bound");
    _jump1892:;
    _739 = 0;
    int64_t _742 = 0; // k
    int64_t _743 = 0; // j
    int64_t _744 = 0; // i
    _jump1893:; // Begin body of loop
    int64_t _745 = _742 - _721;
    _739 += _745;
    _742++;
    if (_742 < _741)
    goto _jump1893;
    _742 = 0;
    _743++;
    if (_743 < _740)
    goto _jump1893;
    _743 = 0;
    _744++;
    if (_744 < _721)
    goto _jump1893;
    // End body of loop
    _722.d2 = _739;
    if (_739 > 0) 
    goto _jump1894;
    fail_assertion("non-positive loop bound");
    _jump1894:;
    // Computing total size of heap memory to allocate
    int64_t _746 = 1;
    _746 *= _721;
    _746 *= _738;
    _746 *= _739;
    _746 *= sizeof(_a3_int64_t);
    _722.data = jpl_alloc(_746);
    int64_t _747 = 0; // k
    int64_t _748 = 0; // j
    int64_t _749 = 0; // i
    _jump1895:; // Begin body of loop
    _a3_int64_t _750;
    // Computing bound for l
    int64_t _751;
    // Computing bound for l
    int64_t _752 = _721 * _747;
    if (_752 > 0) 
    goto _jump1896;
    fail_assertion("non-positive loop bound");
    _jump1896:;
    // Computing bound for m
    int64_t _753 = -_747;
    if (_753 > 0) 
    goto _jump1897;
    fail_assertion("non-positive loop bound");
    _jump1897:;
    // Computing bound for n
    bool _754 = false;
    int64_t _755;
    if (!_754)
    goto _jump1898;
    _755 = _747;
    goto _jump1899;
    _jump1898:;
    _755 = _747;
    _jump1899:;
    if (_755 > 0) 
    goto _jump1900;
    fail_assertion("non-positive loop bound");
    _jump1900:;
    _751 = 0;
    int64_t _756 = 0; // n
    int64_t _757 = 0; // m
    int64_t _758 = 0; // l
    _jump1901:; // Begin body of loop
    _751 += _748;
    _756++;
    if (_756 < _755)
    goto _jump1901;
    _756 = 0;
    _757++;
    if (_757 < _753)
    goto _jump1901;
    _757 = 0;
    _758++;
    if (_758 < _752)
    goto _jump1901;
    // End body of loop
    _750.d0 = _751;
    if (_751 > 0) 
    goto _jump1902;
    fail_assertion("non-positive loop bound");
    _jump1902:;
    // Computing bound for m
    int64_t _759 = 958;
    _750.d1 = _759;
    if (_759 > 0) 
    goto _jump1903;
    fail_assertion("non-positive loop bound");
    _jump1903:;
    // Computing bound for n
    int64_t _760 = _747 * _721;
    _750.d2 = _760;
    if (_760 > 0) 
    goto _jump1904;
    fail_assertion("non-positive loop bound");
    _jump1904:;
    // Computing total size of heap memory to allocate
    int64_t _761 = 1;
    _761 *= _751;
    _761 *= _759;
    _761 *= _760;
    _761 *= sizeof(int64_t);
    _750.data = jpl_alloc(_761);
    int64_t _762 = 0; // n
    int64_t _763 = 0; // m
    int64_t _764 = 0; // l
    _jump1905:; // Begin body of loop
    int64_t _765 = 0;
    _765 *= _750.d0;
    _765 += _764;
    _765 *= _750.d1;
    _765 += _763;
    _765 *= _750.d2;
    _765 += _762;
    _750.data[_765] = _763;
    _762++;
    if (_762 < _760)
    goto _jump1905;
    _762 = 0;
    _763++;
    if (_763 < _759)
    goto _jump1905;
    _763 = 0;
    _764++;
    if (_764 < _751)
    goto _jump1905;
    // End body of loop
    int64_t _766 = 0;
    _766 *= _722.d0;
    _766 += _749;
    _766 *= _722.d1;
    _766 += _748;
    _766 *= _722.d2;
    _766 += _747;
    _722.data[_766] = _750;
    _747++;
    if (_747 < _739)
    goto _jump1895;
    _747 = 0;
    _748++;
    if (_748 < _738)
    goto _jump1895;
    _748 = 0;
    _749++;
    if (_749 < _721)
    goto _jump1895;
    // End body of loop
    int64_t _767;
    // Computing bound for i
    _a3_int64_t _768;
    // Computing bound for i
    int64_t _769 = 500;
    _768.d0 = _769;
    if (_769 > 0) 
    goto _jump1906;
    fail_assertion("non-positive loop bound");
    _jump1906:;
    // Computing bound for j
    int64_t _770 = -_183.d0;
    _768.d1 = _770;
    if (_770 > 0) 
    goto _jump1907;
    fail_assertion("non-positive loop bound");
    _jump1907:;
    // Computing bound for k
    _768.d2 = _721;
    if (_721 > 0) 
    goto _jump1908;
    fail_assertion("non-positive loop bound");
    _jump1908:;
    // Computing total size of heap memory to allocate
    int64_t _771 = 1;
    _771 *= _769;
    _771 *= _770;
    _771 *= _721;
    _771 *= sizeof(int64_t);
    _768.data = jpl_alloc(_771);
    int64_t _772 = 0; // k
    int64_t _773 = 0; // j
    int64_t _774 = 0; // i
    _jump1909:; // Begin body of loop
    int64_t _775 = 0;
    _775 *= _768.d0;
    _775 += _774;
    _775 *= _768.d1;
    _775 += _773;
    _775 *= _768.d2;
    _775 += _772;
    _768.data[_775] = _721;
    _772++;
    if (_772 < _721)
    goto _jump1909;
    _772 = 0;
    _773++;
    if (_773 < _770)
    goto _jump1909;
    _773 = 0;
    _774++;
    if (_774 < _769)
    goto _jump1909;
    // End body of loop
    bool _776 = false;
    bool _777 = !_776;
    int64_t _778;
    if (!_777)
    goto _jump1910;
    _778 = _721;
    goto _jump1911;
    _jump1910:;
    _778 = _183.d0;
    _jump1911:;
    int64_t _779 = -_183.d0;
    if (_778 >= 0)
    goto _jump1912;
    fail_assertion("negative array index");
    _jump1912:;
    if (_778 < _768.d0)
    goto _jump1913;
    fail_assertion("index too large");
    _jump1913:;
    if (_779 >= 0)
    goto _jump1914;
    fail_assertion("negative array index");
    _jump1914:;
    if (_779 < _768.d1)
    goto _jump1915;
    fail_assertion("index too large");
    _jump1915:;
    if (_721 >= 0)
    goto _jump1916;
    fail_assertion("negative array index");
    _jump1916:;
    if (_721 < _768.d2)
    goto _jump1917;
    fail_assertion("index too large");
    _jump1917:;
    int64_t _780 = 0;
    _780 *= _768.d0;
    _780 += _778;
    _780 *= _768.d1;
    _780 += _779;
    _780 *= _768.d2;
    _780 += _721;
    int64_t _781 = _768.data[_780];
    if (_781 > 0) 
    goto _jump1918;
    fail_assertion("non-positive loop bound");
    _jump1918:;
    // Computing bound for j
    int64_t _782;
    // Computing bound for i
    if (_183.d0 > 0) 
    goto _jump1919;
    fail_assertion("non-positive loop bound");
    _jump1919:;
    _782 = 0;
    int64_t _783 = 0; // i
    _jump1920:; // Begin body of loop
    _782 += _183.d0;
    _783++;
    if (_783 < _183.d0)
    goto _jump1920;
    // End body of loop
    if (_782 > 0) 
    goto _jump1921;
    fail_assertion("non-positive loop bound");
    _jump1921:;
    _767 = 0;
    int64_t _784 = 0; // j
    int64_t _785 = 0; // i
    _jump1922:; // Begin body of loop
    _a2_int64_t _786;
    // Computing bound for k
    bool _787 = false;
    int64_t _788;
    if (!_787)
    goto _jump1923;
    _788 = _721;
    goto _jump1924;
    _jump1923:;
    _788 = _785;
    _jump1924:;
    _786.d0 = _788;
    if (_788 > 0) 
    goto _jump1925;
    fail_assertion("non-positive loop bound");
    _jump1925:;
    // Computing bound for l
    int64_t _789 = 753;
    _786.d1 = _789;
    if (_789 > 0) 
    goto _jump1926;
    fail_assertion("non-positive loop bound");
    _jump1926:;
    // Computing total size of heap memory to allocate
    int64_t _790 = 1;
    _790 *= _788;
    _790 *= _789;
    _790 *= sizeof(int64_t);
    _786.data = jpl_alloc(_790);
    int64_t _791 = 0; // l
    int64_t _792 = 0; // k
    _jump1927:; // Begin body of loop
    int64_t _793 = 0;
    _793 *= _786.d0;
    _793 += _792;
    _793 *= _786.d1;
    _793 += _791;
    _786.data[_793] = _791;
    _791++;
    if (_791 < _789)
    goto _jump1927;
    _791 = 0;
    _792++;
    if (_792 < _788)
    goto _jump1927;
    // End body of loop
    if (_784 >= 0)
    goto _jump1928;
    fail_assertion("negative array index");
    _jump1928:;
    if (_784 < _786.d0)
    goto _jump1929;
    fail_assertion("index too large");
    _jump1929:;
    if (_784 >= 0)
    goto _jump1930;
    fail_assertion("negative array index");
    _jump1930:;
    if (_784 < _786.d1)
    goto _jump1931;
    fail_assertion("index too large");
    _jump1931:;
    int64_t _794 = 0;
    _794 *= _786.d0;
    _794 += _784;
    _794 *= _786.d1;
    _794 += _784;
    int64_t _795 = _786.data[_794];
    _767 += _795;
    _784++;
    if (_784 < _782)
    goto _jump1922;
    _784 = 0;
    _785++;
    if (_785 < _781)
    goto _jump1922;
    // End body of loop
    int64_t _796 = -_721;
    int64_t _797 = _183.d0 * _796;
    bool _799 = false;
    bool _800 = !_799;
    bool _798 = _800;
    if (0 != _800)
    goto _jump1932;
    int64_t _801 = 257;
    bool _802 = _801 > _721;
    bool _803 = false;
    bool _804 = _802 != _803;
    _798 = _804;
    _jump1932:;
    int64_t _805;
    if (!_798)
    goto _jump1933;
    int64_t _806 = 782;
    _805 = _806;
    goto _jump1934;
    _jump1933:;
    int64_t _807;
    // Computing bound for i
    int64_t _808 = 559;
    _a1_int64_t _809;
    _809.d0 = 1;
    _809.data = jpl_alloc(sizeof(int64_t) * 1);
    _809.data[0] = _808;
    if (_183.d0 >= 0)
    goto _jump1935;
    fail_assertion("negative array index");
    _jump1935:;
    if (_183.d0 < _809.d0)
    goto _jump1936;
    fail_assertion("index too large");
    _jump1936:;
    int64_t _810 = 0;
    _810 *= _809.d0;
    _810 += _183.d0;
    int64_t _811 = _809.data[_810];
    if (_811 > 0) 
    goto _jump1937;
    fail_assertion("non-positive loop bound");
    _jump1937:;
    // Computing bound for j
    int64_t _812 = 380;
    if (_812 > 0) 
    goto _jump1938;
    fail_assertion("non-positive loop bound");
    _jump1938:;
    _807 = 0;
    int64_t _813 = 0; // j
    int64_t _814 = 0; // i
    _jump1939:; // Begin body of loop
    int64_t _815 = 686;
    _807 += _815;
    _813++;
    if (_813 < _812)
    goto _jump1939;
    _813 = 0;
    _814++;
    if (_814 < _811)
    goto _jump1939;
    // End body of loop
    _805 = _807;
    _jump1934:;
    if (_767 >= 0)
    goto _jump1940;
    fail_assertion("negative array index");
    _jump1940:;
    if (_767 < _722.d0)
    goto _jump1941;
    fail_assertion("index too large");
    _jump1941:;
    if (_797 >= 0)
    goto _jump1942;
    fail_assertion("negative array index");
    _jump1942:;
    if (_797 < _722.d1)
    goto _jump1943;
    fail_assertion("index too large");
    _jump1943:;
    if (_805 >= 0)
    goto _jump1944;
    fail_assertion("negative array index");
    _jump1944:;
    if (_805 < _722.d2)
    goto _jump1945;
    fail_assertion("index too large");
    _jump1945:;
    int64_t _816 = 0;
    _816 *= _722.d0;
    _816 += _767;
    _816 *= _722.d1;
    _816 += _797;
    _816 *= _722.d2;
    _816 += _805;
    _a3_int64_t _817 = _722.data[_816];
    int64_t _818 = 0;
    _818 *= _669.d0;
    _818 += _721;
    _669.data[_818] = _817;
    _721++;
    if (_721 < _678)
    goto _jump1875;
    // End body of loop
    bool _820 = true;
    bool _819 = _820;
    if (0 != _820)
    goto _jump1946;
    double _821 = 26.0;
    double _822 = 8.0;
    bool _823 = _821 == _822;
    double _824;
    if (!_823)
    goto _jump1947;
    double _825;
    // Computing bound for h
    if (_183.d0 > 0) 
    goto _jump1948;
    fail_assertion("non-positive loop bound");
    _jump1948:;
    _825 = 0;
    int64_t _826 = 0; // h
    _jump1949:; // Begin body of loop
    double _827 = 61.0;
    _825 += _827;
    _826++;
    if (_826 < _183.d0)
    goto _jump1949;
    // End body of loop
    _824 = _825;
    goto _jump1950;
    _jump1947:;
    double _828 = 68.0;
    double _829 = 31.0;
    double _830 = _828 + _829;
    _824 = _830;
    _jump1950:;
    double _831 = 38.0;
    double _832 = -_831;
    double _833 = -_832;
    double _834 = 55.0;
    double _835 = fmod(_833, _834);
    bool _836 = _824 == _835;
    _819 = _836;
    _jump1946:;
    int64_t _837;
    if (!_819)
    goto _jump1951;
    int64_t _838 = 149;
    _837 = _838;
    goto _jump1952;
    _jump1951:;
    int64_t _839;
    // Computing bound for h
    int64_t _840;
    // Computing bound for h
    int64_t _841;
    // Computing bound for h
    if (_183.d0 > 0) 
    goto _jump1953;
    fail_assertion("non-positive loop bound");
    _jump1953:;
    // Computing bound for i
    int64_t _842 = -_183.d0;
    if (_842 > 0) 
    goto _jump1954;
    fail_assertion("non-positive loop bound");
    _jump1954:;
    // Computing bound for j
    int64_t _843 = 62;
    int64_t _844 = -_843;
    if (_844 > 0) 
    goto _jump1955;
    fail_assertion("non-positive loop bound");
    _jump1955:;
    _841 = 0;
    int64_t _845 = 0; // j
    int64_t _846 = 0; // i
    int64_t _847 = 0; // h
    _jump1956:; // Begin body of loop
    int64_t _848 = 717;
    _841 += _848;
    _845++;
    if (_845 < _844)
    goto _jump1956;
    _845 = 0;
    _846++;
    if (_846 < _842)
    goto _jump1956;
    _846 = 0;
    _847++;
    if (_847 < _183.d0)
    goto _jump1956;
    // End body of loop
    int64_t _849 = _183.d0 / _841;
    if (_849 > 0) 
    goto _jump1957;
    fail_assertion("non-positive loop bound");
    _jump1957:;
    _840 = 0;
    int64_t _850 = 0; // h
    _jump1958:; // Begin body of loop
    _840 += _850;
    _850++;
    if (_850 < _849)
    goto _jump1958;
    // End body of loop
    if (_840 > 0) 
    goto _jump1959;
    fail_assertion("non-positive loop bound");
    _jump1959:;
    // Computing bound for i
    _a2_int64_t _851;
    // Computing bound for h
    _851.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump1960;
    fail_assertion("non-positive loop bound");
    _jump1960:;
    // Computing bound for i
    int64_t _852 = 377;
    _851.d1 = _852;
    if (_852 > 0) 
    goto _jump1961;
    fail_assertion("non-positive loop bound");
    _jump1961:;
    // Computing total size of heap memory to allocate
    int64_t _853 = 1;
    _853 *= _183.d0;
    _853 *= _852;
    _853 *= sizeof(int64_t);
    _851.data = jpl_alloc(_853);
    int64_t _854 = 0; // i
    int64_t _855 = 0; // h
    _jump1962:; // Begin body of loop
    int64_t _856 = 0;
    _856 *= _851.d0;
    _856 += _855;
    _856 *= _851.d1;
    _856 += _854;
    _851.data[_856] = _183.d0;
    _854++;
    if (_854 < _852)
    goto _jump1962;
    _854 = 0;
    _855++;
    if (_855 < _183.d0)
    goto _jump1962;
    // End body of loop
    int64_t _857 = 848;
    int64_t _858 = 850;
    if (_857 >= 0)
    goto _jump1963;
    fail_assertion("negative array index");
    _jump1963:;
    if (_857 < _851.d0)
    goto _jump1964;
    fail_assertion("index too large");
    _jump1964:;
    if (_858 >= 0)
    goto _jump1965;
    fail_assertion("negative array index");
    _jump1965:;
    if (_858 < _851.d1)
    goto _jump1966;
    fail_assertion("index too large");
    _jump1966:;
    int64_t _859 = 0;
    _859 *= _851.d0;
    _859 += _857;
    _859 *= _851.d1;
    _859 += _858;
    int64_t _860 = _851.data[_859];
    if (_860 >= 0)
    goto _jump1967;
    fail_assertion("negative array index");
    _jump1967:;
    if (_860 < _183.d0)
    goto _jump1968;
    fail_assertion("index too large");
    _jump1968:;
    int64_t _861 = 0;
    _861 *= _183.d0;
    _861 += _860;
    bool _862 = _183.data[_861];
    int64_t _863;
    if (!_862)
    goto _jump1969;
    int64_t _864 = 292;
    _863 = _864;
    goto _jump1970;
    _jump1969:;
    _863 = _183.d0;
    _jump1970:;
    if (_863 > 0) 
    goto _jump1971;
    fail_assertion("non-positive loop bound");
    _jump1971:;
    _839 = 0;
    int64_t _865 = 0; // i
    int64_t _866 = 0; // h
    _jump1972:; // Begin body of loop
    int64_t _867;
    // Computing bound for j
    if (_866 > 0) 
    goto _jump1973;
    fail_assertion("non-positive loop bound");
    _jump1973:;
    // Computing bound for k
    int64_t _868 = 193;
    if (_868 > 0) 
    goto _jump1974;
    fail_assertion("non-positive loop bound");
    _jump1974:;
    _867 = 0;
    int64_t _869 = 0; // k
    int64_t _870 = 0; // j
    _jump1975:; // Begin body of loop
    _867 += _183.d0;
    _869++;
    if (_869 < _868)
    goto _jump1975;
    _869 = 0;
    _870++;
    if (_870 < _866)
    goto _jump1975;
    // End body of loop
    int64_t _871 = _867 / _866;
    int64_t _872 = -_871;
    int64_t _873 = -_872;
    _839 += _873;
    _865++;
    if (_865 < _863)
    goto _jump1972;
    _865 = 0;
    _866++;
    if (_866 < _840)
    goto _jump1972;
    // End body of loop
    _837 = _839;
    _jump1952:;
    if (_837 >= 0)
    goto _jump1976;
    fail_assertion("negative array index");
    _jump1976:;
    if (_837 < _669.d0)
    goto _jump1977;
    fail_assertion("index too large");
    _jump1977:;
    int64_t _874 = 0;
    _874 *= _669.d0;
    _874 += _837;
    _a3_int64_t _875 = _669.data[_874];
    int64_t _876;
    // Computing bound for l
    int64_t _877 = 674;
    _a1_int64_t _878;
    _878.d0 = 1;
    _878.data = jpl_alloc(sizeof(int64_t) * 1);
    _878.data[0] = _877;
    if (_875.d0 >= 0)
    goto _jump1978;
    fail_assertion("negative array index");
    _jump1978:;
    if (_875.d0 < _878.d0)
    goto _jump1979;
    fail_assertion("index too large");
    _jump1979:;
    int64_t _879 = 0;
    _879 *= _878.d0;
    _879 += _875.d0;
    int64_t _880 = _878.data[_879];
    if (_880 > 0) 
    goto _jump1980;
    fail_assertion("non-positive loop bound");
    _jump1980:;
    _876 = 0;
    int64_t _881 = 0; // l
    _jump1981:; // Begin body of loop
    _a1_int64_t _882;
    _882.d0 = 2;
    _882.data = jpl_alloc(sizeof(int64_t) * 2);
    _882.data[0] = _875.d0;
    _882.data[1] = _875.d1;
    int64_t _883 = _881 + _183.d0;
    if (_883 >= 0)
    goto _jump1982;
    fail_assertion("negative array index");
    _jump1982:;
    if (_883 < _882.d0)
    goto _jump1983;
    fail_assertion("index too large");
    _jump1983:;
    int64_t _884 = 0;
    _884 *= _882.d0;
    _884 += _883;
    int64_t _885 = _882.data[_884];
    _876 += _885;
    _881++;
    if (_881 < _880)
    goto _jump1981;
    // End body of loop
    bool _886 = _875.d0 == _876;
    e _887;
    if (!_886)
    goto _jump1984;
    bool _888 = false;
    rgba _889;
    if (!_888)
    goto _jump1985;
    double _890;
    // Computing bound for l
    if (_875.d2 > 0) 
    goto _jump1986;
    fail_assertion("non-positive loop bound");
    _jump1986:;
    _890 = 0;
    int64_t _891 = 0; // l
    _jump1987:; // Begin body of loop
    double _892 = 69.0;
    _890 += _892;
    _891++;
    if (_891 < _875.d2)
    goto _jump1987;
    // End body of loop
    double _893 = 4.0;
    bool _894 = true;
    double _895;
    if (!_894)
    goto _jump1988;
    double _896 = 42.0;
    double _897 = -_896;
    _895 = _897;
    goto _jump1989;
    _jump1988:;
    double _898 = 78.0;
    _895 = _898;
    _jump1989:;
    double _899 = 35.0;
    double _900 = -_899;
    rgba _901 = { _890, _893, _895, _900 };
    _889 = _901;
    goto _jump1990;
    _jump1985:;
    double _902;
    // Computing bound for l
    if (_875.d2 > 0) 
    goto _jump1991;
    fail_assertion("non-positive loop bound");
    _jump1991:;
    // Computing bound for m
    int64_t _903;
    // Computing bound for l
    int64_t _904 = 871;
    if (_904 > 0) 
    goto _jump1992;
    fail_assertion("non-positive loop bound");
    _jump1992:;
    // Computing bound for m
    if (_875.d2 > 0) 
    goto _jump1993;
    fail_assertion("non-positive loop bound");
    _jump1993:;
    _903 = 0;
    int64_t _905 = 0; // m
    int64_t _906 = 0; // l
    _jump1994:; // Begin body of loop
    _903 += _875.d0;
    _905++;
    if (_905 < _875.d2)
    goto _jump1994;
    _905 = 0;
    _906++;
    if (_906 < _904)
    goto _jump1994;
    // End body of loop
    if (_903 > 0) 
    goto _jump1995;
    fail_assertion("non-positive loop bound");
    _jump1995:;
    _902 = 0;
    int64_t _907 = 0; // m
    int64_t _908 = 0; // l
    _jump1996:; // Begin body of loop
    double _909 = 59.0;
    double _910 = -_909;
    _902 += _910;
    _907++;
    if (_907 < _903)
    goto _jump1996;
    _907 = 0;
    _908++;
    if (_908 < _875.d2)
    goto _jump1996;
    // End body of loop
    double _911;
    // Computing bound for l
    int64_t _912 = -_875.d2;
    if (_912 > 0) 
    goto _jump1997;
    fail_assertion("non-positive loop bound");
    _jump1997:;
    // Computing bound for m
    bool _913 = false;
    int64_t _914;
    if (!_913)
    goto _jump1998;
    _914 = _875.d0;
    goto _jump1999;
    _jump1998:;
    int64_t _915 = 917;
    _914 = _915;
    _jump1999:;
    if (_914 > 0) 
    goto _jump2000;
    fail_assertion("non-positive loop bound");
    _jump2000:;
    // Computing bound for n
    if (_875.d2 > 0) 
    goto _jump2001;
    fail_assertion("non-positive loop bound");
    _jump2001:;
    _911 = 0;
    int64_t _916 = 0; // n
    int64_t _917 = 0; // m
    int64_t _918 = 0; // l
    _jump2002:; // Begin body of loop
    double _919 = 31.0;
    double _920 = -_919;
    _911 += _920;
    _916++;
    if (_916 < _875.d2)
    goto _jump2002;
    _916 = 0;
    _917++;
    if (_917 < _914)
    goto _jump2002;
    _917 = 0;
    _918++;
    if (_918 < _912)
    goto _jump2002;
    // End body of loop
    bool _921 = true;
    double _922;
    if (!_921)
    goto _jump2003;
    double _923 = 54.0;
    _922 = _923;
    goto _jump2004;
    _jump2003:;
    double _924 = 97.0;
    _922 = _924;
    _jump2004:;
    double _925 = -_922;
    double _926 = 76.0;
    rgba _927 = { _902, _911, _925, _926 };
    _889 = _927;
    _jump1990:;
    e _928 = { _889 };
    _887 = _928;
    goto _jump2005;
    _jump1984:;
    int64_t _929 = _183.d0 / _875.d0;
    if (_929 >= 0)
    goto _jump2006;
    fail_assertion("negative array index");
    _jump2006:;
    if (_929 < _668.d0)
    goto _jump2007;
    fail_assertion("index too large");
    _jump2007:;
    if (_875.d0 >= 0)
    goto _jump2008;
    fail_assertion("negative array index");
    _jump2008:;
    if (_875.d0 < _668.d1)
    goto _jump2009;
    fail_assertion("index too large");
    _jump2009:;
    int64_t _930 = 0;
    _930 *= _668.d0;
    _930 += _929;
    _930 *= _668.d1;
    _930 += _875.d0;
    rgba _931 = _668.data[_930];
    double _932 = _931.g;
    double _933;
    // Computing bound for l
    int64_t _934 = 122;
    if (_183.d0 >= 0)
    goto _jump2010;
    fail_assertion("negative array index");
    _jump2010:;
    if (_183.d0 < _875.d0)
    goto _jump2011;
    fail_assertion("index too large");
    _jump2011:;
    if (_934 >= 0)
    goto _jump2012;
    fail_assertion("negative array index");
    _jump2012:;
    if (_934 < _875.d1)
    goto _jump2013;
    fail_assertion("index too large");
    _jump2013:;
    if (_875.d2 >= 0)
    goto _jump2014;
    fail_assertion("negative array index");
    _jump2014:;
    if (_875.d2 < _875.d2)
    goto _jump2015;
    fail_assertion("index too large");
    _jump2015:;
    int64_t _935 = 0;
    _935 *= _875.d0;
    _935 += _183.d0;
    _935 *= _875.d1;
    _935 += _934;
    _935 *= _875.d2;
    _935 += _875.d2;
    int64_t _936 = _875.data[_935];
    int64_t _937 = _183.d0 - _936;
    if (_937 > 0) 
    goto _jump2016;
    fail_assertion("non-positive loop bound");
    _jump2016:;
    _933 = 0;
    int64_t _938 = 0; // l
    _jump2017:; // Begin body of loop
    double _939 = 29.0;
    double _940 = -_939;
    double _941 = -_940;
    _933 += _941;
    _938++;
    if (_938 < _937)
    goto _jump2017;
    // End body of loop
    double _942 = 65.0;
    double _943 = -_942;
    bool _944 = true;
    _a2_rgba _945;
    if (!_944)
    goto _jump2018;
    _945 = _668;
    goto _jump2019;
    _jump2018:;
    _945 = _668;
    _jump2019:;
    int64_t _946 = 259;
    if (_875.d1 >= 0)
    goto _jump2020;
    fail_assertion("negative array index");
    _jump2020:;
    if (_875.d1 < _945.d0)
    goto _jump2021;
    fail_assertion("index too large");
    _jump2021:;
    if (_946 >= 0)
    goto _jump2022;
    fail_assertion("negative array index");
    _jump2022:;
    if (_946 < _945.d1)
    goto _jump2023;
    fail_assertion("index too large");
    _jump2023:;
    int64_t _947 = 0;
    _947 *= _945.d0;
    _947 += _875.d1;
    _947 *= _945.d1;
    _947 += _946;
    rgba _948 = _945.data[_947];
    double _949 = _948.r;
    rgba _950 = { _932, _933, _943, _949 };
    e _951 = { _950 };
    _887 = _951;
    _jump2005:;
    rgba _952 = _887.a;
    show("(TupleType (FloatType) (FloatType) (FloatType) (FloatType))", &_952);
    double _953 = 33.0;
    double _954 = -_953;
    _a3__a2__a1_bool _955;
    // Computing bound for p
    _a3__a1_int64_t _956;
    // Computing bound for p
    _956.d0 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2169;
    fail_assertion("non-positive loop bound");
    _jump2169:;
    // Computing bound for q
    _956.d1 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2170;
    fail_assertion("non-positive loop bound");
    _jump2170:;
    // Computing bound for r
    int64_t _957 = _875.d1 * _183.d0;
    _956.d2 = _957;
    if (_957 > 0) 
    goto _jump2171;
    fail_assertion("non-positive loop bound");
    _jump2171:;
    // Computing total size of heap memory to allocate
    int64_t _958 = 1;
    _958 *= _875.d2;
    _958 *= _875.d0;
    _958 *= _957;
    _958 *= sizeof(_a1_int64_t);
    _956.data = jpl_alloc(_958);
    int64_t _959 = 0; // r
    int64_t _960 = 0; // q
    int64_t _961 = 0; // p
    _jump2172:; // Begin body of loop
    bool _962 = false;
    _a1_int64_t _963;
    if (!_962)
    goto _jump2173;
    int64_t _964 = 789;
    _a1_int64_t _965;
    _965.d0 = 3;
    _965.data = jpl_alloc(sizeof(int64_t) * 3);
    _965.data[0] = _961;
    _965.data[1] = _964;
    _965.data[2] = _959;
    _963 = _965;
    goto _jump2174;
    _jump2173:;
    _a1_int64_t _966;
    _966.d0 = 3;
    _966.data = jpl_alloc(sizeof(int64_t) * 3);
    _966.data[0] = _183.d0;
    _966.data[1] = _183.d0;
    _966.data[2] = _183.d0;
    _963 = _966;
    _jump2174:;
    int64_t _967 = 0;
    _967 *= _956.d0;
    _967 += _961;
    _967 *= _956.d1;
    _967 += _960;
    _967 *= _956.d2;
    _967 += _959;
    _956.data[_967] = _963;
    _959++;
    if (_959 < _957)
    goto _jump2172;
    _959 = 0;
    _960++;
    if (_960 < _875.d0)
    goto _jump2172;
    _960 = 0;
    _961++;
    if (_961 < _875.d2)
    goto _jump2172;
    // End body of loop
    int64_t _968 = 910;
    int64_t _969;
    // Computing bound for p
    int64_t _970;
    // Computing bound for p
    if (_875.d1 > 0) 
    goto _jump2175;
    fail_assertion("non-positive loop bound");
    _jump2175:;
    // Computing bound for q
    if (_875.d0 > 0) 
    goto _jump2176;
    fail_assertion("non-positive loop bound");
    _jump2176:;
    // Computing bound for r
    if (_183.d0 > 0) 
    goto _jump2177;
    fail_assertion("non-positive loop bound");
    _jump2177:;
    _970 = 0;
    int64_t _971 = 0; // r
    int64_t _972 = 0; // q
    int64_t _973 = 0; // p
    _jump2178:; // Begin body of loop
    _970 += _973;
    _971++;
    if (_971 < _183.d0)
    goto _jump2178;
    _971 = 0;
    _972++;
    if (_972 < _875.d0)
    goto _jump2178;
    _972 = 0;
    _973++;
    if (_973 < _875.d1)
    goto _jump2178;
    // End body of loop
    if (_970 > 0) 
    goto _jump2179;
    fail_assertion("non-positive loop bound");
    _jump2179:;
    _969 = 0;
    int64_t _974 = 0; // p
    _jump2180:; // Begin body of loop
    int64_t _975;
    // Computing bound for q
    if (_183.d0 > 0) 
    goto _jump2181;
    fail_assertion("non-positive loop bound");
    _jump2181:;
    // Computing bound for r
    if (_183.d0 > 0) 
    goto _jump2182;
    fail_assertion("non-positive loop bound");
    _jump2182:;
    _975 = 0;
    int64_t _976 = 0; // r
    int64_t _977 = 0; // q
    _jump2183:; // Begin body of loop
    _975 += _875.d2;
    _976++;
    if (_976 < _183.d0)
    goto _jump2183;
    _976 = 0;
    _977++;
    if (_977 < _183.d0)
    goto _jump2183;
    // End body of loop
    _969 += _975;
    _974++;
    if (_974 < _970)
    goto _jump2180;
    // End body of loop
    int64_t _978 = _968 - _969;
    int64_t _979 = 324;
    int64_t _980 = -_979;
    if (_978 >= 0)
    goto _jump2184;
    fail_assertion("negative array index");
    _jump2184:;
    if (_978 < _956.d0)
    goto _jump2185;
    fail_assertion("index too large");
    _jump2185:;
    if (_980 >= 0)
    goto _jump2186;
    fail_assertion("negative array index");
    _jump2186:;
    if (_980 < _956.d1)
    goto _jump2187;
    fail_assertion("index too large");
    _jump2187:;
    if (_183.d0 >= 0)
    goto _jump2188;
    fail_assertion("negative array index");
    _jump2188:;
    if (_183.d0 < _956.d2)
    goto _jump2189;
    fail_assertion("index too large");
    _jump2189:;
    int64_t _981 = 0;
    _981 *= _956.d0;
    _981 += _978;
    _981 *= _956.d1;
    _981 += _980;
    _981 *= _956.d2;
    _981 += _183.d0;
    _a1_int64_t _982 = _956.data[_981];
    int64_t _983 = -_183.d0;
    int64_t _984 = _875.d0 + _983;
    int64_t _985 = -_984;
    if (_985 >= 0)
    goto _jump2190;
    fail_assertion("negative array index");
    _jump2190:;
    if (_985 < _982.d0)
    goto _jump2191;
    fail_assertion("index too large");
    _jump2191:;
    int64_t _986 = 0;
    _986 *= _982.d0;
    _986 += _985;
    int64_t _987 = _982.data[_986];
    _955.d0 = _987;
    if (_987 > 0) 
    goto _jump2192;
    fail_assertion("non-positive loop bound");
    _jump2192:;
    // Computing bound for q
    int64_t _988 = -_875.d1;
    int64_t _989 = -_988;
    int64_t _990 = _183.d0 % _989;
    int64_t _991 = -_990;
    _955.d1 = _991;
    if (_991 > 0) 
    goto _jump2193;
    fail_assertion("non-positive loop bound");
    _jump2193:;
    // Computing bound for r
    _955.d2 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2194;
    fail_assertion("non-positive loop bound");
    _jump2194:;
    // Computing total size of heap memory to allocate
    int64_t _992 = 1;
    _992 *= _987;
    _992 *= _991;
    _992 *= _875.d0;
    _992 *= sizeof(_a2__a1_bool);
    _955.data = jpl_alloc(_992);
    int64_t _993 = 0; // r
    int64_t _994 = 0; // q
    int64_t _995 = 0; // p
    _jump2195:; // Begin body of loop
    bool _997 = _875.d0 != _875.d2;
    bool _996 = _997;
    if (0 != _997)
    goto _jump2196;
    bool _998 = _994 < _875.d2;
    _996 = _998;
    _jump2196:;
    _a2__a1_bool _999;
    if (!_996)
    goto _jump2197;
    _a2__a1_bool _1000;
    // Computing bound for s
    _1000.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2198;
    fail_assertion("non-positive loop bound");
    _jump2198:;
    // Computing bound for t
    _1000.d1 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2199;
    fail_assertion("non-positive loop bound");
    _jump2199:;
    // Computing total size of heap memory to allocate
    int64_t _1001 = 1;
    _1001 *= _183.d0;
    _1001 *= _875.d0;
    _1001 *= sizeof(_a1_bool);
    _1000.data = jpl_alloc(_1001);
    int64_t _1002 = 0; // t
    int64_t _1003 = 0; // s
    _jump2200:; // Begin body of loop
    int64_t _1004 = 0;
    _1004 *= _1000.d0;
    _1004 += _1003;
    _1004 *= _1000.d1;
    _1004 += _1002;
    _1000.data[_1004] = _183;
    _1002++;
    if (_1002 < _875.d0)
    goto _jump2200;
    _1002 = 0;
    _1003++;
    if (_1003 < _183.d0)
    goto _jump2200;
    // End body of loop
    _999 = _1000;
    goto _jump2201;
    _jump2197:;
    _a2__a2__a1_bool _1005;
    // Computing bound for s
    bool _1006 = true;
    int64_t _1007;
    if (!_1006)
    goto _jump2202;
    _1007 = _995;
    goto _jump2203;
    _jump2202:;
    int64_t _1008;
    // Computing bound for s
    if (_994 > 0) 
    goto _jump2204;
    fail_assertion("non-positive loop bound");
    _jump2204:;
    // Computing bound for t
    if (_993 > 0) 
    goto _jump2205;
    fail_assertion("non-positive loop bound");
    _jump2205:;
    // Computing bound for u
    int64_t _1009 = 77;
    if (_1009 > 0) 
    goto _jump2206;
    fail_assertion("non-positive loop bound");
    _jump2206:;
    _1008 = 0;
    int64_t _1010 = 0; // u
    int64_t _1011 = 0; // t
    int64_t _1012 = 0; // s
    _jump2207:; // Begin body of loop
    _1008 += _995;
    _1010++;
    if (_1010 < _1009)
    goto _jump2207;
    _1010 = 0;
    _1011++;
    if (_1011 < _993)
    goto _jump2207;
    _1011 = 0;
    _1012++;
    if (_1012 < _994)
    goto _jump2207;
    // End body of loop
    _1007 = _1008;
    _jump2203:;
    _1005.d0 = _1007;
    if (_1007 > 0) 
    goto _jump2208;
    fail_assertion("non-positive loop bound");
    _jump2208:;
    // Computing bound for t
    _1005.d1 = _994;
    if (_994 > 0) 
    goto _jump2209;
    fail_assertion("non-positive loop bound");
    _jump2209:;
    // Computing total size of heap memory to allocate
    int64_t _1013 = 1;
    _1013 *= _1007;
    _1013 *= _994;
    _1013 *= sizeof(_a2__a1_bool);
    _1005.data = jpl_alloc(_1013);
    int64_t _1014 = 0; // t
    int64_t _1015 = 0; // s
    _jump2210:; // Begin body of loop
    bool _1016 = false;
    _a2__a1_bool _1017;
    if (!_1016)
    goto _jump2211;
    _a2__a1_bool _1018;
    // Computing bound for u
    _1018.d0 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2212;
    fail_assertion("non-positive loop bound");
    _jump2212:;
    // Computing bound for v
    _1018.d1 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2213;
    fail_assertion("non-positive loop bound");
    _jump2213:;
    // Computing total size of heap memory to allocate
    int64_t _1019 = 1;
    _1019 *= _875.d0;
    _1019 *= _875.d0;
    _1019 *= sizeof(_a1_bool);
    _1018.data = jpl_alloc(_1019);
    int64_t _1020 = 0; // v
    int64_t _1021 = 0; // u
    _jump2214:; // Begin body of loop
    int64_t _1022 = 0;
    _1022 *= _1018.d0;
    _1022 += _1021;
    _1022 *= _1018.d1;
    _1022 += _1020;
    _1018.data[_1022] = _183;
    _1020++;
    if (_1020 < _875.d0)
    goto _jump2214;
    _1020 = 0;
    _1021++;
    if (_1021 < _875.d0)
    goto _jump2214;
    // End body of loop
    _1017 = _1018;
    goto _jump2215;
    _jump2211:;
    _a2__a1_bool _1023;
    // Computing bound for u
    _1023.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2216;
    fail_assertion("non-positive loop bound");
    _jump2216:;
    // Computing bound for v
    _1023.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2217;
    fail_assertion("non-positive loop bound");
    _jump2217:;
    // Computing total size of heap memory to allocate
    int64_t _1024 = 1;
    _1024 *= _183.d0;
    _1024 *= _183.d0;
    _1024 *= sizeof(_a1_bool);
    _1023.data = jpl_alloc(_1024);
    int64_t _1025 = 0; // v
    int64_t _1026 = 0; // u
    _jump2218:; // Begin body of loop
    int64_t _1027 = 0;
    _1027 *= _1023.d0;
    _1027 += _1026;
    _1027 *= _1023.d1;
    _1027 += _1025;
    _1023.data[_1027] = _183;
    _1025++;
    if (_1025 < _183.d0)
    goto _jump2218;
    _1025 = 0;
    _1026++;
    if (_1026 < _183.d0)
    goto _jump2218;
    // End body of loop
    _1017 = _1023;
    _jump2215:;
    int64_t _1028 = 0;
    _1028 *= _1005.d0;
    _1028 += _1015;
    _1028 *= _1005.d1;
    _1028 += _1014;
    _1005.data[_1028] = _1017;
    _1014++;
    if (_1014 < _994)
    goto _jump2210;
    _1014 = 0;
    _1015++;
    if (_1015 < _1007)
    goto _jump2210;
    // End body of loop
    if (_875.d0 >= 0)
    goto _jump2219;
    fail_assertion("negative array index");
    _jump2219:;
    if (_875.d0 < _1005.d0)
    goto _jump2220;
    fail_assertion("index too large");
    _jump2220:;
    if (_875.d2 >= 0)
    goto _jump2221;
    fail_assertion("negative array index");
    _jump2221:;
    if (_875.d2 < _1005.d1)
    goto _jump2222;
    fail_assertion("index too large");
    _jump2222:;
    int64_t _1029 = 0;
    _1029 *= _1005.d0;
    _1029 += _875.d0;
    _1029 *= _1005.d1;
    _1029 += _875.d2;
    _a2__a1_bool _1030 = _1005.data[_1029];
    _999 = _1030;
    _jump2201:;
    int64_t _1031 = 0;
    _1031 *= _955.d0;
    _1031 += _995;
    _1031 *= _955.d1;
    _1031 += _994;
    _1031 *= _955.d2;
    _1031 += _993;
    _955.data[_1031] = _999;
    _993++;
    if (_993 < _875.d0)
    goto _jump2195;
    _993 = 0;
    _994++;
    if (_994 < _991)
    goto _jump2195;
    _994 = 0;
    _995++;
    if (_995 < _987)
    goto _jump2195;
    // End body of loop
    int64_t _1032 = 636;
    if (_875.d0 >= 0)
    goto _jump2223;
    fail_assertion("negative array index");
    _jump2223:;
    if (_875.d0 < _955.d0)
    goto _jump2224;
    fail_assertion("index too large");
    _jump2224:;
    if (_1032 >= 0)
    goto _jump2225;
    fail_assertion("negative array index");
    _jump2225:;
    if (_1032 < _955.d1)
    goto _jump2226;
    fail_assertion("index too large");
    _jump2226:;
    if (_183.d0 >= 0)
    goto _jump2227;
    fail_assertion("negative array index");
    _jump2227:;
    if (_183.d0 < _955.d2)
    goto _jump2228;
    fail_assertion("index too large");
    _jump2228:;
    int64_t _1033 = 0;
    _1033 *= _955.d0;
    _1033 += _875.d0;
    _1033 *= _955.d1;
    _1033 += _1032;
    _1033 *= _955.d2;
    _1033 += _183.d0;
    _a2__a1_bool _1034 = _955.data[_1033];
    show("(IntType)", &_183.d0);
    _a3__a3__a3_int64_t _1035;
    // Computing bound for s
    int64_t _1036 = 814;
    _1035.d0 = _1036;
    if (_1036 > 0) 
    goto _jump2229;
    fail_assertion("non-positive loop bound");
    _jump2229:;
    // Computing bound for t
    int64_t _1037 = 150;
    _1035.d1 = _1037;
    if (_1037 > 0) 
    goto _jump2230;
    fail_assertion("non-positive loop bound");
    _jump2230:;
    // Computing bound for u
    int64_t _1038 = -_1034.d0;
    _1035.d2 = _1038;
    if (_1038 > 0) 
    goto _jump2231;
    fail_assertion("non-positive loop bound");
    _jump2231:;
    // Computing total size of heap memory to allocate
    int64_t _1039 = 1;
    _1039 *= _1036;
    _1039 *= _1037;
    _1039 *= _1038;
    _1039 *= sizeof(_a3__a3_int64_t);
    _1035.data = jpl_alloc(_1039);
    int64_t _1040 = 0; // u
    int64_t _1041 = 0; // t
    int64_t _1042 = 0; // s
    _jump2232:; // Begin body of loop
    bool _1043 = _954 > _954;
    bool _1044 = !_1043;
    bool _1045 = _183.d0 >= _1034.d0;
    bool _1046;
    if (!_1045)
    goto _jump2233;
    bool _1047 = false;
    _1046 = _1047;
    goto _jump2234;
    _jump2233:;
    bool _1048 = true;
    _1046 = _1048;
    _jump2234:;
    bool _1049 = _1044 == _1046;
    _a3__a3_int64_t _1050;
    if (!_1049)
    goto _jump2235;
    _a3__a3_int64_t _1051;
    // Computing bound for v
    _a2_int64_t _1052;
    // Computing bound for v
    _1052.d0 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2236;
    fail_assertion("non-positive loop bound");
    _jump2236:;
    // Computing bound for w
    _1052.d1 = _1040;
    if (_1040 > 0) 
    goto _jump2237;
    fail_assertion("non-positive loop bound");
    _jump2237:;
    // Computing total size of heap memory to allocate
    int64_t _1053 = 1;
    _1053 *= _875.d2;
    _1053 *= _1040;
    _1053 *= sizeof(int64_t);
    _1052.data = jpl_alloc(_1053);
    int64_t _1054 = 0; // w
    int64_t _1055 = 0; // v
    _jump2238:; // Begin body of loop
    int64_t _1056 = 0;
    _1056 *= _1052.d0;
    _1056 += _1055;
    _1056 *= _1052.d1;
    _1056 += _1054;
    _1052.data[_1056] = _183.d0;
    _1054++;
    if (_1054 < _1040)
    goto _jump2238;
    _1054 = 0;
    _1055++;
    if (_1055 < _875.d2)
    goto _jump2238;
    // End body of loop
    int64_t _1057;
    // Computing bound for v
    if (_1041 > 0) 
    goto _jump2239;
    fail_assertion("non-positive loop bound");
    _jump2239:;
    // Computing bound for w
    int64_t _1058 = 429;
    if (_1058 > 0) 
    goto _jump2240;
    fail_assertion("non-positive loop bound");
    _jump2240:;
    // Computing bound for x
    int64_t _1059 = 423;
    if (_1059 > 0) 
    goto _jump2241;
    fail_assertion("non-positive loop bound");
    _jump2241:;
    _1057 = 0;
    int64_t _1060 = 0; // x
    int64_t _1061 = 0; // w
    int64_t _1062 = 0; // v
    _jump2242:; // Begin body of loop
    _1057 += _1034.d1;
    _1060++;
    if (_1060 < _1059)
    goto _jump2242;
    _1060 = 0;
    _1061++;
    if (_1061 < _1058)
    goto _jump2242;
    _1061 = 0;
    _1062++;
    if (_1062 < _1041)
    goto _jump2242;
    // End body of loop
    int64_t _1063 = 768;
    if (_1057 >= 0)
    goto _jump2243;
    fail_assertion("negative array index");
    _jump2243:;
    if (_1057 < _1052.d0)
    goto _jump2244;
    fail_assertion("index too large");
    _jump2244:;
    if (_1063 >= 0)
    goto _jump2245;
    fail_assertion("negative array index");
    _jump2245:;
    if (_1063 < _1052.d1)
    goto _jump2246;
    fail_assertion("index too large");
    _jump2246:;
    int64_t _1064 = 0;
    _1064 *= _1052.d0;
    _1064 += _1057;
    _1064 *= _1052.d1;
    _1064 += _1063;
    int64_t _1065 = _1052.data[_1064];
    _1051.d0 = _1065;
    if (_1065 > 0) 
    goto _jump2247;
    fail_assertion("non-positive loop bound");
    _jump2247:;
    // Computing bound for w
    _1051.d1 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2248;
    fail_assertion("non-positive loop bound");
    _jump2248:;
    // Computing bound for x
    int64_t _1066;
    // Computing bound for v
    if (_1034.d1 > 0) 
    goto _jump2249;
    fail_assertion("non-positive loop bound");
    _jump2249:;
    // Computing bound for w
    if (_1034.d0 > 0) 
    goto _jump2250;
    fail_assertion("non-positive loop bound");
    _jump2250:;
    _1066 = 0;
    int64_t _1067 = 0; // w
    int64_t _1068 = 0; // v
    _jump2251:; // Begin body of loop
    int64_t _1069 = -_1040;
    _1066 += _1069;
    _1067++;
    if (_1067 < _1034.d0)
    goto _jump2251;
    _1067 = 0;
    _1068++;
    if (_1068 < _1034.d1)
    goto _jump2251;
    // End body of loop
    _1051.d2 = _1066;
    if (_1066 > 0) 
    goto _jump2252;
    fail_assertion("non-positive loop bound");
    _jump2252:;
    // Computing total size of heap memory to allocate
    int64_t _1070 = 1;
    _1070 *= _1065;
    _1070 *= _875.d2;
    _1070 *= _1066;
    _1070 *= sizeof(_a3_int64_t);
    _1051.data = jpl_alloc(_1070);
    int64_t _1071 = 0; // x
    int64_t _1072 = 0; // w
    int64_t _1073 = 0; // v
    _jump2253:; // Begin body of loop
    _a3__a3_int64_t _1074;
    // Computing bound for y
    _1074.d0 = _875.d1;
    if (_875.d1 > 0) 
    goto _jump2254;
    fail_assertion("non-positive loop bound");
    _jump2254:;
    // Computing bound for z
    _1074.d1 = _1040;
    if (_1040 > 0) 
    goto _jump2255;
    fail_assertion("non-positive loop bound");
    _jump2255:;
    // Computing bound for A
    _1074.d2 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2256;
    fail_assertion("non-positive loop bound");
    _jump2256:;
    // Computing total size of heap memory to allocate
    int64_t _1075 = 1;
    _1075 *= _875.d1;
    _1075 *= _1040;
    _1075 *= _875.d2;
    _1075 *= sizeof(_a3_int64_t);
    _1074.data = jpl_alloc(_1075);
    int64_t _1076 = 0; // A
    int64_t _1077 = 0; // z
    int64_t _1078 = 0; // y
    _jump2257:; // Begin body of loop
    int64_t _1079 = 0;
    _1079 *= _1074.d0;
    _1079 += _1078;
    _1079 *= _1074.d1;
    _1079 += _1077;
    _1079 *= _1074.d2;
    _1079 += _1076;
    _1074.data[_1079] = _875;
    _1076++;
    if (_1076 < _875.d2)
    goto _jump2257;
    _1076 = 0;
    _1077++;
    if (_1077 < _1040)
    goto _jump2257;
    _1077 = 0;
    _1078++;
    if (_1078 < _875.d1)
    goto _jump2257;
    // End body of loop
    bool _1080 = true;
    int64_t _1081;
    if (!_1080)
    goto _jump2258;
    _1081 = _1071;
    goto _jump2259;
    _jump2258:;
    _1081 = _1072;
    _jump2259:;
    if (_1081 >= 0)
    goto _jump2260;
    fail_assertion("negative array index");
    _jump2260:;
    if (_1081 < _1074.d0)
    goto _jump2261;
    fail_assertion("index too large");
    _jump2261:;
    if (_875.d2 >= 0)
    goto _jump2262;
    fail_assertion("negative array index");
    _jump2262:;
    if (_875.d2 < _1074.d1)
    goto _jump2263;
    fail_assertion("index too large");
    _jump2263:;
    if (_1042 >= 0)
    goto _jump2264;
    fail_assertion("negative array index");
    _jump2264:;
    if (_1042 < _1074.d2)
    goto _jump2265;
    fail_assertion("index too large");
    _jump2265:;
    int64_t _1082 = 0;
    _1082 *= _1074.d0;
    _1082 += _1081;
    _1082 *= _1074.d1;
    _1082 += _875.d2;
    _1082 *= _1074.d2;
    _1082 += _1042;
    _a3_int64_t _1083 = _1074.data[_1082];
    int64_t _1084 = 0;
    _1084 *= _1051.d0;
    _1084 += _1073;
    _1084 *= _1051.d1;
    _1084 += _1072;
    _1084 *= _1051.d2;
    _1084 += _1071;
    _1051.data[_1084] = _1083;
    _1071++;
    if (_1071 < _1066)
    goto _jump2253;
    _1071 = 0;
    _1072++;
    if (_1072 < _875.d2)
    goto _jump2253;
    _1072 = 0;
    _1073++;
    if (_1073 < _1065)
    goto _jump2253;
    // End body of loop
    _1050 = _1051;
    goto _jump2266;
    _jump2235:;
    _a3__a3__a3_int64_t _1085;
    // Computing bound for v
    _1085.d0 = _1040;
    if (_1040 > 0) 
    goto _jump2267;
    fail_assertion("non-positive loop bound");
    _jump2267:;
    // Computing bound for w
    _1085.d1 = _1042;
    if (_1042 > 0) 
    goto _jump2268;
    fail_assertion("non-positive loop bound");
    _jump2268:;
    // Computing bound for x
    int64_t _1086;
    // Computing bound for v
    int64_t _1087 = 727;
    if (_1087 > 0) 
    goto _jump2269;
    fail_assertion("non-positive loop bound");
    _jump2269:;
    // Computing bound for w
    int64_t _1088 = 181;
    if (_1088 > 0) 
    goto _jump2270;
    fail_assertion("non-positive loop bound");
    _jump2270:;
    // Computing bound for x
    int64_t _1089 = 764;
    if (_1089 > 0) 
    goto _jump2271;
    fail_assertion("non-positive loop bound");
    _jump2271:;
    _1086 = 0;
    int64_t _1090 = 0; // x
    int64_t _1091 = 0; // w
    int64_t _1092 = 0; // v
    _jump2272:; // Begin body of loop
    _1086 += _1092;
    _1090++;
    if (_1090 < _1089)
    goto _jump2272;
    _1090 = 0;
    _1091++;
    if (_1091 < _1088)
    goto _jump2272;
    _1091 = 0;
    _1092++;
    if (_1092 < _1087)
    goto _jump2272;
    // End body of loop
    _1085.d2 = _1086;
    if (_1086 > 0) 
    goto _jump2273;
    fail_assertion("non-positive loop bound");
    _jump2273:;
    // Computing total size of heap memory to allocate
    int64_t _1093 = 1;
    _1093 *= _1040;
    _1093 *= _1042;
    _1093 *= _1086;
    _1093 *= sizeof(_a3__a3_int64_t);
    _1085.data = jpl_alloc(_1093);
    int64_t _1094 = 0; // x
    int64_t _1095 = 0; // w
    int64_t _1096 = 0; // v
    _jump2274:; // Begin body of loop
    _a3__a3_int64_t _1097;
    // Computing bound for y
    int64_t _1098 = 717;
    _1097.d0 = _1098;
    if (_1098 > 0) 
    goto _jump2275;
    fail_assertion("non-positive loop bound");
    _jump2275:;
    // Computing bound for z
    _1097.d1 = _1096;
    if (_1096 > 0) 
    goto _jump2276;
    fail_assertion("non-positive loop bound");
    _jump2276:;
    // Computing bound for A
    _1097.d2 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2277;
    fail_assertion("non-positive loop bound");
    _jump2277:;
    // Computing total size of heap memory to allocate
    int64_t _1099 = 1;
    _1099 *= _1098;
    _1099 *= _1096;
    _1099 *= _1034.d0;
    _1099 *= sizeof(_a3_int64_t);
    _1097.data = jpl_alloc(_1099);
    int64_t _1100 = 0; // A
    int64_t _1101 = 0; // z
    int64_t _1102 = 0; // y
    _jump2278:; // Begin body of loop
    int64_t _1103 = 0;
    _1103 *= _1097.d0;
    _1103 += _1102;
    _1103 *= _1097.d1;
    _1103 += _1101;
    _1103 *= _1097.d2;
    _1103 += _1100;
    _1097.data[_1103] = _875;
    _1100++;
    if (_1100 < _1034.d0)
    goto _jump2278;
    _1100 = 0;
    _1101++;
    if (_1101 < _1096)
    goto _jump2278;
    _1101 = 0;
    _1102++;
    if (_1102 < _1098)
    goto _jump2278;
    // End body of loop
    int64_t _1104 = 0;
    _1104 *= _1085.d0;
    _1104 += _1096;
    _1104 *= _1085.d1;
    _1104 += _1095;
    _1104 *= _1085.d2;
    _1104 += _1094;
    _1085.data[_1104] = _1097;
    _1094++;
    if (_1094 < _1086)
    goto _jump2274;
    _1094 = 0;
    _1095++;
    if (_1095 < _1042)
    goto _jump2274;
    _1095 = 0;
    _1096++;
    if (_1096 < _1040)
    goto _jump2274;
    // End body of loop
    int64_t _1105;
    // Computing bound for v
    bool _1106 = false;
    int64_t _1107;
    if (!_1106)
    goto _jump2279;
    _1107 = _875.d0;
    goto _jump2280;
    _jump2279:;
    int64_t _1108 = 900;
    _1107 = _1108;
    _jump2280:;
    if (_1107 > 0) 
    goto _jump2281;
    fail_assertion("non-positive loop bound");
    _jump2281:;
    _1105 = 0;
    int64_t _1109 = 0; // v
    _jump2282:; // Begin body of loop
    int64_t _1110 = _875.d2 + _1042;
    _1105 += _1110;
    _1109++;
    if (_1109 < _1107)
    goto _jump2282;
    // End body of loop
    if (_1105 >= 0)
    goto _jump2283;
    fail_assertion("negative array index");
    _jump2283:;
    if (_1105 < _1085.d0)
    goto _jump2284;
    fail_assertion("index too large");
    _jump2284:;
    if (_183.d0 >= 0)
    goto _jump2285;
    fail_assertion("negative array index");
    _jump2285:;
    if (_183.d0 < _1085.d1)
    goto _jump2286;
    fail_assertion("index too large");
    _jump2286:;
    if (_183.d0 >= 0)
    goto _jump2287;
    fail_assertion("negative array index");
    _jump2287:;
    if (_183.d0 < _1085.d2)
    goto _jump2288;
    fail_assertion("index too large");
    _jump2288:;
    int64_t _1111 = 0;
    _1111 *= _1085.d0;
    _1111 += _1105;
    _1111 *= _1085.d1;
    _1111 += _183.d0;
    _1111 *= _1085.d2;
    _1111 += _183.d0;
    _a3__a3_int64_t _1112 = _1085.data[_1111];
    _1050 = _1112;
    _jump2266:;
    int64_t _1113 = 0;
    _1113 *= _1035.d0;
    _1113 += _1042;
    _1113 *= _1035.d1;
    _1113 += _1041;
    _1113 *= _1035.d2;
    _1113 += _1040;
    _1035.data[_1113] = _1050;
    _1040++;
    if (_1040 < _1038)
    goto _jump2232;
    _1040 = 0;
    _1041++;
    if (_1041 < _1037)
    goto _jump2232;
    _1041 = 0;
    _1042++;
    if (_1042 < _1036)
    goto _jump2232;
    // End body of loop
    int64_t _1115 = -_875.d2;
    bool _1116 = _875.d0 != _1115;
    bool _1114 = _1116;
    if (0 != _1116)
    goto _jump2289;
    double _1118 = 56.0;
    double _1119 = 98.0;
    bool _1120 = _1118 > _1119;
    bool _1117 = _1120;
    if (0 == _1120)
    goto _jump2290;
    int64_t _1121 = 29;
    bool _1122 = _1121 <= _183.d0;
    _1117 = _1122;
    _jump2290:;
    _1114 = _1117;
    _jump2289:;
    int64_t _1123;
    if (!_1114)
    goto _jump2291;
    _1123 = _1034.d0;
    goto _jump2292;
    _jump2291:;
    int64_t _1124;
    // Computing bound for s
    if (_183.d0 > 0) 
    goto _jump2293;
    fail_assertion("non-positive loop bound");
    _jump2293:;
    // Computing bound for t
    if (_875.d2 > 0) 
    goto _jump2294;
    fail_assertion("non-positive loop bound");
    _jump2294:;
    // Computing bound for u
    if (_875.d0 > 0) 
    goto _jump2295;
    fail_assertion("non-positive loop bound");
    _jump2295:;
    _1124 = 0;
    int64_t _1125 = 0; // u
    int64_t _1126 = 0; // t
    int64_t _1127 = 0; // s
    _jump2296:; // Begin body of loop
    int64_t _1128 = 128;
    _1124 += _1128;
    _1125++;
    if (_1125 < _875.d0)
    goto _jump2296;
    _1125 = 0;
    _1126++;
    if (_1126 < _875.d2)
    goto _jump2296;
    _1126 = 0;
    _1127++;
    if (_1127 < _183.d0)
    goto _jump2296;
    // End body of loop
    _1123 = _1124;
    _jump2292:;
    bool _1129 = false;
    int64_t _1130;
    if (!_1129)
    goto _jump2297;
    int64_t _1131 = 48;
    _a1_int64_t _1132;
    _1132.d0 = 2;
    _1132.data = jpl_alloc(sizeof(int64_t) * 2);
    _1132.data[0] = _183.d0;
    _1132.data[1] = _1131;
    int64_t _1133;
    // Computing bound for s
    if (_183.d0 > 0) 
    goto _jump2298;
    fail_assertion("non-positive loop bound");
    _jump2298:;
    _1133 = 0;
    int64_t _1134 = 0; // s
    _jump2299:; // Begin body of loop
    _1133 += _1134;
    _1134++;
    if (_1134 < _183.d0)
    goto _jump2299;
    // End body of loop
    if (_1133 >= 0)
    goto _jump2300;
    fail_assertion("negative array index");
    _jump2300:;
    if (_1133 < _1132.d0)
    goto _jump2301;
    fail_assertion("index too large");
    _jump2301:;
    int64_t _1135 = 0;
    _1135 *= _1132.d0;
    _1135 += _1133;
    int64_t _1136 = _1132.data[_1135];
    if (_875.d0 >= 0)
    goto _jump2302;
    fail_assertion("negative array index");
    _jump2302:;
    if (_875.d0 < _875.d0)
    goto _jump2303;
    fail_assertion("index too large");
    _jump2303:;
    if (_1034.d1 >= 0)
    goto _jump2304;
    fail_assertion("negative array index");
    _jump2304:;
    if (_1034.d1 < _875.d1)
    goto _jump2305;
    fail_assertion("index too large");
    _jump2305:;
    if (_1136 >= 0)
    goto _jump2306;
    fail_assertion("negative array index");
    _jump2306:;
    if (_1136 < _875.d2)
    goto _jump2307;
    fail_assertion("index too large");
    _jump2307:;
    int64_t _1137 = 0;
    _1137 *= _875.d0;
    _1137 += _875.d0;
    _1137 *= _875.d1;
    _1137 += _1034.d1;
    _1137 *= _875.d2;
    _1137 += _1136;
    int64_t _1138 = _875.data[_1137];
    _1130 = _1138;
    goto _jump2308;
    _jump2297:;
    _1130 = _183.d0;
    _jump2308:;
    int64_t _1139 = _1123 / _1130;
    if (_183.d0 >= 0)
    goto _jump2309;
    fail_assertion("negative array index");
    _jump2309:;
    if (_183.d0 < _1035.d0)
    goto _jump2310;
    fail_assertion("index too large");
    _jump2310:;
    if (_1139 >= 0)
    goto _jump2311;
    fail_assertion("negative array index");
    _jump2311:;
    if (_1139 < _1035.d1)
    goto _jump2312;
    fail_assertion("index too large");
    _jump2312:;
    if (_183.d0 >= 0)
    goto _jump2313;
    fail_assertion("negative array index");
    _jump2313:;
    if (_183.d0 < _1035.d2)
    goto _jump2314;
    fail_assertion("index too large");
    _jump2314:;
    int64_t _1140 = 0;
    _1140 *= _1035.d0;
    _1140 += _183.d0;
    _1140 *= _1035.d1;
    _1140 += _1139;
    _1140 *= _1035.d2;
    _1140 += _183.d0;
    _a3__a3_int64_t _1141 = _1035.data[_1140];
    int64_t _1142 = _183.d0 / _875.d2;
    int64_t _1143;
    // Computing bound for s
    if (_875.d2 > 0) 
    goto _jump2315;
    fail_assertion("non-positive loop bound");
    _jump2315:;
    // Computing bound for t
    bool _1144 = false;
    bool _1145;
    if (!_1144)
    goto _jump2316;
    double _1146;
    // Computing bound for s
    if (_875.d0 > 0) 
    goto _jump2317;
    fail_assertion("non-positive loop bound");
    _jump2317:;
    // Computing bound for t
    if (_183.d0 > 0) 
    goto _jump2318;
    fail_assertion("non-positive loop bound");
    _jump2318:;
    // Computing bound for u
    if (_1034.d1 > 0) 
    goto _jump2319;
    fail_assertion("non-positive loop bound");
    _jump2319:;
    _1146 = 0;
    int64_t _1147 = 0; // u
    int64_t _1148 = 0; // t
    int64_t _1149 = 0; // s
    _jump2320:; // Begin body of loop
    _1146 += _954;
    _1147++;
    if (_1147 < _1034.d1)
    goto _jump2320;
    _1147 = 0;
    _1148++;
    if (_1148 < _183.d0)
    goto _jump2320;
    _1148 = 0;
    _1149++;
    if (_1149 < _875.d0)
    goto _jump2320;
    // End body of loop
    double _1150 = 38.0;
    bool _1151 = _1146 < _1150;
    _1145 = _1151;
    goto _jump2321;
    _jump2316:;
    bool _1153 = true;
    bool _1152 = _1153;
    if (0 == _1153)
    goto _jump2322;
    bool _1154 = false;
    _1152 = _1154;
    _jump2322:;
    bool _1155 = !_1152;
    _1145 = _1155;
    _jump2321:;
    int64_t _1156;
    if (!_1145)
    goto _jump2323;
    _1156 = _183.d0;
    goto _jump2324;
    _jump2323:;
    _1156 = _875.d0;
    _jump2324:;
    int64_t _1157;
    // Computing bound for s
    int64_t _1158;
    // Computing bound for s
    if (_875.d2 > 0) 
    goto _jump2325;
    fail_assertion("non-positive loop bound");
    _jump2325:;
    _1158 = 0;
    int64_t _1159 = 0; // s
    _jump2326:; // Begin body of loop
    int64_t _1160 = _875.d0 - _1034.d1;
    _1158 += _1160;
    _1159++;
    if (_1159 < _875.d2)
    goto _jump2326;
    // End body of loop
    int64_t _1161 = _183.d0 + _1158;
    if (_1161 > 0) 
    goto _jump2327;
    fail_assertion("non-positive loop bound");
    _jump2327:;
    // Computing bound for t
    double _1162 = 78.0;
    double _1163 = _954 - _954;
    bool _1164 = _1162 < _1163;
    int64_t _1165;
    if (!_1164)
    goto _jump2328;
    int64_t _1166 = _875.d2 - _1034.d1;
    _1165 = _1166;
    goto _jump2329;
    _jump2328:;
    _1165 = _1034.d1;
    _jump2329:;
    if (_1165 > 0) 
    goto _jump2330;
    fail_assertion("non-positive loop bound");
    _jump2330:;
    // Computing bound for u
    if (_875.d0 > 0) 
    goto _jump2331;
    fail_assertion("non-positive loop bound");
    _jump2331:;
    _1157 = 0;
    int64_t _1167 = 0; // u
    int64_t _1168 = 0; // t
    int64_t _1169 = 0; // s
    _jump2332:; // Begin body of loop
    bool _1170 = _875.d1 <= _1034.d0;
    int64_t _1171;
    if (!_1170)
    goto _jump2333;
    _1171 = _875.d1;
    goto _jump2334;
    _jump2333:;
    int64_t _1172 = 886;
    _1171 = _1172;
    _jump2334:;
    int64_t _1173 = -_1171;
    _1157 += _1173;
    _1167++;
    if (_1167 < _875.d0)
    goto _jump2332;
    _1167 = 0;
    _1168++;
    if (_1168 < _1165)
    goto _jump2332;
    _1168 = 0;
    _1169++;
    if (_1169 < _1161)
    goto _jump2332;
    // End body of loop
    int64_t _1174 = _1156 + _1157;
    if (_1174 > 0) 
    goto _jump2335;
    fail_assertion("non-positive loop bound");
    _jump2335:;
    // Computing bound for u
    int64_t _1175 = 930;
    if (_1175 > 0) 
    goto _jump2336;
    fail_assertion("non-positive loop bound");
    _jump2336:;
    _1143 = 0;
    int64_t _1176 = 0; // u
    int64_t _1177 = 0; // t
    int64_t _1178 = 0; // s
    _jump2337:; // Begin body of loop
    _1143 += _1034.d1;
    _1176++;
    if (_1176 < _1175)
    goto _jump2337;
    _1176 = 0;
    _1177++;
    if (_1177 < _1174)
    goto _jump2337;
    _1177 = 0;
    _1178++;
    if (_1178 < _875.d2)
    goto _jump2337;
    // End body of loop
    if (_1034.d1 >= 0)
    goto _jump2338;
    fail_assertion("negative array index");
    _jump2338:;
    if (_1034.d1 < _1141.d0)
    goto _jump2339;
    fail_assertion("index too large");
    _jump2339:;
    if (_1142 >= 0)
    goto _jump2340;
    fail_assertion("negative array index");
    _jump2340:;
    if (_1142 < _1141.d1)
    goto _jump2341;
    fail_assertion("index too large");
    _jump2341:;
    if (_1143 >= 0)
    goto _jump2342;
    fail_assertion("negative array index");
    _jump2342:;
    if (_1143 < _1141.d2)
    goto _jump2343;
    fail_assertion("index too large");
    _jump2343:;
    int64_t _1179 = 0;
    _1179 *= _1141.d0;
    _1179 += _1034.d1;
    _1179 *= _1141.d1;
    _1179 += _1142;
    _1179 *= _1141.d2;
    _1179 += _1143;
    _a3_int64_t _1180 = _1141.data[_1179];
    _a1_bool _1181;
    // Computing bound for w
    _1181.d0 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2344;
    fail_assertion("non-positive loop bound");
    _jump2344:;
    // Computing total size of heap memory to allocate
    int64_t _1182 = 1;
    _1182 *= _1034.d0;
    _1182 *= sizeof(bool);
    _1181.data = jpl_alloc(_1182);
    int64_t _1183 = 0; // w
    _jump2345:; // Begin body of loop
    _a3_bool _1184;
    // Computing bound for x
    _1184.d0 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2346;
    fail_assertion("non-positive loop bound");
    _jump2346:;
    // Computing bound for y
    _1184.d1 = _1034.d1;
    if (_1034.d1 > 0) 
    goto _jump2347;
    fail_assertion("non-positive loop bound");
    _jump2347:;
    // Computing bound for z
    _1184.d2 = _1180.d0;
    if (_1180.d0 > 0) 
    goto _jump2348;
    fail_assertion("non-positive loop bound");
    _jump2348:;
    // Computing total size of heap memory to allocate
    int64_t _1185 = 1;
    _1185 *= _875.d2;
    _1185 *= _1034.d1;
    _1185 *= _1180.d0;
    _1185 *= sizeof(bool);
    _1184.data = jpl_alloc(_1185);
    int64_t _1186 = 0; // z
    int64_t _1187 = 0; // y
    int64_t _1188 = 0; // x
    _jump2349:; // Begin body of loop
    bool _1189 = false;
    int64_t _1190 = 0;
    _1190 *= _1184.d0;
    _1190 += _1188;
    _1190 *= _1184.d1;
    _1190 += _1187;
    _1190 *= _1184.d2;
    _1190 += _1186;
    _1184.data[_1190] = _1189;
    _1186++;
    if (_1186 < _1180.d0)
    goto _jump2349;
    _1186 = 0;
    _1187++;
    if (_1187 < _1034.d1)
    goto _jump2349;
    _1187 = 0;
    _1188++;
    if (_1188 < _875.d2)
    goto _jump2349;
    // End body of loop
    int64_t _1191 = _1180.d1 - _875.d2;
    int64_t _1192 = -_875.d2;
    if (_183.d0 >= 0)
    goto _jump2350;
    fail_assertion("negative array index");
    _jump2350:;
    if (_183.d0 < _1184.d0)
    goto _jump2351;
    fail_assertion("index too large");
    _jump2351:;
    if (_1191 >= 0)
    goto _jump2352;
    fail_assertion("negative array index");
    _jump2352:;
    if (_1191 < _1184.d1)
    goto _jump2353;
    fail_assertion("index too large");
    _jump2353:;
    if (_1192 >= 0)
    goto _jump2354;
    fail_assertion("negative array index");
    _jump2354:;
    if (_1192 < _1184.d2)
    goto _jump2355;
    fail_assertion("index too large");
    _jump2355:;
    int64_t _1193 = 0;
    _1193 *= _1184.d0;
    _1193 += _183.d0;
    _1193 *= _1184.d1;
    _1193 += _1191;
    _1193 *= _1184.d2;
    _1193 += _1192;
    bool _1194 = _1184.data[_1193];
    int64_t _1195 = 0;
    _1195 *= _1181.d0;
    _1195 += _1183;
    _1181.data[_1195] = _1194;
    _1183++;
    if (_1183 < _1034.d0)
    goto _jump2345;
    // End body of loop
    if (_1034.d0 >= 0)
    goto _jump2356;
    fail_assertion("negative array index");
    _jump2356:;
    if (_1034.d0 < _1181.d0)
    goto _jump2357;
    fail_assertion("index too large");
    _jump2357:;
    int64_t _1196 = 0;
    _1196 *= _1181.d0;
    _1196 += _1034.d0;
    bool _1197 = _1181.data[_1196];
    bool _1198 = !_1197;
    int64_t _1199;
    // Computing bound for w
    if (_875.d1 > 0) 
    goto _jump2358;
    fail_assertion("non-positive loop bound");
    _jump2358:;
    // Computing bound for x
    if (_875.d2 > 0) 
    goto _jump2359;
    fail_assertion("non-positive loop bound");
    _jump2359:;
    _1199 = 0;
    int64_t _1200 = 0; // x
    int64_t _1201 = 0; // w
    _jump2360:; // Begin body of loop
    _1199 += _1180.d2;
    _1200++;
    if (_1200 < _875.d2)
    goto _jump2360;
    _1200 = 0;
    _1201++;
    if (_1201 < _875.d1)
    goto _jump2360;
    // End body of loop
    bool _1202 = _1199 > _1034.d1;
    bool _1203 = _1198 != _1202;
    _a1_bool _1204;
    if (!_1203)
    goto _jump2361;
    int64_t _1205 = -_1180.d1;
    bool _1206 = _1034.d0 != _1205;
    bool _1207 = !_1206;
    _a3__a1_bool _1208;
    if (!_1207)
    goto _jump2362;
    int64_t _1209 = _875.d1 + _875.d1;
    int64_t _1210 = _875.d0 * _1209;
    if (_1210 >= 0)
    goto _jump2363;
    fail_assertion("negative array index");
    _jump2363:;
    if (_1210 < _183.d0)
    goto _jump2364;
    fail_assertion("index too large");
    _jump2364:;
    int64_t _1211 = 0;
    _1211 *= _183.d0;
    _1211 += _1210;
    bool _1212 = _183.data[_1211];
    _a3__a1_bool _1213;
    if (!_1212)
    goto _jump2365;
    int64_t _1214 = _1180.d2 / _1180.d1;
    if (_1214 >= 0)
    goto _jump2366;
    fail_assertion("negative array index");
    _jump2366:;
    if (_1214 < _183.d0)
    goto _jump2367;
    fail_assertion("index too large");
    _jump2367:;
    int64_t _1215 = 0;
    _1215 *= _183.d0;
    _1215 += _1214;
    bool _1216 = _183.data[_1215];
    _a3__a1_bool _1217;
    if (!_1216)
    goto _jump2368;
    bool _1218 = true;
    _a3__a1_bool _1219;
    if (!_1218)
    goto _jump2369;
    _a3__a1_bool _1220;
    // Computing bound for w
    _1220.d0 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2370;
    fail_assertion("non-positive loop bound");
    _jump2370:;
    // Computing bound for x
    _1220.d1 = _1034.d1;
    if (_1034.d1 > 0) 
    goto _jump2371;
    fail_assertion("non-positive loop bound");
    _jump2371:;
    // Computing bound for y
    _1220.d2 = _875.d1;
    if (_875.d1 > 0) 
    goto _jump2372;
    fail_assertion("non-positive loop bound");
    _jump2372:;
    // Computing total size of heap memory to allocate
    int64_t _1221 = 1;
    _1221 *= _875.d0;
    _1221 *= _1034.d1;
    _1221 *= _875.d1;
    _1221 *= sizeof(_a1_bool);
    _1220.data = jpl_alloc(_1221);
    int64_t _1222 = 0; // y
    int64_t _1223 = 0; // x
    int64_t _1224 = 0; // w
    _jump2373:; // Begin body of loop
    int64_t _1225 = 0;
    _1225 *= _1220.d0;
    _1225 += _1224;
    _1225 *= _1220.d1;
    _1225 += _1223;
    _1225 *= _1220.d2;
    _1225 += _1222;
    _1220.data[_1225] = _183;
    _1222++;
    if (_1222 < _875.d1)
    goto _jump2373;
    _1222 = 0;
    _1223++;
    if (_1223 < _1034.d1)
    goto _jump2373;
    _1223 = 0;
    _1224++;
    if (_1224 < _875.d0)
    goto _jump2373;
    // End body of loop
    _1219 = _1220;
    goto _jump2374;
    _jump2369:;
    _a3__a1_bool _1226;
    // Computing bound for w
    _1226.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2375;
    fail_assertion("non-positive loop bound");
    _jump2375:;
    // Computing bound for x
    _1226.d1 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2376;
    fail_assertion("non-positive loop bound");
    _jump2376:;
    // Computing bound for y
    _1226.d2 = _875.d1;
    if (_875.d1 > 0) 
    goto _jump2377;
    fail_assertion("non-positive loop bound");
    _jump2377:;
    // Computing total size of heap memory to allocate
    int64_t _1227 = 1;
    _1227 *= _183.d0;
    _1227 *= _1034.d0;
    _1227 *= _875.d1;
    _1227 *= sizeof(_a1_bool);
    _1226.data = jpl_alloc(_1227);
    int64_t _1228 = 0; // y
    int64_t _1229 = 0; // x
    int64_t _1230 = 0; // w
    _jump2378:; // Begin body of loop
    int64_t _1231 = 0;
    _1231 *= _1226.d0;
    _1231 += _1230;
    _1231 *= _1226.d1;
    _1231 += _1229;
    _1231 *= _1226.d2;
    _1231 += _1228;
    _1226.data[_1231] = _183;
    _1228++;
    if (_1228 < _875.d1)
    goto _jump2378;
    _1228 = 0;
    _1229++;
    if (_1229 < _1034.d0)
    goto _jump2378;
    _1229 = 0;
    _1230++;
    if (_1230 < _183.d0)
    goto _jump2378;
    // End body of loop
    _1219 = _1226;
    _jump2374:;
    _1217 = _1219;
    goto _jump2379;
    _jump2368:;
    _a3__a1_bool _1232;
    // Computing bound for w
    _1232.d0 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2380;
    fail_assertion("non-positive loop bound");
    _jump2380:;
    // Computing bound for x
    _1232.d1 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2381;
    fail_assertion("non-positive loop bound");
    _jump2381:;
    // Computing bound for y
    _1232.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2382;
    fail_assertion("non-positive loop bound");
    _jump2382:;
    // Computing total size of heap memory to allocate
    int64_t _1233 = 1;
    _1233 *= _1034.d0;
    _1233 *= _1180.d1;
    _1233 *= _183.d0;
    _1233 *= sizeof(_a1_bool);
    _1232.data = jpl_alloc(_1233);
    int64_t _1234 = 0; // y
    int64_t _1235 = 0; // x
    int64_t _1236 = 0; // w
    _jump2383:; // Begin body of loop
    bool _1237 = true;
    _a1_bool _1238;
    _1238.d0 = 1;
    _1238.data = jpl_alloc(sizeof(bool) * 1);
    _1238.data[0] = _1237;
    int64_t _1239 = 0;
    _1239 *= _1232.d0;
    _1239 += _1236;
    _1239 *= _1232.d1;
    _1239 += _1235;
    _1239 *= _1232.d2;
    _1239 += _1234;
    _1232.data[_1239] = _1238;
    _1234++;
    if (_1234 < _183.d0)
    goto _jump2383;
    _1234 = 0;
    _1235++;
    if (_1235 < _1180.d1)
    goto _jump2383;
    _1235 = 0;
    _1236++;
    if (_1236 < _1034.d0)
    goto _jump2383;
    // End body of loop
    _1217 = _1232;
    _jump2379:;
    _1213 = _1217;
    goto _jump2384;
    _jump2365:;
    bool _1241 = true;
    bool _1240 = _1241;
    if (0 == _1241)
    goto _jump2385;
    bool _1242 = false;
    _1240 = _1242;
    _jump2385:;
    _a3__a1_bool _1243;
    if (!_1240)
    goto _jump2386;
    _a3__a1_bool _1244;
    // Computing bound for w
    _1244.d0 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2387;
    fail_assertion("non-positive loop bound");
    _jump2387:;
    // Computing bound for x
    int64_t _1245;
    // Computing bound for w
    if (_183.d0 > 0) 
    goto _jump2388;
    fail_assertion("non-positive loop bound");
    _jump2388:;
    // Computing bound for x
    if (_1034.d1 > 0) 
    goto _jump2389;
    fail_assertion("non-positive loop bound");
    _jump2389:;
    // Computing bound for y
    if (_875.d1 > 0) 
    goto _jump2390;
    fail_assertion("non-positive loop bound");
    _jump2390:;
    _1245 = 0;
    int64_t _1246 = 0; // y
    int64_t _1247 = 0; // x
    int64_t _1248 = 0; // w
    _jump2391:; // Begin body of loop
    _1245 += _183.d0;
    _1246++;
    if (_1246 < _875.d1)
    goto _jump2391;
    _1246 = 0;
    _1247++;
    if (_1247 < _1034.d1)
    goto _jump2391;
    _1247 = 0;
    _1248++;
    if (_1248 < _183.d0)
    goto _jump2391;
    // End body of loop
    _1244.d1 = _1245;
    if (_1245 > 0) 
    goto _jump2392;
    fail_assertion("non-positive loop bound");
    _jump2392:;
    // Computing bound for y
    _1244.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2393;
    fail_assertion("non-positive loop bound");
    _jump2393:;
    // Computing total size of heap memory to allocate
    int64_t _1249 = 1;
    _1249 *= _875.d0;
    _1249 *= _1245;
    _1249 *= _183.d0;
    _1249 *= sizeof(_a1_bool);
    _1244.data = jpl_alloc(_1249);
    int64_t _1250 = 0; // y
    int64_t _1251 = 0; // x
    int64_t _1252 = 0; // w
    _jump2394:; // Begin body of loop
    int64_t _1253 = 0;
    _1253 *= _1244.d0;
    _1253 += _1252;
    _1253 *= _1244.d1;
    _1253 += _1251;
    _1253 *= _1244.d2;
    _1253 += _1250;
    _1244.data[_1253] = _183;
    _1250++;
    if (_1250 < _183.d0)
    goto _jump2394;
    _1250 = 0;
    _1251++;
    if (_1251 < _1245)
    goto _jump2394;
    _1251 = 0;
    _1252++;
    if (_1252 < _875.d0)
    goto _jump2394;
    // End body of loop
    _1243 = _1244;
    goto _jump2395;
    _jump2386:;
    _a3__a1_bool _1254;
    // Computing bound for w
    int64_t _1255;
    // Computing bound for w
    if (_183.d0 > 0) 
    goto _jump2396;
    fail_assertion("non-positive loop bound");
    _jump2396:;
    _1255 = 0;
    int64_t _1256 = 0; // w
    _jump2397:; // Begin body of loop
    int64_t _1257 = 631;
    _1255 += _1257;
    _1256++;
    if (_1256 < _183.d0)
    goto _jump2397;
    // End body of loop
    _1254.d0 = _1255;
    if (_1255 > 0) 
    goto _jump2398;
    fail_assertion("non-positive loop bound");
    _jump2398:;
    // Computing bound for x
    _1254.d1 = _1180.d2;
    if (_1180.d2 > 0) 
    goto _jump2399;
    fail_assertion("non-positive loop bound");
    _jump2399:;
    // Computing bound for y
    int64_t _1258 = 573;
    _1254.d2 = _1258;
    if (_1258 > 0) 
    goto _jump2400;
    fail_assertion("non-positive loop bound");
    _jump2400:;
    // Computing total size of heap memory to allocate
    int64_t _1259 = 1;
    _1259 *= _1255;
    _1259 *= _1180.d2;
    _1259 *= _1258;
    _1259 *= sizeof(_a1_bool);
    _1254.data = jpl_alloc(_1259);
    int64_t _1260 = 0; // y
    int64_t _1261 = 0; // x
    int64_t _1262 = 0; // w
    _jump2401:; // Begin body of loop
    bool _1263 = true;
    _a1_bool _1264;
    if (!_1263)
    goto _jump2402;
    _1264 = _183;
    goto _jump2403;
    _jump2402:;
    _1264 = _183;
    _jump2403:;
    int64_t _1265 = 0;
    _1265 *= _1254.d0;
    _1265 += _1262;
    _1265 *= _1254.d1;
    _1265 += _1261;
    _1265 *= _1254.d2;
    _1265 += _1260;
    _1254.data[_1265] = _1264;
    _1260++;
    if (_1260 < _1258)
    goto _jump2401;
    _1260 = 0;
    _1261++;
    if (_1261 < _1180.d2)
    goto _jump2401;
    _1261 = 0;
    _1262++;
    if (_1262 < _1255)
    goto _jump2401;
    // End body of loop
    _1243 = _1254;
    _jump2395:;
    _1213 = _1243;
    _jump2384:;
    _1208 = _1213;
    goto _jump2404;
    _jump2362:;
    bool _1266 = false;
    bool _1267 = !_1266;
    bool _1268 = !_1267;
    bool _1269;
    if (!_1268)
    goto _jump2405;
    bool _1270 = false;
    bool _1271 = !_1270;
    bool _1272 = !_1271;
    _1269 = _1272;
    goto _jump2406;
    _jump2405:;
    bool _1273 = _875.d2 == _1034.d1;
    _1269 = _1273;
    _jump2406:;
    _a3__a1_bool _1274;
    if (!_1269)
    goto _jump2407;
    _a3__a1_bool _1275;
    // Computing bound for w
    int64_t _1276;
    // Computing bound for w
    int64_t _1277 = 684;
    if (_1277 > 0) 
    goto _jump2408;
    fail_assertion("non-positive loop bound");
    _jump2408:;
    // Computing bound for x
    if (_183.d0 > 0) 
    goto _jump2409;
    fail_assertion("non-positive loop bound");
    _jump2409:;
    // Computing bound for y
    if (_1034.d1 > 0) 
    goto _jump2410;
    fail_assertion("non-positive loop bound");
    _jump2410:;
    _1276 = 0;
    int64_t _1278 = 0; // y
    int64_t _1279 = 0; // x
    int64_t _1280 = 0; // w
    _jump2411:; // Begin body of loop
    _1276 += _1278;
    _1278++;
    if (_1278 < _1034.d1)
    goto _jump2411;
    _1278 = 0;
    _1279++;
    if (_1279 < _183.d0)
    goto _jump2411;
    _1279 = 0;
    _1280++;
    if (_1280 < _1277)
    goto _jump2411;
    // End body of loop
    int64_t _1281 = _1276 + _875.d1;
    _1275.d0 = _1281;
    if (_1281 > 0) 
    goto _jump2412;
    fail_assertion("non-positive loop bound");
    _jump2412:;
    // Computing bound for x
    _1275.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2413;
    fail_assertion("non-positive loop bound");
    _jump2413:;
    // Computing bound for y
    _1275.d2 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2414;
    fail_assertion("non-positive loop bound");
    _jump2414:;
    // Computing total size of heap memory to allocate
    int64_t _1282 = 1;
    _1282 *= _1281;
    _1282 *= _183.d0;
    _1282 *= _875.d2;
    _1282 *= sizeof(_a1_bool);
    _1275.data = jpl_alloc(_1282);
    int64_t _1283 = 0; // y
    int64_t _1284 = 0; // x
    int64_t _1285 = 0; // w
    _jump2415:; // Begin body of loop
    _a2__a1_bool _1286;
    // Computing bound for z
    _1286.d0 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2416;
    fail_assertion("non-positive loop bound");
    _jump2416:;
    // Computing bound for A
    _1286.d1 = _1180.d2;
    if (_1180.d2 > 0) 
    goto _jump2417;
    fail_assertion("non-positive loop bound");
    _jump2417:;
    // Computing total size of heap memory to allocate
    int64_t _1287 = 1;
    _1287 *= _183.d0;
    _1287 *= _1180.d2;
    _1287 *= sizeof(_a1_bool);
    _1286.data = jpl_alloc(_1287);
    int64_t _1288 = 0; // A
    int64_t _1289 = 0; // z
    _jump2418:; // Begin body of loop
    int64_t _1290 = 0;
    _1290 *= _1286.d0;
    _1290 += _1289;
    _1290 *= _1286.d1;
    _1290 += _1288;
    _1286.data[_1290] = _183;
    _1288++;
    if (_1288 < _1180.d2)
    goto _jump2418;
    _1288 = 0;
    _1289++;
    if (_1289 < _183.d0)
    goto _jump2418;
    // End body of loop
    int64_t _1291 = 919;
    if (_1034.d0 >= 0)
    goto _jump2419;
    fail_assertion("negative array index");
    _jump2419:;
    if (_1034.d0 < _1286.d0)
    goto _jump2420;
    fail_assertion("index too large");
    _jump2420:;
    if (_1291 >= 0)
    goto _jump2421;
    fail_assertion("negative array index");
    _jump2421:;
    if (_1291 < _1286.d1)
    goto _jump2422;
    fail_assertion("index too large");
    _jump2422:;
    int64_t _1292 = 0;
    _1292 *= _1286.d0;
    _1292 += _1034.d0;
    _1292 *= _1286.d1;
    _1292 += _1291;
    _a1_bool _1293 = _1286.data[_1292];
    int64_t _1294 = 0;
    _1294 *= _1275.d0;
    _1294 += _1285;
    _1294 *= _1275.d1;
    _1294 += _1284;
    _1294 *= _1275.d2;
    _1294 += _1283;
    _1275.data[_1294] = _1293;
    _1283++;
    if (_1283 < _875.d2)
    goto _jump2415;
    _1283 = 0;
    _1284++;
    if (_1284 < _183.d0)
    goto _jump2415;
    _1284 = 0;
    _1285++;
    if (_1285 < _1281)
    goto _jump2415;
    // End body of loop
    _1274 = _1275;
    goto _jump2423;
    _jump2407:;
    if (_1180.d1 >= 0)
    goto _jump2424;
    fail_assertion("negative array index");
    _jump2424:;
    if (_1180.d1 < _183.d0)
    goto _jump2425;
    fail_assertion("index too large");
    _jump2425:;
    int64_t _1295 = 0;
    _1295 *= _183.d0;
    _1295 += _1180.d1;
    bool _1296 = _183.data[_1295];
    _a3__a1_bool _1297;
    if (!_1296)
    goto _jump2426;
    _a3__a1_bool _1298;
    // Computing bound for w
    _1298.d0 = _875.d1;
    if (_875.d1 > 0) 
    goto _jump2427;
    fail_assertion("non-positive loop bound");
    _jump2427:;
    // Computing bound for x
    _1298.d1 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2428;
    fail_assertion("non-positive loop bound");
    _jump2428:;
    // Computing bound for y
    _1298.d2 = _1180.d2;
    if (_1180.d2 > 0) 
    goto _jump2429;
    fail_assertion("non-positive loop bound");
    _jump2429:;
    // Computing total size of heap memory to allocate
    int64_t _1299 = 1;
    _1299 *= _875.d1;
    _1299 *= _1034.d0;
    _1299 *= _1180.d2;
    _1299 *= sizeof(_a1_bool);
    _1298.data = jpl_alloc(_1299);
    int64_t _1300 = 0; // y
    int64_t _1301 = 0; // x
    int64_t _1302 = 0; // w
    _jump2430:; // Begin body of loop
    bool _1303 = true;
    _a1_bool _1304;
    _1304.d0 = 1;
    _1304.data = jpl_alloc(sizeof(bool) * 1);
    _1304.data[0] = _1303;
    int64_t _1305 = 0;
    _1305 *= _1298.d0;
    _1305 += _1302;
    _1305 *= _1298.d1;
    _1305 += _1301;
    _1305 *= _1298.d2;
    _1305 += _1300;
    _1298.data[_1305] = _1304;
    _1300++;
    if (_1300 < _1180.d2)
    goto _jump2430;
    _1300 = 0;
    _1301++;
    if (_1301 < _1034.d0)
    goto _jump2430;
    _1301 = 0;
    _1302++;
    if (_1302 < _875.d1)
    goto _jump2430;
    // End body of loop
    _1297 = _1298;
    goto _jump2431;
    _jump2426:;
    _a3__a1_bool _1306;
    // Computing bound for w
    _1306.d0 = _1180.d2;
    if (_1180.d2 > 0) 
    goto _jump2432;
    fail_assertion("non-positive loop bound");
    _jump2432:;
    // Computing bound for x
    _1306.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2433;
    fail_assertion("non-positive loop bound");
    _jump2433:;
    // Computing bound for y
    _1306.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2434;
    fail_assertion("non-positive loop bound");
    _jump2434:;
    // Computing total size of heap memory to allocate
    int64_t _1307 = 1;
    _1307 *= _1180.d2;
    _1307 *= _183.d0;
    _1307 *= _183.d0;
    _1307 *= sizeof(_a1_bool);
    _1306.data = jpl_alloc(_1307);
    int64_t _1308 = 0; // y
    int64_t _1309 = 0; // x
    int64_t _1310 = 0; // w
    _jump2435:; // Begin body of loop
    int64_t _1311 = 0;
    _1311 *= _1306.d0;
    _1311 += _1310;
    _1311 *= _1306.d1;
    _1311 += _1309;
    _1311 *= _1306.d2;
    _1311 += _1308;
    _1306.data[_1311] = _183;
    _1308++;
    if (_1308 < _183.d0)
    goto _jump2435;
    _1308 = 0;
    _1309++;
    if (_1309 < _183.d0)
    goto _jump2435;
    _1309 = 0;
    _1310++;
    if (_1310 < _1180.d2)
    goto _jump2435;
    // End body of loop
    _1297 = _1306;
    _jump2431:;
    _1274 = _1297;
    _jump2423:;
    _1208 = _1274;
    _jump2404:;
    _a1_int64_t _1312;
    // Computing bound for w
    int64_t _1313 = 319;
    _1312.d0 = _1313;
    if (_1313 > 0) 
    goto _jump2436;
    fail_assertion("non-positive loop bound");
    _jump2436:;
    // Computing total size of heap memory to allocate
    int64_t _1314 = 1;
    _1314 *= _1313;
    _1314 *= sizeof(int64_t);
    _1312.data = jpl_alloc(_1314);
    int64_t _1315 = 0; // w
    _jump2437:; // Begin body of loop
    int64_t _1316 = 0;
    _1316 *= _1312.d0;
    _1316 += _1315;
    _1312.data[_1316] = _875.d2;
    _1315++;
    if (_1315 < _1313)
    goto _jump2437;
    // End body of loop
    _a1_int64_t _1317;
    // Computing bound for w
    _1317.d0 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2438;
    fail_assertion("non-positive loop bound");
    _jump2438:;
    // Computing total size of heap memory to allocate
    int64_t _1318 = 1;
    _1318 *= _1180.d1;
    _1318 *= sizeof(int64_t);
    _1317.data = jpl_alloc(_1318);
    int64_t _1319 = 0; // w
    _jump2439:; // Begin body of loop
    int64_t _1320 = 0;
    _1320 *= _1317.d0;
    _1320 += _1319;
    _1317.data[_1320] = _1034.d1;
    _1319++;
    if (_1319 < _1180.d1)
    goto _jump2439;
    // End body of loop
    if (_1034.d0 >= 0)
    goto _jump2440;
    fail_assertion("negative array index");
    _jump2440:;
    if (_1034.d0 < _1317.d0)
    goto _jump2441;
    fail_assertion("index too large");
    _jump2441:;
    int64_t _1321 = 0;
    _1321 *= _1317.d0;
    _1321 += _1034.d0;
    int64_t _1322 = _1317.data[_1321];
    int64_t _1323 = -_1322;
    if (_1323 >= 0)
    goto _jump2442;
    fail_assertion("negative array index");
    _jump2442:;
    if (_1323 < _1312.d0)
    goto _jump2443;
    fail_assertion("index too large");
    _jump2443:;
    int64_t _1324 = 0;
    _1324 *= _1312.d0;
    _1324 += _1323;
    int64_t _1325 = _1312.data[_1324];
    int64_t _1326 = _183.d0 - _1180.d2;
    int64_t _1327 = _1034.d0 - _1326;
    int64_t _1328 = 816;
    if (_1325 >= 0)
    goto _jump2444;
    fail_assertion("negative array index");
    _jump2444:;
    if (_1325 < _1208.d0)
    goto _jump2445;
    fail_assertion("index too large");
    _jump2445:;
    if (_1327 >= 0)
    goto _jump2446;
    fail_assertion("negative array index");
    _jump2446:;
    if (_1327 < _1208.d1)
    goto _jump2447;
    fail_assertion("index too large");
    _jump2447:;
    if (_1328 >= 0)
    goto _jump2448;
    fail_assertion("negative array index");
    _jump2448:;
    if (_1328 < _1208.d2)
    goto _jump2449;
    fail_assertion("index too large");
    _jump2449:;
    int64_t _1329 = 0;
    _1329 *= _1208.d0;
    _1329 += _1325;
    _1329 *= _1208.d1;
    _1329 += _1327;
    _1329 *= _1208.d2;
    _1329 += _1328;
    _a1_bool _1330 = _1208.data[_1329];
    _1204 = _1330;
    goto _jump2450;
    _jump2361:;
    bool _1332 = false;
    bool _1331 = _1332;
    if (0 == _1332)
    goto _jump2451;
    _a2_bool _1333;
    // Computing bound for w
    _1333.d0 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2452;
    fail_assertion("non-positive loop bound");
    _jump2452:;
    // Computing bound for x
    int64_t _1334 = 434;
    _1333.d1 = _1334;
    if (_1334 > 0) 
    goto _jump2453;
    fail_assertion("non-positive loop bound");
    _jump2453:;
    // Computing total size of heap memory to allocate
    int64_t _1335 = 1;
    _1335 *= _875.d0;
    _1335 *= _1334;
    _1335 *= sizeof(bool);
    _1333.data = jpl_alloc(_1335);
    int64_t _1336 = 0; // x
    int64_t _1337 = 0; // w
    _jump2454:; // Begin body of loop
    bool _1338 = false;
    int64_t _1339 = 0;
    _1339 *= _1333.d0;
    _1339 += _1337;
    _1339 *= _1333.d1;
    _1339 += _1336;
    _1333.data[_1339] = _1338;
    _1336++;
    if (_1336 < _1334)
    goto _jump2454;
    _1336 = 0;
    _1337++;
    if (_1337 < _875.d0)
    goto _jump2454;
    // End body of loop
    int64_t _1340 = 535;
    int64_t _1341 = -_1340;
    if (_875.d1 >= 0)
    goto _jump2455;
    fail_assertion("negative array index");
    _jump2455:;
    if (_875.d1 < _1333.d0)
    goto _jump2456;
    fail_assertion("index too large");
    _jump2456:;
    if (_1341 >= 0)
    goto _jump2457;
    fail_assertion("negative array index");
    _jump2457:;
    if (_1341 < _1333.d1)
    goto _jump2458;
    fail_assertion("index too large");
    _jump2458:;
    int64_t _1342 = 0;
    _1342 *= _1333.d0;
    _1342 += _875.d1;
    _1342 *= _1333.d1;
    _1342 += _1341;
    bool _1343 = _1333.data[_1342];
    bool _1344 = !_1343;
    _1331 = _1344;
    _jump2451:;
    _a1__a1_bool _1345;
    if (!_1331)
    goto _jump2459;
    _a1__a1__a1_bool _1346;
    // Computing bound for w
    _1346.d0 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2460;
    fail_assertion("non-positive loop bound");
    _jump2460:;
    // Computing total size of heap memory to allocate
    int64_t _1347 = 1;
    _1347 *= _1180.d1;
    _1347 *= sizeof(_a1__a1_bool);
    _1346.data = jpl_alloc(_1347);
    int64_t _1348 = 0; // w
    _jump2461:; // Begin body of loop
    _a1__a1_bool _1349;
    // Computing bound for x
    int64_t _1350 = -_1034.d1;
    _1349.d0 = _1350;
    if (_1350 > 0) 
    goto _jump2462;
    fail_assertion("non-positive loop bound");
    _jump2462:;
    // Computing total size of heap memory to allocate
    int64_t _1351 = 1;
    _1351 *= _1350;
    _1351 *= sizeof(_a1_bool);
    _1349.data = jpl_alloc(_1351);
    int64_t _1352 = 0; // x
    _jump2463:; // Begin body of loop
    bool _1353 = false;
    _a1_bool _1354;
    if (!_1353)
    goto _jump2464;
    _1354 = _183;
    goto _jump2465;
    _jump2464:;
    _1354 = _183;
    _jump2465:;
    int64_t _1355 = 0;
    _1355 *= _1349.d0;
    _1355 += _1352;
    _1349.data[_1355] = _1354;
    _1352++;
    if (_1352 < _1350)
    goto _jump2463;
    // End body of loop
    int64_t _1356 = 0;
    _1356 *= _1346.d0;
    _1356 += _1348;
    _1346.data[_1356] = _1349;
    _1348++;
    if (_1348 < _1180.d1)
    goto _jump2461;
    // End body of loop
    if (_1180.d1 >= 0)
    goto _jump2466;
    fail_assertion("negative array index");
    _jump2466:;
    if (_1180.d1 < _1346.d0)
    goto _jump2467;
    fail_assertion("index too large");
    _jump2467:;
    int64_t _1357 = 0;
    _1357 *= _1346.d0;
    _1357 += _1180.d1;
    _a1__a1_bool _1358 = _1346.data[_1357];
    _1345 = _1358;
    goto _jump2468;
    _jump2459:;
    _a1__a1_bool _1359;
    // Computing bound for w
    _1359.d0 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2469;
    fail_assertion("non-positive loop bound");
    _jump2469:;
    // Computing total size of heap memory to allocate
    int64_t _1360 = 1;
    _1360 *= _1180.d1;
    _1360 *= sizeof(_a1_bool);
    _1359.data = jpl_alloc(_1360);
    int64_t _1361 = 0; // w
    _jump2470:; // Begin body of loop
    bool _1362 = _954 > _954;
    _a1_bool _1363;
    if (!_1362)
    goto _jump2471;
    _1363 = _183;
    goto _jump2472;
    _jump2471:;
    _a1_bool _1364;
    // Computing bound for x
    _1364.d0 = _1180.d0;
    if (_1180.d0 > 0) 
    goto _jump2473;
    fail_assertion("non-positive loop bound");
    _jump2473:;
    // Computing total size of heap memory to allocate
    int64_t _1365 = 1;
    _1365 *= _1180.d0;
    _1365 *= sizeof(bool);
    _1364.data = jpl_alloc(_1365);
    int64_t _1366 = 0; // x
    _jump2474:; // Begin body of loop
    bool _1367 = true;
    int64_t _1368 = 0;
    _1368 *= _1364.d0;
    _1368 += _1366;
    _1364.data[_1368] = _1367;
    _1366++;
    if (_1366 < _1180.d0)
    goto _jump2474;
    // End body of loop
    _1363 = _1364;
    _jump2472:;
    int64_t _1369 = 0;
    _1369 *= _1359.d0;
    _1369 += _1361;
    _1359.data[_1369] = _1363;
    _1361++;
    if (_1361 < _1180.d1)
    goto _jump2470;
    // End body of loop
    _1345 = _1359;
    _jump2468:;
    if (_1180.d0 >= 0)
    goto _jump2475;
    fail_assertion("negative array index");
    _jump2475:;
    if (_1180.d0 < _1345.d0)
    goto _jump2476;
    fail_assertion("index too large");
    _jump2476:;
    int64_t _1370 = 0;
    _1370 *= _1345.d0;
    _1370 += _1180.d0;
    _a1_bool _1371 = _1345.data[_1370];
    _1204 = _1371;
    _jump2450:;
    bool _1373 = _1034.d1 >= _1034.d1;
    bool _1372 = _1373;
    if (0 != _1373)
    goto _jump2477;
    if (_875.d0 >= 0)
    goto _jump2478;
    fail_assertion("negative array index");
    _jump2478:;
    if (_875.d0 < _183.d0)
    goto _jump2479;
    fail_assertion("index too large");
    _jump2479:;
    int64_t _1375 = 0;
    _1375 *= _183.d0;
    _1375 += _875.d0;
    bool _1376 = _183.data[_1375];
    bool _1374 = _1376;
    if (0 == _1376)
    goto _jump2480;
    bool _1377 = false;
    bool _1378 = !_1377;
    _1374 = _1378;
    _jump2480:;
    _1372 = _1374;
    _jump2477:;
    _a1_bool _1379;
    if (!_1372)
    goto _jump2481;
    bool _1380 = false;
    _a1_bool _1381;
    if (!_1380)
    goto _jump2482;
    _1381 = _183;
    goto _jump2483;
    _jump2482:;
    _a1__a1_bool _1382;
    _1382.d0 = 3;
    _1382.data = jpl_alloc(sizeof(_a1_bool) * 3);
    _1382.data[0] = _183;
    _1382.data[1] = _183;
    _1382.data[2] = _183;
    int64_t _1383;
    // Computing bound for z
    if (_875.d2 > 0) 
    goto _jump2484;
    fail_assertion("non-positive loop bound");
    _jump2484:;
    _1383 = 0;
    int64_t _1384 = 0; // z
    _jump2485:; // Begin body of loop
    _1383 += _183.d0;
    _1384++;
    if (_1384 < _875.d2)
    goto _jump2485;
    // End body of loop
    if (_1383 >= 0)
    goto _jump2486;
    fail_assertion("negative array index");
    _jump2486:;
    if (_1383 < _1382.d0)
    goto _jump2487;
    fail_assertion("index too large");
    _jump2487:;
    int64_t _1385 = 0;
    _1385 *= _1382.d0;
    _1385 += _1383;
    _a1_bool _1386 = _1382.data[_1385];
    _1381 = _1386;
    _jump2483:;
    _1379 = _1381;
    goto _jump2488;
    _jump2481:;
    bool _1387 = true;
    bool _1388;
    if (!_1387)
    goto _jump2489;
    bool _1389 = true;
    _1388 = _1389;
    goto _jump2490;
    _jump2489:;
    bool _1391 = true;
    bool _1390 = _1391;
    if (0 != _1391)
    goto _jump2491;
    bool _1392 = false;
    _1390 = _1392;
    _jump2491:;
    _1388 = _1390;
    _jump2490:;
    bool _1393 = true;
    bool _1394 = false;
    bool _1395 = _1393 != _1394;
    bool _1396;
    if (!_1395)
    goto _jump2492;
    bool _1397 = true;
    _1396 = _1397;
    goto _jump2493;
    _jump2492:;
    bool _1399 = false;
    bool _1398 = _1399;
    if (0 == _1399)
    goto _jump2494;
    bool _1400 = true;
    _1398 = _1400;
    _jump2494:;
    _1396 = _1398;
    _jump2493:;
    _a1_bool _1401;
    _1401.d0 = 2;
    _1401.data = jpl_alloc(sizeof(bool) * 2);
    _1401.data[0] = _1388;
    _1401.data[1] = _1396;
    _1379 = _1401;
    _jump2488:;
    int64_t _1402;
    // Computing bound for z
    int64_t _1403 = _183.d0 - _1034.d0;
    if (_1403 > 0) 
    goto _jump2495;
    fail_assertion("non-positive loop bound");
    _jump2495:;
    _1402 = 0;
    int64_t _1404 = 0; // z
    _jump2496:; // Begin body of loop
    int64_t _1405 = _1180.d0 - _1034.d0;
    _1402 += _1405;
    _1404++;
    if (_1404 < _1403)
    goto _jump2496;
    // End body of loop
    bool _1406 = _1402 != _875.d2;
    int64_t _1407;
    if (!_1406)
    goto _jump2497;
    _1407 = _1204.d0;
    goto _jump2498;
    _jump2497:;
    _1407 = _1034.d1;
    _jump2498:;
    if (_1407 >= 0)
    goto _jump2499;
    fail_assertion("negative array index");
    _jump2499:;
    if (_1407 < _1379.d0)
    goto _jump2500;
    fail_assertion("index too large");
    _jump2500:;
    int64_t _1408 = 0;
    _1408 *= _1379.d0;
    _1408 += _1407;
    bool _1409 = _1379.data[_1408];
    _a3__a2_int64_t _1410;
    if (!_1409)
    goto _jump2501;
    _a3__a2_int64_t _1411;
    // Computing bound for z
    _1411.d0 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2502;
    fail_assertion("non-positive loop bound");
    _jump2502:;
    // Computing bound for A
    _1411.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2503;
    fail_assertion("non-positive loop bound");
    _jump2503:;
    // Computing bound for B
    _1411.d2 = _1180.d0;
    if (_1180.d0 > 0) 
    goto _jump2504;
    fail_assertion("non-positive loop bound");
    _jump2504:;
    // Computing total size of heap memory to allocate
    int64_t _1412 = 1;
    _1412 *= _1180.d1;
    _1412 *= _183.d0;
    _1412 *= _1180.d0;
    _1412 *= sizeof(_a2_int64_t);
    _1411.data = jpl_alloc(_1412);
    int64_t _1413 = 0; // B
    int64_t _1414 = 0; // A
    int64_t _1415 = 0; // z
    _jump2505:; // Begin body of loop
    _a2_int64_t _1416;
    // Computing bound for C
    _1416.d0 = _875.d1;
    if (_875.d1 > 0) 
    goto _jump2506;
    fail_assertion("non-positive loop bound");
    _jump2506:;
    // Computing bound for D
    _1416.d1 = _1180.d2;
    if (_1180.d2 > 0) 
    goto _jump2507;
    fail_assertion("non-positive loop bound");
    _jump2507:;
    // Computing total size of heap memory to allocate
    int64_t _1417 = 1;
    _1417 *= _875.d1;
    _1417 *= _1180.d2;
    _1417 *= sizeof(int64_t);
    _1416.data = jpl_alloc(_1417);
    int64_t _1418 = 0; // D
    int64_t _1419 = 0; // C
    _jump2508:; // Begin body of loop
    int64_t _1420 = 0;
    _1420 *= _1416.d0;
    _1420 += _1419;
    _1420 *= _1416.d1;
    _1420 += _1418;
    _1416.data[_1420] = _1204.d0;
    _1418++;
    if (_1418 < _1180.d2)
    goto _jump2508;
    _1418 = 0;
    _1419++;
    if (_1419 < _875.d1)
    goto _jump2508;
    // End body of loop
    int64_t _1421 = 0;
    _1421 *= _1411.d0;
    _1421 += _1415;
    _1421 *= _1411.d1;
    _1421 += _1414;
    _1421 *= _1411.d2;
    _1421 += _1413;
    _1411.data[_1421] = _1416;
    _1413++;
    if (_1413 < _1180.d0)
    goto _jump2505;
    _1413 = 0;
    _1414++;
    if (_1414 < _183.d0)
    goto _jump2505;
    _1414 = 0;
    _1415++;
    if (_1415 < _1180.d1)
    goto _jump2505;
    // End body of loop
    _1410 = _1411;
    goto _jump2509;
    _jump2501:;
    bool _1422 = true;
    _a3__a3__a2_int64_t _1423;
    if (!_1422)
    goto _jump2510;
    _a3__a3__a2_int64_t _1424;
    // Computing bound for z
    int64_t _1425;
    // Computing bound for z
    int64_t _1426;
    // Computing bound for z
    if (_1180.d1 > 0) 
    goto _jump2511;
    fail_assertion("non-positive loop bound");
    _jump2511:;
    // Computing bound for A
    if (_1034.d1 > 0) 
    goto _jump2512;
    fail_assertion("non-positive loop bound");
    _jump2512:;
    // Computing bound for B
    if (_1180.d1 > 0) 
    goto _jump2513;
    fail_assertion("non-positive loop bound");
    _jump2513:;
    _1426 = 0;
    int64_t _1427 = 0; // B
    int64_t _1428 = 0; // A
    int64_t _1429 = 0; // z
    _jump2514:; // Begin body of loop
    _1426 += _1428;
    _1427++;
    if (_1427 < _1180.d1)
    goto _jump2514;
    _1427 = 0;
    _1428++;
    if (_1428 < _1034.d1)
    goto _jump2514;
    _1428 = 0;
    _1429++;
    if (_1429 < _1180.d1)
    goto _jump2514;
    // End body of loop
    if (_1426 > 0) 
    goto _jump2515;
    fail_assertion("non-positive loop bound");
    _jump2515:;
    _1425 = 0;
    int64_t _1430 = 0; // z
    _jump2516:; // Begin body of loop
    _1425 += _1180.d0;
    _1430++;
    if (_1430 < _1426)
    goto _jump2516;
    // End body of loop
    _1424.d0 = _1425;
    if (_1425 > 0) 
    goto _jump2517;
    fail_assertion("non-positive loop bound");
    _jump2517:;
    // Computing bound for A
    _1424.d1 = _1180.d0;
    if (_1180.d0 > 0) 
    goto _jump2518;
    fail_assertion("non-positive loop bound");
    _jump2518:;
    // Computing bound for B
    _1424.d2 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2519;
    fail_assertion("non-positive loop bound");
    _jump2519:;
    // Computing total size of heap memory to allocate
    int64_t _1431 = 1;
    _1431 *= _1425;
    _1431 *= _1180.d0;
    _1431 *= _875.d2;
    _1431 *= sizeof(_a3__a2_int64_t);
    _1424.data = jpl_alloc(_1431);
    int64_t _1432 = 0; // B
    int64_t _1433 = 0; // A
    int64_t _1434 = 0; // z
    _jump2520:; // Begin body of loop
    _a3__a2_int64_t _1435;
    // Computing bound for C
    _1435.d0 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2521;
    fail_assertion("non-positive loop bound");
    _jump2521:;
    // Computing bound for D
    _1435.d1 = _1432;
    if (_1432 > 0) 
    goto _jump2522;
    fail_assertion("non-positive loop bound");
    _jump2522:;
    // Computing bound for E
    _1435.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2523;
    fail_assertion("non-positive loop bound");
    _jump2523:;
    // Computing total size of heap memory to allocate
    int64_t _1436 = 1;
    _1436 *= _1034.d0;
    _1436 *= _1432;
    _1436 *= _183.d0;
    _1436 *= sizeof(_a2_int64_t);
    _1435.data = jpl_alloc(_1436);
    int64_t _1437 = 0; // E
    int64_t _1438 = 0; // D
    int64_t _1439 = 0; // C
    _jump2524:; // Begin body of loop
    _a2_int64_t _1440;
    // Computing bound for F
    _1440.d0 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2525;
    fail_assertion("non-positive loop bound");
    _jump2525:;
    // Computing bound for G
    int64_t _1441 = 924;
    _1440.d1 = _1441;
    if (_1441 > 0) 
    goto _jump2526;
    fail_assertion("non-positive loop bound");
    _jump2526:;
    // Computing total size of heap memory to allocate
    int64_t _1442 = 1;
    _1442 *= _875.d2;
    _1442 *= _1441;
    _1442 *= sizeof(int64_t);
    _1440.data = jpl_alloc(_1442);
    int64_t _1443 = 0; // G
    int64_t _1444 = 0; // F
    _jump2527:; // Begin body of loop
    int64_t _1445 = 0;
    _1445 *= _1440.d0;
    _1445 += _1444;
    _1445 *= _1440.d1;
    _1445 += _1443;
    _1440.data[_1445] = _183.d0;
    _1443++;
    if (_1443 < _1441)
    goto _jump2527;
    _1443 = 0;
    _1444++;
    if (_1444 < _875.d2)
    goto _jump2527;
    // End body of loop
    int64_t _1446 = 0;
    _1446 *= _1435.d0;
    _1446 += _1439;
    _1446 *= _1435.d1;
    _1446 += _1438;
    _1446 *= _1435.d2;
    _1446 += _1437;
    _1435.data[_1446] = _1440;
    _1437++;
    if (_1437 < _183.d0)
    goto _jump2524;
    _1437 = 0;
    _1438++;
    if (_1438 < _1432)
    goto _jump2524;
    _1438 = 0;
    _1439++;
    if (_1439 < _1034.d0)
    goto _jump2524;
    // End body of loop
    int64_t _1447 = 0;
    _1447 *= _1424.d0;
    _1447 += _1434;
    _1447 *= _1424.d1;
    _1447 += _1433;
    _1447 *= _1424.d2;
    _1447 += _1432;
    _1424.data[_1447] = _1435;
    _1432++;
    if (_1432 < _875.d2)
    goto _jump2520;
    _1432 = 0;
    _1433++;
    if (_1433 < _1180.d0)
    goto _jump2520;
    _1433 = 0;
    _1434++;
    if (_1434 < _1425)
    goto _jump2520;
    // End body of loop
    _1423 = _1424;
    goto _jump2528;
    _jump2510:;
    _a3__a3__a2_int64_t _1448;
    // Computing bound for z
    int64_t _1449 = -_1034.d1;
    int64_t _1450 = _875.d0 * _1449;
    _1448.d0 = _1450;
    if (_1450 > 0) 
    goto _jump2529;
    fail_assertion("non-positive loop bound");
    _jump2529:;
    // Computing bound for A
    int64_t _1451 = 61;
    _1448.d1 = _1451;
    if (_1451 > 0) 
    goto _jump2530;
    fail_assertion("non-positive loop bound");
    _jump2530:;
    // Computing bound for B
    _1448.d2 = _1180.d2;
    if (_1180.d2 > 0) 
    goto _jump2531;
    fail_assertion("non-positive loop bound");
    _jump2531:;
    // Computing total size of heap memory to allocate
    int64_t _1452 = 1;
    _1452 *= _1450;
    _1452 *= _1451;
    _1452 *= _1180.d2;
    _1452 *= sizeof(_a3__a2_int64_t);
    _1448.data = jpl_alloc(_1452);
    int64_t _1453 = 0; // B
    int64_t _1454 = 0; // A
    int64_t _1455 = 0; // z
    _jump2532:; // Begin body of loop
    _a3__a2_int64_t _1456;
    // Computing bound for C
    _1456.d0 = _875.d0;
    if (_875.d0 > 0) 
    goto _jump2533;
    fail_assertion("non-positive loop bound");
    _jump2533:;
    // Computing bound for D
    _1456.d1 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2534;
    fail_assertion("non-positive loop bound");
    _jump2534:;
    // Computing bound for E
    _1456.d2 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2535;
    fail_assertion("non-positive loop bound");
    _jump2535:;
    // Computing total size of heap memory to allocate
    int64_t _1457 = 1;
    _1457 *= _875.d0;
    _1457 *= _1180.d1;
    _1457 *= _183.d0;
    _1457 *= sizeof(_a2_int64_t);
    _1456.data = jpl_alloc(_1457);
    int64_t _1458 = 0; // E
    int64_t _1459 = 0; // D
    int64_t _1460 = 0; // C
    _jump2536:; // Begin body of loop
    _a2_int64_t _1461;
    // Computing bound for F
    _1461.d0 = _1458;
    if (_1458 > 0) 
    goto _jump2537;
    fail_assertion("non-positive loop bound");
    _jump2537:;
    // Computing bound for G
    int64_t _1462 = 734;
    _1461.d1 = _1462;
    if (_1462 > 0) 
    goto _jump2538;
    fail_assertion("non-positive loop bound");
    _jump2538:;
    // Computing total size of heap memory to allocate
    int64_t _1463 = 1;
    _1463 *= _1458;
    _1463 *= _1462;
    _1463 *= sizeof(int64_t);
    _1461.data = jpl_alloc(_1463);
    int64_t _1464 = 0; // G
    int64_t _1465 = 0; // F
    _jump2539:; // Begin body of loop
    int64_t _1466 = 0;
    _1466 *= _1461.d0;
    _1466 += _1465;
    _1466 *= _1461.d1;
    _1466 += _1464;
    _1461.data[_1466] = _1180.d0;
    _1464++;
    if (_1464 < _1462)
    goto _jump2539;
    _1464 = 0;
    _1465++;
    if (_1465 < _1458)
    goto _jump2539;
    // End body of loop
    int64_t _1467 = 0;
    _1467 *= _1456.d0;
    _1467 += _1460;
    _1467 *= _1456.d1;
    _1467 += _1459;
    _1467 *= _1456.d2;
    _1467 += _1458;
    _1456.data[_1467] = _1461;
    _1458++;
    if (_1458 < _183.d0)
    goto _jump2536;
    _1458 = 0;
    _1459++;
    if (_1459 < _1180.d1)
    goto _jump2536;
    _1459 = 0;
    _1460++;
    if (_1460 < _875.d0)
    goto _jump2536;
    // End body of loop
    int64_t _1468 = 0;
    _1468 *= _1448.d0;
    _1468 += _1455;
    _1468 *= _1448.d1;
    _1468 += _1454;
    _1468 *= _1448.d2;
    _1468 += _1453;
    _1448.data[_1468] = _1456;
    _1453++;
    if (_1453 < _1180.d2)
    goto _jump2532;
    _1453 = 0;
    _1454++;
    if (_1454 < _1451)
    goto _jump2532;
    _1454 = 0;
    _1455++;
    if (_1455 < _1450)
    goto _jump2532;
    // End body of loop
    _1423 = _1448;
    _jump2528:;
    int64_t _1469 = _1034.d0 + _183.d0;
    if (_1180.d1 >= 0)
    goto _jump2540;
    fail_assertion("negative array index");
    _jump2540:;
    if (_1180.d1 < _1423.d0)
    goto _jump2541;
    fail_assertion("index too large");
    _jump2541:;
    if (_1469 >= 0)
    goto _jump2542;
    fail_assertion("negative array index");
    _jump2542:;
    if (_1469 < _1423.d1)
    goto _jump2543;
    fail_assertion("index too large");
    _jump2543:;
    if (_875.d1 >= 0)
    goto _jump2544;
    fail_assertion("negative array index");
    _jump2544:;
    if (_875.d1 < _1423.d2)
    goto _jump2545;
    fail_assertion("index too large");
    _jump2545:;
    int64_t _1470 = 0;
    _1470 *= _1423.d0;
    _1470 += _1180.d1;
    _1470 *= _1423.d1;
    _1470 += _1469;
    _1470 *= _1423.d2;
    _1470 += _875.d1;
    _a3__a2_int64_t _1471 = _1423.data[_1470];
    _1410 = _1471;
    _jump2509:;
    bool _1473 = false;
    bool _1474 = _183.d0 != _1034.d0;
    bool _1475 = !_1474;
    bool _1476 = _1473 != _1475;
    bool _1477;
    if (!_1476)
    goto _jump2546;
    double _1478 = 49.0;
    double _1479 = 27.0;
    double _1480 = _1479 - _954;
    double _1481 = _1478 + _1480;
    double _1482 = 80.0;
    bool _1483 = _1481 > _1482;
    _1477 = _1483;
    goto _jump2547;
    _jump2546:;
    bool _1485 = _1180.d2 == _1034.d0;
    bool _1484 = _1485;
    if (0 == _1485)
    goto _jump2548;
    bool _1486 = true;
    _1484 = _1486;
    _jump2548:;
    bool _1487 = !_1484;
    _1477 = _1487;
    _jump2547:;
    bool _1472 = _1477;
    if (0 != _1477)
    goto _jump2549;
    _a2_bool _1488;
    // Computing bound for z
    _1488.d0 = _875.d2;
    if (_875.d2 > 0) 
    goto _jump2550;
    fail_assertion("non-positive loop bound");
    _jump2550:;
    // Computing bound for A
    _1488.d1 = _1034.d0;
    if (_1034.d0 > 0) 
    goto _jump2551;
    fail_assertion("non-positive loop bound");
    _jump2551:;
    // Computing total size of heap memory to allocate
    int64_t _1489 = 1;
    _1489 *= _875.d2;
    _1489 *= _1034.d0;
    _1489 *= sizeof(bool);
    _1488.data = jpl_alloc(_1489);
    int64_t _1490 = 0; // A
    int64_t _1491 = 0; // z
    _jump2552:; // Begin body of loop
    _a2_bool _1492;
    // Computing bound for B
    _1492.d0 = _1180.d1;
    if (_1180.d1 > 0) 
    goto _jump2553;
    fail_assertion("non-positive loop bound");
    _jump2553:;
    // Computing bound for C
    _1492.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2554;
    fail_assertion("non-positive loop bound");
    _jump2554:;
    // Computing total size of heap memory to allocate
    int64_t _1493 = 1;
    _1493 *= _1180.d1;
    _1493 *= _183.d0;
    _1493 *= sizeof(bool);
    _1492.data = jpl_alloc(_1493);
    int64_t _1494 = 0; // C
    int64_t _1495 = 0; // B
    _jump2555:; // Begin body of loop
    bool _1496 = false;
    int64_t _1497 = 0;
    _1497 *= _1492.d0;
    _1497 += _1495;
    _1497 *= _1492.d1;
    _1497 += _1494;
    _1492.data[_1497] = _1496;
    _1494++;
    if (_1494 < _183.d0)
    goto _jump2555;
    _1494 = 0;
    _1495++;
    if (_1495 < _1180.d1)
    goto _jump2555;
    // End body of loop
    int64_t _1498 = 66;
    if (_1180.d2 >= 0)
    goto _jump2556;
    fail_assertion("negative array index");
    _jump2556:;
    if (_1180.d2 < _1492.d0)
    goto _jump2557;
    fail_assertion("index too large");
    _jump2557:;
    if (_1498 >= 0)
    goto _jump2558;
    fail_assertion("negative array index");
    _jump2558:;
    if (_1498 < _1492.d1)
    goto _jump2559;
    fail_assertion("index too large");
    _jump2559:;
    int64_t _1499 = 0;
    _1499 *= _1492.d0;
    _1499 += _1180.d2;
    _1499 *= _1492.d1;
    _1499 += _1498;
    bool _1500 = _1492.data[_1499];
    int64_t _1501 = 0;
    _1501 *= _1488.d0;
    _1501 += _1491;
    _1501 *= _1488.d1;
    _1501 += _1490;
    _1488.data[_1501] = _1500;
    _1490++;
    if (_1490 < _1034.d0)
    goto _jump2552;
    _1490 = 0;
    _1491++;
    if (_1491 < _875.d2)
    goto _jump2552;
    // End body of loop
    int64_t _1502 = 915;
    if (_1180.d0 >= 0)
    goto _jump2560;
    fail_assertion("negative array index");
    _jump2560:;
    if (_1180.d0 < _1488.d0)
    goto _jump2561;
    fail_assertion("index too large");
    _jump2561:;
    if (_1502 >= 0)
    goto _jump2562;
    fail_assertion("negative array index");
    _jump2562:;
    if (_1502 < _1488.d1)
    goto _jump2563;
    fail_assertion("index too large");
    _jump2563:;
    int64_t _1503 = 0;
    _1503 *= _1488.d0;
    _1503 += _1180.d0;
    _1503 *= _1488.d1;
    _1503 += _1502;
    bool _1504 = _1488.data[_1503];
    _1472 = _1504;
    _jump2549:;
    int64_t _1505;
    if (!_1472)
    goto _jump2564;
    _1505 = _1034.d0;
    goto _jump2565;
    _jump2564:;
    _1505 = _1180.d2;
    _jump2565:;
    if (_183.d0 >= 0)
    goto _jump2566;
    fail_assertion("negative array index");
    _jump2566:;
    if (_183.d0 < _1410.d0)
    goto _jump2567;
    fail_assertion("index too large");
    _jump2567:;
    if (_875.d2 >= 0)
    goto _jump2568;
    fail_assertion("negative array index");
    _jump2568:;
    if (_875.d2 < _1410.d1)
    goto _jump2569;
    fail_assertion("index too large");
    _jump2569:;
    if (_1505 >= 0)
    goto _jump2570;
    fail_assertion("negative array index");
    _jump2570:;
    if (_1505 < _1410.d2)
    goto _jump2571;
    fail_assertion("index too large");
    _jump2571:;
    int64_t _1506 = 0;
    _1506 *= _1410.d0;
    _1506 += _183.d0;
    _1506 *= _1410.d1;
    _1506 += _875.d2;
    _1506 *= _1410.d2;
    _1506 += _1505;
    _a2_int64_t _1507 = _1410.data[_1506];
    _a2_rgba _1508 = read_image("C.png");
    _a2_int64_t _1509;
    // Computing bound for D
    bool _1510 = true;
    int64_t _1511;
    if (!_1510)
    goto _jump2572;
    int64_t _1512 = 781;
    _1511 = _1512;
    goto _jump2573;
    _jump2572:;
    _1511 = _1507.d0;
    _jump2573:;
    int64_t _1513 = _1511 + _875.d1;
    _1509.d0 = _1513;
    if (_1513 > 0) 
    goto _jump2574;
    fail_assertion("non-positive loop bound");
    _jump2574:;
    // Computing bound for E
    _1509.d1 = _183.d0;
    if (_183.d0 > 0) 
    goto _jump2575;
    fail_assertion("non-positive loop bound");
    _jump2575:;
    // Computing total size of heap memory to allocate
    int64_t _1514 = 1;
    _1514 *= _1513;
    _1514 *= _183.d0;
    _1514 *= sizeof(int64_t);
    _1509.data = jpl_alloc(_1514);
    int64_t _1515 = 0; // E
    int64_t _1516 = 0; // D
    _jump2576:; // Begin body of loop
    int64_t _1517 = 0;
    _1517 *= _1509.d0;
    _1517 += _1516;
    _1517 *= _1509.d1;
    _1517 += _1515;
    _1509.data[_1517] = _1180.d2;
    _1515++;
    if (_1515 < _183.d0)
    goto _jump2576;
    _1515 = 0;
    _1516++;
    if (_1516 < _1513)
    goto _jump2576;
    // End body of loop
    bool _1518 = _875.d2 >= _183.d0;
}

