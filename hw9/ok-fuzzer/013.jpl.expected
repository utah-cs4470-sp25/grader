
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_double *data;
} _a2__a3_double;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  _a2__a3_int64_t *data;
} _a1__a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_double *data;
} _a2__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_bool *data;
} _a2__a2_bool;

typedef struct {
  int64_t d0;
  _a2__a2_bool *data;
} _a1__a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a2_bool *data;
} _a2__a2__a2_bool;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_int64_t *data;
} _a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a1_int64_t *data;
} _a3__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2__a1_int64_t *data;
} _a1__a2__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  void_t *data;
} _a2_void_t;

typedef struct {
  int64_t d0;
  _a2_double *data;
} _a1__a2_double;

typedef struct {
  int64_t d0;
  _a2_void_t *data;
} _a1__a2_void_t;

typedef struct {
  int64_t d0;
  _a2_int64_t *data;
} _a1__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_void_t *data;
} _a2__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2_void_t *data;
} _a3__a2__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  _a3__a3_int64_t *data;
} _a1__a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_int64_t *data;
} _a2__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a3_int64_t *data;
} _a2__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  _a1__a2_void_t *data;
} _a1__a1__a2_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_double *data;
} _a3__a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a2_bool *data;
} _a3__a2__a2_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  _a1_double *data;
} _a1__a1_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1_double *data;
} _a3__a1__a1_double;

typedef struct {
    _a3_bool a;
    bool b;
    double c;
} W;

double D(_a2_double E, _a3_int64_t H) {
    double _0;
    // Computing bound for L
    if (h > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing bound for M
    if (H.d0 > 0) 
    goto _jump525;
    fail_assertion("non-positive loop bound");
    _jump525:;
    _0 = 0;
    int64_t _1 = 0; // M
    int64_t _2 = 0; // L
    _jump526:; // Begin body of loop
    bool _3 = H.d2 == E.d0;
    double _4;
    if (!_3)
    goto _jump527;
    double _5;
    // Computing bound for N
    if (z > 0) 
    goto _jump528;
    fail_assertion("non-positive loop bound");
    _jump528:;
    // Computing bound for O
    int64_t _6 = -b;
    if (_6 > 0) 
    goto _jump529;
    fail_assertion("non-positive loop bound");
    _jump529:;
    // Computing bound for P
    if (A > 0) 
    goto _jump530;
    fail_assertion("non-positive loop bound");
    _jump530:;
    _5 = 0;
    int64_t _7 = 0; // P
    int64_t _8 = 0; // O
    int64_t _9 = 0; // N
    _jump531:; // Begin body of loop
    _5 += C;
    _7++;
    if (_7 < A)
    goto _jump531;
    _7 = 0;
    _8++;
    if (_8 < _6)
    goto _jump531;
    _8 = 0;
    _9++;
    if (_9 < z)
    goto _jump531;
    // End body of loop
    _4 = _5;
    goto _jump532;
    _jump527:;
    if (o >= 0)
    goto _jump533;
    fail_assertion("negative array index");
    _jump533:;
    if (o < x.d0)
    goto _jump534;
    fail_assertion("index too large");
    _jump534:;
    if (t >= 0)
    goto _jump535;
    fail_assertion("negative array index");
    _jump535:;
    if (t < x.d1)
    goto _jump536;
    fail_assertion("index too large");
    _jump536:;
    int64_t _10 = 0;
    _10 *= x.d0;
    _10 += o;
    _10 *= x.d1;
    _10 += t;
    bool _11 = x.data[_10];
    bool _12 = i != _11;
    double _13;
    if (!_12)
    goto _jump537;
    double _14 = D(E, H);
    double _15 = -_14;
    _13 = _15;
    goto _jump538;
    _jump537:;
    double _16;
    // Computing bound for N
    if (_2 > 0) 
    goto _jump539;
    fail_assertion("non-positive loop bound");
    _jump539:;
    // Computing bound for O
    if (b > 0) 
    goto _jump540;
    fail_assertion("non-positive loop bound");
    _jump540:;
    // Computing bound for P
    if (k > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    _16 = 0;
    int64_t _17 = 0; // P
    int64_t _18 = 0; // O
    int64_t _19 = 0; // N
    _jump542:; // Begin body of loop
    double _20;
    // Computing bound for Q
    if (b > 0) 
    goto _jump543;
    fail_assertion("non-positive loop bound");
    _jump543:;
    // Computing bound for R
    if (t > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for S
    if (m > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    _20 = 0;
    int64_t _21 = 0; // S
    int64_t _22 = 0; // R
    int64_t _23 = 0; // Q
    _jump546:; // Begin body of loop
    _20 += C;
    _21++;
    if (_21 < m)
    goto _jump546;
    _21 = 0;
    _22++;
    if (_22 < t)
    goto _jump546;
    _22 = 0;
    _23++;
    if (_23 < b)
    goto _jump546;
    // End body of loop
    _16 += _20;
    _17++;
    if (_17 < k)
    goto _jump542;
    _17 = 0;
    _18++;
    if (_18 < b)
    goto _jump542;
    _18 = 0;
    _19++;
    if (_19 < _2)
    goto _jump542;
    // End body of loop
    _13 = _16;
    _jump538:;
    _4 = _13;
    _jump532:;
    _0 += _4;
    _1++;
    if (_1 < H.d0)
    goto _jump526;
    _1 = 0;
    _2++;
    if (_2 < h)
    goto _jump526;
    // End body of loop
    bool _24 = _0 == C;
    _a3_int64_t _25;
    if (!_24)
    goto _jump547;
    _25 = j;
    goto _jump548;
    _jump547:;
    _25 = H;
    _jump548:;
    double _26;
    // Computing bound for T
    if (w > 0) 
    goto _jump549;
    fail_assertion("non-positive loop bound");
    _jump549:;
    // Computing bound for U
    if (H.d2 > 0) 
    goto _jump550;
    fail_assertion("non-positive loop bound");
    _jump550:;
    _26 = 0;
    int64_t _27 = 0; // U
    int64_t _28 = 0; // T
    _jump551:; // Begin body of loop
    double _29 = D(E, e);
    _26 += _29;
    _27++;
    if (_27 < H.d2)
    goto _jump551;
    _27 = 0;
    _28++;
    if (_28 < w)
    goto _jump551;
    // End body of loop
    double _30 = 67.0;
    _a1_double _31;
    _31.d0 = 2;
    _31.data = jpl_alloc(sizeof(double) * 2);
    _31.data[0] = _26;
    _31.data[1] = _30;
    if (H.d2 >= 0)
    goto _jump552;
    fail_assertion("negative array index");
    _jump552:;
    if (H.d2 < _31.d0)
    goto _jump553;
    fail_assertion("index too large");
    _jump553:;
    int64_t _32 = 0;
    _32 *= _31.d0;
    _32 += H.d2;
    double _33 = _31.data[_32];
    rgba _34;
    if (!B)
    goto _jump554;
    double _35 = 67.0;
    double _36 = D(E, H);
    double _37 = 2.0;
    rgba _38 = { _35, _36, _37, C };
    _34 = _38;
    goto _jump555;
    _jump554:;
    if (H.d2 >= 0)
    goto _jump556;
    fail_assertion("negative array index");
    _jump556:;
    if (H.d2 < E.d0)
    goto _jump557;
    fail_assertion("index too large");
    _jump557:;
    if (H.d1 >= 0)
    goto _jump558;
    fail_assertion("negative array index");
    _jump558:;
    if (H.d1 < E.d1)
    goto _jump559;
    fail_assertion("index too large");
    _jump559:;
    int64_t _39 = 0;
    _39 *= E.d0;
    _39 += H.d2;
    _39 *= E.d1;
    _39 += H.d1;
    double _40 = E.data[_39];
    double _41 = 62.0;
    double _42 = 97.0;
    double _43 = -_42;
    double _44 = 0.0;
    rgba _45 = { _40, _41, _43, _44 };
    _34 = _45;
    _jump555:;
    double _46 = _34.a;
    double _47 = _33 - _46;
    double _48 = 13.0;
    bool _49 = _47 < _48;
    _a1_int64_t _50;
    if (!_49)
    goto _jump560;
    _a1_int64_t _51;
    // Computing bound for T
    _a1_bool _52;
    // Computing bound for T
    _52.d0 = _25.d0;
    if (_25.d0 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= _25.d0;
    _53 *= sizeof(bool);
    _52.data = jpl_alloc(_53);
    int64_t _54 = 0; // T
    _jump562:; // Begin body of loop
    int64_t _55 = 0;
    _55 *= _52.d0;
    _55 += _54;
    _52.data[_55] = i;
    _54++;
    if (_54 < _25.d0)
    goto _jump562;
    // End body of loop
    if (y >= 0)
    goto _jump563;
    fail_assertion("negative array index");
    _jump563:;
    if (y < _52.d0)
    goto _jump564;
    fail_assertion("index too large");
    _jump564:;
    int64_t _56 = 0;
    _56 *= _52.d0;
    _56 += y;
    bool _57 = _52.data[_56];
    bool _58;
    if (!_57)
    goto _jump565;
    _a3_bool _59;
    // Computing bound for T
    _59.d0 = z;
    if (z > 0) 
    goto _jump566;
    fail_assertion("non-positive loop bound");
    _jump566:;
    // Computing bound for U
    _59.d1 = r;
    if (r > 0) 
    goto _jump567;
    fail_assertion("non-positive loop bound");
    _jump567:;
    // Computing bound for V
    _59.d2 = c;
    if (c > 0) 
    goto _jump568;
    fail_assertion("non-positive loop bound");
    _jump568:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= z;
    _60 *= r;
    _60 *= c;
    _60 *= sizeof(bool);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // V
    int64_t _62 = 0; // U
    int64_t _63 = 0; // T
    _jump569:; // Begin body of loop
    bool _64 = false;
    int64_t _65 = 0;
    _65 *= _59.d0;
    _65 += _63;
    _65 *= _59.d1;
    _65 += _62;
    _65 *= _59.d2;
    _65 += _61;
    _59.data[_65] = _64;
    _61++;
    if (_61 < c)
    goto _jump569;
    _61 = 0;
    _62++;
    if (_62 < r)
    goto _jump569;
    _62 = 0;
    _63++;
    if (_63 < z)
    goto _jump569;
    // End body of loop
    int64_t _66 = 451;
    if (_66 >= 0)
    goto _jump570;
    fail_assertion("negative array index");
    _jump570:;
    if (_66 < _59.d0)
    goto _jump571;
    fail_assertion("index too large");
    _jump571:;
    if (H.d2 >= 0)
    goto _jump572;
    fail_assertion("negative array index");
    _jump572:;
    if (H.d2 < _59.d1)
    goto _jump573;
    fail_assertion("index too large");
    _jump573:;
    if (H.d0 >= 0)
    goto _jump574;
    fail_assertion("negative array index");
    _jump574:;
    if (H.d0 < _59.d2)
    goto _jump575;
    fail_assertion("index too large");
    _jump575:;
    int64_t _67 = 0;
    _67 *= _59.d0;
    _67 += _66;
    _67 *= _59.d1;
    _67 += H.d2;
    _67 *= _59.d2;
    _67 += H.d0;
    bool _68 = _59.data[_67];
    _58 = _68;
    goto _jump576;
    _jump565:;
    if (m >= 0)
    goto _jump577;
    fail_assertion("negative array index");
    _jump577:;
    if (m < n.d0)
    goto _jump578;
    fail_assertion("index too large");
    _jump578:;
    if (z >= 0)
    goto _jump579;
    fail_assertion("negative array index");
    _jump579:;
    if (z < n.d1)
    goto _jump580;
    fail_assertion("index too large");
    _jump580:;
    int64_t _70 = 0;
    _70 *= n.d0;
    _70 += m;
    _70 *= n.d1;
    _70 += z;
    bool _71 = n.data[_70];
    bool _69 = _71;
    if (0 != _71)
    goto _jump581;
    _69 = i;
    _jump581:;
    _58 = _69;
    _jump576:;
    _a2_int64_t _72;
    if (!_58)
    goto _jump582;
    _a2_int64_t _73;
    // Computing bound for T
    _73.d0 = y;
    if (y > 0) 
    goto _jump583;
    fail_assertion("non-positive loop bound");
    _jump583:;
    // Computing bound for U
    _73.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump584;
    fail_assertion("non-positive loop bound");
    _jump584:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= y;
    _74 *= H.d0;
    _74 *= sizeof(int64_t);
    _73.data = jpl_alloc(_74);
    int64_t _75 = 0; // U
    int64_t _76 = 0; // T
    _jump585:; // Begin body of loop
    int64_t _77 = 0;
    _77 *= _73.d0;
    _77 += _76;
    _77 *= _73.d1;
    _77 += _75;
    _73.data[_77] = k;
    _75++;
    if (_75 < H.d0)
    goto _jump585;
    _75 = 0;
    _76++;
    if (_76 < y)
    goto _jump585;
    // End body of loop
    _72 = _73;
    goto _jump586;
    _jump582:;
    _a2_int64_t _78;
    if (!B)
    goto _jump587;
    bool _79 = H.d2 != H.d2;
    _a2_int64_t _80;
    if (!_79)
    goto _jump588;
    _a2_int64_t _81;
    // Computing bound for T
    _81.d0 = g;
    if (g > 0) 
    goto _jump589;
    fail_assertion("non-positive loop bound");
    _jump589:;
    // Computing bound for U
    _81.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing total size of heap memory to allocate
    int64_t _82 = 1;
    _82 *= g;
    _82 *= H.d0;
    _82 *= sizeof(int64_t);
    _81.data = jpl_alloc(_82);
    int64_t _83 = 0; // U
    int64_t _84 = 0; // T
    _jump591:; // Begin body of loop
    int64_t _85 = 0;
    _85 *= _81.d0;
    _85 += _84;
    _85 *= _81.d1;
    _85 += _83;
    _81.data[_85] = H.d2;
    _83++;
    if (_83 < H.d0)
    goto _jump591;
    _83 = 0;
    _84++;
    if (_84 < g)
    goto _jump591;
    // End body of loop
    _80 = _81;
    goto _jump592;
    _jump588:;
    _a2_int64_t _86;
    // Computing bound for T
    _86.d0 = m;
    if (m > 0) 
    goto _jump593;
    fail_assertion("non-positive loop bound");
    _jump593:;
    // Computing bound for U
    _86.d1 = c;
    if (c > 0) 
    goto _jump594;
    fail_assertion("non-positive loop bound");
    _jump594:;
    // Computing total size of heap memory to allocate
    int64_t _87 = 1;
    _87 *= m;
    _87 *= c;
    _87 *= sizeof(int64_t);
    _86.data = jpl_alloc(_87);
    int64_t _88 = 0; // U
    int64_t _89 = 0; // T
    _jump595:; // Begin body of loop
    int64_t _90 = 0;
    _90 *= _86.d0;
    _90 += _89;
    _90 *= _86.d1;
    _90 += _88;
    _86.data[_90] = _25.d2;
    _88++;
    if (_88 < c)
    goto _jump595;
    _88 = 0;
    _89++;
    if (_89 < m)
    goto _jump595;
    // End body of loop
    _80 = _86;
    _jump592:;
    _78 = _80;
    goto _jump596;
    _jump587:;
    _a2_int64_t _91;
    // Computing bound for T
    _91.d0 = m;
    if (m > 0) 
    goto _jump597;
    fail_assertion("non-positive loop bound");
    _jump597:;
    // Computing bound for U
    _91.d1 = E.d1;
    if (E.d1 > 0) 
    goto _jump598;
    fail_assertion("non-positive loop bound");
    _jump598:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= m;
    _92 *= E.d1;
    _92 *= sizeof(int64_t);
    _91.data = jpl_alloc(_92);
    int64_t _93 = 0; // U
    int64_t _94 = 0; // T
    _jump599:; // Begin body of loop
    int64_t _95 = 0;
    _95 *= _91.d0;
    _95 += _94;
    _95 *= _91.d1;
    _95 += _93;
    _91.data[_95] = H.d0;
    _93++;
    if (_93 < E.d1)
    goto _jump599;
    _93 = 0;
    _94++;
    if (_94 < m)
    goto _jump599;
    // End body of loop
    _78 = _91;
    _jump596:;
    _72 = _78;
    _jump586:;
    if (f >= 0)
    goto _jump600;
    fail_assertion("negative array index");
    _jump600:;
    if (f < _72.d0)
    goto _jump601;
    fail_assertion("index too large");
    _jump601:;
    if (m >= 0)
    goto _jump602;
    fail_assertion("negative array index");
    _jump602:;
    if (m < _72.d1)
    goto _jump603;
    fail_assertion("index too large");
    _jump603:;
    int64_t _96 = 0;
    _96 *= _72.d0;
    _96 += f;
    _96 *= _72.d1;
    _96 += m;
    int64_t _97 = _72.data[_96];
    _51.d0 = _97;
    if (_97 > 0) 
    goto _jump604;
    fail_assertion("non-positive loop bound");
    _jump604:;
    // Computing total size of heap memory to allocate
    int64_t _98 = 1;
    _98 *= _97;
    _98 *= sizeof(int64_t);
    _51.data = jpl_alloc(_98);
    int64_t _99 = 0; // T
    _jump605:; // Begin body of loop
    int64_t _100 = 0;
    _100 *= _51.d0;
    _100 += _99;
    _51.data[_100] = c;
    _99++;
    if (_99 < _97)
    goto _jump605;
    // End body of loop
    _50 = _51;
    goto _jump606;
    _jump560:;
    _a1_int64_t _101;
    _101.d0 = 3;
    _101.data = jpl_alloc(sizeof(int64_t) * 3);
    _101.data[0] = A;
    _101.data[1] = t;
    _101.data[2] = o;
    _a1_int64_t _102;
    // Computing bound for T
    _102.d0 = h;
    if (h > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    // Computing total size of heap memory to allocate
    int64_t _103 = 1;
    _103 *= h;
    _103 *= sizeof(int64_t);
    _102.data = jpl_alloc(_103);
    int64_t _104 = 0; // T
    _jump608:; // Begin body of loop
    int64_t _105 = 0;
    _105 *= _102.d0;
    _105 += _104;
    _102.data[_105] = E.d0;
    _104++;
    if (_104 < h)
    goto _jump608;
    // End body of loop
    _a1_int64_t _106;
    _106.d0 = 3;
    _106.data = jpl_alloc(sizeof(int64_t) * 3);
    _106.data[0] = H.d2;
    _106.data[1] = r;
    _106.data[2] = t;
    _a1__a1_int64_t _107;
    _107.d0 = 3;
    _107.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _107.data[0] = _101;
    _107.data[1] = _102;
    _107.data[2] = _106;
    if (r >= 0)
    goto _jump609;
    fail_assertion("negative array index");
    _jump609:;
    if (r < _107.d0)
    goto _jump610;
    fail_assertion("index too large");
    _jump610:;
    int64_t _108 = 0;
    _108 *= _107.d0;
    _108 += r;
    _a1_int64_t _109 = _107.data[_108];
    _a1__a1_int64_t _110;
    _110.d0 = 1;
    _110.data = jpl_alloc(sizeof(_a1_int64_t) * 1);
    _110.data[0] = _109;
    if (_25.d0 >= 0)
    goto _jump611;
    fail_assertion("negative array index");
    _jump611:;
    if (_25.d0 < _110.d0)
    goto _jump612;
    fail_assertion("index too large");
    _jump612:;
    int64_t _111 = 0;
    _111 *= _110.d0;
    _111 += _25.d0;
    _a1_int64_t _112 = _110.data[_111];
    _50 = _112;
    _jump606:;
    _a2_int64_t _113;
    // Computing bound for W
    _113.d0 = p;
    if (p > 0) 
    goto _jump613;
    fail_assertion("non-positive loop bound");
    _jump613:;
    // Computing bound for X
    _113.d1 = y;
    if (y > 0) 
    goto _jump614;
    fail_assertion("non-positive loop bound");
    _jump614:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= p;
    _114 *= y;
    _114 *= sizeof(int64_t);
    _113.data = jpl_alloc(_114);
    int64_t _115 = 0; // X
    int64_t _116 = 0; // W
    _jump615:; // Begin body of loop
    int64_t _117 = 0;
    _117 *= _113.d0;
    _117 += _116;
    _117 *= _113.d1;
    _117 += _115;
    _113.data[_117] = _25.d2;
    _115++;
    if (_115 < y)
    goto _jump615;
    _115 = 0;
    _116++;
    if (_116 < p)
    goto _jump615;
    // End body of loop
    int64_t _118 = H.d2 + H.d0;
    _a1_bool _120;
    _120.d0 = 2;
    _120.data = jpl_alloc(sizeof(bool) * 2);
    _120.data[0] = B;
    _120.data[1] = i;
    if (w >= 0)
    goto _jump616;
    fail_assertion("negative array index");
    _jump616:;
    if (w < _120.d0)
    goto _jump617;
    fail_assertion("index too large");
    _jump617:;
    int64_t _121 = 0;
    _121 *= _120.d0;
    _121 += w;
    bool _122 = _120.data[_121];
    bool _119 = _122;
    if (0 == _122)
    goto _jump618;
    bool _125 = true;
    bool _124 = _125;
    if (0 != _125)
    goto _jump619;
    bool _126 = false;
    _124 = _126;
    _jump619:;
    bool _127 = !_124;
    bool _123 = _127;
    if (0 == _127)
    goto _jump620;
    bool _128 = _25.d1 >= t;
    _123 = _128;
    _jump620:;
    _119 = _123;
    _jump618:;
    _a1_rgba _129;
    if (!_119)
    goto _jump621;
    _a1_rgba _130;
    // Computing bound for aa
    _130.d0 = _25.d0;
    if (_25.d0 > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    // Computing total size of heap memory to allocate
    int64_t _131 = 1;
    _131 *= _25.d0;
    _131 *= sizeof(rgba);
    _130.data = jpl_alloc(_131);
    int64_t _132 = 0; // aa
    _jump623:; // Begin body of loop
    _a1_rgba _133;
    // Computing bound for ab
    int64_t _134;
    // Computing bound for ab
    if (_132 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    // Computing bound for ac
    if (p > 0) 
    goto _jump625;
    fail_assertion("non-positive loop bound");
    _jump625:;
    // Computing bound for ad
    if (d > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    _134 = 0;
    int64_t _135 = 0; // ad
    int64_t _136 = 0; // ac
    int64_t _137 = 0; // ab
    _jump627:; // Begin body of loop
    _134 += _132;
    _135++;
    if (_135 < d)
    goto _jump627;
    _135 = 0;
    _136++;
    if (_136 < p)
    goto _jump627;
    _136 = 0;
    _137++;
    if (_137 < _132)
    goto _jump627;
    // End body of loop
    _133.d0 = _134;
    if (_134 > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    // Computing total size of heap memory to allocate
    int64_t _138 = 1;
    _138 *= _134;
    _138 *= sizeof(rgba);
    _133.data = jpl_alloc(_138);
    int64_t _139 = 0; // ab
    _jump629:; // Begin body of loop
    double _140 = 98.0;
    double _141 = 79.0;
    double _142 = 48.0;
    rgba _143 = { _140, _141, _142, C };
    int64_t _144 = 0;
    _144 *= _133.d0;
    _144 += _139;
    _133.data[_144] = _143;
    _139++;
    if (_139 < _134)
    goto _jump629;
    // End body of loop
    if (f >= 0)
    goto _jump630;
    fail_assertion("negative array index");
    _jump630:;
    if (f < _133.d0)
    goto _jump631;
    fail_assertion("index too large");
    _jump631:;
    int64_t _145 = 0;
    _145 *= _133.d0;
    _145 += f;
    rgba _146 = _133.data[_145];
    int64_t _147 = 0;
    _147 *= _130.d0;
    _147 += _132;
    _130.data[_147] = _146;
    _132++;
    if (_132 < _25.d0)
    goto _jump623;
    // End body of loop
    _129 = _130;
    goto _jump632;
    _jump621:;
    if (_118 >= 0)
    goto _jump633;
    fail_assertion("negative array index");
    _jump633:;
    if (_118 < E.d0)
    goto _jump634;
    fail_assertion("index too large");
    _jump634:;
    if (p >= 0)
    goto _jump635;
    fail_assertion("negative array index");
    _jump635:;
    if (p < E.d1)
    goto _jump636;
    fail_assertion("index too large");
    _jump636:;
    int64_t _148 = 0;
    _148 *= E.d0;
    _148 += _118;
    _148 *= E.d1;
    _148 += p;
    double _149 = E.data[_148];
    if (t >= 0)
    goto _jump637;
    fail_assertion("negative array index");
    _jump637:;
    if (t < E.d0)
    goto _jump638;
    fail_assertion("index too large");
    _jump638:;
    if (b >= 0)
    goto _jump639;
    fail_assertion("negative array index");
    _jump639:;
    if (b < E.d1)
    goto _jump640;
    fail_assertion("index too large");
    _jump640:;
    int64_t _150 = 0;
    _150 *= E.d0;
    _150 += t;
    _150 *= E.d1;
    _150 += b;
    double _151 = E.data[_150];
    double _152 = 21.0;
    double _153 = 99.0;
    rgba _154 = { _149, _151, _152, _153 };
    double _155 = -C;
    double _156 = 43.0;
    bool _157 = _156 <= C;
    double _158;
    if (!_157)
    goto _jump641;
    double _159 = 23.0;
    _158 = _159;
    goto _jump642;
    _jump641:;
    double _160;
    if (!B)
    goto _jump643;
    _160 = C;
    goto _jump644;
    _jump643:;
    double _161 = 31.0;
    _160 = _161;
    _jump644:;
    _158 = _160;
    _jump642:;
    _a2_double _162;
    if (!i)
    goto _jump645;
    _162 = E;
    goto _jump646;
    _jump645:;
    _162 = E;
    _jump646:;
    double _163 = D(_162, H);
    rgba _164 = { _155, _158, _163, C };
    double _165 = 74.0;
    bool _166 = true;
    double _167;
    if (!_166)
    goto _jump647;
    _167 = C;
    goto _jump648;
    _jump647:;
    if (_50.d0 >= 0)
    goto _jump649;
    fail_assertion("negative array index");
    _jump649:;
    if (_50.d0 < E.d0)
    goto _jump650;
    fail_assertion("index too large");
    _jump650:;
    if (b >= 0)
    goto _jump651;
    fail_assertion("negative array index");
    _jump651:;
    if (b < E.d1)
    goto _jump652;
    fail_assertion("index too large");
    _jump652:;
    int64_t _168 = 0;
    _168 *= E.d0;
    _168 += _50.d0;
    _168 *= E.d1;
    _168 += b;
    double _169 = E.data[_168];
    _167 = _169;
    _jump648:;
    _a3_int64_t _170;
    // Computing bound for aa
    _170.d0 = m;
    if (m > 0) 
    goto _jump653;
    fail_assertion("non-positive loop bound");
    _jump653:;
    // Computing bound for ab
    _170.d1 = H.d2;
    if (H.d2 > 0) 
    goto _jump654;
    fail_assertion("non-positive loop bound");
    _jump654:;
    // Computing bound for ac
    _170.d2 = r;
    if (r > 0) 
    goto _jump655;
    fail_assertion("non-positive loop bound");
    _jump655:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= m;
    _171 *= H.d2;
    _171 *= r;
    _171 *= sizeof(int64_t);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // ac
    int64_t _173 = 0; // ab
    int64_t _174 = 0; // aa
    _jump656:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _170.d0;
    _175 += _174;
    _175 *= _170.d1;
    _175 += _173;
    _175 *= _170.d2;
    _175 += _172;
    _170.data[_175] = A;
    _172++;
    if (_172 < r)
    goto _jump656;
    _172 = 0;
    _173++;
    if (_173 < H.d2)
    goto _jump656;
    _173 = 0;
    _174++;
    if (_174 < m)
    goto _jump656;
    // End body of loop
    double _176 = D(E, _170);
    double _177 = 26.0;
    double _178 = -_177;
    rgba _179 = { _165, _167, _176, _178 };
    _a1_rgba _180;
    _180.d0 = 3;
    _180.data = jpl_alloc(sizeof(rgba) * 3);
    _180.data[0] = _154;
    _180.data[1] = _164;
    _180.data[2] = _179;
    _129 = _180;
    _jump632:;
    if (H.d2 >= 0)
    goto _jump657;
    fail_assertion("negative array index");
    _jump657:;
    if (H.d2 < _129.d0)
    goto _jump658;
    fail_assertion("index too large");
    _jump658:;
    int64_t _181 = 0;
    _181 *= _129.d0;
    _181 += H.d2;
    rgba _182 = _129.data[_181];
    double _183 = _182.g;
    return _183;
}

_a2_void_t G(_a2_double H) {
    bool _1 = p > h;
    bool _2 = !_1;
    bool _0 = _2;
    if (0 == _2)
    goto _jump693;
    bool _3 = B;
    if (0 == B)
    goto _jump694;
    bool _4 = false;
    _3 = _4;
    _jump694:;
    _0 = _3;
    _jump693:;
    bool _5 = !_0;
    _a2_void_t _6;
    if (!_5)
    goto _jump695;
    if (v >= 0)
    goto _jump696;
    fail_assertion("negative array index");
    _jump696:;
    if (v < u.d0)
    goto _jump697;
    fail_assertion("index too large");
    _jump697:;
    if (s >= 0)
    goto _jump698;
    fail_assertion("negative array index");
    _jump698:;
    if (s < u.d1)
    goto _jump699;
    fail_assertion("index too large");
    _jump699:;
    int64_t _7 = 0;
    _7 *= u.d0;
    _7 += v;
    _7 *= u.d1;
    _7 += s;
    bool _8 = u.data[_7];
    bool _9 = !_8;
    _a2_void_t _10;
    if (!_9)
    goto _jump700;
    _a3_bool _11;
    // Computing bound for L
    int64_t _12;
    // Computing bound for L
    bool _13 = true;
    int64_t _14;
    if (!_13)
    goto _jump701;
    _14 = F;
    goto _jump702;
    _jump701:;
    _14 = y;
    _jump702:;
    if (_14 > 0) 
    goto _jump703;
    fail_assertion("non-positive loop bound");
    _jump703:;
    // Computing bound for M
    if (h > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for N
    if (o > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    _12 = 0;
    int64_t _15 = 0; // N
    int64_t _16 = 0; // M
    int64_t _17 = 0; // L
    _jump706:; // Begin body of loop
    _12 += f;
    _15++;
    if (_15 < o)
    goto _jump706;
    _15 = 0;
    _16++;
    if (_16 < h)
    goto _jump706;
    _16 = 0;
    _17++;
    if (_17 < _14)
    goto _jump706;
    // End body of loop
    _11.d0 = _12;
    if (_12 > 0) 
    goto _jump707;
    fail_assertion("non-positive loop bound");
    _jump707:;
    // Computing bound for M
    _11.d1 = t;
    if (t > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    // Computing bound for N
    int64_t _18;
    if (!B)
    goto _jump709;
    _18 = b;
    goto _jump710;
    _jump709:;
    _18 = h;
    _jump710:;
    _11.d2 = _18;
    if (_18 > 0) 
    goto _jump711;
    fail_assertion("non-positive loop bound");
    _jump711:;
    // Computing total size of heap memory to allocate
    int64_t _19 = 1;
    _19 *= _12;
    _19 *= t;
    _19 *= _18;
    _19 *= sizeof(bool);
    _11.data = jpl_alloc(_19);
    int64_t _20 = 0; // N
    int64_t _21 = 0; // M
    int64_t _22 = 0; // L
    _jump712:; // Begin body of loop
    bool _23 = _21 == y;
    bool _24;
    if (!_23)
    goto _jump713;
    bool _25 = false;
    _24 = _25;
    goto _jump714;
    _jump713:;
    bool _26 = false;
    _24 = _26;
    _jump714:;
    int64_t _27 = 0;
    _27 *= _11.d0;
    _27 += _22;
    _27 *= _11.d1;
    _27 += _21;
    _27 *= _11.d2;
    _27 += _20;
    _11.data[_27] = _24;
    _20++;
    if (_20 < _18)
    goto _jump712;
    _20 = 0;
    _21++;
    if (_21 < t)
    goto _jump712;
    _21 = 0;
    _22++;
    if (_22 < _12)
    goto _jump712;
    // End body of loop
    bool _28 = false;
    int64_t _29;
    if (!_28)
    goto _jump715;
    _29 = k;
    goto _jump716;
    _jump715:;
    _29 = o;
    _jump716:;
    int64_t _30;
    // Computing bound for L
    if (c > 0) 
    goto _jump717;
    fail_assertion("non-positive loop bound");
    _jump717:;
    // Computing bound for M
    if (l > 0) 
    goto _jump718;
    fail_assertion("non-positive loop bound");
    _jump718:;
    // Computing bound for N
    bool _31 = false;
    bool _32;
    if (!_31)
    goto _jump719;
    _32 = B;
    goto _jump720;
    _jump719:;
    _32 = B;
    _jump720:;
    int64_t _33;
    if (!_32)
    goto _jump721;
    int64_t _34 = -c;
    _33 = _34;
    goto _jump722;
    _jump721:;
    int64_t _35 = c / z;
    _33 = _35;
    _jump722:;
    if (_33 > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    _30 = 0;
    int64_t _36 = 0; // N
    int64_t _37 = 0; // M
    int64_t _38 = 0; // L
    _jump724:; // Begin body of loop
    int64_t _39;
    // Computing bound for O
    if (A > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    _39 = 0;
    int64_t _40 = 0; // O
    _jump726:; // Begin body of loop
    _39 += l;
    _40++;
    if (_40 < A)
    goto _jump726;
    // End body of loop
    _30 += _39;
    _36++;
    if (_36 < _33)
    goto _jump724;
    _36 = 0;
    _37++;
    if (_37 < l)
    goto _jump724;
    _37 = 0;
    _38++;
    if (_38 < c)
    goto _jump724;
    // End body of loop
    if (g >= 0)
    goto _jump727;
    fail_assertion("negative array index");
    _jump727:;
    if (g < _11.d0)
    goto _jump728;
    fail_assertion("index too large");
    _jump728:;
    if (_29 >= 0)
    goto _jump729;
    fail_assertion("negative array index");
    _jump729:;
    if (_29 < _11.d1)
    goto _jump730;
    fail_assertion("index too large");
    _jump730:;
    if (_30 >= 0)
    goto _jump731;
    fail_assertion("negative array index");
    _jump731:;
    if (_30 < _11.d2)
    goto _jump732;
    fail_assertion("index too large");
    _jump732:;
    int64_t _41 = 0;
    _41 *= _11.d0;
    _41 += g;
    _41 *= _11.d1;
    _41 += _29;
    _41 *= _11.d2;
    _41 += _30;
    bool _42 = _11.data[_41];
    _a2_void_t _43;
    if (!_42)
    goto _jump733;
    double _44 = 87.0;
    double _45 = 68.0;
    bool _46 = _44 < _45;
    _a2_void_t _47;
    if (!_46)
    goto _jump734;
    _a1__a2_double _48;
    // Computing bound for L
    _48.d0 = s;
    if (s > 0) 
    goto _jump735;
    fail_assertion("non-positive loop bound");
    _jump735:;
    // Computing total size of heap memory to allocate
    int64_t _49 = 1;
    _49 *= s;
    _49 *= sizeof(_a2_double);
    _48.data = jpl_alloc(_49);
    int64_t _50 = 0; // L
    _jump736:; // Begin body of loop
    int64_t _51 = 0;
    _51 *= _48.d0;
    _51 += _50;
    _48.data[_51] = H;
    _50++;
    if (_50 < s)
    goto _jump736;
    // End body of loop
    if (r >= 0)
    goto _jump737;
    fail_assertion("negative array index");
    _jump737:;
    if (r < _48.d0)
    goto _jump738;
    fail_assertion("index too large");
    _jump738:;
    int64_t _52 = 0;
    _52 *= _48.d0;
    _52 += r;
    _a2_double _53 = _48.data[_52];
    _a2_void_t _54 = G(_53);
    _47 = _54;
    goto _jump739;
    _jump734:;
    _a1__a2_void_t _55;
    // Computing bound for L
    _55.d0 = l;
    if (l > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    // Computing total size of heap memory to allocate
    int64_t _56 = 1;
    _56 *= l;
    _56 *= sizeof(_a2_void_t);
    _55.data = jpl_alloc(_56);
    int64_t _57 = 0; // L
    _jump741:; // Begin body of loop
    _a2_void_t _58 = G(H);
    int64_t _59 = 0;
    _59 *= _55.d0;
    _59 += _57;
    _55.data[_59] = _58;
    _57++;
    if (_57 < l)
    goto _jump741;
    // End body of loop
    if (m >= 0)
    goto _jump742;
    fail_assertion("negative array index");
    _jump742:;
    if (m < _55.d0)
    goto _jump743;
    fail_assertion("index too large");
    _jump743:;
    int64_t _60 = 0;
    _60 *= _55.d0;
    _60 += m;
    _a2_void_t _61 = _55.data[_60];
    _47 = _61;
    _jump739:;
    _43 = _47;
    goto _jump744;
    _jump733:;
    bool _62 = false;
    _a2_void_t _63;
    if (!_62)
    goto _jump745;
    _a2_double _64;
    // Computing bound for L
    _64.d0 = y;
    if (y > 0) 
    goto _jump746;
    fail_assertion("non-positive loop bound");
    _jump746:;
    // Computing bound for M
    _64.d1 = y;
    if (y > 0) 
    goto _jump747;
    fail_assertion("non-positive loop bound");
    _jump747:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= y;
    _65 *= y;
    _65 *= sizeof(double);
    _64.data = jpl_alloc(_65);
    int64_t _66 = 0; // M
    int64_t _67 = 0; // L
    _jump748:; // Begin body of loop
    double _68;
    if (!B)
    goto _jump749;
    double _69 = 99.0;
    _68 = _69;
    goto _jump750;
    _jump749:;
    double _70 = 32.0;
    _68 = _70;
    _jump750:;
    int64_t _71 = 0;
    _71 *= _64.d0;
    _71 += _67;
    _71 *= _64.d1;
    _71 += _66;
    _64.data[_71] = _68;
    _66++;
    if (_66 < y)
    goto _jump748;
    _66 = 0;
    _67++;
    if (_67 < y)
    goto _jump748;
    // End body of loop
    _a2_void_t _72 = G(_64);
    _63 = _72;
    goto _jump751;
    _jump745:;
    _a2_void_t _73;
    // Computing bound for L
    int64_t _74 = b % y;
    _73.d0 = _74;
    if (_74 > 0) 
    goto _jump752;
    fail_assertion("non-positive loop bound");
    _jump752:;
    // Computing bound for M
    _73.d1 = z;
    if (z > 0) 
    goto _jump753;
    fail_assertion("non-positive loop bound");
    _jump753:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= _74;
    _75 *= z;
    _75 *= sizeof(void_t);
    _73.data = jpl_alloc(_75);
    int64_t _76 = 0; // M
    int64_t _77 = 0; // L
    _jump754:; // Begin body of loop
    _a2_void_t _78 = G(H);
    int64_t _79 = y + g;
    if (_77 >= 0)
    goto _jump755;
    fail_assertion("negative array index");
    _jump755:;
    if (_77 < _78.d0)
    goto _jump756;
    fail_assertion("index too large");
    _jump756:;
    if (_79 >= 0)
    goto _jump757;
    fail_assertion("negative array index");
    _jump757:;
    if (_79 < _78.d1)
    goto _jump758;
    fail_assertion("index too large");
    _jump758:;
    int64_t _80 = 0;
    _80 *= _78.d0;
    _80 += _77;
    _80 *= _78.d1;
    _80 += _79;
    void_t _81 = _78.data[_80];
    int64_t _82 = 0;
    _82 *= _73.d0;
    _82 += _77;
    _82 *= _73.d1;
    _82 += _76;
    _73.data[_82] = _81;
    _76++;
    if (_76 < z)
    goto _jump754;
    _76 = 0;
    _77++;
    if (_77 < _74)
    goto _jump754;
    // End body of loop
    _63 = _73;
    _jump751:;
    _43 = _63;
    _jump744:;
    _10 = _43;
    goto _jump759;
    _jump700:;
    bool _83 = i;
    if (0 == i)
    goto _jump760;
    _83 = B;
    _jump760:;
    _a1__a2_void_t _84;
    if (!_83)
    goto _jump761;
    _a1__a2_void_t _85;
    // Computing bound for L
    _85.d0 = p;
    if (p > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= p;
    _86 *= sizeof(_a2_void_t);
    _85.data = jpl_alloc(_86);
    int64_t _87 = 0; // L
    _jump763:; // Begin body of loop
    _a2_void_t _88 = G(H);
    int64_t _89 = 0;
    _89 *= _85.d0;
    _89 += _87;
    _85.data[_89] = _88;
    _87++;
    if (_87 < p)
    goto _jump763;
    // End body of loop
    _84 = _85;
    goto _jump764;
    _jump761:;
    _a1__a2_void_t _90;
    // Computing bound for L
    _90.d0 = f;
    if (f > 0) 
    goto _jump765;
    fail_assertion("non-positive loop bound");
    _jump765:;
    // Computing total size of heap memory to allocate
    int64_t _91 = 1;
    _91 *= f;
    _91 *= sizeof(_a2_void_t);
    _90.data = jpl_alloc(_91);
    int64_t _92 = 0; // L
    _jump766:; // Begin body of loop
    _a2_double _93;
    if (!i)
    goto _jump767;
    _93 = H;
    goto _jump768;
    _jump767:;
    _93 = H;
    _jump768:;
    _a2_void_t _94 = G(_93);
    int64_t _95 = 0;
    _95 *= _90.d0;
    _95 += _92;
    _90.data[_95] = _94;
    _92++;
    if (_92 < f)
    goto _jump766;
    // End body of loop
    _84 = _90;
    _jump764:;
    _a1__a2_int64_t _96;
    // Computing bound for L
    _96.d0 = f;
    if (f > 0) 
    goto _jump769;
    fail_assertion("non-positive loop bound");
    _jump769:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= f;
    _97 *= sizeof(_a2_int64_t);
    _96.data = jpl_alloc(_97);
    int64_t _98 = 0; // L
    _jump770:; // Begin body of loop
    _a2_int64_t _99;
    // Computing bound for M
    _99.d0 = f;
    if (f > 0) 
    goto _jump771;
    fail_assertion("non-positive loop bound");
    _jump771:;
    // Computing bound for N
    _99.d1 = h;
    if (h > 0) 
    goto _jump772;
    fail_assertion("non-positive loop bound");
    _jump772:;
    // Computing total size of heap memory to allocate
    int64_t _100 = 1;
    _100 *= f;
    _100 *= h;
    _100 *= sizeof(int64_t);
    _99.data = jpl_alloc(_100);
    int64_t _101 = 0; // N
    int64_t _102 = 0; // M
    _jump773:; // Begin body of loop
    int64_t _103 = 0;
    _103 *= _99.d0;
    _103 += _102;
    _103 *= _99.d1;
    _103 += _101;
    _99.data[_103] = v;
    _101++;
    if (_101 < h)
    goto _jump773;
    _101 = 0;
    _102++;
    if (_102 < f)
    goto _jump773;
    // End body of loop
    int64_t _104 = 0;
    _104 *= _96.d0;
    _104 += _98;
    _96.data[_104] = _99;
    _98++;
    if (_98 < f)
    goto _jump770;
    // End body of loop
    if (H.d1 >= 0)
    goto _jump774;
    fail_assertion("negative array index");
    _jump774:;
    if (H.d1 < _96.d0)
    goto _jump775;
    fail_assertion("index too large");
    _jump775:;
    int64_t _105 = 0;
    _105 *= _96.d0;
    _105 += H.d1;
    _a2_int64_t _106 = _96.data[_105];
    int64_t _107 = 484;
    if (r >= 0)
    goto _jump776;
    fail_assertion("negative array index");
    _jump776:;
    if (r < _106.d0)
    goto _jump777;
    fail_assertion("index too large");
    _jump777:;
    if (_107 >= 0)
    goto _jump778;
    fail_assertion("negative array index");
    _jump778:;
    if (_107 < _106.d1)
    goto _jump779;
    fail_assertion("index too large");
    _jump779:;
    int64_t _108 = 0;
    _108 *= _106.d0;
    _108 += r;
    _108 *= _106.d1;
    _108 += _107;
    int64_t _109 = _106.data[_108];
    if (_109 >= 0)
    goto _jump780;
    fail_assertion("negative array index");
    _jump780:;
    if (_109 < _84.d0)
    goto _jump781;
    fail_assertion("index too large");
    _jump781:;
    int64_t _110 = 0;
    _110 *= _84.d0;
    _110 += _109;
    _a2_void_t _111 = _84.data[_110];
    _10 = _111;
    _jump759:;
    _6 = _10;
    goto _jump782;
    _jump695:;
    _a3__a2__a2_void_t _112;
    // Computing bound for L
    int64_t _113 = 93;
    int64_t _114 = h / _113;
    _112.d0 = _114;
    if (_114 > 0) 
    goto _jump783;
    fail_assertion("non-positive loop bound");
    _jump783:;
    // Computing bound for M
    _112.d1 = A;
    if (A > 0) 
    goto _jump784;
    fail_assertion("non-positive loop bound");
    _jump784:;
    // Computing bound for N
    _112.d2 = F;
    if (F > 0) 
    goto _jump785;
    fail_assertion("non-positive loop bound");
    _jump785:;
    // Computing total size of heap memory to allocate
    int64_t _115 = 1;
    _115 *= _114;
    _115 *= A;
    _115 *= F;
    _115 *= sizeof(_a2__a2_void_t);
    _112.data = jpl_alloc(_115);
    int64_t _116 = 0; // N
    int64_t _117 = 0; // M
    int64_t _118 = 0; // L
    _jump786:; // Begin body of loop
    _a2__a2_void_t _119;
    // Computing bound for O
    _119.d0 = m;
    if (m > 0) 
    goto _jump787;
    fail_assertion("non-positive loop bound");
    _jump787:;
    // Computing bound for P
    _119.d1 = k;
    if (k > 0) 
    goto _jump788;
    fail_assertion("non-positive loop bound");
    _jump788:;
    // Computing total size of heap memory to allocate
    int64_t _120 = 1;
    _120 *= m;
    _120 *= k;
    _120 *= sizeof(_a2_void_t);
    _119.data = jpl_alloc(_120);
    int64_t _121 = 0; // P
    int64_t _122 = 0; // O
    _jump789:; // Begin body of loop
    _a2_void_t _123 = G(H);
    int64_t _124 = 0;
    _124 *= _119.d0;
    _124 += _122;
    _124 *= _119.d1;
    _124 += _121;
    _119.data[_124] = _123;
    _121++;
    if (_121 < k)
    goto _jump789;
    _121 = 0;
    _122++;
    if (_122 < m)
    goto _jump789;
    // End body of loop
    int64_t _125 = 0;
    _125 *= _112.d0;
    _125 += _118;
    _125 *= _112.d1;
    _125 += _117;
    _125 *= _112.d2;
    _125 += _116;
    _112.data[_125] = _119;
    _116++;
    if (_116 < F)
    goto _jump786;
    _116 = 0;
    _117++;
    if (_117 < A)
    goto _jump786;
    _117 = 0;
    _118++;
    if (_118 < _114)
    goto _jump786;
    // End body of loop
    bool _127 = y <= r;
    bool _126 = _127;
    if (0 != _127)
    goto _jump790;
    if (w >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (w < x.d0)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    if (H.d0 >= 0)
    goto _jump793;
    fail_assertion("negative array index");
    _jump793:;
    if (H.d0 < x.d1)
    goto _jump794;
    fail_assertion("index too large");
    _jump794:;
    int64_t _128 = 0;
    _128 *= x.d0;
    _128 += w;
    _128 *= x.d1;
    _128 += H.d0;
    bool _129 = x.data[_128];
    _126 = _129;
    _jump790:;
    _a1_int64_t _130;
    if (!_126)
    goto _jump795;
    _130 = E;
    goto _jump796;
    _jump795:;
    double _131 = 70.0;
    bool _132 = _131 >= C;
    _a1_int64_t _133;
    if (!_132)
    goto _jump797;
    _a1_int64_t _134;
    // Computing bound for L
    _134.d0 = s;
    if (s > 0) 
    goto _jump798;
    fail_assertion("non-positive loop bound");
    _jump798:;
    // Computing total size of heap memory to allocate
    int64_t _135 = 1;
    _135 *= s;
    _135 *= sizeof(int64_t);
    _134.data = jpl_alloc(_135);
    int64_t _136 = 0; // L
    _jump799:; // Begin body of loop
    int64_t _137 = 0;
    _137 *= _134.d0;
    _137 += _136;
    _134.data[_137] = v;
    _136++;
    if (_136 < s)
    goto _jump799;
    // End body of loop
    _133 = _134;
    goto _jump800;
    _jump797:;
    _133 = E;
    _jump800:;
    _130 = _133;
    _jump796:;
    if (H.d0 >= 0)
    goto _jump801;
    fail_assertion("negative array index");
    _jump801:;
    if (H.d0 < _130.d0)
    goto _jump802;
    fail_assertion("index too large");
    _jump802:;
    int64_t _138 = 0;
    _138 *= _130.d0;
    _138 += H.d0;
    int64_t _139 = _130.data[_138];
    int64_t _140 = d + r;
    if (A >= 0)
    goto _jump803;
    fail_assertion("negative array index");
    _jump803:;
    if (A < _112.d0)
    goto _jump804;
    fail_assertion("index too large");
    _jump804:;
    if (_139 >= 0)
    goto _jump805;
    fail_assertion("negative array index");
    _jump805:;
    if (_139 < _112.d1)
    goto _jump806;
    fail_assertion("index too large");
    _jump806:;
    if (_140 >= 0)
    goto _jump807;
    fail_assertion("negative array index");
    _jump807:;
    if (_140 < _112.d2)
    goto _jump808;
    fail_assertion("index too large");
    _jump808:;
    int64_t _141 = 0;
    _141 *= _112.d0;
    _141 += A;
    _141 *= _112.d1;
    _141 += _139;
    _141 *= _112.d2;
    _141 += _140;
    _a2__a2_void_t _142 = _112.data[_141];
    if (v >= 0)
    goto _jump809;
    fail_assertion("negative array index");
    _jump809:;
    if (v < _142.d0)
    goto _jump810;
    fail_assertion("index too large");
    _jump810:;
    if (s >= 0)
    goto _jump811;
    fail_assertion("negative array index");
    _jump811:;
    if (s < _142.d1)
    goto _jump812;
    fail_assertion("index too large");
    _jump812:;
    int64_t _143 = 0;
    _143 *= _142.d0;
    _143 += v;
    _143 *= _142.d1;
    _143 += s;
    _a2_void_t _144 = _142.data[_143];
    _6 = _144;
    _jump782:;
    return _6;
    _a3__a3_int64_t _145;
    if (!i)
    goto _jump813;
    _a1_bool _146;
    // Computing bound for L
    _146.d0 = s;
    if (s > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    // Computing total size of heap memory to allocate
    int64_t _147 = 1;
    _147 *= s;
    _147 *= sizeof(bool);
    _146.data = jpl_alloc(_147);
    int64_t _148 = 0; // L
    _jump815:; // Begin body of loop
    bool _149 = !i;
    int64_t _150 = 0;
    _150 *= _146.d0;
    _150 += _148;
    _146.data[_150] = _149;
    _148++;
    if (_148 < s)
    goto _jump815;
    // End body of loop
    _a2_int64_t _151;
    if (!B)
    goto _jump816;
    _a2_int64_t _152;
    // Computing bound for L
    _152.d0 = H.d1;
    if (H.d1 > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for M
    _152.d1 = o;
    if (o > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= H.d1;
    _153 *= o;
    _153 *= sizeof(int64_t);
    _152.data = jpl_alloc(_153);
    int64_t _154 = 0; // M
    int64_t _155 = 0; // L
    _jump819:; // Begin body of loop
    int64_t _156 = 0;
    _156 *= _152.d0;
    _156 += _155;
    _156 *= _152.d1;
    _156 += _154;
    _152.data[_156] = k;
    _154++;
    if (_154 < o)
    goto _jump819;
    _154 = 0;
    _155++;
    if (_155 < H.d1)
    goto _jump819;
    // End body of loop
    _151 = _152;
    goto _jump820;
    _jump816:;
    _a2_int64_t _157;
    // Computing bound for L
    _157.d0 = p;
    if (p > 0) 
    goto _jump821;
    fail_assertion("non-positive loop bound");
    _jump821:;
    // Computing bound for M
    _157.d1 = o;
    if (o > 0) 
    goto _jump822;
    fail_assertion("non-positive loop bound");
    _jump822:;
    // Computing total size of heap memory to allocate
    int64_t _158 = 1;
    _158 *= p;
    _158 *= o;
    _158 *= sizeof(int64_t);
    _157.data = jpl_alloc(_158);
    int64_t _159 = 0; // M
    int64_t _160 = 0; // L
    _jump823:; // Begin body of loop
    int64_t _161 = 270;
    int64_t _162 = 0;
    _162 *= _157.d0;
    _162 += _160;
    _162 *= _157.d1;
    _162 += _159;
    _157.data[_162] = _161;
    _159++;
    if (_159 < o)
    goto _jump823;
    _159 = 0;
    _160++;
    if (_160 < p)
    goto _jump823;
    // End body of loop
    _151 = _157;
    _jump820:;
    _a1_int64_t _163;
    _163.d0 = 1;
    _163.data = jpl_alloc(sizeof(int64_t) * 1);
    _163.data[0] = c;
    if (w >= 0)
    goto _jump824;
    fail_assertion("negative array index");
    _jump824:;
    if (w < _163.d0)
    goto _jump825;
    fail_assertion("index too large");
    _jump825:;
    int64_t _164 = 0;
    _164 *= _163.d0;
    _164 += w;
    int64_t _165 = _163.data[_164];
    if (m >= 0)
    goto _jump826;
    fail_assertion("negative array index");
    _jump826:;
    if (m < _151.d0)
    goto _jump827;
    fail_assertion("index too large");
    _jump827:;
    if (_165 >= 0)
    goto _jump828;
    fail_assertion("negative array index");
    _jump828:;
    if (_165 < _151.d1)
    goto _jump829;
    fail_assertion("index too large");
    _jump829:;
    int64_t _166 = 0;
    _166 *= _151.d0;
    _166 += m;
    _166 *= _151.d1;
    _166 += _165;
    int64_t _167 = _151.data[_166];
    if (_167 >= 0)
    goto _jump830;
    fail_assertion("negative array index");
    _jump830:;
    if (_167 < _146.d0)
    goto _jump831;
    fail_assertion("index too large");
    _jump831:;
    int64_t _168 = 0;
    _168 *= _146.d0;
    _168 += _167;
    bool _169 = _146.data[_168];
    _a3__a3_int64_t _170;
    if (!_169)
    goto _jump832;
    _a1__a3__a3_int64_t _171;
    // Computing bound for L
    int64_t _172;
    if (!B)
    goto _jump833;
    _172 = w;
    goto _jump834;
    _jump833:;
    _172 = z;
    _jump834:;
    _171.d0 = _172;
    if (_172 > 0) 
    goto _jump835;
    fail_assertion("non-positive loop bound");
    _jump835:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= _172;
    _173 *= sizeof(_a3__a3_int64_t);
    _171.data = jpl_alloc(_173);
    int64_t _174 = 0; // L
    _jump836:; // Begin body of loop
    _a3__a3_int64_t _175;
    // Computing bound for M
    _175.d0 = H.d0;
    if (H.d0 > 0) 
    goto _jump837;
    fail_assertion("non-positive loop bound");
    _jump837:;
    // Computing bound for N
    _175.d1 = m;
    if (m > 0) 
    goto _jump838;
    fail_assertion("non-positive loop bound");
    _jump838:;
    // Computing bound for O
    _175.d2 = t;
    if (t > 0) 
    goto _jump839;
    fail_assertion("non-positive loop bound");
    _jump839:;
    // Computing total size of heap memory to allocate
    int64_t _176 = 1;
    _176 *= H.d0;
    _176 *= m;
    _176 *= t;
    _176 *= sizeof(_a3_int64_t);
    _175.data = jpl_alloc(_176);
    int64_t _177 = 0; // O
    int64_t _178 = 0; // N
    int64_t _179 = 0; // M
    _jump840:; // Begin body of loop
    _a3_int64_t _180;
    // Computing bound for P
    _180.d0 = o;
    if (o > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing bound for Q
    _180.d1 = z;
    if (z > 0) 
    goto _jump842;
    fail_assertion("non-positive loop bound");
    _jump842:;
    // Computing bound for R
    _180.d2 = _178;
    if (_178 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= o;
    _181 *= z;
    _181 *= _178;
    _181 *= sizeof(int64_t);
    _180.data = jpl_alloc(_181);
    int64_t _182 = 0; // R
    int64_t _183 = 0; // Q
    int64_t _184 = 0; // P
    _jump844:; // Begin body of loop
    int64_t _185 = 0;
    _185 *= _180.d0;
    _185 += _184;
    _185 *= _180.d1;
    _185 += _183;
    _185 *= _180.d2;
    _185 += _182;
    _180.data[_185] = g;
    _182++;
    if (_182 < _178)
    goto _jump844;
    _182 = 0;
    _183++;
    if (_183 < z)
    goto _jump844;
    _183 = 0;
    _184++;
    if (_184 < o)
    goto _jump844;
    // End body of loop
    int64_t _186 = 0;
    _186 *= _175.d0;
    _186 += _179;
    _186 *= _175.d1;
    _186 += _178;
    _186 *= _175.d2;
    _186 += _177;
    _175.data[_186] = _180;
    _177++;
    if (_177 < t)
    goto _jump840;
    _177 = 0;
    _178++;
    if (_178 < m)
    goto _jump840;
    _178 = 0;
    _179++;
    if (_179 < H.d0)
    goto _jump840;
    // End body of loop
    int64_t _187 = 0;
    _187 *= _171.d0;
    _187 += _174;
    _171.data[_187] = _175;
    _174++;
    if (_174 < _172)
    goto _jump836;
    // End body of loop
    if (h >= 0)
    goto _jump845;
    fail_assertion("negative array index");
    _jump845:;
    if (h < _171.d0)
    goto _jump846;
    fail_assertion("index too large");
    _jump846:;
    int64_t _188 = 0;
    _188 *= _171.d0;
    _188 += h;
    _a3__a3_int64_t _189 = _171.data[_188];
    _170 = _189;
    goto _jump847;
    _jump832:;
    _a1__a3__a3_int64_t _190;
    // Computing bound for L
    int64_t _191 = l + b;
    _190.d0 = _191;
    if (_191 > 0) 
    goto _jump848;
    fail_assertion("non-positive loop bound");
    _jump848:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= _191;
    _192 *= sizeof(_a3__a3_int64_t);
    _190.data = jpl_alloc(_192);
    int64_t _193 = 0; // L
    _jump849:; // Begin body of loop
    _a3__a3_int64_t _194;
    // Computing bound for M
    _194.d0 = g;
    if (g > 0) 
    goto _jump850;
    fail_assertion("non-positive loop bound");
    _jump850:;
    // Computing bound for N
    _194.d1 = p;
    if (p > 0) 
    goto _jump851;
    fail_assertion("non-positive loop bound");
    _jump851:;
    // Computing bound for O
    _194.d2 = b;
    if (b > 0) 
    goto _jump852;
    fail_assertion("non-positive loop bound");
    _jump852:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= g;
    _195 *= p;
    _195 *= b;
    _195 *= sizeof(_a3_int64_t);
    _194.data = jpl_alloc(_195);
    int64_t _196 = 0; // O
    int64_t _197 = 0; // N
    int64_t _198 = 0; // M
    _jump853:; // Begin body of loop
    int64_t _199 = 0;
    _199 *= _194.d0;
    _199 += _198;
    _199 *= _194.d1;
    _199 += _197;
    _199 *= _194.d2;
    _199 += _196;
    _194.data[_199] = e;
    _196++;
    if (_196 < b)
    goto _jump853;
    _196 = 0;
    _197++;
    if (_197 < p)
    goto _jump853;
    _197 = 0;
    _198++;
    if (_198 < g)
    goto _jump853;
    // End body of loop
    int64_t _200 = 0;
    _200 *= _190.d0;
    _200 += _193;
    _190.data[_200] = _194;
    _193++;
    if (_193 < _191)
    goto _jump849;
    // End body of loop
    _a1_int64_t _201;
    if (!i)
    goto _jump854;
    _a1_int64_t _202;
    // Computing bound for L
    _202.d0 = w;
    if (w > 0) 
    goto _jump855;
    fail_assertion("non-positive loop bound");
    _jump855:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= w;
    _203 *= sizeof(int64_t);
    _202.data = jpl_alloc(_203);
    int64_t _204 = 0; // L
    _jump856:; // Begin body of loop
    int64_t _205 = 0;
    _205 *= _202.d0;
    _205 += _204;
    _202.data[_205] = b;
    _204++;
    if (_204 < w)
    goto _jump856;
    // End body of loop
    _201 = _202;
    goto _jump857;
    _jump854:;
    _201 = E;
    _jump857:;
    if (o >= 0)
    goto _jump858;
    fail_assertion("negative array index");
    _jump858:;
    if (o < _201.d0)
    goto _jump859;
    fail_assertion("index too large");
    _jump859:;
    int64_t _206 = 0;
    _206 *= _201.d0;
    _206 += o;
    int64_t _207 = _201.data[_206];
    if (_207 >= 0)
    goto _jump860;
    fail_assertion("negative array index");
    _jump860:;
    if (_207 < _190.d0)
    goto _jump861;
    fail_assertion("index too large");
    _jump861:;
    int64_t _208 = 0;
    _208 *= _190.d0;
    _208 += _207;
    _a3__a3_int64_t _209 = _190.data[_208];
    _170 = _209;
    _jump847:;
    _145 = _170;
    goto _jump862;
    _jump813:;
    _a3__a3_int64_t _210;
    // Computing bound for L
    _210.d0 = H.d1;
    if (H.d1 > 0) 
    goto _jump863;
    fail_assertion("non-positive loop bound");
    _jump863:;
    // Computing bound for M
    _210.d1 = f;
    if (f > 0) 
    goto _jump864;
    fail_assertion("non-positive loop bound");
    _jump864:;
    // Computing bound for N
    _210.d2 = l;
    if (l > 0) 
    goto _jump865;
    fail_assertion("non-positive loop bound");
    _jump865:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= H.d1;
    _211 *= f;
    _211 *= l;
    _211 *= sizeof(_a3_int64_t);
    _210.data = jpl_alloc(_211);
    int64_t _212 = 0; // N
    int64_t _213 = 0; // M
    int64_t _214 = 0; // L
    _jump866:; // Begin body of loop
    _a3_int64_t _215;
    // Computing bound for O
    _215.d0 = r;
    if (r > 0) 
    goto _jump867;
    fail_assertion("non-positive loop bound");
    _jump867:;
    // Computing bound for P
    _215.d1 = H.d1;
    if (H.d1 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing bound for Q
    _215.d2 = _213;
    if (_213 > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing total size of heap memory to allocate
    int64_t _216 = 1;
    _216 *= r;
    _216 *= H.d1;
    _216 *= _213;
    _216 *= sizeof(int64_t);
    _215.data = jpl_alloc(_216);
    int64_t _217 = 0; // Q
    int64_t _218 = 0; // P
    int64_t _219 = 0; // O
    _jump870:; // Begin body of loop
    int64_t _220 = 0;
    _220 *= _215.d0;
    _220 += _219;
    _220 *= _215.d1;
    _220 += _218;
    _220 *= _215.d2;
    _220 += _217;
    _215.data[_220] = _218;
    _217++;
    if (_217 < _213)
    goto _jump870;
    _217 = 0;
    _218++;
    if (_218 < H.d1)
    goto _jump870;
    _218 = 0;
    _219++;
    if (_219 < r)
    goto _jump870;
    // End body of loop
    int64_t _221 = 0;
    _221 *= _210.d0;
    _221 += _214;
    _221 *= _210.d1;
    _221 += _213;
    _221 *= _210.d2;
    _221 += _212;
    _210.data[_221] = _215;
    _212++;
    if (_212 < l)
    goto _jump866;
    _212 = 0;
    _213++;
    if (_213 < f)
    goto _jump866;
    _213 = 0;
    _214++;
    if (_214 < H.d1)
    goto _jump866;
    // End body of loop
    _145 = _210;
    _jump862:;
    _a2__a2_int64_t _222;
    // Computing bound for L
    _222.d0 = A;
    if (A > 0) 
    goto _jump871;
    fail_assertion("non-positive loop bound");
    _jump871:;
    // Computing bound for M
    _222.d1 = F;
    if (F > 0) 
    goto _jump872;
    fail_assertion("non-positive loop bound");
    _jump872:;
    // Computing total size of heap memory to allocate
    int64_t _223 = 1;
    _223 *= A;
    _223 *= F;
    _223 *= sizeof(_a2_int64_t);
    _222.data = jpl_alloc(_223);
    int64_t _224 = 0; // M
    int64_t _225 = 0; // L
    _jump873:; // Begin body of loop
    _a3__a2_int64_t _226;
    // Computing bound for N
    _226.d0 = H.d1;
    if (H.d1 > 0) 
    goto _jump874;
    fail_assertion("non-positive loop bound");
    _jump874:;
    // Computing bound for O
    _226.d1 = h;
    if (h > 0) 
    goto _jump875;
    fail_assertion("non-positive loop bound");
    _jump875:;
    // Computing bound for P
    _226.d2 = l;
    if (l > 0) 
    goto _jump876;
    fail_assertion("non-positive loop bound");
    _jump876:;
    // Computing total size of heap memory to allocate
    int64_t _227 = 1;
    _227 *= H.d1;
    _227 *= h;
    _227 *= l;
    _227 *= sizeof(_a2_int64_t);
    _226.data = jpl_alloc(_227);
    int64_t _228 = 0; // P
    int64_t _229 = 0; // O
    int64_t _230 = 0; // N
    _jump877:; // Begin body of loop
    _a2_int64_t _231;
    // Computing bound for Q
    _231.d0 = f;
    if (f > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing bound for R
    _231.d1 = s;
    if (s > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing total size of heap memory to allocate
    int64_t _232 = 1;
    _232 *= f;
    _232 *= s;
    _232 *= sizeof(int64_t);
    _231.data = jpl_alloc(_232);
    int64_t _233 = 0; // R
    int64_t _234 = 0; // Q
    _jump880:; // Begin body of loop
    int64_t _235 = 0;
    _235 *= _231.d0;
    _235 += _234;
    _235 *= _231.d1;
    _235 += _233;
    _231.data[_235] = w;
    _233++;
    if (_233 < s)
    goto _jump880;
    _233 = 0;
    _234++;
    if (_234 < f)
    goto _jump880;
    // End body of loop
    int64_t _236 = 0;
    _236 *= _226.d0;
    _236 += _230;
    _236 *= _226.d1;
    _236 += _229;
    _236 *= _226.d2;
    _236 += _228;
    _226.data[_236] = _231;
    _228++;
    if (_228 < l)
    goto _jump877;
    _228 = 0;
    _229++;
    if (_229 < h)
    goto _jump877;
    _229 = 0;
    _230++;
    if (_230 < H.d1)
    goto _jump877;
    // End body of loop
    int64_t _237 = 617;
    if (_237 >= 0)
    goto _jump881;
    fail_assertion("negative array index");
    _jump881:;
    if (_237 < _226.d0)
    goto _jump882;
    fail_assertion("index too large");
    _jump882:;
    if (g >= 0)
    goto _jump883;
    fail_assertion("negative array index");
    _jump883:;
    if (g < _226.d1)
    goto _jump884;
    fail_assertion("index too large");
    _jump884:;
    if (h >= 0)
    goto _jump885;
    fail_assertion("negative array index");
    _jump885:;
    if (h < _226.d2)
    goto _jump886;
    fail_assertion("index too large");
    _jump886:;
    int64_t _238 = 0;
    _238 *= _226.d0;
    _238 += _237;
    _238 *= _226.d1;
    _238 += g;
    _238 *= _226.d2;
    _238 += h;
    _a2_int64_t _239 = _226.data[_238];
    int64_t _240 = 0;
    _240 *= _222.d0;
    _240 += _225;
    _240 *= _222.d1;
    _240 += _224;
    _222.data[_240] = _239;
    _224++;
    if (_224 < F)
    goto _jump873;
    _224 = 0;
    _225++;
    if (_225 < A)
    goto _jump873;
    // End body of loop
    if (y >= 0)
    goto _jump887;
    fail_assertion("negative array index");
    _jump887:;
    if (y < _222.d0)
    goto _jump888;
    fail_assertion("index too large");
    _jump888:;
    if (h >= 0)
    goto _jump889;
    fail_assertion("negative array index");
    _jump889:;
    if (h < _222.d1)
    goto _jump890;
    fail_assertion("index too large");
    _jump890:;
    int64_t _241 = 0;
    _241 *= _222.d0;
    _241 += y;
    _241 *= _222.d1;
    _241 += h;
    _a2_int64_t _242 = _222.data[_241];
    int64_t _243 = -f;
    if (_243 >= 0)
    goto _jump891;
    fail_assertion("negative array index");
    _jump891:;
    if (_243 < _242.d0)
    goto _jump892;
    fail_assertion("index too large");
    _jump892:;
    if (o >= 0)
    goto _jump893;
    fail_assertion("negative array index");
    _jump893:;
    if (o < _242.d1)
    goto _jump894;
    fail_assertion("index too large");
    _jump894:;
    int64_t _244 = 0;
    _244 *= _242.d0;
    _244 += _243;
    _244 *= _242.d1;
    _244 += o;
    int64_t _245 = _242.data[_244];
    int64_t _246 = -p;
    if (s >= 0)
    goto _jump895;
    fail_assertion("negative array index");
    _jump895:;
    if (s < _145.d0)
    goto _jump896;
    fail_assertion("index too large");
    _jump896:;
    if (_245 >= 0)
    goto _jump897;
    fail_assertion("negative array index");
    _jump897:;
    if (_245 < _145.d1)
    goto _jump898;
    fail_assertion("index too large");
    _jump898:;
    if (_246 >= 0)
    goto _jump899;
    fail_assertion("negative array index");
    _jump899:;
    if (_246 < _145.d2)
    goto _jump900;
    fail_assertion("index too large");
    _jump900:;
    int64_t _247 = 0;
    _247 *= _145.d0;
    _247 += s;
    _247 *= _145.d1;
    _247 += _245;
    _247 *= _145.d2;
    _247 += _246;
    _a3_int64_t _248 = _145.data[_247];
    _a2_double _249;
    // Computing bound for P
    _249.d0 = _248.d1;
    if (_248.d1 > 0) 
    goto _jump901;
    fail_assertion("non-positive loop bound");
    _jump901:;
    // Computing bound for Q
    _249.d1 = _248.d0;
    if (_248.d0 > 0) 
    goto _jump902;
    fail_assertion("non-positive loop bound");
    _jump902:;
    // Computing total size of heap memory to allocate
    int64_t _250 = 1;
    _250 *= _248.d1;
    _250 *= _248.d0;
    _250 *= sizeof(double);
    _249.data = jpl_alloc(_250);
    int64_t _251 = 0; // Q
    int64_t _252 = 0; // P
    _jump903:; // Begin body of loop
    _a2_double _253;
    // Computing bound for R
    _253.d0 = p;
    if (p > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for S
    _253.d1 = _248.d1;
    if (_248.d1 > 0) 
    goto _jump905;
    fail_assertion("non-positive loop bound");
    _jump905:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= p;
    _254 *= _248.d1;
    _254 *= sizeof(double);
    _253.data = jpl_alloc(_254);
    int64_t _255 = 0; // S
    int64_t _256 = 0; // R
    _jump906:; // Begin body of loop
    double _257 = D(H, j);
    int64_t _258 = 0;
    _258 *= _253.d0;
    _258 += _256;
    _258 *= _253.d1;
    _258 += _255;
    _253.data[_258] = _257;
    _255++;
    if (_255 < _248.d1)
    goto _jump906;
    _255 = 0;
    _256++;
    if (_256 < p)
    goto _jump906;
    // End body of loop
    double _259 = D(_253, j);
    double _260 = -_259;
    int64_t _261 = 0;
    _261 *= _249.d0;
    _261 += _252;
    _261 *= _249.d1;
    _261 += _251;
    _249.data[_261] = _260;
    _251++;
    if (_251 < _248.d0)
    goto _jump903;
    _251 = 0;
    _252++;
    if (_252 < _248.d1)
    goto _jump903;
    // End body of loop
    _a2__a1__a3_int64_t _262;
    // Computing bound for P
    _262.d0 = w;
    if (w > 0) 
    goto _jump907;
    fail_assertion("non-positive loop bound");
    _jump907:;
    // Computing bound for Q
    _262.d1 = b;
    if (b > 0) 
    goto _jump908;
    fail_assertion("non-positive loop bound");
    _jump908:;
    // Computing total size of heap memory to allocate
    int64_t _263 = 1;
    _263 *= w;
    _263 *= b;
    _263 *= sizeof(_a1__a3_int64_t);
    _262.data = jpl_alloc(_263);
    int64_t _264 = 0; // Q
    int64_t _265 = 0; // P
    _jump909:; // Begin body of loop
    _a3_int64_t _266;
    // Computing bound for R
    _266.d0 = A;
    if (A > 0) 
    goto _jump910;
    fail_assertion("non-positive loop bound");
    _jump910:;
    // Computing bound for S
    _266.d1 = H.d0;
    if (H.d0 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing bound for T
    _266.d2 = _264;
    if (_264 > 0) 
    goto _jump912;
    fail_assertion("non-positive loop bound");
    _jump912:;
    // Computing total size of heap memory to allocate
    int64_t _267 = 1;
    _267 *= A;
    _267 *= H.d0;
    _267 *= _264;
    _267 *= sizeof(int64_t);
    _266.data = jpl_alloc(_267);
    int64_t _268 = 0; // T
    int64_t _269 = 0; // S
    int64_t _270 = 0; // R
    _jump913:; // Begin body of loop
    int64_t _271 = 0;
    _271 *= _266.d0;
    _271 += _270;
    _271 *= _266.d1;
    _271 += _269;
    _271 *= _266.d2;
    _271 += _268;
    _266.data[_271] = _268;
    _268++;
    if (_268 < _264)
    goto _jump913;
    _268 = 0;
    _269++;
    if (_269 < H.d0)
    goto _jump913;
    _269 = 0;
    _270++;
    if (_270 < A)
    goto _jump913;
    // End body of loop
    _a1__a3_int64_t _272;
    _272.d0 = 3;
    _272.data = jpl_alloc(sizeof(_a3_int64_t) * 3);
    _272.data[0] = e;
    _272.data[1] = e;
    _272.data[2] = _266;
    int64_t _273 = 0;
    _273 *= _262.d0;
    _273 += _265;
    _273 *= _262.d1;
    _273 += _264;
    _262.data[_273] = _272;
    _264++;
    if (_264 < b)
    goto _jump909;
    _264 = 0;
    _265++;
    if (_265 < w)
    goto _jump909;
    // End body of loop
    if (l >= 0)
    goto _jump914;
    fail_assertion("negative array index");
    _jump914:;
    if (l < _262.d0)
    goto _jump915;
    fail_assertion("index too large");
    _jump915:;
    if (H.d0 >= 0)
    goto _jump916;
    fail_assertion("negative array index");
    _jump916:;
    if (H.d0 < _262.d1)
    goto _jump917;
    fail_assertion("index too large");
    _jump917:;
    int64_t _274 = 0;
    _274 *= _262.d0;
    _274 += l;
    _274 *= _262.d1;
    _274 += H.d0;
    _a1__a3_int64_t _275 = _262.data[_274];
    int64_t _276;
    // Computing bound for P
    if (z > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    _276 = 0;
    int64_t _277 = 0; // P
    _jump919:; // Begin body of loop
    _276 += h;
    _277++;
    if (_277 < z)
    goto _jump919;
    // End body of loop
    if (_276 >= 0)
    goto _jump920;
    fail_assertion("negative array index");
    _jump920:;
    if (_276 < E.d0)
    goto _jump921;
    fail_assertion("index too large");
    _jump921:;
    int64_t _278 = 0;
    _278 *= E.d0;
    _278 += _276;
    int64_t _279 = E.data[_278];
    if (_279 >= 0)
    goto _jump922;
    fail_assertion("negative array index");
    _jump922:;
    if (_279 < _275.d0)
    goto _jump923;
    fail_assertion("index too large");
    _jump923:;
    int64_t _280 = 0;
    _280 *= _275.d0;
    _280 += _279;
    _a3_int64_t _281 = _275.data[_280];
    double _282 = D(_249, _281);
    double _283 = 66.0;
    double _284 = -_283;
    double _285 = 8.0;
    double _286;
    // Computing bound for P
    if (l > 0) 
    goto _jump924;
    fail_assertion("non-positive loop bound");
    _jump924:;
    // Computing bound for Q
    if (r > 0) 
    goto _jump925;
    fail_assertion("non-positive loop bound");
    _jump925:;
    _286 = 0;
    int64_t _287 = 0; // Q
    int64_t _288 = 0; // P
    _jump926:; // Begin body of loop
    _286 += C;
    _287++;
    if (_287 < r)
    goto _jump926;
    _287 = 0;
    _288++;
    if (_288 < l)
    goto _jump926;
    // End body of loop
    double _289;
    // Computing bound for P
    if (h > 0) 
    goto _jump927;
    fail_assertion("non-positive loop bound");
    _jump927:;
    // Computing bound for Q
    if (c > 0) 
    goto _jump928;
    fail_assertion("non-positive loop bound");
    _jump928:;
    _289 = 0;
    int64_t _290 = 0; // Q
    int64_t _291 = 0; // P
    _jump929:; // Begin body of loop
    _289 += C;
    _290++;
    if (_290 < c)
    goto _jump929;
    _290 = 0;
    _291++;
    if (_291 < h)
    goto _jump929;
    // End body of loop
    double _292 = 24.0;
    rgba _293 = { _285, _286, _289, _292 };
    double _294 = _293.r;
    bool _295 = _284 <= _294;
    _a3_int64_t _296;
    if (!_295)
    goto _jump930;
    _296 = j;
    goto _jump931;
    _jump930:;
    _296 = j;
    _jump931:;
    double _297 = D(H, _296);
    _a2_double _298;
    // Computing bound for P
    _298.d0 = c;
    if (c > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    // Computing bound for Q
    _298.d1 = r;
    if (r > 0) 
    goto _jump933;
    fail_assertion("non-positive loop bound");
    _jump933:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= c;
    _299 *= r;
    _299 *= sizeof(double);
    _298.data = jpl_alloc(_299);
    int64_t _300 = 0; // Q
    int64_t _301 = 0; // P
    _jump934:; // Begin body of loop
    _a1_rgba _302;
    // Computing bound for R
    _302.d0 = f;
    if (f > 0) 
    goto _jump935;
    fail_assertion("non-positive loop bound");
    _jump935:;
    // Computing total size of heap memory to allocate
    int64_t _303 = 1;
    _303 *= f;
    _303 *= sizeof(rgba);
    _302.data = jpl_alloc(_303);
    int64_t _304 = 0; // R
    _jump936:; // Begin body of loop
    double _305 = 66.0;
    double _306 = 1.0;
    double _307 = 55.0;
    rgba _308 = { C, _305, _306, _307 };
    int64_t _309 = 0;
    _309 *= _302.d0;
    _309 += _304;
    _302.data[_309] = _308;
    _304++;
    if (_304 < f)
    goto _jump936;
    // End body of loop
    if (w >= 0)
    goto _jump937;
    fail_assertion("negative array index");
    _jump937:;
    if (w < _302.d0)
    goto _jump938;
    fail_assertion("index too large");
    _jump938:;
    int64_t _310 = 0;
    _310 *= _302.d0;
    _310 += w;
    rgba _311 = _302.data[_310];
    double _312 = _311.r;
    int64_t _313 = 0;
    _313 *= _298.d0;
    _313 += _301;
    _313 *= _298.d1;
    _313 += _300;
    _298.data[_313] = _312;
    _300++;
    if (_300 < r)
    goto _jump934;
    _300 = 0;
    _301++;
    if (_301 < c)
    goto _jump934;
    // End body of loop
    double _314 = D(_298, j);
    double _315;
    // Computing bound for P
    if (b > 0) 
    goto _jump939;
    fail_assertion("non-positive loop bound");
    _jump939:;
    _315 = 0;
    int64_t _316 = 0; // P
    _jump940:; // Begin body of loop
    double _317 = 71.0;
    _315 += _317;
    _316++;
    if (_316 < b)
    goto _jump940;
    // End body of loop
    double _318 = fmod(_315, C);
    double _319 = 77.0;
    bool _320 = !B;
    double _321;
    if (!_320)
    goto _jump941;
    _a2_double _322;
    // Computing bound for P
    _322.d0 = b;
    if (b > 0) 
    goto _jump942;
    fail_assertion("non-positive loop bound");
    _jump942:;
    // Computing bound for Q
    _322.d1 = A;
    if (A > 0) 
    goto _jump943;
    fail_assertion("non-positive loop bound");
    _jump943:;
    // Computing total size of heap memory to allocate
    int64_t _323 = 1;
    _323 *= b;
    _323 *= A;
    _323 *= sizeof(double);
    _322.data = jpl_alloc(_323);
    int64_t _324 = 0; // Q
    int64_t _325 = 0; // P
    _jump944:; // Begin body of loop
    double _326 = 86.0;
    double _327 = 73.0;
    double _328 = _326 * _327;
    int64_t _329 = 0;
    _329 *= _322.d0;
    _329 += _325;
    _329 *= _322.d1;
    _329 += _324;
    _322.data[_329] = _328;
    _324++;
    if (_324 < A)
    goto _jump944;
    _324 = 0;
    _325++;
    if (_325 < b)
    goto _jump944;
    // End body of loop
    double _330 = D(_322, j);
    _321 = _330;
    goto _jump945;
    _jump941:;
    _321 = C;
    _jump945:;
    double _331;
    // Computing bound for P
    if (r > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    _331 = 0;
    int64_t _332 = 0; // P
    _jump947:; // Begin body of loop
    double _333;
    // Computing bound for Q
    if (r > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing bound for R
    if (H.d0 > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    _333 = 0;
    int64_t _334 = 0; // R
    int64_t _335 = 0; // Q
    _jump950:; // Begin body of loop
    double _336 = -C;
    _333 += _336;
    _334++;
    if (_334 < H.d0)
    goto _jump950;
    _334 = 0;
    _335++;
    if (_335 < r)
    goto _jump950;
    // End body of loop
    if (d >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (d < H.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    if (d >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (d < H.d1)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    int64_t _337 = 0;
    _337 *= H.d0;
    _337 += d;
    _337 *= H.d1;
    _337 += d;
    double _338 = H.data[_337];
    double _339 = _333 + _338;
    _331 += _339;
    _332++;
    if (_332 < r)
    goto _jump947;
    // End body of loop
    rgba _340 = { _318, _319, _321, _331 };
    double _341 = _340.r;
    rgba _342 = { _282, _297, _314, _341 };
    _a1__a2_void_t _343;
    // Computing bound for V
    _343.d0 = y;
    if (y > 0) 
    goto _jump955;
    fail_assertion("non-positive loop bound");
    _jump955:;
    // Computing total size of heap memory to allocate
    int64_t _344 = 1;
    _344 *= y;
    _344 *= sizeof(_a2_void_t);
    _343.data = jpl_alloc(_344);
    int64_t _345 = 0; // V
    _jump956:; // Begin body of loop
    _a1__a2_double _346;
    // Computing bound for W
    _346.d0 = k;
    if (k > 0) 
    goto _jump957;
    fail_assertion("non-positive loop bound");
    _jump957:;
    // Computing total size of heap memory to allocate
    int64_t _347 = 1;
    _347 *= k;
    _347 *= sizeof(_a2_double);
    _346.data = jpl_alloc(_347);
    int64_t _348 = 0; // W
    _jump958:; // Begin body of loop
    int64_t _349 = 0;
    _349 *= _346.d0;
    _349 += _348;
    _346.data[_349] = H;
    _348++;
    if (_348 < k)
    goto _jump958;
    // End body of loop
    if (k >= 0)
    goto _jump959;
    fail_assertion("negative array index");
    _jump959:;
    if (k < _346.d0)
    goto _jump960;
    fail_assertion("index too large");
    _jump960:;
    int64_t _350 = 0;
    _350 *= _346.d0;
    _350 += k;
    _a2_double _351 = _346.data[_350];
    _a2_void_t _352 = G(_351);
    int64_t _353 = 0;
    _353 *= _343.d0;
    _353 += _345;
    _343.data[_353] = _352;
    _345++;
    if (_345 < y)
    goto _jump956;
    // End body of loop
    _a2_void_t _354;
    // Computing bound for V
    _354.d0 = d;
    if (d > 0) 
    goto _jump961;
    fail_assertion("non-positive loop bound");
    _jump961:;
    // Computing bound for W
    int64_t _355 = -z;
    _354.d1 = _355;
    if (_355 > 0) 
    goto _jump962;
    fail_assertion("non-positive loop bound");
    _jump962:;
    // Computing total size of heap memory to allocate
    int64_t _356 = 1;
    _356 *= d;
    _356 *= _355;
    _356 *= sizeof(void_t);
    _354.data = jpl_alloc(_356);
    int64_t _357 = 0; // W
    int64_t _358 = 0; // V
    _jump963:; // Begin body of loop
    _a2_void_t _359 = G(H);
    if (_248.d1 >= 0)
    goto _jump964;
    fail_assertion("negative array index");
    _jump964:;
    if (_248.d1 < _359.d0)
    goto _jump965;
    fail_assertion("index too large");
    _jump965:;
    if (p >= 0)
    goto _jump966;
    fail_assertion("negative array index");
    _jump966:;
    if (p < _359.d1)
    goto _jump967;
    fail_assertion("index too large");
    _jump967:;
    int64_t _360 = 0;
    _360 *= _359.d0;
    _360 += _248.d1;
    _360 *= _359.d1;
    _360 += p;
    void_t _361 = _359.data[_360];
    int64_t _362 = 0;
    _362 *= _354.d0;
    _362 += _358;
    _362 *= _354.d1;
    _362 += _357;
    _354.data[_362] = _361;
    _357++;
    if (_357 < _355)
    goto _jump963;
    _357 = 0;
    _358++;
    if (_358 < d)
    goto _jump963;
    // End body of loop
    _a2_void_t _363;
    if (!i)
    goto _jump968;
    _a2_double _364;
    // Computing bound for V
    _364.d0 = A;
    if (A > 0) 
    goto _jump969;
    fail_assertion("non-positive loop bound");
    _jump969:;
    // Computing bound for W
    _364.d1 = q.d2;
    if (q.d2 > 0) 
    goto _jump970;
    fail_assertion("non-positive loop bound");
    _jump970:;
    // Computing total size of heap memory to allocate
    int64_t _365 = 1;
    _365 *= A;
    _365 *= q.d2;
    _365 *= sizeof(double);
    _364.data = jpl_alloc(_365);
    int64_t _366 = 0; // W
    int64_t _367 = 0; // V
    _jump971:; // Begin body of loop
    int64_t _368 = 0;
    _368 *= _364.d0;
    _368 += _367;
    _368 *= _364.d1;
    _368 += _366;
    _364.data[_368] = C;
    _366++;
    if (_366 < q.d2)
    goto _jump971;
    _366 = 0;
    _367++;
    if (_367 < A)
    goto _jump971;
    // End body of loop
    _a2_void_t _369 = G(_364);
    _363 = _369;
    goto _jump972;
    _jump968:;
    _a2_void_t _370 = G(H);
    _363 = _370;
    _jump972:;
    _a2_double _371;
    // Computing bound for V
    _371.d0 = z;
    if (z > 0) 
    goto _jump973;
    fail_assertion("non-positive loop bound");
    _jump973:;
    // Computing bound for W
    _371.d1 = b;
    if (b > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    // Computing total size of heap memory to allocate
    int64_t _372 = 1;
    _372 *= z;
    _372 *= b;
    _372 *= sizeof(double);
    _371.data = jpl_alloc(_372);
    int64_t _373 = 0; // W
    int64_t _374 = 0; // V
    _jump975:; // Begin body of loop
    double _375 = 31.0;
    double _376 = 2.0;
    double _377 = _375 * _376;
    int64_t _378 = 0;
    _378 *= _371.d0;
    _378 += _374;
    _378 *= _371.d1;
    _378 += _373;
    _371.data[_378] = _377;
    _373++;
    if (_373 < b)
    goto _jump975;
    _373 = 0;
    _374++;
    if (_374 < z)
    goto _jump975;
    // End body of loop
    _a2_void_t _379 = G(_371);
    _a1__a2_void_t _380;
    _380.d0 = 3;
    _380.data = jpl_alloc(sizeof(_a2_void_t) * 3);
    _380.data[0] = _354;
    _380.data[1] = _363;
    _380.data[2] = _379;
    _a1__a1__a2_void_t _381;
    _381.d0 = 2;
    _381.data = jpl_alloc(sizeof(_a1__a2_void_t) * 2);
    _381.data[0] = _343;
    _381.data[1] = _380;
    int64_t _382;
    // Computing bound for V
    if (A > 0) 
    goto _jump976;
    fail_assertion("non-positive loop bound");
    _jump976:;
    _382 = 0;
    int64_t _383 = 0; // V
    _jump977:; // Begin body of loop
    _382 += t;
    _383++;
    if (_383 < A)
    goto _jump977;
    // End body of loop
    if (_382 >= 0)
    goto _jump978;
    fail_assertion("negative array index");
    _jump978:;
    if (_382 < _381.d0)
    goto _jump979;
    fail_assertion("index too large");
    _jump979:;
    int64_t _384 = 0;
    _384 *= _381.d0;
    _384 += _382;
    _a1__a2_void_t _385 = _381.data[_384];
    int64_t _386 = m * q.d2;
    if (_386 >= 0)
    goto _jump980;
    fail_assertion("negative array index");
    _jump980:;
    if (_386 < _385.d0)
    goto _jump981;
    fail_assertion("index too large");
    _jump981:;
    int64_t _387 = 0;
    _387 *= _385.d0;
    _387 += _386;
    _a2_void_t _388 = _385.data[_387];
    return _388;
}

bool U(bool V, _a1_double W) {
    if (0 != V)
    goto _jump1152;
    fail_assertion("Y");
    _jump1152:;
    bool _0 = true;
    if (0 != _0)
    goto _jump1153;
    fail_assertion("Z");
    _jump1153:;
    bool _1 = false;
    bool _2 = !_1;
    double _3;
    if (!_2)
    goto _jump1154;
    double _4;
    // Computing bound for Z
    if (A > 0) 
    goto _jump1155;
    fail_assertion("non-positive loop bound");
    _jump1155:;
    // Computing bound for aa
    if (R > 0) 
    goto _jump1156;
    fail_assertion("non-positive loop bound");
    _jump1156:;
    _4 = 0;
    int64_t _5 = 0; // aa
    int64_t _6 = 0; // Z
    _jump1157:; // Begin body of loop
    bool _7 = h > d;
    double _8;
    if (!_7)
    goto _jump1158;
    double _9 = 69.0;
    _8 = _9;
    goto _jump1159;
    _jump1158:;
    _8 = C;
    _jump1159:;
    _4 += _8;
    _5++;
    if (_5 < R)
    goto _jump1157;
    _5 = 0;
    _6++;
    if (_6 < A)
    goto _jump1157;
    // End body of loop
    _3 = _4;
    goto _jump1160;
    _jump1154:;
    bool _10 = P != o;
    rgba _11;
    if (!_10)
    goto _jump1161;
    if (I >= 0)
    goto _jump1162;
    fail_assertion("negative array index");
    _jump1162:;
    if (I < H.d0)
    goto _jump1163;
    fail_assertion("index too large");
    _jump1163:;
    if (W.d0 >= 0)
    goto _jump1164;
    fail_assertion("negative array index");
    _jump1164:;
    if (W.d0 < H.d1)
    goto _jump1165;
    fail_assertion("index too large");
    _jump1165:;
    if (P >= 0)
    goto _jump1166;
    fail_assertion("negative array index");
    _jump1166:;
    if (P < H.d2)
    goto _jump1167;
    fail_assertion("index too large");
    _jump1167:;
    int64_t _12 = 0;
    _12 *= H.d0;
    _12 += I;
    _12 *= H.d1;
    _12 += W.d0;
    _12 *= H.d2;
    _12 += P;
    double _13 = H.data[_12];
    int64_t _14 = 387;
    if (k >= 0)
    goto _jump1168;
    fail_assertion("negative array index");
    _jump1168:;
    if (k < q.d0)
    goto _jump1169;
    fail_assertion("index too large");
    _jump1169:;
    if (_14 >= 0)
    goto _jump1170;
    fail_assertion("negative array index");
    _jump1170:;
    if (_14 < q.d1)
    goto _jump1171;
    fail_assertion("index too large");
    _jump1171:;
    if (R >= 0)
    goto _jump1172;
    fail_assertion("negative array index");
    _jump1172:;
    if (R < q.d2)
    goto _jump1173;
    fail_assertion("index too large");
    _jump1173:;
    int64_t _15 = 0;
    _15 *= q.d0;
    _15 += k;
    _15 *= q.d1;
    _15 += _14;
    _15 *= q.d2;
    _15 += R;
    double _16 = q.data[_15];
    double _17 = 85.0;
    double _18 = -_17;
    double _19 = fmod(_16, _18);
    _a1_double _20;
    if (!B)
    goto _jump1174;
    _20 = W;
    goto _jump1175;
    _jump1174:;
    _20 = W;
    _jump1175:;
    if (t >= 0)
    goto _jump1176;
    fail_assertion("negative array index");
    _jump1176:;
    if (t < _20.d0)
    goto _jump1177;
    fail_assertion("index too large");
    _jump1177:;
    int64_t _21 = 0;
    _21 *= _20.d0;
    _21 += t;
    double _22 = _20.data[_21];
    rgba _23 = { _13, _19, _22, C };
    _11 = _23;
    goto _jump1178;
    _jump1161:;
    if (y >= 0)
    goto _jump1179;
    fail_assertion("negative array index");
    _jump1179:;
    if (y < W.d0)
    goto _jump1180;
    fail_assertion("index too large");
    _jump1180:;
    int64_t _24 = 0;
    _24 *= W.d0;
    _24 += y;
    double _25 = W.data[_24];
    double _26;
    // Computing bound for Z
    if (I > 0) 
    goto _jump1181;
    fail_assertion("non-positive loop bound");
    _jump1181:;
    _26 = 0;
    int64_t _27 = 0; // Z
    _jump1182:; // Begin body of loop
    double _28;
    if (!B)
    goto _jump1183;
    double _29 = 10.0;
    _28 = _29;
    goto _jump1184;
    _jump1183:;
    _28 = C;
    _jump1184:;
    _26 += _28;
    _27++;
    if (_27 < I)
    goto _jump1182;
    // End body of loop
    rgba _30 = { C, C, _25, _26 };
    _11 = _30;
    _jump1178:;
    double _31 = _11.a;
    _3 = _31;
    _jump1160:;
    _a2_double _32;
    if (!T)
    goto _jump1185;
    _a2_double _33;
    // Computing bound for Z
    _33.d0 = l;
    if (l > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    // Computing bound for aa
    _33.d1 = F;
    if (F > 0) 
    goto _jump1187;
    fail_assertion("non-positive loop bound");
    _jump1187:;
    // Computing total size of heap memory to allocate
    int64_t _34 = 1;
    _34 *= l;
    _34 *= F;
    _34 *= sizeof(double);
    _33.data = jpl_alloc(_34);
    int64_t _35 = 0; // aa
    int64_t _36 = 0; // Z
    _jump1188:; // Begin body of loop
    double _37 = 79.0;
    int64_t _38 = 0;
    _38 *= _33.d0;
    _38 += _36;
    _38 *= _33.d1;
    _38 += _35;
    _33.data[_38] = _37;
    _35++;
    if (_35 < F)
    goto _jump1188;
    _35 = 0;
    _36++;
    if (_36 < l)
    goto _jump1188;
    // End body of loop
    _32 = _33;
    goto _jump1189;
    _jump1185:;
    _a2_double _39;
    // Computing bound for Z
    _39.d0 = y;
    if (y > 0) 
    goto _jump1190;
    fail_assertion("non-positive loop bound");
    _jump1190:;
    // Computing bound for aa
    _39.d1 = R;
    if (R > 0) 
    goto _jump1191;
    fail_assertion("non-positive loop bound");
    _jump1191:;
    // Computing total size of heap memory to allocate
    int64_t _40 = 1;
    _40 *= y;
    _40 *= R;
    _40 *= sizeof(double);
    _39.data = jpl_alloc(_40);
    int64_t _41 = 0; // aa
    int64_t _42 = 0; // Z
    _jump1192:; // Begin body of loop
    double _43 = 72.0;
    int64_t _44 = 0;
    _44 *= _39.d0;
    _44 += _42;
    _44 *= _39.d1;
    _44 += _41;
    _39.data[_44] = _43;
    _41++;
    if (_41 < R)
    goto _jump1192;
    _41 = 0;
    _42++;
    if (_42 < y)
    goto _jump1192;
    // End body of loop
    _32 = _39;
    _jump1189:;
    bool _45 = B;
    if (0 != B)
    goto _jump1193;
    _45 = i;
    _jump1193:;
    _a3_int64_t _46;
    if (!_45)
    goto _jump1194;
    _46 = j;
    goto _jump1195;
    _jump1194:;
    _a3_int64_t _47;
    if (!V)
    goto _jump1196;
    _47 = j;
    goto _jump1197;
    _jump1196:;
    _47 = j;
    _jump1197:;
    _46 = _47;
    _jump1195:;
    double _48 = D(_32, _46);
    bool _49 = !B;
    double _50;
    if (!_49)
    goto _jump1198;
    _50 = C;
    goto _jump1199;
    _jump1198:;
    double _51;
    // Computing bound for Z
    if (F > 0) 
    goto _jump1200;
    fail_assertion("non-positive loop bound");
    _jump1200:;
    _51 = 0;
    int64_t _52 = 0; // Z
    _jump1201:; // Begin body of loop
    _51 += C;
    _52++;
    if (_52 < F)
    goto _jump1201;
    // End body of loop
    _50 = _51;
    _jump1199:;
    bool _53 = _48 != _50;
    _a2_double _54;
    if (!_53)
    goto _jump1202;
    _a2_double _55;
    if (!V)
    goto _jump1203;
    _a2_double _56;
    // Computing bound for Z
    _56.d0 = O;
    if (O > 0) 
    goto _jump1204;
    fail_assertion("non-positive loop bound");
    _jump1204:;
    // Computing bound for aa
    _56.d1 = r;
    if (r > 0) 
    goto _jump1205;
    fail_assertion("non-positive loop bound");
    _jump1205:;
    // Computing total size of heap memory to allocate
    int64_t _57 = 1;
    _57 *= O;
    _57 *= r;
    _57 *= sizeof(double);
    _56.data = jpl_alloc(_57);
    int64_t _58 = 0; // aa
    int64_t _59 = 0; // Z
    _jump1206:; // Begin body of loop
    double _60 = 46.0;
    double _61 = C + _60;
    int64_t _62 = 0;
    _62 *= _56.d0;
    _62 += _59;
    _62 *= _56.d1;
    _62 += _58;
    _56.data[_62] = _61;
    _58++;
    if (_58 < r)
    goto _jump1206;
    _58 = 0;
    _59++;
    if (_59 < O)
    goto _jump1206;
    // End body of loop
    _55 = _56;
    goto _jump1207;
    _jump1203:;
    _a2_double _63;
    // Computing bound for Z
    _63.d0 = y;
    if (y > 0) 
    goto _jump1208;
    fail_assertion("non-positive loop bound");
    _jump1208:;
    // Computing bound for aa
    _63.d1 = I;
    if (I > 0) 
    goto _jump1209;
    fail_assertion("non-positive loop bound");
    _jump1209:;
    // Computing total size of heap memory to allocate
    int64_t _64 = 1;
    _64 *= y;
    _64 *= I;
    _64 *= sizeof(double);
    _63.data = jpl_alloc(_64);
    int64_t _65 = 0; // aa
    int64_t _66 = 0; // Z
    _jump1210:; // Begin body of loop
    double _67;
    // Computing bound for ab
    if (y > 0) 
    goto _jump1211;
    fail_assertion("non-positive loop bound");
    _jump1211:;
    _67 = 0;
    int64_t _68 = 0; // ab
    _jump1212:; // Begin body of loop
    double _69 = 32.0;
    double _70 = fmod(_69, C);
    _67 += _70;
    _68++;
    if (_68 < y)
    goto _jump1212;
    // End body of loop
    int64_t _71 = 0;
    _71 *= _63.d0;
    _71 += _66;
    _71 *= _63.d1;
    _71 += _65;
    _63.data[_71] = _67;
    _65++;
    if (_65 < I)
    goto _jump1210;
    _65 = 0;
    _66++;
    if (_66 < y)
    goto _jump1210;
    // End body of loop
    _55 = _63;
    _jump1207:;
    _54 = _55;
    goto _jump1213;
    _jump1202:;
    bool _72 = l < k;
    _a2_double _73;
    if (!_72)
    goto _jump1214;
    _a2_double _74;
    // Computing bound for Z
    _74.d0 = y;
    if (y > 0) 
    goto _jump1215;
    fail_assertion("non-positive loop bound");
    _jump1215:;
    // Computing bound for aa
    _74.d1 = R;
    if (R > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing total size of heap memory to allocate
    int64_t _75 = 1;
    _75 *= y;
    _75 *= R;
    _75 *= sizeof(double);
    _74.data = jpl_alloc(_75);
    int64_t _76 = 0; // aa
    int64_t _77 = 0; // Z
    _jump1217:; // Begin body of loop
    _a1_double _78;
    _78.d0 = 1;
    _78.data = jpl_alloc(sizeof(double) * 1);
    _78.data[0] = C;
    if (z >= 0)
    goto _jump1218;
    fail_assertion("negative array index");
    _jump1218:;
    if (z < _78.d0)
    goto _jump1219;
    fail_assertion("index too large");
    _jump1219:;
    int64_t _79 = 0;
    _79 *= _78.d0;
    _79 += z;
    double _80 = _78.data[_79];
    int64_t _81 = 0;
    _81 *= _74.d0;
    _81 += _77;
    _81 *= _74.d1;
    _81 += _76;
    _74.data[_81] = _80;
    _76++;
    if (_76 < R)
    goto _jump1217;
    _76 = 0;
    _77++;
    if (_77 < y)
    goto _jump1217;
    // End body of loop
    _73 = _74;
    goto _jump1220;
    _jump1214:;
    _a3__a2_double _82;
    // Computing bound for Z
    _82.d0 = M;
    if (M > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing bound for aa
    _82.d1 = N;
    if (N > 0) 
    goto _jump1222;
    fail_assertion("non-positive loop bound");
    _jump1222:;
    // Computing bound for ab
    int64_t _83 = 764;
    _82.d2 = _83;
    if (_83 > 0) 
    goto _jump1223;
    fail_assertion("non-positive loop bound");
    _jump1223:;
    // Computing total size of heap memory to allocate
    int64_t _84 = 1;
    _84 *= M;
    _84 *= N;
    _84 *= _83;
    _84 *= sizeof(_a2_double);
    _82.data = jpl_alloc(_84);
    int64_t _85 = 0; // ab
    int64_t _86 = 0; // aa
    int64_t _87 = 0; // Z
    _jump1224:; // Begin body of loop
    _a2_double _88;
    // Computing bound for ac
    _88.d0 = O;
    if (O > 0) 
    goto _jump1225;
    fail_assertion("non-positive loop bound");
    _jump1225:;
    // Computing bound for ad
    _88.d1 = g;
    if (g > 0) 
    goto _jump1226;
    fail_assertion("non-positive loop bound");
    _jump1226:;
    // Computing total size of heap memory to allocate
    int64_t _89 = 1;
    _89 *= O;
    _89 *= g;
    _89 *= sizeof(double);
    _88.data = jpl_alloc(_89);
    int64_t _90 = 0; // ad
    int64_t _91 = 0; // ac
    _jump1227:; // Begin body of loop
    double _92 = 88.0;
    int64_t _93 = 0;
    _93 *= _88.d0;
    _93 += _91;
    _93 *= _88.d1;
    _93 += _90;
    _88.data[_93] = _92;
    _90++;
    if (_90 < g)
    goto _jump1227;
    _90 = 0;
    _91++;
    if (_91 < O)
    goto _jump1227;
    // End body of loop
    int64_t _94 = 0;
    _94 *= _82.d0;
    _94 += _87;
    _94 *= _82.d1;
    _94 += _86;
    _94 *= _82.d2;
    _94 += _85;
    _82.data[_94] = _88;
    _85++;
    if (_85 < _83)
    goto _jump1224;
    _85 = 0;
    _86++;
    if (_86 < N)
    goto _jump1224;
    _86 = 0;
    _87++;
    if (_87 < M)
    goto _jump1224;
    // End body of loop
    bool _95 = m <= o;
    int64_t _96;
    if (!_95)
    goto _jump1228;
    _96 = J;
    goto _jump1229;
    _jump1228:;
    _96 = h;
    _jump1229:;
    if (b >= 0)
    goto _jump1230;
    fail_assertion("negative array index");
    _jump1230:;
    if (b < _82.d0)
    goto _jump1231;
    fail_assertion("index too large");
    _jump1231:;
    if (b >= 0)
    goto _jump1232;
    fail_assertion("negative array index");
    _jump1232:;
    if (b < _82.d1)
    goto _jump1233;
    fail_assertion("index too large");
    _jump1233:;
    if (_96 >= 0)
    goto _jump1234;
    fail_assertion("negative array index");
    _jump1234:;
    if (_96 < _82.d2)
    goto _jump1235;
    fail_assertion("index too large");
    _jump1235:;
    int64_t _97 = 0;
    _97 *= _82.d0;
    _97 += b;
    _97 *= _82.d1;
    _97 += b;
    _97 *= _82.d2;
    _97 += _96;
    _a2_double _98 = _82.data[_97];
    _73 = _98;
    _jump1220:;
    _54 = _73;
    _jump1213:;
    _a3_int64_t _99;
    // Computing bound for Z
    _99.d0 = S;
    if (S > 0) 
    goto _jump1236;
    fail_assertion("non-positive loop bound");
    _jump1236:;
    // Computing bound for aa
    _99.d1 = w;
    if (w > 0) 
    goto _jump1237;
    fail_assertion("non-positive loop bound");
    _jump1237:;
    // Computing bound for ab
    int64_t _100 = -t;
    _99.d2 = _100;
    if (_100 > 0) 
    goto _jump1238;
    fail_assertion("non-positive loop bound");
    _jump1238:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= S;
    _101 *= w;
    _101 *= _100;
    _101 *= sizeof(int64_t);
    _99.data = jpl_alloc(_101);
    int64_t _102 = 0; // ab
    int64_t _103 = 0; // aa
    int64_t _104 = 0; // Z
    _jump1239:; // Begin body of loop
    int64_t _105 = 0;
    _105 *= _99.d0;
    _105 += _104;
    _105 *= _99.d1;
    _105 += _103;
    _105 *= _99.d2;
    _105 += _102;
    _99.data[_105] = K;
    _102++;
    if (_102 < _100)
    goto _jump1239;
    _102 = 0;
    _103++;
    if (_103 < w)
    goto _jump1239;
    _103 = 0;
    _104++;
    if (_104 < S)
    goto _jump1239;
    // End body of loop
    double _106 = D(_54, _99);
    bool _107 = _3 > _106;
    if (0 != _107)
    goto _jump1240;
    fail_assertion("Z");
    _jump1240:;
    _a1_int64_t _108;
    if (!T)
    goto _jump1241;
    _a1_int64_t _109;
    // Computing bound for aa
    int64_t _110 = M % r;
    int64_t _111 = -_110;
    _109.d0 = _111;
    if (_111 > 0) 
    goto _jump1242;
    fail_assertion("non-positive loop bound");
    _jump1242:;
    // Computing total size of heap memory to allocate
    int64_t _112 = 1;
    _112 *= _111;
    _112 *= sizeof(int64_t);
    _109.data = jpl_alloc(_112);
    int64_t _113 = 0; // aa
    _jump1243:; // Begin body of loop
    int64_t _114 = 0;
    _114 *= _109.d0;
    _114 += _113;
    _109.data[_114] = y;
    _113++;
    if (_113 < _111)
    goto _jump1243;
    // End body of loop
    _108 = _109;
    goto _jump1244;
    _jump1241:;
    _108 = E;
    _jump1244:;
    bool _115 = R == y;
    _a2_double _116;
    if (!_115)
    goto _jump1245;
    _a2_double _117;
    // Computing bound for ac
    _117.d0 = R;
    if (R > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing bound for ad
    _117.d1 = P;
    if (P > 0) 
    goto _jump1247;
    fail_assertion("non-positive loop bound");
    _jump1247:;
    // Computing total size of heap memory to allocate
    int64_t _118 = 1;
    _118 *= R;
    _118 *= P;
    _118 *= sizeof(double);
    _117.data = jpl_alloc(_118);
    int64_t _119 = 0; // ad
    int64_t _120 = 0; // ac
    _jump1248:; // Begin body of loop
    double _121 = 27.0;
    int64_t _122 = 0;
    _122 *= _117.d0;
    _122 += _120;
    _122 *= _117.d1;
    _122 += _119;
    _117.data[_122] = _121;
    _119++;
    if (_119 < P)
    goto _jump1248;
    _119 = 0;
    _120++;
    if (_120 < R)
    goto _jump1248;
    // End body of loop
    _116 = _117;
    goto _jump1249;
    _jump1245:;
    _a2_double _123;
    // Computing bound for ac
    _123.d0 = y;
    if (y > 0) 
    goto _jump1250;
    fail_assertion("non-positive loop bound");
    _jump1250:;
    // Computing bound for ad
    _123.d1 = S;
    if (S > 0) 
    goto _jump1251;
    fail_assertion("non-positive loop bound");
    _jump1251:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= y;
    _124 *= S;
    _124 *= sizeof(double);
    _123.data = jpl_alloc(_124);
    int64_t _125 = 0; // ad
    int64_t _126 = 0; // ac
    _jump1252:; // Begin body of loop
    int64_t _127 = 0;
    _127 *= _123.d0;
    _127 += _126;
    _127 *= _123.d1;
    _127 += _125;
    _123.data[_127] = C;
    _125++;
    if (_125 < S)
    goto _jump1252;
    _125 = 0;
    _126++;
    if (_126 < y)
    goto _jump1252;
    // End body of loop
    _116 = _123;
    _jump1249:;
    _a3_int64_t _128;
    // Computing bound for ac
    _128.d0 = R;
    if (R > 0) 
    goto _jump1253;
    fail_assertion("non-positive loop bound");
    _jump1253:;
    // Computing bound for ad
    _128.d1 = y;
    if (y > 0) 
    goto _jump1254;
    fail_assertion("non-positive loop bound");
    _jump1254:;
    // Computing bound for ae
    _128.d2 = y;
    if (y > 0) 
    goto _jump1255;
    fail_assertion("non-positive loop bound");
    _jump1255:;
    // Computing total size of heap memory to allocate
    int64_t _129 = 1;
    _129 *= R;
    _129 *= y;
    _129 *= y;
    _129 *= sizeof(int64_t);
    _128.data = jpl_alloc(_129);
    int64_t _130 = 0; // ae
    int64_t _131 = 0; // ad
    int64_t _132 = 0; // ac
    _jump1256:; // Begin body of loop
    int64_t _133 = 0;
    _133 *= _128.d0;
    _133 += _132;
    _133 *= _128.d1;
    _133 += _131;
    _133 *= _128.d2;
    _133 += _130;
    _128.data[_133] = N;
    _130++;
    if (_130 < y)
    goto _jump1256;
    _130 = 0;
    _131++;
    if (_131 < y)
    goto _jump1256;
    _131 = 0;
    _132++;
    if (_132 < R)
    goto _jump1256;
    // End body of loop
    double _134 = D(_116, _128);
    bool _135 = i;
    if (0 != i)
    goto _jump1257;
    _135 = T;
    _jump1257:;
    double _136;
    if (!_135)
    goto _jump1258;
    if (p >= 0)
    goto _jump1259;
    fail_assertion("negative array index");
    _jump1259:;
    if (p < W.d0)
    goto _jump1260;
    fail_assertion("index too large");
    _jump1260:;
    int64_t _137 = 0;
    _137 *= W.d0;
    _137 += p;
    double _138 = W.data[_137];
    double _139 = -_138;
    _136 = _139;
    goto _jump1261;
    _jump1258:;
    _a2_double _140;
    // Computing bound for ac
    _140.d0 = z;
    if (z > 0) 
    goto _jump1262;
    fail_assertion("non-positive loop bound");
    _jump1262:;
    // Computing bound for ad
    _140.d1 = d;
    if (d > 0) 
    goto _jump1263;
    fail_assertion("non-positive loop bound");
    _jump1263:;
    // Computing total size of heap memory to allocate
    int64_t _141 = 1;
    _141 *= z;
    _141 *= d;
    _141 *= sizeof(double);
    _140.data = jpl_alloc(_141);
    int64_t _142 = 0; // ad
    int64_t _143 = 0; // ac
    _jump1264:; // Begin body of loop
    int64_t _144 = 0;
    _144 *= _140.d0;
    _144 += _143;
    _144 *= _140.d1;
    _144 += _142;
    _140.data[_144] = C;
    _142++;
    if (_142 < d)
    goto _jump1264;
    _142 = 0;
    _143++;
    if (_143 < z)
    goto _jump1264;
    // End body of loop
    double _145 = D(_140, j);
    _136 = _145;
    _jump1261:;
    bool _146 = _134 >= _136;
    double _147;
    if (!T)
    goto _jump1265;
    double _148 = 73.0;
    _147 = _148;
    goto _jump1266;
    _jump1265:;
    _a2_double _149;
    // Computing bound for ac
    _149.d0 = J;
    if (J > 0) 
    goto _jump1267;
    fail_assertion("non-positive loop bound");
    _jump1267:;
    // Computing bound for ad
    _149.d1 = h;
    if (h > 0) 
    goto _jump1268;
    fail_assertion("non-positive loop bound");
    _jump1268:;
    // Computing total size of heap memory to allocate
    int64_t _150 = 1;
    _150 *= J;
    _150 *= h;
    _150 *= sizeof(double);
    _149.data = jpl_alloc(_150);
    int64_t _151 = 0; // ad
    int64_t _152 = 0; // ac
    _jump1269:; // Begin body of loop
    double _153 = 78.0;
    int64_t _154 = 0;
    _154 *= _149.d0;
    _154 += _152;
    _154 *= _149.d1;
    _154 += _151;
    _149.data[_154] = _153;
    _151++;
    if (_151 < h)
    goto _jump1269;
    _151 = 0;
    _152++;
    if (_152 < J)
    goto _jump1269;
    // End body of loop
    double _155 = D(_149, e);
    _147 = _155;
    _jump1266:;
    double _156 = 18.0;
    double _157 = 9.0;
    double _158 = -_157;
    double _159;
    if (!V)
    goto _jump1270;
    _159 = C;
    goto _jump1271;
    _jump1270:;
    double _160 = 12.0;
    _159 = _160;
    _jump1271:;
    rgba _161 = { _156, C, _158, _159 };
    double _162 = _161.g;
    _a1_double _163;
    _163.d0 = 2;
    _163.data = jpl_alloc(sizeof(double) * 2);
    _163.data[0] = _147;
    _163.data[1] = _162;
    bool _164 = U(_146, _163);
    bool _165 = !_164;
    double _166 = 16.0;
    double _167 = _166 + C;
    bool _168 = _167 > C;
    _a3__a1__a1_double _169;
    if (!_168)
    goto _jump1272;
    _a3__a1__a1_double _170;
    // Computing bound for ac
    _170.d0 = y;
    if (y > 0) 
    goto _jump1273;
    fail_assertion("non-positive loop bound");
    _jump1273:;
    // Computing bound for ad
    _170.d1 = g;
    if (g > 0) 
    goto _jump1274;
    fail_assertion("non-positive loop bound");
    _jump1274:;
    // Computing bound for ae
    _170.d2 = R;
    if (R > 0) 
    goto _jump1275;
    fail_assertion("non-positive loop bound");
    _jump1275:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= y;
    _171 *= g;
    _171 *= R;
    _171 *= sizeof(_a1__a1_double);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // ae
    int64_t _173 = 0; // ad
    int64_t _174 = 0; // ac
    _jump1276:; // Begin body of loop
    _a1__a1_double _175;
    _175.d0 = 1;
    _175.data = jpl_alloc(sizeof(_a1_double) * 1);
    _175.data[0] = W;
    int64_t _176 = 0;
    _176 *= _170.d0;
    _176 += _174;
    _176 *= _170.d1;
    _176 += _173;
    _176 *= _170.d2;
    _176 += _172;
    _170.data[_176] = _175;
    _172++;
    if (_172 < R)
    goto _jump1276;
    _172 = 0;
    _173++;
    if (_173 < g)
    goto _jump1276;
    _173 = 0;
    _174++;
    if (_174 < y)
    goto _jump1276;
    // End body of loop
    _169 = _170;
    goto _jump1277;
    _jump1272:;
    _a3__a1__a1_double _177;
    if (!V)
    goto _jump1278;
    _a3__a1__a1_double _178;
    // Computing bound for ac
    _178.d0 = h;
    if (h > 0) 
    goto _jump1279;
    fail_assertion("non-positive loop bound");
    _jump1279:;
    // Computing bound for ad
    int64_t _179 = k / t;
    _178.d1 = _179;
    if (_179 > 0) 
    goto _jump1280;
    fail_assertion("non-positive loop bound");
    _jump1280:;
    // Computing bound for ae
    if (w >= 0)
    goto _jump1281;
    fail_assertion("negative array index");
    _jump1281:;
    if (w < E.d0)
    goto _jump1282;
    fail_assertion("index too large");
    _jump1282:;
    int64_t _180 = 0;
    _180 *= E.d0;
    _180 += w;
    int64_t _181 = E.data[_180];
    _178.d2 = _181;
    if (_181 > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing total size of heap memory to allocate
    int64_t _182 = 1;
    _182 *= h;
    _182 *= _179;
    _182 *= _181;
    _182 *= sizeof(_a1__a1_double);
    _178.data = jpl_alloc(_182);
    int64_t _183 = 0; // ae
    int64_t _184 = 0; // ad
    int64_t _185 = 0; // ac
    _jump1284:; // Begin body of loop
    _a1__a1_double _186;
    // Computing bound for af
    _186.d0 = t;
    if (t > 0) 
    goto _jump1285;
    fail_assertion("non-positive loop bound");
    _jump1285:;
    // Computing total size of heap memory to allocate
    int64_t _187 = 1;
    _187 *= t;
    _187 *= sizeof(_a1_double);
    _186.data = jpl_alloc(_187);
    int64_t _188 = 0; // af
    _jump1286:; // Begin body of loop
    int64_t _189 = 0;
    _189 *= _186.d0;
    _189 += _188;
    _186.data[_189] = W;
    _188++;
    if (_188 < t)
    goto _jump1286;
    // End body of loop
    int64_t _190 = 0;
    _190 *= _178.d0;
    _190 += _185;
    _190 *= _178.d1;
    _190 += _184;
    _190 *= _178.d2;
    _190 += _183;
    _178.data[_190] = _186;
    _183++;
    if (_183 < _181)
    goto _jump1284;
    _183 = 0;
    _184++;
    if (_184 < _179)
    goto _jump1284;
    _184 = 0;
    _185++;
    if (_185 < h)
    goto _jump1284;
    // End body of loop
    _177 = _178;
    goto _jump1287;
    _jump1278:;
    _a3__a1__a1_double _191;
    // Computing bound for ac
    _191.d0 = d;
    if (d > 0) 
    goto _jump1288;
    fail_assertion("non-positive loop bound");
    _jump1288:;
    // Computing bound for ad
    _191.d1 = d;
    if (d > 0) 
    goto _jump1289;
    fail_assertion("non-positive loop bound");
    _jump1289:;
    // Computing bound for ae
    _191.d2 = F;
    if (F > 0) 
    goto _jump1290;
    fail_assertion("non-positive loop bound");
    _jump1290:;
    // Computing total size of heap memory to allocate
    int64_t _192 = 1;
    _192 *= d;
    _192 *= d;
    _192 *= F;
    _192 *= sizeof(_a1__a1_double);
    _191.data = jpl_alloc(_192);
    int64_t _193 = 0; // ae
    int64_t _194 = 0; // ad
    int64_t _195 = 0; // ac
    _jump1291:; // Begin body of loop
    _a1__a1_double _196;
    // Computing bound for af
    _196.d0 = K;
    if (K > 0) 
    goto _jump1292;
    fail_assertion("non-positive loop bound");
    _jump1292:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= K;
    _197 *= sizeof(_a1_double);
    _196.data = jpl_alloc(_197);
    int64_t _198 = 0; // af
    _jump1293:; // Begin body of loop
    int64_t _199 = 0;
    _199 *= _196.d0;
    _199 += _198;
    _196.data[_199] = W;
    _198++;
    if (_198 < K)
    goto _jump1293;
    // End body of loop
    int64_t _200 = 0;
    _200 *= _191.d0;
    _200 += _195;
    _200 *= _191.d1;
    _200 += _194;
    _200 *= _191.d2;
    _200 += _193;
    _191.data[_200] = _196;
    _193++;
    if (_193 < F)
    goto _jump1291;
    _193 = 0;
    _194++;
    if (_194 < d)
    goto _jump1291;
    _194 = 0;
    _195++;
    if (_195 < d)
    goto _jump1291;
    // End body of loop
    _177 = _191;
    _jump1287:;
    _169 = _177;
    _jump1277:;
    if (o >= 0)
    goto _jump1294;
    fail_assertion("negative array index");
    _jump1294:;
    if (o < _169.d0)
    goto _jump1295;
    fail_assertion("index too large");
    _jump1295:;
    if (w >= 0)
    goto _jump1296;
    fail_assertion("negative array index");
    _jump1296:;
    if (w < _169.d1)
    goto _jump1297;
    fail_assertion("index too large");
    _jump1297:;
    if (R >= 0)
    goto _jump1298;
    fail_assertion("negative array index");
    _jump1298:;
    if (R < _169.d2)
    goto _jump1299;
    fail_assertion("index too large");
    _jump1299:;
    int64_t _201 = 0;
    _201 *= _169.d0;
    _201 += o;
    _201 *= _169.d1;
    _201 += w;
    _201 *= _169.d2;
    _201 += R;
    _a1__a1_double _202 = _169.data[_201];
    if (c >= 0)
    goto _jump1300;
    fail_assertion("negative array index");
    _jump1300:;
    if (c < _202.d0)
    goto _jump1301;
    fail_assertion("index too large");
    _jump1301:;
    int64_t _203 = 0;
    _203 *= _202.d0;
    _203 += c;
    _a1_double _204 = _202.data[_203];
    bool _205 = U(_165, _204);
    return _205;
}

void jpl_main(struct args args) {
    bool _1 = false;
    bool _0 = _1;
    if (0 != _1)
    goto _jump1;
    double _2;
    // Computing bound for a
    int64_t _3 = 711;
    if (_3 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    _2 = 0;
    int64_t _4 = 0; // a
    _jump3:; // Begin body of loop
    double _5 = 53.0;
    double _6 = -_5;
    double _7 = -_6;
    _2 += _7;
    _4++;
    if (_4 < _3)
    goto _jump3;
    // End body of loop
    double _8 = 68.0;
    bool _9 = _2 > _8;
    _0 = _9;
    _jump1:;
    bool _10;
    if (!_0)
    goto _jump4;
    _a1__a1_bool _11;
    // Computing bound for a
    int64_t _12 = 407;
    _11.d0 = _12;
    if (_12 > 0) 
    goto _jump5;
    fail_assertion("non-positive loop bound");
    _jump5:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _12;
    _13 *= sizeof(_a1_bool);
    _11.data = jpl_alloc(_13);
    int64_t _14 = 0; // a
    _jump6:; // Begin body of loop
    _a1_bool _15;
    // Computing bound for b
    _15.d0 = _14;
    if (_14 > 0) 
    goto _jump7;
    fail_assertion("non-positive loop bound");
    _jump7:;
    // Computing total size of heap memory to allocate
    int64_t _16 = 1;
    _16 *= _14;
    _16 *= sizeof(bool);
    _15.data = jpl_alloc(_16);
    int64_t _17 = 0; // b
    _jump8:; // Begin body of loop
    bool _18 = false;
    bool _19 = !_18;
    int64_t _20 = 0;
    _20 *= _15.d0;
    _20 += _17;
    _15.data[_20] = _19;
    _17++;
    if (_17 < _14)
    goto _jump8;
    // End body of loop
    int64_t _21 = 0;
    _21 *= _11.d0;
    _21 += _14;
    _11.data[_21] = _15;
    _14++;
    if (_14 < _12)
    goto _jump6;
    // End body of loop
    int64_t _22 = 444;
    if (_22 >= 0)
    goto _jump9;
    fail_assertion("negative array index");
    _jump9:;
    if (_22 < _11.d0)
    goto _jump10;
    fail_assertion("index too large");
    _jump10:;
    int64_t _23 = 0;
    _23 *= _11.d0;
    _23 += _22;
    _a1_bool _24 = _11.data[_23];
    int64_t _25;
    // Computing bound for a
    int64_t _26;
    // Computing bound for a
    int64_t _27 = 155;
    if (_27 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    _26 = 0;
    int64_t _28 = 0; // a
    _jump12:; // Begin body of loop
    int64_t _29 = -_28;
    _26 += _29;
    _28++;
    if (_28 < _27)
    goto _jump12;
    // End body of loop
    int64_t _30 = -_26;
    if (_30 > 0) 
    goto _jump13;
    fail_assertion("non-positive loop bound");
    _jump13:;
    // Computing bound for b
    int64_t _31 = 978;
    int64_t _32 = 209;
    int64_t _33 = _31 / _32;
    int64_t _34 = 773;
    int64_t _35 = 885;
    int64_t _36 = _34 - _35;
    int64_t _37 = _33 - _36;
    if (_37 > 0) 
    goto _jump14;
    fail_assertion("non-positive loop bound");
    _jump14:;
    // Computing bound for c
    int64_t _38;
    // Computing bound for a
    int64_t _39;
    // Computing bound for a
    int64_t _40 = 683;
    if (_40 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    // Computing bound for b
    int64_t _41 = 365;
    if (_41 > 0) 
    goto _jump16;
    fail_assertion("non-positive loop bound");
    _jump16:;
    _39 = 0;
    int64_t _42 = 0; // b
    int64_t _43 = 0; // a
    _jump17:; // Begin body of loop
    int64_t _44 = -_43;
    _39 += _44;
    _42++;
    if (_42 < _41)
    goto _jump17;
    _42 = 0;
    _43++;
    if (_43 < _40)
    goto _jump17;
    // End body of loop
    if (_39 > 0) 
    goto _jump18;
    fail_assertion("non-positive loop bound");
    _jump18:;
    _38 = 0;
    int64_t _45 = 0; // a
    _jump19:; // Begin body of loop
    int64_t _46 = 403;
    int64_t _47 = -_46;
    _38 += _47;
    _45++;
    if (_45 < _39)
    goto _jump19;
    // End body of loop
    if (_38 > 0) 
    goto _jump20;
    fail_assertion("non-positive loop bound");
    _jump20:;
    _25 = 0;
    int64_t _48 = 0; // c
    int64_t _49 = 0; // b
    int64_t _50 = 0; // a
    _jump21:; // Begin body of loop
    int64_t _51;
    // Computing bound for d
    if (_50 > 0) 
    goto _jump22;
    fail_assertion("non-positive loop bound");
    _jump22:;
    // Computing bound for e
    double _52 = 24.0;
    double _53 = 51.0;
    bool _54 = _52 != _53;
    int64_t _55;
    if (!_54)
    goto _jump23;
    bool _56 = true;
    int64_t _57;
    if (!_56)
    goto _jump24;
    _57 = _50;
    goto _jump25;
    _jump24:;
    int64_t _58 = 863;
    _57 = _58;
    _jump25:;
    _55 = _57;
    goto _jump26;
    _jump23:;
    int64_t _59 = -_48;
    _55 = _59;
    _jump26:;
    if (_55 > 0) 
    goto _jump27;
    fail_assertion("non-positive loop bound");
    _jump27:;
    // Computing bound for f
    int64_t _60 = 481;
    int64_t _61 = -_60;
    if (_61 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    _51 = 0;
    int64_t _62 = 0; // f
    int64_t _63 = 0; // e
    int64_t _64 = 0; // d
    _jump29:; // Begin body of loop
    _51 += _62;
    _62++;
    if (_62 < _61)
    goto _jump29;
    _62 = 0;
    _63++;
    if (_63 < _55)
    goto _jump29;
    _63 = 0;
    _64++;
    if (_64 < _50)
    goto _jump29;
    // End body of loop
    _25 += _51;
    _48++;
    if (_48 < _38)
    goto _jump21;
    _48 = 0;
    _49++;
    if (_49 < _37)
    goto _jump21;
    _49 = 0;
    _50++;
    if (_50 < _30)
    goto _jump21;
    // End body of loop
    if (_25 >= 0)
    goto _jump30;
    fail_assertion("negative array index");
    _jump30:;
    if (_25 < _24.d0)
    goto _jump31;
    fail_assertion("index too large");
    _jump31:;
    int64_t _65 = 0;
    _65 *= _24.d0;
    _65 += _25;
    bool _66 = _24.data[_65];
    _10 = _66;
    goto _jump32;
    _jump4:;
    bool _67 = false;
    bool _68 = !_67;
    bool _69;
    if (!_68)
    goto _jump33;
    double _70 = 60.0;
    double _71 = 39.0;
    double _72 = -_71;
    bool _73 = _70 != _72;
    _69 = _73;
    goto _jump34;
    _jump33:;
    bool _74 = false;
    bool _75 = !_74;
    _69 = _75;
    _jump34:;
    bool _76 = false;
    bool _77 = _69 != _76;
    bool _78 = !_77;
    _10 = _78;
    _jump32:;
    _a3_double _79;
    if (!_10)
    goto _jump35;
    _a3_double _80;
    // Computing bound for a
    _a2_int64_t _81;
    // Computing bound for a
    int64_t _82 = 480;
    int64_t _83 = -_82;
    _81.d0 = _83;
    if (_83 > 0) 
    goto _jump36;
    fail_assertion("non-positive loop bound");
    _jump36:;
    // Computing bound for b
    int64_t _84;
    // Computing bound for a
    int64_t _85 = 943;
    if (_85 > 0) 
    goto _jump37;
    fail_assertion("non-positive loop bound");
    _jump37:;
    _84 = 0;
    int64_t _86 = 0; // a
    _jump38:; // Begin body of loop
    int64_t _87 = -_86;
    _84 += _87;
    _86++;
    if (_86 < _85)
    goto _jump38;
    // End body of loop
    _81.d1 = _84;
    if (_84 > 0) 
    goto _jump39;
    fail_assertion("non-positive loop bound");
    _jump39:;
    // Computing total size of heap memory to allocate
    int64_t _88 = 1;
    _88 *= _83;
    _88 *= _84;
    _88 *= sizeof(int64_t);
    _81.data = jpl_alloc(_88);
    int64_t _89 = 0; // b
    int64_t _90 = 0; // a
    _jump40:; // Begin body of loop
    int64_t _91 = 735;
    int64_t _92 = 0;
    _92 *= _81.d0;
    _92 += _90;
    _92 *= _81.d1;
    _92 += _89;
    _81.data[_92] = _91;
    _89++;
    if (_89 < _84)
    goto _jump40;
    _89 = 0;
    _90++;
    if (_90 < _83)
    goto _jump40;
    // End body of loop
    int64_t _93 = 691;
    int64_t _94 = 237;
    int64_t _95 = -_94;
    _a1_int64_t _96;
    _96.d0 = 2;
    _96.data = jpl_alloc(sizeof(int64_t) * 2);
    _96.data[0] = _93;
    _96.data[1] = _95;
    int64_t _97 = 481;
    if (_97 >= 0)
    goto _jump41;
    fail_assertion("negative array index");
    _jump41:;
    if (_97 < _96.d0)
    goto _jump42;
    fail_assertion("index too large");
    _jump42:;
    int64_t _98 = 0;
    _98 *= _96.d0;
    _98 += _97;
    int64_t _99 = _96.data[_98];
    int64_t _100 = 343;
    int64_t _101 = -_100;
    int64_t _102 = 343;
    int64_t _103 = 859;
    int64_t _104 = _102 - _103;
    bool _105 = _101 >= _104;
    int64_t _106;
    if (!_105)
    goto _jump43;
    int64_t _107 = 663;
    int64_t _108 = -_107;
    _106 = _108;
    goto _jump44;
    _jump43:;
    int64_t _109;
    // Computing bound for a
    int64_t _110 = 865;
    if (_110 > 0) 
    goto _jump45;
    fail_assertion("non-positive loop bound");
    _jump45:;
    _109 = 0;
    int64_t _111 = 0; // a
    _jump46:; // Begin body of loop
    int64_t _112 = 642;
    _109 += _112;
    _111++;
    if (_111 < _110)
    goto _jump46;
    // End body of loop
    _106 = _109;
    _jump44:;
    if (_99 >= 0)
    goto _jump47;
    fail_assertion("negative array index");
    _jump47:;
    if (_99 < _81.d0)
    goto _jump48;
    fail_assertion("index too large");
    _jump48:;
    if (_106 >= 0)
    goto _jump49;
    fail_assertion("negative array index");
    _jump49:;
    if (_106 < _81.d1)
    goto _jump50;
    fail_assertion("index too large");
    _jump50:;
    int64_t _113 = 0;
    _113 *= _81.d0;
    _113 += _99;
    _113 *= _81.d1;
    _113 += _106;
    int64_t _114 = _81.data[_113];
    int64_t _115 = 711;
    int64_t _116 = _114 / _115;
    _80.d0 = _116;
    if (_116 > 0) 
    goto _jump51;
    fail_assertion("non-positive loop bound");
    _jump51:;
    // Computing bound for b
    bool _117 = true;
    int64_t _118;
    if (!_117)
    goto _jump52;
    int64_t _119 = 644;
    int64_t _120 = 974;
    bool _121 = _119 == _120;
    int64_t _122;
    if (!_121)
    goto _jump53;
    int64_t _123;
    // Computing bound for a
    int64_t _124 = 391;
    if (_124 > 0) 
    goto _jump54;
    fail_assertion("non-positive loop bound");
    _jump54:;
    // Computing bound for b
    int64_t _125 = 50;
    if (_125 > 0) 
    goto _jump55;
    fail_assertion("non-positive loop bound");
    _jump55:;
    _123 = 0;
    int64_t _126 = 0; // b
    int64_t _127 = 0; // a
    _jump56:; // Begin body of loop
    _123 += _127;
    _126++;
    if (_126 < _125)
    goto _jump56;
    _126 = 0;
    _127++;
    if (_127 < _124)
    goto _jump56;
    // End body of loop
    _122 = _123;
    goto _jump57;
    _jump53:;
    int64_t _128 = 337;
    _122 = _128;
    _jump57:;
    _118 = _122;
    goto _jump58;
    _jump52:;
    int64_t _129;
    // Computing bound for a
    int64_t _130 = 417;
    if (_130 > 0) 
    goto _jump59;
    fail_assertion("non-positive loop bound");
    _jump59:;
    _129 = 0;
    int64_t _131 = 0; // a
    _jump60:; // Begin body of loop
    int64_t _132;
    // Computing bound for b
    int64_t _133 = 396;
    if (_133 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing bound for c
    int64_t _134 = 772;
    if (_134 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    _132 = 0;
    int64_t _135 = 0; // c
    int64_t _136 = 0; // b
    _jump63:; // Begin body of loop
    _132 += _136;
    _135++;
    if (_135 < _134)
    goto _jump63;
    _135 = 0;
    _136++;
    if (_136 < _133)
    goto _jump63;
    // End body of loop
    _129 += _132;
    _131++;
    if (_131 < _130)
    goto _jump60;
    // End body of loop
    _118 = _129;
    _jump58:;
    int64_t _137 = 307;
    int64_t _138 = -_137;
    _a1_int64_t _139;
    _139.d0 = 1;
    _139.data = jpl_alloc(sizeof(int64_t) * 1);
    _139.data[0] = _138;
    int64_t _140;
    // Computing bound for a
    int64_t _141 = 591;
    int64_t _142 = 208;
    int64_t _143 = _141 - _142;
    if (_143 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing bound for b
    int64_t _144 = 978;
    if (_144 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    _140 = 0;
    int64_t _145 = 0; // b
    int64_t _146 = 0; // a
    _jump66:; // Begin body of loop
    _140 += _145;
    _145++;
    if (_145 < _144)
    goto _jump66;
    _145 = 0;
    _146++;
    if (_146 < _143)
    goto _jump66;
    // End body of loop
    if (_140 >= 0)
    goto _jump67;
    fail_assertion("negative array index");
    _jump67:;
    if (_140 < _139.d0)
    goto _jump68;
    fail_assertion("index too large");
    _jump68:;
    int64_t _147 = 0;
    _147 *= _139.d0;
    _147 += _140;
    int64_t _148 = _139.data[_147];
    int64_t _149 = _118 / _148;
    int64_t _150;
    // Computing bound for a
    int64_t _151 = 441;
    if (_151 > 0) 
    goto _jump69;
    fail_assertion("non-positive loop bound");
    _jump69:;
    _150 = 0;
    int64_t _152 = 0; // a
    _jump70:; // Begin body of loop
    int64_t _153 = 46;
    int64_t _154 = -_153;
    _150 += _154;
    _152++;
    if (_152 < _151)
    goto _jump70;
    // End body of loop
    int64_t _155;
    // Computing bound for a
    int64_t _156 = 69;
    int64_t _157 = 747;
    int64_t _158 = _156 * _157;
    if (_158 > 0) 
    goto _jump71;
    fail_assertion("non-positive loop bound");
    _jump71:;
    _155 = 0;
    int64_t _159 = 0; // a
    _jump72:; // Begin body of loop
    int64_t _160 = 566;
    _155 += _160;
    _159++;
    if (_159 < _158)
    goto _jump72;
    // End body of loop
    bool _161 = _150 == _155;
    int64_t _162;
    if (!_161)
    goto _jump73;
    int64_t _163 = 953;
    _162 = _163;
    goto _jump74;
    _jump73:;
    int64_t _164 = 501;
    int64_t _165 = -_164;
    _162 = _165;
    _jump74:;
    int64_t _166 = _149 + _162;
    _80.d1 = _166;
    if (_166 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for c
    int64_t _167;
    // Computing bound for a
    int64_t _168 = 450;
    if (_168 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    _167 = 0;
    int64_t _169 = 0; // a
    _jump77:; // Begin body of loop
    int64_t _170;
    // Computing bound for b
    int64_t _171;
    // Computing bound for b
    if (_169 > 0) 
    goto _jump78;
    fail_assertion("non-positive loop bound");
    _jump78:;
    // Computing bound for c
    if (_169 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    _171 = 0;
    int64_t _172 = 0; // c
    int64_t _173 = 0; // b
    _jump80:; // Begin body of loop
    int64_t _174 = _172 - _172;
    _171 += _174;
    _172++;
    if (_172 < _169)
    goto _jump80;
    _172 = 0;
    _173++;
    if (_173 < _169)
    goto _jump80;
    // End body of loop
    int64_t _175 = -_171;
    if (_175 > 0) 
    goto _jump81;
    fail_assertion("non-positive loop bound");
    _jump81:;
    // Computing bound for c
    int64_t _176 = 443;
    if (_176 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing bound for d
    int64_t _177 = 921;
    if (_177 > 0) 
    goto _jump83;
    fail_assertion("non-positive loop bound");
    _jump83:;
    _170 = 0;
    int64_t _178 = 0; // d
    int64_t _179 = 0; // c
    int64_t _180 = 0; // b
    _jump84:; // Begin body of loop
    _170 += _180;
    _178++;
    if (_178 < _177)
    goto _jump84;
    _178 = 0;
    _179++;
    if (_179 < _176)
    goto _jump84;
    _179 = 0;
    _180++;
    if (_180 < _175)
    goto _jump84;
    // End body of loop
    _167 += _170;
    _169++;
    if (_169 < _168)
    goto _jump77;
    // End body of loop
    _80.d2 = _167;
    if (_167 > 0) 
    goto _jump85;
    fail_assertion("non-positive loop bound");
    _jump85:;
    // Computing total size of heap memory to allocate
    int64_t _181 = 1;
    _181 *= _116;
    _181 *= _166;
    _181 *= _167;
    _181 *= sizeof(double);
    _80.data = jpl_alloc(_181);
    int64_t _182 = 0; // c
    int64_t _183 = 0; // b
    int64_t _184 = 0; // a
    _jump86:; // Begin body of loop
    double _185 = 83.0;
    double _186 = 0.0;
    double _187 = 39.0;
    double _188 = 74.0;
    rgba _189 = { _185, _186, _187, _188 };
    double _190 = _189.b;
    double _191;
    // Computing bound for d
    int64_t _192 = _184 / _182;
    if (_192 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    // Computing bound for e
    if (_183 > 0) 
    goto _jump88;
    fail_assertion("non-positive loop bound");
    _jump88:;
    _191 = 0;
    int64_t _193 = 0; // e
    int64_t _194 = 0; // d
    _jump89:; // Begin body of loop
    _a3_double _195;
    // Computing bound for f
    _195.d0 = _194;
    if (_194 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing bound for g
    _195.d1 = _194;
    if (_194 > 0) 
    goto _jump91;
    fail_assertion("non-positive loop bound");
    _jump91:;
    // Computing bound for h
    _195.d2 = _183;
    if (_183 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    // Computing total size of heap memory to allocate
    int64_t _196 = 1;
    _196 *= _194;
    _196 *= _194;
    _196 *= _183;
    _196 *= sizeof(double);
    _195.data = jpl_alloc(_196);
    int64_t _197 = 0; // h
    int64_t _198 = 0; // g
    int64_t _199 = 0; // f
    _jump93:; // Begin body of loop
    double _200 = 24.0;
    int64_t _201 = 0;
    _201 *= _195.d0;
    _201 += _199;
    _201 *= _195.d1;
    _201 += _198;
    _201 *= _195.d2;
    _201 += _197;
    _195.data[_201] = _200;
    _197++;
    if (_197 < _183)
    goto _jump93;
    _197 = 0;
    _198++;
    if (_198 < _194)
    goto _jump93;
    _198 = 0;
    _199++;
    if (_199 < _194)
    goto _jump93;
    // End body of loop
    int64_t _202 = -_183;
    if (_202 >= 0)
    goto _jump94;
    fail_assertion("negative array index");
    _jump94:;
    if (_202 < _195.d0)
    goto _jump95;
    fail_assertion("index too large");
    _jump95:;
    if (_183 >= 0)
    goto _jump96;
    fail_assertion("negative array index");
    _jump96:;
    if (_183 < _195.d1)
    goto _jump97;
    fail_assertion("index too large");
    _jump97:;
    if (_184 >= 0)
    goto _jump98;
    fail_assertion("negative array index");
    _jump98:;
    if (_184 < _195.d2)
    goto _jump99;
    fail_assertion("index too large");
    _jump99:;
    int64_t _203 = 0;
    _203 *= _195.d0;
    _203 += _202;
    _203 *= _195.d1;
    _203 += _183;
    _203 *= _195.d2;
    _203 += _184;
    double _204 = _195.data[_203];
    _191 += _204;
    _193++;
    if (_193 < _183)
    goto _jump89;
    _193 = 0;
    _194++;
    if (_194 < _192)
    goto _jump89;
    // End body of loop
    double _205;
    // Computing bound for d
    double _206 = 11.0;
    double _207 = 25.0;
    bool _208 = _206 > _207;
    int64_t _209;
    if (!_208)
    goto _jump100;
    int64_t _210 = 855;
    int64_t _211 = -_210;
    _209 = _211;
    goto _jump101;
    _jump100:;
    _209 = _182;
    _jump101:;
    if (_209 > 0) 
    goto _jump102;
    fail_assertion("non-positive loop bound");
    _jump102:;
    // Computing bound for e
    int64_t _212 = 532;
    int64_t _213 = _212 / _183;
    if (_213 > 0) 
    goto _jump103;
    fail_assertion("non-positive loop bound");
    _jump103:;
    _205 = 0;
    int64_t _214 = 0; // e
    int64_t _215 = 0; // d
    _jump104:; // Begin body of loop
    double _216 = 42.0;
    bool _217 = false;
    double _218;
    if (!_217)
    goto _jump105;
    double _219 = 27.0;
    _218 = _219;
    goto _jump106;
    _jump105:;
    double _220 = 85.0;
    _218 = _220;
    _jump106:;
    double _221 = fmod(_216, _218);
    _205 += _221;
    _214++;
    if (_214 < _213)
    goto _jump104;
    _214 = 0;
    _215++;
    if (_215 < _209)
    goto _jump104;
    // End body of loop
    double _222 = 24.0;
    rgba _223 = { _190, _191, _205, _222 };
    double _224 = _223.a;
    int64_t _225 = 0;
    _225 *= _80.d0;
    _225 += _184;
    _225 *= _80.d1;
    _225 += _183;
    _225 *= _80.d2;
    _225 += _182;
    _80.data[_225] = _224;
    _182++;
    if (_182 < _167)
    goto _jump86;
    _182 = 0;
    _183++;
    if (_183 < _166)
    goto _jump86;
    _183 = 0;
    _184++;
    if (_184 < _116)
    goto _jump86;
    // End body of loop
    _79 = _80;
    goto _jump107;
    _jump35:;
    _a3_bool _226;
    // Computing bound for a
    bool _227 = true;
    int64_t _228;
    if (!_227)
    goto _jump108;
    int64_t _229 = 218;
    _228 = _229;
    goto _jump109;
    _jump108:;
    int64_t _230 = 152;
    _228 = _230;
    _jump109:;
    _226.d0 = _228;
    if (_228 > 0) 
    goto _jump110;
    fail_assertion("non-positive loop bound");
    _jump110:;
    // Computing bound for b
    int64_t _231 = 763;
    int64_t _232 = 539;
    int64_t _233 = -_232;
    int64_t _234 = _231 % _233;
    _226.d1 = _234;
    if (_234 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing bound for c
    int64_t _235 = 272;
    int64_t _236 = 207;
    int64_t _237 = 613;
    int64_t _238 = _236 + _237;
    int64_t _239 = _235 - _238;
    _226.d2 = _239;
    if (_239 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    // Computing total size of heap memory to allocate
    int64_t _240 = 1;
    _240 *= _228;
    _240 *= _234;
    _240 *= _239;
    _240 *= sizeof(bool);
    _226.data = jpl_alloc(_240);
    int64_t _241 = 0; // c
    int64_t _242 = 0; // b
    int64_t _243 = 0; // a
    _jump113:; // Begin body of loop
    bool _245 = true;
    bool _244 = _245;
    if (0 != _245)
    goto _jump114;
    bool _246 = false;
    _244 = _246;
    _jump114:;
    int64_t _247 = 0;
    _247 *= _226.d0;
    _247 += _243;
    _247 *= _226.d1;
    _247 += _242;
    _247 *= _226.d2;
    _247 += _241;
    _226.data[_247] = _244;
    _241++;
    if (_241 < _239)
    goto _jump113;
    _241 = 0;
    _242++;
    if (_242 < _234)
    goto _jump113;
    _242 = 0;
    _243++;
    if (_243 < _228)
    goto _jump113;
    // End body of loop
    int64_t _248 = 856;
    int64_t _249 = 839;
    int64_t _250 = 701;
    int64_t _251 = -_250;
    if (_248 >= 0)
    goto _jump115;
    fail_assertion("negative array index");
    _jump115:;
    if (_248 < _226.d0)
    goto _jump116;
    fail_assertion("index too large");
    _jump116:;
    if (_249 >= 0)
    goto _jump117;
    fail_assertion("negative array index");
    _jump117:;
    if (_249 < _226.d1)
    goto _jump118;
    fail_assertion("index too large");
    _jump118:;
    if (_251 >= 0)
    goto _jump119;
    fail_assertion("negative array index");
    _jump119:;
    if (_251 < _226.d2)
    goto _jump120;
    fail_assertion("index too large");
    _jump120:;
    int64_t _252 = 0;
    _252 *= _226.d0;
    _252 += _248;
    _252 *= _226.d1;
    _252 += _249;
    _252 *= _226.d2;
    _252 += _251;
    bool _253 = _226.data[_252];
    bool _254 = !_253;
    _a3_double _255;
    if (!_254)
    goto _jump121;
    bool _257 = true;
    bool _256 = _257;
    if (0 == _257)
    goto _jump122;
    bool _259 = true;
    double _260;
    if (!_259)
    goto _jump123;
    double _261 = 82.0;
    _260 = _261;
    goto _jump124;
    _jump123:;
    double _262 = 71.0;
    _260 = _262;
    _jump124:;
    double _263 = 24.0;
    bool _264 = _260 >= _263;
    bool _258 = _264;
    if (0 != _264)
    goto _jump125;
    bool _265 = true;
    double _266 = 96.0;
    double _267 = 97.0;
    bool _268 = _266 < _267;
    bool _269 = _265 == _268;
    _258 = _269;
    _jump125:;
    _256 = _258;
    _jump122:;
    _a3_double _270;
    if (!_256)
    goto _jump126;
    _a3_double _271;
    // Computing bound for a
    int64_t _272 = 93;
    int64_t _273 = -_272;
    int64_t _274 = -_273;
    int64_t _275 = -_274;
    _271.d0 = _275;
    if (_275 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing bound for b
    int64_t _276 = 908;
    bool _277 = false;
    int64_t _278;
    if (!_277)
    goto _jump128;
    int64_t _279 = 15;
    _278 = _279;
    goto _jump129;
    _jump128:;
    int64_t _280 = 792;
    _278 = _280;
    _jump129:;
    int64_t _281 = _276 / _278;
    int64_t _282 = -_281;
    _271.d1 = _282;
    if (_282 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    // Computing bound for c
    int64_t _283 = 453;
    _271.d2 = _283;
    if (_283 > 0) 
    goto _jump131;
    fail_assertion("non-positive loop bound");
    _jump131:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _275;
    _284 *= _282;
    _284 *= _283;
    _284 *= sizeof(double);
    _271.data = jpl_alloc(_284);
    int64_t _285 = 0; // c
    int64_t _286 = 0; // b
    int64_t _287 = 0; // a
    _jump132:; // Begin body of loop
    double _288 = 47.0;
    int64_t _289 = 0;
    _289 *= _271.d0;
    _289 += _287;
    _289 *= _271.d1;
    _289 += _286;
    _289 *= _271.d2;
    _289 += _285;
    _271.data[_289] = _288;
    _285++;
    if (_285 < _283)
    goto _jump132;
    _285 = 0;
    _286++;
    if (_286 < _282)
    goto _jump132;
    _286 = 0;
    _287++;
    if (_287 < _275)
    goto _jump132;
    // End body of loop
    _270 = _271;
    goto _jump133;
    _jump126:;
    bool _290 = true;
    _a3_double _291;
    if (!_290)
    goto _jump134;
    _a3_double _292;
    // Computing bound for a
    int64_t _293 = 759;
    bool _294 = false;
    int64_t _295;
    if (!_294)
    goto _jump135;
    int64_t _296 = 759;
    _295 = _296;
    goto _jump136;
    _jump135:;
    int64_t _297 = 165;
    _295 = _297;
    _jump136:;
    int64_t _298 = _293 % _295;
    _292.d0 = _298;
    if (_298 > 0) 
    goto _jump137;
    fail_assertion("non-positive loop bound");
    _jump137:;
    // Computing bound for b
    int64_t _299 = 666;
    int64_t _300 = -_299;
    _292.d1 = _300;
    if (_300 > 0) 
    goto _jump138;
    fail_assertion("non-positive loop bound");
    _jump138:;
    // Computing bound for c
    int64_t _301 = 332;
    _a1_int64_t _302;
    _302.d0 = 1;
    _302.data = jpl_alloc(sizeof(int64_t) * 1);
    _302.data[0] = _301;
    int64_t _303 = 806;
    if (_303 >= 0)
    goto _jump139;
    fail_assertion("negative array index");
    _jump139:;
    if (_303 < _302.d0)
    goto _jump140;
    fail_assertion("index too large");
    _jump140:;
    int64_t _304 = 0;
    _304 *= _302.d0;
    _304 += _303;
    int64_t _305 = _302.data[_304];
    _292.d2 = _305;
    if (_305 > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    // Computing total size of heap memory to allocate
    int64_t _306 = 1;
    _306 *= _298;
    _306 *= _300;
    _306 *= _305;
    _306 *= sizeof(double);
    _292.data = jpl_alloc(_306);
    int64_t _307 = 0; // c
    int64_t _308 = 0; // b
    int64_t _309 = 0; // a
    _jump142:; // Begin body of loop
    double _310;
    // Computing bound for d
    int64_t _311 = -_308;
    if (_311 > 0) 
    goto _jump143;
    fail_assertion("non-positive loop bound");
    _jump143:;
    _310 = 0;
    int64_t _312 = 0; // d
    _jump144:; // Begin body of loop
    double _313 = 9.0;
    double _314 = -_313;
    _310 += _314;
    _312++;
    if (_312 < _311)
    goto _jump144;
    // End body of loop
    int64_t _315 = 0;
    _315 *= _292.d0;
    _315 += _309;
    _315 *= _292.d1;
    _315 += _308;
    _315 *= _292.d2;
    _315 += _307;
    _292.data[_315] = _310;
    _307++;
    if (_307 < _305)
    goto _jump142;
    _307 = 0;
    _308++;
    if (_308 < _300)
    goto _jump142;
    _308 = 0;
    _309++;
    if (_309 < _298)
    goto _jump142;
    // End body of loop
    _291 = _292;
    goto _jump145;
    _jump134:;
    _a3_double _316;
    // Computing bound for a
    bool _317 = false;
    bool _318 = !_317;
    int64_t _319;
    if (!_318)
    goto _jump146;
    int64_t _320 = 715;
    _319 = _320;
    goto _jump147;
    _jump146:;
    int64_t _321 = 899;
    _319 = _321;
    _jump147:;
    _316.d0 = _319;
    if (_319 > 0) 
    goto _jump148;
    fail_assertion("non-positive loop bound");
    _jump148:;
    // Computing bound for b
    int64_t _322 = 952;
    int64_t _323 = -_322;
    _316.d1 = _323;
    if (_323 > 0) 
    goto _jump149;
    fail_assertion("non-positive loop bound");
    _jump149:;
    // Computing bound for c
    int64_t _324 = 239;
    _316.d2 = _324;
    if (_324 > 0) 
    goto _jump150;
    fail_assertion("non-positive loop bound");
    _jump150:;
    // Computing total size of heap memory to allocate
    int64_t _325 = 1;
    _325 *= _319;
    _325 *= _323;
    _325 *= _324;
    _325 *= sizeof(double);
    _316.data = jpl_alloc(_325);
    int64_t _326 = 0; // c
    int64_t _327 = 0; // b
    int64_t _328 = 0; // a
    _jump151:; // Begin body of loop
    double _329 = 1.0;
    int64_t _330 = 0;
    _330 *= _316.d0;
    _330 += _328;
    _330 *= _316.d1;
    _330 += _327;
    _330 *= _316.d2;
    _330 += _326;
    _316.data[_330] = _329;
    _326++;
    if (_326 < _324)
    goto _jump151;
    _326 = 0;
    _327++;
    if (_327 < _323)
    goto _jump151;
    _327 = 0;
    _328++;
    if (_328 < _319)
    goto _jump151;
    // End body of loop
    _291 = _316;
    _jump145:;
    _270 = _291;
    _jump133:;
    _255 = _270;
    goto _jump152;
    _jump121:;
    _a2__a3_double _331;
    // Computing bound for a
    int64_t _332 = 487;
    int64_t _333;
    // Computing bound for a
    int64_t _334 = 89;
    int64_t _335 = 353;
    int64_t _336 = _334 * _335;
    if (_336 > 0) 
    goto _jump153;
    fail_assertion("non-positive loop bound");
    _jump153:;
    _333 = 0;
    int64_t _337 = 0; // a
    _jump154:; // Begin body of loop
    int64_t _338 = 846;
    int64_t _339 = -_338;
    _333 += _339;
    _337++;
    if (_337 < _336)
    goto _jump154;
    // End body of loop
    int64_t _340 = _332 - _333;
    _331.d0 = _340;
    if (_340 > 0) 
    goto _jump155;
    fail_assertion("non-positive loop bound");
    _jump155:;
    // Computing bound for b
    int64_t _341;
    // Computing bound for a
    int64_t _342 = 683;
    int64_t _343 = -_342;
    if (_343 > 0) 
    goto _jump156;
    fail_assertion("non-positive loop bound");
    _jump156:;
    // Computing bound for b
    int64_t _344 = 753;
    if (_344 > 0) 
    goto _jump157;
    fail_assertion("non-positive loop bound");
    _jump157:;
    _341 = 0;
    int64_t _345 = 0; // b
    int64_t _346 = 0; // a
    _jump158:; // Begin body of loop
    int64_t _347 = 143;
    _341 += _347;
    _345++;
    if (_345 < _344)
    goto _jump158;
    _345 = 0;
    _346++;
    if (_346 < _343)
    goto _jump158;
    // End body of loop
    _331.d1 = _341;
    if (_341 > 0) 
    goto _jump159;
    fail_assertion("non-positive loop bound");
    _jump159:;
    // Computing total size of heap memory to allocate
    int64_t _348 = 1;
    _348 *= _340;
    _348 *= _341;
    _348 *= sizeof(_a3_double);
    _331.data = jpl_alloc(_348);
    int64_t _349 = 0; // b
    int64_t _350 = 0; // a
    _jump160:; // Begin body of loop
    _a3_double _351;
    // Computing bound for c
    int64_t _352;
    // Computing bound for c
    int64_t _353;
    // Computing bound for c
    if (_349 > 0) 
    goto _jump161;
    fail_assertion("non-positive loop bound");
    _jump161:;
    // Computing bound for d
    int64_t _354 = 645;
    if (_354 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _353 = 0;
    int64_t _355 = 0; // d
    int64_t _356 = 0; // c
    _jump163:; // Begin body of loop
    _353 += _349;
    _355++;
    if (_355 < _354)
    goto _jump163;
    _355 = 0;
    _356++;
    if (_356 < _349)
    goto _jump163;
    // End body of loop
    if (_353 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing bound for d
    if (_350 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    _352 = 0;
    int64_t _357 = 0; // d
    int64_t _358 = 0; // c
    _jump166:; // Begin body of loop
    _352 += _357;
    _357++;
    if (_357 < _350)
    goto _jump166;
    _357 = 0;
    _358++;
    if (_358 < _353)
    goto _jump166;
    // End body of loop
    _351.d0 = _352;
    if (_352 > 0) 
    goto _jump167;
    fail_assertion("non-positive loop bound");
    _jump167:;
    // Computing bound for d
    int64_t _359 = 507;
    _351.d1 = _359;
    if (_359 > 0) 
    goto _jump168;
    fail_assertion("non-positive loop bound");
    _jump168:;
    // Computing bound for e
    int64_t _360 = 88;
    _351.d2 = _360;
    if (_360 > 0) 
    goto _jump169;
    fail_assertion("non-positive loop bound");
    _jump169:;
    // Computing total size of heap memory to allocate
    int64_t _361 = 1;
    _361 *= _352;
    _361 *= _359;
    _361 *= _360;
    _361 *= sizeof(double);
    _351.data = jpl_alloc(_361);
    int64_t _362 = 0; // e
    int64_t _363 = 0; // d
    int64_t _364 = 0; // c
    _jump170:; // Begin body of loop
    _a1_double _365;
    // Computing bound for f
    _365.d0 = _350;
    if (_350 > 0) 
    goto _jump171;
    fail_assertion("non-positive loop bound");
    _jump171:;
    // Computing total size of heap memory to allocate
    int64_t _366 = 1;
    _366 *= _350;
    _366 *= sizeof(double);
    _365.data = jpl_alloc(_366);
    int64_t _367 = 0; // f
    _jump172:; // Begin body of loop
    double _368 = 13.0;
    int64_t _369 = 0;
    _369 *= _365.d0;
    _369 += _367;
    _365.data[_369] = _368;
    _367++;
    if (_367 < _350)
    goto _jump172;
    // End body of loop
    if (_363 >= 0)
    goto _jump173;
    fail_assertion("negative array index");
    _jump173:;
    if (_363 < _365.d0)
    goto _jump174;
    fail_assertion("index too large");
    _jump174:;
    int64_t _370 = 0;
    _370 *= _365.d0;
    _370 += _363;
    double _371 = _365.data[_370];
    int64_t _372 = 0;
    _372 *= _351.d0;
    _372 += _364;
    _372 *= _351.d1;
    _372 += _363;
    _372 *= _351.d2;
    _372 += _362;
    _351.data[_372] = _371;
    _362++;
    if (_362 < _360)
    goto _jump170;
    _362 = 0;
    _363++;
    if (_363 < _359)
    goto _jump170;
    _363 = 0;
    _364++;
    if (_364 < _352)
    goto _jump170;
    // End body of loop
    int64_t _373 = 0;
    _373 *= _331.d0;
    _373 += _350;
    _373 *= _331.d1;
    _373 += _349;
    _331.data[_373] = _351;
    _349++;
    if (_349 < _341)
    goto _jump160;
    _349 = 0;
    _350++;
    if (_350 < _340)
    goto _jump160;
    // End body of loop
    int64_t _374;
    // Computing bound for a
    int64_t _375 = 868;
    if (_375 > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing bound for b
    int64_t _376 = 81;
    int64_t _377 = 115;
    int64_t _378 = 501;
    int64_t _379 = _377 + _378;
    bool _380 = _376 == _379;
    int64_t _381;
    if (!_380)
    goto _jump176;
    int64_t _382 = 322;
    _381 = _382;
    goto _jump177;
    _jump176:;
    int64_t _383;
    // Computing bound for a
    int64_t _384 = 375;
    int64_t _385 = 486;
    int64_t _386 = _384 + _385;
    if (_386 > 0) 
    goto _jump178;
    fail_assertion("non-positive loop bound");
    _jump178:;
    // Computing bound for b
    int64_t _387 = 806;
    if (_387 > 0) 
    goto _jump179;
    fail_assertion("non-positive loop bound");
    _jump179:;
    _383 = 0;
    int64_t _388 = 0; // b
    int64_t _389 = 0; // a
    _jump180:; // Begin body of loop
    _383 += _388;
    _388++;
    if (_388 < _387)
    goto _jump180;
    _388 = 0;
    _389++;
    if (_389 < _386)
    goto _jump180;
    // End body of loop
    _381 = _383;
    _jump177:;
    if (_381 > 0) 
    goto _jump181;
    fail_assertion("non-positive loop bound");
    _jump181:;
    _374 = 0;
    int64_t _390 = 0; // b
    int64_t _391 = 0; // a
    _jump182:; // Begin body of loop
    bool _392 = true;
    int64_t _393;
    if (!_392)
    goto _jump183;
    _a2_int64_t _394;
    // Computing bound for c
    _394.d0 = _390;
    if (_390 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing bound for d
    _394.d1 = _391;
    if (_391 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing total size of heap memory to allocate
    int64_t _395 = 1;
    _395 *= _390;
    _395 *= _391;
    _395 *= sizeof(int64_t);
    _394.data = jpl_alloc(_395);
    int64_t _396 = 0; // d
    int64_t _397 = 0; // c
    _jump186:; // Begin body of loop
    int64_t _398 = 0;
    _398 *= _394.d0;
    _398 += _397;
    _398 *= _394.d1;
    _398 += _396;
    _394.data[_398] = _390;
    _396++;
    if (_396 < _391)
    goto _jump186;
    _396 = 0;
    _397++;
    if (_397 < _390)
    goto _jump186;
    // End body of loop
    int64_t _399;
    // Computing bound for c
    if (_391 > 0) 
    goto _jump187;
    fail_assertion("non-positive loop bound");
    _jump187:;
    _399 = 0;
    int64_t _400 = 0; // c
    _jump188:; // Begin body of loop
    _399 += _391;
    _400++;
    if (_400 < _391)
    goto _jump188;
    // End body of loop
    int64_t _401 = 97;
    if (_399 >= 0)
    goto _jump189;
    fail_assertion("negative array index");
    _jump189:;
    if (_399 < _394.d0)
    goto _jump190;
    fail_assertion("index too large");
    _jump190:;
    if (_401 >= 0)
    goto _jump191;
    fail_assertion("negative array index");
    _jump191:;
    if (_401 < _394.d1)
    goto _jump192;
    fail_assertion("index too large");
    _jump192:;
    int64_t _402 = 0;
    _402 *= _394.d0;
    _402 += _399;
    _402 *= _394.d1;
    _402 += _401;
    int64_t _403 = _394.data[_402];
    _393 = _403;
    goto _jump193;
    _jump183:;
    int64_t _404 = 311;
    int64_t _405 = _391 + _404;
    _393 = _405;
    _jump193:;
    _374 += _393;
    _390++;
    if (_390 < _381)
    goto _jump182;
    _390 = 0;
    _391++;
    if (_391 < _375)
    goto _jump182;
    // End body of loop
    int64_t _406 = 21;
    int64_t _407 = -_406;
    int64_t _408;
    // Computing bound for a
    int64_t _409 = 148;
    int64_t _410 = -_409;
    int64_t _411 = 936;
    int64_t _412 = -_411;
    int64_t _413 = _410 % _412;
    if (_413 > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for b
    int64_t _414;
    // Computing bound for a
    int64_t _415;
    // Computing bound for a
    int64_t _416 = 541;
    if (_416 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    _415 = 0;
    int64_t _417 = 0; // a
    _jump196:; // Begin body of loop
    int64_t _418 = 503;
    _415 += _418;
    _417++;
    if (_417 < _416)
    goto _jump196;
    // End body of loop
    if (_415 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing bound for b
    int64_t _419 = 450;
    if (_419 > 0) 
    goto _jump198;
    fail_assertion("non-positive loop bound");
    _jump198:;
    _414 = 0;
    int64_t _420 = 0; // b
    int64_t _421 = 0; // a
    _jump199:; // Begin body of loop
    _414 += _420;
    _420++;
    if (_420 < _419)
    goto _jump199;
    _420 = 0;
    _421++;
    if (_421 < _415)
    goto _jump199;
    // End body of loop
    if (_414 > 0) 
    goto _jump200;
    fail_assertion("non-positive loop bound");
    _jump200:;
    _408 = 0;
    int64_t _422 = 0; // b
    int64_t _423 = 0; // a
    _jump201:; // Begin body of loop
    int64_t _424 = _423 % _422;
    int64_t _425 = -_424;
    _408 += _425;
    _422++;
    if (_422 < _414)
    goto _jump201;
    _422 = 0;
    _423++;
    if (_423 < _413)
    goto _jump201;
    // End body of loop
    int64_t _426 = _407 + _408;
    if (_374 >= 0)
    goto _jump202;
    fail_assertion("negative array index");
    _jump202:;
    if (_374 < _331.d0)
    goto _jump203;
    fail_assertion("index too large");
    _jump203:;
    if (_426 >= 0)
    goto _jump204;
    fail_assertion("negative array index");
    _jump204:;
    if (_426 < _331.d1)
    goto _jump205;
    fail_assertion("index too large");
    _jump205:;
    int64_t _427 = 0;
    _427 *= _331.d0;
    _427 += _374;
    _427 *= _331.d1;
    _427 += _426;
    _a3_double _428 = _331.data[_427];
    _255 = _428;
    _jump152:;
    _79 = _255;
    _jump107:;
    bool _429 = _79.d2 == _79.d1;
    _a3_int64_t _430;
    if (!_429)
    goto _jump206;
    _a1__a3_int64_t _431;
    // Computing bound for e
    _431.d0 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump207;
    fail_assertion("non-positive loop bound");
    _jump207:;
    // Computing total size of heap memory to allocate
    int64_t _432 = 1;
    _432 *= _79.d0;
    _432 *= sizeof(_a3_int64_t);
    _431.data = jpl_alloc(_432);
    int64_t _433 = 0; // e
    _jump208:; // Begin body of loop
    bool _435 = true;
    bool _434 = _435;
    if (0 == _435)
    goto _jump209;
    bool _436 = false;
    _434 = _436;
    _jump209:;
    _a3_int64_t _437;
    if (!_434)
    goto _jump210;
    _a3_int64_t _438;
    // Computing bound for f
    _438.d0 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump211;
    fail_assertion("non-positive loop bound");
    _jump211:;
    // Computing bound for g
    int64_t _439 = 528;
    _438.d1 = _439;
    if (_439 > 0) 
    goto _jump212;
    fail_assertion("non-positive loop bound");
    _jump212:;
    // Computing bound for h
    _438.d2 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump213;
    fail_assertion("non-positive loop bound");
    _jump213:;
    // Computing total size of heap memory to allocate
    int64_t _440 = 1;
    _440 *= _79.d2;
    _440 *= _439;
    _440 *= _79.d0;
    _440 *= sizeof(int64_t);
    _438.data = jpl_alloc(_440);
    int64_t _441 = 0; // h
    int64_t _442 = 0; // g
    int64_t _443 = 0; // f
    _jump214:; // Begin body of loop
    int64_t _444 = 0;
    _444 *= _438.d0;
    _444 += _443;
    _444 *= _438.d1;
    _444 += _442;
    _444 *= _438.d2;
    _444 += _441;
    _438.data[_444] = _79.d1;
    _441++;
    if (_441 < _79.d0)
    goto _jump214;
    _441 = 0;
    _442++;
    if (_442 < _439)
    goto _jump214;
    _442 = 0;
    _443++;
    if (_443 < _79.d2)
    goto _jump214;
    // End body of loop
    _a1__a3_int64_t _445;
    _445.d0 = 1;
    _445.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _445.data[0] = _438;
    _a2_int64_t _446;
    // Computing bound for f
    _446.d0 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump215;
    fail_assertion("non-positive loop bound");
    _jump215:;
    // Computing bound for g
    _446.d1 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump216;
    fail_assertion("non-positive loop bound");
    _jump216:;
    // Computing total size of heap memory to allocate
    int64_t _447 = 1;
    _447 *= _79.d2;
    _447 *= _79.d2;
    _447 *= sizeof(int64_t);
    _446.data = jpl_alloc(_447);
    int64_t _448 = 0; // g
    int64_t _449 = 0; // f
    _jump217:; // Begin body of loop
    int64_t _450 = 0;
    _450 *= _446.d0;
    _450 += _449;
    _450 *= _446.d1;
    _450 += _448;
    _446.data[_450] = _79.d2;
    _448++;
    if (_448 < _79.d2)
    goto _jump217;
    _448 = 0;
    _449++;
    if (_449 < _79.d2)
    goto _jump217;
    // End body of loop
    if (_433 >= 0)
    goto _jump218;
    fail_assertion("negative array index");
    _jump218:;
    if (_433 < _446.d0)
    goto _jump219;
    fail_assertion("index too large");
    _jump219:;
    if (_79.d0 >= 0)
    goto _jump220;
    fail_assertion("negative array index");
    _jump220:;
    if (_79.d0 < _446.d1)
    goto _jump221;
    fail_assertion("index too large");
    _jump221:;
    int64_t _451 = 0;
    _451 *= _446.d0;
    _451 += _433;
    _451 *= _446.d1;
    _451 += _79.d0;
    int64_t _452 = _446.data[_451];
    if (_452 >= 0)
    goto _jump222;
    fail_assertion("negative array index");
    _jump222:;
    if (_452 < _445.d0)
    goto _jump223;
    fail_assertion("index too large");
    _jump223:;
    int64_t _453 = 0;
    _453 *= _445.d0;
    _453 += _452;
    _a3_int64_t _454 = _445.data[_453];
    _437 = _454;
    goto _jump224;
    _jump210:;
    _a3_int64_t _455;
    // Computing bound for f
    int64_t _456;
    // Computing bound for f
    int64_t _457 = 751;
    if (_457 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for g
    int64_t _458 = -_79.d1;
    if (_458 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for h
    if (_433 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    _456 = 0;
    int64_t _459 = 0; // h
    int64_t _460 = 0; // g
    int64_t _461 = 0; // f
    _jump228:; // Begin body of loop
    _456 += _433;
    _459++;
    if (_459 < _433)
    goto _jump228;
    _459 = 0;
    _460++;
    if (_460 < _458)
    goto _jump228;
    _460 = 0;
    _461++;
    if (_461 < _457)
    goto _jump228;
    // End body of loop
    _455.d0 = _456;
    if (_456 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for g
    _a3_int64_t _462;
    // Computing bound for f
    _462.d0 = _79.d1;
    if (_79.d1 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for g
    int64_t _463 = 414;
    _462.d1 = _463;
    if (_463 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    // Computing bound for h
    int64_t _464 = 419;
    _462.d2 = _464;
    if (_464 > 0) 
    goto _jump232;
    fail_assertion("non-positive loop bound");
    _jump232:;
    // Computing total size of heap memory to allocate
    int64_t _465 = 1;
    _465 *= _79.d1;
    _465 *= _463;
    _465 *= _464;
    _465 *= sizeof(int64_t);
    _462.data = jpl_alloc(_465);
    int64_t _466 = 0; // h
    int64_t _467 = 0; // g
    int64_t _468 = 0; // f
    _jump233:; // Begin body of loop
    int64_t _469 = 0;
    _469 *= _462.d0;
    _469 += _468;
    _469 *= _462.d1;
    _469 += _467;
    _469 *= _462.d2;
    _469 += _466;
    _462.data[_469] = _79.d1;
    _466++;
    if (_466 < _464)
    goto _jump233;
    _466 = 0;
    _467++;
    if (_467 < _463)
    goto _jump233;
    _467 = 0;
    _468++;
    if (_468 < _79.d1)
    goto _jump233;
    // End body of loop
    if (_79.d1 >= 0)
    goto _jump234;
    fail_assertion("negative array index");
    _jump234:;
    if (_79.d1 < _462.d0)
    goto _jump235;
    fail_assertion("index too large");
    _jump235:;
    if (_79.d0 >= 0)
    goto _jump236;
    fail_assertion("negative array index");
    _jump236:;
    if (_79.d0 < _462.d1)
    goto _jump237;
    fail_assertion("index too large");
    _jump237:;
    if (_79.d2 >= 0)
    goto _jump238;
    fail_assertion("negative array index");
    _jump238:;
    if (_79.d2 < _462.d2)
    goto _jump239;
    fail_assertion("index too large");
    _jump239:;
    int64_t _470 = 0;
    _470 *= _462.d0;
    _470 += _79.d1;
    _470 *= _462.d1;
    _470 += _79.d0;
    _470 *= _462.d2;
    _470 += _79.d2;
    int64_t _471 = _462.data[_470];
    _455.d1 = _471;
    if (_471 > 0) 
    goto _jump240;
    fail_assertion("non-positive loop bound");
    _jump240:;
    // Computing bound for h
    _455.d2 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump241;
    fail_assertion("non-positive loop bound");
    _jump241:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _456;
    _472 *= _471;
    _472 *= _79.d2;
    _472 *= sizeof(int64_t);
    _455.data = jpl_alloc(_472);
    int64_t _473 = 0; // h
    int64_t _474 = 0; // g
    int64_t _475 = 0; // f
    _jump242:; // Begin body of loop
    int64_t _476 = -_79.d2;
    int64_t _477 = 0;
    _477 *= _455.d0;
    _477 += _475;
    _477 *= _455.d1;
    _477 += _474;
    _477 *= _455.d2;
    _477 += _473;
    _455.data[_477] = _476;
    _473++;
    if (_473 < _79.d2)
    goto _jump242;
    _473 = 0;
    _474++;
    if (_474 < _471)
    goto _jump242;
    _474 = 0;
    _475++;
    if (_475 < _456)
    goto _jump242;
    // End body of loop
    _437 = _455;
    _jump224:;
    int64_t _478 = 0;
    _478 *= _431.d0;
    _478 += _433;
    _431.data[_478] = _437;
    _433++;
    if (_433 < _79.d0)
    goto _jump208;
    // End body of loop
    if (_79.d2 >= 0)
    goto _jump243;
    fail_assertion("negative array index");
    _jump243:;
    if (_79.d2 < _431.d0)
    goto _jump244;
    fail_assertion("index too large");
    _jump244:;
    int64_t _479 = 0;
    _479 *= _431.d0;
    _479 += _79.d2;
    _a3_int64_t _480 = _431.data[_479];
    _430 = _480;
    goto _jump245;
    _jump206:;
    _a2__a3_int64_t _481;
    // Computing bound for e
    bool _482 = false;
    int64_t _483;
    if (!_482)
    goto _jump246;
    int64_t _484 = -_79.d1;
    _483 = _484;
    goto _jump247;
    _jump246:;
    int64_t _485 = 49;
    _483 = _485;
    _jump247:;
    _481.d0 = _483;
    if (_483 > 0) 
    goto _jump248;
    fail_assertion("non-positive loop bound");
    _jump248:;
    // Computing bound for f
    int64_t _486 = -_79.d0;
    _481.d1 = _486;
    if (_486 > 0) 
    goto _jump249;
    fail_assertion("non-positive loop bound");
    _jump249:;
    // Computing total size of heap memory to allocate
    int64_t _487 = 1;
    _487 *= _483;
    _487 *= _486;
    _487 *= sizeof(_a3_int64_t);
    _481.data = jpl_alloc(_487);
    int64_t _488 = 0; // f
    int64_t _489 = 0; // e
    _jump250:; // Begin body of loop
    _a3_int64_t _490;
    // Computing bound for g
    int64_t _491 = -_79.d0;
    _490.d0 = _491;
    if (_491 > 0) 
    goto _jump251;
    fail_assertion("non-positive loop bound");
    _jump251:;
    // Computing bound for h
    _490.d1 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump252;
    fail_assertion("non-positive loop bound");
    _jump252:;
    // Computing bound for i
    int64_t _492 = -_79.d1;
    _490.d2 = _492;
    if (_492 > 0) 
    goto _jump253;
    fail_assertion("non-positive loop bound");
    _jump253:;
    // Computing total size of heap memory to allocate
    int64_t _493 = 1;
    _493 *= _491;
    _493 *= _79.d0;
    _493 *= _492;
    _493 *= sizeof(int64_t);
    _490.data = jpl_alloc(_493);
    int64_t _494 = 0; // i
    int64_t _495 = 0; // h
    int64_t _496 = 0; // g
    _jump254:; // Begin body of loop
    int64_t _497 = 0;
    _497 *= _490.d0;
    _497 += _496;
    _497 *= _490.d1;
    _497 += _495;
    _497 *= _490.d2;
    _497 += _494;
    _490.data[_497] = _489;
    _494++;
    if (_494 < _492)
    goto _jump254;
    _494 = 0;
    _495++;
    if (_495 < _79.d0)
    goto _jump254;
    _495 = 0;
    _496++;
    if (_496 < _491)
    goto _jump254;
    // End body of loop
    int64_t _498 = 0;
    _498 *= _481.d0;
    _498 += _489;
    _498 *= _481.d1;
    _498 += _488;
    _481.data[_498] = _490;
    _488++;
    if (_488 < _486)
    goto _jump250;
    _488 = 0;
    _489++;
    if (_489 < _483)
    goto _jump250;
    // End body of loop
    _a1__a2__a3_int64_t _499;
    _499.d0 = 1;
    _499.data = jpl_alloc(sizeof(_a2__a3_int64_t) * 1);
    _499.data[0] = _481;
    if (_79.d0 >= 0)
    goto _jump255;
    fail_assertion("negative array index");
    _jump255:;
    if (_79.d0 < _499.d0)
    goto _jump256;
    fail_assertion("index too large");
    _jump256:;
    int64_t _500 = 0;
    _500 *= _499.d0;
    _500 += _79.d0;
    _a2__a3_int64_t _501 = _499.data[_500];
    if (_79.d1 >= 0)
    goto _jump257;
    fail_assertion("negative array index");
    _jump257:;
    if (_79.d1 < _501.d0)
    goto _jump258;
    fail_assertion("index too large");
    _jump258:;
    if (_79.d0 >= 0)
    goto _jump259;
    fail_assertion("negative array index");
    _jump259:;
    if (_79.d0 < _501.d1)
    goto _jump260;
    fail_assertion("index too large");
    _jump260:;
    int64_t _502 = 0;
    _502 *= _501.d0;
    _502 += _79.d1;
    _502 *= _501.d1;
    _502 += _79.d0;
    _a3_int64_t _503 = _501.data[_502];
    _430 = _503;
    _jump245:;
    int64_t _504 = 588;
    int64_t _505 = _504 - _79.d0;
    bool _506 = _79.d1 <= _505;
    _a3_int64_t _507;
    // Computing bound for j
    int64_t _508 = 760;
    _507.d0 = _508;
    if (_508 > 0) 
    goto _jump261;
    fail_assertion("non-positive loop bound");
    _jump261:;
    // Computing bound for k
    int64_t _509 = -_79.d1;
    int64_t _510 = _430.d0 + _509;
    _507.d1 = _510;
    if (_510 > 0) 
    goto _jump262;
    fail_assertion("non-positive loop bound");
    _jump262:;
    // Computing bound for l
    _507.d2 = _79.d1;
    if (_79.d1 > 0) 
    goto _jump263;
    fail_assertion("non-positive loop bound");
    _jump263:;
    // Computing total size of heap memory to allocate
    int64_t _511 = 1;
    _511 *= _508;
    _511 *= _510;
    _511 *= _79.d1;
    _511 *= sizeof(int64_t);
    _507.data = jpl_alloc(_511);
    int64_t _512 = 0; // l
    int64_t _513 = 0; // k
    int64_t _514 = 0; // j
    _jump264:; // Begin body of loop
    int64_t _515 = 0;
    _515 *= _507.d0;
    _515 += _514;
    _515 *= _507.d1;
    _515 += _513;
    _515 *= _507.d2;
    _515 += _512;
    _507.data[_515] = _79.d2;
    _512++;
    if (_512 < _79.d1)
    goto _jump264;
    _512 = 0;
    _513++;
    if (_513 < _510)
    goto _jump264;
    _513 = 0;
    _514++;
    if (_514 < _508)
    goto _jump264;
    // End body of loop
    _a2_rgba _516;
    // Computing bound for n
    _516.d0 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing bound for o
    int64_t _517 = _507.d1 / _430.d1;
    _516.d1 = _517;
    if (_517 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    // Computing total size of heap memory to allocate
    int64_t _518 = 1;
    _518 *= _430.d0;
    _518 *= _517;
    _518 *= sizeof(rgba);
    _516.data = jpl_alloc(_518);
    int64_t _519 = 0; // o
    int64_t _520 = 0; // n
    _jump267:; // Begin body of loop
    double _521;
    // Computing bound for p
    int64_t _522;
    // Computing bound for p
    if (_507.d0 > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for q
    if (_507.d2 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    _522 = 0;
    int64_t _523 = 0; // q
    int64_t _524 = 0; // p
    _jump270:; // Begin body of loop
    _522 += _507.d2;
    _523++;
    if (_523 < _507.d2)
    goto _jump270;
    _523 = 0;
    _524++;
    if (_524 < _507.d0)
    goto _jump270;
    // End body of loop
    if (_522 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for q
    int64_t _525 = 764;
    if (_525 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing bound for r
    if (_79.d2 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    _521 = 0;
    int64_t _526 = 0; // r
    int64_t _527 = 0; // q
    int64_t _528 = 0; // p
    _jump274:; // Begin body of loop
    bool _529 = false;
    double _530;
    if (!_529)
    goto _jump275;
    double _531 = 22.0;
    _530 = _531;
    goto _jump276;
    _jump275:;
    double _532 = 34.0;
    _530 = _532;
    _jump276:;
    _521 += _530;
    _526++;
    if (_526 < _79.d2)
    goto _jump274;
    _526 = 0;
    _527++;
    if (_527 < _525)
    goto _jump274;
    _527 = 0;
    _528++;
    if (_528 < _522)
    goto _jump274;
    // End body of loop
    double _533 = -_521;
    double _534 = 17.0;
    double _535 = -_534;
    double _536;
    // Computing bound for p
    int64_t _537 = -_430.d0;
    if (_537 > 0) 
    goto _jump277;
    fail_assertion("non-positive loop bound");
    _jump277:;
    _536 = 0;
    int64_t _538 = 0; // p
    _jump278:; // Begin body of loop
    double _539 = 82.0;
    _536 += _539;
    _538++;
    if (_538 < _537)
    goto _jump278;
    // End body of loop
    double _540 = 31.0;
    rgba _541 = { _533, _535, _536, _540 };
    double _542 = _541.g;
    double _543;
    // Computing bound for p
    if (_79.d2 > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    _543 = 0;
    int64_t _544 = 0; // p
    _jump280:; // Begin body of loop
    bool _545 = _507.d2 < _544;
    bool _546;
    if (!_545)
    goto _jump281;
    bool _547 = _79.d1 != _507.d1;
    _546 = _547;
    goto _jump282;
    _jump281:;
    bool _548 = true;
    _546 = _548;
    _jump282:;
    double _549;
    if (!_546)
    goto _jump283;
    double _550;
    // Computing bound for q
    if (_507.d0 > 0) 
    goto _jump284;
    fail_assertion("non-positive loop bound");
    _jump284:;
    // Computing bound for r
    if (_79.d0 > 0) 
    goto _jump285;
    fail_assertion("non-positive loop bound");
    _jump285:;
    _550 = 0;
    int64_t _551 = 0; // r
    int64_t _552 = 0; // q
    _jump286:; // Begin body of loop
    double _553 = 31.0;
    _550 += _553;
    _551++;
    if (_551 < _79.d0)
    goto _jump286;
    _551 = 0;
    _552++;
    if (_552 < _507.d0)
    goto _jump286;
    // End body of loop
    _549 = _550;
    goto _jump287;
    _jump283:;
    double _554 = 52.0;
    double _555 = -_554;
    double _556 = -_555;
    _549 = _556;
    _jump287:;
    _543 += _549;
    _544++;
    if (_544 < _79.d2)
    goto _jump280;
    // End body of loop
    double _557 = -_543;
    bool _558 = !_506;
    double _559;
    if (!_558)
    goto _jump288;
    double _560;
    // Computing bound for p
    if (_520 > 0) 
    goto _jump289;
    fail_assertion("non-positive loop bound");
    _jump289:;
    _560 = 0;
    int64_t _561 = 0; // p
    _jump290:; // Begin body of loop
    double _562 = 96.0;
    _560 += _562;
    _561++;
    if (_561 < _520)
    goto _jump290;
    // End body of loop
    _559 = _560;
    goto _jump291;
    _jump288:;
    double _563 = 38.0;
    _559 = _563;
    _jump291:;
    double _564 = 76.0;
    double _565 = -_564;
    double _566 = -_565;
    double _567 = _559 - _566;
    double _568;
    // Computing bound for p
    if (_79.d1 > 0) 
    goto _jump292;
    fail_assertion("non-positive loop bound");
    _jump292:;
    // Computing bound for q
    if (_520 > 0) 
    goto _jump293;
    fail_assertion("non-positive loop bound");
    _jump293:;
    _568 = 0;
    int64_t _569 = 0; // q
    int64_t _570 = 0; // p
    _jump294:; // Begin body of loop
    double _571 = 82.0;
    double _572 = -_571;
    _568 += _572;
    _569++;
    if (_569 < _520)
    goto _jump294;
    _569 = 0;
    _570++;
    if (_570 < _79.d1)
    goto _jump294;
    // End body of loop
    double _573 = -_568;
    double _574 = _567 + _573;
    _a2__a2_double _575;
    // Computing bound for p
    _575.d0 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing bound for q
    _575.d1 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    // Computing total size of heap memory to allocate
    int64_t _576 = 1;
    _576 *= _79.d0;
    _576 *= _507.d2;
    _576 *= sizeof(_a2_double);
    _575.data = jpl_alloc(_576);
    int64_t _577 = 0; // q
    int64_t _578 = 0; // p
    _jump297:; // Begin body of loop
    _a2_double _579;
    // Computing bound for r
    _579.d0 = _578;
    if (_578 > 0) 
    goto _jump298;
    fail_assertion("non-positive loop bound");
    _jump298:;
    // Computing bound for s
    _579.d1 = _519;
    if (_519 > 0) 
    goto _jump299;
    fail_assertion("non-positive loop bound");
    _jump299:;
    // Computing total size of heap memory to allocate
    int64_t _580 = 1;
    _580 *= _578;
    _580 *= _519;
    _580 *= sizeof(double);
    _579.data = jpl_alloc(_580);
    int64_t _581 = 0; // s
    int64_t _582 = 0; // r
    _jump300:; // Begin body of loop
    double _583 = 13.0;
    int64_t _584 = 0;
    _584 *= _579.d0;
    _584 += _582;
    _584 *= _579.d1;
    _584 += _581;
    _579.data[_584] = _583;
    _581++;
    if (_581 < _519)
    goto _jump300;
    _581 = 0;
    _582++;
    if (_582 < _578)
    goto _jump300;
    // End body of loop
    int64_t _585 = 0;
    _585 *= _575.d0;
    _585 += _578;
    _585 *= _575.d1;
    _585 += _577;
    _575.data[_585] = _579;
    _577++;
    if (_577 < _507.d2)
    goto _jump297;
    _577 = 0;
    _578++;
    if (_578 < _79.d0)
    goto _jump297;
    // End body of loop
    int64_t _586;
    // Computing bound for p
    if (_507.d1 > 0) 
    goto _jump301;
    fail_assertion("non-positive loop bound");
    _jump301:;
    // Computing bound for q
    bool _587 = false;
    int64_t _588;
    if (!_587)
    goto _jump302;
    _588 = _507.d2;
    goto _jump303;
    _jump302:;
    _588 = _79.d2;
    _jump303:;
    if (_588 > 0) 
    goto _jump304;
    fail_assertion("non-positive loop bound");
    _jump304:;
    // Computing bound for r
    if (_430.d1 > 0) 
    goto _jump305;
    fail_assertion("non-positive loop bound");
    _jump305:;
    _586 = 0;
    int64_t _589 = 0; // r
    int64_t _590 = 0; // q
    int64_t _591 = 0; // p
    _jump306:; // Begin body of loop
    int64_t _592 = 266;
    _586 += _592;
    _589++;
    if (_589 < _430.d1)
    goto _jump306;
    _589 = 0;
    _590++;
    if (_590 < _588)
    goto _jump306;
    _590 = 0;
    _591++;
    if (_591 < _507.d1)
    goto _jump306;
    // End body of loop
    int64_t _593 = 405;
    if (_586 >= 0)
    goto _jump307;
    fail_assertion("negative array index");
    _jump307:;
    if (_586 < _575.d0)
    goto _jump308;
    fail_assertion("index too large");
    _jump308:;
    if (_593 >= 0)
    goto _jump309;
    fail_assertion("negative array index");
    _jump309:;
    if (_593 < _575.d1)
    goto _jump310;
    fail_assertion("index too large");
    _jump310:;
    int64_t _594 = 0;
    _594 *= _575.d0;
    _594 += _586;
    _594 *= _575.d1;
    _594 += _593;
    _a2_double _595 = _575.data[_594];
    if (_507.d1 >= 0)
    goto _jump311;
    fail_assertion("negative array index");
    _jump311:;
    if (_507.d1 < _595.d0)
    goto _jump312;
    fail_assertion("index too large");
    _jump312:;
    if (_519 >= 0)
    goto _jump313;
    fail_assertion("negative array index");
    _jump313:;
    if (_519 < _595.d1)
    goto _jump314;
    fail_assertion("index too large");
    _jump314:;
    int64_t _596 = 0;
    _596 *= _595.d0;
    _596 += _507.d1;
    _596 *= _595.d1;
    _596 += _519;
    double _597 = _595.data[_596];
    double _598 = _574 / _597;
    double _599;
    // Computing bound for p
    _a1_int64_t _600;
    // Computing bound for p
    int64_t _601;
    // Computing bound for p
    if (_79.d1 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    // Computing bound for q
    if (_430.d0 > 0) 
    goto _jump316;
    fail_assertion("non-positive loop bound");
    _jump316:;
    _601 = 0;
    int64_t _602 = 0; // q
    int64_t _603 = 0; // p
    _jump317:; // Begin body of loop
    int64_t _604 = _519 % _430.d0;
    _601 += _604;
    _602++;
    if (_602 < _430.d0)
    goto _jump317;
    _602 = 0;
    _603++;
    if (_603 < _79.d1)
    goto _jump317;
    // End body of loop
    _600.d0 = _601;
    if (_601 > 0) 
    goto _jump318;
    fail_assertion("non-positive loop bound");
    _jump318:;
    // Computing total size of heap memory to allocate
    int64_t _605 = 1;
    _605 *= _601;
    _605 *= sizeof(int64_t);
    _600.data = jpl_alloc(_605);
    int64_t _606 = 0; // p
    _jump319:; // Begin body of loop
    bool _607 = _430.d2 < _430.d0;
    int64_t _608;
    if (!_607)
    goto _jump320;
    int64_t _609 = 307;
    if (_430.d0 >= 0)
    goto _jump321;
    fail_assertion("negative array index");
    _jump321:;
    if (_430.d0 < _507.d0)
    goto _jump322;
    fail_assertion("index too large");
    _jump322:;
    if (_507.d0 >= 0)
    goto _jump323;
    fail_assertion("negative array index");
    _jump323:;
    if (_507.d0 < _507.d1)
    goto _jump324;
    fail_assertion("index too large");
    _jump324:;
    if (_609 >= 0)
    goto _jump325;
    fail_assertion("negative array index");
    _jump325:;
    if (_609 < _507.d2)
    goto _jump326;
    fail_assertion("index too large");
    _jump326:;
    int64_t _610 = 0;
    _610 *= _507.d0;
    _610 += _430.d0;
    _610 *= _507.d1;
    _610 += _507.d0;
    _610 *= _507.d2;
    _610 += _609;
    int64_t _611 = _507.data[_610];
    _608 = _611;
    goto _jump327;
    _jump320:;
    int64_t _612;
    if (!_506)
    goto _jump328;
    _612 = _430.d0;
    goto _jump329;
    _jump328:;
    _612 = _79.d0;
    _jump329:;
    _608 = _612;
    _jump327:;
    int64_t _613 = 0;
    _613 *= _600.d0;
    _613 += _606;
    _600.data[_613] = _608;
    _606++;
    if (_606 < _601)
    goto _jump319;
    // End body of loop
    if (_520 >= 0)
    goto _jump330;
    fail_assertion("negative array index");
    _jump330:;
    if (_520 < _507.d0)
    goto _jump331;
    fail_assertion("index too large");
    _jump331:;
    if (_79.d0 >= 0)
    goto _jump332;
    fail_assertion("negative array index");
    _jump332:;
    if (_79.d0 < _507.d1)
    goto _jump333;
    fail_assertion("index too large");
    _jump333:;
    if (_520 >= 0)
    goto _jump334;
    fail_assertion("negative array index");
    _jump334:;
    if (_520 < _507.d2)
    goto _jump335;
    fail_assertion("index too large");
    _jump335:;
    int64_t _614 = 0;
    _614 *= _507.d0;
    _614 += _520;
    _614 *= _507.d1;
    _614 += _79.d0;
    _614 *= _507.d2;
    _614 += _520;
    int64_t _615 = _507.data[_614];
    if (_615 >= 0)
    goto _jump336;
    fail_assertion("negative array index");
    _jump336:;
    if (_615 < _600.d0)
    goto _jump337;
    fail_assertion("index too large");
    _jump337:;
    int64_t _616 = 0;
    _616 *= _600.d0;
    _616 += _615;
    int64_t _617 = _600.data[_616];
    if (_617 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for q
    if (_519 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    _599 = 0;
    int64_t _618 = 0; // q
    int64_t _619 = 0; // p
    _jump340:; // Begin body of loop
    double _620;
    // Computing bound for r
    int64_t _621;
    // Computing bound for r
    if (_79.d1 > 0) 
    goto _jump341;
    fail_assertion("non-positive loop bound");
    _jump341:;
    // Computing bound for s
    int64_t _622 = 327;
    if (_622 > 0) 
    goto _jump342;
    fail_assertion("non-positive loop bound");
    _jump342:;
    // Computing bound for t
    if (_430.d2 > 0) 
    goto _jump343;
    fail_assertion("non-positive loop bound");
    _jump343:;
    _621 = 0;
    int64_t _623 = 0; // t
    int64_t _624 = 0; // s
    int64_t _625 = 0; // r
    _jump344:; // Begin body of loop
    int64_t _626 = 87;
    int64_t _627 = -_626;
    _621 += _627;
    _623++;
    if (_623 < _430.d2)
    goto _jump344;
    _623 = 0;
    _624++;
    if (_624 < _622)
    goto _jump344;
    _624 = 0;
    _625++;
    if (_625 < _79.d1)
    goto _jump344;
    // End body of loop
    if (_621 > 0) 
    goto _jump345;
    fail_assertion("non-positive loop bound");
    _jump345:;
    _620 = 0;
    int64_t _628 = 0; // r
    _jump346:; // Begin body of loop
    double _629 = 65.0;
    double _630 = -_629;
    _620 += _630;
    _628++;
    if (_628 < _621)
    goto _jump346;
    // End body of loop
    double _631 = -_620;
    _599 += _631;
    _618++;
    if (_618 < _519)
    goto _jump340;
    _618 = 0;
    _619++;
    if (_619 < _617)
    goto _jump340;
    // End body of loop
    rgba _632 = { _542, _557, _598, _599 };
    int64_t _633 = 0;
    _633 *= _516.d0;
    _633 += _520;
    _633 *= _516.d1;
    _633 += _519;
    _516.data[_633] = _632;
    _519++;
    if (_519 < _517)
    goto _jump267;
    _519 = 0;
    _520++;
    if (_520 < _430.d0)
    goto _jump267;
    // End body of loop
    write_image(_516, "n.png");
    _a2_bool _634;
    // Computing bound for n
    int64_t _635 = -_79.d1;
    int64_t _636 = _79.d2 - _635;
    _634.d0 = _636;
    if (_636 > 0) 
    goto _jump347;
    fail_assertion("non-positive loop bound");
    _jump347:;
    // Computing bound for o
    _634.d1 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump348;
    fail_assertion("non-positive loop bound");
    _jump348:;
    // Computing total size of heap memory to allocate
    int64_t _637 = 1;
    _637 *= _636;
    _637 *= _507.d0;
    _637 *= sizeof(bool);
    _634.data = jpl_alloc(_637);
    int64_t _638 = 0; // o
    int64_t _639 = 0; // n
    _jump349:; // Begin body of loop
    bool _640 = _79.d1 >= _430.d2;
    int64_t _641 = 0;
    _641 *= _634.d0;
    _641 += _639;
    _641 *= _634.d1;
    _641 += _638;
    _634.data[_641] = _640;
    _638++;
    if (_638 < _507.d0)
    goto _jump349;
    _638 = 0;
    _639++;
    if (_639 < _636)
    goto _jump349;
    // End body of loop
    _a3_double _642;
    // Computing bound for q
    int64_t _643 = 756;
    int64_t _644 = -_643;
    _642.d0 = _644;
    if (_644 > 0) 
    goto _jump350;
    fail_assertion("non-positive loop bound");
    _jump350:;
    // Computing bound for r
    _642.d1 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    // Computing bound for s
    int64_t _645;
    // Computing bound for q
    if (_430.d1 > 0) 
    goto _jump352;
    fail_assertion("non-positive loop bound");
    _jump352:;
    // Computing bound for r
    if (_79.d1 > 0) 
    goto _jump353;
    fail_assertion("non-positive loop bound");
    _jump353:;
    _645 = 0;
    int64_t _646 = 0; // r
    int64_t _647 = 0; // q
    _jump354:; // Begin body of loop
    bool _648 = false;
    int64_t _649;
    if (!_648)
    goto _jump355;
    _649 = _430.d0;
    goto _jump356;
    _jump355:;
    _649 = _507.d0;
    _jump356:;
    _645 += _649;
    _646++;
    if (_646 < _79.d1)
    goto _jump354;
    _646 = 0;
    _647++;
    if (_647 < _430.d1)
    goto _jump354;
    // End body of loop
    _642.d2 = _645;
    if (_645 > 0) 
    goto _jump357;
    fail_assertion("non-positive loop bound");
    _jump357:;
    // Computing total size of heap memory to allocate
    int64_t _650 = 1;
    _650 *= _644;
    _650 *= _507.d0;
    _650 *= _645;
    _650 *= sizeof(double);
    _642.data = jpl_alloc(_650);
    int64_t _651 = 0; // s
    int64_t _652 = 0; // r
    int64_t _653 = 0; // q
    _jump358:; // Begin body of loop
    double _654 = 92.0;
    int64_t _655 = 0;
    _655 *= _642.d0;
    _655 += _653;
    _655 *= _642.d1;
    _655 += _652;
    _655 *= _642.d2;
    _655 += _651;
    _642.data[_655] = _654;
    _651++;
    if (_651 < _645)
    goto _jump358;
    _651 = 0;
    _652++;
    if (_652 < _507.d0)
    goto _jump358;
    _652 = 0;
    _653++;
    if (_653 < _644)
    goto _jump358;
    // End body of loop
    double _656 = 80.0;
    double _657 = -_656;
    double _658 = -_657;
    double _659;
    // Computing bound for u
    if (_507.d0 > 0) 
    goto _jump359;
    fail_assertion("non-positive loop bound");
    _jump359:;
    _659 = 0;
    int64_t _660 = 0; // u
    _jump360:; // Begin body of loop
    double _661 = 2.0;
    if (_634.d1 >= 0)
    goto _jump361;
    fail_assertion("negative array index");
    _jump361:;
    if (_634.d1 < _79.d0)
    goto _jump362;
    fail_assertion("index too large");
    _jump362:;
    if (_79.d0 >= 0)
    goto _jump363;
    fail_assertion("negative array index");
    _jump363:;
    if (_79.d0 < _79.d1)
    goto _jump364;
    fail_assertion("index too large");
    _jump364:;
    if (_430.d2 >= 0)
    goto _jump365;
    fail_assertion("negative array index");
    _jump365:;
    if (_430.d2 < _79.d2)
    goto _jump366;
    fail_assertion("index too large");
    _jump366:;
    int64_t _662 = 0;
    _662 *= _79.d0;
    _662 += _634.d1;
    _662 *= _79.d1;
    _662 += _79.d0;
    _662 *= _79.d2;
    _662 += _430.d2;
    double _663 = _79.data[_662];
    double _664 = _661 * _663;
    _659 += _664;
    _660++;
    if (_660 < _507.d0)
    goto _jump360;
    // End body of loop
    double _665 = -_659;
    bool _666 = _658 == _665;
    _a2__a2_bool _667;
    if (!_666)
    goto _jump367;
    _a1__a2__a2_bool _668;
    // Computing bound for u
    _668.d0 = _430.d2;
    if (_430.d2 > 0) 
    goto _jump368;
    fail_assertion("non-positive loop bound");
    _jump368:;
    // Computing total size of heap memory to allocate
    int64_t _669 = 1;
    _669 *= _430.d2;
    _669 *= sizeof(_a2__a2_bool);
    _668.data = jpl_alloc(_669);
    int64_t _670 = 0; // u
    _jump369:; // Begin body of loop
    _a2__a2_bool _671;
    // Computing bound for v
    _671.d0 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump370;
    fail_assertion("non-positive loop bound");
    _jump370:;
    // Computing bound for w
    _671.d1 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing total size of heap memory to allocate
    int64_t _672 = 1;
    _672 *= _642.d0;
    _672 *= _507.d1;
    _672 *= sizeof(_a2_bool);
    _671.data = jpl_alloc(_672);
    int64_t _673 = 0; // w
    int64_t _674 = 0; // v
    _jump372:; // Begin body of loop
    bool _675 = true;
    _a2_bool _676;
    if (!_675)
    goto _jump373;
    _676 = _634;
    goto _jump374;
    _jump373:;
    bool _677 = false;
    _a2_bool _678;
    if (!_677)
    goto _jump375;
    _678 = _634;
    goto _jump376;
    _jump375:;
    _678 = _634;
    _jump376:;
    _676 = _678;
    _jump374:;
    int64_t _679 = 0;
    _679 *= _671.d0;
    _679 += _674;
    _679 *= _671.d1;
    _679 += _673;
    _671.data[_679] = _676;
    _673++;
    if (_673 < _507.d1)
    goto _jump372;
    _673 = 0;
    _674++;
    if (_674 < _642.d0)
    goto _jump372;
    // End body of loop
    int64_t _680 = 0;
    _680 *= _668.d0;
    _680 += _670;
    _668.data[_680] = _671;
    _670++;
    if (_670 < _430.d2)
    goto _jump369;
    // End body of loop
    if (_642.d0 >= 0)
    goto _jump377;
    fail_assertion("negative array index");
    _jump377:;
    if (_642.d0 < _668.d0)
    goto _jump378;
    fail_assertion("index too large");
    _jump378:;
    int64_t _681 = 0;
    _681 *= _668.d0;
    _681 += _642.d0;
    _a2__a2_bool _682 = _668.data[_681];
    _667 = _682;
    goto _jump379;
    _jump367:;
    bool _683 = false;
    bool _684 = !_683;
    bool _685;
    if (!_684)
    goto _jump380;
    _a3_bool _686;
    // Computing bound for u
    _686.d0 = _642.d1;
    if (_642.d1 > 0) 
    goto _jump381;
    fail_assertion("non-positive loop bound");
    _jump381:;
    // Computing bound for v
    _686.d1 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing bound for w
    bool _687 = false;
    int64_t _688;
    if (!_687)
    goto _jump383;
    _688 = _430.d2;
    goto _jump384;
    _jump383:;
    _688 = _430.d1;
    _jump384:;
    _686.d2 = _688;
    if (_688 > 0) 
    goto _jump385;
    fail_assertion("non-positive loop bound");
    _jump385:;
    // Computing total size of heap memory to allocate
    int64_t _689 = 1;
    _689 *= _642.d1;
    _689 *= _507.d0;
    _689 *= _688;
    _689 *= sizeof(bool);
    _686.data = jpl_alloc(_689);
    int64_t _690 = 0; // w
    int64_t _691 = 0; // v
    int64_t _692 = 0; // u
    _jump386:; // Begin body of loop
    bool _693 = _506;
    if (0 != _506)
    goto _jump387;
    bool _694 = true;
    _693 = _694;
    _jump387:;
    int64_t _695 = 0;
    _695 *= _686.d0;
    _695 += _692;
    _695 *= _686.d1;
    _695 += _691;
    _695 *= _686.d2;
    _695 += _690;
    _686.data[_695] = _693;
    _690++;
    if (_690 < _688)
    goto _jump386;
    _690 = 0;
    _691++;
    if (_691 < _507.d0)
    goto _jump386;
    _691 = 0;
    _692++;
    if (_692 < _642.d1)
    goto _jump386;
    // End body of loop
    bool _696 = _506;
    if (0 != _506)
    goto _jump388;
    bool _697 = true;
    _696 = _697;
    _jump388:;
    int64_t _698;
    if (!_696)
    goto _jump389;
    _698 = _507.d1;
    goto _jump390;
    _jump389:;
    _698 = _634.d0;
    _jump390:;
    if (_79.d0 >= 0)
    goto _jump391;
    fail_assertion("negative array index");
    _jump391:;
    if (_79.d0 < _686.d0)
    goto _jump392;
    fail_assertion("index too large");
    _jump392:;
    if (_698 >= 0)
    goto _jump393;
    fail_assertion("negative array index");
    _jump393:;
    if (_698 < _686.d1)
    goto _jump394;
    fail_assertion("index too large");
    _jump394:;
    if (_507.d0 >= 0)
    goto _jump395;
    fail_assertion("negative array index");
    _jump395:;
    if (_507.d0 < _686.d2)
    goto _jump396;
    fail_assertion("index too large");
    _jump396:;
    int64_t _699 = 0;
    _699 *= _686.d0;
    _699 += _79.d0;
    _699 *= _686.d1;
    _699 += _698;
    _699 *= _686.d2;
    _699 += _507.d0;
    bool _700 = _686.data[_699];
    _685 = _700;
    goto _jump397;
    _jump380:;
    _685 = _506;
    _jump397:;
    _a2__a2_bool _701;
    if (!_685)
    goto _jump398;
    _a2__a2_bool _702;
    // Computing bound for u
    if (_430.d0 >= 0)
    goto _jump399;
    fail_assertion("negative array index");
    _jump399:;
    if (_430.d0 < _430.d0)
    goto _jump400;
    fail_assertion("index too large");
    _jump400:;
    if (_507.d0 >= 0)
    goto _jump401;
    fail_assertion("negative array index");
    _jump401:;
    if (_507.d0 < _430.d1)
    goto _jump402;
    fail_assertion("index too large");
    _jump402:;
    if (_507.d0 >= 0)
    goto _jump403;
    fail_assertion("negative array index");
    _jump403:;
    if (_507.d0 < _430.d2)
    goto _jump404;
    fail_assertion("index too large");
    _jump404:;
    int64_t _703 = 0;
    _703 *= _430.d0;
    _703 += _430.d0;
    _703 *= _430.d1;
    _703 += _507.d0;
    _703 *= _430.d2;
    _703 += _507.d0;
    int64_t _704 = _430.data[_703];
    int64_t _705 = -_704;
    int64_t _706 = _430.d0 + _705;
    _702.d0 = _706;
    if (_706 > 0) 
    goto _jump405;
    fail_assertion("non-positive loop bound");
    _jump405:;
    // Computing bound for v
    _702.d1 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump406;
    fail_assertion("non-positive loop bound");
    _jump406:;
    // Computing total size of heap memory to allocate
    int64_t _707 = 1;
    _707 *= _706;
    _707 *= _79.d0;
    _707 *= sizeof(_a2_bool);
    _702.data = jpl_alloc(_707);
    int64_t _708 = 0; // v
    int64_t _709 = 0; // u
    _jump407:; // Begin body of loop
    int64_t _710;
    // Computing bound for w
    if (_634.d0 > 0) 
    goto _jump408;
    fail_assertion("non-positive loop bound");
    _jump408:;
    _710 = 0;
    int64_t _711 = 0; // w
    _jump409:; // Begin body of loop
    _710 += _507.d0;
    _711++;
    if (_711 < _634.d0)
    goto _jump409;
    // End body of loop
    bool _712 = _708 != _710;
    _a2_bool _713;
    if (!_712)
    goto _jump410;
    bool _714 = !_506;
    _a2_bool _715;
    if (!_714)
    goto _jump411;
    _a2_bool _716;
    // Computing bound for w
    _716.d0 = _708;
    if (_708 > 0) 
    goto _jump412;
    fail_assertion("non-positive loop bound");
    _jump412:;
    // Computing bound for x
    _716.d1 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump413;
    fail_assertion("non-positive loop bound");
    _jump413:;
    // Computing total size of heap memory to allocate
    int64_t _717 = 1;
    _717 *= _708;
    _717 *= _430.d0;
    _717 *= sizeof(bool);
    _716.data = jpl_alloc(_717);
    int64_t _718 = 0; // x
    int64_t _719 = 0; // w
    _jump414:; // Begin body of loop
    int64_t _720 = 0;
    _720 *= _716.d0;
    _720 += _719;
    _720 *= _716.d1;
    _720 += _718;
    _716.data[_720] = _506;
    _718++;
    if (_718 < _430.d0)
    goto _jump414;
    _718 = 0;
    _719++;
    if (_719 < _708)
    goto _jump414;
    // End body of loop
    _715 = _716;
    goto _jump415;
    _jump411:;
    _715 = _634;
    _jump415:;
    _713 = _715;
    goto _jump416;
    _jump410:;
    _713 = _634;
    _jump416:;
    int64_t _721 = 0;
    _721 *= _702.d0;
    _721 += _709;
    _721 *= _702.d1;
    _721 += _708;
    _702.data[_721] = _713;
    _708++;
    if (_708 < _79.d0)
    goto _jump407;
    _708 = 0;
    _709++;
    if (_709 < _706)
    goto _jump407;
    // End body of loop
    _701 = _702;
    goto _jump417;
    _jump398:;
    _a2__a2__a2_bool _722;
    // Computing bound for u
    _722.d0 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump418;
    fail_assertion("non-positive loop bound");
    _jump418:;
    // Computing bound for v
    _722.d1 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump419;
    fail_assertion("non-positive loop bound");
    _jump419:;
    // Computing total size of heap memory to allocate
    int64_t _723 = 1;
    _723 *= _642.d0;
    _723 *= _79.d0;
    _723 *= sizeof(_a2__a2_bool);
    _722.data = jpl_alloc(_723);
    int64_t _724 = 0; // v
    int64_t _725 = 0; // u
    _jump420:; // Begin body of loop
    bool _726 = false;
    _a2__a2_bool _727;
    if (!_726)
    goto _jump421;
    _a2__a2_bool _728;
    // Computing bound for w
    _728.d0 = _642.d2;
    if (_642.d2 > 0) 
    goto _jump422;
    fail_assertion("non-positive loop bound");
    _jump422:;
    // Computing bound for x
    _728.d1 = _79.d1;
    if (_79.d1 > 0) 
    goto _jump423;
    fail_assertion("non-positive loop bound");
    _jump423:;
    // Computing total size of heap memory to allocate
    int64_t _729 = 1;
    _729 *= _642.d2;
    _729 *= _79.d1;
    _729 *= sizeof(_a2_bool);
    _728.data = jpl_alloc(_729);
    int64_t _730 = 0; // x
    int64_t _731 = 0; // w
    _jump424:; // Begin body of loop
    int64_t _732 = 0;
    _732 *= _728.d0;
    _732 += _731;
    _732 *= _728.d1;
    _732 += _730;
    _728.data[_732] = _634;
    _730++;
    if (_730 < _79.d1)
    goto _jump424;
    _730 = 0;
    _731++;
    if (_731 < _642.d2)
    goto _jump424;
    // End body of loop
    _727 = _728;
    goto _jump425;
    _jump421:;
    _a2__a2_bool _733;
    // Computing bound for w
    _733.d0 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    // Computing bound for x
    _733.d1 = _430.d1;
    if (_430.d1 > 0) 
    goto _jump427;
    fail_assertion("non-positive loop bound");
    _jump427:;
    // Computing total size of heap memory to allocate
    int64_t _734 = 1;
    _734 *= _507.d0;
    _734 *= _430.d1;
    _734 *= sizeof(_a2_bool);
    _733.data = jpl_alloc(_734);
    int64_t _735 = 0; // x
    int64_t _736 = 0; // w
    _jump428:; // Begin body of loop
    int64_t _737 = 0;
    _737 *= _733.d0;
    _737 += _736;
    _737 *= _733.d1;
    _737 += _735;
    _733.data[_737] = _634;
    _735++;
    if (_735 < _430.d1)
    goto _jump428;
    _735 = 0;
    _736++;
    if (_736 < _507.d0)
    goto _jump428;
    // End body of loop
    _727 = _733;
    _jump425:;
    int64_t _738 = 0;
    _738 *= _722.d0;
    _738 += _725;
    _738 *= _722.d1;
    _738 += _724;
    _722.data[_738] = _727;
    _724++;
    if (_724 < _79.d0)
    goto _jump420;
    _724 = 0;
    _725++;
    if (_725 < _642.d0)
    goto _jump420;
    // End body of loop
    int64_t _739 = 735;
    int64_t _740 = _642.d2 - _739;
    if (_740 >= 0)
    goto _jump429;
    fail_assertion("negative array index");
    _jump429:;
    if (_740 < _722.d0)
    goto _jump430;
    fail_assertion("index too large");
    _jump430:;
    if (_507.d2 >= 0)
    goto _jump431;
    fail_assertion("negative array index");
    _jump431:;
    if (_507.d2 < _722.d1)
    goto _jump432;
    fail_assertion("index too large");
    _jump432:;
    int64_t _741 = 0;
    _741 *= _722.d0;
    _741 += _740;
    _741 *= _722.d1;
    _741 += _507.d2;
    _a2__a2_bool _742 = _722.data[_741];
    _701 = _742;
    _jump417:;
    _667 = _701;
    _jump379:;
    if (_634.d1 >= 0)
    goto _jump433;
    fail_assertion("negative array index");
    _jump433:;
    if (_634.d1 < _667.d0)
    goto _jump434;
    fail_assertion("index too large");
    _jump434:;
    if (_634.d0 >= 0)
    goto _jump435;
    fail_assertion("negative array index");
    _jump435:;
    if (_634.d0 < _667.d1)
    goto _jump436;
    fail_assertion("index too large");
    _jump436:;
    int64_t _743 = 0;
    _743 *= _667.d0;
    _743 += _634.d1;
    _743 *= _667.d1;
    _743 += _634.d0;
    _a2_bool _744 = _667.data[_743];
    _a1_double _746;
    // Computing bound for x
    _746.d0 = _430.d2;
    if (_430.d2 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing total size of heap memory to allocate
    int64_t _747 = 1;
    _747 *= _430.d2;
    _747 *= sizeof(double);
    _746.data = jpl_alloc(_747);
    int64_t _748 = 0; // x
    _jump438:; // Begin body of loop
    double _749 = 94.0;
    double _750 = -_749;
    int64_t _751 = 0;
    _751 *= _746.d0;
    _751 += _748;
    _746.data[_751] = _750;
    _748++;
    if (_748 < _430.d2)
    goto _jump438;
    // End body of loop
    if (_642.d0 >= 0)
    goto _jump439;
    fail_assertion("negative array index");
    _jump439:;
    if (_642.d0 < _746.d0)
    goto _jump440;
    fail_assertion("index too large");
    _jump440:;
    int64_t _752 = 0;
    _752 *= _746.d0;
    _752 += _642.d0;
    double _753 = _746.data[_752];
    double _754 = 13.0;
    bool _755 = _753 < _754;
    bool _745 = _755;
    if (0 == _755)
    goto _jump441;
    if (_642.d0 >= 0)
    goto _jump442;
    fail_assertion("negative array index");
    _jump442:;
    if (_642.d0 < _634.d0)
    goto _jump443;
    fail_assertion("index too large");
    _jump443:;
    if (_430.d0 >= 0)
    goto _jump444;
    fail_assertion("negative array index");
    _jump444:;
    if (_430.d0 < _634.d1)
    goto _jump445;
    fail_assertion("index too large");
    _jump445:;
    int64_t _756 = 0;
    _756 *= _634.d0;
    _756 += _642.d0;
    _756 *= _634.d1;
    _756 += _430.d0;
    bool _757 = _634.data[_756];
    bool _758;
    if (!_757)
    goto _jump446;
    _a3_bool _759;
    // Computing bound for x
    _759.d0 = _430.d1;
    if (_430.d1 > 0) 
    goto _jump447;
    fail_assertion("non-positive loop bound");
    _jump447:;
    // Computing bound for y
    _759.d1 = _430.d2;
    if (_430.d2 > 0) 
    goto _jump448;
    fail_assertion("non-positive loop bound");
    _jump448:;
    // Computing bound for z
    _759.d2 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing total size of heap memory to allocate
    int64_t _760 = 1;
    _760 *= _430.d1;
    _760 *= _430.d2;
    _760 *= _507.d2;
    _760 *= sizeof(bool);
    _759.data = jpl_alloc(_760);
    int64_t _761 = 0; // z
    int64_t _762 = 0; // y
    int64_t _763 = 0; // x
    _jump450:; // Begin body of loop
    int64_t _764 = 0;
    _764 *= _759.d0;
    _764 += _763;
    _764 *= _759.d1;
    _764 += _762;
    _764 *= _759.d2;
    _764 += _761;
    _759.data[_764] = _506;
    _761++;
    if (_761 < _507.d2)
    goto _jump450;
    _761 = 0;
    _762++;
    if (_762 < _430.d2)
    goto _jump450;
    _762 = 0;
    _763++;
    if (_763 < _430.d1)
    goto _jump450;
    // End body of loop
    int64_t _765 = -_79.d1;
    int64_t _766;
    // Computing bound for x
    if (_507.d2 > 0) 
    goto _jump451;
    fail_assertion("non-positive loop bound");
    _jump451:;
    _766 = 0;
    int64_t _767 = 0; // x
    _jump452:; // Begin body of loop
    _766 += _430.d1;
    _767++;
    if (_767 < _507.d2)
    goto _jump452;
    // End body of loop
    if (_765 >= 0)
    goto _jump453;
    fail_assertion("negative array index");
    _jump453:;
    if (_765 < _759.d0)
    goto _jump454;
    fail_assertion("index too large");
    _jump454:;
    if (_766 >= 0)
    goto _jump455;
    fail_assertion("negative array index");
    _jump455:;
    if (_766 < _759.d1)
    goto _jump456;
    fail_assertion("index too large");
    _jump456:;
    if (_507.d0 >= 0)
    goto _jump457;
    fail_assertion("negative array index");
    _jump457:;
    if (_507.d0 < _759.d2)
    goto _jump458;
    fail_assertion("index too large");
    _jump458:;
    int64_t _768 = 0;
    _768 *= _759.d0;
    _768 += _765;
    _768 *= _759.d1;
    _768 += _766;
    _768 *= _759.d2;
    _768 += _507.d0;
    bool _769 = _759.data[_768];
    _758 = _769;
    goto _jump459;
    _jump446:;
    bool _770 = false;
    _758 = _770;
    _jump459:;
    bool _771;
    if (!_758)
    goto _jump460;
    bool _772 = _79.d2 >= _642.d1;
    bool _773;
    if (!_772)
    goto _jump461;
    bool _775 = _79.d1 >= _507.d1;
    bool _774 = _775;
    if (0 == _775)
    goto _jump462;
    bool _777 = true;
    bool _776 = _777;
    if (0 == _777)
    goto _jump463;
    _776 = _506;
    _jump463:;
    _774 = _776;
    _jump462:;
    _773 = _774;
    goto _jump464;
    _jump461:;
    bool _778 = !_506;
    bool _779;
    if (!_778)
    goto _jump465;
    bool _780 = _430.d2 >= _634.d1;
    _779 = _780;
    goto _jump466;
    _jump465:;
    bool _781 = !_506;
    _779 = _781;
    _jump466:;
    _773 = _779;
    _jump464:;
    _771 = _773;
    goto _jump467;
    _jump460:;
    _a2_bool _783;
    // Computing bound for x
    _783.d0 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump468;
    fail_assertion("non-positive loop bound");
    _jump468:;
    // Computing bound for y
    _783.d1 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump469;
    fail_assertion("non-positive loop bound");
    _jump469:;
    // Computing total size of heap memory to allocate
    int64_t _784 = 1;
    _784 *= _642.d0;
    _784 *= _642.d0;
    _784 *= sizeof(bool);
    _783.data = jpl_alloc(_784);
    int64_t _785 = 0; // y
    int64_t _786 = 0; // x
    _jump470:; // Begin body of loop
    int64_t _787 = 0;
    _787 *= _783.d0;
    _787 += _786;
    _787 *= _783.d1;
    _787 += _785;
    _783.data[_787] = _506;
    _785++;
    if (_785 < _642.d0)
    goto _jump470;
    _785 = 0;
    _786++;
    if (_786 < _642.d0)
    goto _jump470;
    // End body of loop
    int64_t _788;
    // Computing bound for x
    if (_642.d2 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    // Computing bound for y
    if (_507.d1 > 0) 
    goto _jump472;
    fail_assertion("non-positive loop bound");
    _jump472:;
    // Computing bound for z
    if (_507.d0 > 0) 
    goto _jump473;
    fail_assertion("non-positive loop bound");
    _jump473:;
    _788 = 0;
    int64_t _789 = 0; // z
    int64_t _790 = 0; // y
    int64_t _791 = 0; // x
    _jump474:; // Begin body of loop
    _788 += _634.d1;
    _789++;
    if (_789 < _507.d0)
    goto _jump474;
    _789 = 0;
    _790++;
    if (_790 < _507.d1)
    goto _jump474;
    _790 = 0;
    _791++;
    if (_791 < _642.d2)
    goto _jump474;
    // End body of loop
    if (_744.d0 >= 0)
    goto _jump475;
    fail_assertion("negative array index");
    _jump475:;
    if (_744.d0 < _783.d0)
    goto _jump476;
    fail_assertion("index too large");
    _jump476:;
    if (_788 >= 0)
    goto _jump477;
    fail_assertion("negative array index");
    _jump477:;
    if (_788 < _783.d1)
    goto _jump478;
    fail_assertion("index too large");
    _jump478:;
    int64_t _792 = 0;
    _792 *= _783.d0;
    _792 += _744.d0;
    _792 *= _783.d1;
    _792 += _788;
    bool _793 = _783.data[_792];
    bool _782 = _793;
    if (0 != _793)
    goto _jump479;
    _782 = _506;
    _jump479:;
    _771 = _782;
    _jump467:;
    _745 = _771;
    _jump441:;
    bool _794 = !_745;
    _a2_bool _795;
    if (!_794)
    goto _jump480;
    _795 = _634;
    goto _jump481;
    _jump480:;
    _a2_bool _796;
    // Computing bound for x
    _796.d0 = _744.d0;
    if (_744.d0 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing bound for y
    _796.d1 = _507.d2;
    if (_507.d2 > 0) 
    goto _jump483;
    fail_assertion("non-positive loop bound");
    _jump483:;
    // Computing total size of heap memory to allocate
    int64_t _797 = 1;
    _797 *= _744.d0;
    _797 *= _507.d2;
    _797 *= sizeof(bool);
    _796.data = jpl_alloc(_797);
    int64_t _798 = 0; // y
    int64_t _799 = 0; // x
    _jump484:; // Begin body of loop
    bool _800 = _506;
    if (0 != _506)
    goto _jump485;
    double _801 = 27.0;
    double _802 = 99.0;
    double _803 = 22.0;
    double _804 = _802 * _803;
    bool _805 = _801 == _804;
    _800 = _805;
    _jump485:;
    bool _806 = !_800;
    bool _809 = true;
    bool _810 = !_809;
    bool _808 = _810;
    if (0 != _810)
    goto _jump486;
    if (_642.d0 >= 0)
    goto _jump487;
    fail_assertion("negative array index");
    _jump487:;
    if (_642.d0 < _744.d0)
    goto _jump488;
    fail_assertion("index too large");
    _jump488:;
    if (_744.d0 >= 0)
    goto _jump489;
    fail_assertion("negative array index");
    _jump489:;
    if (_744.d0 < _744.d1)
    goto _jump490;
    fail_assertion("index too large");
    _jump490:;
    int64_t _811 = 0;
    _811 *= _744.d0;
    _811 += _642.d0;
    _811 *= _744.d1;
    _811 += _744.d0;
    bool _812 = _744.data[_811];
    bool _813 = !_812;
    _808 = _813;
    _jump486:;
    bool _807 = _808;
    if (0 == _808)
    goto _jump491;
    bool _814;
    if (!_506)
    goto _jump492;
    if (_642.d2 >= 0)
    goto _jump493;
    fail_assertion("negative array index");
    _jump493:;
    if (_642.d2 < _642.d0)
    goto _jump494;
    fail_assertion("index too large");
    _jump494:;
    if (_634.d0 >= 0)
    goto _jump495;
    fail_assertion("negative array index");
    _jump495:;
    if (_634.d0 < _642.d1)
    goto _jump496;
    fail_assertion("index too large");
    _jump496:;
    if (_642.d1 >= 0)
    goto _jump497;
    fail_assertion("negative array index");
    _jump497:;
    if (_642.d1 < _642.d2)
    goto _jump498;
    fail_assertion("index too large");
    _jump498:;
    int64_t _815 = 0;
    _815 *= _642.d0;
    _815 += _642.d2;
    _815 *= _642.d1;
    _815 += _634.d0;
    _815 *= _642.d2;
    _815 += _642.d1;
    double _816 = _642.data[_815];
    double _817 = 58.0;
    bool _818 = _816 < _817;
    _814 = _818;
    goto _jump499;
    _jump492:;
    bool _819 = true;
    bool _820 = _506 == _819;
    bool _821 = _634.d0 < _799;
    bool _822 = _820 == _821;
    _814 = _822;
    _jump499:;
    _807 = _814;
    _jump491:;
    bool _823 = _806 == _807;
    int64_t _824 = 0;
    _824 *= _796.d0;
    _824 += _799;
    _824 *= _796.d1;
    _824 += _798;
    _796.data[_824] = _823;
    _798++;
    if (_798 < _507.d2)
    goto _jump484;
    _798 = 0;
    _799++;
    if (_799 < _744.d0)
    goto _jump484;
    // End body of loop
    _795 = _796;
    _jump481:;
    bool _825 = false;
    double _826;
    // Computing bound for C
    if (_795.d1 > 0) 
    goto _jump500;
    fail_assertion("non-positive loop bound");
    _jump500:;
    _826 = 0;
    int64_t _827 = 0; // C
    _jump501:; // Begin body of loop
    double _828 = 53.0;
    _826 += _828;
    _827++;
    if (_827 < _795.d1)
    goto _jump501;
    // End body of loop
    double _829 = 87.0;
    double _830 = 67.0;
    bool _831 = _829 > _830;
    double _832;
    if (!_831)
    goto _jump502;
    double _833 = 19.0;
    _832 = _833;
    goto _jump503;
    _jump502:;
    double _834 = 42.0;
    _832 = _834;
    _jump503:;
    bool _835 = !_506;
    double _836;
    if (!_835)
    goto _jump504;
    bool _837 = _795.d1 != _795.d0;
    bool _838 = !_837;
    double _839;
    if (!_838)
    goto _jump505;
    double _840;
    // Computing bound for C
    if (_507.d1 > 0) 
    goto _jump506;
    fail_assertion("non-positive loop bound");
    _jump506:;
    _840 = 0;
    int64_t _841 = 0; // C
    _jump507:; // Begin body of loop
    double _842;
    // Computing bound for D
    if (_79.d1 > 0) 
    goto _jump508;
    fail_assertion("non-positive loop bound");
    _jump508:;
    _842 = 0;
    int64_t _843 = 0; // D
    _jump509:; // Begin body of loop
    double _844 = 85.0;
    _842 += _844;
    _843++;
    if (_843 < _79.d1)
    goto _jump509;
    // End body of loop
    _840 += _842;
    _841++;
    if (_841 < _507.d1)
    goto _jump507;
    // End body of loop
    _839 = _840;
    goto _jump510;
    _jump505:;
    double _845;
    if (!_825)
    goto _jump511;
    double _846 = 60.0;
    _845 = _846;
    goto _jump512;
    _jump511:;
    double _847;
    // Computing bound for C
    if (_507.d0 > 0) 
    goto _jump513;
    fail_assertion("non-positive loop bound");
    _jump513:;
    _847 = 0;
    int64_t _848 = 0; // C
    _jump514:; // Begin body of loop
    double _849 = 72.0;
    _847 += _849;
    _848++;
    if (_848 < _507.d0)
    goto _jump514;
    // End body of loop
    _845 = _847;
    _jump512:;
    _839 = _845;
    _jump510:;
    _836 = _839;
    goto _jump515;
    _jump504:;
    double _850;
    // Computing bound for C
    if (_634.d1 > 0) 
    goto _jump516;
    fail_assertion("non-positive loop bound");
    _jump516:;
    // Computing bound for D
    if (_744.d1 > 0) 
    goto _jump517;
    fail_assertion("non-positive loop bound");
    _jump517:;
    // Computing bound for E
    if (_634.d1 > 0) 
    goto _jump518;
    fail_assertion("non-positive loop bound");
    _jump518:;
    _850 = 0;
    int64_t _851 = 0; // E
    int64_t _852 = 0; // D
    int64_t _853 = 0; // C
    _jump519:; // Begin body of loop
    double _854 = 73.0;
    _850 += _854;
    _851++;
    if (_851 < _634.d1)
    goto _jump519;
    _851 = 0;
    _852++;
    if (_852 < _744.d1)
    goto _jump519;
    _852 = 0;
    _853++;
    if (_853 < _634.d1)
    goto _jump519;
    // End body of loop
    double _855 = 72.0;
    double _856;
    // Computing bound for C
    if (_795.d1 > 0) 
    goto _jump520;
    fail_assertion("non-positive loop bound");
    _jump520:;
    // Computing bound for D
    if (_642.d0 > 0) 
    goto _jump521;
    fail_assertion("non-positive loop bound");
    _jump521:;
    // Computing bound for E
    if (_744.d1 > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    _856 = 0;
    int64_t _857 = 0; // E
    int64_t _858 = 0; // D
    int64_t _859 = 0; // C
    _jump523:; // Begin body of loop
    double _860 = 88.0;
    _856 += _860;
    _857++;
    if (_857 < _744.d1)
    goto _jump523;
    _857 = 0;
    _858++;
    if (_858 < _642.d0)
    goto _jump523;
    _858 = 0;
    _859++;
    if (_859 < _795.d1)
    goto _jump523;
    // End body of loop
    double _861 = _855 + _856;
    double _862 = _850 * _861;
    _836 = _862;
    _jump515:;
    double _863 = _832 + _836;
    double _864 = -_863;
    double _865 = _826 * _864;
    _a3__a2__a1_int64_t _866;
    // Computing bound for E
    _866.d0 = _79.d1;
    if (_79.d1 > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    // Computing bound for F
    _866.d1 = _430.d2;
    if (_430.d2 > 0) 
    goto _jump660;
    fail_assertion("non-positive loop bound");
    _jump660:;
    // Computing bound for G
    int64_t _867 = -_795.d1;
    int64_t _868 = -_867;
    int64_t _869 = _868 + _795.d1;
    _866.d2 = _869;
    if (_869 > 0) 
    goto _jump661;
    fail_assertion("non-positive loop bound");
    _jump661:;
    // Computing total size of heap memory to allocate
    int64_t _870 = 1;
    _870 *= _79.d1;
    _870 *= _430.d2;
    _870 *= _869;
    _870 *= sizeof(_a2__a1_int64_t);
    _866.data = jpl_alloc(_870);
    int64_t _871 = 0; // G
    int64_t _872 = 0; // F
    int64_t _873 = 0; // E
    _jump662:; // Begin body of loop
    _a2__a1_int64_t _874;
    // Computing bound for H
    _874.d0 = _642.d2;
    if (_642.d2 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing bound for I
    _874.d1 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing total size of heap memory to allocate
    int64_t _875 = 1;
    _875 *= _642.d2;
    _875 *= _430.d0;
    _875 *= sizeof(_a1_int64_t);
    _874.data = jpl_alloc(_875);
    int64_t _876 = 0; // I
    int64_t _877 = 0; // H
    _jump665:; // Begin body of loop
    _a1_int64_t _878;
    // Computing bound for J
    _878.d0 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump666;
    fail_assertion("non-positive loop bound");
    _jump666:;
    // Computing total size of heap memory to allocate
    int64_t _879 = 1;
    _879 *= _79.d2;
    _879 *= sizeof(int64_t);
    _878.data = jpl_alloc(_879);
    int64_t _880 = 0; // J
    _jump667:; // Begin body of loop
    int64_t _881 = 0;
    _881 *= _878.d0;
    _881 += _880;
    _878.data[_881] = _507.d0;
    _880++;
    if (_880 < _79.d2)
    goto _jump667;
    // End body of loop
    int64_t _882 = 0;
    _882 *= _874.d0;
    _882 += _877;
    _882 *= _874.d1;
    _882 += _876;
    _874.data[_882] = _878;
    _876++;
    if (_876 < _430.d0)
    goto _jump665;
    _876 = 0;
    _877++;
    if (_877 < _642.d2)
    goto _jump665;
    // End body of loop
    _a2__a1_int64_t _883;
    // Computing bound for H
    _883.d0 = _873;
    if (_873 > 0) 
    goto _jump668;
    fail_assertion("non-positive loop bound");
    _jump668:;
    // Computing bound for I
    _883.d1 = _872;
    if (_872 > 0) 
    goto _jump669;
    fail_assertion("non-positive loop bound");
    _jump669:;
    // Computing total size of heap memory to allocate
    int64_t _884 = 1;
    _884 *= _873;
    _884 *= _872;
    _884 *= sizeof(_a1_int64_t);
    _883.data = jpl_alloc(_884);
    int64_t _885 = 0; // I
    int64_t _886 = 0; // H
    _jump670:; // Begin body of loop
    _a1_int64_t _887;
    _887.d0 = 1;
    _887.data = jpl_alloc(sizeof(int64_t) * 1);
    _887.data[0] = _744.d0;
    int64_t _888 = 0;
    _888 *= _883.d0;
    _888 += _886;
    _888 *= _883.d1;
    _888 += _885;
    _883.data[_888] = _887;
    _885++;
    if (_885 < _872)
    goto _jump670;
    _885 = 0;
    _886++;
    if (_886 < _873)
    goto _jump670;
    // End body of loop
    _a1__a2__a1_int64_t _889;
    _889.d0 = 2;
    _889.data = jpl_alloc(sizeof(_a2__a1_int64_t) * 2);
    _889.data[0] = _874;
    _889.data[1] = _883;
    _a3_int64_t _890;
    // Computing bound for H
    _890.d0 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    // Computing bound for I
    _890.d1 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump672;
    fail_assertion("non-positive loop bound");
    _jump672:;
    // Computing bound for J
    _890.d2 = _795.d1;
    if (_795.d1 > 0) 
    goto _jump673;
    fail_assertion("non-positive loop bound");
    _jump673:;
    // Computing total size of heap memory to allocate
    int64_t _891 = 1;
    _891 *= _642.d0;
    _891 *= _79.d2;
    _891 *= _795.d1;
    _891 *= sizeof(int64_t);
    _890.data = jpl_alloc(_891);
    int64_t _892 = 0; // J
    int64_t _893 = 0; // I
    int64_t _894 = 0; // H
    _jump674:; // Begin body of loop
    int64_t _895 = _642.d0 + _894;
    int64_t _896 = 0;
    _896 *= _890.d0;
    _896 += _894;
    _896 *= _890.d1;
    _896 += _893;
    _896 *= _890.d2;
    _896 += _892;
    _890.data[_896] = _895;
    _892++;
    if (_892 < _795.d1)
    goto _jump674;
    _892 = 0;
    _893++;
    if (_893 < _79.d2)
    goto _jump674;
    _893 = 0;
    _894++;
    if (_894 < _642.d0)
    goto _jump674;
    // End body of loop
    if (_507.d1 >= 0)
    goto _jump675;
    fail_assertion("negative array index");
    _jump675:;
    if (_507.d1 < _890.d0)
    goto _jump676;
    fail_assertion("index too large");
    _jump676:;
    if (_79.d1 >= 0)
    goto _jump677;
    fail_assertion("negative array index");
    _jump677:;
    if (_79.d1 < _890.d1)
    goto _jump678;
    fail_assertion("index too large");
    _jump678:;
    if (_871 >= 0)
    goto _jump679;
    fail_assertion("negative array index");
    _jump679:;
    if (_871 < _890.d2)
    goto _jump680;
    fail_assertion("index too large");
    _jump680:;
    int64_t _897 = 0;
    _897 *= _890.d0;
    _897 += _507.d1;
    _897 *= _890.d1;
    _897 += _79.d1;
    _897 *= _890.d2;
    _897 += _871;
    int64_t _898 = _890.data[_897];
    if (_898 >= 0)
    goto _jump681;
    fail_assertion("negative array index");
    _jump681:;
    if (_898 < _889.d0)
    goto _jump682;
    fail_assertion("index too large");
    _jump682:;
    int64_t _899 = 0;
    _899 *= _889.d0;
    _899 += _898;
    _a2__a1_int64_t _900 = _889.data[_899];
    int64_t _901 = 0;
    _901 *= _866.d0;
    _901 += _873;
    _901 *= _866.d1;
    _901 += _872;
    _901 *= _866.d2;
    _901 += _871;
    _866.data[_901] = _900;
    _871++;
    if (_871 < _869)
    goto _jump662;
    _871 = 0;
    _872++;
    if (_872 < _430.d2)
    goto _jump662;
    _872 = 0;
    _873++;
    if (_873 < _79.d1)
    goto _jump662;
    // End body of loop
    if (_507.d1 >= 0)
    goto _jump683;
    fail_assertion("negative array index");
    _jump683:;
    if (_507.d1 < _866.d0)
    goto _jump684;
    fail_assertion("index too large");
    _jump684:;
    if (_79.d2 >= 0)
    goto _jump685;
    fail_assertion("negative array index");
    _jump685:;
    if (_79.d2 < _866.d1)
    goto _jump686;
    fail_assertion("index too large");
    _jump686:;
    if (_79.d2 >= 0)
    goto _jump687;
    fail_assertion("negative array index");
    _jump687:;
    if (_79.d2 < _866.d2)
    goto _jump688;
    fail_assertion("index too large");
    _jump688:;
    int64_t _902 = 0;
    _902 *= _866.d0;
    _902 += _507.d1;
    _902 *= _866.d1;
    _902 += _79.d2;
    _902 *= _866.d2;
    _902 += _79.d2;
    _a2__a1_int64_t _903 = _866.data[_902];
    int64_t _904 = 618;
    if (_904 >= 0)
    goto _jump689;
    fail_assertion("negative array index");
    _jump689:;
    if (_904 < _903.d0)
    goto _jump690;
    fail_assertion("index too large");
    _jump690:;
    if (_507.d2 >= 0)
    goto _jump691;
    fail_assertion("negative array index");
    _jump691:;
    if (_507.d2 < _903.d1)
    goto _jump692;
    fail_assertion("index too large");
    _jump692:;
    int64_t _905 = 0;
    _905 *= _903.d0;
    _905 += _904;
    _905 *= _903.d1;
    _905 += _507.d2;
    _a1_int64_t _906 = _903.data[_905];
    _a3__a3_double _907;
    // Computing bound for H
    _907.d0 = _634.d1;
    if (_634.d1 > 0) 
    goto _jump982;
    fail_assertion("non-positive loop bound");
    _jump982:;
    // Computing bound for I
    _907.d1 = _634.d1;
    if (_634.d1 > 0) 
    goto _jump983;
    fail_assertion("non-positive loop bound");
    _jump983:;
    // Computing bound for J
    _907.d2 = _79.d1;
    if (_79.d1 > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing total size of heap memory to allocate
    int64_t _908 = 1;
    _908 *= _634.d1;
    _908 *= _634.d1;
    _908 *= _79.d1;
    _908 *= sizeof(_a3_double);
    _907.data = jpl_alloc(_908);
    int64_t _909 = 0; // J
    int64_t _910 = 0; // I
    int64_t _911 = 0; // H
    _jump985:; // Begin body of loop
    int64_t _912 = 0;
    _912 *= _907.d0;
    _912 += _911;
    _912 *= _907.d1;
    _912 += _910;
    _912 *= _907.d2;
    _912 += _909;
    _907.data[_912] = _79;
    _909++;
    if (_909 < _79.d1)
    goto _jump985;
    _909 = 0;
    _910++;
    if (_910 < _634.d1)
    goto _jump985;
    _910 = 0;
    _911++;
    if (_911 < _634.d1)
    goto _jump985;
    // End body of loop
    int64_t _913 = _642.d1 * _634.d1;
    bool _914 = _913 <= _642.d0;
    _a2_int64_t _915;
    if (!_914)
    goto _jump986;
    bool _916 = false;
    _a2_int64_t _917;
    if (!_916)
    goto _jump987;
    _a3__a2_int64_t _918;
    // Computing bound for H
    _918.d0 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump988;
    fail_assertion("non-positive loop bound");
    _jump988:;
    // Computing bound for I
    _918.d1 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump989;
    fail_assertion("non-positive loop bound");
    _jump989:;
    // Computing bound for J
    _918.d2 = _795.d0;
    if (_795.d0 > 0) 
    goto _jump990;
    fail_assertion("non-positive loop bound");
    _jump990:;
    // Computing total size of heap memory to allocate
    int64_t _919 = 1;
    _919 *= _79.d2;
    _919 *= _507.d1;
    _919 *= _795.d0;
    _919 *= sizeof(_a2_int64_t);
    _918.data = jpl_alloc(_919);
    int64_t _920 = 0; // J
    int64_t _921 = 0; // I
    int64_t _922 = 0; // H
    _jump991:; // Begin body of loop
    _a2_int64_t _923;
    // Computing bound for K
    _923.d0 = _922;
    if (_922 > 0) 
    goto _jump992;
    fail_assertion("non-positive loop bound");
    _jump992:;
    // Computing bound for L
    _923.d1 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump993;
    fail_assertion("non-positive loop bound");
    _jump993:;
    // Computing total size of heap memory to allocate
    int64_t _924 = 1;
    _924 *= _922;
    _924 *= _79.d0;
    _924 *= sizeof(int64_t);
    _923.data = jpl_alloc(_924);
    int64_t _925 = 0; // L
    int64_t _926 = 0; // K
    _jump994:; // Begin body of loop
    int64_t _927 = 0;
    _927 *= _923.d0;
    _927 += _926;
    _927 *= _923.d1;
    _927 += _925;
    _923.data[_927] = _926;
    _925++;
    if (_925 < _79.d0)
    goto _jump994;
    _925 = 0;
    _926++;
    if (_926 < _922)
    goto _jump994;
    // End body of loop
    int64_t _928 = 0;
    _928 *= _918.d0;
    _928 += _922;
    _928 *= _918.d1;
    _928 += _921;
    _928 *= _918.d2;
    _928 += _920;
    _918.data[_928] = _923;
    _920++;
    if (_920 < _795.d0)
    goto _jump991;
    _920 = 0;
    _921++;
    if (_921 < _507.d1)
    goto _jump991;
    _921 = 0;
    _922++;
    if (_922 < _79.d2)
    goto _jump991;
    // End body of loop
    if (_744.d1 >= 0)
    goto _jump995;
    fail_assertion("negative array index");
    _jump995:;
    if (_744.d1 < _918.d0)
    goto _jump996;
    fail_assertion("index too large");
    _jump996:;
    if (_430.d1 >= 0)
    goto _jump997;
    fail_assertion("negative array index");
    _jump997:;
    if (_430.d1 < _918.d1)
    goto _jump998;
    fail_assertion("index too large");
    _jump998:;
    if (_79.d1 >= 0)
    goto _jump999;
    fail_assertion("negative array index");
    _jump999:;
    if (_79.d1 < _918.d2)
    goto _jump1000;
    fail_assertion("index too large");
    _jump1000:;
    int64_t _929 = 0;
    _929 *= _918.d0;
    _929 += _744.d1;
    _929 *= _918.d1;
    _929 += _430.d1;
    _929 *= _918.d2;
    _929 += _79.d1;
    _a2_int64_t _930 = _918.data[_929];
    _917 = _930;
    goto _jump1001;
    _jump987:;
    bool _931 = _634.d0 != _79.d0;
    bool _932 = !_931;
    _a2_int64_t _933;
    if (!_932)
    goto _jump1002;
    _a2_int64_t _934;
    if (!_825)
    goto _jump1003;
    _a2_int64_t _935;
    // Computing bound for H
    _935.d0 = _507.d0;
    if (_507.d0 > 0) 
    goto _jump1004;
    fail_assertion("non-positive loop bound");
    _jump1004:;
    // Computing bound for I
    _935.d1 = _634.d0;
    if (_634.d0 > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing total size of heap memory to allocate
    int64_t _936 = 1;
    _936 *= _507.d0;
    _936 *= _634.d0;
    _936 *= sizeof(int64_t);
    _935.data = jpl_alloc(_936);
    int64_t _937 = 0; // I
    int64_t _938 = 0; // H
    _jump1006:; // Begin body of loop
    int64_t _939 = 0;
    _939 *= _935.d0;
    _939 += _938;
    _939 *= _935.d1;
    _939 += _937;
    _935.data[_939] = _634.d1;
    _937++;
    if (_937 < _634.d0)
    goto _jump1006;
    _937 = 0;
    _938++;
    if (_938 < _507.d0)
    goto _jump1006;
    // End body of loop
    _934 = _935;
    goto _jump1007;
    _jump1003:;
    _a2_int64_t _940;
    // Computing bound for H
    _940.d0 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    // Computing bound for I
    _940.d1 = _430.d1;
    if (_430.d1 > 0) 
    goto _jump1009;
    fail_assertion("non-positive loop bound");
    _jump1009:;
    // Computing total size of heap memory to allocate
    int64_t _941 = 1;
    _941 *= _507.d1;
    _941 *= _430.d1;
    _941 *= sizeof(int64_t);
    _940.data = jpl_alloc(_941);
    int64_t _942 = 0; // I
    int64_t _943 = 0; // H
    _jump1010:; // Begin body of loop
    int64_t _944 = 0;
    _944 *= _940.d0;
    _944 += _943;
    _944 *= _940.d1;
    _944 += _942;
    _940.data[_944] = _430.d1;
    _942++;
    if (_942 < _430.d1)
    goto _jump1010;
    _942 = 0;
    _943++;
    if (_943 < _507.d1)
    goto _jump1010;
    // End body of loop
    _934 = _940;
    _jump1007:;
    _933 = _934;
    goto _jump1011;
    _jump1002:;
    bool _945;
    if (!_825)
    goto _jump1012;
    _945 = _506;
    goto _jump1013;
    _jump1012:;
    _945 = _825;
    _jump1013:;
    _a2_int64_t _946;
    if (!_945)
    goto _jump1014;
    _a2_int64_t _947;
    // Computing bound for H
    _947.d0 = _634.d0;
    if (_634.d0 > 0) 
    goto _jump1015;
    fail_assertion("non-positive loop bound");
    _jump1015:;
    // Computing bound for I
    _947.d1 = _642.d1;
    if (_642.d1 > 0) 
    goto _jump1016;
    fail_assertion("non-positive loop bound");
    _jump1016:;
    // Computing total size of heap memory to allocate
    int64_t _948 = 1;
    _948 *= _634.d0;
    _948 *= _642.d1;
    _948 *= sizeof(int64_t);
    _947.data = jpl_alloc(_948);
    int64_t _949 = 0; // I
    int64_t _950 = 0; // H
    _jump1017:; // Begin body of loop
    int64_t _951 = 0;
    _951 *= _947.d0;
    _951 += _950;
    _951 *= _947.d1;
    _951 += _949;
    _947.data[_951] = _634.d0;
    _949++;
    if (_949 < _642.d1)
    goto _jump1017;
    _949 = 0;
    _950++;
    if (_950 < _634.d0)
    goto _jump1017;
    // End body of loop
    _946 = _947;
    goto _jump1018;
    _jump1014:;
    _a2_int64_t _952;
    // Computing bound for H
    _952.d0 = _430.d1;
    if (_430.d1 > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    // Computing bound for I
    _952.d1 = _642.d1;
    if (_642.d1 > 0) 
    goto _jump1020;
    fail_assertion("non-positive loop bound");
    _jump1020:;
    // Computing total size of heap memory to allocate
    int64_t _953 = 1;
    _953 *= _430.d1;
    _953 *= _642.d1;
    _953 *= sizeof(int64_t);
    _952.data = jpl_alloc(_953);
    int64_t _954 = 0; // I
    int64_t _955 = 0; // H
    _jump1021:; // Begin body of loop
    int64_t _956 = 0;
    _956 *= _952.d0;
    _956 += _955;
    _956 *= _952.d1;
    _956 += _954;
    _952.data[_956] = _642.d0;
    _954++;
    if (_954 < _642.d1)
    goto _jump1021;
    _954 = 0;
    _955++;
    if (_955 < _430.d1)
    goto _jump1021;
    // End body of loop
    _946 = _952;
    _jump1018:;
    _933 = _946;
    _jump1011:;
    _917 = _933;
    _jump1001:;
    _915 = _917;
    goto _jump1022;
    _jump986:;
    _a2_double _957;
    // Computing bound for H
    _957.d0 = _79.d1;
    if (_79.d1 > 0) 
    goto _jump1023;
    fail_assertion("non-positive loop bound");
    _jump1023:;
    // Computing bound for I
    _957.d1 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing total size of heap memory to allocate
    int64_t _958 = 1;
    _958 *= _79.d1;
    _958 *= _430.d0;
    _958 *= sizeof(double);
    _957.data = jpl_alloc(_958);
    int64_t _959 = 0; // I
    int64_t _960 = 0; // H
    _jump1025:; // Begin body of loop
    int64_t _961 = 0;
    _961 *= _957.d0;
    _961 += _960;
    _961 *= _957.d1;
    _961 += _959;
    _957.data[_961] = _865;
    _959++;
    if (_959 < _430.d0)
    goto _jump1025;
    _959 = 0;
    _960++;
    if (_960 < _79.d1)
    goto _jump1025;
    // End body of loop
    double _962 = D(_957, _430);
    bool _963 = _962 == _865;
    _a2_int64_t _964;
    if (!_963)
    goto _jump1026;
    _a2_int64_t _965;
    // Computing bound for H
    int64_t _966 = -_906.d0;
    _965.d0 = _966;
    if (_966 > 0) 
    goto _jump1027;
    fail_assertion("non-positive loop bound");
    _jump1027:;
    // Computing bound for I
    _965.d1 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing total size of heap memory to allocate
    int64_t _967 = 1;
    _967 *= _966;
    _967 *= _79.d0;
    _967 *= sizeof(int64_t);
    _965.data = jpl_alloc(_967);
    int64_t _968 = 0; // I
    int64_t _969 = 0; // H
    _jump1029:; // Begin body of loop
    int64_t _970 = 0;
    _970 *= _965.d0;
    _970 += _969;
    _970 *= _965.d1;
    _970 += _968;
    _965.data[_970] = _795.d0;
    _968++;
    if (_968 < _79.d0)
    goto _jump1029;
    _968 = 0;
    _969++;
    if (_969 < _966)
    goto _jump1029;
    // End body of loop
    _964 = _965;
    goto _jump1030;
    _jump1026:;
    _a2__a2_int64_t _971;
    // Computing bound for H
    _971.d0 = _906.d0;
    if (_906.d0 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    // Computing bound for I
    _971.d1 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump1032;
    fail_assertion("non-positive loop bound");
    _jump1032:;
    // Computing total size of heap memory to allocate
    int64_t _972 = 1;
    _972 *= _906.d0;
    _972 *= _79.d2;
    _972 *= sizeof(_a2_int64_t);
    _971.data = jpl_alloc(_972);
    int64_t _973 = 0; // I
    int64_t _974 = 0; // H
    _jump1033:; // Begin body of loop
    _a2_int64_t _975;
    // Computing bound for J
    _975.d0 = _906.d0;
    if (_906.d0 > 0) 
    goto _jump1034;
    fail_assertion("non-positive loop bound");
    _jump1034:;
    // Computing bound for K
    _975.d1 = _430.d2;
    if (_430.d2 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    // Computing total size of heap memory to allocate
    int64_t _976 = 1;
    _976 *= _906.d0;
    _976 *= _430.d2;
    _976 *= sizeof(int64_t);
    _975.data = jpl_alloc(_976);
    int64_t _977 = 0; // K
    int64_t _978 = 0; // J
    _jump1036:; // Begin body of loop
    int64_t _979 = 0;
    _979 *= _975.d0;
    _979 += _978;
    _979 *= _975.d1;
    _979 += _977;
    _975.data[_979] = _978;
    _977++;
    if (_977 < _430.d2)
    goto _jump1036;
    _977 = 0;
    _978++;
    if (_978 < _906.d0)
    goto _jump1036;
    // End body of loop
    int64_t _980 = 0;
    _980 *= _971.d0;
    _980 += _974;
    _980 *= _971.d1;
    _980 += _973;
    _971.data[_980] = _975;
    _973++;
    if (_973 < _79.d2)
    goto _jump1033;
    _973 = 0;
    _974++;
    if (_974 < _906.d0)
    goto _jump1033;
    // End body of loop
    if (_744.d1 >= 0)
    goto _jump1037;
    fail_assertion("negative array index");
    _jump1037:;
    if (_744.d1 < _971.d0)
    goto _jump1038;
    fail_assertion("index too large");
    _jump1038:;
    if (_79.d0 >= 0)
    goto _jump1039;
    fail_assertion("negative array index");
    _jump1039:;
    if (_79.d0 < _971.d1)
    goto _jump1040;
    fail_assertion("index too large");
    _jump1040:;
    int64_t _981 = 0;
    _981 *= _971.d0;
    _981 += _744.d1;
    _981 *= _971.d1;
    _981 += _79.d0;
    _a2_int64_t _982 = _971.data[_981];
    _964 = _982;
    _jump1030:;
    _915 = _964;
    _jump1022:;
    int64_t _983;
    // Computing bound for H
    if (_744.d1 > 0) 
    goto _jump1041;
    fail_assertion("non-positive loop bound");
    _jump1041:;
    _983 = 0;
    int64_t _984 = 0; // H
    _jump1042:; // Begin body of loop
    int64_t _985;
    // Computing bound for I
    if (_79.d1 > 0) 
    goto _jump1043;
    fail_assertion("non-positive loop bound");
    _jump1043:;
    // Computing bound for J
    int64_t _986;
    if (!_506)
    goto _jump1044;
    _986 = _984;
    goto _jump1045;
    _jump1044:;
    _986 = _642.d1;
    _jump1045:;
    if (_986 > 0) 
    goto _jump1046;
    fail_assertion("non-positive loop bound");
    _jump1046:;
    // Computing bound for K
    if (_79.d2 > 0) 
    goto _jump1047;
    fail_assertion("non-positive loop bound");
    _jump1047:;
    _985 = 0;
    int64_t _987 = 0; // K
    int64_t _988 = 0; // J
    int64_t _989 = 0; // I
    _jump1048:; // Begin body of loop
    _985 += _642.d2;
    _987++;
    if (_987 < _79.d2)
    goto _jump1048;
    _987 = 0;
    _988++;
    if (_988 < _986)
    goto _jump1048;
    _988 = 0;
    _989++;
    if (_989 < _79.d1)
    goto _jump1048;
    // End body of loop
    _983 += _985;
    _984++;
    if (_984 < _744.d1)
    goto _jump1042;
    // End body of loop
    if (_642.d1 >= 0)
    goto _jump1049;
    fail_assertion("negative array index");
    _jump1049:;
    if (_642.d1 < _915.d0)
    goto _jump1050;
    fail_assertion("index too large");
    _jump1050:;
    if (_983 >= 0)
    goto _jump1051;
    fail_assertion("negative array index");
    _jump1051:;
    if (_983 < _915.d1)
    goto _jump1052;
    fail_assertion("index too large");
    _jump1052:;
    int64_t _990 = 0;
    _990 *= _915.d0;
    _990 += _642.d1;
    _990 *= _915.d1;
    _990 += _983;
    int64_t _991 = _915.data[_990];
    if (_507.d0 >= 0)
    goto _jump1053;
    fail_assertion("negative array index");
    _jump1053:;
    if (_507.d0 < _907.d0)
    goto _jump1054;
    fail_assertion("index too large");
    _jump1054:;
    if (_79.d2 >= 0)
    goto _jump1055;
    fail_assertion("negative array index");
    _jump1055:;
    if (_79.d2 < _907.d1)
    goto _jump1056;
    fail_assertion("index too large");
    _jump1056:;
    if (_991 >= 0)
    goto _jump1057;
    fail_assertion("negative array index");
    _jump1057:;
    if (_991 < _907.d2)
    goto _jump1058;
    fail_assertion("index too large");
    _jump1058:;
    int64_t _992 = 0;
    _992 *= _907.d0;
    _992 += _507.d0;
    _992 *= _907.d1;
    _992 += _79.d2;
    _992 *= _907.d2;
    _992 += _991;
    _a3_double _993 = _907.data[_992];
    _a2__a2_bool _994;
    if (!_506)
    goto _jump1059;
    bool _995 = _506;
    if (0 != _506)
    goto _jump1060;
    bool _996 = !_825;
    bool _997 = !_996;
    _995 = _997;
    _jump1060:;
    _a2__a2_bool _998;
    if (!_995)
    goto _jump1061;
    bool _999 = _79.d1 <= _642.d2;
    bool _1000;
    if (!_999)
    goto _jump1062;
    bool _1001 = false;
    bool _1002 = !_1001;
    _1000 = _1002;
    goto _jump1063;
    _jump1062:;
    _1000 = _506;
    _jump1063:;
    bool _1003 = !_1000;
    _a2__a2_bool _1004;
    if (!_1003)
    goto _jump1064;
    _a2__a2_bool _1005;
    if (!_506)
    goto _jump1065;
    _a2__a2_bool _1006;
    // Computing bound for Q
    _1006.d0 = _430.d1;
    if (_430.d1 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    // Computing bound for R
    _1006.d1 = _634.d1;
    if (_634.d1 > 0) 
    goto _jump1067;
    fail_assertion("non-positive loop bound");
    _jump1067:;
    // Computing total size of heap memory to allocate
    int64_t _1007 = 1;
    _1007 *= _430.d1;
    _1007 *= _634.d1;
    _1007 *= sizeof(_a2_bool);
    _1006.data = jpl_alloc(_1007);
    int64_t _1008 = 0; // R
    int64_t _1009 = 0; // Q
    _jump1068:; // Begin body of loop
    int64_t _1010 = 0;
    _1010 *= _1006.d0;
    _1010 += _1009;
    _1010 *= _1006.d1;
    _1010 += _1008;
    _1006.data[_1010] = _795;
    _1008++;
    if (_1008 < _634.d1)
    goto _jump1068;
    _1008 = 0;
    _1009++;
    if (_1009 < _430.d1)
    goto _jump1068;
    // End body of loop
    _1005 = _1006;
    goto _jump1069;
    _jump1065:;
    _a2__a2_bool _1011;
    // Computing bound for Q
    _1011.d0 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump1070;
    fail_assertion("non-positive loop bound");
    _jump1070:;
    // Computing bound for R
    _1011.d1 = _795.d1;
    if (_795.d1 > 0) 
    goto _jump1071;
    fail_assertion("non-positive loop bound");
    _jump1071:;
    // Computing total size of heap memory to allocate
    int64_t _1012 = 1;
    _1012 *= _642.d0;
    _1012 *= _795.d1;
    _1012 *= sizeof(_a2_bool);
    _1011.data = jpl_alloc(_1012);
    int64_t _1013 = 0; // R
    int64_t _1014 = 0; // Q
    _jump1072:; // Begin body of loop
    _a2_bool _1015;
    // Computing bound for S
    _1015.d0 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump1073;
    fail_assertion("non-positive loop bound");
    _jump1073:;
    // Computing bound for T
    _1015.d1 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump1074;
    fail_assertion("non-positive loop bound");
    _jump1074:;
    // Computing total size of heap memory to allocate
    int64_t _1016 = 1;
    _1016 *= _79.d2;
    _1016 *= _642.d0;
    _1016 *= sizeof(bool);
    _1015.data = jpl_alloc(_1016);
    int64_t _1017 = 0; // T
    int64_t _1018 = 0; // S
    _jump1075:; // Begin body of loop
    int64_t _1019 = 0;
    _1019 *= _1015.d0;
    _1019 += _1018;
    _1019 *= _1015.d1;
    _1019 += _1017;
    _1015.data[_1019] = _506;
    _1017++;
    if (_1017 < _642.d0)
    goto _jump1075;
    _1017 = 0;
    _1018++;
    if (_1018 < _79.d2)
    goto _jump1075;
    // End body of loop
    int64_t _1020 = 0;
    _1020 *= _1011.d0;
    _1020 += _1014;
    _1020 *= _1011.d1;
    _1020 += _1013;
    _1011.data[_1020] = _1015;
    _1013++;
    if (_1013 < _795.d1)
    goto _jump1072;
    _1013 = 0;
    _1014++;
    if (_1014 < _642.d0)
    goto _jump1072;
    // End body of loop
    _1005 = _1011;
    _jump1069:;
    _1004 = _1005;
    goto _jump1076;
    _jump1064:;
    bool _1021 = _906.d0 <= _642.d0;
    _a2__a2_bool _1022;
    if (!_1021)
    goto _jump1077;
    bool _1023 = !_506;
    _a2__a2_bool _1024;
    if (!_1023)
    goto _jump1078;
    _a2__a2_bool _1025;
    // Computing bound for Q
    _1025.d0 = _430.d0;
    if (_430.d0 > 0) 
    goto _jump1079;
    fail_assertion("non-positive loop bound");
    _jump1079:;
    // Computing bound for R
    _1025.d1 = _795.d1;
    if (_795.d1 > 0) 
    goto _jump1080;
    fail_assertion("non-positive loop bound");
    _jump1080:;
    // Computing total size of heap memory to allocate
    int64_t _1026 = 1;
    _1026 *= _430.d0;
    _1026 *= _795.d1;
    _1026 *= sizeof(_a2_bool);
    _1025.data = jpl_alloc(_1026);
    int64_t _1027 = 0; // R
    int64_t _1028 = 0; // Q
    _jump1081:; // Begin body of loop
    int64_t _1029 = 0;
    _1029 *= _1025.d0;
    _1029 += _1028;
    _1029 *= _1025.d1;
    _1029 += _1027;
    _1025.data[_1029] = _634;
    _1027++;
    if (_1027 < _795.d1)
    goto _jump1081;
    _1027 = 0;
    _1028++;
    if (_1028 < _430.d0)
    goto _jump1081;
    // End body of loop
    _1024 = _1025;
    goto _jump1082;
    _jump1078:;
    _a2__a2_bool _1030;
    // Computing bound for Q
    _1030.d0 = _642.d2;
    if (_642.d2 > 0) 
    goto _jump1083;
    fail_assertion("non-positive loop bound");
    _jump1083:;
    // Computing bound for R
    _1030.d1 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump1084;
    fail_assertion("non-positive loop bound");
    _jump1084:;
    // Computing total size of heap memory to allocate
    int64_t _1031 = 1;
    _1031 *= _642.d2;
    _1031 *= _79.d0;
    _1031 *= sizeof(_a2_bool);
    _1030.data = jpl_alloc(_1031);
    int64_t _1032 = 0; // R
    int64_t _1033 = 0; // Q
    _jump1085:; // Begin body of loop
    int64_t _1034 = 0;
    _1034 *= _1030.d0;
    _1034 += _1033;
    _1034 *= _1030.d1;
    _1034 += _1032;
    _1030.data[_1034] = _634;
    _1032++;
    if (_1032 < _79.d0)
    goto _jump1085;
    _1032 = 0;
    _1033++;
    if (_1033 < _642.d2)
    goto _jump1085;
    // End body of loop
    _1024 = _1030;
    _jump1082:;
    _1022 = _1024;
    goto _jump1086;
    _jump1077:;
    bool _1035 = true;
    bool _1036 = !_1035;
    _a2__a2_bool _1037;
    if (!_1036)
    goto _jump1087;
    _a2__a2_bool _1038;
    // Computing bound for Q
    _1038.d0 = _507.d1;
    if (_507.d1 > 0) 
    goto _jump1088;
    fail_assertion("non-positive loop bound");
    _jump1088:;
    // Computing bound for R
    _1038.d1 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump1089;
    fail_assertion("non-positive loop bound");
    _jump1089:;
    // Computing total size of heap memory to allocate
    int64_t _1039 = 1;
    _1039 *= _507.d1;
    _1039 *= _79.d2;
    _1039 *= sizeof(_a2_bool);
    _1038.data = jpl_alloc(_1039);
    int64_t _1040 = 0; // R
    int64_t _1041 = 0; // Q
    _jump1090:; // Begin body of loop
    int64_t _1042 = 0;
    _1042 *= _1038.d0;
    _1042 += _1041;
    _1042 *= _1038.d1;
    _1042 += _1040;
    _1038.data[_1042] = _744;
    _1040++;
    if (_1040 < _79.d2)
    goto _jump1090;
    _1040 = 0;
    _1041++;
    if (_1041 < _507.d1)
    goto _jump1090;
    // End body of loop
    _1037 = _1038;
    goto _jump1091;
    _jump1087:;
    _a2__a2_bool _1043;
    // Computing bound for Q
    _1043.d0 = _906.d0;
    if (_906.d0 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing bound for R
    _1043.d1 = _642.d0;
    if (_642.d0 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing total size of heap memory to allocate
    int64_t _1044 = 1;
    _1044 *= _906.d0;
    _1044 *= _642.d0;
    _1044 *= sizeof(_a2_bool);
    _1043.data = jpl_alloc(_1044);
    int64_t _1045 = 0; // R
    int64_t _1046 = 0; // Q
    _jump1094:; // Begin body of loop
    int64_t _1047 = 0;
    _1047 *= _1043.d0;
    _1047 += _1046;
    _1047 *= _1043.d1;
    _1047 += _1045;
    _1043.data[_1047] = _795;
    _1045++;
    if (_1045 < _642.d0)
    goto _jump1094;
    _1045 = 0;
    _1046++;
    if (_1046 < _906.d0)
    goto _jump1094;
    // End body of loop
    _1037 = _1043;
    _jump1091:;
    _1022 = _1037;
    _jump1086:;
    _1004 = _1022;
    _jump1076:;
    _998 = _1004;
    goto _jump1095;
    _jump1061:;
    _a3__a2__a2_bool _1048;
    // Computing bound for Q
    _1048.d0 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump1096;
    fail_assertion("non-positive loop bound");
    _jump1096:;
    // Computing bound for R
    _1048.d1 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for S
    _1048.d2 = _634.d0;
    if (_634.d0 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    // Computing total size of heap memory to allocate
    int64_t _1049 = 1;
    _1049 *= _79.d2;
    _1049 *= _79.d2;
    _1049 *= _634.d0;
    _1049 *= sizeof(_a2__a2_bool);
    _1048.data = jpl_alloc(_1049);
    int64_t _1050 = 0; // S
    int64_t _1051 = 0; // R
    int64_t _1052 = 0; // Q
    _jump1099:; // Begin body of loop
    _a2__a2_bool _1053;
    // Computing bound for T
    _1053.d0 = _642.d2;
    if (_642.d2 > 0) 
    goto _jump1100;
    fail_assertion("non-positive loop bound");
    _jump1100:;
    // Computing bound for U
    _1053.d1 = _795.d1;
    if (_795.d1 > 0) 
    goto _jump1101;
    fail_assertion("non-positive loop bound");
    _jump1101:;
    // Computing total size of heap memory to allocate
    int64_t _1054 = 1;
    _1054 *= _642.d2;
    _1054 *= _795.d1;
    _1054 *= sizeof(_a2_bool);
    _1053.data = jpl_alloc(_1054);
    int64_t _1055 = 0; // U
    int64_t _1056 = 0; // T
    _jump1102:; // Begin body of loop
    int64_t _1057 = 0;
    _1057 *= _1053.d0;
    _1057 += _1056;
    _1057 *= _1053.d1;
    _1057 += _1055;
    _1053.data[_1057] = _744;
    _1055++;
    if (_1055 < _795.d1)
    goto _jump1102;
    _1055 = 0;
    _1056++;
    if (_1056 < _642.d2)
    goto _jump1102;
    // End body of loop
    int64_t _1058 = 0;
    _1058 *= _1048.d0;
    _1058 += _1052;
    _1058 *= _1048.d1;
    _1058 += _1051;
    _1058 *= _1048.d2;
    _1058 += _1050;
    _1048.data[_1058] = _1053;
    _1050++;
    if (_1050 < _634.d0)
    goto _jump1099;
    _1050 = 0;
    _1051++;
    if (_1051 < _79.d2)
    goto _jump1099;
    _1051 = 0;
    _1052++;
    if (_1052 < _79.d2)
    goto _jump1099;
    // End body of loop
    int64_t _1059;
    // Computing bound for Q
    if (_906.d0 > 0) 
    goto _jump1103;
    fail_assertion("non-positive loop bound");
    _jump1103:;
    // Computing bound for R
    int64_t _1060 = -_744.d0;
    if (_1060 > 0) 
    goto _jump1104;
    fail_assertion("non-positive loop bound");
    _jump1104:;
    _1059 = 0;
    int64_t _1061 = 0; // R
    int64_t _1062 = 0; // Q
    _jump1105:; // Begin body of loop
    _1059 += _993.d2;
    _1061++;
    if (_1061 < _1060)
    goto _jump1105;
    _1061 = 0;
    _1062++;
    if (_1062 < _906.d0)
    goto _jump1105;
    // End body of loop
    if (_79.d2 >= 0)
    goto _jump1106;
    fail_assertion("negative array index");
    _jump1106:;
    if (_79.d2 < _1048.d0)
    goto _jump1107;
    fail_assertion("index too large");
    _jump1107:;
    if (_795.d1 >= 0)
    goto _jump1108;
    fail_assertion("negative array index");
    _jump1108:;
    if (_795.d1 < _1048.d1)
    goto _jump1109;
    fail_assertion("index too large");
    _jump1109:;
    if (_1059 >= 0)
    goto _jump1110;
    fail_assertion("negative array index");
    _jump1110:;
    if (_1059 < _1048.d2)
    goto _jump1111;
    fail_assertion("index too large");
    _jump1111:;
    int64_t _1063 = 0;
    _1063 *= _1048.d0;
    _1063 += _79.d2;
    _1063 *= _1048.d1;
    _1063 += _795.d1;
    _1063 *= _1048.d2;
    _1063 += _1059;
    _a2__a2_bool _1064 = _1048.data[_1063];
    _998 = _1064;
    _jump1095:;
    _994 = _998;
    goto _jump1112;
    _jump1059:;
    bool _1065;
    if (!_506)
    goto _jump1113;
    _1065 = _506;
    goto _jump1114;
    _jump1113:;
    bool _1066 = _506;
    if (0 == _506)
    goto _jump1115;
    _1066 = _825;
    _jump1115:;
    bool _1067 = !_1066;
    _1065 = _1067;
    _jump1114:;
    _a2__a2_bool _1068;
    if (!_1065)
    goto _jump1116;
    _a2__a2_bool _1069;
    // Computing bound for Q
    int64_t _1070;
    if (!_506)
    goto _jump1117;
    _1070 = _642.d0;
    goto _jump1118;
    _jump1117:;
    _1070 = _430.d0;
    _jump1118:;
    _1069.d0 = _1070;
    if (_1070 > 0) 
    goto _jump1119;
    fail_assertion("non-positive loop bound");
    _jump1119:;
    // Computing bound for R
    _1069.d1 = _795.d1;
    if (_795.d1 > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing total size of heap memory to allocate
    int64_t _1071 = 1;
    _1071 *= _1070;
    _1071 *= _795.d1;
    _1071 *= sizeof(_a2_bool);
    _1069.data = jpl_alloc(_1071);
    int64_t _1072 = 0; // R
    int64_t _1073 = 0; // Q
    _jump1121:; // Begin body of loop
    _a2__a2_bool _1074;
    // Computing bound for S
    _1074.d0 = _993.d2;
    if (_993.d2 > 0) 
    goto _jump1122;
    fail_assertion("non-positive loop bound");
    _jump1122:;
    // Computing bound for T
    _1074.d1 = _993.d2;
    if (_993.d2 > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    // Computing total size of heap memory to allocate
    int64_t _1075 = 1;
    _1075 *= _993.d2;
    _1075 *= _993.d2;
    _1075 *= sizeof(_a2_bool);
    _1074.data = jpl_alloc(_1075);
    int64_t _1076 = 0; // T
    int64_t _1077 = 0; // S
    _jump1124:; // Begin body of loop
    int64_t _1078 = 0;
    _1078 *= _1074.d0;
    _1078 += _1077;
    _1078 *= _1074.d1;
    _1078 += _1076;
    _1074.data[_1078] = _744;
    _1076++;
    if (_1076 < _993.d2)
    goto _jump1124;
    _1076 = 0;
    _1077++;
    if (_1077 < _993.d2)
    goto _jump1124;
    // End body of loop
    if (_744.d0 >= 0)
    goto _jump1125;
    fail_assertion("negative array index");
    _jump1125:;
    if (_744.d0 < _1074.d0)
    goto _jump1126;
    fail_assertion("index too large");
    _jump1126:;
    if (_795.d0 >= 0)
    goto _jump1127;
    fail_assertion("negative array index");
    _jump1127:;
    if (_795.d0 < _1074.d1)
    goto _jump1128;
    fail_assertion("index too large");
    _jump1128:;
    int64_t _1079 = 0;
    _1079 *= _1074.d0;
    _1079 += _744.d0;
    _1079 *= _1074.d1;
    _1079 += _795.d0;
    _a2_bool _1080 = _1074.data[_1079];
    int64_t _1081 = 0;
    _1081 *= _1069.d0;
    _1081 += _1073;
    _1081 *= _1069.d1;
    _1081 += _1072;
    _1069.data[_1081] = _1080;
    _1072++;
    if (_1072 < _795.d1)
    goto _jump1121;
    _1072 = 0;
    _1073++;
    if (_1073 < _1070)
    goto _jump1121;
    // End body of loop
    _1068 = _1069;
    goto _jump1129;
    _jump1116:;
    _a2__a2_bool _1082;
    if (!_825)
    goto _jump1130;
    _a2__a2_bool _1083;
    if (!_506)
    goto _jump1131;
    _a2__a2_bool _1084;
    // Computing bound for Q
    _1084.d0 = _744.d0;
    if (_744.d0 > 0) 
    goto _jump1132;
    fail_assertion("non-positive loop bound");
    _jump1132:;
    // Computing bound for R
    _1084.d1 = _79.d2;
    if (_79.d2 > 0) 
    goto _jump1133;
    fail_assertion("non-positive loop bound");
    _jump1133:;
    // Computing total size of heap memory to allocate
    int64_t _1085 = 1;
    _1085 *= _744.d0;
    _1085 *= _79.d2;
    _1085 *= sizeof(_a2_bool);
    _1084.data = jpl_alloc(_1085);
    int64_t _1086 = 0; // R
    int64_t _1087 = 0; // Q
    _jump1134:; // Begin body of loop
    int64_t _1088 = 0;
    _1088 *= _1084.d0;
    _1088 += _1087;
    _1088 *= _1084.d1;
    _1088 += _1086;
    _1084.data[_1088] = _744;
    _1086++;
    if (_1086 < _79.d2)
    goto _jump1134;
    _1086 = 0;
    _1087++;
    if (_1087 < _744.d0)
    goto _jump1134;
    // End body of loop
    _1083 = _1084;
    goto _jump1135;
    _jump1131:;
    bool _1089 = true;
    _a2__a2_bool _1090;
    if (!_1089)
    goto _jump1136;
    _a2__a2_bool _1091;
    // Computing bound for Q
    _1091.d0 = _79.d0;
    if (_79.d0 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    // Computing bound for R
    int64_t _1092 = 456;
    _1091.d1 = _1092;
    if (_1092 > 0) 
    goto _jump1138;
    fail_assertion("non-positive loop bound");
    _jump1138:;
    // Computing total size of heap memory to allocate
    int64_t _1093 = 1;
    _1093 *= _79.d0;
    _1093 *= _1092;
    _1093 *= sizeof(_a2_bool);
    _1091.data = jpl_alloc(_1093);
    int64_t _1094 = 0; // R
    int64_t _1095 = 0; // Q
    _jump1139:; // Begin body of loop
    int64_t _1096 = 0;
    _1096 *= _1091.d0;
    _1096 += _1095;
    _1096 *= _1091.d1;
    _1096 += _1094;
    _1091.data[_1096] = _795;
    _1094++;
    if (_1094 < _1092)
    goto _jump1139;
    _1094 = 0;
    _1095++;
    if (_1095 < _79.d0)
    goto _jump1139;
    // End body of loop
    _1090 = _1091;
    goto _jump1140;
    _jump1136:;
    _a2__a2_bool _1097;
    // Computing bound for Q
    _1097.d0 = _430.d2;
    if (_430.d2 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    // Computing bound for R
    _1097.d1 = _993.d2;
    if (_993.d2 > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    // Computing total size of heap memory to allocate
    int64_t _1098 = 1;
    _1098 *= _430.d2;
    _1098 *= _993.d2;
    _1098 *= sizeof(_a2_bool);
    _1097.data = jpl_alloc(_1098);
    int64_t _1099 = 0; // R
    int64_t _1100 = 0; // Q
    _jump1143:; // Begin body of loop
    int64_t _1101 = 0;
    _1101 *= _1097.d0;
    _1101 += _1100;
    _1101 *= _1097.d1;
    _1101 += _1099;
    _1097.data[_1101] = _744;
    _1099++;
    if (_1099 < _993.d2)
    goto _jump1143;
    _1099 = 0;
    _1100++;
    if (_1100 < _430.d2)
    goto _jump1143;
    // End body of loop
    _1090 = _1097;
    _jump1140:;
    _1083 = _1090;
    _jump1135:;
    _1082 = _1083;
    goto _jump1144;
    _jump1130:;
    _a2__a2_bool _1102;
    // Computing bound for Q
    _1102.d0 = _993.d1;
    if (_993.d1 > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing bound for R
    _1102.d1 = _634.d1;
    if (_634.d1 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing total size of heap memory to allocate
    int64_t _1103 = 1;
    _1103 *= _993.d1;
    _1103 *= _634.d1;
    _1103 *= sizeof(_a2_bool);
    _1102.data = jpl_alloc(_1103);
    int64_t _1104 = 0; // R
    int64_t _1105 = 0; // Q
    _jump1147:; // Begin body of loop
    int64_t _1106 = 0;
    _1106 *= _1102.d0;
    _1106 += _1105;
    _1106 *= _1102.d1;
    _1106 += _1104;
    _1102.data[_1106] = _795;
    _1104++;
    if (_1104 < _634.d1)
    goto _jump1147;
    _1104 = 0;
    _1105++;
    if (_1105 < _993.d1)
    goto _jump1147;
    // End body of loop
    _1082 = _1102;
    _jump1144:;
    _1068 = _1082;
    _jump1129:;
    _994 = _1068;
    _jump1112:;
    if (_79.d2 >= 0)
    goto _jump1148;
    fail_assertion("negative array index");
    _jump1148:;
    if (_79.d2 < _994.d0)
    goto _jump1149;
    fail_assertion("index too large");
    _jump1149:;
    if (_795.d0 >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (_795.d0 < _994.d1)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _1107 = 0;
    _1107 *= _994.d0;
    _1107 += _79.d2;
    _1107 *= _994.d1;
    _1107 += _795.d0;
    _a2_bool _1108 = _994.data[_1107];
    if (0 != _506)
    goto _jump1302;
    fail_assertion("W");
    _jump1302:;
}

