
#include <math.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include "rt/runtime.h"

typedef struct { } void_t;

typedef struct {
  int64_t d0;
  double *data;
} _a1_double;

typedef struct {
  int64_t d0;
  bool *data;
} _a1_bool;

typedef struct {
    void_t a;
    double b;
} a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t *data;
} _a2_int64_t;

typedef struct {
  int64_t d0;
  int64_t *data;
} _a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  double *data;
} _a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  rgba *data;
} _a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  bool *data;
} _a2_bool;

typedef struct {
  int64_t d0;
  _a1_bool *data;
} _a1__a1_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  bool *data;
} _a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_bool *data;
} _a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  int64_t *data;
} _a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  double *data;
} _a3_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_bool *data;
} _a3__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_int64_t *data;
} _a3__a2_int64_t;

typedef struct {
  int64_t d0;
  _a3_bool *data;
} _a1__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2__a3_bool *data;
} _a3__a2__a3_bool;

typedef struct {
  int64_t d0;
  int64_t d1;
  a *data;
} _a2_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_a *data;
} _a3__a2_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2_a *data;
} _a2__a2_a;

typedef struct {
  int64_t d0;
  rgba *data;
} _a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1_rgba *data;
} _a2__a1_rgba;

typedef struct {
  int64_t d0;
  _a2__a1_rgba *data;
} _a1__a2__a1_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  void_t *data;
} _a3_void_t;

typedef struct {
  int64_t d0;
  _a3_void_t *data;
} _a1__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a3_void_t *data;
} _a3__a1__a3_void_t;

typedef struct {
  int64_t d0;
  _a1_int64_t *data;
} _a1__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1__a1_int64_t *data;
} _a3__a1__a1_int64_t;

typedef struct {
  int64_t d0;
  _a2_bool *data;
} _a1__a2_bool;

typedef struct {
  int64_t d0;
  a *data;
} _a1_a;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a2_double *data;
} _a3__a2_double;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_int64_t *data;
} _a3__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_void_t *data;
} _a3__a3_void_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a1_int64_t *data;
} _a3__a1_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3__a1_int64_t *data;
} _a3__a3__a1_int64_t;

typedef struct {
  int64_t d0;
  _a3_int64_t *data;
} _a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  int64_t d2;
  _a3_rgba *data;
} _a3__a3_rgba;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a1__a3_int64_t *data;
} _a2__a1__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a3_int64_t *data;
} _a2__a3_int64_t;

typedef struct {
  int64_t d0;
  int64_t d1;
  _a2__a3_int64_t *data;
} _a2__a2__a3_int64_t;

_a2_double f(_a3_rgba g) {
    _a1_bool _0;
    // Computing bound for k
    int64_t _1 = 779;
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump127;
    fail_assertion("non-positive loop bound");
    _jump127:;
    // Computing total size of heap memory to allocate
    int64_t _2 = 1;
    _2 *= _1;
    _2 *= sizeof(bool);
    _0.data = jpl_alloc(_2);
    int64_t _3 = 0; // k
    _jump128:; // Begin body of loop
    _a2_bool _4;
    // Computing bound for l
    int64_t _5;
    // Computing bound for l
    int64_t _6 = 617;
    if (_6 > 0) 
    goto _jump129;
    fail_assertion("non-positive loop bound");
    _jump129:;
    // Computing bound for m
    if (g.d1 > 0) 
    goto _jump130;
    fail_assertion("non-positive loop bound");
    _jump130:;
    _5 = 0;
    int64_t _7 = 0; // m
    int64_t _8 = 0; // l
    _jump131:; // Begin body of loop
    _5 += _7;
    _7++;
    if (_7 < g.d1)
    goto _jump131;
    _7 = 0;
    _8++;
    if (_8 < _6)
    goto _jump131;
    // End body of loop
    _4.d0 = _5;
    if (_5 > 0) 
    goto _jump132;
    fail_assertion("non-positive loop bound");
    _jump132:;
    // Computing bound for m
    int64_t _9 = 70;
    int64_t _10 = g.d0 - _9;
    _4.d1 = _10;
    if (_10 > 0) 
    goto _jump133;
    fail_assertion("non-positive loop bound");
    _jump133:;
    // Computing total size of heap memory to allocate
    int64_t _11 = 1;
    _11 *= _5;
    _11 *= _10;
    _11 *= sizeof(bool);
    _4.data = jpl_alloc(_11);
    int64_t _12 = 0; // m
    int64_t _13 = 0; // l
    _jump134:; // Begin body of loop
    bool _14 = _13 != _3;
    int64_t _15 = 0;
    _15 *= _4.d0;
    _15 += _13;
    _15 *= _4.d1;
    _15 += _12;
    _4.data[_15] = _14;
    _12++;
    if (_12 < _10)
    goto _jump134;
    _12 = 0;
    _13++;
    if (_13 < _5)
    goto _jump134;
    // End body of loop
    int64_t _16 = -g.d1;
    if (_16 >= 0)
    goto _jump135;
    fail_assertion("negative array index");
    _jump135:;
    if (_16 < _4.d0)
    goto _jump136;
    fail_assertion("index too large");
    _jump136:;
    if (_3 >= 0)
    goto _jump137;
    fail_assertion("negative array index");
    _jump137:;
    if (_3 < _4.d1)
    goto _jump138;
    fail_assertion("index too large");
    _jump138:;
    int64_t _17 = 0;
    _17 *= _4.d0;
    _17 += _16;
    _17 *= _4.d1;
    _17 += _3;
    bool _18 = _4.data[_17];
    bool _19 = !_18;
    bool _20 = !_19;
    bool _21 = !_20;
    int64_t _22 = 0;
    _22 *= _0.d0;
    _22 += _3;
    _0.data[_22] = _21;
    _3++;
    if (_3 < _1)
    goto _jump128;
    // End body of loop
    _a1_bool _23;
    // Computing bound for m
    _23.d0 = c;
    if (c > 0) 
    goto _jump139;
    fail_assertion("non-positive loop bound");
    _jump139:;
    // Computing total size of heap memory to allocate
    int64_t _24 = 1;
    _24 *= c;
    _24 *= sizeof(bool);
    _23.data = jpl_alloc(_24);
    int64_t _25 = 0; // m
    _jump140:; // Begin body of loop
    int64_t _26;
    // Computing bound for n
    if (c > 0) 
    goto _jump141;
    fail_assertion("non-positive loop bound");
    _jump141:;
    // Computing bound for o
    if (g.d1 > 0) 
    goto _jump142;
    fail_assertion("non-positive loop bound");
    _jump142:;
    _26 = 0;
    int64_t _27 = 0; // o
    int64_t _28 = 0; // n
    _jump143:; // Begin body of loop
    _26 += g.d0;
    _27++;
    if (_27 < g.d1)
    goto _jump143;
    _27 = 0;
    _28++;
    if (_28 < c)
    goto _jump143;
    // End body of loop
    bool _29 = _26 <= g.d2;
    bool _30 = !_29;
    int64_t _31 = 0;
    _31 *= _23.d0;
    _31 += _25;
    _23.data[_31] = _30;
    _25++;
    if (_25 < c)
    goto _jump140;
    // End body of loop
    int64_t _32 = g.d2 + g.d0;
    int64_t _33 = g.d2 + d;
    bool _34 = _32 >= _33;
    _a1_bool _35;
    if (!_34)
    goto _jump144;
    _a1_bool _36;
    // Computing bound for m
    _36.d0 = d;
    if (d > 0) 
    goto _jump145;
    fail_assertion("non-positive loop bound");
    _jump145:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= d;
    _37 *= sizeof(bool);
    _36.data = jpl_alloc(_37);
    int64_t _38 = 0; // m
    _jump146:; // Begin body of loop
    bool _39 = g.d0 != d;
    int64_t _40 = 0;
    _40 *= _36.d0;
    _40 += _38;
    _36.data[_40] = _39;
    _38++;
    if (_38 < d)
    goto _jump146;
    // End body of loop
    _35 = _36;
    goto _jump147;
    _jump144:;
    bool _41 = true;
    _a1_bool _42;
    _42.d0 = 1;
    _42.data = jpl_alloc(sizeof(bool) * 1);
    _42.data[0] = _41;
    _35 = _42;
    _jump147:;
    _a1__a1_bool _43;
    _43.d0 = 3;
    _43.data = jpl_alloc(sizeof(_a1_bool) * 3);
    _43.data[0] = _23;
    _43.data[1] = _35;
    _43.data[2] = _0;
    bool _44 = true;
    bool _45;
    if (!_44)
    goto _jump148;
    int64_t _46 = 256;
    int64_t _47 = 469;
    bool _48 = _46 <= _47;
    bool _49 = true;
    bool _50 = _48 != _49;
    _45 = _50;
    goto _jump149;
    _jump148:;
    int64_t _51 = 20;
    bool _52 = d >= _51;
    if (c >= 0)
    goto _jump150;
    fail_assertion("negative array index");
    _jump150:;
    if (c < _0.d0)
    goto _jump151;
    fail_assertion("index too large");
    _jump151:;
    int64_t _53 = 0;
    _53 *= _0.d0;
    _53 += c;
    bool _54 = _0.data[_53];
    bool _55 = _52 != _54;
    _45 = _55;
    _jump149:;
    _a1_int64_t _56;
    if (!_45)
    goto _jump152;
    double _57 = 73.0;
    double _58 = 86.0;
    bool _59 = _57 >= _58;
    bool _60 = false;
    bool _61 = _59 == _60;
    _a1_int64_t _62;
    if (!_61)
    goto _jump153;
    _a1_int64_t _63;
    // Computing bound for m
    int64_t _64 = -_0.d0;
    _63.d0 = _64;
    if (_64 > 0) 
    goto _jump154;
    fail_assertion("non-positive loop bound");
    _jump154:;
    // Computing total size of heap memory to allocate
    int64_t _65 = 1;
    _65 *= _64;
    _65 *= sizeof(int64_t);
    _63.data = jpl_alloc(_65);
    int64_t _66 = 0; // m
    _jump155:; // Begin body of loop
    int64_t _67 = 0;
    _67 *= _63.d0;
    _67 += _66;
    _63.data[_67] = g.d0;
    _66++;
    if (_66 < _64)
    goto _jump155;
    // End body of loop
    _62 = _63;
    goto _jump156;
    _jump153:;
    if (g.d1 >= 0)
    goto _jump157;
    fail_assertion("negative array index");
    _jump157:;
    if (g.d1 < b.d0)
    goto _jump158;
    fail_assertion("index too large");
    _jump158:;
    if (c >= 0)
    goto _jump159;
    fail_assertion("negative array index");
    _jump159:;
    if (c < b.d1)
    goto _jump160;
    fail_assertion("index too large");
    _jump160:;
    int64_t _68 = 0;
    _68 *= b.d0;
    _68 += g.d1;
    _68 *= b.d1;
    _68 += c;
    int64_t _69 = b.data[_68];
    int64_t _70 = -c;
    _a1_int64_t _71;
    _71.d0 = 2;
    _71.data = jpl_alloc(sizeof(int64_t) * 2);
    _71.data[0] = _69;
    _71.data[1] = _70;
    _62 = _71;
    _jump156:;
    _56 = _62;
    goto _jump161;
    _jump152:;
    int64_t _72 = g.d2 * g.d2;
    int64_t _73;
    // Computing bound for m
    int64_t _74 = 375;
    if (_74 > 0) 
    goto _jump162;
    fail_assertion("non-positive loop bound");
    _jump162:;
    _73 = 0;
    int64_t _75 = 0; // m
    _jump163:; // Begin body of loop
    int64_t _76;
    // Computing bound for n
    int64_t _77 = 439;
    if (_77 > 0) 
    goto _jump164;
    fail_assertion("non-positive loop bound");
    _jump164:;
    // Computing bound for o
    int64_t _78 = 581;
    if (_78 > 0) 
    goto _jump165;
    fail_assertion("non-positive loop bound");
    _jump165:;
    _76 = 0;
    int64_t _79 = 0; // o
    int64_t _80 = 0; // n
    _jump166:; // Begin body of loop
    _76 += _79;
    _79++;
    if (_79 < _78)
    goto _jump166;
    _79 = 0;
    _80++;
    if (_80 < _77)
    goto _jump166;
    // End body of loop
    _73 += _76;
    _75++;
    if (_75 < _74)
    goto _jump163;
    // End body of loop
    _a1_int64_t _81;
    _81.d0 = 3;
    _81.data = jpl_alloc(sizeof(int64_t) * 3);
    _81.data[0] = _0.d0;
    _81.data[1] = _72;
    _81.data[2] = _73;
    _56 = _81;
    _jump161:;
    if (g.d1 >= 0)
    goto _jump167;
    fail_assertion("negative array index");
    _jump167:;
    if (g.d1 < _56.d0)
    goto _jump168;
    fail_assertion("index too large");
    _jump168:;
    int64_t _82 = 0;
    _82 *= _56.d0;
    _82 += g.d1;
    int64_t _83 = _56.data[_82];
    if (_83 >= 0)
    goto _jump169;
    fail_assertion("negative array index");
    _jump169:;
    if (_83 < _43.d0)
    goto _jump170;
    fail_assertion("index too large");
    _jump170:;
    int64_t _84 = 0;
    _84 *= _43.d0;
    _84 += _83;
    _a1_bool _85 = _43.data[_84];
    int64_t _86 = -g.d1;
    int64_t _87 = _86 / g.d1;
    if (_87 >= 0)
    goto _jump171;
    fail_assertion("negative array index");
    _jump171:;
    if (_87 < _85.d0)
    goto _jump172;
    fail_assertion("index too large");
    _jump172:;
    int64_t _88 = 0;
    _88 *= _85.d0;
    _88 += _87;
    bool _89 = _85.data[_88];
    if (0 != _89)
    goto _jump173;
    fail_assertion("m");
    _jump173:;
    _a2_int64_t _90;
    // Computing bound for m
    _90.d0 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump174;
    fail_assertion("non-positive loop bound");
    _jump174:;
    // Computing bound for n
    int64_t _91;
    // Computing bound for m
    if (c > 0) 
    goto _jump175;
    fail_assertion("non-positive loop bound");
    _jump175:;
    // Computing bound for n
    int64_t _92 = g.d0 / _0.d0;
    int64_t _93 = _92 * g.d0;
    int64_t _94 = g.d0 * _93;
    if (_94 > 0) 
    goto _jump176;
    fail_assertion("non-positive loop bound");
    _jump176:;
    _91 = 0;
    int64_t _95 = 0; // n
    int64_t _96 = 0; // m
    _jump177:; // Begin body of loop
    int64_t _97;
    // Computing bound for o
    if (_95 > 0) 
    goto _jump178;
    fail_assertion("non-positive loop bound");
    _jump178:;
    _97 = 0;
    int64_t _98 = 0; // o
    _jump179:; // Begin body of loop
    bool _99 = true;
    int64_t _100;
    if (!_99)
    goto _jump180;
    _100 = g.d1;
    goto _jump181;
    _jump180:;
    _100 = _95;
    _jump181:;
    _97 += _100;
    _98++;
    if (_98 < _95)
    goto _jump179;
    // End body of loop
    _91 += _97;
    _95++;
    if (_95 < _94)
    goto _jump177;
    _95 = 0;
    _96++;
    if (_96 < c)
    goto _jump177;
    // End body of loop
    _90.d1 = _91;
    if (_91 > 0) 
    goto _jump182;
    fail_assertion("non-positive loop bound");
    _jump182:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _0.d0;
    _101 *= _91;
    _101 *= sizeof(int64_t);
    _90.data = jpl_alloc(_101);
    int64_t _102 = 0; // n
    int64_t _103 = 0; // m
    _jump183:; // Begin body of loop
    int64_t _104 = 606;
    int64_t _105 = 0;
    _105 *= _90.d0;
    _105 += _103;
    _105 *= _90.d1;
    _105 += _102;
    _90.data[_105] = _104;
    _102++;
    if (_102 < _91)
    goto _jump183;
    _102 = 0;
    _103++;
    if (_103 < _0.d0)
    goto _jump183;
    // End body of loop
    _a2_bool _106;
    // Computing bound for p
    _106.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump184;
    fail_assertion("non-positive loop bound");
    _jump184:;
    // Computing bound for q
    int64_t _107;
    // Computing bound for p
    if (_90.d0 > 0) 
    goto _jump185;
    fail_assertion("non-positive loop bound");
    _jump185:;
    // Computing bound for q
    if (g.d0 > 0) 
    goto _jump186;
    fail_assertion("non-positive loop bound");
    _jump186:;
    _107 = 0;
    int64_t _108 = 0; // q
    int64_t _109 = 0; // p
    _jump187:; // Begin body of loop
    _107 += _108;
    _108++;
    if (_108 < g.d0)
    goto _jump187;
    _108 = 0;
    _109++;
    if (_109 < _90.d0)
    goto _jump187;
    // End body of loop
    bool _110 = _90.d0 <= _107;
    int64_t _111;
    if (!_110)
    goto _jump188;
    _111 = c;
    goto _jump189;
    _jump188:;
    int64_t _112;
    // Computing bound for p
    if (g.d1 > 0) 
    goto _jump190;
    fail_assertion("non-positive loop bound");
    _jump190:;
    // Computing bound for q
    int64_t _113 = 480;
    if (_113 > 0) 
    goto _jump191;
    fail_assertion("non-positive loop bound");
    _jump191:;
    // Computing bound for r
    if (_0.d0 > 0) 
    goto _jump192;
    fail_assertion("non-positive loop bound");
    _jump192:;
    _112 = 0;
    int64_t _114 = 0; // r
    int64_t _115 = 0; // q
    int64_t _116 = 0; // p
    _jump193:; // Begin body of loop
    int64_t _117;
    // Computing bound for s
    if (d > 0) 
    goto _jump194;
    fail_assertion("non-positive loop bound");
    _jump194:;
    // Computing bound for t
    if (_90.d1 > 0) 
    goto _jump195;
    fail_assertion("non-positive loop bound");
    _jump195:;
    _117 = 0;
    int64_t _118 = 0; // t
    int64_t _119 = 0; // s
    _jump196:; // Begin body of loop
    _117 += _90.d1;
    _118++;
    if (_118 < _90.d1)
    goto _jump196;
    _118 = 0;
    _119++;
    if (_119 < d)
    goto _jump196;
    // End body of loop
    _112 += _117;
    _114++;
    if (_114 < _0.d0)
    goto _jump193;
    _114 = 0;
    _115++;
    if (_115 < _113)
    goto _jump193;
    _115 = 0;
    _116++;
    if (_116 < g.d1)
    goto _jump193;
    // End body of loop
    _111 = _112;
    _jump189:;
    int64_t _120 = -_111;
    _106.d1 = _120;
    if (_120 > 0) 
    goto _jump197;
    fail_assertion("non-positive loop bound");
    _jump197:;
    // Computing total size of heap memory to allocate
    int64_t _121 = 1;
    _121 *= g.d1;
    _121 *= _120;
    _121 *= sizeof(bool);
    _106.data = jpl_alloc(_121);
    int64_t _122 = 0; // q
    int64_t _123 = 0; // p
    _jump198:; // Begin body of loop
    int64_t _124 = -_90.d0;
    int64_t _125;
    // Computing bound for r
    if (_0.d0 > 0) 
    goto _jump199;
    fail_assertion("non-positive loop bound");
    _jump199:;
    _125 = 0;
    int64_t _126 = 0; // r
    _jump200:; // Begin body of loop
    _125 += g.d0;
    _126++;
    if (_126 < _0.d0)
    goto _jump200;
    // End body of loop
    int64_t _127;
    // Computing bound for r
    if (_90.d1 > 0) 
    goto _jump201;
    fail_assertion("non-positive loop bound");
    _jump201:;
    // Computing bound for s
    if (_0.d0 > 0) 
    goto _jump202;
    fail_assertion("non-positive loop bound");
    _jump202:;
    _127 = 0;
    int64_t _128 = 0; // s
    int64_t _129 = 0; // r
    _jump203:; // Begin body of loop
    _127 += g.d2;
    _128++;
    if (_128 < _0.d0)
    goto _jump203;
    _128 = 0;
    _129++;
    if (_129 < _90.d1)
    goto _jump203;
    // End body of loop
    if (_125 >= 0)
    goto _jump204;
    fail_assertion("negative array index");
    _jump204:;
    if (_125 < b.d0)
    goto _jump205;
    fail_assertion("index too large");
    _jump205:;
    if (_127 >= 0)
    goto _jump206;
    fail_assertion("negative array index");
    _jump206:;
    if (_127 < b.d1)
    goto _jump207;
    fail_assertion("index too large");
    _jump207:;
    int64_t _130 = 0;
    _130 *= b.d0;
    _130 += _125;
    _130 *= b.d1;
    _130 += _127;
    int64_t _131 = b.data[_130];
    bool _132 = _124 == _131;
    int64_t _133 = 0;
    _133 *= _106.d0;
    _133 += _123;
    _133 *= _106.d1;
    _133 += _122;
    _106.data[_133] = _132;
    _122++;
    if (_122 < _120)
    goto _jump198;
    _122 = 0;
    _123++;
    if (_123 < g.d1)
    goto _jump198;
    // End body of loop
    if (_90.d1 >= 0)
    goto _jump208;
    fail_assertion("negative array index");
    _jump208:;
    if (_90.d1 < _106.d0)
    goto _jump209;
    fail_assertion("index too large");
    _jump209:;
    if (_0.d0 >= 0)
    goto _jump210;
    fail_assertion("negative array index");
    _jump210:;
    if (_0.d0 < _106.d1)
    goto _jump211;
    fail_assertion("index too large");
    _jump211:;
    int64_t _134 = 0;
    _134 *= _106.d0;
    _134 += _90.d1;
    _134 *= _106.d1;
    _134 += _0.d0;
    bool _135 = _106.data[_134];
    bool _136;
    if (!_135)
    goto _jump212;
    bool _139 = false;
    bool _140 = !_139;
    bool _138 = _140;
    if (0 != _140)
    goto _jump213;
    bool _141 = true;
    _138 = _141;
    _jump213:;
    bool _142 = !_138;
    bool _137 = _142;
    if (0 != _142)
    goto _jump214;
    bool _143 = d == c;
    bool _144 = true;
    bool _145;
    if (!_144)
    goto _jump215;
    bool _146 = _90.d0 > g.d0;
    _145 = _146;
    goto _jump216;
    _jump215:;
    bool _147 = true;
    _145 = _147;
    _jump216:;
    bool _148 = _143 == _145;
    _137 = _148;
    _jump214:;
    bool _149 = !_137;
    bool _150;
    if (!_149)
    goto _jump217;
    _a2__a3_bool _151;
    // Computing bound for p
    _151.d0 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump218;
    fail_assertion("non-positive loop bound");
    _jump218:;
    // Computing bound for q
    _a1_int64_t _152;
    // Computing bound for p
    _152.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump219;
    fail_assertion("non-positive loop bound");
    _jump219:;
    // Computing total size of heap memory to allocate
    int64_t _153 = 1;
    _153 *= g.d0;
    _153 *= sizeof(int64_t);
    _152.data = jpl_alloc(_153);
    int64_t _154 = 0; // p
    _jump220:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _152.d0;
    _155 += _154;
    _152.data[_155] = _154;
    _154++;
    if (_154 < g.d0)
    goto _jump220;
    // End body of loop
    int64_t _156 = 314;
    if (_156 >= 0)
    goto _jump221;
    fail_assertion("negative array index");
    _jump221:;
    if (_156 < _152.d0)
    goto _jump222;
    fail_assertion("index too large");
    _jump222:;
    int64_t _157 = 0;
    _157 *= _152.d0;
    _157 += _156;
    int64_t _158 = _152.data[_157];
    _151.d1 = _158;
    if (_158 > 0) 
    goto _jump223;
    fail_assertion("non-positive loop bound");
    _jump223:;
    // Computing total size of heap memory to allocate
    int64_t _159 = 1;
    _159 *= _90.d0;
    _159 *= _158;
    _159 *= sizeof(_a3_bool);
    _151.data = jpl_alloc(_159);
    int64_t _160 = 0; // q
    int64_t _161 = 0; // p
    _jump224:; // Begin body of loop
    _a3_bool _162;
    // Computing bound for r
    _162.d0 = _160;
    if (_160 > 0) 
    goto _jump225;
    fail_assertion("non-positive loop bound");
    _jump225:;
    // Computing bound for s
    _162.d1 = g.d1;
    if (g.d1 > 0) 
    goto _jump226;
    fail_assertion("non-positive loop bound");
    _jump226:;
    // Computing bound for t
    _162.d2 = g.d0;
    if (g.d0 > 0) 
    goto _jump227;
    fail_assertion("non-positive loop bound");
    _jump227:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= _160;
    _163 *= g.d1;
    _163 *= g.d0;
    _163 *= sizeof(bool);
    _162.data = jpl_alloc(_163);
    int64_t _164 = 0; // t
    int64_t _165 = 0; // s
    int64_t _166 = 0; // r
    _jump228:; // Begin body of loop
    bool _167 = true;
    int64_t _168 = 0;
    _168 *= _162.d0;
    _168 += _166;
    _168 *= _162.d1;
    _168 += _165;
    _168 *= _162.d2;
    _168 += _164;
    _162.data[_168] = _167;
    _164++;
    if (_164 < g.d0)
    goto _jump228;
    _164 = 0;
    _165++;
    if (_165 < g.d1)
    goto _jump228;
    _165 = 0;
    _166++;
    if (_166 < _160)
    goto _jump228;
    // End body of loop
    int64_t _169 = 0;
    _169 *= _151.d0;
    _169 += _161;
    _169 *= _151.d1;
    _169 += _160;
    _151.data[_169] = _162;
    _160++;
    if (_160 < _158)
    goto _jump224;
    _160 = 0;
    _161++;
    if (_161 < _90.d0)
    goto _jump224;
    // End body of loop
    _a3_int64_t _170;
    // Computing bound for p
    _170.d0 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump229;
    fail_assertion("non-positive loop bound");
    _jump229:;
    // Computing bound for q
    _170.d1 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump230;
    fail_assertion("non-positive loop bound");
    _jump230:;
    // Computing bound for r
    _170.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump231;
    fail_assertion("non-positive loop bound");
    _jump231:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= _90.d0;
    _171 *= _90.d0;
    _171 *= g.d1;
    _171 *= sizeof(int64_t);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // r
    int64_t _173 = 0; // q
    int64_t _174 = 0; // p
    _jump232:; // Begin body of loop
    int64_t _175 = 0;
    _175 *= _170.d0;
    _175 += _174;
    _175 *= _170.d1;
    _175 += _173;
    _175 *= _170.d2;
    _175 += _172;
    _170.data[_175] = _172;
    _172++;
    if (_172 < g.d1)
    goto _jump232;
    _172 = 0;
    _173++;
    if (_173 < _90.d0)
    goto _jump232;
    _173 = 0;
    _174++;
    if (_174 < _90.d0)
    goto _jump232;
    // End body of loop
    int64_t _176 = 628;
    int64_t _177 = -_176;
    if (_177 >= 0)
    goto _jump233;
    fail_assertion("negative array index");
    _jump233:;
    if (_177 < _170.d0)
    goto _jump234;
    fail_assertion("index too large");
    _jump234:;
    if (g.d2 >= 0)
    goto _jump235;
    fail_assertion("negative array index");
    _jump235:;
    if (g.d2 < _170.d1)
    goto _jump236;
    fail_assertion("index too large");
    _jump236:;
    if (g.d1 >= 0)
    goto _jump237;
    fail_assertion("negative array index");
    _jump237:;
    if (g.d1 < _170.d2)
    goto _jump238;
    fail_assertion("index too large");
    _jump238:;
    int64_t _178 = 0;
    _178 *= _170.d0;
    _178 += _177;
    _178 *= _170.d1;
    _178 += g.d2;
    _178 *= _170.d2;
    _178 += g.d1;
    int64_t _179 = _170.data[_178];
    if (_179 >= 0)
    goto _jump239;
    fail_assertion("negative array index");
    _jump239:;
    if (_179 < _151.d0)
    goto _jump240;
    fail_assertion("index too large");
    _jump240:;
    if (g.d1 >= 0)
    goto _jump241;
    fail_assertion("negative array index");
    _jump241:;
    if (g.d1 < _151.d1)
    goto _jump242;
    fail_assertion("index too large");
    _jump242:;
    int64_t _180 = 0;
    _180 *= _151.d0;
    _180 += _179;
    _180 *= _151.d1;
    _180 += g.d1;
    _a3_bool _181 = _151.data[_180];
    int64_t _182;
    // Computing bound for p
    if (_90.d0 > 0) 
    goto _jump243;
    fail_assertion("non-positive loop bound");
    _jump243:;
    _182 = 0;
    int64_t _183 = 0; // p
    _jump244:; // Begin body of loop
    _182 += g.d1;
    _183++;
    if (_183 < _90.d0)
    goto _jump244;
    // End body of loop
    _a1_int64_t _184;
    // Computing bound for p
    _184.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump245;
    fail_assertion("non-positive loop bound");
    _jump245:;
    // Computing total size of heap memory to allocate
    int64_t _185 = 1;
    _185 *= g.d1;
    _185 *= sizeof(int64_t);
    _184.data = jpl_alloc(_185);
    int64_t _186 = 0; // p
    _jump246:; // Begin body of loop
    int64_t _187 = 0;
    _187 *= _184.d0;
    _187 += _186;
    _184.data[_187] = g.d2;
    _186++;
    if (_186 < g.d1)
    goto _jump246;
    // End body of loop
    bool _188 = false;
    int64_t _189;
    if (!_188)
    goto _jump247;
    _189 = g.d0;
    goto _jump248;
    _jump247:;
    _189 = _90.d1;
    _jump248:;
    if (_189 >= 0)
    goto _jump249;
    fail_assertion("negative array index");
    _jump249:;
    if (_189 < _184.d0)
    goto _jump250;
    fail_assertion("index too large");
    _jump250:;
    int64_t _190 = 0;
    _190 *= _184.d0;
    _190 += _189;
    int64_t _191 = _184.data[_190];
    int64_t _192 = -_90.d0;
    if (_182 >= 0)
    goto _jump251;
    fail_assertion("negative array index");
    _jump251:;
    if (_182 < _181.d0)
    goto _jump252;
    fail_assertion("index too large");
    _jump252:;
    if (_191 >= 0)
    goto _jump253;
    fail_assertion("negative array index");
    _jump253:;
    if (_191 < _181.d1)
    goto _jump254;
    fail_assertion("index too large");
    _jump254:;
    if (_192 >= 0)
    goto _jump255;
    fail_assertion("negative array index");
    _jump255:;
    if (_192 < _181.d2)
    goto _jump256;
    fail_assertion("index too large");
    _jump256:;
    int64_t _193 = 0;
    _193 *= _181.d0;
    _193 += _182;
    _193 *= _181.d1;
    _193 += _191;
    _193 *= _181.d2;
    _193 += _192;
    bool _194 = _181.data[_193];
    _150 = _194;
    goto _jump257;
    _jump217:;
    int64_t _196;
    // Computing bound for p
    if (_90.d0 > 0) 
    goto _jump258;
    fail_assertion("non-positive loop bound");
    _jump258:;
    _196 = 0;
    int64_t _197 = 0; // p
    _jump259:; // Begin body of loop
    int64_t _198 = -_90.d0;
    _196 += _198;
    _197++;
    if (_197 < _90.d0)
    goto _jump259;
    // End body of loop
    bool _199 = g.d2 != _196;
    bool _200 = !_199;
    bool _195 = _200;
    if (0 == _200)
    goto _jump260;
    bool _201 = d >= _90.d0;
    int64_t _202;
    if (!_201)
    goto _jump261;
    int64_t _203 = _90.d1 + g.d2;
    _202 = _203;
    goto _jump262;
    _jump261:;
    _202 = _90.d1;
    _jump262:;
    bool _204 = g.d2 != _202;
    _195 = _204;
    _jump260:;
    _150 = _195;
    _jump257:;
    _136 = _150;
    goto _jump263;
    _jump212:;
    bool _205 = false;
    bool _206 = !_205;
    _136 = _206;
    _jump263:;
    if (0 != _136)
    goto _jump264;
    fail_assertion("p");
    _jump264:;
    double _207;
    // Computing bound for p
    int64_t _208 = 262;
    if (_208 > 0) 
    goto _jump265;
    fail_assertion("non-positive loop bound");
    _jump265:;
    // Computing bound for q
    if (g.d0 > 0) 
    goto _jump266;
    fail_assertion("non-positive loop bound");
    _jump266:;
    _207 = 0;
    int64_t _209 = 0; // q
    int64_t _210 = 0; // p
    _jump267:; // Begin body of loop
    double _211;
    // Computing bound for r
    int64_t _212;
    // Computing bound for r
    int64_t _213;
    // Computing bound for r
    if (c > 0) 
    goto _jump268;
    fail_assertion("non-positive loop bound");
    _jump268:;
    // Computing bound for s
    int64_t _214 = 824;
    if (_214 > 0) 
    goto _jump269;
    fail_assertion("non-positive loop bound");
    _jump269:;
    _213 = 0;
    int64_t _215 = 0; // s
    int64_t _216 = 0; // r
    _jump270:; // Begin body of loop
    int64_t _217 = -c;
    _213 += _217;
    _215++;
    if (_215 < _214)
    goto _jump270;
    _215 = 0;
    _216++;
    if (_216 < c)
    goto _jump270;
    // End body of loop
    if (_213 > 0) 
    goto _jump271;
    fail_assertion("non-positive loop bound");
    _jump271:;
    // Computing bound for s
    if (_90.d1 > 0) 
    goto _jump272;
    fail_assertion("non-positive loop bound");
    _jump272:;
    // Computing bound for t
    if (_209 > 0) 
    goto _jump273;
    fail_assertion("non-positive loop bound");
    _jump273:;
    _212 = 0;
    int64_t _218 = 0; // t
    int64_t _219 = 0; // s
    int64_t _220 = 0; // r
    _jump274:; // Begin body of loop
    _212 += _90.d1;
    _218++;
    if (_218 < _209)
    goto _jump274;
    _218 = 0;
    _219++;
    if (_219 < _90.d1)
    goto _jump274;
    _219 = 0;
    _220++;
    if (_220 < _213)
    goto _jump274;
    // End body of loop
    if (_212 > 0) 
    goto _jump275;
    fail_assertion("non-positive loop bound");
    _jump275:;
    // Computing bound for s
    int64_t _221 = -_0.d0;
    if (_221 > 0) 
    goto _jump276;
    fail_assertion("non-positive loop bound");
    _jump276:;
    _211 = 0;
    int64_t _222 = 0; // s
    int64_t _223 = 0; // r
    _jump277:; // Begin body of loop
    double _224 = 60.0;
    double _225 = 46.0;
    double _226 = 95.0;
    double _227 = -_226;
    double _228 = 9.0;
    double _229 = 6.0;
    double _230 = _228 / _229;
    rgba _231 = { _224, _225, _227, _230 };
    double _232 = _231.b;
    _a3_double _233;
    // Computing bound for t
    _233.d0 = g.d1;
    if (g.d1 > 0) 
    goto _jump278;
    fail_assertion("non-positive loop bound");
    _jump278:;
    // Computing bound for u
    _233.d1 = c;
    if (c > 0) 
    goto _jump279;
    fail_assertion("non-positive loop bound");
    _jump279:;
    // Computing bound for v
    _233.d2 = g.d2;
    if (g.d2 > 0) 
    goto _jump280;
    fail_assertion("non-positive loop bound");
    _jump280:;
    // Computing total size of heap memory to allocate
    int64_t _234 = 1;
    _234 *= g.d1;
    _234 *= c;
    _234 *= g.d2;
    _234 *= sizeof(double);
    _233.data = jpl_alloc(_234);
    int64_t _235 = 0; // v
    int64_t _236 = 0; // u
    int64_t _237 = 0; // t
    _jump281:; // Begin body of loop
    double _238 = 70.0;
    int64_t _239 = 0;
    _239 *= _233.d0;
    _239 += _237;
    _239 *= _233.d1;
    _239 += _236;
    _239 *= _233.d2;
    _239 += _235;
    _233.data[_239] = _238;
    _235++;
    if (_235 < g.d2)
    goto _jump281;
    _235 = 0;
    _236++;
    if (_236 < c)
    goto _jump281;
    _236 = 0;
    _237++;
    if (_237 < g.d1)
    goto _jump281;
    // End body of loop
    int64_t _240 = 519;
    if (_210 >= 0)
    goto _jump282;
    fail_assertion("negative array index");
    _jump282:;
    if (_210 < _233.d0)
    goto _jump283;
    fail_assertion("index too large");
    _jump283:;
    if (_240 >= 0)
    goto _jump284;
    fail_assertion("negative array index");
    _jump284:;
    if (_240 < _233.d1)
    goto _jump285;
    fail_assertion("index too large");
    _jump285:;
    if (g.d0 >= 0)
    goto _jump286;
    fail_assertion("negative array index");
    _jump286:;
    if (g.d0 < _233.d2)
    goto _jump287;
    fail_assertion("index too large");
    _jump287:;
    int64_t _241 = 0;
    _241 *= _233.d0;
    _241 += _210;
    _241 *= _233.d1;
    _241 += _240;
    _241 *= _233.d2;
    _241 += g.d0;
    double _242 = _233.data[_241];
    double _243 = 82.0;
    double _244 = -_243;
    double _245 = 65.0;
    double _246 = -_245;
    double _247 = _244 * _246;
    double _248 = _242 * _247;
    double _249 = _232 + _248;
    _211 += _249;
    _222++;
    if (_222 < _221)
    goto _jump277;
    _222 = 0;
    _223++;
    if (_223 < _212)
    goto _jump277;
    // End body of loop
    _207 += _211;
    _209++;
    if (_209 < g.d0)
    goto _jump267;
    _209 = 0;
    _210++;
    if (_210 < _208)
    goto _jump267;
    // End body of loop
    double _250 = 10.0;
    double _251;
    // Computing bound for p
    if (_90.d0 > 0) 
    goto _jump288;
    fail_assertion("non-positive loop bound");
    _jump288:;
    _251 = 0;
    int64_t _252 = 0; // p
    _jump289:; // Begin body of loop
    double _253 = 92.0;
    _251 += _253;
    _252++;
    if (_252 < _90.d0)
    goto _jump289;
    // End body of loop
    bool _254 = _250 < _251;
    bool _255 = !_254;
    _a3_double _256;
    if (!_255)
    goto _jump290;
    _a3_double _257;
    // Computing bound for p
    int64_t _258;
    // Computing bound for p
    if (_90.d1 >= 0)
    goto _jump291;
    fail_assertion("negative array index");
    _jump291:;
    if (_90.d1 < b.d0)
    goto _jump292;
    fail_assertion("index too large");
    _jump292:;
    if (g.d1 >= 0)
    goto _jump293;
    fail_assertion("negative array index");
    _jump293:;
    if (g.d1 < b.d1)
    goto _jump294;
    fail_assertion("index too large");
    _jump294:;
    int64_t _259 = 0;
    _259 *= b.d0;
    _259 += _90.d1;
    _259 *= b.d1;
    _259 += g.d1;
    int64_t _260 = b.data[_259];
    if (_260 > 0) 
    goto _jump295;
    fail_assertion("non-positive loop bound");
    _jump295:;
    // Computing bound for q
    if (d > 0) 
    goto _jump296;
    fail_assertion("non-positive loop bound");
    _jump296:;
    _258 = 0;
    int64_t _261 = 0; // q
    int64_t _262 = 0; // p
    _jump297:; // Begin body of loop
    int64_t _263 = _90.d1 - _262;
    _258 += _263;
    _261++;
    if (_261 < d)
    goto _jump297;
    _261 = 0;
    _262++;
    if (_262 < _260)
    goto _jump297;
    // End body of loop
    if (d >= 0)
    goto _jump298;
    fail_assertion("negative array index");
    _jump298:;
    if (d < b.d0)
    goto _jump299;
    fail_assertion("index too large");
    _jump299:;
    if (_258 >= 0)
    goto _jump300;
    fail_assertion("negative array index");
    _jump300:;
    if (_258 < b.d1)
    goto _jump301;
    fail_assertion("index too large");
    _jump301:;
    int64_t _264 = 0;
    _264 *= b.d0;
    _264 += d;
    _264 *= b.d1;
    _264 += _258;
    int64_t _265 = b.data[_264];
    _257.d0 = _265;
    if (_265 > 0) 
    goto _jump302;
    fail_assertion("non-positive loop bound");
    _jump302:;
    // Computing bound for q
    int64_t _266;
    // Computing bound for p
    bool _267 = true;
    int64_t _268;
    if (!_267)
    goto _jump303;
    if (c >= 0)
    goto _jump304;
    fail_assertion("negative array index");
    _jump304:;
    if (c < _90.d0)
    goto _jump305;
    fail_assertion("index too large");
    _jump305:;
    if (g.d2 >= 0)
    goto _jump306;
    fail_assertion("negative array index");
    _jump306:;
    if (g.d2 < _90.d1)
    goto _jump307;
    fail_assertion("index too large");
    _jump307:;
    int64_t _269 = 0;
    _269 *= _90.d0;
    _269 += c;
    _269 *= _90.d1;
    _269 += g.d2;
    int64_t _270 = _90.data[_269];
    _268 = _270;
    goto _jump308;
    _jump303:;
    _268 = d;
    _jump308:;
    if (_268 > 0) 
    goto _jump309;
    fail_assertion("non-positive loop bound");
    _jump309:;
    // Computing bound for q
    if (g.d0 > 0) 
    goto _jump310;
    fail_assertion("non-positive loop bound");
    _jump310:;
    // Computing bound for r
    int64_t _271;
    // Computing bound for p
    int64_t _272 = d * g.d0;
    if (_272 > 0) 
    goto _jump311;
    fail_assertion("non-positive loop bound");
    _jump311:;
    // Computing bound for q
    if (c > 0) 
    goto _jump312;
    fail_assertion("non-positive loop bound");
    _jump312:;
    // Computing bound for r
    int64_t _273 = _90.d1 * c;
    if (_273 > 0) 
    goto _jump313;
    fail_assertion("non-positive loop bound");
    _jump313:;
    _271 = 0;
    int64_t _274 = 0; // r
    int64_t _275 = 0; // q
    int64_t _276 = 0; // p
    _jump314:; // Begin body of loop
    _271 += c;
    _274++;
    if (_274 < _273)
    goto _jump314;
    _274 = 0;
    _275++;
    if (_275 < c)
    goto _jump314;
    _275 = 0;
    _276++;
    if (_276 < _272)
    goto _jump314;
    // End body of loop
    if (_271 > 0) 
    goto _jump315;
    fail_assertion("non-positive loop bound");
    _jump315:;
    _266 = 0;
    int64_t _277 = 0; // r
    int64_t _278 = 0; // q
    int64_t _279 = 0; // p
    _jump316:; // Begin body of loop
    _266 += c;
    _277++;
    if (_277 < _271)
    goto _jump316;
    _277 = 0;
    _278++;
    if (_278 < g.d0)
    goto _jump316;
    _278 = 0;
    _279++;
    if (_279 < _268)
    goto _jump316;
    // End body of loop
    _257.d1 = _266;
    if (_266 > 0) 
    goto _jump317;
    fail_assertion("non-positive loop bound");
    _jump317:;
    // Computing bound for r
    _257.d2 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump318;
    fail_assertion("non-positive loop bound");
    _jump318:;
    // Computing total size of heap memory to allocate
    int64_t _280 = 1;
    _280 *= _265;
    _280 *= _266;
    _280 *= _0.d0;
    _280 *= sizeof(double);
    _257.data = jpl_alloc(_280);
    int64_t _281 = 0; // r
    int64_t _282 = 0; // q
    int64_t _283 = 0; // p
    _jump319:; // Begin body of loop
    double _284 = 24.0;
    int64_t _285 = 0;
    _285 *= _257.d0;
    _285 += _283;
    _285 *= _257.d1;
    _285 += _282;
    _285 *= _257.d2;
    _285 += _281;
    _257.data[_285] = _284;
    _281++;
    if (_281 < _0.d0)
    goto _jump319;
    _281 = 0;
    _282++;
    if (_282 < _266)
    goto _jump319;
    _282 = 0;
    _283++;
    if (_283 < _265)
    goto _jump319;
    // End body of loop
    _256 = _257;
    goto _jump320;
    _jump290:;
    _a3_double _286;
    // Computing bound for p
    _286.d0 = _90.d1;
    if (_90.d1 > 0) 
    goto _jump321;
    fail_assertion("non-positive loop bound");
    _jump321:;
    // Computing bound for q
    _286.d1 = c;
    if (c > 0) 
    goto _jump322;
    fail_assertion("non-positive loop bound");
    _jump322:;
    // Computing bound for r
    _286.d2 = c;
    if (c > 0) 
    goto _jump323;
    fail_assertion("non-positive loop bound");
    _jump323:;
    // Computing total size of heap memory to allocate
    int64_t _287 = 1;
    _287 *= _90.d1;
    _287 *= c;
    _287 *= c;
    _287 *= sizeof(double);
    _286.data = jpl_alloc(_287);
    int64_t _288 = 0; // r
    int64_t _289 = 0; // q
    int64_t _290 = 0; // p
    _jump324:; // Begin body of loop
    bool _291 = true;
    double _292;
    if (!_291)
    goto _jump325;
    double _293;
    // Computing bound for s
    if (c > 0) 
    goto _jump326;
    fail_assertion("non-positive loop bound");
    _jump326:;
    // Computing bound for t
    if (_90.d1 > 0) 
    goto _jump327;
    fail_assertion("non-positive loop bound");
    _jump327:;
    // Computing bound for u
    if (_289 > 0) 
    goto _jump328;
    fail_assertion("non-positive loop bound");
    _jump328:;
    _293 = 0;
    int64_t _294 = 0; // u
    int64_t _295 = 0; // t
    int64_t _296 = 0; // s
    _jump329:; // Begin body of loop
    double _297 = 84.0;
    _293 += _297;
    _294++;
    if (_294 < _289)
    goto _jump329;
    _294 = 0;
    _295++;
    if (_295 < _90.d1)
    goto _jump329;
    _295 = 0;
    _296++;
    if (_296 < c)
    goto _jump329;
    // End body of loop
    double _298 = 3.0;
    double _299 = 50.0;
    double _300 = fmod(_298, _299);
    double _301 = fmod(_293, _300);
    _292 = _301;
    goto _jump330;
    _jump325:;
    double _302;
    // Computing bound for s
    if (g.d1 > 0) 
    goto _jump331;
    fail_assertion("non-positive loop bound");
    _jump331:;
    // Computing bound for t
    if (_290 > 0) 
    goto _jump332;
    fail_assertion("non-positive loop bound");
    _jump332:;
    _302 = 0;
    int64_t _303 = 0; // t
    int64_t _304 = 0; // s
    _jump333:; // Begin body of loop
    double _305 = 98.0;
    _302 += _305;
    _303++;
    if (_303 < _290)
    goto _jump333;
    _303 = 0;
    _304++;
    if (_304 < g.d1)
    goto _jump333;
    // End body of loop
    double _306 = -_302;
    _292 = _306;
    _jump330:;
    int64_t _307 = 0;
    _307 *= _286.d0;
    _307 += _290;
    _307 *= _286.d1;
    _307 += _289;
    _307 *= _286.d2;
    _307 += _288;
    _286.data[_307] = _292;
    _288++;
    if (_288 < c)
    goto _jump324;
    _288 = 0;
    _289++;
    if (_289 < c)
    goto _jump324;
    _289 = 0;
    _290++;
    if (_290 < _90.d1)
    goto _jump324;
    // End body of loop
    _256 = _286;
    _jump320:;
    int64_t _308;
    // Computing bound for p
    if (_90.d1 > 0) 
    goto _jump334;
    fail_assertion("non-positive loop bound");
    _jump334:;
    // Computing bound for q
    if (g.d2 > 0) 
    goto _jump335;
    fail_assertion("non-positive loop bound");
    _jump335:;
    // Computing bound for r
    if (_90.d1 > 0) 
    goto _jump336;
    fail_assertion("non-positive loop bound");
    _jump336:;
    _308 = 0;
    int64_t _309 = 0; // r
    int64_t _310 = 0; // q
    int64_t _311 = 0; // p
    _jump337:; // Begin body of loop
    _308 += _309;
    _309++;
    if (_309 < _90.d1)
    goto _jump337;
    _309 = 0;
    _310++;
    if (_310 < g.d2)
    goto _jump337;
    _310 = 0;
    _311++;
    if (_311 < _90.d1)
    goto _jump337;
    // End body of loop
    int64_t _312 = -_308;
    _a3_bool _313;
    // Computing bound for p
    _313.d0 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump338;
    fail_assertion("non-positive loop bound");
    _jump338:;
    // Computing bound for q
    _313.d1 = _90.d1;
    if (_90.d1 > 0) 
    goto _jump339;
    fail_assertion("non-positive loop bound");
    _jump339:;
    // Computing bound for r
    _313.d2 = g.d1;
    if (g.d1 > 0) 
    goto _jump340;
    fail_assertion("non-positive loop bound");
    _jump340:;
    // Computing total size of heap memory to allocate
    int64_t _314 = 1;
    _314 *= _90.d0;
    _314 *= _90.d1;
    _314 *= g.d1;
    _314 *= sizeof(bool);
    _313.data = jpl_alloc(_314);
    int64_t _315 = 0; // r
    int64_t _316 = 0; // q
    int64_t _317 = 0; // p
    _jump341:; // Begin body of loop
    bool _318 = true;
    int64_t _319 = 0;
    _319 *= _313.d0;
    _319 += _317;
    _319 *= _313.d1;
    _319 += _316;
    _319 *= _313.d2;
    _319 += _315;
    _313.data[_319] = _318;
    _315++;
    if (_315 < g.d1)
    goto _jump341;
    _315 = 0;
    _316++;
    if (_316 < _90.d1)
    goto _jump341;
    _316 = 0;
    _317++;
    if (_317 < _90.d0)
    goto _jump341;
    // End body of loop
    int64_t _320 = 512;
    int64_t _321 = 742;
    if (_320 >= 0)
    goto _jump342;
    fail_assertion("negative array index");
    _jump342:;
    if (_320 < _313.d0)
    goto _jump343;
    fail_assertion("index too large");
    _jump343:;
    if (d >= 0)
    goto _jump344;
    fail_assertion("negative array index");
    _jump344:;
    if (d < _313.d1)
    goto _jump345;
    fail_assertion("index too large");
    _jump345:;
    if (_321 >= 0)
    goto _jump346;
    fail_assertion("negative array index");
    _jump346:;
    if (_321 < _313.d2)
    goto _jump347;
    fail_assertion("index too large");
    _jump347:;
    int64_t _322 = 0;
    _322 *= _313.d0;
    _322 += _320;
    _322 *= _313.d1;
    _322 += d;
    _322 *= _313.d2;
    _322 += _321;
    bool _323 = _313.data[_322];
    int64_t _324;
    if (!_323)
    goto _jump348;
    double _325 = 30.0;
    double _326 = -_325;
    double _327 = 38.0;
    bool _328 = _326 > _327;
    int64_t _329;
    if (!_328)
    goto _jump349;
    bool _330 = false;
    int64_t _331;
    if (!_330)
    goto _jump350;
    int64_t _332;
    // Computing bound for p
    if (g.d1 > 0) 
    goto _jump351;
    fail_assertion("non-positive loop bound");
    _jump351:;
    _332 = 0;
    int64_t _333 = 0; // p
    _jump352:; // Begin body of loop
    _332 += g.d0;
    _333++;
    if (_333 < g.d1)
    goto _jump352;
    // End body of loop
    _331 = _332;
    goto _jump353;
    _jump350:;
    _331 = g.d1;
    _jump353:;
    int64_t _334 = g.d2 - _331;
    _329 = _334;
    goto _jump354;
    _jump349:;
    _329 = _0.d0;
    _jump354:;
    _324 = _329;
    goto _jump355;
    _jump348:;
    _324 = _90.d1;
    _jump355:;
    int64_t _335 = 144;
    if (_312 >= 0)
    goto _jump356;
    fail_assertion("negative array index");
    _jump356:;
    if (_312 < _256.d0)
    goto _jump357;
    fail_assertion("index too large");
    _jump357:;
    if (_324 >= 0)
    goto _jump358;
    fail_assertion("negative array index");
    _jump358:;
    if (_324 < _256.d1)
    goto _jump359;
    fail_assertion("index too large");
    _jump359:;
    if (_335 >= 0)
    goto _jump360;
    fail_assertion("negative array index");
    _jump360:;
    if (_335 < _256.d2)
    goto _jump361;
    fail_assertion("index too large");
    _jump361:;
    int64_t _336 = 0;
    _336 *= _256.d0;
    _336 += _312;
    _336 *= _256.d1;
    _336 += _324;
    _336 *= _256.d2;
    _336 += _335;
    double _337 = _256.data[_336];
    bool _338 = _207 <= _337;
    if (0 != _338)
    goto _jump362;
    fail_assertion("p");
    _jump362:;
    _a2_double _339;
    // Computing bound for s
    _339.d0 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump363;
    fail_assertion("non-positive loop bound");
    _jump363:;
    // Computing bound for t
    _339.d1 = d;
    if (d > 0) 
    goto _jump364;
    fail_assertion("non-positive loop bound");
    _jump364:;
    // Computing total size of heap memory to allocate
    int64_t _340 = 1;
    _340 *= _90.d0;
    _340 *= d;
    _340 *= sizeof(double);
    _339.data = jpl_alloc(_340);
    int64_t _341 = 0; // t
    int64_t _342 = 0; // s
    _jump365:; // Begin body of loop
    bool _343 = false;
    bool _344 = !_343;
    int64_t _346 = 416;
    bool _347 = _90.d1 > _346;
    bool _348 = !_347;
    bool _345 = _348;
    if (0 == _348)
    goto _jump366;
    bool _349 = true;
    bool _350 = !_349;
    bool _351;
    if (!_350)
    goto _jump367;
    bool _352 = c < _0.d0;
    _351 = _352;
    goto _jump368;
    _jump367:;
    double _353 = 83.0;
    double _354 = 64.0;
    bool _355 = _353 != _354;
    _351 = _355;
    _jump368:;
    _345 = _351;
    _jump366:;
    bool _356 = _344 != _345;
    _a3_double _357;
    if (!_356)
    goto _jump369;
    bool _358 = true;
    bool _359 = !_358;
    _a3_double _360;
    if (!_359)
    goto _jump370;
    _a3_double _361;
    // Computing bound for u
    _361.d0 = g.d0;
    if (g.d0 > 0) 
    goto _jump371;
    fail_assertion("non-positive loop bound");
    _jump371:;
    // Computing bound for v
    _361.d1 = g.d0;
    if (g.d0 > 0) 
    goto _jump372;
    fail_assertion("non-positive loop bound");
    _jump372:;
    // Computing bound for w
    _361.d2 = _90.d1;
    if (_90.d1 > 0) 
    goto _jump373;
    fail_assertion("non-positive loop bound");
    _jump373:;
    // Computing total size of heap memory to allocate
    int64_t _362 = 1;
    _362 *= g.d0;
    _362 *= g.d0;
    _362 *= _90.d1;
    _362 *= sizeof(double);
    _361.data = jpl_alloc(_362);
    int64_t _363 = 0; // w
    int64_t _364 = 0; // v
    int64_t _365 = 0; // u
    _jump374:; // Begin body of loop
    double _366 = 21.0;
    double _367 = -_366;
    int64_t _368 = 0;
    _368 *= _361.d0;
    _368 += _365;
    _368 *= _361.d1;
    _368 += _364;
    _368 *= _361.d2;
    _368 += _363;
    _361.data[_368] = _367;
    _363++;
    if (_363 < _90.d1)
    goto _jump374;
    _363 = 0;
    _364++;
    if (_364 < g.d0)
    goto _jump374;
    _364 = 0;
    _365++;
    if (_365 < g.d0)
    goto _jump374;
    // End body of loop
    _360 = _361;
    goto _jump375;
    _jump370:;
    _a3_double _369;
    // Computing bound for u
    int64_t _370 = -c;
    _369.d0 = _370;
    if (_370 > 0) 
    goto _jump376;
    fail_assertion("non-positive loop bound");
    _jump376:;
    // Computing bound for v
    _369.d1 = _341;
    if (_341 > 0) 
    goto _jump377;
    fail_assertion("non-positive loop bound");
    _jump377:;
    // Computing bound for w
    bool _371 = true;
    int64_t _372;
    if (!_371)
    goto _jump378;
    _372 = g.d0;
    goto _jump379;
    _jump378:;
    bool _373 = true;
    int64_t _374;
    if (!_373)
    goto _jump380;
    _374 = _341;
    goto _jump381;
    _jump380:;
    _374 = _0.d0;
    _jump381:;
    _372 = _374;
    _jump379:;
    _369.d2 = _372;
    if (_372 > 0) 
    goto _jump382;
    fail_assertion("non-positive loop bound");
    _jump382:;
    // Computing total size of heap memory to allocate
    int64_t _375 = 1;
    _375 *= _370;
    _375 *= _341;
    _375 *= _372;
    _375 *= sizeof(double);
    _369.data = jpl_alloc(_375);
    int64_t _376 = 0; // w
    int64_t _377 = 0; // v
    int64_t _378 = 0; // u
    _jump383:; // Begin body of loop
    double _379 = 68.0;
    double _380 = -_379;
    double _381 = 61.0;
    double _382 = _380 - _381;
    int64_t _383 = 0;
    _383 *= _369.d0;
    _383 += _378;
    _383 *= _369.d1;
    _383 += _377;
    _383 *= _369.d2;
    _383 += _376;
    _369.data[_383] = _382;
    _376++;
    if (_376 < _372)
    goto _jump383;
    _376 = 0;
    _377++;
    if (_377 < _341)
    goto _jump383;
    _377 = 0;
    _378++;
    if (_378 < _370)
    goto _jump383;
    // End body of loop
    _360 = _369;
    _jump375:;
    _357 = _360;
    goto _jump384;
    _jump369:;
    bool _384 = true;
    bool _385;
    if (!_384)
    goto _jump385;
    bool _386 = false;
    bool _387 = false;
    bool _388 = _386 == _387;
    _385 = _388;
    goto _jump386;
    _jump385:;
    bool _389 = d >= _90.d1;
    _385 = _389;
    _jump386:;
    bool _390;
    if (!_385)
    goto _jump387;
    bool _392 = true;
    bool _391 = _392;
    if (0 == _392)
    goto _jump388;
    bool _393 = _90.d0 <= g.d2;
    _391 = _393;
    _jump388:;
    _390 = _391;
    goto _jump389;
    _jump387:;
    int64_t _394 = 859;
    bool _395 = g.d2 != _394;
    _390 = _395;
    _jump389:;
    _a3_double _396;
    if (!_390)
    goto _jump390;
    _a3_double _397;
    // Computing bound for u
    _397.d0 = _90.d1;
    if (_90.d1 > 0) 
    goto _jump391;
    fail_assertion("non-positive loop bound");
    _jump391:;
    // Computing bound for v
    _397.d1 = _341;
    if (_341 > 0) 
    goto _jump392;
    fail_assertion("non-positive loop bound");
    _jump392:;
    // Computing bound for w
    _397.d2 = _90.d1;
    if (_90.d1 > 0) 
    goto _jump393;
    fail_assertion("non-positive loop bound");
    _jump393:;
    // Computing total size of heap memory to allocate
    int64_t _398 = 1;
    _398 *= _90.d1;
    _398 *= _341;
    _398 *= _90.d1;
    _398 *= sizeof(double);
    _397.data = jpl_alloc(_398);
    int64_t _399 = 0; // w
    int64_t _400 = 0; // v
    int64_t _401 = 0; // u
    _jump394:; // Begin body of loop
    double _402;
    // Computing bound for x
    int64_t _403 = 22;
    if (_403 > 0) 
    goto _jump395;
    fail_assertion("non-positive loop bound");
    _jump395:;
    // Computing bound for y
    if (_90.d0 > 0) 
    goto _jump396;
    fail_assertion("non-positive loop bound");
    _jump396:;
    // Computing bound for z
    if (_90.d1 > 0) 
    goto _jump397;
    fail_assertion("non-positive loop bound");
    _jump397:;
    _402 = 0;
    int64_t _404 = 0; // z
    int64_t _405 = 0; // y
    int64_t _406 = 0; // x
    _jump398:; // Begin body of loop
    double _407 = 33.0;
    double _408 = -_407;
    _402 += _408;
    _404++;
    if (_404 < _90.d1)
    goto _jump398;
    _404 = 0;
    _405++;
    if (_405 < _90.d0)
    goto _jump398;
    _405 = 0;
    _406++;
    if (_406 < _403)
    goto _jump398;
    // End body of loop
    int64_t _409 = 0;
    _409 *= _397.d0;
    _409 += _401;
    _409 *= _397.d1;
    _409 += _400;
    _409 *= _397.d2;
    _409 += _399;
    _397.data[_409] = _402;
    _399++;
    if (_399 < _90.d1)
    goto _jump394;
    _399 = 0;
    _400++;
    if (_400 < _341)
    goto _jump394;
    _400 = 0;
    _401++;
    if (_401 < _90.d1)
    goto _jump394;
    // End body of loop
    _396 = _397;
    goto _jump399;
    _jump390:;
    _a3_double _410;
    // Computing bound for u
    _410.d0 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump400;
    fail_assertion("non-positive loop bound");
    _jump400:;
    // Computing bound for v
    _410.d1 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump401;
    fail_assertion("non-positive loop bound");
    _jump401:;
    // Computing bound for w
    _410.d2 = g.d2;
    if (g.d2 > 0) 
    goto _jump402;
    fail_assertion("non-positive loop bound");
    _jump402:;
    // Computing total size of heap memory to allocate
    int64_t _411 = 1;
    _411 *= _90.d0;
    _411 *= _90.d0;
    _411 *= g.d2;
    _411 *= sizeof(double);
    _410.data = jpl_alloc(_411);
    int64_t _412 = 0; // w
    int64_t _413 = 0; // v
    int64_t _414 = 0; // u
    _jump403:; // Begin body of loop
    _a1_double _415;
    // Computing bound for x
    _415.d0 = _90.d0;
    if (_90.d0 > 0) 
    goto _jump404;
    fail_assertion("non-positive loop bound");
    _jump404:;
    // Computing total size of heap memory to allocate
    int64_t _416 = 1;
    _416 *= _90.d0;
    _416 *= sizeof(double);
    _415.data = jpl_alloc(_416);
    int64_t _417 = 0; // x
    _jump405:; // Begin body of loop
    double _418 = 1.0;
    int64_t _419 = 0;
    _419 *= _415.d0;
    _419 += _417;
    _415.data[_419] = _418;
    _417++;
    if (_417 < _90.d0)
    goto _jump405;
    // End body of loop
    if (g.d1 >= 0)
    goto _jump406;
    fail_assertion("negative array index");
    _jump406:;
    if (g.d1 < _415.d0)
    goto _jump407;
    fail_assertion("index too large");
    _jump407:;
    int64_t _420 = 0;
    _420 *= _415.d0;
    _420 += g.d1;
    double _421 = _415.data[_420];
    int64_t _422 = 0;
    _422 *= _410.d0;
    _422 += _414;
    _422 *= _410.d1;
    _422 += _413;
    _422 *= _410.d2;
    _422 += _412;
    _410.data[_422] = _421;
    _412++;
    if (_412 < g.d2)
    goto _jump403;
    _412 = 0;
    _413++;
    if (_413 < _90.d0)
    goto _jump403;
    _413 = 0;
    _414++;
    if (_414 < _90.d0)
    goto _jump403;
    // End body of loop
    _396 = _410;
    _jump399:;
    _357 = _396;
    _jump384:;
    if (_90.d0 >= 0)
    goto _jump408;
    fail_assertion("negative array index");
    _jump408:;
    if (_90.d0 < _357.d0)
    goto _jump409;
    fail_assertion("index too large");
    _jump409:;
    if (c >= 0)
    goto _jump410;
    fail_assertion("negative array index");
    _jump410:;
    if (c < _357.d1)
    goto _jump411;
    fail_assertion("index too large");
    _jump411:;
    if (_341 >= 0)
    goto _jump412;
    fail_assertion("negative array index");
    _jump412:;
    if (_341 < _357.d2)
    goto _jump413;
    fail_assertion("index too large");
    _jump413:;
    int64_t _423 = 0;
    _423 *= _357.d0;
    _423 += _90.d0;
    _423 *= _357.d1;
    _423 += c;
    _423 *= _357.d2;
    _423 += _341;
    double _424 = _357.data[_423];
    int64_t _425 = 0;
    _425 *= _339.d0;
    _425 += _342;
    _425 *= _339.d1;
    _425 += _341;
    _339.data[_425] = _424;
    _341++;
    if (_341 < d)
    goto _jump365;
    _341 = 0;
    _342++;
    if (_342 < _90.d0)
    goto _jump365;
    // End body of loop
    return _339;
}

double g(bool h) {
    double _0 = 69.0;
    double _1 = -_0;
    return _1;
    _a2_int64_t _2;
    // Computing bound for i
    _a2_int64_t _3;
    // Computing bound for i
    int64_t _4 = 326;
    _3.d0 = _4;
    if (_4 > 0) 
    goto _jump414;
    fail_assertion("non-positive loop bound");
    _jump414:;
    // Computing bound for j
    int64_t _5 = 790;
    _3.d1 = _5;
    if (_5 > 0) 
    goto _jump415;
    fail_assertion("non-positive loop bound");
    _jump415:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _4;
    _6 *= _5;
    _6 *= sizeof(int64_t);
    _3.data = jpl_alloc(_6);
    int64_t _7 = 0; // j
    int64_t _8 = 0; // i
    _jump416:; // Begin body of loop
    int64_t _9 = 0;
    _9 *= _3.d0;
    _9 += _8;
    _9 *= _3.d1;
    _9 += _7;
    _3.data[_9] = _8;
    _7++;
    if (_7 < _5)
    goto _jump416;
    _7 = 0;
    _8++;
    if (_8 < _4)
    goto _jump416;
    // End body of loop
    if (d >= 0)
    goto _jump417;
    fail_assertion("negative array index");
    _jump417:;
    if (d < _3.d0)
    goto _jump418;
    fail_assertion("index too large");
    _jump418:;
    if (c >= 0)
    goto _jump419;
    fail_assertion("negative array index");
    _jump419:;
    if (c < _3.d1)
    goto _jump420;
    fail_assertion("index too large");
    _jump420:;
    int64_t _10 = 0;
    _10 *= _3.d0;
    _10 += d;
    _10 *= _3.d1;
    _10 += c;
    int64_t _11 = _3.data[_10];
    _2.d0 = _11;
    if (_11 > 0) 
    goto _jump421;
    fail_assertion("non-positive loop bound");
    _jump421:;
    // Computing bound for j
    int64_t _12 = 254;
    _2.d1 = _12;
    if (_12 > 0) 
    goto _jump422;
    fail_assertion("non-positive loop bound");
    _jump422:;
    // Computing total size of heap memory to allocate
    int64_t _13 = 1;
    _13 *= _11;
    _13 *= _12;
    _13 *= sizeof(int64_t);
    _2.data = jpl_alloc(_13);
    int64_t _14 = 0; // j
    int64_t _15 = 0; // i
    _jump423:; // Begin body of loop
    int64_t _16;
    // Computing bound for k
    if (d > 0) 
    goto _jump424;
    fail_assertion("non-positive loop bound");
    _jump424:;
    // Computing bound for l
    if (_14 > 0) 
    goto _jump425;
    fail_assertion("non-positive loop bound");
    _jump425:;
    // Computing bound for m
    int64_t _17 = 264;
    int64_t _18 = _17 * _15;
    if (_18 > 0) 
    goto _jump426;
    fail_assertion("non-positive loop bound");
    _jump426:;
    _16 = 0;
    int64_t _19 = 0; // m
    int64_t _20 = 0; // l
    int64_t _21 = 0; // k
    _jump427:; // Begin body of loop
    int64_t _22;
    // Computing bound for n
    if (_14 > 0) 
    goto _jump428;
    fail_assertion("non-positive loop bound");
    _jump428:;
    _22 = 0;
    int64_t _23 = 0; // n
    _jump429:; // Begin body of loop
    int64_t _24 = -_23;
    _22 += _24;
    _23++;
    if (_23 < _14)
    goto _jump429;
    // End body of loop
    _16 += _22;
    _19++;
    if (_19 < _18)
    goto _jump427;
    _19 = 0;
    _20++;
    if (_20 < _14)
    goto _jump427;
    _20 = 0;
    _21++;
    if (_21 < d)
    goto _jump427;
    // End body of loop
    int64_t _25 = 0;
    _25 *= _2.d0;
    _25 += _15;
    _25 *= _2.d1;
    _25 += _14;
    _2.data[_25] = _16;
    _14++;
    if (_14 < _12)
    goto _jump423;
    _14 = 0;
    _15++;
    if (_15 < _11)
    goto _jump423;
    // End body of loop
    double _27;
    // Computing bound for j
    if (c > 0) 
    goto _jump430;
    fail_assertion("non-positive loop bound");
    _jump430:;
    // Computing bound for k
    if (c > 0) 
    goto _jump431;
    fail_assertion("non-positive loop bound");
    _jump431:;
    _27 = 0;
    int64_t _28 = 0; // k
    int64_t _29 = 0; // j
    _jump432:; // Begin body of loop
    int64_t _30 = -_29;
    if (_30 >= 0)
    goto _jump433;
    fail_assertion("negative array index");
    _jump433:;
    if (_30 < e.d0)
    goto _jump434;
    fail_assertion("index too large");
    _jump434:;
    if (_29 >= 0)
    goto _jump435;
    fail_assertion("negative array index");
    _jump435:;
    if (_29 < e.d1)
    goto _jump436;
    fail_assertion("index too large");
    _jump436:;
    int64_t _31 = 0;
    _31 *= e.d0;
    _31 += _30;
    _31 *= e.d1;
    _31 += _29;
    rgba _32 = e.data[_31];
    double _33 = _32.r;
    _27 += _33;
    _28++;
    if (_28 < c)
    goto _jump432;
    _28 = 0;
    _29++;
    if (_29 < c)
    goto _jump432;
    // End body of loop
    double _34;
    // Computing bound for j
    int64_t _35 = 211;
    if (_35 > 0) 
    goto _jump437;
    fail_assertion("non-positive loop bound");
    _jump437:;
    // Computing bound for k
    int64_t _36;
    if (!h)
    goto _jump438;
    _36 = d;
    goto _jump439;
    _jump438:;
    int64_t _37 = 918;
    _36 = _37;
    _jump439:;
    int64_t _38 = -_36;
    if (_38 > 0) 
    goto _jump440;
    fail_assertion("non-positive loop bound");
    _jump440:;
    _34 = 0;
    int64_t _39 = 0; // k
    int64_t _40 = 0; // j
    _jump441:; // Begin body of loop
    double _41 = 11.0;
    double _42 = -_41;
    _34 += _42;
    _39++;
    if (_39 < _38)
    goto _jump441;
    _39 = 0;
    _40++;
    if (_40 < _35)
    goto _jump441;
    // End body of loop
    double _43 = 56.0;
    int64_t _44 = 734;
    bool _45 = _44 >= d;
    double _46;
    if (!_45)
    goto _jump442;
    double _47 = 14.0;
    _46 = _47;
    goto _jump443;
    _jump442:;
    double _48 = 2.0;
    _46 = _48;
    _jump443:;
    double _49 = _43 + _46;
    bool _50 = _34 == _49;
    double _51;
    if (!_50)
    goto _jump444;
    double _52 = g(h);
    double _53 = -_52;
    _51 = _53;
    goto _jump445;
    _jump444:;
    double _54;
    // Computing bound for j
    _a3_int64_t _55;
    // Computing bound for j
    int64_t _56 = 277;
    _55.d0 = _56;
    if (_56 > 0) 
    goto _jump446;
    fail_assertion("non-positive loop bound");
    _jump446:;
    // Computing bound for k
    bool _57 = true;
    int64_t _58;
    if (!_57)
    goto _jump447;
    _58 = c;
    goto _jump448;
    _jump447:;
    _58 = d;
    _jump448:;
    _55.d1 = _58;
    if (_58 > 0) 
    goto _jump449;
    fail_assertion("non-positive loop bound");
    _jump449:;
    // Computing bound for l
    int64_t _59 = -d;
    _55.d2 = _59;
    if (_59 > 0) 
    goto _jump450;
    fail_assertion("non-positive loop bound");
    _jump450:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= _56;
    _60 *= _58;
    _60 *= _59;
    _60 *= sizeof(int64_t);
    _55.data = jpl_alloc(_60);
    int64_t _61 = 0; // l
    int64_t _62 = 0; // k
    int64_t _63 = 0; // j
    _jump451:; // Begin body of loop
    int64_t _64;
    // Computing bound for m
    if (c > 0) 
    goto _jump452;
    fail_assertion("non-positive loop bound");
    _jump452:;
    // Computing bound for n
    if (c > 0) 
    goto _jump453;
    fail_assertion("non-positive loop bound");
    _jump453:;
    // Computing bound for o
    if (d > 0) 
    goto _jump454;
    fail_assertion("non-positive loop bound");
    _jump454:;
    _64 = 0;
    int64_t _65 = 0; // o
    int64_t _66 = 0; // n
    int64_t _67 = 0; // m
    _jump455:; // Begin body of loop
    _64 += c;
    _65++;
    if (_65 < d)
    goto _jump455;
    _65 = 0;
    _66++;
    if (_66 < c)
    goto _jump455;
    _66 = 0;
    _67++;
    if (_67 < c)
    goto _jump455;
    // End body of loop
    int64_t _68 = 0;
    _68 *= _55.d0;
    _68 += _63;
    _68 *= _55.d1;
    _68 += _62;
    _68 *= _55.d2;
    _68 += _61;
    _55.data[_68] = _64;
    _61++;
    if (_61 < _59)
    goto _jump451;
    _61 = 0;
    _62++;
    if (_62 < _58)
    goto _jump451;
    _62 = 0;
    _63++;
    if (_63 < _56)
    goto _jump451;
    // End body of loop
    int64_t _69 = 712;
    int64_t _70;
    // Computing bound for j
    int64_t _71 = 515;
    int64_t _72 = d % _71;
    if (_72 > 0) 
    goto _jump456;
    fail_assertion("non-positive loop bound");
    _jump456:;
    // Computing bound for k
    int64_t _73 = 13;
    int64_t _74 = d - _73;
    if (_74 > 0) 
    goto _jump457;
    fail_assertion("non-positive loop bound");
    _jump457:;
    _70 = 0;
    int64_t _75 = 0; // k
    int64_t _76 = 0; // j
    _jump458:; // Begin body of loop
    int64_t _77;
    if (!h)
    goto _jump459;
    _77 = d;
    goto _jump460;
    _jump459:;
    _77 = d;
    _jump460:;
    _70 += _77;
    _75++;
    if (_75 < _74)
    goto _jump458;
    _75 = 0;
    _76++;
    if (_76 < _72)
    goto _jump458;
    // End body of loop
    int64_t _78 = 60;
    int64_t _79 = -_78;
    if (_69 >= 0)
    goto _jump461;
    fail_assertion("negative array index");
    _jump461:;
    if (_69 < _55.d0)
    goto _jump462;
    fail_assertion("index too large");
    _jump462:;
    if (_70 >= 0)
    goto _jump463;
    fail_assertion("negative array index");
    _jump463:;
    if (_70 < _55.d1)
    goto _jump464;
    fail_assertion("index too large");
    _jump464:;
    if (_79 >= 0)
    goto _jump465;
    fail_assertion("negative array index");
    _jump465:;
    if (_79 < _55.d2)
    goto _jump466;
    fail_assertion("index too large");
    _jump466:;
    int64_t _80 = 0;
    _80 *= _55.d0;
    _80 += _69;
    _80 *= _55.d1;
    _80 += _70;
    _80 *= _55.d2;
    _80 += _79;
    int64_t _81 = _55.data[_80];
    if (_81 > 0) 
    goto _jump467;
    fail_assertion("non-positive loop bound");
    _jump467:;
    // Computing bound for k
    int64_t _82;
    if (!h)
    goto _jump468;
    int64_t _83 = -d;
    _82 = _83;
    goto _jump469;
    _jump468:;
    int64_t _84 = -c;
    int64_t _85 = -_84;
    _82 = _85;
    _jump469:;
    if (_82 > 0) 
    goto _jump470;
    fail_assertion("non-positive loop bound");
    _jump470:;
    // Computing bound for l
    int64_t _86 = 139;
    if (_86 > 0) 
    goto _jump471;
    fail_assertion("non-positive loop bound");
    _jump471:;
    _54 = 0;
    int64_t _87 = 0; // l
    int64_t _88 = 0; // k
    int64_t _89 = 0; // j
    _jump472:; // Begin body of loop
    double _90 = 14.0;
    double _91 = 59.0;
    _a1_double _92;
    _92.d0 = 2;
    _92.data = jpl_alloc(sizeof(double) * 2);
    _92.data[0] = _90;
    _92.data[1] = _91;
    if (_89 >= 0)
    goto _jump473;
    fail_assertion("negative array index");
    _jump473:;
    if (_89 < _92.d0)
    goto _jump474;
    fail_assertion("index too large");
    _jump474:;
    int64_t _93 = 0;
    _93 *= _92.d0;
    _93 += _89;
    double _94 = _92.data[_93];
    _54 += _94;
    _87++;
    if (_87 < _86)
    goto _jump472;
    _87 = 0;
    _88++;
    if (_88 < _82)
    goto _jump472;
    _88 = 0;
    _89++;
    if (_89 < _81)
    goto _jump472;
    // End body of loop
    _51 = _54;
    _jump445:;
    bool _95 = _27 > _51;
    bool _26 = _95;
    if (0 != _95)
    goto _jump475;
    _a3_bool _96;
    if (!h)
    goto _jump476;
    _a3_bool _97;
    if (!h)
    goto _jump477;
    _a3_bool _98;
    // Computing bound for j
    _98.d0 = d;
    if (d > 0) 
    goto _jump478;
    fail_assertion("non-positive loop bound");
    _jump478:;
    // Computing bound for k
    int64_t _99;
    // Computing bound for j
    int64_t _100 = 115;
    if (_100 > 0) 
    goto _jump479;
    fail_assertion("non-positive loop bound");
    _jump479:;
    // Computing bound for k
    if (d > 0) 
    goto _jump480;
    fail_assertion("non-positive loop bound");
    _jump480:;
    _99 = 0;
    int64_t _101 = 0; // k
    int64_t _102 = 0; // j
    _jump481:; // Begin body of loop
    _99 += d;
    _101++;
    if (_101 < d)
    goto _jump481;
    _101 = 0;
    _102++;
    if (_102 < _100)
    goto _jump481;
    // End body of loop
    _98.d1 = _99;
    if (_99 > 0) 
    goto _jump482;
    fail_assertion("non-positive loop bound");
    _jump482:;
    // Computing bound for l
    int64_t _103 = 629;
    if (_103 >= 0)
    goto _jump483;
    fail_assertion("negative array index");
    _jump483:;
    if (_103 < b.d0)
    goto _jump484;
    fail_assertion("index too large");
    _jump484:;
    if (d >= 0)
    goto _jump485;
    fail_assertion("negative array index");
    _jump485:;
    if (d < b.d1)
    goto _jump486;
    fail_assertion("index too large");
    _jump486:;
    int64_t _104 = 0;
    _104 *= b.d0;
    _104 += _103;
    _104 *= b.d1;
    _104 += d;
    int64_t _105 = b.data[_104];
    _98.d2 = _105;
    if (_105 > 0) 
    goto _jump487;
    fail_assertion("non-positive loop bound");
    _jump487:;
    // Computing total size of heap memory to allocate
    int64_t _106 = 1;
    _106 *= d;
    _106 *= _99;
    _106 *= _105;
    _106 *= sizeof(bool);
    _98.data = jpl_alloc(_106);
    int64_t _107 = 0; // l
    int64_t _108 = 0; // k
    int64_t _109 = 0; // j
    _jump488:; // Begin body of loop
    int64_t _110 = -_107;
    bool _111 = _110 != d;
    int64_t _112 = 0;
    _112 *= _98.d0;
    _112 += _109;
    _112 *= _98.d1;
    _112 += _108;
    _112 *= _98.d2;
    _112 += _107;
    _98.data[_112] = _111;
    _107++;
    if (_107 < _105)
    goto _jump488;
    _107 = 0;
    _108++;
    if (_108 < _99)
    goto _jump488;
    _108 = 0;
    _109++;
    if (_109 < d)
    goto _jump488;
    // End body of loop
    _97 = _98;
    goto _jump489;
    _jump477:;
    _a3_bool _113;
    // Computing bound for j
    int64_t _114;
    // Computing bound for j
    if (c > 0) 
    goto _jump490;
    fail_assertion("non-positive loop bound");
    _jump490:;
    // Computing bound for k
    if (c > 0) 
    goto _jump491;
    fail_assertion("non-positive loop bound");
    _jump491:;
    _114 = 0;
    int64_t _115 = 0; // k
    int64_t _116 = 0; // j
    _jump492:; // Begin body of loop
    _114 += c;
    _115++;
    if (_115 < c)
    goto _jump492;
    _115 = 0;
    _116++;
    if (_116 < c)
    goto _jump492;
    // End body of loop
    int64_t _117 = -_114;
    _113.d0 = _117;
    if (_117 > 0) 
    goto _jump493;
    fail_assertion("non-positive loop bound");
    _jump493:;
    // Computing bound for k
    _113.d1 = d;
    if (d > 0) 
    goto _jump494;
    fail_assertion("non-positive loop bound");
    _jump494:;
    // Computing bound for l
    int64_t _118;
    // Computing bound for j
    int64_t _119 = 248;
    if (_119 > 0) 
    goto _jump495;
    fail_assertion("non-positive loop bound");
    _jump495:;
    _118 = 0;
    int64_t _120 = 0; // j
    _jump496:; // Begin body of loop
    int64_t _121 = -_120;
    _118 += _121;
    _120++;
    if (_120 < _119)
    goto _jump496;
    // End body of loop
    _113.d2 = _118;
    if (_118 > 0) 
    goto _jump497;
    fail_assertion("non-positive loop bound");
    _jump497:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _117;
    _122 *= d;
    _122 *= _118;
    _122 *= sizeof(bool);
    _113.data = jpl_alloc(_122);
    int64_t _123 = 0; // l
    int64_t _124 = 0; // k
    int64_t _125 = 0; // j
    _jump498:; // Begin body of loop
    bool _126 = false;
    bool _127;
    if (!_126)
    goto _jump499;
    bool _128 = !h;
    _127 = _128;
    goto _jump500;
    _jump499:;
    double _129 = 43.0;
    double _130 = 39.0;
    bool _131 = _129 == _130;
    _127 = _131;
    _jump500:;
    int64_t _132 = 0;
    _132 *= _113.d0;
    _132 += _125;
    _132 *= _113.d1;
    _132 += _124;
    _132 *= _113.d2;
    _132 += _123;
    _113.data[_132] = _127;
    _123++;
    if (_123 < _118)
    goto _jump498;
    _123 = 0;
    _124++;
    if (_124 < d)
    goto _jump498;
    _124 = 0;
    _125++;
    if (_125 < _117)
    goto _jump498;
    // End body of loop
    _97 = _113;
    _jump489:;
    _96 = _97;
    goto _jump501;
    _jump476:;
    _a3_bool _133;
    // Computing bound for j
    int64_t _134 = -c;
    int64_t _135 = -_134;
    int64_t _136 = 42;
    int64_t _137 = 227;
    int64_t _138 = -_137;
    int64_t _139 = _136 + _138;
    int64_t _140 = _135 - _139;
    _133.d0 = _140;
    if (_140 > 0) 
    goto _jump502;
    fail_assertion("non-positive loop bound");
    _jump502:;
    // Computing bound for k
    bool _141 = c == d;
    _a1_int64_t _142;
    if (!_141)
    goto _jump503;
    _a1_int64_t _143;
    // Computing bound for j
    _143.d0 = c;
    if (c > 0) 
    goto _jump504;
    fail_assertion("non-positive loop bound");
    _jump504:;
    // Computing total size of heap memory to allocate
    int64_t _144 = 1;
    _144 *= c;
    _144 *= sizeof(int64_t);
    _143.data = jpl_alloc(_144);
    int64_t _145 = 0; // j
    _jump505:; // Begin body of loop
    int64_t _146 = 0;
    _146 *= _143.d0;
    _146 += _145;
    _143.data[_146] = d;
    _145++;
    if (_145 < c)
    goto _jump505;
    // End body of loop
    _142 = _143;
    goto _jump506;
    _jump503:;
    _a1_int64_t _147;
    // Computing bound for j
    int64_t _148 = 398;
    _147.d0 = _148;
    if (_148 > 0) 
    goto _jump507;
    fail_assertion("non-positive loop bound");
    _jump507:;
    // Computing total size of heap memory to allocate
    int64_t _149 = 1;
    _149 *= _148;
    _149 *= sizeof(int64_t);
    _147.data = jpl_alloc(_149);
    int64_t _150 = 0; // j
    _jump508:; // Begin body of loop
    int64_t _151 = 0;
    _151 *= _147.d0;
    _151 += _150;
    _147.data[_151] = c;
    _150++;
    if (_150 < _148)
    goto _jump508;
    // End body of loop
    _142 = _147;
    _jump506:;
    if (d >= 0)
    goto _jump509;
    fail_assertion("negative array index");
    _jump509:;
    if (d < _142.d0)
    goto _jump510;
    fail_assertion("index too large");
    _jump510:;
    int64_t _152 = 0;
    _152 *= _142.d0;
    _152 += d;
    int64_t _153 = _142.data[_152];
    _133.d1 = _153;
    if (_153 > 0) 
    goto _jump511;
    fail_assertion("non-positive loop bound");
    _jump511:;
    // Computing bound for l
    _133.d2 = d;
    if (d > 0) 
    goto _jump512;
    fail_assertion("non-positive loop bound");
    _jump512:;
    // Computing total size of heap memory to allocate
    int64_t _154 = 1;
    _154 *= _140;
    _154 *= _153;
    _154 *= d;
    _154 *= sizeof(bool);
    _133.data = jpl_alloc(_154);
    int64_t _155 = 0; // l
    int64_t _156 = 0; // k
    int64_t _157 = 0; // j
    _jump513:; // Begin body of loop
    bool _158 = d != _155;
    int64_t _159 = 0;
    _159 *= _133.d0;
    _159 += _157;
    _159 *= _133.d1;
    _159 += _156;
    _159 *= _133.d2;
    _159 += _155;
    _133.data[_159] = _158;
    _155++;
    if (_155 < d)
    goto _jump513;
    _155 = 0;
    _156++;
    if (_156 < _153)
    goto _jump513;
    _156 = 0;
    _157++;
    if (_157 < _140)
    goto _jump513;
    // End body of loop
    _96 = _133;
    _jump501:;
    int64_t _160 = 378;
    int64_t _161 = -c;
    int64_t _162 = 37;
    int64_t _163 = -_162;
    if (_160 >= 0)
    goto _jump514;
    fail_assertion("negative array index");
    _jump514:;
    if (_160 < _96.d0)
    goto _jump515;
    fail_assertion("index too large");
    _jump515:;
    if (_161 >= 0)
    goto _jump516;
    fail_assertion("negative array index");
    _jump516:;
    if (_161 < _96.d1)
    goto _jump517;
    fail_assertion("index too large");
    _jump517:;
    if (_163 >= 0)
    goto _jump518;
    fail_assertion("negative array index");
    _jump518:;
    if (_163 < _96.d2)
    goto _jump519;
    fail_assertion("index too large");
    _jump519:;
    int64_t _164 = 0;
    _164 *= _96.d0;
    _164 += _160;
    _164 *= _96.d1;
    _164 += _161;
    _164 *= _96.d2;
    _164 += _163;
    bool _165 = _96.data[_164];
    _26 = _165;
    _jump475:;
    if (0 != h)
    goto _jump520;
    fail_assertion("k");
    _jump520:;
    bool _166 = false;
    if (0 != _166)
    goto _jump521;
    fail_assertion("l");
    _jump521:;
    double _167;
    // Computing bound for l
    _a3_int64_t _168;
    // Computing bound for l
    _168.d0 = d;
    if (d > 0) 
    goto _jump522;
    fail_assertion("non-positive loop bound");
    _jump522:;
    // Computing bound for m
    _168.d1 = d;
    if (d > 0) 
    goto _jump523;
    fail_assertion("non-positive loop bound");
    _jump523:;
    // Computing bound for n
    int64_t _169 = 795;
    _168.d2 = _169;
    if (_169 > 0) 
    goto _jump524;
    fail_assertion("non-positive loop bound");
    _jump524:;
    // Computing total size of heap memory to allocate
    int64_t _170 = 1;
    _170 *= d;
    _170 *= d;
    _170 *= _169;
    _170 *= sizeof(int64_t);
    _168.data = jpl_alloc(_170);
    int64_t _171 = 0; // n
    int64_t _172 = 0; // m
    int64_t _173 = 0; // l
    _jump525:; // Begin body of loop
    int64_t _174 = 731;
    int64_t _175 = -_174;
    bool _176 = true;
    bool _177;
    if (!_176)
    goto _jump526;
    _177 = h;
    goto _jump527;
    _jump526:;
    _177 = _26;
    _jump527:;
    int64_t _178;
    if (!_177)
    goto _jump528;
    _178 = _171;
    goto _jump529;
    _jump528:;
    _178 = _173;
    _jump529:;
    int64_t _179 = _175 + _178;
    int64_t _180 = 0;
    _180 *= _168.d0;
    _180 += _173;
    _180 *= _168.d1;
    _180 += _172;
    _180 *= _168.d2;
    _180 += _171;
    _168.data[_180] = _179;
    _171++;
    if (_171 < _169)
    goto _jump525;
    _171 = 0;
    _172++;
    if (_172 < d)
    goto _jump525;
    _172 = 0;
    _173++;
    if (_173 < d)
    goto _jump525;
    // End body of loop
    int64_t _181;
    // Computing bound for l
    _a1_int64_t _182;
    // Computing bound for l
    _182.d0 = d;
    if (d > 0) 
    goto _jump530;
    fail_assertion("non-positive loop bound");
    _jump530:;
    // Computing total size of heap memory to allocate
    int64_t _183 = 1;
    _183 *= d;
    _183 *= sizeof(int64_t);
    _182.data = jpl_alloc(_183);
    int64_t _184 = 0; // l
    _jump531:; // Begin body of loop
    int64_t _185 = 0;
    _185 *= _182.d0;
    _185 += _184;
    _182.data[_185] = c;
    _184++;
    if (_184 < d)
    goto _jump531;
    // End body of loop
    int64_t _186;
    // Computing bound for l
    int64_t _187 = 84;
    if (_187 > 0) 
    goto _jump532;
    fail_assertion("non-positive loop bound");
    _jump532:;
    _186 = 0;
    int64_t _188 = 0; // l
    _jump533:; // Begin body of loop
    int64_t _189 = c - d;
    _186 += _189;
    _188++;
    if (_188 < _187)
    goto _jump533;
    // End body of loop
    if (_186 >= 0)
    goto _jump534;
    fail_assertion("negative array index");
    _jump534:;
    if (_186 < _182.d0)
    goto _jump535;
    fail_assertion("index too large");
    _jump535:;
    int64_t _190 = 0;
    _190 *= _182.d0;
    _190 += _186;
    int64_t _191 = _182.data[_190];
    if (_191 > 0) 
    goto _jump536;
    fail_assertion("non-positive loop bound");
    _jump536:;
    // Computing bound for m
    int64_t _192 = d - c;
    int64_t _193 = 23;
    int64_t _194 = c / _193;
    int64_t _195 = _192 - _194;
    int64_t _196 = -_195;
    if (_196 > 0) 
    goto _jump537;
    fail_assertion("non-positive loop bound");
    _jump537:;
    // Computing bound for n
    if (d > 0) 
    goto _jump538;
    fail_assertion("non-positive loop bound");
    _jump538:;
    _181 = 0;
    int64_t _197 = 0; // n
    int64_t _198 = 0; // m
    int64_t _199 = 0; // l
    _jump539:; // Begin body of loop
    int64_t _200 = 326;
    bool _201 = _200 != _198;
    bool _202 = _26 != _201;
    int64_t _203;
    if (!_202)
    goto _jump540;
    int64_t _204;
    // Computing bound for o
    int64_t _205 = 916;
    if (_205 > 0) 
    goto _jump541;
    fail_assertion("non-positive loop bound");
    _jump541:;
    // Computing bound for p
    if (_199 > 0) 
    goto _jump542;
    fail_assertion("non-positive loop bound");
    _jump542:;
    _204 = 0;
    int64_t _206 = 0; // p
    int64_t _207 = 0; // o
    _jump543:; // Begin body of loop
    int64_t _208;
    // Computing bound for q
    int64_t _209 = 52;
    if (_209 > 0) 
    goto _jump544;
    fail_assertion("non-positive loop bound");
    _jump544:;
    // Computing bound for r
    if (c > 0) 
    goto _jump545;
    fail_assertion("non-positive loop bound");
    _jump545:;
    _208 = 0;
    int64_t _210 = 0; // r
    int64_t _211 = 0; // q
    _jump546:; // Begin body of loop
    int64_t _212 = 860;
    _208 += _212;
    _210++;
    if (_210 < c)
    goto _jump546;
    _210 = 0;
    _211++;
    if (_211 < _209)
    goto _jump546;
    // End body of loop
    _204 += _208;
    _206++;
    if (_206 < _199)
    goto _jump543;
    _206 = 0;
    _207++;
    if (_207 < _205)
    goto _jump543;
    // End body of loop
    _203 = _204;
    goto _jump547;
    _jump540:;
    _203 = c;
    _jump547:;
    _181 += _203;
    _197++;
    if (_197 < d)
    goto _jump539;
    _197 = 0;
    _198++;
    if (_198 < _196)
    goto _jump539;
    _198 = 0;
    _199++;
    if (_199 < _191)
    goto _jump539;
    // End body of loop
    int64_t _213;
    // Computing bound for l
    bool _214 = _26;
    if (0 == _26)
    goto _jump548;
    _214 = _26;
    _jump548:;
    int64_t _215;
    if (!_214)
    goto _jump549;
    _215 = c;
    goto _jump550;
    _jump549:;
    _215 = c;
    _jump550:;
    if (_215 > 0) 
    goto _jump551;
    fail_assertion("non-positive loop bound");
    _jump551:;
    // Computing bound for m
    int64_t _216 = 558;
    _a1_int64_t _217;
    _217.d0 = 3;
    _217.data = jpl_alloc(sizeof(int64_t) * 3);
    _217.data[0] = _216;
    _217.data[1] = d;
    _217.data[2] = d;
    if (d >= 0)
    goto _jump552;
    fail_assertion("negative array index");
    _jump552:;
    if (d < _217.d0)
    goto _jump553;
    fail_assertion("index too large");
    _jump553:;
    int64_t _218 = 0;
    _218 *= _217.d0;
    _218 += d;
    int64_t _219 = _217.data[_218];
    int64_t _220 = -_219;
    if (_220 > 0) 
    goto _jump554;
    fail_assertion("non-positive loop bound");
    _jump554:;
    // Computing bound for n
    int64_t _221;
    // Computing bound for l
    int64_t _222 = c - c;
    int64_t _223 = -_222;
    if (_223 > 0) 
    goto _jump555;
    fail_assertion("non-positive loop bound");
    _jump555:;
    // Computing bound for m
    int64_t _224 = 223;
    if (_224 > 0) 
    goto _jump556;
    fail_assertion("non-positive loop bound");
    _jump556:;
    // Computing bound for n
    int64_t _225 = d / c;
    if (_225 > 0) 
    goto _jump557;
    fail_assertion("non-positive loop bound");
    _jump557:;
    _221 = 0;
    int64_t _226 = 0; // n
    int64_t _227 = 0; // m
    int64_t _228 = 0; // l
    _jump558:; // Begin body of loop
    _221 += c;
    _226++;
    if (_226 < _225)
    goto _jump558;
    _226 = 0;
    _227++;
    if (_227 < _224)
    goto _jump558;
    _227 = 0;
    _228++;
    if (_228 < _223)
    goto _jump558;
    // End body of loop
    if (_221 > 0) 
    goto _jump559;
    fail_assertion("non-positive loop bound");
    _jump559:;
    _213 = 0;
    int64_t _229 = 0; // n
    int64_t _230 = 0; // m
    int64_t _231 = 0; // l
    _jump560:; // Begin body of loop
    int64_t _232;
    // Computing bound for o
    int64_t _233 = _229 % d;
    int64_t _234 = -_233;
    if (_234 > 0) 
    goto _jump561;
    fail_assertion("non-positive loop bound");
    _jump561:;
    _232 = 0;
    int64_t _235 = 0; // o
    _jump562:; // Begin body of loop
    _232 += c;
    _235++;
    if (_235 < _234)
    goto _jump562;
    // End body of loop
    _213 += _232;
    _229++;
    if (_229 < _221)
    goto _jump560;
    _229 = 0;
    _230++;
    if (_230 < _220)
    goto _jump560;
    _230 = 0;
    _231++;
    if (_231 < _215)
    goto _jump560;
    // End body of loop
    if (_181 >= 0)
    goto _jump563;
    fail_assertion("negative array index");
    _jump563:;
    if (_181 < _168.d0)
    goto _jump564;
    fail_assertion("index too large");
    _jump564:;
    if (_213 >= 0)
    goto _jump565;
    fail_assertion("negative array index");
    _jump565:;
    if (_213 < _168.d1)
    goto _jump566;
    fail_assertion("index too large");
    _jump566:;
    if (c >= 0)
    goto _jump567;
    fail_assertion("negative array index");
    _jump567:;
    if (c < _168.d2)
    goto _jump568;
    fail_assertion("index too large");
    _jump568:;
    int64_t _236 = 0;
    _236 *= _168.d0;
    _236 += _181;
    _236 *= _168.d1;
    _236 += _213;
    _236 *= _168.d2;
    _236 += c;
    int64_t _237 = _168.data[_236];
    int64_t _238 = 479;
    if (c >= 0)
    goto _jump569;
    fail_assertion("negative array index");
    _jump569:;
    if (c < b.d0)
    goto _jump570;
    fail_assertion("index too large");
    _jump570:;
    if (_238 >= 0)
    goto _jump571;
    fail_assertion("negative array index");
    _jump571:;
    if (_238 < b.d1)
    goto _jump572;
    fail_assertion("index too large");
    _jump572:;
    int64_t _239 = 0;
    _239 *= b.d0;
    _239 += c;
    _239 *= b.d1;
    _239 += _238;
    int64_t _240 = b.data[_239];
    int64_t _241 = -_240;
    int64_t _242 = _237 % _241;
    if (_242 > 0) 
    goto _jump573;
    fail_assertion("non-positive loop bound");
    _jump573:;
    // Computing bound for m
    if (d > 0) 
    goto _jump574;
    fail_assertion("non-positive loop bound");
    _jump574:;
    // Computing bound for n
    _a3_int64_t _243;
    // Computing bound for l
    int64_t _244 = 531;
    _243.d0 = _244;
    if (_244 > 0) 
    goto _jump575;
    fail_assertion("non-positive loop bound");
    _jump575:;
    // Computing bound for m
    _243.d1 = c;
    if (c > 0) 
    goto _jump576;
    fail_assertion("non-positive loop bound");
    _jump576:;
    // Computing bound for n
    int64_t _245 = 46;
    _243.d2 = _245;
    if (_245 > 0) 
    goto _jump577;
    fail_assertion("non-positive loop bound");
    _jump577:;
    // Computing total size of heap memory to allocate
    int64_t _246 = 1;
    _246 *= _244;
    _246 *= c;
    _246 *= _245;
    _246 *= sizeof(int64_t);
    _243.data = jpl_alloc(_246);
    int64_t _247 = 0; // n
    int64_t _248 = 0; // m
    int64_t _249 = 0; // l
    _jump578:; // Begin body of loop
    int64_t _250;
    // Computing bound for o
    int64_t _251 = 920;
    if (_251 > 0) 
    goto _jump579;
    fail_assertion("non-positive loop bound");
    _jump579:;
    _250 = 0;
    int64_t _252 = 0; // o
    _jump580:; // Begin body of loop
    _250 += _252;
    _252++;
    if (_252 < _251)
    goto _jump580;
    // End body of loop
    int64_t _253 = 0;
    _253 *= _243.d0;
    _253 += _249;
    _253 *= _243.d1;
    _253 += _248;
    _253 *= _243.d2;
    _253 += _247;
    _243.data[_253] = _250;
    _247++;
    if (_247 < _245)
    goto _jump578;
    _247 = 0;
    _248++;
    if (_248 < c)
    goto _jump578;
    _248 = 0;
    _249++;
    if (_249 < _244)
    goto _jump578;
    // End body of loop
    int64_t _254 = -d;
    int64_t _255 = d / _254;
    int64_t _256 = -_255;
    int64_t _257 = 823;
    int64_t _258 = -_257;
    int64_t _259 = -c;
    if (_256 >= 0)
    goto _jump581;
    fail_assertion("negative array index");
    _jump581:;
    if (_256 < _243.d0)
    goto _jump582;
    fail_assertion("index too large");
    _jump582:;
    if (_258 >= 0)
    goto _jump583;
    fail_assertion("negative array index");
    _jump583:;
    if (_258 < _243.d1)
    goto _jump584;
    fail_assertion("index too large");
    _jump584:;
    if (_259 >= 0)
    goto _jump585;
    fail_assertion("negative array index");
    _jump585:;
    if (_259 < _243.d2)
    goto _jump586;
    fail_assertion("index too large");
    _jump586:;
    int64_t _260 = 0;
    _260 *= _243.d0;
    _260 += _256;
    _260 *= _243.d1;
    _260 += _258;
    _260 *= _243.d2;
    _260 += _259;
    int64_t _261 = _243.data[_260];
    if (_261 > 0) 
    goto _jump587;
    fail_assertion("non-positive loop bound");
    _jump587:;
    _167 = 0;
    int64_t _262 = 0; // n
    int64_t _263 = 0; // m
    int64_t _264 = 0; // l
    _jump588:; // Begin body of loop
    double _265 = g(h);
    double _266 = 28.0;
    bool _267 = false;
    double _268 = g(_267);
    bool _269 = _266 >= _268;
    bool _270;
    if (!_269)
    goto _jump589;
    _a3_bool _271;
    // Computing bound for o
    _271.d0 = c;
    if (c > 0) 
    goto _jump590;
    fail_assertion("non-positive loop bound");
    _jump590:;
    // Computing bound for p
    int64_t _272 = 535;
    _271.d1 = _272;
    if (_272 > 0) 
    goto _jump591;
    fail_assertion("non-positive loop bound");
    _jump591:;
    // Computing bound for q
    _271.d2 = _263;
    if (_263 > 0) 
    goto _jump592;
    fail_assertion("non-positive loop bound");
    _jump592:;
    // Computing total size of heap memory to allocate
    int64_t _273 = 1;
    _273 *= c;
    _273 *= _272;
    _273 *= _263;
    _273 *= sizeof(bool);
    _271.data = jpl_alloc(_273);
    int64_t _274 = 0; // q
    int64_t _275 = 0; // p
    int64_t _276 = 0; // o
    _jump593:; // Begin body of loop
    int64_t _277 = 0;
    _277 *= _271.d0;
    _277 += _276;
    _277 *= _271.d1;
    _277 += _275;
    _277 *= _271.d2;
    _277 += _274;
    _271.data[_277] = h;
    _274++;
    if (_274 < _263)
    goto _jump593;
    _274 = 0;
    _275++;
    if (_275 < _272)
    goto _jump593;
    _275 = 0;
    _276++;
    if (_276 < c)
    goto _jump593;
    // End body of loop
    int64_t _278 = d % c;
    int64_t _279 = 136;
    if (_278 >= 0)
    goto _jump594;
    fail_assertion("negative array index");
    _jump594:;
    if (_278 < _271.d0)
    goto _jump595;
    fail_assertion("index too large");
    _jump595:;
    if (_279 >= 0)
    goto _jump596;
    fail_assertion("negative array index");
    _jump596:;
    if (_279 < _271.d1)
    goto _jump597;
    fail_assertion("index too large");
    _jump597:;
    if (_262 >= 0)
    goto _jump598;
    fail_assertion("negative array index");
    _jump598:;
    if (_262 < _271.d2)
    goto _jump599;
    fail_assertion("index too large");
    _jump599:;
    int64_t _280 = 0;
    _280 *= _271.d0;
    _280 += _278;
    _280 *= _271.d1;
    _280 += _279;
    _280 *= _271.d2;
    _280 += _262;
    bool _281 = _271.data[_280];
    _270 = _281;
    goto _jump600;
    _jump589:;
    _270 = h;
    _jump600:;
    double _282;
    if (!_270)
    goto _jump601;
    double _283 = g(_26);
    double _284 = 38.0;
    double _285 = fmod(_283, _284);
    _282 = _285;
    goto _jump602;
    _jump601:;
    bool _286;
    if (!h)
    goto _jump603;
    bool _287 = _263 < _264;
    _286 = _287;
    goto _jump604;
    _jump603:;
    bool _288 = !_26;
    _286 = _288;
    _jump604:;
    double _289 = g(_286);
    _282 = _289;
    _jump602:;
    double _290 = -_282;
    double _291 = _265 / _290;
    _167 += _291;
    _262++;
    if (_262 < _261)
    goto _jump588;
    _262 = 0;
    _263++;
    if (_263 < d)
    goto _jump588;
    _263 = 0;
    _264++;
    if (_264 < _242)
    goto _jump588;
    // End body of loop
    return _167;
}

a h() {
    double _2;
    // Computing bound for i
    _a3_int64_t _3;
    // Computing bound for i
    _3.d0 = d;
    if (d > 0) 
    goto _jump605;
    fail_assertion("non-positive loop bound");
    _jump605:;
    // Computing bound for j
    _3.d1 = d;
    if (d > 0) 
    goto _jump606;
    fail_assertion("non-positive loop bound");
    _jump606:;
    // Computing bound for k
    int64_t _4 = -d;
    _3.d2 = _4;
    if (_4 > 0) 
    goto _jump607;
    fail_assertion("non-positive loop bound");
    _jump607:;
    // Computing total size of heap memory to allocate
    int64_t _5 = 1;
    _5 *= d;
    _5 *= d;
    _5 *= _4;
    _5 *= sizeof(int64_t);
    _3.data = jpl_alloc(_5);
    int64_t _6 = 0; // k
    int64_t _7 = 0; // j
    int64_t _8 = 0; // i
    _jump608:; // Begin body of loop
    int64_t _9;
    // Computing bound for l
    if (_8 > 0) 
    goto _jump609;
    fail_assertion("non-positive loop bound");
    _jump609:;
    _9 = 0;
    int64_t _10 = 0; // l
    _jump610:; // Begin body of loop
    int64_t _11 = 949;
    _9 += _11;
    _10++;
    if (_10 < _8)
    goto _jump610;
    // End body of loop
    int64_t _12 = 0;
    _12 *= _3.d0;
    _12 += _8;
    _12 *= _3.d1;
    _12 += _7;
    _12 *= _3.d2;
    _12 += _6;
    _3.data[_12] = _9;
    _6++;
    if (_6 < _4)
    goto _jump608;
    _6 = 0;
    _7++;
    if (_7 < d)
    goto _jump608;
    _7 = 0;
    _8++;
    if (_8 < d)
    goto _jump608;
    // End body of loop
    int64_t _13 = -d;
    int64_t _14 = c - d;
    int64_t _15 = _13 % _14;
    int64_t _16 = 930;
    int64_t _17 = _16 * c;
    if (d >= 0)
    goto _jump611;
    fail_assertion("negative array index");
    _jump611:;
    if (d < _3.d0)
    goto _jump612;
    fail_assertion("index too large");
    _jump612:;
    if (_15 >= 0)
    goto _jump613;
    fail_assertion("negative array index");
    _jump613:;
    if (_15 < _3.d1)
    goto _jump614;
    fail_assertion("index too large");
    _jump614:;
    if (_17 >= 0)
    goto _jump615;
    fail_assertion("negative array index");
    _jump615:;
    if (_17 < _3.d2)
    goto _jump616;
    fail_assertion("index too large");
    _jump616:;
    int64_t _18 = 0;
    _18 *= _3.d0;
    _18 += d;
    _18 *= _3.d1;
    _18 += _15;
    _18 *= _3.d2;
    _18 += _17;
    int64_t _19 = _3.data[_18];
    if (_19 > 0) 
    goto _jump617;
    fail_assertion("non-positive loop bound");
    _jump617:;
    // Computing bound for j
    bool _21 = false;
    bool _22 = !_21;
    bool _20 = _22;
    if (0 == _22)
    goto _jump618;
    double _23 = 0.0;
    double _24 = 78.0;
    bool _25 = _23 == _24;
    _20 = _25;
    _jump618:;
    int64_t _26;
    if (!_20)
    goto _jump619;
    int64_t _27 = 147;
    int64_t _28 = -_27;
    int64_t _29 = -_28;
    _26 = _29;
    goto _jump620;
    _jump619:;
    _26 = c;
    _jump620:;
    if (_26 > 0) 
    goto _jump621;
    fail_assertion("non-positive loop bound");
    _jump621:;
    // Computing bound for k
    int64_t _30;
    // Computing bound for i
    int64_t _31;
    // Computing bound for i
    if (c > 0) 
    goto _jump622;
    fail_assertion("non-positive loop bound");
    _jump622:;
    _31 = 0;
    int64_t _32 = 0; // i
    _jump623:; // Begin body of loop
    int64_t _33 = 223;
    _31 += _33;
    _32++;
    if (_32 < c)
    goto _jump623;
    // End body of loop
    if (_31 > 0) 
    goto _jump624;
    fail_assertion("non-positive loop bound");
    _jump624:;
    _30 = 0;
    int64_t _34 = 0; // i
    _jump625:; // Begin body of loop
    _30 += _34;
    _34++;
    if (_34 < _31)
    goto _jump625;
    // End body of loop
    if (_30 > 0) 
    goto _jump626;
    fail_assertion("non-positive loop bound");
    _jump626:;
    _2 = 0;
    int64_t _35 = 0; // k
    int64_t _36 = 0; // j
    int64_t _37 = 0; // i
    _jump627:; // Begin body of loop
    a _38 = h();
    double _39 = _38.b;
    _2 += _39;
    _35++;
    if (_35 < _30)
    goto _jump627;
    _35 = 0;
    _36++;
    if (_36 < _26)
    goto _jump627;
    _36 = 0;
    _37++;
    if (_37 < _19)
    goto _jump627;
    // End body of loop
    int64_t _40 = -d;
    int64_t _41;
    // Computing bound for i
    if (c > 0) 
    goto _jump628;
    fail_assertion("non-positive loop bound");
    _jump628:;
    // Computing bound for j
    int64_t _42 = 689;
    int64_t _43 = 523;
    int64_t _44 = _42 / _43;
    if (_44 > 0) 
    goto _jump629;
    fail_assertion("non-positive loop bound");
    _jump629:;
    _41 = 0;
    int64_t _45 = 0; // j
    int64_t _46 = 0; // i
    _jump630:; // Begin body of loop
    int64_t _47 = _46 / c;
    _41 += _47;
    _45++;
    if (_45 < _44)
    goto _jump630;
    _45 = 0;
    _46++;
    if (_46 < c)
    goto _jump630;
    // End body of loop
    if (_40 >= 0)
    goto _jump631;
    fail_assertion("negative array index");
    _jump631:;
    if (_40 < e.d0)
    goto _jump632;
    fail_assertion("index too large");
    _jump632:;
    if (_41 >= 0)
    goto _jump633;
    fail_assertion("negative array index");
    _jump633:;
    if (_41 < e.d1)
    goto _jump634;
    fail_assertion("index too large");
    _jump634:;
    int64_t _48 = 0;
    _48 *= e.d0;
    _48 += _40;
    _48 *= e.d1;
    _48 += _41;
    rgba _49 = e.data[_48];
    double _50 = _49.a;
    bool _51 = _2 <= _50;
    bool _1 = _51;
    if (0 != _51)
    goto _jump635;
    int64_t _52;
    // Computing bound for i
    int64_t _53 = 242;
    int64_t _54;
    // Computing bound for i
    int64_t _55 = 696;
    if (_55 > 0) 
    goto _jump636;
    fail_assertion("non-positive loop bound");
    _jump636:;
    // Computing bound for j
    if (c > 0) 
    goto _jump637;
    fail_assertion("non-positive loop bound");
    _jump637:;
    // Computing bound for k
    int64_t _56 = 514;
    if (_56 > 0) 
    goto _jump638;
    fail_assertion("non-positive loop bound");
    _jump638:;
    _54 = 0;
    int64_t _57 = 0; // k
    int64_t _58 = 0; // j
    int64_t _59 = 0; // i
    _jump639:; // Begin body of loop
    _54 += _59;
    _57++;
    if (_57 < _56)
    goto _jump639;
    _57 = 0;
    _58++;
    if (_58 < c)
    goto _jump639;
    _58 = 0;
    _59++;
    if (_59 < _55)
    goto _jump639;
    // End body of loop
    int64_t _60 = _53 + _54;
    if (_60 > 0) 
    goto _jump640;
    fail_assertion("non-positive loop bound");
    _jump640:;
    // Computing bound for j
    if (c > 0) 
    goto _jump641;
    fail_assertion("non-positive loop bound");
    _jump641:;
    // Computing bound for k
    int64_t _61;
    // Computing bound for i
    int64_t _62 = 650;
    if (_62 > 0) 
    goto _jump642;
    fail_assertion("non-positive loop bound");
    _jump642:;
    _61 = 0;
    int64_t _63 = 0; // i
    _jump643:; // Begin body of loop
    bool _64 = false;
    bool _65 = !_64;
    int64_t _66;
    if (!_65)
    goto _jump644;
    int64_t _67;
    // Computing bound for j
    if (c > 0) 
    goto _jump645;
    fail_assertion("non-positive loop bound");
    _jump645:;
    _67 = 0;
    int64_t _68 = 0; // j
    _jump646:; // Begin body of loop
    _67 += d;
    _68++;
    if (_68 < c)
    goto _jump646;
    // End body of loop
    _66 = _67;
    goto _jump647;
    _jump644:;
    int64_t _69 = 149;
    _66 = _69;
    _jump647:;
    _61 += _66;
    _63++;
    if (_63 < _62)
    goto _jump643;
    // End body of loop
    if (_61 > 0) 
    goto _jump648;
    fail_assertion("non-positive loop bound");
    _jump648:;
    _52 = 0;
    int64_t _70 = 0; // k
    int64_t _71 = 0; // j
    int64_t _72 = 0; // i
    _jump649:; // Begin body of loop
    _52 += _72;
    _70++;
    if (_70 < _61)
    goto _jump649;
    _70 = 0;
    _71++;
    if (_71 < c)
    goto _jump649;
    _71 = 0;
    _72++;
    if (_72 < _60)
    goto _jump649;
    // End body of loop
    double _73 = 97.0;
    a _74 = h();
    double _75 = _74.b;
    bool _76 = _73 < _75;
    int64_t _77;
    if (!_76)
    goto _jump650;
    _77 = c;
    goto _jump651;
    _jump650:;
    int64_t _78 = 243;
    if (d >= 0)
    goto _jump652;
    fail_assertion("negative array index");
    _jump652:;
    if (d < b.d0)
    goto _jump653;
    fail_assertion("index too large");
    _jump653:;
    if (_78 >= 0)
    goto _jump654;
    fail_assertion("negative array index");
    _jump654:;
    if (_78 < b.d1)
    goto _jump655;
    fail_assertion("index too large");
    _jump655:;
    int64_t _79 = 0;
    _79 *= b.d0;
    _79 += d;
    _79 *= b.d1;
    _79 += _78;
    int64_t _80 = b.data[_79];
    int64_t _81 = d / _80;
    _77 = _81;
    _jump651:;
    int64_t _82 = d % _77;
    bool _83 = _52 > _82;
    _1 = _83;
    _jump635:;
    bool _0 = _1;
    if (0 != _1)
    goto _jump656;
    bool _84 = true;
    _0 = _84;
    _jump656:;
    int64_t _85;
    if (!_0)
    goto _jump657;
    int64_t _86 = 906;
    _85 = _86;
    goto _jump658;
    _jump657:;
    int64_t _87 = 505;
    _85 = _87;
    _jump658:;
    int64_t _88;
    // Computing bound for j
    int64_t _89 = 228;
    if (_89 > 0) 
    goto _jump659;
    fail_assertion("non-positive loop bound");
    _jump659:;
    _88 = 0;
    int64_t _90 = 0; // j
    _jump660:; // Begin body of loop
    _88 += d;
    _90++;
    if (_90 < _89)
    goto _jump660;
    // End body of loop
    int64_t _91 = -_88;
    int64_t _92 = _85 % _91;
    int64_t _93 = -_92;
    int64_t _94 = -_93;
    bool _95 = _94 != c;
    _a3_bool _96;
    if (!_95)
    goto _jump661;
    _a3_bool _97;
    // Computing bound for j
    _97.d0 = d;
    if (d > 0) 
    goto _jump662;
    fail_assertion("non-positive loop bound");
    _jump662:;
    // Computing bound for k
    int64_t _98 = 522;
    _97.d1 = _98;
    if (_98 > 0) 
    goto _jump663;
    fail_assertion("non-positive loop bound");
    _jump663:;
    // Computing bound for l
    _97.d2 = c;
    if (c > 0) 
    goto _jump664;
    fail_assertion("non-positive loop bound");
    _jump664:;
    // Computing total size of heap memory to allocate
    int64_t _99 = 1;
    _99 *= d;
    _99 *= _98;
    _99 *= c;
    _99 *= sizeof(bool);
    _97.data = jpl_alloc(_99);
    int64_t _100 = 0; // l
    int64_t _101 = 0; // k
    int64_t _102 = 0; // j
    _jump665:; // Begin body of loop
    bool _103 = false;
    int64_t _104 = 0;
    _104 *= _97.d0;
    _104 += _102;
    _104 *= _97.d1;
    _104 += _101;
    _104 *= _97.d2;
    _104 += _100;
    _97.data[_104] = _103;
    _100++;
    if (_100 < c)
    goto _jump665;
    _100 = 0;
    _101++;
    if (_101 < _98)
    goto _jump665;
    _101 = 0;
    _102++;
    if (_102 < d)
    goto _jump665;
    // End body of loop
    _96 = _97;
    goto _jump666;
    _jump661:;
    int64_t _105 = -c;
    bool _106 = d == _105;
    _a3__a3_bool _107;
    if (!_106)
    goto _jump667;
    int64_t _109 = -d;
    int64_t _110;
    if (!_0)
    goto _jump668;
    int64_t _111 = 57;
    _110 = _111;
    goto _jump669;
    _jump668:;
    _110 = c;
    _jump669:;
    bool _112 = _109 >= _110;
    bool _108 = _112;
    if (0 != _112)
    goto _jump670;
    int64_t _113 = -d;
    int64_t _114;
    // Computing bound for j
    if (d > 0) 
    goto _jump671;
    fail_assertion("non-positive loop bound");
    _jump671:;
    _114 = 0;
    int64_t _115 = 0; // j
    _jump672:; // Begin body of loop
    _114 += d;
    _115++;
    if (_115 < d)
    goto _jump672;
    // End body of loop
    bool _116 = _113 == _114;
    _108 = _116;
    _jump670:;
    _a3__a3_bool _117;
    if (!_108)
    goto _jump673;
    _a3__a3_bool _118;
    // Computing bound for j
    _118.d0 = d;
    if (d > 0) 
    goto _jump674;
    fail_assertion("non-positive loop bound");
    _jump674:;
    // Computing bound for k
    int64_t _119;
    // Computing bound for j
    if (d > 0) 
    goto _jump675;
    fail_assertion("non-positive loop bound");
    _jump675:;
    // Computing bound for k
    int64_t _120 = -c;
    if (_120 > 0) 
    goto _jump676;
    fail_assertion("non-positive loop bound");
    _jump676:;
    // Computing bound for l
    int64_t _121 = 666;
    if (_121 > 0) 
    goto _jump677;
    fail_assertion("non-positive loop bound");
    _jump677:;
    _119 = 0;
    int64_t _122 = 0; // l
    int64_t _123 = 0; // k
    int64_t _124 = 0; // j
    _jump678:; // Begin body of loop
    _119 += _123;
    _122++;
    if (_122 < _121)
    goto _jump678;
    _122 = 0;
    _123++;
    if (_123 < _120)
    goto _jump678;
    _123 = 0;
    _124++;
    if (_124 < d)
    goto _jump678;
    // End body of loop
    _118.d1 = _119;
    if (_119 > 0) 
    goto _jump679;
    fail_assertion("non-positive loop bound");
    _jump679:;
    // Computing bound for l
    bool _126 = true;
    bool _125 = _126;
    if (0 != _126)
    goto _jump680;
    bool _127 = false;
    _125 = _127;
    _jump680:;
    int64_t _128;
    if (!_125)
    goto _jump681;
    int64_t _129 = 608;
    int64_t _130 = _129 + d;
    _128 = _130;
    goto _jump682;
    _jump681:;
    int64_t _131 = c % d;
    _128 = _131;
    _jump682:;
    _118.d2 = _128;
    if (_128 > 0) 
    goto _jump683;
    fail_assertion("non-positive loop bound");
    _jump683:;
    // Computing total size of heap memory to allocate
    int64_t _132 = 1;
    _132 *= d;
    _132 *= _119;
    _132 *= _128;
    _132 *= sizeof(_a3_bool);
    _118.data = jpl_alloc(_132);
    int64_t _133 = 0; // l
    int64_t _134 = 0; // k
    int64_t _135 = 0; // j
    _jump684:; // Begin body of loop
    _a3_bool _136;
    // Computing bound for m
    _136.d0 = c;
    if (c > 0) 
    goto _jump685;
    fail_assertion("non-positive loop bound");
    _jump685:;
    // Computing bound for n
    _136.d1 = d;
    if (d > 0) 
    goto _jump686;
    fail_assertion("non-positive loop bound");
    _jump686:;
    // Computing bound for o
    int64_t _137;
    // Computing bound for m
    int64_t _138 = 151;
    if (_138 > 0) 
    goto _jump687;
    fail_assertion("non-positive loop bound");
    _jump687:;
    // Computing bound for n
    if (c > 0) 
    goto _jump688;
    fail_assertion("non-positive loop bound");
    _jump688:;
    // Computing bound for o
    if (_133 > 0) 
    goto _jump689;
    fail_assertion("non-positive loop bound");
    _jump689:;
    _137 = 0;
    int64_t _139 = 0; // o
    int64_t _140 = 0; // n
    int64_t _141 = 0; // m
    _jump690:; // Begin body of loop
    _137 += _135;
    _139++;
    if (_139 < _133)
    goto _jump690;
    _139 = 0;
    _140++;
    if (_140 < c)
    goto _jump690;
    _140 = 0;
    _141++;
    if (_141 < _138)
    goto _jump690;
    // End body of loop
    _136.d2 = _137;
    if (_137 > 0) 
    goto _jump691;
    fail_assertion("non-positive loop bound");
    _jump691:;
    // Computing total size of heap memory to allocate
    int64_t _142 = 1;
    _142 *= c;
    _142 *= d;
    _142 *= _137;
    _142 *= sizeof(bool);
    _136.data = jpl_alloc(_142);
    int64_t _143 = 0; // o
    int64_t _144 = 0; // n
    int64_t _145 = 0; // m
    _jump692:; // Begin body of loop
    bool _146 = _143 == _145;
    int64_t _147 = 0;
    _147 *= _136.d0;
    _147 += _145;
    _147 *= _136.d1;
    _147 += _144;
    _147 *= _136.d2;
    _147 += _143;
    _136.data[_147] = _146;
    _143++;
    if (_143 < _137)
    goto _jump692;
    _143 = 0;
    _144++;
    if (_144 < d)
    goto _jump692;
    _144 = 0;
    _145++;
    if (_145 < c)
    goto _jump692;
    // End body of loop
    int64_t _148 = 0;
    _148 *= _118.d0;
    _148 += _135;
    _148 *= _118.d1;
    _148 += _134;
    _148 *= _118.d2;
    _148 += _133;
    _118.data[_148] = _136;
    _133++;
    if (_133 < _128)
    goto _jump684;
    _133 = 0;
    _134++;
    if (_134 < _119)
    goto _jump684;
    _134 = 0;
    _135++;
    if (_135 < d)
    goto _jump684;
    // End body of loop
    _117 = _118;
    goto _jump693;
    _jump673:;
    _a3__a3_bool _149;
    // Computing bound for j
    _a3_int64_t _150;
    // Computing bound for j
    _150.d0 = d;
    if (d > 0) 
    goto _jump694;
    fail_assertion("non-positive loop bound");
    _jump694:;
    // Computing bound for k
    _150.d1 = d;
    if (d > 0) 
    goto _jump695;
    fail_assertion("non-positive loop bound");
    _jump695:;
    // Computing bound for l
    _150.d2 = d;
    if (d > 0) 
    goto _jump696;
    fail_assertion("non-positive loop bound");
    _jump696:;
    // Computing total size of heap memory to allocate
    int64_t _151 = 1;
    _151 *= d;
    _151 *= d;
    _151 *= d;
    _151 *= sizeof(int64_t);
    _150.data = jpl_alloc(_151);
    int64_t _152 = 0; // l
    int64_t _153 = 0; // k
    int64_t _154 = 0; // j
    _jump697:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _150.d0;
    _155 += _154;
    _155 *= _150.d1;
    _155 += _153;
    _155 *= _150.d2;
    _155 += _152;
    _150.data[_155] = _153;
    _152++;
    if (_152 < d)
    goto _jump697;
    _152 = 0;
    _153++;
    if (_153 < d)
    goto _jump697;
    _153 = 0;
    _154++;
    if (_154 < d)
    goto _jump697;
    // End body of loop
    int64_t _156 = 429;
    int64_t _157 = 93;
    if (c >= 0)
    goto _jump698;
    fail_assertion("negative array index");
    _jump698:;
    if (c < _150.d0)
    goto _jump699;
    fail_assertion("index too large");
    _jump699:;
    if (_156 >= 0)
    goto _jump700;
    fail_assertion("negative array index");
    _jump700:;
    if (_156 < _150.d1)
    goto _jump701;
    fail_assertion("index too large");
    _jump701:;
    if (_157 >= 0)
    goto _jump702;
    fail_assertion("negative array index");
    _jump702:;
    if (_157 < _150.d2)
    goto _jump703;
    fail_assertion("index too large");
    _jump703:;
    int64_t _158 = 0;
    _158 *= _150.d0;
    _158 += c;
    _158 *= _150.d1;
    _158 += _156;
    _158 *= _150.d2;
    _158 += _157;
    int64_t _159 = _150.data[_158];
    _149.d0 = _159;
    if (_159 > 0) 
    goto _jump704;
    fail_assertion("non-positive loop bound");
    _jump704:;
    // Computing bound for k
    _149.d1 = c;
    if (c > 0) 
    goto _jump705;
    fail_assertion("non-positive loop bound");
    _jump705:;
    // Computing bound for l
    int64_t _160;
    // Computing bound for j
    int64_t _161;
    // Computing bound for j
    if (d > 0) 
    goto _jump706;
    fail_assertion("non-positive loop bound");
    _jump706:;
    _161 = 0;
    int64_t _162 = 0; // j
    _jump707:; // Begin body of loop
    int64_t _163 = 883;
    _161 += _163;
    _162++;
    if (_162 < d)
    goto _jump707;
    // End body of loop
    if (_161 > 0) 
    goto _jump708;
    fail_assertion("non-positive loop bound");
    _jump708:;
    _160 = 0;
    int64_t _164 = 0; // j
    _jump709:; // Begin body of loop
    int64_t _165;
    // Computing bound for k
    int64_t _166 = 128;
    if (_166 > 0) 
    goto _jump710;
    fail_assertion("non-positive loop bound");
    _jump710:;
    _165 = 0;
    int64_t _167 = 0; // k
    _jump711:; // Begin body of loop
    _165 += c;
    _167++;
    if (_167 < _166)
    goto _jump711;
    // End body of loop
    _160 += _165;
    _164++;
    if (_164 < _161)
    goto _jump709;
    // End body of loop
    _149.d2 = _160;
    if (_160 > 0) 
    goto _jump712;
    fail_assertion("non-positive loop bound");
    _jump712:;
    // Computing total size of heap memory to allocate
    int64_t _168 = 1;
    _168 *= _159;
    _168 *= c;
    _168 *= _160;
    _168 *= sizeof(_a3_bool);
    _149.data = jpl_alloc(_168);
    int64_t _169 = 0; // l
    int64_t _170 = 0; // k
    int64_t _171 = 0; // j
    _jump713:; // Begin body of loop
    _a3_bool _172;
    // Computing bound for m
    _172.d0 = _171;
    if (_171 > 0) 
    goto _jump714;
    fail_assertion("non-positive loop bound");
    _jump714:;
    // Computing bound for n
    _172.d1 = _171;
    if (_171 > 0) 
    goto _jump715;
    fail_assertion("non-positive loop bound");
    _jump715:;
    // Computing bound for o
    _172.d2 = _170;
    if (_170 > 0) 
    goto _jump716;
    fail_assertion("non-positive loop bound");
    _jump716:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= _171;
    _173 *= _171;
    _173 *= _170;
    _173 *= sizeof(bool);
    _172.data = jpl_alloc(_173);
    int64_t _174 = 0; // o
    int64_t _175 = 0; // n
    int64_t _176 = 0; // m
    _jump717:; // Begin body of loop
    bool _177 = _0;
    if (0 == _0)
    goto _jump718;
    _177 = _0;
    _jump718:;
    int64_t _178 = 0;
    _178 *= _172.d0;
    _178 += _176;
    _178 *= _172.d1;
    _178 += _175;
    _178 *= _172.d2;
    _178 += _174;
    _172.data[_178] = _177;
    _174++;
    if (_174 < _170)
    goto _jump717;
    _174 = 0;
    _175++;
    if (_175 < _171)
    goto _jump717;
    _175 = 0;
    _176++;
    if (_176 < _171)
    goto _jump717;
    // End body of loop
    int64_t _179 = 0;
    _179 *= _149.d0;
    _179 += _171;
    _179 *= _149.d1;
    _179 += _170;
    _179 *= _149.d2;
    _179 += _169;
    _149.data[_179] = _172;
    _169++;
    if (_169 < _160)
    goto _jump713;
    _169 = 0;
    _170++;
    if (_170 < c)
    goto _jump713;
    _170 = 0;
    _171++;
    if (_171 < _159)
    goto _jump713;
    // End body of loop
    _117 = _149;
    _jump693:;
    _107 = _117;
    goto _jump719;
    _jump667:;
    _a3__a3_bool _180;
    // Computing bound for j
    int64_t _181 = -d;
    _180.d0 = _181;
    if (_181 > 0) 
    goto _jump720;
    fail_assertion("non-positive loop bound");
    _jump720:;
    // Computing bound for k
    int64_t _182;
    // Computing bound for j
    if (d > 0) 
    goto _jump721;
    fail_assertion("non-positive loop bound");
    _jump721:;
    // Computing bound for k
    int64_t _183 = 907;
    if (_183 > 0) 
    goto _jump722;
    fail_assertion("non-positive loop bound");
    _jump722:;
    // Computing bound for l
    int64_t _184 = d % c;
    int64_t _185;
    // Computing bound for j
    if (c > 0) 
    goto _jump723;
    fail_assertion("non-positive loop bound");
    _jump723:;
    _185 = 0;
    int64_t _186 = 0; // j
    _jump724:; // Begin body of loop
    _185 += d;
    _186++;
    if (_186 < c)
    goto _jump724;
    // End body of loop
    int64_t _187 = _184 / _185;
    if (_187 > 0) 
    goto _jump725;
    fail_assertion("non-positive loop bound");
    _jump725:;
    _182 = 0;
    int64_t _188 = 0; // l
    int64_t _189 = 0; // k
    int64_t _190 = 0; // j
    _jump726:; // Begin body of loop
    int64_t _191 = d + _190;
    int64_t _192 = -_191;
    _182 += _192;
    _188++;
    if (_188 < _187)
    goto _jump726;
    _188 = 0;
    _189++;
    if (_189 < _183)
    goto _jump726;
    _189 = 0;
    _190++;
    if (_190 < d)
    goto _jump726;
    // End body of loop
    _180.d1 = _182;
    if (_182 > 0) 
    goto _jump727;
    fail_assertion("non-positive loop bound");
    _jump727:;
    // Computing bound for l
    int64_t _193;
    // Computing bound for j
    int64_t _194;
    // Computing bound for j
    if (c > 0) 
    goto _jump728;
    fail_assertion("non-positive loop bound");
    _jump728:;
    // Computing bound for k
    int64_t _195 = 90;
    if (_195 > 0) 
    goto _jump729;
    fail_assertion("non-positive loop bound");
    _jump729:;
    // Computing bound for l
    int64_t _196 = 333;
    if (_196 > 0) 
    goto _jump730;
    fail_assertion("non-positive loop bound");
    _jump730:;
    _194 = 0;
    int64_t _197 = 0; // l
    int64_t _198 = 0; // k
    int64_t _199 = 0; // j
    _jump731:; // Begin body of loop
    int64_t _200 = 453;
    _194 += _200;
    _197++;
    if (_197 < _196)
    goto _jump731;
    _197 = 0;
    _198++;
    if (_198 < _195)
    goto _jump731;
    _198 = 0;
    _199++;
    if (_199 < c)
    goto _jump731;
    // End body of loop
    if (_194 > 0) 
    goto _jump732;
    fail_assertion("non-positive loop bound");
    _jump732:;
    _193 = 0;
    int64_t _201 = 0; // j
    _jump733:; // Begin body of loop
    int64_t _202 = 709;
    _193 += _202;
    _201++;
    if (_201 < _194)
    goto _jump733;
    // End body of loop
    _180.d2 = _193;
    if (_193 > 0) 
    goto _jump734;
    fail_assertion("non-positive loop bound");
    _jump734:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= _181;
    _203 *= _182;
    _203 *= _193;
    _203 *= sizeof(_a3_bool);
    _180.data = jpl_alloc(_203);
    int64_t _204 = 0; // l
    int64_t _205 = 0; // k
    int64_t _206 = 0; // j
    _jump735:; // Begin body of loop
    _a3_bool _207;
    // Computing bound for m
    int64_t _208 = _204 * c;
    _207.d0 = _208;
    if (_208 > 0) 
    goto _jump736;
    fail_assertion("non-positive loop bound");
    _jump736:;
    // Computing bound for n
    _207.d1 = d;
    if (d > 0) 
    goto _jump737;
    fail_assertion("non-positive loop bound");
    _jump737:;
    // Computing bound for o
    int64_t _209;
    if (!_0)
    goto _jump738;
    _209 = _206;
    goto _jump739;
    _jump738:;
    _209 = _205;
    _jump739:;
    _207.d2 = _209;
    if (_209 > 0) 
    goto _jump740;
    fail_assertion("non-positive loop bound");
    _jump740:;
    // Computing total size of heap memory to allocate
    int64_t _210 = 1;
    _210 *= _208;
    _210 *= d;
    _210 *= _209;
    _210 *= sizeof(bool);
    _207.data = jpl_alloc(_210);
    int64_t _211 = 0; // o
    int64_t _212 = 0; // n
    int64_t _213 = 0; // m
    _jump741:; // Begin body of loop
    _a2_bool _214;
    // Computing bound for p
    _214.d0 = _212;
    if (_212 > 0) 
    goto _jump742;
    fail_assertion("non-positive loop bound");
    _jump742:;
    // Computing bound for q
    _214.d1 = _205;
    if (_205 > 0) 
    goto _jump743;
    fail_assertion("non-positive loop bound");
    _jump743:;
    // Computing total size of heap memory to allocate
    int64_t _215 = 1;
    _215 *= _212;
    _215 *= _205;
    _215 *= sizeof(bool);
    _214.data = jpl_alloc(_215);
    int64_t _216 = 0; // q
    int64_t _217 = 0; // p
    _jump744:; // Begin body of loop
    bool _218 = true;
    int64_t _219 = 0;
    _219 *= _214.d0;
    _219 += _217;
    _219 *= _214.d1;
    _219 += _216;
    _214.data[_219] = _218;
    _216++;
    if (_216 < _205)
    goto _jump744;
    _216 = 0;
    _217++;
    if (_217 < _212)
    goto _jump744;
    // End body of loop
    if (_206 >= 0)
    goto _jump745;
    fail_assertion("negative array index");
    _jump745:;
    if (_206 < _214.d0)
    goto _jump746;
    fail_assertion("index too large");
    _jump746:;
    if (c >= 0)
    goto _jump747;
    fail_assertion("negative array index");
    _jump747:;
    if (c < _214.d1)
    goto _jump748;
    fail_assertion("index too large");
    _jump748:;
    int64_t _220 = 0;
    _220 *= _214.d0;
    _220 += _206;
    _220 *= _214.d1;
    _220 += c;
    bool _221 = _214.data[_220];
    int64_t _222 = 0;
    _222 *= _207.d0;
    _222 += _213;
    _222 *= _207.d1;
    _222 += _212;
    _222 *= _207.d2;
    _222 += _211;
    _207.data[_222] = _221;
    _211++;
    if (_211 < _209)
    goto _jump741;
    _211 = 0;
    _212++;
    if (_212 < d)
    goto _jump741;
    _212 = 0;
    _213++;
    if (_213 < _208)
    goto _jump741;
    // End body of loop
    int64_t _223 = 0;
    _223 *= _180.d0;
    _223 += _206;
    _223 *= _180.d1;
    _223 += _205;
    _223 *= _180.d2;
    _223 += _204;
    _180.data[_223] = _207;
    _204++;
    if (_204 < _193)
    goto _jump735;
    _204 = 0;
    _205++;
    if (_205 < _182)
    goto _jump735;
    _205 = 0;
    _206++;
    if (_206 < _181)
    goto _jump735;
    // End body of loop
    _107 = _180;
    _jump719:;
    bool _225 = !_0;
    bool _226;
    if (!_225)
    goto _jump749;
    bool _228 = false;
    bool _227 = _228;
    if (0 == _228)
    goto _jump750;
    _227 = _0;
    _jump750:;
    _226 = _227;
    goto _jump751;
    _jump749:;
    bool _229 = true;
    _226 = _229;
    _jump751:;
    bool _224 = _226;
    if (0 == _226)
    goto _jump752;
    _224 = _0;
    _jump752:;
    bool _230;
    if (!_224)
    goto _jump753;
    int64_t _231 = 783;
    bool _232 = _231 != c;
    bool _233;
    if (!_232)
    goto _jump754;
    bool _234 = true;
    _233 = _234;
    goto _jump755;
    _jump754:;
    bool _235 = false;
    bool _236 = !_235;
    bool _237 = !_236;
    _233 = _237;
    _jump755:;
    _230 = _233;
    goto _jump756;
    _jump753:;
    bool _238 = c <= c;
    _230 = _238;
    _jump756:;
    int64_t _239;
    if (!_230)
    goto _jump757;
    int64_t _240 = 990;
    _239 = _240;
    goto _jump758;
    _jump757:;
    int64_t _241 = 11;
    _239 = _241;
    _jump758:;
    _a1_int64_t _242;
    if (!_0)
    goto _jump759;
    _a1_int64_t _243;
    if (!_0)
    goto _jump760;
    bool _244 = false;
    _a1_int64_t _245;
    if (!_244)
    goto _jump761;
    _a1_int64_t _246;
    // Computing bound for j
    _246.d0 = c;
    if (c > 0) 
    goto _jump762;
    fail_assertion("non-positive loop bound");
    _jump762:;
    // Computing total size of heap memory to allocate
    int64_t _247 = 1;
    _247 *= c;
    _247 *= sizeof(int64_t);
    _246.data = jpl_alloc(_247);
    int64_t _248 = 0; // j
    _jump763:; // Begin body of loop
    int64_t _249 = 0;
    _249 *= _246.d0;
    _249 += _248;
    _246.data[_249] = _248;
    _248++;
    if (_248 < c)
    goto _jump763;
    // End body of loop
    _245 = _246;
    goto _jump764;
    _jump761:;
    int64_t _250 = 993;
    _a1_int64_t _251;
    _251.d0 = 2;
    _251.data = jpl_alloc(sizeof(int64_t) * 2);
    _251.data[0] = c;
    _251.data[1] = _250;
    _245 = _251;
    _jump764:;
    _243 = _245;
    goto _jump765;
    _jump760:;
    int64_t _252 = 174;
    int64_t _253 = 41;
    _a1_int64_t _254;
    _254.d0 = 3;
    _254.data = jpl_alloc(sizeof(int64_t) * 3);
    _254.data[0] = _252;
    _254.data[1] = _253;
    _254.data[2] = d;
    _243 = _254;
    _jump765:;
    _242 = _243;
    goto _jump766;
    _jump759:;
    int64_t _255;
    // Computing bound for j
    int64_t _256 = 430;
    if (_256 > 0) 
    goto _jump767;
    fail_assertion("non-positive loop bound");
    _jump767:;
    _255 = 0;
    int64_t _257 = 0; // j
    _jump768:; // Begin body of loop
    int64_t _258 = 93;
    if (c >= 0)
    goto _jump769;
    fail_assertion("negative array index");
    _jump769:;
    if (c < b.d0)
    goto _jump770;
    fail_assertion("index too large");
    _jump770:;
    if (_258 >= 0)
    goto _jump771;
    fail_assertion("negative array index");
    _jump771:;
    if (_258 < b.d1)
    goto _jump772;
    fail_assertion("index too large");
    _jump772:;
    int64_t _259 = 0;
    _259 *= b.d0;
    _259 += c;
    _259 *= b.d1;
    _259 += _258;
    int64_t _260 = b.data[_259];
    _255 += _260;
    _257++;
    if (_257 < _256)
    goto _jump768;
    // End body of loop
    int64_t _261 = 289;
    int64_t _262 = _261 + d;
    int64_t _263 = 438;
    _a1_int64_t _264;
    _264.d0 = 3;
    _264.data = jpl_alloc(sizeof(int64_t) * 3);
    _264.data[0] = _255;
    _264.data[1] = _262;
    _264.data[2] = _263;
    _242 = _264;
    _jump766:;
    _a3__a2_int64_t _265;
    // Computing bound for j
    _265.d0 = d;
    if (d > 0) 
    goto _jump773;
    fail_assertion("non-positive loop bound");
    _jump773:;
    // Computing bound for k
    int64_t _266;
    // Computing bound for j
    if (d > 0) 
    goto _jump774;
    fail_assertion("non-positive loop bound");
    _jump774:;
    // Computing bound for k
    if (d > 0) 
    goto _jump775;
    fail_assertion("non-positive loop bound");
    _jump775:;
    // Computing bound for l
    int64_t _267 = 708;
    if (_267 > 0) 
    goto _jump776;
    fail_assertion("non-positive loop bound");
    _jump776:;
    _266 = 0;
    int64_t _268 = 0; // l
    int64_t _269 = 0; // k
    int64_t _270 = 0; // j
    _jump777:; // Begin body of loop
    _266 += _268;
    _268++;
    if (_268 < _267)
    goto _jump777;
    _268 = 0;
    _269++;
    if (_269 < d)
    goto _jump777;
    _269 = 0;
    _270++;
    if (_270 < d)
    goto _jump777;
    // End body of loop
    _265.d1 = _266;
    if (_266 > 0) 
    goto _jump778;
    fail_assertion("non-positive loop bound");
    _jump778:;
    // Computing bound for l
    _265.d2 = d;
    if (d > 0) 
    goto _jump779;
    fail_assertion("non-positive loop bound");
    _jump779:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= d;
    _271 *= _266;
    _271 *= d;
    _271 *= sizeof(_a2_int64_t);
    _265.data = jpl_alloc(_271);
    int64_t _272 = 0; // l
    int64_t _273 = 0; // k
    int64_t _274 = 0; // j
    _jump780:; // Begin body of loop
    int64_t _275 = 0;
    _275 *= _265.d0;
    _275 += _274;
    _275 *= _265.d1;
    _275 += _273;
    _275 *= _265.d2;
    _275 += _272;
    _265.data[_275] = b;
    _272++;
    if (_272 < d)
    goto _jump780;
    _272 = 0;
    _273++;
    if (_273 < _266)
    goto _jump780;
    _273 = 0;
    _274++;
    if (_274 < d)
    goto _jump780;
    // End body of loop
    int64_t _276 = 432;
    int64_t _277 = 602;
    _a1_int64_t _278;
    _278.d0 = 2;
    _278.data = jpl_alloc(sizeof(int64_t) * 2);
    _278.data[0] = _276;
    _278.data[1] = _277;
    if (d >= 0)
    goto _jump781;
    fail_assertion("negative array index");
    _jump781:;
    if (d < _278.d0)
    goto _jump782;
    fail_assertion("index too large");
    _jump782:;
    int64_t _279 = 0;
    _279 *= _278.d0;
    _279 += d;
    int64_t _280 = _278.data[_279];
    int64_t _281 = -d;
    int64_t _282 = d / _281;
    int64_t _283 = 623;
    int64_t _284 = c / c;
    if (_283 >= 0)
    goto _jump783;
    fail_assertion("negative array index");
    _jump783:;
    if (_283 < b.d0)
    goto _jump784;
    fail_assertion("index too large");
    _jump784:;
    if (_284 >= 0)
    goto _jump785;
    fail_assertion("negative array index");
    _jump785:;
    if (_284 < b.d1)
    goto _jump786;
    fail_assertion("index too large");
    _jump786:;
    int64_t _285 = 0;
    _285 *= b.d0;
    _285 += _283;
    _285 *= b.d1;
    _285 += _284;
    int64_t _286 = b.data[_285];
    if (_280 >= 0)
    goto _jump787;
    fail_assertion("negative array index");
    _jump787:;
    if (_280 < _265.d0)
    goto _jump788;
    fail_assertion("index too large");
    _jump788:;
    if (_282 >= 0)
    goto _jump789;
    fail_assertion("negative array index");
    _jump789:;
    if (_282 < _265.d1)
    goto _jump790;
    fail_assertion("index too large");
    _jump790:;
    if (_286 >= 0)
    goto _jump791;
    fail_assertion("negative array index");
    _jump791:;
    if (_286 < _265.d2)
    goto _jump792;
    fail_assertion("index too large");
    _jump792:;
    int64_t _287 = 0;
    _287 *= _265.d0;
    _287 += _280;
    _287 *= _265.d1;
    _287 += _282;
    _287 *= _265.d2;
    _287 += _286;
    _a2_int64_t _288 = _265.data[_287];
    int64_t _289 = -c;
    int64_t _290 = _289 % c;
    int64_t _291 = 887;
    int64_t _292 = _291 / d;
    int64_t _293 = -_292;
    int64_t _294 = _293 * d;
    if (_290 >= 0)
    goto _jump793;
    fail_assertion("negative array index");
    _jump793:;
    if (_290 < _288.d0)
    goto _jump794;
    fail_assertion("index too large");
    _jump794:;
    if (_294 >= 0)
    goto _jump795;
    fail_assertion("negative array index");
    _jump795:;
    if (_294 < _288.d1)
    goto _jump796;
    fail_assertion("index too large");
    _jump796:;
    int64_t _295 = 0;
    _295 *= _288.d0;
    _295 += _290;
    _295 *= _288.d1;
    _295 += _294;
    int64_t _296 = _288.data[_295];
    if (_296 >= 0)
    goto _jump797;
    fail_assertion("negative array index");
    _jump797:;
    if (_296 < _242.d0)
    goto _jump798;
    fail_assertion("index too large");
    _jump798:;
    int64_t _297 = 0;
    _297 *= _242.d0;
    _297 += _296;
    int64_t _298 = _242.data[_297];
    int64_t _299 = 717;
    if (_239 >= 0)
    goto _jump799;
    fail_assertion("negative array index");
    _jump799:;
    if (_239 < _107.d0)
    goto _jump800;
    fail_assertion("index too large");
    _jump800:;
    if (_298 >= 0)
    goto _jump801;
    fail_assertion("negative array index");
    _jump801:;
    if (_298 < _107.d1)
    goto _jump802;
    fail_assertion("index too large");
    _jump802:;
    if (_299 >= 0)
    goto _jump803;
    fail_assertion("negative array index");
    _jump803:;
    if (_299 < _107.d2)
    goto _jump804;
    fail_assertion("index too large");
    _jump804:;
    int64_t _300 = 0;
    _300 *= _107.d0;
    _300 += _239;
    _300 *= _107.d1;
    _300 += _298;
    _300 *= _107.d2;
    _300 += _299;
    _a3_bool _301 = _107.data[_300];
    _96 = _301;
    _jump666:;
    _a1__a3_bool _302;
    // Computing bound for n
    int64_t _303 = 342;
    _302.d0 = _303;
    if (_303 > 0) 
    goto _jump805;
    fail_assertion("non-positive loop bound");
    _jump805:;
    // Computing total size of heap memory to allocate
    int64_t _304 = 1;
    _304 *= _303;
    _304 *= sizeof(_a3_bool);
    _302.data = jpl_alloc(_304);
    int64_t _305 = 0; // n
    _jump806:; // Begin body of loop
    bool _306 = true;
    _a3_bool _307;
    if (!_306)
    goto _jump807;
    _307 = _96;
    goto _jump808;
    _jump807:;
    _a3__a2__a3_bool _308;
    // Computing bound for o
    _308.d0 = c;
    if (c > 0) 
    goto _jump809;
    fail_assertion("non-positive loop bound");
    _jump809:;
    // Computing bound for p
    _308.d1 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump810;
    fail_assertion("non-positive loop bound");
    _jump810:;
    // Computing bound for q
    int64_t _309 = _96.d0 / _305;
    _308.d2 = _309;
    if (_309 > 0) 
    goto _jump811;
    fail_assertion("non-positive loop bound");
    _jump811:;
    // Computing total size of heap memory to allocate
    int64_t _310 = 1;
    _310 *= c;
    _310 *= _96.d0;
    _310 *= _309;
    _310 *= sizeof(_a2__a3_bool);
    _308.data = jpl_alloc(_310);
    int64_t _311 = 0; // q
    int64_t _312 = 0; // p
    int64_t _313 = 0; // o
    _jump812:; // Begin body of loop
    _a2__a3_bool _314;
    // Computing bound for r
    _314.d0 = _305;
    if (_305 > 0) 
    goto _jump813;
    fail_assertion("non-positive loop bound");
    _jump813:;
    // Computing bound for s
    _314.d1 = _96.d1;
    if (_96.d1 > 0) 
    goto _jump814;
    fail_assertion("non-positive loop bound");
    _jump814:;
    // Computing total size of heap memory to allocate
    int64_t _315 = 1;
    _315 *= _305;
    _315 *= _96.d1;
    _315 *= sizeof(_a3_bool);
    _314.data = jpl_alloc(_315);
    int64_t _316 = 0; // s
    int64_t _317 = 0; // r
    _jump815:; // Begin body of loop
    int64_t _318 = 0;
    _318 *= _314.d0;
    _318 += _317;
    _318 *= _314.d1;
    _318 += _316;
    _314.data[_318] = _96;
    _316++;
    if (_316 < _96.d1)
    goto _jump815;
    _316 = 0;
    _317++;
    if (_317 < _305)
    goto _jump815;
    // End body of loop
    int64_t _319 = 0;
    _319 *= _308.d0;
    _319 += _313;
    _319 *= _308.d1;
    _319 += _312;
    _319 *= _308.d2;
    _319 += _311;
    _308.data[_319] = _314;
    _311++;
    if (_311 < _309)
    goto _jump812;
    _311 = 0;
    _312++;
    if (_312 < _96.d0)
    goto _jump812;
    _312 = 0;
    _313++;
    if (_313 < c)
    goto _jump812;
    // End body of loop
    int64_t _320 = -_96.d1;
    int64_t _321 = -_320;
    _a3_int64_t _322;
    // Computing bound for o
    _322.d0 = _96.d2;
    if (_96.d2 > 0) 
    goto _jump816;
    fail_assertion("non-positive loop bound");
    _jump816:;
    // Computing bound for p
    _322.d1 = c;
    if (c > 0) 
    goto _jump817;
    fail_assertion("non-positive loop bound");
    _jump817:;
    // Computing bound for q
    int64_t _323 = -_96.d0;
    _322.d2 = _323;
    if (_323 > 0) 
    goto _jump818;
    fail_assertion("non-positive loop bound");
    _jump818:;
    // Computing total size of heap memory to allocate
    int64_t _324 = 1;
    _324 *= _96.d2;
    _324 *= c;
    _324 *= _323;
    _324 *= sizeof(int64_t);
    _322.data = jpl_alloc(_324);
    int64_t _325 = 0; // q
    int64_t _326 = 0; // p
    int64_t _327 = 0; // o
    _jump819:; // Begin body of loop
    int64_t _328 = 0;
    _328 *= _322.d0;
    _328 += _327;
    _328 *= _322.d1;
    _328 += _326;
    _328 *= _322.d2;
    _328 += _325;
    _322.data[_328] = _326;
    _325++;
    if (_325 < _323)
    goto _jump819;
    _325 = 0;
    _326++;
    if (_326 < c)
    goto _jump819;
    _326 = 0;
    _327++;
    if (_327 < _96.d2)
    goto _jump819;
    // End body of loop
    int64_t _329 = 817;
    bool _330 = false;
    bool _331;
    if (!_330)
    goto _jump820;
    bool _332 = false;
    _331 = _332;
    goto _jump821;
    _jump820:;
    _331 = _0;
    _jump821:;
    int64_t _333;
    if (!_331)
    goto _jump822;
    int64_t _334 = -c;
    _333 = _334;
    goto _jump823;
    _jump822:;
    int64_t _335 = 77;
    int64_t _336 = _335 * _305;
    _333 = _336;
    _jump823:;
    if (_96.d1 >= 0)
    goto _jump824;
    fail_assertion("negative array index");
    _jump824:;
    if (_96.d1 < _322.d0)
    goto _jump825;
    fail_assertion("index too large");
    _jump825:;
    if (_329 >= 0)
    goto _jump826;
    fail_assertion("negative array index");
    _jump826:;
    if (_329 < _322.d1)
    goto _jump827;
    fail_assertion("index too large");
    _jump827:;
    if (_333 >= 0)
    goto _jump828;
    fail_assertion("negative array index");
    _jump828:;
    if (_333 < _322.d2)
    goto _jump829;
    fail_assertion("index too large");
    _jump829:;
    int64_t _337 = 0;
    _337 *= _322.d0;
    _337 += _96.d1;
    _337 *= _322.d1;
    _337 += _329;
    _337 *= _322.d2;
    _337 += _333;
    int64_t _338 = _322.data[_337];
    if (_321 >= 0)
    goto _jump830;
    fail_assertion("negative array index");
    _jump830:;
    if (_321 < _308.d0)
    goto _jump831;
    fail_assertion("index too large");
    _jump831:;
    if (_338 >= 0)
    goto _jump832;
    fail_assertion("negative array index");
    _jump832:;
    if (_338 < _308.d1)
    goto _jump833;
    fail_assertion("index too large");
    _jump833:;
    if (_96.d2 >= 0)
    goto _jump834;
    fail_assertion("negative array index");
    _jump834:;
    if (_96.d2 < _308.d2)
    goto _jump835;
    fail_assertion("index too large");
    _jump835:;
    int64_t _339 = 0;
    _339 *= _308.d0;
    _339 += _321;
    _339 *= _308.d1;
    _339 += _338;
    _339 *= _308.d2;
    _339 += _96.d2;
    _a2__a3_bool _340 = _308.data[_339];
    int64_t _341 = 388;
    int64_t _342 = _96.d1 - _96.d0;
    if (_341 >= 0)
    goto _jump836;
    fail_assertion("negative array index");
    _jump836:;
    if (_341 < _340.d0)
    goto _jump837;
    fail_assertion("index too large");
    _jump837:;
    if (_342 >= 0)
    goto _jump838;
    fail_assertion("negative array index");
    _jump838:;
    if (_342 < _340.d1)
    goto _jump839;
    fail_assertion("index too large");
    _jump839:;
    int64_t _343 = 0;
    _343 *= _340.d0;
    _343 += _341;
    _343 *= _340.d1;
    _343 += _342;
    _a3_bool _344 = _340.data[_343];
    _307 = _344;
    _jump808:;
    int64_t _345 = 0;
    _345 *= _302.d0;
    _345 += _305;
    _302.data[_345] = _307;
    _305++;
    if (_305 < _303)
    goto _jump806;
    // End body of loop
    _a1_int64_t _346;
    // Computing bound for q
    _a2_int64_t _347;
    // Computing bound for q
    _347.d0 = _96.d1;
    if (_96.d1 > 0) 
    goto _jump840;
    fail_assertion("non-positive loop bound");
    _jump840:;
    // Computing bound for r
    _347.d1 = _302.d0;
    if (_302.d0 > 0) 
    goto _jump841;
    fail_assertion("non-positive loop bound");
    _jump841:;
    // Computing total size of heap memory to allocate
    int64_t _348 = 1;
    _348 *= _96.d1;
    _348 *= _302.d0;
    _348 *= sizeof(int64_t);
    _347.data = jpl_alloc(_348);
    int64_t _349 = 0; // r
    int64_t _350 = 0; // q
    _jump842:; // Begin body of loop
    int64_t _351;
    // Computing bound for s
    if (_96.d1 > 0) 
    goto _jump843;
    fail_assertion("non-positive loop bound");
    _jump843:;
    _351 = 0;
    int64_t _352 = 0; // s
    _jump844:; // Begin body of loop
    _351 += _352;
    _352++;
    if (_352 < _96.d1)
    goto _jump844;
    // End body of loop
    int64_t _353 = 0;
    _353 *= _347.d0;
    _353 += _350;
    _353 *= _347.d1;
    _353 += _349;
    _347.data[_353] = _351;
    _349++;
    if (_349 < _302.d0)
    goto _jump842;
    _349 = 0;
    _350++;
    if (_350 < _96.d1)
    goto _jump842;
    // End body of loop
    if (d >= 0)
    goto _jump845;
    fail_assertion("negative array index");
    _jump845:;
    if (d < _302.d0)
    goto _jump846;
    fail_assertion("index too large");
    _jump846:;
    int64_t _354 = 0;
    _354 *= _302.d0;
    _354 += d;
    _a3_bool _355 = _302.data[_354];
    int64_t _356 = -c;
    int64_t _357 = -_96.d0;
    int64_t _358 = -d;
    int64_t _359 = _357 - _358;
    int64_t _360 = -_359;
    if (d >= 0)
    goto _jump847;
    fail_assertion("negative array index");
    _jump847:;
    if (d < _355.d0)
    goto _jump848;
    fail_assertion("index too large");
    _jump848:;
    if (_356 >= 0)
    goto _jump849;
    fail_assertion("negative array index");
    _jump849:;
    if (_356 < _355.d1)
    goto _jump850;
    fail_assertion("index too large");
    _jump850:;
    if (_360 >= 0)
    goto _jump851;
    fail_assertion("negative array index");
    _jump851:;
    if (_360 < _355.d2)
    goto _jump852;
    fail_assertion("index too large");
    _jump852:;
    int64_t _361 = 0;
    _361 *= _355.d0;
    _361 += d;
    _361 *= _355.d1;
    _361 += _356;
    _361 *= _355.d2;
    _361 += _360;
    bool _362 = _355.data[_361];
    int64_t _363;
    if (!_362)
    goto _jump853;
    _363 = _96.d2;
    goto _jump854;
    _jump853:;
    _363 = d;
    _jump854:;
    if (_363 >= 0)
    goto _jump855;
    fail_assertion("negative array index");
    _jump855:;
    if (_363 < _347.d0)
    goto _jump856;
    fail_assertion("index too large");
    _jump856:;
    if (d >= 0)
    goto _jump857;
    fail_assertion("negative array index");
    _jump857:;
    if (d < _347.d1)
    goto _jump858;
    fail_assertion("index too large");
    _jump858:;
    int64_t _364 = 0;
    _364 *= _347.d0;
    _364 += _363;
    _364 *= _347.d1;
    _364 += d;
    int64_t _365 = _347.data[_364];
    _346.d0 = _365;
    if (_365 > 0) 
    goto _jump859;
    fail_assertion("non-positive loop bound");
    _jump859:;
    // Computing total size of heap memory to allocate
    int64_t _366 = 1;
    _366 *= _365;
    _366 *= sizeof(int64_t);
    _346.data = jpl_alloc(_366);
    int64_t _367 = 0; // q
    _jump860:; // Begin body of loop
    int64_t _368 = 0;
    _368 *= _346.d0;
    _368 += _367;
    _346.data[_368] = _302.d0;
    _367++;
    if (_367 < _365)
    goto _jump860;
    // End body of loop
    bool _369 = _346.d0 == _302.d0;
    bool _370 = false;
    bool _371;
    if (!_370)
    goto _jump861;
    a _372 = h();
    double _373 = _372.b;
    double _374 = 87.0;
    double _375 = -_374;
    double _376 = _373 - _375;
    double _377 = 51.0;
    bool _378 = _376 > _377;
    bool _379 = !_378;
    _371 = _379;
    goto _jump862;
    _jump861:;
    bool _380 = false;
    _a1_bool _381;
    _381.d0 = 1;
    _381.data = jpl_alloc(sizeof(bool) * 1);
    _381.data[0] = _380;
    if (c >= 0)
    goto _jump863;
    fail_assertion("negative array index");
    _jump863:;
    if (c < _381.d0)
    goto _jump864;
    fail_assertion("index too large");
    _jump864:;
    int64_t _382 = 0;
    _382 *= _381.d0;
    _382 += c;
    bool _383 = _381.data[_382];
    _371 = _383;
    _jump862:;
    _a2_a _384;
    if (!_371)
    goto _jump865;
    _a2_a _385;
    // Computing bound for t
    int64_t _386;
    // Computing bound for t
    if (_96.d2 > 0) 
    goto _jump866;
    fail_assertion("non-positive loop bound");
    _jump866:;
    _386 = 0;
    int64_t _387 = 0; // t
    _jump867:; // Begin body of loop
    _a3_int64_t _388;
    // Computing bound for u
    int64_t _389 = -_346.d0;
    _388.d0 = _389;
    if (_389 > 0) 
    goto _jump868;
    fail_assertion("non-positive loop bound");
    _jump868:;
    // Computing bound for v
    int64_t _390 = 377;
    _388.d1 = _390;
    if (_390 > 0) 
    goto _jump869;
    fail_assertion("non-positive loop bound");
    _jump869:;
    // Computing bound for w
    _388.d2 = _346.d0;
    if (_346.d0 > 0) 
    goto _jump870;
    fail_assertion("non-positive loop bound");
    _jump870:;
    // Computing total size of heap memory to allocate
    int64_t _391 = 1;
    _391 *= _389;
    _391 *= _390;
    _391 *= _346.d0;
    _391 *= sizeof(int64_t);
    _388.data = jpl_alloc(_391);
    int64_t _392 = 0; // w
    int64_t _393 = 0; // v
    int64_t _394 = 0; // u
    _jump871:; // Begin body of loop
    int64_t _395 = 0;
    _395 *= _388.d0;
    _395 += _394;
    _395 *= _388.d1;
    _395 += _393;
    _395 *= _388.d2;
    _395 += _392;
    _388.data[_395] = _394;
    _392++;
    if (_392 < _346.d0)
    goto _jump871;
    _392 = 0;
    _393++;
    if (_393 < _390)
    goto _jump871;
    _393 = 0;
    _394++;
    if (_394 < _389)
    goto _jump871;
    // End body of loop
    if (d >= 0)
    goto _jump872;
    fail_assertion("negative array index");
    _jump872:;
    if (d < _388.d0)
    goto _jump873;
    fail_assertion("index too large");
    _jump873:;
    if (_96.d2 >= 0)
    goto _jump874;
    fail_assertion("negative array index");
    _jump874:;
    if (_96.d2 < _388.d1)
    goto _jump875;
    fail_assertion("index too large");
    _jump875:;
    if (_302.d0 >= 0)
    goto _jump876;
    fail_assertion("negative array index");
    _jump876:;
    if (_302.d0 < _388.d2)
    goto _jump877;
    fail_assertion("index too large");
    _jump877:;
    int64_t _396 = 0;
    _396 *= _388.d0;
    _396 += d;
    _396 *= _388.d1;
    _396 += _96.d2;
    _396 *= _388.d2;
    _396 += _302.d0;
    int64_t _397 = _388.data[_396];
    _386 += _397;
    _387++;
    if (_387 < _96.d2)
    goto _jump867;
    // End body of loop
    _385.d0 = _386;
    if (_386 > 0) 
    goto _jump878;
    fail_assertion("non-positive loop bound");
    _jump878:;
    // Computing bound for u
    _385.d1 = d;
    if (d > 0) 
    goto _jump879;
    fail_assertion("non-positive loop bound");
    _jump879:;
    // Computing total size of heap memory to allocate
    int64_t _398 = 1;
    _398 *= _386;
    _398 *= d;
    _398 *= sizeof(a);
    _385.data = jpl_alloc(_398);
    int64_t _399 = 0; // u
    int64_t _400 = 0; // t
    _jump880:; // Begin body of loop
    a _401;
    if (!_0)
    goto _jump881;
    a _402 = h();
    _401 = _402;
    goto _jump882;
    _jump881:;
    bool _403 = true;
    a _404;
    if (!_403)
    goto _jump883;
    a _405 = h();
    _404 = _405;
    goto _jump884;
    _jump883:;
    bool _406 = true;
    a _407;
    if (!_406)
    goto _jump885;
    a _408 = h();
    _407 = _408;
    goto _jump886;
    _jump885:;
    a _409 = h();
    _407 = _409;
    _jump886:;
    _404 = _407;
    _jump884:;
    _401 = _404;
    _jump882:;
    int64_t _410 = 0;
    _410 *= _385.d0;
    _410 += _400;
    _410 *= _385.d1;
    _410 += _399;
    _385.data[_410] = _401;
    _399++;
    if (_399 < d)
    goto _jump880;
    _399 = 0;
    _400++;
    if (_400 < _386)
    goto _jump880;
    // End body of loop
    _384 = _385;
    goto _jump887;
    _jump865:;
    bool _411 = false;
    bool _412 = !_411;
    _a2_a _413;
    if (!_412)
    goto _jump888;
    _a2_a _414;
    if (!_369)
    goto _jump889;
    _a3__a2_a _415;
    // Computing bound for t
    _415.d0 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump890;
    fail_assertion("non-positive loop bound");
    _jump890:;
    // Computing bound for u
    int64_t _416 = 689;
    _415.d1 = _416;
    if (_416 > 0) 
    goto _jump891;
    fail_assertion("non-positive loop bound");
    _jump891:;
    // Computing bound for v
    int64_t _417 = 617;
    _415.d2 = _417;
    if (_417 > 0) 
    goto _jump892;
    fail_assertion("non-positive loop bound");
    _jump892:;
    // Computing total size of heap memory to allocate
    int64_t _418 = 1;
    _418 *= _96.d0;
    _418 *= _416;
    _418 *= _417;
    _418 *= sizeof(_a2_a);
    _415.data = jpl_alloc(_418);
    int64_t _419 = 0; // v
    int64_t _420 = 0; // u
    int64_t _421 = 0; // t
    _jump893:; // Begin body of loop
    _a2_a _422;
    // Computing bound for w
    _422.d0 = _96.d2;
    if (_96.d2 > 0) 
    goto _jump894;
    fail_assertion("non-positive loop bound");
    _jump894:;
    // Computing bound for x
    _422.d1 = _420;
    if (_420 > 0) 
    goto _jump895;
    fail_assertion("non-positive loop bound");
    _jump895:;
    // Computing total size of heap memory to allocate
    int64_t _423 = 1;
    _423 *= _96.d2;
    _423 *= _420;
    _423 *= sizeof(a);
    _422.data = jpl_alloc(_423);
    int64_t _424 = 0; // x
    int64_t _425 = 0; // w
    _jump896:; // Begin body of loop
    a _426 = h();
    int64_t _427 = 0;
    _427 *= _422.d0;
    _427 += _425;
    _427 *= _422.d1;
    _427 += _424;
    _422.data[_427] = _426;
    _424++;
    if (_424 < _420)
    goto _jump896;
    _424 = 0;
    _425++;
    if (_425 < _96.d2)
    goto _jump896;
    // End body of loop
    int64_t _428 = 0;
    _428 *= _415.d0;
    _428 += _421;
    _428 *= _415.d1;
    _428 += _420;
    _428 *= _415.d2;
    _428 += _419;
    _415.data[_428] = _422;
    _419++;
    if (_419 < _417)
    goto _jump893;
    _419 = 0;
    _420++;
    if (_420 < _416)
    goto _jump893;
    _420 = 0;
    _421++;
    if (_421 < _96.d0)
    goto _jump893;
    // End body of loop
    if (c >= 0)
    goto _jump897;
    fail_assertion("negative array index");
    _jump897:;
    if (c < _415.d0)
    goto _jump898;
    fail_assertion("index too large");
    _jump898:;
    if (_96.d2 >= 0)
    goto _jump899;
    fail_assertion("negative array index");
    _jump899:;
    if (_96.d2 < _415.d1)
    goto _jump900;
    fail_assertion("index too large");
    _jump900:;
    if (d >= 0)
    goto _jump901;
    fail_assertion("negative array index");
    _jump901:;
    if (d < _415.d2)
    goto _jump902;
    fail_assertion("index too large");
    _jump902:;
    int64_t _429 = 0;
    _429 *= _415.d0;
    _429 += c;
    _429 *= _415.d1;
    _429 += _96.d2;
    _429 *= _415.d2;
    _429 += d;
    _a2_a _430 = _415.data[_429];
    _414 = _430;
    goto _jump903;
    _jump889:;
    _a2_a _431;
    // Computing bound for t
    _431.d0 = _96.d0;
    if (_96.d0 > 0) 
    goto _jump904;
    fail_assertion("non-positive loop bound");
    _jump904:;
    // Computing bound for u
    bool _432 = false;
    int64_t _433;
    if (!_432)
    goto _jump905;
    _433 = _96.d1;
    goto _jump906;
    _jump905:;
    int64_t _434 = 328;
    _433 = _434;
    _jump906:;
    if (d >= 0)
    goto _jump907;
    fail_assertion("negative array index");
    _jump907:;
    if (d < b.d0)
    goto _jump908;
    fail_assertion("index too large");
    _jump908:;
    if (_433 >= 0)
    goto _jump909;
    fail_assertion("negative array index");
    _jump909:;
    if (_433 < b.d1)
    goto _jump910;
    fail_assertion("index too large");
    _jump910:;
    int64_t _435 = 0;
    _435 *= b.d0;
    _435 += d;
    _435 *= b.d1;
    _435 += _433;
    int64_t _436 = b.data[_435];
    _431.d1 = _436;
    if (_436 > 0) 
    goto _jump911;
    fail_assertion("non-positive loop bound");
    _jump911:;
    // Computing total size of heap memory to allocate
    int64_t _437 = 1;
    _437 *= _96.d0;
    _437 *= _436;
    _437 *= sizeof(a);
    _431.data = jpl_alloc(_437);
    int64_t _438 = 0; // u
    int64_t _439 = 0; // t
    _jump912:; // Begin body of loop
    a _440 = h();
    int64_t _441 = 0;
    _441 *= _431.d0;
    _441 += _439;
    _441 *= _431.d1;
    _441 += _438;
    _431.data[_441] = _440;
    _438++;
    if (_438 < _436)
    goto _jump912;
    _438 = 0;
    _439++;
    if (_439 < _96.d0)
    goto _jump912;
    // End body of loop
    _414 = _431;
    _jump903:;
    _413 = _414;
    goto _jump913;
    _jump888:;
    _a2__a2_a _442;
    // Computing bound for t
    int64_t _443 = c % _96.d2;
    _442.d0 = _443;
    if (_443 > 0) 
    goto _jump914;
    fail_assertion("non-positive loop bound");
    _jump914:;
    // Computing bound for u
    _442.d1 = d;
    if (d > 0) 
    goto _jump915;
    fail_assertion("non-positive loop bound");
    _jump915:;
    // Computing total size of heap memory to allocate
    int64_t _444 = 1;
    _444 *= _443;
    _444 *= d;
    _444 *= sizeof(_a2_a);
    _442.data = jpl_alloc(_444);
    int64_t _445 = 0; // u
    int64_t _446 = 0; // t
    _jump916:; // Begin body of loop
    _a2_a _447;
    // Computing bound for v
    _447.d0 = _302.d0;
    if (_302.d0 > 0) 
    goto _jump917;
    fail_assertion("non-positive loop bound");
    _jump917:;
    // Computing bound for w
    int64_t _448 = 38;
    _447.d1 = _448;
    if (_448 > 0) 
    goto _jump918;
    fail_assertion("non-positive loop bound");
    _jump918:;
    // Computing total size of heap memory to allocate
    int64_t _449 = 1;
    _449 *= _302.d0;
    _449 *= _448;
    _449 *= sizeof(a);
    _447.data = jpl_alloc(_449);
    int64_t _450 = 0; // w
    int64_t _451 = 0; // v
    _jump919:; // Begin body of loop
    a _452 = h();
    int64_t _453 = 0;
    _453 *= _447.d0;
    _453 += _451;
    _453 *= _447.d1;
    _453 += _450;
    _447.data[_453] = _452;
    _450++;
    if (_450 < _448)
    goto _jump919;
    _450 = 0;
    _451++;
    if (_451 < _302.d0)
    goto _jump919;
    // End body of loop
    int64_t _454 = 0;
    _454 *= _442.d0;
    _454 += _446;
    _454 *= _442.d1;
    _454 += _445;
    _442.data[_454] = _447;
    _445++;
    if (_445 < d)
    goto _jump916;
    _445 = 0;
    _446++;
    if (_446 < _443)
    goto _jump916;
    // End body of loop
    if (_346.d0 >= 0)
    goto _jump920;
    fail_assertion("negative array index");
    _jump920:;
    if (_346.d0 < _442.d0)
    goto _jump921;
    fail_assertion("index too large");
    _jump921:;
    if (_96.d1 >= 0)
    goto _jump922;
    fail_assertion("negative array index");
    _jump922:;
    if (_96.d1 < _442.d1)
    goto _jump923;
    fail_assertion("index too large");
    _jump923:;
    int64_t _455 = 0;
    _455 *= _442.d0;
    _455 += _346.d0;
    _455 *= _442.d1;
    _455 += _96.d1;
    _a2_a _456 = _442.data[_455];
    _413 = _456;
    _jump913:;
    _384 = _413;
    _jump887:;
    if (d >= 0)
    goto _jump924;
    fail_assertion("negative array index");
    _jump924:;
    if (d < _384.d0)
    goto _jump925;
    fail_assertion("index too large");
    _jump925:;
    if (_96.d1 >= 0)
    goto _jump926;
    fail_assertion("negative array index");
    _jump926:;
    if (_96.d1 < _384.d1)
    goto _jump927;
    fail_assertion("index too large");
    _jump927:;
    int64_t _457 = 0;
    _457 *= _384.d0;
    _457 += d;
    _457 *= _384.d1;
    _457 += _96.d1;
    a _458 = _384.data[_457];
    return _458;
}

_a1_int64_t i(int64_t j, _a1_rgba k, a m) {
    bool _0 = false;
    bool _1;
    if (!_0)
    goto _jump928;
    bool _3 = true;
    bool _2 = _3;
    if (0 == _3)
    goto _jump929;
    bool _4 = true;
    _2 = _4;
    _jump929:;
    double _5 = g(_2);
    _a1_double _6;
    _6.d0 = 1;
    _6.data = jpl_alloc(sizeof(double) * 1);
    _6.data[0] = _5;
    _a1_int64_t _7;
    // Computing bound for n
    int64_t _8;
    // Computing bound for n
    if (k.d0 > 0) 
    goto _jump930;
    fail_assertion("non-positive loop bound");
    _jump930:;
    // Computing bound for o
    if (c > 0) 
    goto _jump931;
    fail_assertion("non-positive loop bound");
    _jump931:;
    // Computing bound for p
    if (d > 0) 
    goto _jump932;
    fail_assertion("non-positive loop bound");
    _jump932:;
    _8 = 0;
    int64_t _9 = 0; // p
    int64_t _10 = 0; // o
    int64_t _11 = 0; // n
    _jump933:; // Begin body of loop
    _8 += d;
    _9++;
    if (_9 < d)
    goto _jump933;
    _9 = 0;
    _10++;
    if (_10 < c)
    goto _jump933;
    _10 = 0;
    _11++;
    if (_11 < k.d0)
    goto _jump933;
    // End body of loop
    _7.d0 = _8;
    if (_8 > 0) 
    goto _jump934;
    fail_assertion("non-positive loop bound");
    _jump934:;
    // Computing total size of heap memory to allocate
    int64_t _12 = 1;
    _12 *= _8;
    _12 *= sizeof(int64_t);
    _7.data = jpl_alloc(_12);
    int64_t _13 = 0; // n
    _jump935:; // Begin body of loop
    int64_t _14 = 0;
    _14 *= _7.d0;
    _14 += _13;
    _7.data[_14] = k.d0;
    _13++;
    if (_13 < _8)
    goto _jump935;
    // End body of loop
    int64_t _15;
    // Computing bound for n
    int64_t _16 = 569;
    if (_16 > 0) 
    goto _jump936;
    fail_assertion("non-positive loop bound");
    _jump936:;
    // Computing bound for o
    if (c > 0) 
    goto _jump937;
    fail_assertion("non-positive loop bound");
    _jump937:;
    // Computing bound for p
    if (k.d0 > 0) 
    goto _jump938;
    fail_assertion("non-positive loop bound");
    _jump938:;
    _15 = 0;
    int64_t _17 = 0; // p
    int64_t _18 = 0; // o
    int64_t _19 = 0; // n
    _jump939:; // Begin body of loop
    _15 += _19;
    _17++;
    if (_17 < k.d0)
    goto _jump939;
    _17 = 0;
    _18++;
    if (_18 < c)
    goto _jump939;
    _18 = 0;
    _19++;
    if (_19 < _16)
    goto _jump939;
    // End body of loop
    if (_15 >= 0)
    goto _jump940;
    fail_assertion("negative array index");
    _jump940:;
    if (_15 < _7.d0)
    goto _jump941;
    fail_assertion("index too large");
    _jump941:;
    int64_t _20 = 0;
    _20 *= _7.d0;
    _20 += _15;
    int64_t _21 = _7.data[_20];
    if (_21 >= 0)
    goto _jump942;
    fail_assertion("negative array index");
    _jump942:;
    if (_21 < _6.d0)
    goto _jump943;
    fail_assertion("index too large");
    _jump943:;
    int64_t _22 = 0;
    _22 *= _6.d0;
    _22 += _21;
    double _23 = _6.data[_22];
    _a3_double _24;
    // Computing bound for n
    _24.d0 = j;
    if (j > 0) 
    goto _jump944;
    fail_assertion("non-positive loop bound");
    _jump944:;
    // Computing bound for o
    _24.d1 = k.d0;
    if (k.d0 > 0) 
    goto _jump945;
    fail_assertion("non-positive loop bound");
    _jump945:;
    // Computing bound for p
    _24.d2 = c;
    if (c > 0) 
    goto _jump946;
    fail_assertion("non-positive loop bound");
    _jump946:;
    // Computing total size of heap memory to allocate
    int64_t _25 = 1;
    _25 *= j;
    _25 *= k.d0;
    _25 *= c;
    _25 *= sizeof(double);
    _24.data = jpl_alloc(_25);
    int64_t _26 = 0; // p
    int64_t _27 = 0; // o
    int64_t _28 = 0; // n
    _jump947:; // Begin body of loop
    double _29;
    // Computing bound for q
    if (_28 > 0) 
    goto _jump948;
    fail_assertion("non-positive loop bound");
    _jump948:;
    // Computing bound for r
    if (j > 0) 
    goto _jump949;
    fail_assertion("non-positive loop bound");
    _jump949:;
    _29 = 0;
    int64_t _30 = 0; // r
    int64_t _31 = 0; // q
    _jump950:; // Begin body of loop
    double _32 = 72.0;
    _29 += _32;
    _30++;
    if (_30 < j)
    goto _jump950;
    _30 = 0;
    _31++;
    if (_31 < _28)
    goto _jump950;
    // End body of loop
    int64_t _33 = 0;
    _33 *= _24.d0;
    _33 += _28;
    _33 *= _24.d1;
    _33 += _27;
    _33 *= _24.d2;
    _33 += _26;
    _24.data[_33] = _29;
    _26++;
    if (_26 < c)
    goto _jump947;
    _26 = 0;
    _27++;
    if (_27 < k.d0)
    goto _jump947;
    _27 = 0;
    _28++;
    if (_28 < j)
    goto _jump947;
    // End body of loop
    int64_t _34 = -d;
    if (_34 >= 0)
    goto _jump951;
    fail_assertion("negative array index");
    _jump951:;
    if (_34 < b.d0)
    goto _jump952;
    fail_assertion("index too large");
    _jump952:;
    if (j >= 0)
    goto _jump953;
    fail_assertion("negative array index");
    _jump953:;
    if (j < b.d1)
    goto _jump954;
    fail_assertion("index too large");
    _jump954:;
    int64_t _35 = 0;
    _35 *= b.d0;
    _35 += _34;
    _35 *= b.d1;
    _35 += j;
    int64_t _36 = b.data[_35];
    bool _38 = true;
    bool _37 = _38;
    if (0 != _38)
    goto _jump955;
    bool _39 = true;
    _37 = _39;
    _jump955:;
    int64_t _40;
    if (!_37)
    goto _jump956;
    _40 = c;
    goto _jump957;
    _jump956:;
    _40 = c;
    _jump957:;
    if (d >= 0)
    goto _jump958;
    fail_assertion("negative array index");
    _jump958:;
    if (d < _24.d0)
    goto _jump959;
    fail_assertion("index too large");
    _jump959:;
    if (_36 >= 0)
    goto _jump960;
    fail_assertion("negative array index");
    _jump960:;
    if (_36 < _24.d1)
    goto _jump961;
    fail_assertion("index too large");
    _jump961:;
    if (_40 >= 0)
    goto _jump962;
    fail_assertion("negative array index");
    _jump962:;
    if (_40 < _24.d2)
    goto _jump963;
    fail_assertion("index too large");
    _jump963:;
    int64_t _41 = 0;
    _41 *= _24.d0;
    _41 += d;
    _41 *= _24.d1;
    _41 += _36;
    _41 *= _24.d2;
    _41 += _40;
    double _42 = _24.data[_41];
    double _43 = 8.0;
    double _44 = -_43;
    double _45 = _42 - _44;
    double _46 = _23 * _45;
    double _47 = 78.0;
    double _48;
    // Computing bound for n
    if (c > 0) 
    goto _jump964;
    fail_assertion("non-positive loop bound");
    _jump964:;
    // Computing bound for o
    if (d > 0) 
    goto _jump965;
    fail_assertion("non-positive loop bound");
    _jump965:;
    _48 = 0;
    int64_t _49 = 0; // o
    int64_t _50 = 0; // n
    _jump966:; // Begin body of loop
    double _51 = 80.0;
    _48 += _51;
    _49++;
    if (_49 < d)
    goto _jump966;
    _49 = 0;
    _50++;
    if (_50 < c)
    goto _jump966;
    // End body of loop
    double _52 = _47 / _48;
    if (k.d0 >= 0)
    goto _jump967;
    fail_assertion("negative array index");
    _jump967:;
    if (k.d0 < k.d0)
    goto _jump968;
    fail_assertion("index too large");
    _jump968:;
    int64_t _53 = 0;
    _53 *= k.d0;
    _53 += k.d0;
    rgba _54 = k.data[_53];
    double _55 = _54.b;
    double _56 = fmod(_52, _55);
    double _57 = 3.0;
    double _58 = 31.0;
    double _59;
    // Computing bound for n
    int64_t _60 = 648;
    _a1_int64_t _61;
    _61.d0 = 1;
    _61.data = jpl_alloc(sizeof(int64_t) * 1);
    _61.data[0] = _60;
    if (c >= 0)
    goto _jump969;
    fail_assertion("negative array index");
    _jump969:;
    if (c < _61.d0)
    goto _jump970;
    fail_assertion("index too large");
    _jump970:;
    int64_t _62 = 0;
    _62 *= _61.d0;
    _62 += c;
    int64_t _63 = _61.data[_62];
    if (_63 > 0) 
    goto _jump971;
    fail_assertion("non-positive loop bound");
    _jump971:;
    // Computing bound for o
    if (k.d0 > 0) 
    goto _jump972;
    fail_assertion("non-positive loop bound");
    _jump972:;
    _59 = 0;
    int64_t _64 = 0; // o
    int64_t _65 = 0; // n
    _jump973:; // Begin body of loop
    double _66;
    // Computing bound for p
    if (c > 0) 
    goto _jump974;
    fail_assertion("non-positive loop bound");
    _jump974:;
    _66 = 0;
    int64_t _67 = 0; // p
    _jump975:; // Begin body of loop
    bool _68 = true;
    double _69 = g(_68);
    _66 += _69;
    _67++;
    if (_67 < c)
    goto _jump975;
    // End body of loop
    _59 += _66;
    _64++;
    if (_64 < k.d0)
    goto _jump973;
    _64 = 0;
    _65++;
    if (_65 < _63)
    goto _jump973;
    // End body of loop
    rgba _70 = { _56, _57, _58, _59 };
    double _71 = _70.b;
    bool _72 = _46 == _71;
    _1 = _72;
    goto _jump976;
    _jump928:;
    double _73;
    // Computing bound for n
    int64_t _74;
    // Computing bound for n
    if (d > 0) 
    goto _jump977;
    fail_assertion("non-positive loop bound");
    _jump977:;
    // Computing bound for o
    int64_t _75 = 868;
    if (_75 > 0) 
    goto _jump978;
    fail_assertion("non-positive loop bound");
    _jump978:;
    _74 = 0;
    int64_t _76 = 0; // o
    int64_t _77 = 0; // n
    _jump979:; // Begin body of loop
    _74 += c;
    _76++;
    if (_76 < _75)
    goto _jump979;
    _76 = 0;
    _77++;
    if (_77 < d)
    goto _jump979;
    // End body of loop
    if (_74 > 0) 
    goto _jump980;
    fail_assertion("non-positive loop bound");
    _jump980:;
    _73 = 0;
    int64_t _78 = 0; // n
    _jump981:; // Begin body of loop
    double _79 = 36.0;
    _73 += _79;
    _78++;
    if (_78 < _74)
    goto _jump981;
    // End body of loop
    double _80 = 14.0;
    bool _81 = true;
    double _82;
    if (!_81)
    goto _jump982;
    a _83 = h();
    double _84 = _83.b;
    _82 = _84;
    goto _jump983;
    _jump982:;
    bool _85 = true;
    double _86 = g(_85);
    _82 = _86;
    _jump983:;
    double _87 = 77.0;
    double _88 = -_87;
    double _89;
    // Computing bound for n
    if (j > 0) 
    goto _jump984;
    fail_assertion("non-positive loop bound");
    _jump984:;
    // Computing bound for o
    if (d > 0) 
    goto _jump985;
    fail_assertion("non-positive loop bound");
    _jump985:;
    _89 = 0;
    int64_t _90 = 0; // o
    int64_t _91 = 0; // n
    _jump986:; // Begin body of loop
    double _92 = 3.0;
    _89 += _92;
    _90++;
    if (_90 < d)
    goto _jump986;
    _90 = 0;
    _91++;
    if (_91 < j)
    goto _jump986;
    // End body of loop
    double _93 = _88 * _89;
    rgba _94 = { _73, _80, _82, _93 };
    double _95 = _94.r;
    double _96 = 54.0;
    bool _97 = _95 >= _96;
    bool _98;
    if (!_97)
    goto _jump987;
    int64_t _99 = 506;
    int64_t _100 = 23;
    if (_99 >= 0)
    goto _jump988;
    fail_assertion("negative array index");
    _jump988:;
    if (_99 < b.d0)
    goto _jump989;
    fail_assertion("index too large");
    _jump989:;
    if (_100 >= 0)
    goto _jump990;
    fail_assertion("negative array index");
    _jump990:;
    if (_100 < b.d1)
    goto _jump991;
    fail_assertion("index too large");
    _jump991:;
    int64_t _101 = 0;
    _101 *= b.d0;
    _101 += _99;
    _101 *= b.d1;
    _101 += _100;
    int64_t _102 = b.data[_101];
    bool _103 = j > _102;
    int64_t _104;
    if (!_103)
    goto _jump992;
    int64_t _105 = 829;
    _104 = _105;
    goto _jump993;
    _jump992:;
    _104 = k.d0;
    _jump993:;
    int64_t _106;
    // Computing bound for n
    int64_t _107 = 344;
    if (_107 > 0) 
    goto _jump994;
    fail_assertion("non-positive loop bound");
    _jump994:;
    // Computing bound for o
    int64_t _108 = 27;
    int64_t _109 = _108 % k.d0;
    if (_109 > 0) 
    goto _jump995;
    fail_assertion("non-positive loop bound");
    _jump995:;
    _106 = 0;
    int64_t _110 = 0; // o
    int64_t _111 = 0; // n
    _jump996:; // Begin body of loop
    _106 += c;
    _110++;
    if (_110 < _109)
    goto _jump996;
    _110 = 0;
    _111++;
    if (_111 < _107)
    goto _jump996;
    // End body of loop
    bool _112 = _104 >= _106;
    _98 = _112;
    goto _jump997;
    _jump987:;
    bool _113 = true;
    _98 = _113;
    _jump997:;
    _1 = _98;
    _jump976:;
    double _114 = 34.0;
    bool _115 = false;
    double _116 = g(_115);
    bool _117 = _114 == _116;
    _a2_rgba _118;
    if (!_117)
    goto _jump998;
    _118 = e;
    goto _jump999;
    _jump998:;
    _118 = e;
    _jump999:;
    int64_t _119;
    // Computing bound for r
    if (d > 0) 
    goto _jump1000;
    fail_assertion("non-positive loop bound");
    _jump1000:;
    // Computing bound for s
    int64_t _120 = 761;
    int64_t _121 = -_120;
    int64_t _122 = j - _121;
    if (_122 > 0) 
    goto _jump1001;
    fail_assertion("non-positive loop bound");
    _jump1001:;
    _119 = 0;
    int64_t _123 = 0; // s
    int64_t _124 = 0; // r
    _jump1002:; // Begin body of loop
    _119 += k.d0;
    _123++;
    if (_123 < _122)
    goto _jump1002;
    _123 = 0;
    _124++;
    if (_124 < d)
    goto _jump1002;
    // End body of loop
    int64_t _125;
    if (!_1)
    goto _jump1003;
    int64_t _126 = e.d1 % j;
    _125 = _126;
    goto _jump1004;
    _jump1003:;
    int64_t _127;
    // Computing bound for r
    if (j > 0) 
    goto _jump1005;
    fail_assertion("non-positive loop bound");
    _jump1005:;
    // Computing bound for s
    if (e.d0 > 0) 
    goto _jump1006;
    fail_assertion("non-positive loop bound");
    _jump1006:;
    // Computing bound for t
    int64_t _128;
    // Computing bound for r
    if (c > 0) 
    goto _jump1007;
    fail_assertion("non-positive loop bound");
    _jump1007:;
    // Computing bound for s
    int64_t _129;
    // Computing bound for r
    int64_t _130 = 654;
    if (_130 > 0) 
    goto _jump1008;
    fail_assertion("non-positive loop bound");
    _jump1008:;
    _129 = 0;
    int64_t _131 = 0; // r
    _jump1009:; // Begin body of loop
    _129 += c;
    _131++;
    if (_131 < _130)
    goto _jump1009;
    // End body of loop
    if (_129 > 0) 
    goto _jump1010;
    fail_assertion("non-positive loop bound");
    _jump1010:;
    _128 = 0;
    int64_t _132 = 0; // s
    int64_t _133 = 0; // r
    _jump1011:; // Begin body of loop
    _128 += e.d1;
    _132++;
    if (_132 < _129)
    goto _jump1011;
    _132 = 0;
    _133++;
    if (_133 < c)
    goto _jump1011;
    // End body of loop
    if (_128 > 0) 
    goto _jump1012;
    fail_assertion("non-positive loop bound");
    _jump1012:;
    _127 = 0;
    int64_t _134 = 0; // t
    int64_t _135 = 0; // s
    int64_t _136 = 0; // r
    _jump1013:; // Begin body of loop
    _127 += d;
    _134++;
    if (_134 < _128)
    goto _jump1013;
    _134 = 0;
    _135++;
    if (_135 < e.d0)
    goto _jump1013;
    _135 = 0;
    _136++;
    if (_136 < j)
    goto _jump1013;
    // End body of loop
    _125 = _127;
    _jump1004:;
    if (_119 >= 0)
    goto _jump1014;
    fail_assertion("negative array index");
    _jump1014:;
    if (_119 < _118.d0)
    goto _jump1015;
    fail_assertion("index too large");
    _jump1015:;
    if (_125 >= 0)
    goto _jump1016;
    fail_assertion("negative array index");
    _jump1016:;
    if (_125 < _118.d1)
    goto _jump1017;
    fail_assertion("index too large");
    _jump1017:;
    int64_t _137 = 0;
    _137 *= _118.d0;
    _137 += _119;
    _137 *= _118.d1;
    _137 += _125;
    rgba _138 = _118.data[_137];
    double _140 = 66.0;
    double _141;
    // Computing bound for v
    if (e.d1 > 0) 
    goto _jump1018;
    fail_assertion("non-positive loop bound");
    _jump1018:;
    // Computing bound for w
    int64_t _142 = e.d0 % e.d1;
    if (_142 > 0) 
    goto _jump1019;
    fail_assertion("non-positive loop bound");
    _jump1019:;
    _141 = 0;
    int64_t _143 = 0; // w
    int64_t _144 = 0; // v
    _jump1020:; // Begin body of loop
    double _145 = 10.0;
    double _146 = 58.0;
    double _147 = _145 / _146;
    _141 += _147;
    _143++;
    if (_143 < _142)
    goto _jump1020;
    _143 = 0;
    _144++;
    if (_144 < e.d1)
    goto _jump1020;
    // End body of loop
    bool _148 = _140 == _141;
    bool _139 = _148;
    if (0 != _148)
    goto _jump1021;
    bool _149 = !_1;
    bool _150 = _1;
    if (0 != _1)
    goto _jump1022;
    _150 = _1;
    _jump1022:;
    bool _151 = _149 != _150;
    _139 = _151;
    _jump1021:;
    bool _152 = _1 != _139;
    _a2__a1_rgba _153;
    if (!_152)
    goto _jump1023;
    _a2__a1_rgba _154;
    // Computing bound for v
    _154.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump1024;
    fail_assertion("non-positive loop bound");
    _jump1024:;
    // Computing bound for w
    _154.d1 = k.d0;
    if (k.d0 > 0) 
    goto _jump1025;
    fail_assertion("non-positive loop bound");
    _jump1025:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= e.d0;
    _155 *= k.d0;
    _155 *= sizeof(_a1_rgba);
    _154.data = jpl_alloc(_155);
    int64_t _156 = 0; // w
    int64_t _157 = 0; // v
    _jump1026:; // Begin body of loop
    int64_t _158 = 0;
    _158 *= _154.d0;
    _158 += _157;
    _158 *= _154.d1;
    _158 += _156;
    _154.data[_158] = k;
    _156++;
    if (_156 < k.d0)
    goto _jump1026;
    _156 = 0;
    _157++;
    if (_157 < e.d0)
    goto _jump1026;
    // End body of loop
    _153 = _154;
    goto _jump1027;
    _jump1023:;
    _a1__a2__a1_rgba _159;
    // Computing bound for v
    _159.d0 = k.d0;
    if (k.d0 > 0) 
    goto _jump1028;
    fail_assertion("non-positive loop bound");
    _jump1028:;
    // Computing total size of heap memory to allocate
    int64_t _160 = 1;
    _160 *= k.d0;
    _160 *= sizeof(_a2__a1_rgba);
    _159.data = jpl_alloc(_160);
    int64_t _161 = 0; // v
    _jump1029:; // Begin body of loop
    _a2__a1_rgba _162;
    // Computing bound for w
    _162.d0 = e.d0;
    if (e.d0 > 0) 
    goto _jump1030;
    fail_assertion("non-positive loop bound");
    _jump1030:;
    // Computing bound for x
    _162.d1 = _161;
    if (_161 > 0) 
    goto _jump1031;
    fail_assertion("non-positive loop bound");
    _jump1031:;
    // Computing total size of heap memory to allocate
    int64_t _163 = 1;
    _163 *= e.d0;
    _163 *= _161;
    _163 *= sizeof(_a1_rgba);
    _162.data = jpl_alloc(_163);
    int64_t _164 = 0; // x
    int64_t _165 = 0; // w
    _jump1032:; // Begin body of loop
    int64_t _166 = 0;
    _166 *= _162.d0;
    _166 += _165;
    _166 *= _162.d1;
    _166 += _164;
    _162.data[_166] = k;
    _164++;
    if (_164 < _161)
    goto _jump1032;
    _164 = 0;
    _165++;
    if (_165 < e.d0)
    goto _jump1032;
    // End body of loop
    int64_t _167 = 0;
    _167 *= _159.d0;
    _167 += _161;
    _159.data[_167] = _162;
    _161++;
    if (_161 < k.d0)
    goto _jump1029;
    // End body of loop
    if (d >= 0)
    goto _jump1033;
    fail_assertion("negative array index");
    _jump1033:;
    if (d < _159.d0)
    goto _jump1034;
    fail_assertion("index too large");
    _jump1034:;
    int64_t _168 = 0;
    _168 *= _159.d0;
    _168 += d;
    _a2__a1_rgba _169 = _159.data[_168];
    _a2__a1_rgba _170;
    // Computing bound for v
    int64_t _171;
    // Computing bound for v
    if (e.d0 > 0) 
    goto _jump1035;
    fail_assertion("non-positive loop bound");
    _jump1035:;
    // Computing bound for w
    if (c > 0) 
    goto _jump1036;
    fail_assertion("non-positive loop bound");
    _jump1036:;
    _171 = 0;
    int64_t _172 = 0; // w
    int64_t _173 = 0; // v
    _jump1037:; // Begin body of loop
    _171 += _173;
    _172++;
    if (_172 < c)
    goto _jump1037;
    _172 = 0;
    _173++;
    if (_173 < e.d0)
    goto _jump1037;
    // End body of loop
    _170.d0 = _171;
    if (_171 > 0) 
    goto _jump1038;
    fail_assertion("non-positive loop bound");
    _jump1038:;
    // Computing bound for w
    int64_t _174;
    // Computing bound for v
    bool _175 = true;
    int64_t _176;
    if (!_175)
    goto _jump1039;
    _176 = d;
    goto _jump1040;
    _jump1039:;
    _176 = e.d1;
    _jump1040:;
    if (_176 > 0) 
    goto _jump1041;
    fail_assertion("non-positive loop bound");
    _jump1041:;
    // Computing bound for w
    int64_t _177 = j / e.d1;
    if (_177 > 0) 
    goto _jump1042;
    fail_assertion("non-positive loop bound");
    _jump1042:;
    _174 = 0;
    int64_t _178 = 0; // w
    int64_t _179 = 0; // v
    _jump1043:; // Begin body of loop
    _174 += e.d0;
    _178++;
    if (_178 < _177)
    goto _jump1043;
    _178 = 0;
    _179++;
    if (_179 < _176)
    goto _jump1043;
    // End body of loop
    _170.d1 = _174;
    if (_174 > 0) 
    goto _jump1044;
    fail_assertion("non-positive loop bound");
    _jump1044:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= _171;
    _180 *= _174;
    _180 *= sizeof(_a1_rgba);
    _170.data = jpl_alloc(_180);
    int64_t _181 = 0; // w
    int64_t _182 = 0; // v
    _jump1045:; // Begin body of loop
    if (e.d1 >= 0)
    goto _jump1046;
    fail_assertion("negative array index");
    _jump1046:;
    if (e.d1 < e.d0)
    goto _jump1047;
    fail_assertion("index too large");
    _jump1047:;
    if (d >= 0)
    goto _jump1048;
    fail_assertion("negative array index");
    _jump1048:;
    if (d < e.d1)
    goto _jump1049;
    fail_assertion("index too large");
    _jump1049:;
    int64_t _183 = 0;
    _183 *= e.d0;
    _183 += e.d1;
    _183 *= e.d1;
    _183 += d;
    rgba _184 = e.data[_183];
    _a1_rgba _185;
    _185.d0 = 2;
    _185.data = jpl_alloc(sizeof(rgba) * 2);
    _185.data[0] = _184;
    _185.data[1] = _138;
    int64_t _186 = 0;
    _186 *= _170.d0;
    _186 += _182;
    _186 *= _170.d1;
    _186 += _181;
    _170.data[_186] = _185;
    _181++;
    if (_181 < _174)
    goto _jump1045;
    _181 = 0;
    _182++;
    if (_182 < _171)
    goto _jump1045;
    // End body of loop
    _a1__a2__a1_rgba _187;
    _187.d0 = 2;
    _187.data = jpl_alloc(sizeof(_a2__a1_rgba) * 2);
    _187.data[0] = _169;
    _187.data[1] = _170;
    if (e.d0 >= 0)
    goto _jump1050;
    fail_assertion("negative array index");
    _jump1050:;
    if (e.d0 < _187.d0)
    goto _jump1051;
    fail_assertion("index too large");
    _jump1051:;
    int64_t _188 = 0;
    _188 *= _187.d0;
    _188 += e.d0;
    _a2__a1_rgba _189 = _187.data[_188];
    _153 = _189;
    _jump1027:;
    int64_t _190 = 935;
    if (_190 >= 0)
    goto _jump1052;
    fail_assertion("negative array index");
    _jump1052:;
    if (_190 < _153.d0)
    goto _jump1053;
    fail_assertion("index too large");
    _jump1053:;
    if (e.d1 >= 0)
    goto _jump1054;
    fail_assertion("negative array index");
    _jump1054:;
    if (e.d1 < _153.d1)
    goto _jump1055;
    fail_assertion("index too large");
    _jump1055:;
    int64_t _191 = 0;
    _191 *= _153.d0;
    _191 += _190;
    _191 *= _153.d1;
    _191 += e.d1;
    _a1_rgba _192 = _153.data[_191];
    _a3_rgba _193;
    // Computing bound for x
    int64_t _194;
    // Computing bound for x
    if (e.d0 > 0) 
    goto _jump1056;
    fail_assertion("non-positive loop bound");
    _jump1056:;
    _194 = 0;
    int64_t _195 = 0; // x
    _jump1057:; // Begin body of loop
    _194 += e.d0;
    _195++;
    if (_195 < e.d0)
    goto _jump1057;
    // End body of loop
    _193.d0 = _194;
    if (_194 > 0) 
    goto _jump1058;
    fail_assertion("non-positive loop bound");
    _jump1058:;
    // Computing bound for y
    _193.d1 = _192.d0;
    if (_192.d0 > 0) 
    goto _jump1059;
    fail_assertion("non-positive loop bound");
    _jump1059:;
    // Computing bound for z
    int64_t _196 = 245;
    _193.d2 = _196;
    if (_196 > 0) 
    goto _jump1060;
    fail_assertion("non-positive loop bound");
    _jump1060:;
    // Computing total size of heap memory to allocate
    int64_t _197 = 1;
    _197 *= _194;
    _197 *= _192.d0;
    _197 *= _196;
    _197 *= sizeof(rgba);
    _193.data = jpl_alloc(_197);
    int64_t _198 = 0; // z
    int64_t _199 = 0; // y
    int64_t _200 = 0; // x
    _jump1061:; // Begin body of loop
    bool _201 = _1;
    if (0 == _1)
    goto _jump1062;
    double _202 = g(_1);
    double _203 = _138.a;
    bool _204 = _202 >= _203;
    _201 = _204;
    _jump1062:;
    bool _205;
    if (!_201)
    goto _jump1063;
    a _206 = h();
    double _207 = _206.b;
    double _208 = 8.0;
    double _209 = fmod(_207, _208);
    double _210;
    // Computing bound for A
    if (e.d1 > 0) 
    goto _jump1064;
    fail_assertion("non-positive loop bound");
    _jump1064:;
    // Computing bound for B
    if (e.d0 > 0) 
    goto _jump1065;
    fail_assertion("non-positive loop bound");
    _jump1065:;
    // Computing bound for C
    if (_199 > 0) 
    goto _jump1066;
    fail_assertion("non-positive loop bound");
    _jump1066:;
    _210 = 0;
    int64_t _211 = 0; // C
    int64_t _212 = 0; // B
    int64_t _213 = 0; // A
    _jump1067:; // Begin body of loop
    double _214;
    if (!_1)
    goto _jump1068;
    double _215 = 18.0;
    _214 = _215;
    goto _jump1069;
    _jump1068:;
    double _216 = 86.0;
    _214 = _216;
    _jump1069:;
    _210 += _214;
    _211++;
    if (_211 < _199)
    goto _jump1067;
    _211 = 0;
    _212++;
    if (_212 < e.d0)
    goto _jump1067;
    _212 = 0;
    _213++;
    if (_213 < e.d1)
    goto _jump1067;
    // End body of loop
    bool _217 = _209 < _210;
    _205 = _217;
    goto _jump1070;
    _jump1063:;
    bool _218 = _1;
    if (0 != _1)
    goto _jump1071;
    double _219 = 57.0;
    double _220 = 98.0;
    double _221 = -_220;
    bool _222 = _219 != _221;
    _218 = _222;
    _jump1071:;
    _205 = _218;
    _jump1070:;
    rgba _223;
    if (!_205)
    goto _jump1072;
    _223 = _138;
    goto _jump1073;
    _jump1072:;
    bool _225 = !_1;
    bool _224 = _225;
    if (0 != _225)
    goto _jump1074;
    bool _226 = _192.d0 < c;
    bool _227 = !_226;
    _224 = _227;
    _jump1074:;
    rgba _228;
    if (!_224)
    goto _jump1075;
    if (e.d0 >= 0)
    goto _jump1076;
    fail_assertion("negative array index");
    _jump1076:;
    if (e.d0 < k.d0)
    goto _jump1077;
    fail_assertion("index too large");
    _jump1077:;
    int64_t _229 = 0;
    _229 *= k.d0;
    _229 += e.d0;
    rgba _230 = k.data[_229];
    double _231 = _230.a;
    rgba _232;
    if (!_1)
    goto _jump1078;
    _232 = _138;
    goto _jump1079;
    _jump1078:;
    _232 = _138;
    _jump1079:;
    double _233 = _232.a;
    rgba _234;
    if (!_1)
    goto _jump1080;
    _234 = _138;
    goto _jump1081;
    _jump1080:;
    _234 = _138;
    _jump1081:;
    double _235 = _234.a;
    double _236 = 38.0;
    rgba _237 = { _231, _233, _235, _236 };
    _228 = _237;
    goto _jump1082;
    _jump1075:;
    rgba _238;
    if (!_1)
    goto _jump1083;
    _a1_rgba _239;
    _239.d0 = 1;
    _239.data = jpl_alloc(sizeof(rgba) * 1);
    _239.data[0] = _138;
    if (c >= 0)
    goto _jump1084;
    fail_assertion("negative array index");
    _jump1084:;
    if (c < _239.d0)
    goto _jump1085;
    fail_assertion("index too large");
    _jump1085:;
    int64_t _240 = 0;
    _240 *= _239.d0;
    _240 += c;
    rgba _241 = _239.data[_240];
    _238 = _241;
    goto _jump1086;
    _jump1083:;
    double _242 = 66.0;
    double _243 = -_242;
    double _244 = g(_1);
    double _245 = 81.0;
    double _246 = _138.r;
    rgba _247 = { _243, _244, _245, _246 };
    _238 = _247;
    _jump1086:;
    _228 = _238;
    _jump1082:;
    _223 = _228;
    _jump1073:;
    int64_t _248 = 0;
    _248 *= _193.d0;
    _248 += _200;
    _248 *= _193.d1;
    _248 += _199;
    _248 *= _193.d2;
    _248 += _198;
    _193.data[_248] = _223;
    _198++;
    if (_198 < _196)
    goto _jump1061;
    _198 = 0;
    _199++;
    if (_199 < _192.d0)
    goto _jump1061;
    _199 = 0;
    _200++;
    if (_200 < _194)
    goto _jump1061;
    // End body of loop
    _a2_double _249 = f(_193);
    int64_t _250 = -e.d0;
    _a1_int64_t _251;
    _251.d0 = 3;
    _251.data = jpl_alloc(sizeof(int64_t) * 3);
    _251.data[0] = _249.d1;
    _251.data[1] = _250;
    _251.data[2] = e.d1;
    return _251;
}

int64_t l(int64_t m, _a3_void_t n, bool r) {
    _a3_double _0;
    // Computing bound for t
    bool _1 = false;
    int64_t _2;
    if (!_1)
    goto _jump1108;
    int64_t _3 = -j;
    _2 = _3;
    goto _jump1109;
    _jump1108:;
    int64_t _4 = 436;
    _2 = _4;
    _jump1109:;
    _0.d0 = _2;
    if (_2 > 0) 
    goto _jump1110;
    fail_assertion("non-positive loop bound");
    _jump1110:;
    // Computing bound for u
    _0.d1 = j;
    if (j > 0) 
    goto _jump1111;
    fail_assertion("non-positive loop bound");
    _jump1111:;
    // Computing bound for v
    bool _5 = r;
    if (0 != r)
    goto _jump1112;
    bool _6 = true;
    _5 = _6;
    _jump1112:;
    bool _7 = !_5;
    bool _8 = !_7;
    int64_t _9;
    if (!_8)
    goto _jump1113;
    _9 = n.d1;
    goto _jump1114;
    _jump1113:;
    int64_t _10 = 299;
    _9 = _10;
    _jump1114:;
    int64_t _11 = l(_9, n, r);
    _a3__a1__a3_void_t _12;
    // Computing bound for t
    int64_t _13;
    // Computing bound for t
    if (j > 0) 
    goto _jump1115;
    fail_assertion("non-positive loop bound");
    _jump1115:;
    // Computing bound for u
    int64_t _14;
    // Computing bound for t
    if (n.d0 > 0) 
    goto _jump1116;
    fail_assertion("non-positive loop bound");
    _jump1116:;
    // Computing bound for u
    if (m > 0) 
    goto _jump1117;
    fail_assertion("non-positive loop bound");
    _jump1117:;
    // Computing bound for v
    if (n.d0 > 0) 
    goto _jump1118;
    fail_assertion("non-positive loop bound");
    _jump1118:;
    _14 = 0;
    int64_t _15 = 0; // v
    int64_t _16 = 0; // u
    int64_t _17 = 0; // t
    _jump1119:; // Begin body of loop
    _14 += j;
    _15++;
    if (_15 < n.d0)
    goto _jump1119;
    _15 = 0;
    _16++;
    if (_16 < m)
    goto _jump1119;
    _16 = 0;
    _17++;
    if (_17 < n.d0)
    goto _jump1119;
    // End body of loop
    if (_14 > 0) 
    goto _jump1120;
    fail_assertion("non-positive loop bound");
    _jump1120:;
    // Computing bound for v
    if (n.d1 > 0) 
    goto _jump1121;
    fail_assertion("non-positive loop bound");
    _jump1121:;
    _13 = 0;
    int64_t _18 = 0; // v
    int64_t _19 = 0; // u
    int64_t _20 = 0; // t
    _jump1122:; // Begin body of loop
    _13 += c;
    _18++;
    if (_18 < n.d1)
    goto _jump1122;
    _18 = 0;
    _19++;
    if (_19 < _14)
    goto _jump1122;
    _19 = 0;
    _20++;
    if (_20 < j)
    goto _jump1122;
    // End body of loop
    _12.d0 = _13;
    if (_13 > 0) 
    goto _jump1123;
    fail_assertion("non-positive loop bound");
    _jump1123:;
    // Computing bound for u
    _12.d1 = d;
    if (d > 0) 
    goto _jump1124;
    fail_assertion("non-positive loop bound");
    _jump1124:;
    // Computing bound for v
    _12.d2 = d;
    if (d > 0) 
    goto _jump1125;
    fail_assertion("non-positive loop bound");
    _jump1125:;
    // Computing total size of heap memory to allocate
    int64_t _21 = 1;
    _21 *= _13;
    _21 *= d;
    _21 *= d;
    _21 *= sizeof(_a1__a3_void_t);
    _12.data = jpl_alloc(_21);
    int64_t _22 = 0; // v
    int64_t _23 = 0; // u
    int64_t _24 = 0; // t
    _jump1126:; // Begin body of loop
    _a1__a3_void_t _25;
    // Computing bound for w
    _25.d0 = _23;
    if (_23 > 0) 
    goto _jump1127;
    fail_assertion("non-positive loop bound");
    _jump1127:;
    // Computing total size of heap memory to allocate
    int64_t _26 = 1;
    _26 *= _23;
    _26 *= sizeof(_a3_void_t);
    _25.data = jpl_alloc(_26);
    int64_t _27 = 0; // w
    _jump1128:; // Begin body of loop
    int64_t _28 = 0;
    _28 *= _25.d0;
    _28 += _27;
    _25.data[_28] = n;
    _27++;
    if (_27 < _23)
    goto _jump1128;
    // End body of loop
    int64_t _29 = 0;
    _29 *= _12.d0;
    _29 += _24;
    _29 *= _12.d1;
    _29 += _23;
    _29 *= _12.d2;
    _29 += _22;
    _12.data[_29] = _25;
    _22++;
    if (_22 < d)
    goto _jump1126;
    _22 = 0;
    _23++;
    if (_23 < d)
    goto _jump1126;
    _23 = 0;
    _24++;
    if (_24 < _13)
    goto _jump1126;
    // End body of loop
    int64_t _30 = -j;
    if (j >= 0)
    goto _jump1129;
    fail_assertion("negative array index");
    _jump1129:;
    if (j < _12.d0)
    goto _jump1130;
    fail_assertion("index too large");
    _jump1130:;
    if (j >= 0)
    goto _jump1131;
    fail_assertion("negative array index");
    _jump1131:;
    if (j < _12.d1)
    goto _jump1132;
    fail_assertion("index too large");
    _jump1132:;
    if (_30 >= 0)
    goto _jump1133;
    fail_assertion("negative array index");
    _jump1133:;
    if (_30 < _12.d2)
    goto _jump1134;
    fail_assertion("index too large");
    _jump1134:;
    int64_t _31 = 0;
    _31 *= _12.d0;
    _31 += j;
    _31 *= _12.d1;
    _31 += j;
    _31 *= _12.d2;
    _31 += _30;
    _a1__a3_void_t _32 = _12.data[_31];
    if (j >= 0)
    goto _jump1135;
    fail_assertion("negative array index");
    _jump1135:;
    if (j < _32.d0)
    goto _jump1136;
    fail_assertion("index too large");
    _jump1136:;
    int64_t _33 = 0;
    _33 *= _32.d0;
    _33 += j;
    _a3_void_t _34 = _32.data[_33];
    bool _35 = j != m;
    int64_t _36 = l(_11, _34, _35);
    _0.d2 = _36;
    if (_36 > 0) 
    goto _jump1137;
    fail_assertion("non-positive loop bound");
    _jump1137:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _2;
    _37 *= j;
    _37 *= _36;
    _37 *= sizeof(double);
    _0.data = jpl_alloc(_37);
    int64_t _38 = 0; // v
    int64_t _39 = 0; // u
    int64_t _40 = 0; // t
    _jump1138:; // Begin body of loop
    bool _41 = n.d1 >= _38;
    double _42 = g(_41);
    double _43;
    // Computing bound for w
    bool _44 = true;
    bool _45 = false;
    bool _46 = _44 == _45;
    int64_t _47;
    if (!_46)
    goto _jump1139;
    _47 = m;
    goto _jump1140;
    _jump1139:;
    _47 = n.d0;
    _jump1140:;
    if (_47 > 0) 
    goto _jump1141;
    fail_assertion("non-positive loop bound");
    _jump1141:;
    // Computing bound for x
    if (d > 0) 
    goto _jump1142;
    fail_assertion("non-positive loop bound");
    _jump1142:;
    _43 = 0;
    int64_t _48 = 0; // x
    int64_t _49 = 0; // w
    _jump1143:; // Begin body of loop
    _a3_double _50;
    // Computing bound for y
    int64_t _51 = 488;
    int64_t _52 = -_51;
    _50.d0 = _52;
    if (_52 > 0) 
    goto _jump1144;
    fail_assertion("non-positive loop bound");
    _jump1144:;
    // Computing bound for z
    _50.d1 = n.d0;
    if (n.d0 > 0) 
    goto _jump1145;
    fail_assertion("non-positive loop bound");
    _jump1145:;
    // Computing bound for A
    _50.d2 = _40;
    if (_40 > 0) 
    goto _jump1146;
    fail_assertion("non-positive loop bound");
    _jump1146:;
    // Computing total size of heap memory to allocate
    int64_t _53 = 1;
    _53 *= _52;
    _53 *= n.d0;
    _53 *= _40;
    _53 *= sizeof(double);
    _50.data = jpl_alloc(_53);
    int64_t _54 = 0; // A
    int64_t _55 = 0; // z
    int64_t _56 = 0; // y
    _jump1147:; // Begin body of loop
    double _57 = 70.0;
    int64_t _58 = 0;
    _58 *= _50.d0;
    _58 += _56;
    _58 *= _50.d1;
    _58 += _55;
    _58 *= _50.d2;
    _58 += _54;
    _50.data[_58] = _57;
    _54++;
    if (_54 < _40)
    goto _jump1147;
    _54 = 0;
    _55++;
    if (_55 < n.d0)
    goto _jump1147;
    _55 = 0;
    _56++;
    if (_56 < _52)
    goto _jump1147;
    // End body of loop
    _a1_int64_t _59;
    // Computing bound for y
    _59.d0 = _48;
    if (_48 > 0) 
    goto _jump1148;
    fail_assertion("non-positive loop bound");
    _jump1148:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= _48;
    _60 *= sizeof(int64_t);
    _59.data = jpl_alloc(_60);
    int64_t _61 = 0; // y
    _jump1149:; // Begin body of loop
    int64_t _62 = 0;
    _62 *= _59.d0;
    _62 += _61;
    _59.data[_62] = n.d2;
    _61++;
    if (_61 < _48)
    goto _jump1149;
    // End body of loop
    if (m >= 0)
    goto _jump1150;
    fail_assertion("negative array index");
    _jump1150:;
    if (m < _59.d0)
    goto _jump1151;
    fail_assertion("index too large");
    _jump1151:;
    int64_t _63 = 0;
    _63 *= _59.d0;
    _63 += m;
    int64_t _64 = _59.data[_63];
    int64_t _65 = l(_64, n, k);
    int64_t _66 = 220;
    if (j >= 0)
    goto _jump1152;
    fail_assertion("negative array index");
    _jump1152:;
    if (j < _50.d0)
    goto _jump1153;
    fail_assertion("index too large");
    _jump1153:;
    if (_65 >= 0)
    goto _jump1154;
    fail_assertion("negative array index");
    _jump1154:;
    if (_65 < _50.d1)
    goto _jump1155;
    fail_assertion("index too large");
    _jump1155:;
    if (_66 >= 0)
    goto _jump1156;
    fail_assertion("negative array index");
    _jump1156:;
    if (_66 < _50.d2)
    goto _jump1157;
    fail_assertion("index too large");
    _jump1157:;
    int64_t _67 = 0;
    _67 *= _50.d0;
    _67 += j;
    _67 *= _50.d1;
    _67 += _65;
    _67 *= _50.d2;
    _67 += _66;
    double _68 = _50.data[_67];
    _43 += _68;
    _48++;
    if (_48 < d)
    goto _jump1143;
    _48 = 0;
    _49++;
    if (_49 < _47)
    goto _jump1143;
    // End body of loop
    double _69 = _42 / _43;
    int64_t _70 = 0;
    _70 *= _0.d0;
    _70 += _40;
    _70 *= _0.d1;
    _70 += _39;
    _70 *= _0.d2;
    _70 += _38;
    _0.data[_70] = _69;
    _38++;
    if (_38 < _36)
    goto _jump1138;
    _38 = 0;
    _39++;
    if (_39 < j)
    goto _jump1138;
    _39 = 0;
    _40++;
    if (_40 < _2)
    goto _jump1138;
    // End body of loop
    _a3__a1__a1_int64_t _71;
    // Computing bound for x
    int64_t _72 = j - m;
    _71.d0 = _72;
    if (_72 > 0) 
    goto _jump1158;
    fail_assertion("non-positive loop bound");
    _jump1158:;
    // Computing bound for y
    int64_t _73 = 141;
    _71.d1 = _73;
    if (_73 > 0) 
    goto _jump1159;
    fail_assertion("non-positive loop bound");
    _jump1159:;
    // Computing bound for z
    _71.d2 = n.d0;
    if (n.d0 > 0) 
    goto _jump1160;
    fail_assertion("non-positive loop bound");
    _jump1160:;
    // Computing total size of heap memory to allocate
    int64_t _74 = 1;
    _74 *= _72;
    _74 *= _73;
    _74 *= n.d0;
    _74 *= sizeof(_a1__a1_int64_t);
    _71.data = jpl_alloc(_74);
    int64_t _75 = 0; // z
    int64_t _76 = 0; // y
    int64_t _77 = 0; // x
    _jump1161:; // Begin body of loop
    double _78;
    // Computing bound for A
    if (c > 0) 
    goto _jump1162;
    fail_assertion("non-positive loop bound");
    _jump1162:;
    // Computing bound for B
    if (d > 0) 
    goto _jump1163;
    fail_assertion("non-positive loop bound");
    _jump1163:;
    // Computing bound for C
    if (_0.d2 > 0) 
    goto _jump1164;
    fail_assertion("non-positive loop bound");
    _jump1164:;
    _78 = 0;
    int64_t _79 = 0; // C
    int64_t _80 = 0; // B
    int64_t _81 = 0; // A
    _jump1165:; // Begin body of loop
    double _82 = 10.0;
    _78 += _82;
    _79++;
    if (_79 < _0.d2)
    goto _jump1165;
    _79 = 0;
    _80++;
    if (_80 < d)
    goto _jump1165;
    _80 = 0;
    _81++;
    if (_81 < c)
    goto _jump1165;
    // End body of loop
    double _83 = g(r);
    double _84 = 16.0;
    double _85 = -_84;
    double _86 = _83 * _85;
    bool _87 = _78 >= _86;
    _a1__a1_int64_t _88;
    if (!_87)
    goto _jump1166;
    _a1_int64_t _89;
    if (!r)
    goto _jump1167;
    _a1_int64_t _90;
    _90.d0 = 1;
    _90.data = jpl_alloc(sizeof(int64_t) * 1);
    _90.data[0] = m;
    _89 = _90;
    goto _jump1168;
    _jump1167:;
    _a1_int64_t _91;
    // Computing bound for A
    _91.d0 = _77;
    if (_77 > 0) 
    goto _jump1169;
    fail_assertion("non-positive loop bound");
    _jump1169:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= _77;
    _92 *= sizeof(int64_t);
    _91.data = jpl_alloc(_92);
    int64_t _93 = 0; // A
    _jump1170:; // Begin body of loop
    int64_t _94 = 0;
    _94 *= _91.d0;
    _94 += _93;
    _91.data[_94] = _0.d1;
    _93++;
    if (_93 < _77)
    goto _jump1170;
    // End body of loop
    _89 = _91;
    _jump1168:;
    _a1_int64_t _95;
    // Computing bound for A
    int64_t _96 = n.d0 * m;
    _95.d0 = _96;
    if (_96 > 0) 
    goto _jump1171;
    fail_assertion("non-positive loop bound");
    _jump1171:;
    // Computing total size of heap memory to allocate
    int64_t _97 = 1;
    _97 *= _96;
    _97 *= sizeof(int64_t);
    _95.data = jpl_alloc(_97);
    int64_t _98 = 0; // A
    _jump1172:; // Begin body of loop
    int64_t _99 = 787;
    int64_t _100 = 0;
    _100 *= _95.d0;
    _100 += _98;
    _95.data[_100] = _99;
    _98++;
    if (_98 < _96)
    goto _jump1172;
    // End body of loop
    _a1_int64_t _101;
    _101.d0 = 1;
    _101.data = jpl_alloc(sizeof(int64_t) * 1);
    _101.data[0] = _0.d2;
    _a1__a1_int64_t _102;
    _102.d0 = 3;
    _102.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _102.data[0] = _89;
    _102.data[1] = _95;
    _102.data[2] = _101;
    _88 = _102;
    goto _jump1173;
    _jump1166:;
    bool _103 = k != r;
    bool _104;
    if (!_103)
    goto _jump1174;
    bool _105 = true;
    _104 = _105;
    goto _jump1175;
    _jump1174:;
    bool _106 = true;
    _104 = _106;
    _jump1175:;
    _a1__a1_int64_t _107;
    if (!_104)
    goto _jump1176;
    _a1_int64_t _108;
    // Computing bound for A
    _108.d0 = _77;
    if (_77 > 0) 
    goto _jump1177;
    fail_assertion("non-positive loop bound");
    _jump1177:;
    // Computing total size of heap memory to allocate
    int64_t _109 = 1;
    _109 *= _77;
    _109 *= sizeof(int64_t);
    _108.data = jpl_alloc(_109);
    int64_t _110 = 0; // A
    _jump1178:; // Begin body of loop
    int64_t _111 = 0;
    _111 *= _108.d0;
    _111 += _110;
    _108.data[_111] = n.d2;
    _110++;
    if (_110 < _77)
    goto _jump1178;
    // End body of loop
    _a1_int64_t _112;
    // Computing bound for A
    int64_t _113 = 402;
    _112.d0 = _113;
    if (_113 > 0) 
    goto _jump1179;
    fail_assertion("non-positive loop bound");
    _jump1179:;
    // Computing total size of heap memory to allocate
    int64_t _114 = 1;
    _114 *= _113;
    _114 *= sizeof(int64_t);
    _112.data = jpl_alloc(_114);
    int64_t _115 = 0; // A
    _jump1180:; // Begin body of loop
    int64_t _116 = 0;
    _116 *= _112.d0;
    _116 += _115;
    _112.data[_116] = n.d2;
    _115++;
    if (_115 < _113)
    goto _jump1180;
    // End body of loop
    _a1_int64_t _117;
    _117.d0 = 2;
    _117.data = jpl_alloc(sizeof(int64_t) * 2);
    _117.data[0] = j;
    _117.data[1] = n.d2;
    _a1__a1_int64_t _118;
    _118.d0 = 3;
    _118.data = jpl_alloc(sizeof(_a1_int64_t) * 3);
    _118.data[0] = _108;
    _118.data[1] = _112;
    _118.data[2] = _117;
    _107 = _118;
    goto _jump1181;
    _jump1176:;
    _a1__a1_int64_t _119;
    // Computing bound for A
    int64_t _120;
    // Computing bound for A
    if (_76 > 0) 
    goto _jump1182;
    fail_assertion("non-positive loop bound");
    _jump1182:;
    _120 = 0;
    int64_t _121 = 0; // A
    _jump1183:; // Begin body of loop
    _120 += n.d1;
    _121++;
    if (_121 < _76)
    goto _jump1183;
    // End body of loop
    _119.d0 = _120;
    if (_120 > 0) 
    goto _jump1184;
    fail_assertion("non-positive loop bound");
    _jump1184:;
    // Computing total size of heap memory to allocate
    int64_t _122 = 1;
    _122 *= _120;
    _122 *= sizeof(_a1_int64_t);
    _119.data = jpl_alloc(_122);
    int64_t _123 = 0; // A
    _jump1185:; // Begin body of loop
    _a1_int64_t _124;
    // Computing bound for B
    _124.d0 = d;
    if (d > 0) 
    goto _jump1186;
    fail_assertion("non-positive loop bound");
    _jump1186:;
    // Computing total size of heap memory to allocate
    int64_t _125 = 1;
    _125 *= d;
    _125 *= sizeof(int64_t);
    _124.data = jpl_alloc(_125);
    int64_t _126 = 0; // B
    _jump1187:; // Begin body of loop
    int64_t _127 = 0;
    _127 *= _124.d0;
    _127 += _126;
    _124.data[_127] = n.d0;
    _126++;
    if (_126 < d)
    goto _jump1187;
    // End body of loop
    int64_t _128 = 0;
    _128 *= _119.d0;
    _128 += _123;
    _119.data[_128] = _124;
    _123++;
    if (_123 < _120)
    goto _jump1185;
    // End body of loop
    _107 = _119;
    _jump1181:;
    _88 = _107;
    _jump1173:;
    int64_t _129 = 0;
    _129 *= _71.d0;
    _129 += _77;
    _129 *= _71.d1;
    _129 += _76;
    _129 *= _71.d2;
    _129 += _75;
    _71.data[_129] = _88;
    _75++;
    if (_75 < n.d0)
    goto _jump1161;
    _75 = 0;
    _76++;
    if (_76 < _73)
    goto _jump1161;
    _76 = 0;
    _77++;
    if (_77 < _72)
    goto _jump1161;
    // End body of loop
    _a1_int64_t _130;
    if (!r)
    goto _jump1188;
    bool _131 = n.d1 > _0.d2;
    bool _132;
    if (!_131)
    goto _jump1189;
    _132 = k;
    goto _jump1190;
    _jump1189:;
    _132 = r;
    _jump1190:;
    _a1_int64_t _133;
    if (!_132)
    goto _jump1191;
    _a1_int64_t _134;
    _134.d0 = 1;
    _134.data = jpl_alloc(sizeof(int64_t) * 1);
    _134.data[0] = n.d0;
    _133 = _134;
    goto _jump1192;
    _jump1191:;
    bool _135 = false;
    bool _136 = !_135;
    _a1_int64_t _137;
    if (!_136)
    goto _jump1193;
    _a1_int64_t _138;
    _138.d0 = 1;
    _138.data = jpl_alloc(sizeof(int64_t) * 1);
    _138.data[0] = _0.d1;
    _137 = _138;
    goto _jump1194;
    _jump1193:;
    int64_t _139 = 253;
    int64_t _140 = 683;
    _a1_int64_t _141;
    _141.d0 = 2;
    _141.data = jpl_alloc(sizeof(int64_t) * 2);
    _141.data[0] = _139;
    _141.data[1] = _140;
    _137 = _141;
    _jump1194:;
    _133 = _137;
    _jump1192:;
    _130 = _133;
    goto _jump1195;
    _jump1188:;
    int64_t _142 = 50;
    _a1_int64_t _143;
    _143.d0 = 1;
    _143.data = jpl_alloc(sizeof(int64_t) * 1);
    _143.data[0] = _142;
    _130 = _143;
    _jump1195:;
    _a2_int64_t _144;
    // Computing bound for x
    int64_t _145 = 179;
    _144.d0 = _145;
    if (_145 > 0) 
    goto _jump1196;
    fail_assertion("non-positive loop bound");
    _jump1196:;
    // Computing bound for y
    _144.d1 = _0.d0;
    if (_0.d0 > 0) 
    goto _jump1197;
    fail_assertion("non-positive loop bound");
    _jump1197:;
    // Computing total size of heap memory to allocate
    int64_t _146 = 1;
    _146 *= _145;
    _146 *= _0.d0;
    _146 *= sizeof(int64_t);
    _144.data = jpl_alloc(_146);
    int64_t _147 = 0; // y
    int64_t _148 = 0; // x
    _jump1198:; // Begin body of loop
    int64_t _149 = 0;
    _149 *= _144.d0;
    _149 += _148;
    _149 *= _144.d1;
    _149 += _147;
    _144.data[_149] = _0.d2;
    _147++;
    if (_147 < _0.d0)
    goto _jump1198;
    _147 = 0;
    _148++;
    if (_148 < _145)
    goto _jump1198;
    // End body of loop
    if (_0.d1 >= 0)
    goto _jump1199;
    fail_assertion("negative array index");
    _jump1199:;
    if (_0.d1 < _144.d0)
    goto _jump1200;
    fail_assertion("index too large");
    _jump1200:;
    if (n.d1 >= 0)
    goto _jump1201;
    fail_assertion("negative array index");
    _jump1201:;
    if (n.d1 < _144.d1)
    goto _jump1202;
    fail_assertion("index too large");
    _jump1202:;
    int64_t _150 = 0;
    _150 *= _144.d0;
    _150 += _0.d1;
    _150 *= _144.d1;
    _150 += n.d1;
    int64_t _151 = _144.data[_150];
    int64_t _152 = l(_151, n, r);
    int64_t _153 = _152 / j;
    if (_153 >= 0)
    goto _jump1203;
    fail_assertion("negative array index");
    _jump1203:;
    if (_153 < _130.d0)
    goto _jump1204;
    fail_assertion("index too large");
    _jump1204:;
    int64_t _154 = 0;
    _154 *= _130.d0;
    _154 += _153;
    int64_t _155 = _130.data[_154];
    if (n.d0 >= 0)
    goto _jump1205;
    fail_assertion("negative array index");
    _jump1205:;
    if (n.d0 < _71.d0)
    goto _jump1206;
    fail_assertion("index too large");
    _jump1206:;
    if (_0.d1 >= 0)
    goto _jump1207;
    fail_assertion("negative array index");
    _jump1207:;
    if (_0.d1 < _71.d1)
    goto _jump1208;
    fail_assertion("index too large");
    _jump1208:;
    if (_155 >= 0)
    goto _jump1209;
    fail_assertion("negative array index");
    _jump1209:;
    if (_155 < _71.d2)
    goto _jump1210;
    fail_assertion("index too large");
    _jump1210:;
    int64_t _156 = 0;
    _156 *= _71.d0;
    _156 += n.d0;
    _156 *= _71.d1;
    _156 += _0.d1;
    _156 *= _71.d2;
    _156 += _155;
    _a1__a1_int64_t _157 = _71.data[_156];
    bool _158 = !k;
    int64_t _159;
    if (!_158)
    goto _jump1211;
    _159 = n.d2;
    goto _jump1212;
    _jump1211:;
    _159 = _0.d1;
    _jump1212:;
    if (_159 >= 0)
    goto _jump1213;
    fail_assertion("negative array index");
    _jump1213:;
    if (_159 < _157.d0)
    goto _jump1214;
    fail_assertion("index too large");
    _jump1214:;
    int64_t _160 = 0;
    _160 *= _157.d0;
    _160 += _159;
    _a1_int64_t _161 = _157.data[_160];
    bool _162 = _0.d0 > d;
    _a2_a _163;
    if (!_162)
    goto _jump1215;
    _a2_a _164;
    // Computing bound for z
    _164.d0 = c;
    if (c > 0) 
    goto _jump1216;
    fail_assertion("non-positive loop bound");
    _jump1216:;
    // Computing bound for A
    _164.d1 = m;
    if (m > 0) 
    goto _jump1217;
    fail_assertion("non-positive loop bound");
    _jump1217:;
    // Computing total size of heap memory to allocate
    int64_t _165 = 1;
    _165 *= c;
    _165 *= m;
    _165 *= sizeof(a);
    _164.data = jpl_alloc(_165);
    int64_t _166 = 0; // A
    int64_t _167 = 0; // z
    _jump1218:; // Begin body of loop
    a _168 = h();
    int64_t _169 = 0;
    _169 *= _164.d0;
    _169 += _167;
    _169 *= _164.d1;
    _169 += _166;
    _164.data[_169] = _168;
    _166++;
    if (_166 < m)
    goto _jump1218;
    _166 = 0;
    _167++;
    if (_167 < c)
    goto _jump1218;
    // End body of loop
    _163 = _164;
    goto _jump1219;
    _jump1215:;
    _a2_a _170;
    // Computing bound for z
    _170.d0 = n.d2;
    if (n.d2 > 0) 
    goto _jump1220;
    fail_assertion("non-positive loop bound");
    _jump1220:;
    // Computing bound for A
    _170.d1 = n.d0;
    if (n.d0 > 0) 
    goto _jump1221;
    fail_assertion("non-positive loop bound");
    _jump1221:;
    // Computing total size of heap memory to allocate
    int64_t _171 = 1;
    _171 *= n.d2;
    _171 *= n.d0;
    _171 *= sizeof(a);
    _170.data = jpl_alloc(_171);
    int64_t _172 = 0; // A
    int64_t _173 = 0; // z
    _jump1222:; // Begin body of loop
    a _174 = h();
    int64_t _175 = 0;
    _175 *= _170.d0;
    _175 += _173;
    _175 *= _170.d1;
    _175 += _172;
    _170.data[_175] = _174;
    _172++;
    if (_172 < n.d0)
    goto _jump1222;
    _172 = 0;
    _173++;
    if (_173 < n.d2)
    goto _jump1222;
    // End body of loop
    _163 = _170;
    _jump1219:;
    int64_t _176 = n.d0 + n.d1;
    if (_176 >= 0)
    goto _jump1223;
    fail_assertion("negative array index");
    _jump1223:;
    if (_176 < _163.d0)
    goto _jump1224;
    fail_assertion("index too large");
    _jump1224:;
    if (n.d1 >= 0)
    goto _jump1225;
    fail_assertion("negative array index");
    _jump1225:;
    if (n.d1 < _163.d1)
    goto _jump1226;
    fail_assertion("index too large");
    _jump1226:;
    int64_t _177 = 0;
    _177 *= _163.d0;
    _177 += _176;
    _177 *= _163.d1;
    _177 += n.d1;
    a _178 = _163.data[_177];
    double _179 = _178.b;
    double _180;
    // Computing bound for z
    if (m > 0) 
    goto _jump1227;
    fail_assertion("non-positive loop bound");
    _jump1227:;
    // Computing bound for A
    if (_0.d1 > 0) 
    goto _jump1228;
    fail_assertion("non-positive loop bound");
    _jump1228:;
    _180 = 0;
    int64_t _181 = 0; // A
    int64_t _182 = 0; // z
    _jump1229:; // Begin body of loop
    bool _183 = !r;
    double _184 = g(_183);
    _180 += _184;
    _181++;
    if (_181 < _0.d1)
    goto _jump1229;
    _181 = 0;
    _182++;
    if (_182 < m)
    goto _jump1229;
    // End body of loop
    double _185 = -_180;
    bool _186 = _179 != _185;
    bool _187 = _0.d2 <= _0.d2;
    bool _188 = _186 != _187;
    _a1_int64_t _189;
    if (!_188)
    goto _jump1230;
    _a1__a1_int64_t _190;
    // Computing bound for z
    _190.d0 = n.d0;
    if (n.d0 > 0) 
    goto _jump1231;
    fail_assertion("non-positive loop bound");
    _jump1231:;
    // Computing total size of heap memory to allocate
    int64_t _191 = 1;
    _191 *= n.d0;
    _191 *= sizeof(_a1_int64_t);
    _190.data = jpl_alloc(_191);
    int64_t _192 = 0; // z
    _jump1232:; // Begin body of loop
    _a1__a1_int64_t _193;
    // Computing bound for A
    int64_t _194 = 848;
    _193.d0 = _194;
    if (_194 > 0) 
    goto _jump1233;
    fail_assertion("non-positive loop bound");
    _jump1233:;
    // Computing total size of heap memory to allocate
    int64_t _195 = 1;
    _195 *= _194;
    _195 *= sizeof(_a1_int64_t);
    _193.data = jpl_alloc(_195);
    int64_t _196 = 0; // A
    _jump1234:; // Begin body of loop
    _a1_int64_t _197;
    // Computing bound for B
    _197.d0 = _192;
    if (_192 > 0) 
    goto _jump1235;
    fail_assertion("non-positive loop bound");
    _jump1235:;
    // Computing total size of heap memory to allocate
    int64_t _198 = 1;
    _198 *= _192;
    _198 *= sizeof(int64_t);
    _197.data = jpl_alloc(_198);
    int64_t _199 = 0; // B
    _jump1236:; // Begin body of loop
    int64_t _200 = 0;
    _200 *= _197.d0;
    _200 += _199;
    _197.data[_200] = n.d0;
    _199++;
    if (_199 < _192)
    goto _jump1236;
    // End body of loop
    int64_t _201 = 0;
    _201 *= _193.d0;
    _201 += _196;
    _193.data[_201] = _197;
    _196++;
    if (_196 < _194)
    goto _jump1234;
    // End body of loop
    if (m >= 0)
    goto _jump1237;
    fail_assertion("negative array index");
    _jump1237:;
    if (m < _193.d0)
    goto _jump1238;
    fail_assertion("index too large");
    _jump1238:;
    int64_t _202 = 0;
    _202 *= _193.d0;
    _202 += m;
    _a1_int64_t _203 = _193.data[_202];
    int64_t _204 = 0;
    _204 *= _190.d0;
    _204 += _192;
    _190.data[_204] = _203;
    _192++;
    if (_192 < n.d0)
    goto _jump1232;
    // End body of loop
    int64_t _205;
    // Computing bound for z
    int64_t _206 = _0.d2 % m;
    if (_206 > 0) 
    goto _jump1239;
    fail_assertion("non-positive loop bound");
    _jump1239:;
    _205 = 0;
    int64_t _207 = 0; // z
    _jump1240:; // Begin body of loop
    _205 += m;
    _207++;
    if (_207 < _206)
    goto _jump1240;
    // End body of loop
    int64_t _208 = _205 % c;
    int64_t _209 = -_208;
    if (_209 >= 0)
    goto _jump1241;
    fail_assertion("negative array index");
    _jump1241:;
    if (_209 < _190.d0)
    goto _jump1242;
    fail_assertion("index too large");
    _jump1242:;
    int64_t _210 = 0;
    _210 *= _190.d0;
    _210 += _209;
    _a1_int64_t _211 = _190.data[_210];
    _189 = _211;
    goto _jump1243;
    _jump1230:;
    _189 = _161;
    _jump1243:;
    _a1_bool _212;
    // Computing bound for B
    int64_t _213;
    if (!k)
    goto _jump1244;
    _213 = d;
    goto _jump1245;
    _jump1244:;
    _213 = m;
    _jump1245:;
    _212.d0 = _213;
    if (_213 > 0) 
    goto _jump1246;
    fail_assertion("non-positive loop bound");
    _jump1246:;
    // Computing total size of heap memory to allocate
    int64_t _214 = 1;
    _214 *= _213;
    _214 *= sizeof(bool);
    _212.data = jpl_alloc(_214);
    int64_t _215 = 0; // B
    _jump1247:; // Begin body of loop
    bool _216 = !r;
    int64_t _217 = 0;
    _217 *= _212.d0;
    _217 += _215;
    _212.data[_217] = _216;
    _215++;
    if (_215 < _213)
    goto _jump1247;
    // End body of loop
    double _218 = 52.0;
    double _219 = 58.0;
    bool _220 = _218 == _219;
    int64_t _221;
    if (!_220)
    goto _jump1248;
    _221 = m;
    goto _jump1249;
    _jump1248:;
    _221 = n.d1;
    _jump1249:;
    if (_221 >= 0)
    goto _jump1250;
    fail_assertion("negative array index");
    _jump1250:;
    if (_221 < _212.d0)
    goto _jump1251;
    fail_assertion("index too large");
    _jump1251:;
    int64_t _222 = 0;
    _222 *= _212.d0;
    _222 += _221;
    bool _223 = _212.data[_222];
    bool _224;
    if (!_223)
    goto _jump1252;
    bool _227 = r;
    if (0 == r)
    goto _jump1253;
    bool _228 = false;
    _227 = _228;
    _jump1253:;
    bool _226 = _227;
    if (0 == _227)
    goto _jump1254;
    _226 = k;
    _jump1254:;
    bool _225 = _226;
    if (0 != _226)
    goto _jump1255;
    _a3_bool _229;
    // Computing bound for B
    _229.d0 = n.d2;
    if (n.d2 > 0) 
    goto _jump1256;
    fail_assertion("non-positive loop bound");
    _jump1256:;
    // Computing bound for C
    _229.d1 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump1257;
    fail_assertion("non-positive loop bound");
    _jump1257:;
    // Computing bound for D
    int64_t _230 = 963;
    _229.d2 = _230;
    if (_230 > 0) 
    goto _jump1258;
    fail_assertion("non-positive loop bound");
    _jump1258:;
    // Computing total size of heap memory to allocate
    int64_t _231 = 1;
    _231 *= n.d2;
    _231 *= _0.d2;
    _231 *= _230;
    _231 *= sizeof(bool);
    _229.data = jpl_alloc(_231);
    int64_t _232 = 0; // D
    int64_t _233 = 0; // C
    int64_t _234 = 0; // B
    _jump1259:; // Begin body of loop
    int64_t _235 = 0;
    _235 *= _229.d0;
    _235 += _234;
    _235 *= _229.d1;
    _235 += _233;
    _235 *= _229.d2;
    _235 += _232;
    _229.data[_235] = k;
    _232++;
    if (_232 < _230)
    goto _jump1259;
    _232 = 0;
    _233++;
    if (_233 < _0.d2)
    goto _jump1259;
    _233 = 0;
    _234++;
    if (_234 < n.d2)
    goto _jump1259;
    // End body of loop
    int64_t _236 = 501;
    int64_t _237 = _236 - _0.d0;
    if (_0.d0 >= 0)
    goto _jump1260;
    fail_assertion("negative array index");
    _jump1260:;
    if (_0.d0 < _229.d0)
    goto _jump1261;
    fail_assertion("index too large");
    _jump1261:;
    if (m >= 0)
    goto _jump1262;
    fail_assertion("negative array index");
    _jump1262:;
    if (m < _229.d1)
    goto _jump1263;
    fail_assertion("index too large");
    _jump1263:;
    if (_237 >= 0)
    goto _jump1264;
    fail_assertion("negative array index");
    _jump1264:;
    if (_237 < _229.d2)
    goto _jump1265;
    fail_assertion("index too large");
    _jump1265:;
    int64_t _238 = 0;
    _238 *= _229.d0;
    _238 += _0.d0;
    _238 *= _229.d1;
    _238 += m;
    _238 *= _229.d2;
    _238 += _237;
    bool _239 = _229.data[_238];
    _225 = _239;
    _jump1255:;
    _224 = _225;
    goto _jump1266;
    _jump1252:;
    bool _241 = j >= _161.d0;
    bool _240 = _241;
    if (0 != _241)
    goto _jump1267;
    bool _242 = !k;
    _240 = _242;
    _jump1267:;
    bool _243;
    if (!_240)
    goto _jump1268;
    _a2_bool _244;
    // Computing bound for B
    _244.d0 = m;
    if (m > 0) 
    goto _jump1269;
    fail_assertion("non-positive loop bound");
    _jump1269:;
    // Computing bound for C
    _244.d1 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1270;
    fail_assertion("non-positive loop bound");
    _jump1270:;
    // Computing total size of heap memory to allocate
    int64_t _245 = 1;
    _245 *= m;
    _245 *= _161.d0;
    _245 *= sizeof(bool);
    _244.data = jpl_alloc(_245);
    int64_t _246 = 0; // C
    int64_t _247 = 0; // B
    _jump1271:; // Begin body of loop
    int64_t _248 = 0;
    _248 *= _244.d0;
    _248 += _247;
    _248 *= _244.d1;
    _248 += _246;
    _244.data[_248] = k;
    _246++;
    if (_246 < _161.d0)
    goto _jump1271;
    _246 = 0;
    _247++;
    if (_247 < m)
    goto _jump1271;
    // End body of loop
    if (m >= 0)
    goto _jump1272;
    fail_assertion("negative array index");
    _jump1272:;
    if (m < _244.d0)
    goto _jump1273;
    fail_assertion("index too large");
    _jump1273:;
    if (m >= 0)
    goto _jump1274;
    fail_assertion("negative array index");
    _jump1274:;
    if (m < _244.d1)
    goto _jump1275;
    fail_assertion("index too large");
    _jump1275:;
    int64_t _249 = 0;
    _249 *= _244.d0;
    _249 += m;
    _249 *= _244.d1;
    _249 += m;
    bool _250 = _244.data[_249];
    _243 = _250;
    goto _jump1276;
    _jump1268:;
    double _251 = 63.0;
    double _252 = 42.0;
    bool _253 = _251 != _252;
    _243 = _253;
    _jump1276:;
    _224 = _243;
    _jump1266:;
    bool _254;
    if (!_224)
    goto _jump1277;
    bool _255 = true;
    _254 = _255;
    goto _jump1278;
    _jump1277:;
    bool _256 = false;
    _254 = _256;
    _jump1278:;
    _a2_bool _257;
    if (!_254)
    goto _jump1279;
    double _259 = 63.0;
    double _260 = -_259;
    a _261 = h();
    double _262 = _261.b;
    bool _263 = _260 >= _262;
    bool _258 = _263;
    if (0 == _263)
    goto _jump1280;
    _258 = r;
    _jump1280:;
    _a2_bool _264;
    if (!_258)
    goto _jump1281;
    _a2_bool _265;
    // Computing bound for B
    _265.d0 = _161.d0;
    if (_161.d0 > 0) 
    goto _jump1282;
    fail_assertion("non-positive loop bound");
    _jump1282:;
    // Computing bound for C
    _265.d1 = d;
    if (d > 0) 
    goto _jump1283;
    fail_assertion("non-positive loop bound");
    _jump1283:;
    // Computing total size of heap memory to allocate
    int64_t _266 = 1;
    _266 *= _161.d0;
    _266 *= d;
    _266 *= sizeof(bool);
    _265.data = jpl_alloc(_266);
    int64_t _267 = 0; // C
    int64_t _268 = 0; // B
    _jump1284:; // Begin body of loop
    int64_t _269 = 0;
    _269 *= _265.d0;
    _269 += _268;
    _269 *= _265.d1;
    _269 += _267;
    _265.data[_269] = r;
    _267++;
    if (_267 < d)
    goto _jump1284;
    _267 = 0;
    _268++;
    if (_268 < _161.d0)
    goto _jump1284;
    // End body of loop
    _264 = _265;
    goto _jump1285;
    _jump1281:;
    _a1__a2_bool _270;
    // Computing bound for B
    _270.d0 = _0.d2;
    if (_0.d2 > 0) 
    goto _jump1286;
    fail_assertion("non-positive loop bound");
    _jump1286:;
    // Computing total size of heap memory to allocate
    int64_t _271 = 1;
    _271 *= _0.d2;
    _271 *= sizeof(_a2_bool);
    _270.data = jpl_alloc(_271);
    int64_t _272 = 0; // B
    _jump1287:; // Begin body of loop
    _a2_bool _273;
    // Computing bound for C
    _273.d0 = n.d2;
    if (n.d2 > 0) 
    goto _jump1288;
    fail_assertion("non-positive loop bound");
    _jump1288:;
    // Computing bound for D
    _273.d1 = n.d1;
    if (n.d1 > 0) 
    goto _jump1289;
    fail_assertion("non-positive loop bound");
    _jump1289:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= n.d2;
    _274 *= n.d1;
    _274 *= sizeof(bool);
    _273.data = jpl_alloc(_274);
    int64_t _275 = 0; // D
    int64_t _276 = 0; // C
    _jump1290:; // Begin body of loop
    int64_t _277 = 0;
    _277 *= _273.d0;
    _277 += _276;
    _277 *= _273.d1;
    _277 += _275;
    _273.data[_277] = k;
    _275++;
    if (_275 < n.d1)
    goto _jump1290;
    _275 = 0;
    _276++;
    if (_276 < n.d2)
    goto _jump1290;
    // End body of loop
    int64_t _278 = 0;
    _278 *= _270.d0;
    _278 += _272;
    _270.data[_278] = _273;
    _272++;
    if (_272 < _0.d2)
    goto _jump1287;
    // End body of loop
    if (n.d0 >= 0)
    goto _jump1291;
    fail_assertion("negative array index");
    _jump1291:;
    if (n.d0 < _270.d0)
    goto _jump1292;
    fail_assertion("index too large");
    _jump1292:;
    int64_t _279 = 0;
    _279 *= _270.d0;
    _279 += n.d0;
    _a2_bool _280 = _270.data[_279];
    _264 = _280;
    _jump1285:;
    _257 = _264;
    goto _jump1293;
    _jump1279:;
    _a2_bool _281;
    // Computing bound for B
    int64_t _282 = 765;
    _281.d0 = _282;
    if (_282 > 0) 
    goto _jump1294;
    fail_assertion("non-positive loop bound");
    _jump1294:;
    // Computing bound for C
    _281.d1 = n.d1;
    if (n.d1 > 0) 
    goto _jump1295;
    fail_assertion("non-positive loop bound");
    _jump1295:;
    // Computing total size of heap memory to allocate
    int64_t _283 = 1;
    _283 *= _282;
    _283 *= n.d1;
    _283 *= sizeof(bool);
    _281.data = jpl_alloc(_283);
    int64_t _284 = 0; // C
    int64_t _285 = 0; // B
    _jump1296:; // Begin body of loop
    int64_t _286 = 0;
    _286 *= _281.d0;
    _286 += _285;
    _286 *= _281.d1;
    _286 += _284;
    _281.data[_286] = r;
    _284++;
    if (_284 < n.d1)
    goto _jump1296;
    _284 = 0;
    _285++;
    if (_285 < _282)
    goto _jump1296;
    // End body of loop
    _257 = _281;
    _jump1293:;
    int64_t _287 = 255;
    if (m >= 0)
    goto _jump1297;
    fail_assertion("negative array index");
    _jump1297:;
    if (m < _257.d0)
    goto _jump1298;
    fail_assertion("index too large");
    _jump1298:;
    if (_287 >= 0)
    goto _jump1299;
    fail_assertion("negative array index");
    _jump1299:;
    if (_287 < _257.d1)
    goto _jump1300;
    fail_assertion("index too large");
    _jump1300:;
    int64_t _288 = 0;
    _288 *= _257.d0;
    _288 += m;
    _288 *= _257.d1;
    _288 += _287;
    bool _289 = _257.data[_288];
    if (0 != _289)
    goto _jump1301;
    fail_assertion("B");
    _jump1301:;
    bool _290;
    if (!r)
    goto _jump1302;
    _290 = r;
    goto _jump1303;
    _jump1302:;
    double _291;
    if (!r)
    goto _jump1304;
    bool _292 = k;
    if (0 != k)
    goto _jump1305;
    bool _293 = n.d0 < m;
    _292 = _293;
    _jump1305:;
    double _294 = g(_292);
    _291 = _294;
    goto _jump1306;
    _jump1304:;
    _a1_a _295;
    // Computing bound for B
    int64_t _296 = 833;
    int64_t _297 = -_296;
    _295.d0 = _297;
    if (_297 > 0) 
    goto _jump1307;
    fail_assertion("non-positive loop bound");
    _jump1307:;
    // Computing total size of heap memory to allocate
    int64_t _298 = 1;
    _298 *= _297;
    _298 *= sizeof(a);
    _295.data = jpl_alloc(_298);
    int64_t _299 = 0; // B
    _jump1308:; // Begin body of loop
    a _300 = h();
    int64_t _301 = 0;
    _301 *= _295.d0;
    _301 += _299;
    _295.data[_301] = _300;
    _299++;
    if (_299 < _297)
    goto _jump1308;
    // End body of loop
    if (n.d0 >= 0)
    goto _jump1309;
    fail_assertion("negative array index");
    _jump1309:;
    if (n.d0 < _295.d0)
    goto _jump1310;
    fail_assertion("index too large");
    _jump1310:;
    int64_t _302 = 0;
    _302 *= _295.d0;
    _302 += n.d0;
    a _303 = _295.data[_302];
    double _304 = _303.b;
    _291 = _304;
    _jump1306:;
    double _305 = 88.0;
    bool _306 = _291 > _305;
    _290 = _306;
    _jump1303:;
    return n.d0;
}

a m(rgba n, _a2_double o) {
    bool _0;
    if (!k)
    goto _jump1311;
    _0 = k;
    goto _jump1312;
    _jump1311:;
    double _1 = 81.0;
    bool _3 = true;
    bool _2 = _3;
    if (0 != _3)
    goto _jump1313;
    _2 = k;
    _jump1313:;
    double _4 = g(_2);
    double _5 = _1 * _4;
    bool _6 = true;
    bool _7 = !_6;
    bool _8 = !_7;
    double _9;
    if (!_8)
    goto _jump1314;
    bool _10 = false;
    double _11 = g(_10);
    _9 = _11;
    goto _jump1315;
    _jump1314:;
    _a1_double _12;
    // Computing bound for r
    int64_t _13 = 139;
    _12.d0 = _13;
    if (_13 > 0) 
    goto _jump1316;
    fail_assertion("non-positive loop bound");
    _jump1316:;
    // Computing total size of heap memory to allocate
    int64_t _14 = 1;
    _14 *= _13;
    _14 *= sizeof(double);
    _12.data = jpl_alloc(_14);
    int64_t _15 = 0; // r
    _jump1317:; // Begin body of loop
    double _16 = g(k);
    int64_t _17 = 0;
    _17 *= _12.d0;
    _17 += _15;
    _12.data[_17] = _16;
    _15++;
    if (_15 < _13)
    goto _jump1317;
    // End body of loop
    _a3_int64_t _18;
    // Computing bound for r
    int64_t _19 = 968;
    _18.d0 = _19;
    if (_19 > 0) 
    goto _jump1318;
    fail_assertion("non-positive loop bound");
    _jump1318:;
    // Computing bound for s
    _18.d1 = j;
    if (j > 0) 
    goto _jump1319;
    fail_assertion("non-positive loop bound");
    _jump1319:;
    // Computing bound for t
    _18.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump1320;
    fail_assertion("non-positive loop bound");
    _jump1320:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _19;
    _20 *= j;
    _20 *= o.d0;
    _20 *= sizeof(int64_t);
    _18.data = jpl_alloc(_20);
    int64_t _21 = 0; // t
    int64_t _22 = 0; // s
    int64_t _23 = 0; // r
    _jump1321:; // Begin body of loop
    int64_t _24 = 0;
    _24 *= _18.d0;
    _24 += _23;
    _24 *= _18.d1;
    _24 += _22;
    _24 *= _18.d2;
    _24 += _21;
    _18.data[_24] = c;
    _21++;
    if (_21 < o.d0)
    goto _jump1321;
    _21 = 0;
    _22++;
    if (_22 < j)
    goto _jump1321;
    _22 = 0;
    _23++;
    if (_23 < _19)
    goto _jump1321;
    // End body of loop
    int64_t _25 = 933;
    int64_t _26 = _25 % j;
    int64_t _27;
    // Computing bound for r
    if (d > 0) 
    goto _jump1322;
    fail_assertion("non-positive loop bound");
    _jump1322:;
    // Computing bound for s
    if (o.d0 > 0) 
    goto _jump1323;
    fail_assertion("non-positive loop bound");
    _jump1323:;
    _27 = 0;
    int64_t _28 = 0; // s
    int64_t _29 = 0; // r
    _jump1324:; // Begin body of loop
    _27 += o.d1;
    _28++;
    if (_28 < o.d0)
    goto _jump1324;
    _28 = 0;
    _29++;
    if (_29 < d)
    goto _jump1324;
    // End body of loop
    if (_26 >= 0)
    goto _jump1325;
    fail_assertion("negative array index");
    _jump1325:;
    if (_26 < _18.d0)
    goto _jump1326;
    fail_assertion("index too large");
    _jump1326:;
    if (_27 >= 0)
    goto _jump1327;
    fail_assertion("negative array index");
    _jump1327:;
    if (_27 < _18.d1)
    goto _jump1328;
    fail_assertion("index too large");
    _jump1328:;
    if (j >= 0)
    goto _jump1329;
    fail_assertion("negative array index");
    _jump1329:;
    if (j < _18.d2)
    goto _jump1330;
    fail_assertion("index too large");
    _jump1330:;
    int64_t _30 = 0;
    _30 *= _18.d0;
    _30 += _26;
    _30 *= _18.d1;
    _30 += _27;
    _30 *= _18.d2;
    _30 += j;
    int64_t _31 = _18.data[_30];
    if (_31 >= 0)
    goto _jump1331;
    fail_assertion("negative array index");
    _jump1331:;
    if (_31 < _12.d0)
    goto _jump1332;
    fail_assertion("index too large");
    _jump1332:;
    int64_t _32 = 0;
    _32 *= _12.d0;
    _32 += _31;
    double _33 = _12.data[_32];
    double _34 = -_33;
    _9 = _34;
    _jump1315:;
    bool _35 = _5 < _9;
    _0 = _35;
    _jump1312:;
    if (0 != _0)
    goto _jump1333;
    fail_assertion("s");
    _jump1333:;
    a _36 = h();
    return _36;
    int64_t _37 = b.d0 * b.d1;
    bool _38 = b.d0 <= _37;
    _a3_double _39;
    if (!_38)
    goto _jump1334;
    _a3_double _40;
    if (!k)
    goto _jump1335;
    _a3_double _41;
    // Computing bound for v
    _41.d0 = j;
    if (j > 0) 
    goto _jump1336;
    fail_assertion("non-positive loop bound");
    _jump1336:;
    // Computing bound for w
    _41.d1 = j;
    if (j > 0) 
    goto _jump1337;
    fail_assertion("non-positive loop bound");
    _jump1337:;
    // Computing bound for x
    int64_t _42 = 986;
    _41.d2 = _42;
    if (_42 > 0) 
    goto _jump1338;
    fail_assertion("non-positive loop bound");
    _jump1338:;
    // Computing total size of heap memory to allocate
    int64_t _43 = 1;
    _43 *= j;
    _43 *= j;
    _43 *= _42;
    _43 *= sizeof(double);
    _41.data = jpl_alloc(_43);
    int64_t _44 = 0; // x
    int64_t _45 = 0; // w
    int64_t _46 = 0; // v
    _jump1339:; // Begin body of loop
    double _47 = g(k);
    int64_t _48 = 0;
    _48 *= _41.d0;
    _48 += _46;
    _48 *= _41.d1;
    _48 += _45;
    _48 *= _41.d2;
    _48 += _44;
    _41.data[_48] = _47;
    _44++;
    if (_44 < _42)
    goto _jump1339;
    _44 = 0;
    _45++;
    if (_45 < j)
    goto _jump1339;
    _45 = 0;
    _46++;
    if (_46 < j)
    goto _jump1339;
    // End body of loop
    _40 = _41;
    goto _jump1340;
    _jump1335:;
    _a3_double _49;
    // Computing bound for v
    _49.d0 = b.d0;
    if (b.d0 > 0) 
    goto _jump1341;
    fail_assertion("non-positive loop bound");
    _jump1341:;
    // Computing bound for w
    _49.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump1342;
    fail_assertion("non-positive loop bound");
    _jump1342:;
    // Computing bound for x
    _49.d2 = j;
    if (j > 0) 
    goto _jump1343;
    fail_assertion("non-positive loop bound");
    _jump1343:;
    // Computing total size of heap memory to allocate
    int64_t _50 = 1;
    _50 *= b.d0;
    _50 *= o.d1;
    _50 *= j;
    _50 *= sizeof(double);
    _49.data = jpl_alloc(_50);
    int64_t _51 = 0; // x
    int64_t _52 = 0; // w
    int64_t _53 = 0; // v
    _jump1344:; // Begin body of loop
    a _54 = h();
    double _55 = _54.b;
    int64_t _56 = 0;
    _56 *= _49.d0;
    _56 += _53;
    _56 *= _49.d1;
    _56 += _52;
    _56 *= _49.d2;
    _56 += _51;
    _49.data[_56] = _55;
    _51++;
    if (_51 < j)
    goto _jump1344;
    _51 = 0;
    _52++;
    if (_52 < o.d1)
    goto _jump1344;
    _52 = 0;
    _53++;
    if (_53 < b.d0)
    goto _jump1344;
    // End body of loop
    _40 = _49;
    _jump1340:;
    _39 = _40;
    goto _jump1345;
    _jump1334:;
    _a3_double _57;
    // Computing bound for v
    _a3_int64_t _58;
    // Computing bound for v
    _58.d0 = d;
    if (d > 0) 
    goto _jump1346;
    fail_assertion("non-positive loop bound");
    _jump1346:;
    // Computing bound for w
    int64_t _59 = 970;
    _58.d1 = _59;
    if (_59 > 0) 
    goto _jump1347;
    fail_assertion("non-positive loop bound");
    _jump1347:;
    // Computing bound for x
    _58.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump1348;
    fail_assertion("non-positive loop bound");
    _jump1348:;
    // Computing total size of heap memory to allocate
    int64_t _60 = 1;
    _60 *= d;
    _60 *= _59;
    _60 *= o.d0;
    _60 *= sizeof(int64_t);
    _58.data = jpl_alloc(_60);
    int64_t _61 = 0; // x
    int64_t _62 = 0; // w
    int64_t _63 = 0; // v
    _jump1349:; // Begin body of loop
    int64_t _64 = 0;
    _64 *= _58.d0;
    _64 += _63;
    _64 *= _58.d1;
    _64 += _62;
    _64 *= _58.d2;
    _64 += _61;
    _58.data[_64] = d;
    _61++;
    if (_61 < o.d0)
    goto _jump1349;
    _61 = 0;
    _62++;
    if (_62 < _59)
    goto _jump1349;
    _62 = 0;
    _63++;
    if (_63 < d)
    goto _jump1349;
    // End body of loop
    int64_t _65 = 440;
    int64_t _66 = o.d0 * b.d1;
    int64_t _67;
    if (!_0)
    goto _jump1350;
    _67 = o.d0;
    goto _jump1351;
    _jump1350:;
    int64_t _68 = 488;
    _67 = _68;
    _jump1351:;
    if (_65 >= 0)
    goto _jump1352;
    fail_assertion("negative array index");
    _jump1352:;
    if (_65 < _58.d0)
    goto _jump1353;
    fail_assertion("index too large");
    _jump1353:;
    if (_66 >= 0)
    goto _jump1354;
    fail_assertion("negative array index");
    _jump1354:;
    if (_66 < _58.d1)
    goto _jump1355;
    fail_assertion("index too large");
    _jump1355:;
    if (_67 >= 0)
    goto _jump1356;
    fail_assertion("negative array index");
    _jump1356:;
    if (_67 < _58.d2)
    goto _jump1357;
    fail_assertion("index too large");
    _jump1357:;
    int64_t _69 = 0;
    _69 *= _58.d0;
    _69 += _65;
    _69 *= _58.d1;
    _69 += _66;
    _69 *= _58.d2;
    _69 += _67;
    int64_t _70 = _58.data[_69];
    _57.d0 = _70;
    if (_70 > 0) 
    goto _jump1358;
    fail_assertion("non-positive loop bound");
    _jump1358:;
    // Computing bound for w
    _57.d1 = o.d0;
    if (o.d0 > 0) 
    goto _jump1359;
    fail_assertion("non-positive loop bound");
    _jump1359:;
    // Computing bound for x
    _57.d2 = d;
    if (d > 0) 
    goto _jump1360;
    fail_assertion("non-positive loop bound");
    _jump1360:;
    // Computing total size of heap memory to allocate
    int64_t _71 = 1;
    _71 *= _70;
    _71 *= o.d0;
    _71 *= d;
    _71 *= sizeof(double);
    _57.data = jpl_alloc(_71);
    int64_t _72 = 0; // x
    int64_t _73 = 0; // w
    int64_t _74 = 0; // v
    _jump1361:; // Begin body of loop
    bool _75 = b.d1 == _74;
    double _76 = g(_75);
    int64_t _77 = 0;
    _77 *= _57.d0;
    _77 += _74;
    _77 *= _57.d1;
    _77 += _73;
    _77 *= _57.d2;
    _77 += _72;
    _57.data[_77] = _76;
    _72++;
    if (_72 < d)
    goto _jump1361;
    _72 = 0;
    _73++;
    if (_73 < o.d0)
    goto _jump1361;
    _73 = 0;
    _74++;
    if (_74 < _70)
    goto _jump1361;
    // End body of loop
    _39 = _57;
    _jump1345:;
    int64_t _78;
    if (!k)
    goto _jump1362;
    if (c >= 0)
    goto _jump1363;
    fail_assertion("negative array index");
    _jump1363:;
    if (c < b.d0)
    goto _jump1364;
    fail_assertion("index too large");
    _jump1364:;
    if (c >= 0)
    goto _jump1365;
    fail_assertion("negative array index");
    _jump1365:;
    if (c < b.d1)
    goto _jump1366;
    fail_assertion("index too large");
    _jump1366:;
    int64_t _79 = 0;
    _79 *= b.d0;
    _79 += c;
    _79 *= b.d1;
    _79 += c;
    int64_t _80 = b.data[_79];
    _78 = _80;
    goto _jump1367;
    _jump1362:;
    int64_t _81 = 459;
    _78 = _81;
    _jump1367:;
    int64_t _82 = -_78;
    if (b.d0 >= 0)
    goto _jump1368;
    fail_assertion("negative array index");
    _jump1368:;
    if (b.d0 < _39.d0)
    goto _jump1369;
    fail_assertion("index too large");
    _jump1369:;
    if (_82 >= 0)
    goto _jump1370;
    fail_assertion("negative array index");
    _jump1370:;
    if (_82 < _39.d1)
    goto _jump1371;
    fail_assertion("index too large");
    _jump1371:;
    if (o.d0 >= 0)
    goto _jump1372;
    fail_assertion("negative array index");
    _jump1372:;
    if (o.d0 < _39.d2)
    goto _jump1373;
    fail_assertion("index too large");
    _jump1373:;
    int64_t _83 = 0;
    _83 *= _39.d0;
    _83 += b.d0;
    _83 *= _39.d1;
    _83 += _82;
    _83 *= _39.d2;
    _83 += o.d0;
    double _84 = _39.data[_83];
    _a3_double _85;
    // Computing bound for v
    _85.d0 = j;
    if (j > 0) 
    goto _jump1374;
    fail_assertion("non-positive loop bound");
    _jump1374:;
    // Computing bound for w
    _85.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump1375;
    fail_assertion("non-positive loop bound");
    _jump1375:;
    // Computing bound for x
    _85.d2 = d;
    if (d > 0) 
    goto _jump1376;
    fail_assertion("non-positive loop bound");
    _jump1376:;
    // Computing total size of heap memory to allocate
    int64_t _86 = 1;
    _86 *= j;
    _86 *= o.d1;
    _86 *= d;
    _86 *= sizeof(double);
    _85.data = jpl_alloc(_86);
    int64_t _87 = 0; // x
    int64_t _88 = 0; // w
    int64_t _89 = 0; // v
    _jump1377:; // Begin body of loop
    bool _90 = true;
    rgba _91;
    if (!_90)
    goto _jump1378;
    _91 = n;
    goto _jump1379;
    _jump1378:;
    _91 = n;
    _jump1379:;
    double _92 = _91.r;
    int64_t _93 = 0;
    _93 *= _85.d0;
    _93 += _89;
    _93 *= _85.d1;
    _93 += _88;
    _93 *= _85.d2;
    _93 += _87;
    _85.data[_93] = _92;
    _87++;
    if (_87 < d)
    goto _jump1377;
    _87 = 0;
    _88++;
    if (_88 < o.d1)
    goto _jump1377;
    _88 = 0;
    _89++;
    if (_89 < j)
    goto _jump1377;
    // End body of loop
    int64_t _94;
    // Computing bound for v
    if (b.d0 > 0) 
    goto _jump1380;
    fail_assertion("non-positive loop bound");
    _jump1380:;
    // Computing bound for w
    int64_t _95 = o.d1 * d;
    int64_t _96;
    // Computing bound for v
    if (b.d1 > 0) 
    goto _jump1381;
    fail_assertion("non-positive loop bound");
    _jump1381:;
    _96 = 0;
    int64_t _97 = 0; // v
    _jump1382:; // Begin body of loop
    _96 += c;
    _97++;
    if (_97 < b.d1)
    goto _jump1382;
    // End body of loop
    int64_t _98 = _95 / _96;
    int64_t _99;
    // Computing bound for v
    if (o.d1 > 0) 
    goto _jump1383;
    fail_assertion("non-positive loop bound");
    _jump1383:;
    // Computing bound for w
    int64_t _100 = -c;
    if (_100 > 0) 
    goto _jump1384;
    fail_assertion("non-positive loop bound");
    _jump1384:;
    // Computing bound for x
    int64_t _101 = 788;
    int64_t _102 = -_101;
    if (_102 > 0) 
    goto _jump1385;
    fail_assertion("non-positive loop bound");
    _jump1385:;
    _99 = 0;
    int64_t _103 = 0; // x
    int64_t _104 = 0; // w
    int64_t _105 = 0; // v
    _jump1386:; // Begin body of loop
    _99 += c;
    _103++;
    if (_103 < _102)
    goto _jump1386;
    _103 = 0;
    _104++;
    if (_104 < _100)
    goto _jump1386;
    _104 = 0;
    _105++;
    if (_105 < o.d1)
    goto _jump1386;
    // End body of loop
    int64_t _106 = _98 / _99;
    if (_106 > 0) 
    goto _jump1387;
    fail_assertion("non-positive loop bound");
    _jump1387:;
    _94 = 0;
    int64_t _107 = 0; // w
    int64_t _108 = 0; // v
    _jump1388:; // Begin body of loop
    int64_t _109;
    // Computing bound for x
    int64_t _110;
    // Computing bound for x
    if (d > 0) 
    goto _jump1389;
    fail_assertion("non-positive loop bound");
    _jump1389:;
    // Computing bound for y
    if (d > 0) 
    goto _jump1390;
    fail_assertion("non-positive loop bound");
    _jump1390:;
    // Computing bound for z
    int64_t _111 = -_108;
    if (_111 > 0) 
    goto _jump1391;
    fail_assertion("non-positive loop bound");
    _jump1391:;
    _110 = 0;
    int64_t _112 = 0; // z
    int64_t _113 = 0; // y
    int64_t _114 = 0; // x
    _jump1392:; // Begin body of loop
    _110 += _113;
    _112++;
    if (_112 < _111)
    goto _jump1392;
    _112 = 0;
    _113++;
    if (_113 < d)
    goto _jump1392;
    _113 = 0;
    _114++;
    if (_114 < d)
    goto _jump1392;
    // End body of loop
    if (_110 > 0) 
    goto _jump1393;
    fail_assertion("non-positive loop bound");
    _jump1393:;
    // Computing bound for y
    if (c > 0) 
    goto _jump1394;
    fail_assertion("non-positive loop bound");
    _jump1394:;
    // Computing bound for z
    bool _115 = b.d0 == c;
    int64_t _116;
    if (!_115)
    goto _jump1395;
    _116 = d;
    goto _jump1396;
    _jump1395:;
    int64_t _117 = -d;
    _116 = _117;
    _jump1396:;
    if (_116 > 0) 
    goto _jump1397;
    fail_assertion("non-positive loop bound");
    _jump1397:;
    _109 = 0;
    int64_t _118 = 0; // z
    int64_t _119 = 0; // y
    int64_t _120 = 0; // x
    _jump1398:; // Begin body of loop
    _109 += _119;
    _118++;
    if (_118 < _116)
    goto _jump1398;
    _118 = 0;
    _119++;
    if (_119 < c)
    goto _jump1398;
    _119 = 0;
    _120++;
    if (_120 < _110)
    goto _jump1398;
    // End body of loop
    _94 += _109;
    _107++;
    if (_107 < _106)
    goto _jump1388;
    _107 = 0;
    _108++;
    if (_108 < b.d0)
    goto _jump1388;
    // End body of loop
    int64_t _121;
    // Computing bound for v
    if (o.d1 > 0) 
    goto _jump1399;
    fail_assertion("non-positive loop bound");
    _jump1399:;
    // Computing bound for w
    _a1_int64_t _122;
    // Computing bound for v
    int64_t _123 = 189;
    _122.d0 = _123;
    if (_123 > 0) 
    goto _jump1400;
    fail_assertion("non-positive loop bound");
    _jump1400:;
    // Computing total size of heap memory to allocate
    int64_t _124 = 1;
    _124 *= _123;
    _124 *= sizeof(int64_t);
    _122.data = jpl_alloc(_124);
    int64_t _125 = 0; // v
    _jump1401:; // Begin body of loop
    int64_t _126;
    if (!_0)
    goto _jump1402;
    _126 = b.d0;
    goto _jump1403;
    _jump1402:;
    _126 = d;
    _jump1403:;
    int64_t _127 = 0;
    _127 *= _122.d0;
    _127 += _125;
    _122.data[_127] = _126;
    _125++;
    if (_125 < _123)
    goto _jump1401;
    // End body of loop
    int64_t _128;
    // Computing bound for v
    int64_t _129 = 729;
    int64_t _130 = -_129;
    if (_130 > 0) 
    goto _jump1404;
    fail_assertion("non-positive loop bound");
    _jump1404:;
    // Computing bound for w
    int64_t _131 = 830;
    if (_131 > 0) 
    goto _jump1405;
    fail_assertion("non-positive loop bound");
    _jump1405:;
    _128 = 0;
    int64_t _132 = 0; // w
    int64_t _133 = 0; // v
    _jump1406:; // Begin body of loop
    _128 += _132;
    _132++;
    if (_132 < _131)
    goto _jump1406;
    _132 = 0;
    _133++;
    if (_133 < _130)
    goto _jump1406;
    // End body of loop
    if (_128 >= 0)
    goto _jump1407;
    fail_assertion("negative array index");
    _jump1407:;
    if (_128 < _122.d0)
    goto _jump1408;
    fail_assertion("index too large");
    _jump1408:;
    int64_t _134 = 0;
    _134 *= _122.d0;
    _134 += _128;
    int64_t _135 = _122.data[_134];
    if (_135 > 0) 
    goto _jump1409;
    fail_assertion("non-positive loop bound");
    _jump1409:;
    // Computing bound for x
    int64_t _136;
    if (!k)
    goto _jump1410;
    _136 = j;
    goto _jump1411;
    _jump1410:;
    _136 = b.d1;
    _jump1411:;
    int64_t _137 = -_136;
    if (_137 > 0) 
    goto _jump1412;
    fail_assertion("non-positive loop bound");
    _jump1412:;
    _121 = 0;
    int64_t _138 = 0; // x
    int64_t _139 = 0; // w
    int64_t _140 = 0; // v
    _jump1413:; // Begin body of loop
    _121 += b.d1;
    _138++;
    if (_138 < _137)
    goto _jump1413;
    _138 = 0;
    _139++;
    if (_139 < _135)
    goto _jump1413;
    _139 = 0;
    _140++;
    if (_140 < o.d1)
    goto _jump1413;
    // End body of loop
    int64_t _141 = 109;
    _a3_void_t _142;
    // Computing bound for v
    _a2_int64_t _143;
    if (!k)
    goto _jump1414;
    _143 = b;
    goto _jump1415;
    _jump1414:;
    _143 = b;
    _jump1415:;
    if (c >= 0)
    goto _jump1416;
    fail_assertion("negative array index");
    _jump1416:;
    if (c < _143.d0)
    goto _jump1417;
    fail_assertion("index too large");
    _jump1417:;
    if (b.d0 >= 0)
    goto _jump1418;
    fail_assertion("negative array index");
    _jump1418:;
    if (b.d0 < _143.d1)
    goto _jump1419;
    fail_assertion("index too large");
    _jump1419:;
    int64_t _144 = 0;
    _144 *= _143.d0;
    _144 += c;
    _144 *= _143.d1;
    _144 += b.d0;
    int64_t _145 = _143.data[_144];
    _142.d0 = _145;
    if (_145 > 0) 
    goto _jump1420;
    fail_assertion("non-positive loop bound");
    _jump1420:;
    // Computing bound for w
    int64_t _146;
    // Computing bound for v
    if (b.d0 > 0) 
    goto _jump1421;
    fail_assertion("non-positive loop bound");
    _jump1421:;
    // Computing bound for w
    if (d > 0) 
    goto _jump1422;
    fail_assertion("non-positive loop bound");
    _jump1422:;
    // Computing bound for x
    if (o.d0 > 0) 
    goto _jump1423;
    fail_assertion("non-positive loop bound");
    _jump1423:;
    _146 = 0;
    int64_t _147 = 0; // x
    int64_t _148 = 0; // w
    int64_t _149 = 0; // v
    _jump1424:; // Begin body of loop
    int64_t _150;
    if (!k)
    goto _jump1425;
    _150 = o.d0;
    goto _jump1426;
    _jump1425:;
    _150 = _149;
    _jump1426:;
    _146 += _150;
    _147++;
    if (_147 < o.d0)
    goto _jump1424;
    _147 = 0;
    _148++;
    if (_148 < d)
    goto _jump1424;
    _148 = 0;
    _149++;
    if (_149 < b.d0)
    goto _jump1424;
    // End body of loop
    _142.d1 = _146;
    if (_146 > 0) 
    goto _jump1427;
    fail_assertion("non-positive loop bound");
    _jump1427:;
    // Computing bound for x
    _a2_int64_t _151;
    // Computing bound for v
    _151.d0 = o.d0;
    if (o.d0 > 0) 
    goto _jump1428;
    fail_assertion("non-positive loop bound");
    _jump1428:;
    // Computing bound for w
    _151.d1 = o.d1;
    if (o.d1 > 0) 
    goto _jump1429;
    fail_assertion("non-positive loop bound");
    _jump1429:;
    // Computing total size of heap memory to allocate
    int64_t _152 = 1;
    _152 *= o.d0;
    _152 *= o.d1;
    _152 *= sizeof(int64_t);
    _151.data = jpl_alloc(_152);
    int64_t _153 = 0; // w
    int64_t _154 = 0; // v
    _jump1430:; // Begin body of loop
    int64_t _155 = 0;
    _155 *= _151.d0;
    _155 += _154;
    _155 *= _151.d1;
    _155 += _153;
    _151.data[_155] = b.d1;
    _153++;
    if (_153 < o.d1)
    goto _jump1430;
    _153 = 0;
    _154++;
    if (_154 < o.d0)
    goto _jump1430;
    // End body of loop
    bool _156 = false;
    int64_t _157;
    if (!_156)
    goto _jump1431;
    _157 = b.d1;
    goto _jump1432;
    _jump1431:;
    int64_t _158 = 543;
    _157 = _158;
    _jump1432:;
    if (_157 >= 0)
    goto _jump1433;
    fail_assertion("negative array index");
    _jump1433:;
    if (_157 < _151.d0)
    goto _jump1434;
    fail_assertion("index too large");
    _jump1434:;
    if (j >= 0)
    goto _jump1435;
    fail_assertion("negative array index");
    _jump1435:;
    if (j < _151.d1)
    goto _jump1436;
    fail_assertion("index too large");
    _jump1436:;
    int64_t _159 = 0;
    _159 *= _151.d0;
    _159 += _157;
    _159 *= _151.d1;
    _159 += j;
    int64_t _160 = _151.data[_159];
    _142.d2 = _160;
    if (_160 > 0) 
    goto _jump1437;
    fail_assertion("non-positive loop bound");
    _jump1437:;
    // Computing total size of heap memory to allocate
    int64_t _161 = 1;
    _161 *= _145;
    _161 *= _146;
    _161 *= _160;
    _161 *= sizeof(void_t);
    _142.data = jpl_alloc(_161);
    int64_t _162 = 0; // x
    int64_t _163 = 0; // w
    int64_t _164 = 0; // v
    _jump1438:; // Begin body of loop
    bool _165 = true;
    void_t _166;
    if (!_165)
    goto _jump1439;
    a _167 = h();
    void_t _168 = _167.a;
    _166 = _168;
    goto _jump1440;
    _jump1439:;
    a _169 = h();
    void_t _170 = _169.a;
    _166 = _170;
    _jump1440:;
    int64_t _171 = 0;
    _171 *= _142.d0;
    _171 += _164;
    _171 *= _142.d1;
    _171 += _163;
    _171 *= _142.d2;
    _171 += _162;
    _142.data[_171] = _166;
    _162++;
    if (_162 < _160)
    goto _jump1438;
    _162 = 0;
    _163++;
    if (_163 < _146)
    goto _jump1438;
    _163 = 0;
    _164++;
    if (_164 < _145)
    goto _jump1438;
    // End body of loop
    bool _172 = true;
    int64_t _173 = l(_141, _142, _172);
    if (_94 >= 0)
    goto _jump1441;
    fail_assertion("negative array index");
    _jump1441:;
    if (_94 < _85.d0)
    goto _jump1442;
    fail_assertion("index too large");
    _jump1442:;
    if (_121 >= 0)
    goto _jump1443;
    fail_assertion("negative array index");
    _jump1443:;
    if (_121 < _85.d1)
    goto _jump1444;
    fail_assertion("index too large");
    _jump1444:;
    if (_173 >= 0)
    goto _jump1445;
    fail_assertion("negative array index");
    _jump1445:;
    if (_173 < _85.d2)
    goto _jump1446;
    fail_assertion("index too large");
    _jump1446:;
    int64_t _174 = 0;
    _174 *= _85.d0;
    _174 += _94;
    _174 *= _85.d1;
    _174 += _121;
    _174 *= _85.d2;
    _174 += _173;
    double _175 = _85.data[_174];
    bool _176 = true;
    double _177 = g(_176);
    _a1_bool _178;
    // Computing bound for v
    int64_t _179 = -j;
    _178.d0 = _179;
    if (_179 > 0) 
    goto _jump1447;
    fail_assertion("non-positive loop bound");
    _jump1447:;
    // Computing total size of heap memory to allocate
    int64_t _180 = 1;
    _180 *= _179;
    _180 *= sizeof(bool);
    _178.data = jpl_alloc(_180);
    int64_t _181 = 0; // v
    _jump1448:; // Begin body of loop
    bool _182 = false;
    int64_t _183 = 0;
    _183 *= _178.d0;
    _183 += _181;
    _178.data[_183] = _182;
    _181++;
    if (_181 < _179)
    goto _jump1448;
    // End body of loop
    if (o.d1 >= 0)
    goto _jump1449;
    fail_assertion("negative array index");
    _jump1449:;
    if (o.d1 < _178.d0)
    goto _jump1450;
    fail_assertion("index too large");
    _jump1450:;
    int64_t _184 = 0;
    _184 *= _178.d0;
    _184 += o.d1;
    bool _185 = _178.data[_184];
    double _186;
    if (!_185)
    goto _jump1451;
    double _187 = 47.0;
    _186 = _187;
    goto _jump1452;
    _jump1451:;
    double _188 = n.a;
    _186 = _188;
    _jump1452:;
    _a1_a _189;
    // Computing bound for v
    _189.d0 = b.d0;
    if (b.d0 > 0) 
    goto _jump1453;
    fail_assertion("non-positive loop bound");
    _jump1453:;
    // Computing total size of heap memory to allocate
    int64_t _190 = 1;
    _190 *= b.d0;
    _190 *= sizeof(a);
    _189.data = jpl_alloc(_190);
    int64_t _191 = 0; // v
    _jump1454:; // Begin body of loop
    a _192 = h();
    int64_t _193 = 0;
    _193 *= _189.d0;
    _193 += _191;
    _189.data[_193] = _192;
    _191++;
    if (_191 < b.d0)
    goto _jump1454;
    // End body of loop
    if (b.d1 >= 0)
    goto _jump1455;
    fail_assertion("negative array index");
    _jump1455:;
    if (b.d1 < _189.d0)
    goto _jump1456;
    fail_assertion("index too large");
    _jump1456:;
    int64_t _194 = 0;
    _194 *= _189.d0;
    _194 += b.d1;
    a _195 = _189.data[_194];
    double _196 = _195.b;
    double _197 = -_196;
    double _198 = _186 + _197;
    rgba _199 = { _84, _175, _177, _198 };
    a _200 = m(_199, o);
    return _200;
    _a3__a2_double _201;
    // Computing bound for v
    _a1_int64_t _202;
    // Computing bound for v
    _202.d0 = o.d1;
    if (o.d1 > 0) 
    goto _jump1457;
    fail_assertion("non-positive loop bound");
    _jump1457:;
    // Computing total size of heap memory to allocate
    int64_t _203 = 1;
    _203 *= o.d1;
    _203 *= sizeof(int64_t);
    _202.data = jpl_alloc(_203);
    int64_t _204 = 0; // v
    _jump1458:; // Begin body of loop
    int64_t _205 = 0;
    _205 *= _202.d0;
    _205 += _204;
    _202.data[_205] = o.d1;
    _204++;
    if (_204 < o.d1)
    goto _jump1458;
    // End body of loop
    if (d >= 0)
    goto _jump1459;
    fail_assertion("negative array index");
    _jump1459:;
    if (d < _202.d0)
    goto _jump1460;
    fail_assertion("index too large");
    _jump1460:;
    int64_t _206 = 0;
    _206 *= _202.d0;
    _206 += d;
    int64_t _207 = _202.data[_206];
    bool _208 = d <= o.d0;
    bool _209 = !_208;
    int64_t _210;
    if (!_209)
    goto _jump1461;
    _a3_int64_t _211;
    // Computing bound for v
    _211.d0 = d;
    if (d > 0) 
    goto _jump1462;
    fail_assertion("non-positive loop bound");
    _jump1462:;
    // Computing bound for w
    int64_t _212 = 821;
    _211.d1 = _212;
    if (_212 > 0) 
    goto _jump1463;
    fail_assertion("non-positive loop bound");
    _jump1463:;
    // Computing bound for x
    _211.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump1464;
    fail_assertion("non-positive loop bound");
    _jump1464:;
    // Computing total size of heap memory to allocate
    int64_t _213 = 1;
    _213 *= d;
    _213 *= _212;
    _213 *= o.d0;
    _213 *= sizeof(int64_t);
    _211.data = jpl_alloc(_213);
    int64_t _214 = 0; // x
    int64_t _215 = 0; // w
    int64_t _216 = 0; // v
    _jump1465:; // Begin body of loop
    int64_t _217 = 0;
    _217 *= _211.d0;
    _217 += _216;
    _217 *= _211.d1;
    _217 += _215;
    _217 *= _211.d2;
    _217 += _214;
    _211.data[_217] = o.d0;
    _214++;
    if (_214 < o.d0)
    goto _jump1465;
    _214 = 0;
    _215++;
    if (_215 < _212)
    goto _jump1465;
    _215 = 0;
    _216++;
    if (_216 < d)
    goto _jump1465;
    // End body of loop
    int64_t _218;
    // Computing bound for v
    if (b.d1 > 0) 
    goto _jump1466;
    fail_assertion("non-positive loop bound");
    _jump1466:;
    // Computing bound for w
    if (d > 0) 
    goto _jump1467;
    fail_assertion("non-positive loop bound");
    _jump1467:;
    _218 = 0;
    int64_t _219 = 0; // w
    int64_t _220 = 0; // v
    _jump1468:; // Begin body of loop
    _218 += _220;
    _219++;
    if (_219 < d)
    goto _jump1468;
    _219 = 0;
    _220++;
    if (_220 < b.d1)
    goto _jump1468;
    // End body of loop
    if (d >= 0)
    goto _jump1469;
    fail_assertion("negative array index");
    _jump1469:;
    if (d < _211.d0)
    goto _jump1470;
    fail_assertion("index too large");
    _jump1470:;
    if (o.d0 >= 0)
    goto _jump1471;
    fail_assertion("negative array index");
    _jump1471:;
    if (o.d0 < _211.d1)
    goto _jump1472;
    fail_assertion("index too large");
    _jump1472:;
    if (_218 >= 0)
    goto _jump1473;
    fail_assertion("negative array index");
    _jump1473:;
    if (_218 < _211.d2)
    goto _jump1474;
    fail_assertion("index too large");
    _jump1474:;
    int64_t _221 = 0;
    _221 *= _211.d0;
    _221 += d;
    _221 *= _211.d1;
    _221 += o.d0;
    _221 *= _211.d2;
    _221 += _218;
    int64_t _222 = _211.data[_221];
    _210 = _222;
    goto _jump1475;
    _jump1461:;
    int64_t _223 = 426;
    _210 = _223;
    _jump1475:;
    int64_t _224 = _207 % _210;
    _a1_int64_t _225;
    _225.d0 = 3;
    _225.data = jpl_alloc(sizeof(int64_t) * 3);
    _225.data[0] = b.d1;
    _225.data[1] = j;
    _225.data[2] = _224;
    int64_t _226;
    // Computing bound for v
    int64_t _227;
    // Computing bound for v
    int64_t _228 = 927;
    int64_t _229 = -_228;
    if (_229 > 0) 
    goto _jump1476;
    fail_assertion("non-positive loop bound");
    _jump1476:;
    // Computing bound for w
    if (c > 0) 
    goto _jump1477;
    fail_assertion("non-positive loop bound");
    _jump1477:;
    _227 = 0;
    int64_t _230 = 0; // w
    int64_t _231 = 0; // v
    _jump1478:; // Begin body of loop
    _a2_int64_t _232;
    // Computing bound for x
    _232.d0 = j;
    if (j > 0) 
    goto _jump1479;
    fail_assertion("non-positive loop bound");
    _jump1479:;
    // Computing bound for y
    _232.d1 = b.d0;
    if (b.d0 > 0) 
    goto _jump1480;
    fail_assertion("non-positive loop bound");
    _jump1480:;
    // Computing total size of heap memory to allocate
    int64_t _233 = 1;
    _233 *= j;
    _233 *= b.d0;
    _233 *= sizeof(int64_t);
    _232.data = jpl_alloc(_233);
    int64_t _234 = 0; // y
    int64_t _235 = 0; // x
    _jump1481:; // Begin body of loop
    int64_t _236 = 0;
    _236 *= _232.d0;
    _236 += _235;
    _236 *= _232.d1;
    _236 += _234;
    _232.data[_236] = b.d0;
    _234++;
    if (_234 < b.d0)
    goto _jump1481;
    _234 = 0;
    _235++;
    if (_235 < j)
    goto _jump1481;
    // End body of loop
    if (j >= 0)
    goto _jump1482;
    fail_assertion("negative array index");
    _jump1482:;
    if (j < _232.d0)
    goto _jump1483;
    fail_assertion("index too large");
    _jump1483:;
    if (c >= 0)
    goto _jump1484;
    fail_assertion("negative array index");
    _jump1484:;
    if (c < _232.d1)
    goto _jump1485;
    fail_assertion("index too large");
    _jump1485:;
    int64_t _237 = 0;
    _237 *= _232.d0;
    _237 += j;
    _237 *= _232.d1;
    _237 += c;
    int64_t _238 = _232.data[_237];
    _227 += _238;
    _230++;
    if (_230 < c)
    goto _jump1478;
    _230 = 0;
    _231++;
    if (_231 < _229)
    goto _jump1478;
    // End body of loop
    int64_t _239 = -_227;
    if (_239 > 0) 
    goto _jump1486;
    fail_assertion("non-positive loop bound");
    _jump1486:;
    // Computing bound for w
    int64_t _240;
    // Computing bound for v
    if (b.d1 > 0) 
    goto _jump1487;
    fail_assertion("non-positive loop bound");
    _jump1487:;
    _240 = 0;
    int64_t _241 = 0; // v
    _jump1488:; // Begin body of loop
    bool _242 = true;
    bool _243 = _242 == k;
    int64_t _244;
    if (!_243)
    goto _jump1489;
    _244 = o.d1;
    goto _jump1490;
    _jump1489:;
    _244 = c;
    _jump1490:;
    int64_t _245 = c - _244;
    _240 += _245;
    _241++;
    if (_241 < b.d1)
    goto _jump1488;
    // End body of loop
    if (_240 > 0) 
    goto _jump1491;
    fail_assertion("non-positive loop bound");
    _jump1491:;
    // Computing bound for x
    if (b.d0 > 0) 
    goto _jump1492;
    fail_assertion("non-positive loop bound");
    _jump1492:;
    _226 = 0;
    int64_t _246 = 0; // x
    int64_t _247 = 0; // w
    int64_t _248 = 0; // v
    _jump1493:; // Begin body of loop
    _a3_void_t _249;
    // Computing bound for y
    _249.d0 = _247;
    if (_247 > 0) 
    goto _jump1494;
    fail_assertion("non-positive loop bound");
    _jump1494:;
    // Computing bound for z
    bool _250 = true;
    bool _251;
    if (!_250)
    goto _jump1495;
    _251 = k;
    goto _jump1496;
    _jump1495:;
    bool _252 = false;
    _251 = _252;
    _jump1496:;
    int64_t _253;
    if (!_251)
    goto _jump1497;
    _253 = o.d1;
    goto _jump1498;
    _jump1497:;
    _253 = _248;
    _jump1498:;
    _249.d1 = _253;
    if (_253 > 0) 
    goto _jump1499;
    fail_assertion("non-positive loop bound");
    _jump1499:;
    // Computing bound for A
    _249.d2 = d;
    if (d > 0) 
    goto _jump1500;
    fail_assertion("non-positive loop bound");
    _jump1500:;
    // Computing total size of heap memory to allocate
    int64_t _254 = 1;
    _254 *= _247;
    _254 *= _253;
    _254 *= d;
    _254 *= sizeof(void_t);
    _249.data = jpl_alloc(_254);
    int64_t _255 = 0; // A
    int64_t _256 = 0; // z
    int64_t _257 = 0; // y
    _jump1501:; // Begin body of loop
    bool _258 = _0 != _0;
    void_t _259;
    if (!_258)
    goto _jump1502;
    a _260 = h();
    void_t _261 = _260.a;
    _259 = _261;
    goto _jump1503;
    _jump1502:;
    a _262 = h();
    void_t _263 = _262.a;
    _259 = _263;
    _jump1503:;
    int64_t _264 = 0;
    _264 *= _249.d0;
    _264 += _257;
    _264 *= _249.d1;
    _264 += _256;
    _264 *= _249.d2;
    _264 += _255;
    _249.data[_264] = _259;
    _255++;
    if (_255 < d)
    goto _jump1501;
    _255 = 0;
    _256++;
    if (_256 < _253)
    goto _jump1501;
    _256 = 0;
    _257++;
    if (_257 < _247)
    goto _jump1501;
    // End body of loop
    double _265 = 77.0;
    bool _266 = true;
    double _267 = g(_266);
    bool _268 = _265 > _267;
    bool _269;
    if (!_268)
    goto _jump1504;
    bool _270 = !_0;
    bool _271 = !_270;
    _269 = _271;
    goto _jump1505;
    _jump1504:;
    bool _272 = o.d0 != b.d1;
    bool _273 = k == _272;
    _269 = _273;
    _jump1505:;
    int64_t _274 = l(_246, _249, _269);
    _226 += _274;
    _246++;
    if (_246 < b.d0)
    goto _jump1493;
    _246 = 0;
    _247++;
    if (_247 < _240)
    goto _jump1493;
    _247 = 0;
    _248++;
    if (_248 < _239)
    goto _jump1493;
    // End body of loop
    if (_226 >= 0)
    goto _jump1506;
    fail_assertion("negative array index");
    _jump1506:;
    if (_226 < _225.d0)
    goto _jump1507;
    fail_assertion("index too large");
    _jump1507:;
    int64_t _275 = 0;
    _275 *= _225.d0;
    _275 += _226;
    int64_t _276 = _225.data[_275];
    _201.d0 = _276;
    if (_276 > 0) 
    goto _jump1508;
    fail_assertion("non-positive loop bound");
    _jump1508:;
    // Computing bound for w
    _a3__a3_int64_t _277;
    // Computing bound for v
    int64_t _278;
    // Computing bound for v
    int64_t _279 = 502;
    bool _280 = _279 != b.d1;
    int64_t _281;
    if (!_280)
    goto _jump1509;
    _281 = c;
    goto _jump1510;
    _jump1509:;
    _281 = j;
    _jump1510:;
    if (_281 > 0) 
    goto _jump1511;
    fail_assertion("non-positive loop bound");
    _jump1511:;
    _278 = 0;
    int64_t _282 = 0; // v
    _jump1512:; // Begin body of loop
    int64_t _283;
    // Computing bound for w
    if (_282 > 0) 
    goto _jump1513;
    fail_assertion("non-positive loop bound");
    _jump1513:;
    // Computing bound for x
    if (o.d0 > 0) 
    goto _jump1514;
    fail_assertion("non-positive loop bound");
    _jump1514:;
    // Computing bound for y
    if (j > 0) 
    goto _jump1515;
    fail_assertion("non-positive loop bound");
    _jump1515:;
    _283 = 0;
    int64_t _284 = 0; // y
    int64_t _285 = 0; // x
    int64_t _286 = 0; // w
    _jump1516:; // Begin body of loop
    bool _287 = false;
    int64_t _288;
    if (!_287)
    goto _jump1517;
    _288 = j;
    goto _jump1518;
    _jump1517:;
    _288 = o.d0;
    _jump1518:;
    _283 += _288;
    _284++;
    if (_284 < j)
    goto _jump1516;
    _284 = 0;
    _285++;
    if (_285 < o.d0)
    goto _jump1516;
    _285 = 0;
    _286++;
    if (_286 < _282)
    goto _jump1516;
    // End body of loop
    _278 += _283;
    _282++;
    if (_282 < _281)
    goto _jump1512;
    // End body of loop
    _277.d0 = _278;
    if (_278 > 0) 
    goto _jump1519;
    fail_assertion("non-positive loop bound");
    _jump1519:;
    // Computing bound for w
    int64_t _289;
    // Computing bound for v
    if (c > 0) 
    goto _jump1520;
    fail_assertion("non-positive loop bound");
    _jump1520:;
    _289 = 0;
    int64_t _290 = 0; // v
    _jump1521:; // Begin body of loop
    _289 += o.d1;
    _290++;
    if (_290 < c)
    goto _jump1521;
    // End body of loop
    _277.d1 = _289;
    if (_289 > 0) 
    goto _jump1522;
    fail_assertion("non-positive loop bound");
    _jump1522:;
    // Computing bound for x
    _277.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump1523;
    fail_assertion("non-positive loop bound");
    _jump1523:;
    // Computing total size of heap memory to allocate
    int64_t _291 = 1;
    _291 *= _278;
    _291 *= _289;
    _291 *= o.d1;
    _291 *= sizeof(_a3_int64_t);
    _277.data = jpl_alloc(_291);
    int64_t _292 = 0; // x
    int64_t _293 = 0; // w
    int64_t _294 = 0; // v
    _jump1524:; // Begin body of loop
    _a3_int64_t _295;
    if (!k)
    goto _jump1525;
    _a3_int64_t _296;
    // Computing bound for y
    int64_t _297 = 368;
    _296.d0 = _297;
    if (_297 > 0) 
    goto _jump1526;
    fail_assertion("non-positive loop bound");
    _jump1526:;
    // Computing bound for z
    _296.d1 = b.d1;
    if (b.d1 > 0) 
    goto _jump1527;
    fail_assertion("non-positive loop bound");
    _jump1527:;
    // Computing bound for A
    int64_t _298 = -o.d1;
    _296.d2 = _298;
    if (_298 > 0) 
    goto _jump1528;
    fail_assertion("non-positive loop bound");
    _jump1528:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= _297;
    _299 *= b.d1;
    _299 *= _298;
    _299 *= sizeof(int64_t);
    _296.data = jpl_alloc(_299);
    int64_t _300 = 0; // A
    int64_t _301 = 0; // z
    int64_t _302 = 0; // y
    _jump1529:; // Begin body of loop
    int64_t _303 = 0;
    _303 *= _296.d0;
    _303 += _302;
    _303 *= _296.d1;
    _303 += _301;
    _303 *= _296.d2;
    _303 += _300;
    _296.data[_303] = _302;
    _300++;
    if (_300 < _298)
    goto _jump1529;
    _300 = 0;
    _301++;
    if (_301 < b.d1)
    goto _jump1529;
    _301 = 0;
    _302++;
    if (_302 < _297)
    goto _jump1529;
    // End body of loop
    _295 = _296;
    goto _jump1530;
    _jump1525:;
    bool _304 = true;
    _a3_int64_t _305;
    if (!_304)
    goto _jump1531;
    _a3_int64_t _306;
    // Computing bound for y
    _306.d0 = j;
    if (j > 0) 
    goto _jump1532;
    fail_assertion("non-positive loop bound");
    _jump1532:;
    // Computing bound for z
    _306.d1 = j;
    if (j > 0) 
    goto _jump1533;
    fail_assertion("non-positive loop bound");
    _jump1533:;
    // Computing bound for A
    _306.d2 = _293;
    if (_293 > 0) 
    goto _jump1534;
    fail_assertion("non-positive loop bound");
    _jump1534:;
    // Computing total size of heap memory to allocate
    int64_t _307 = 1;
    _307 *= j;
    _307 *= j;
    _307 *= _293;
    _307 *= sizeof(int64_t);
    _306.data = jpl_alloc(_307);
    int64_t _308 = 0; // A
    int64_t _309 = 0; // z
    int64_t _310 = 0; // y
    _jump1535:; // Begin body of loop
    int64_t _311 = 0;
    _311 *= _306.d0;
    _311 += _310;
    _311 *= _306.d1;
    _311 += _309;
    _311 *= _306.d2;
    _311 += _308;
    _306.data[_311] = _293;
    _308++;
    if (_308 < _293)
    goto _jump1535;
    _308 = 0;
    _309++;
    if (_309 < j)
    goto _jump1535;
    _309 = 0;
    _310++;
    if (_310 < j)
    goto _jump1535;
    // End body of loop
    _305 = _306;
    goto _jump1536;
    _jump1531:;
    _a3_int64_t _312;
    // Computing bound for y
    _312.d0 = _293;
    if (_293 > 0) 
    goto _jump1537;
    fail_assertion("non-positive loop bound");
    _jump1537:;
    // Computing bound for z
    _312.d1 = _294;
    if (_294 > 0) 
    goto _jump1538;
    fail_assertion("non-positive loop bound");
    _jump1538:;
    // Computing bound for A
    _312.d2 = _293;
    if (_293 > 0) 
    goto _jump1539;
    fail_assertion("non-positive loop bound");
    _jump1539:;
    // Computing total size of heap memory to allocate
    int64_t _313 = 1;
    _313 *= _293;
    _313 *= _294;
    _313 *= _293;
    _313 *= sizeof(int64_t);
    _312.data = jpl_alloc(_313);
    int64_t _314 = 0; // A
    int64_t _315 = 0; // z
    int64_t _316 = 0; // y
    _jump1540:; // Begin body of loop
    int64_t _317 = 0;
    _317 *= _312.d0;
    _317 += _316;
    _317 *= _312.d1;
    _317 += _315;
    _317 *= _312.d2;
    _317 += _314;
    _312.data[_317] = _294;
    _314++;
    if (_314 < _293)
    goto _jump1540;
    _314 = 0;
    _315++;
    if (_315 < _294)
    goto _jump1540;
    _315 = 0;
    _316++;
    if (_316 < _293)
    goto _jump1540;
    // End body of loop
    _305 = _312;
    _jump1536:;
    _295 = _305;
    _jump1530:;
    int64_t _318 = 0;
    _318 *= _277.d0;
    _318 += _294;
    _318 *= _277.d1;
    _318 += _293;
    _318 *= _277.d2;
    _318 += _292;
    _277.data[_318] = _295;
    _292++;
    if (_292 < o.d1)
    goto _jump1524;
    _292 = 0;
    _293++;
    if (_293 < _289)
    goto _jump1524;
    _293 = 0;
    _294++;
    if (_294 < _278)
    goto _jump1524;
    // End body of loop
    if (o.d0 >= 0)
    goto _jump1541;
    fail_assertion("negative array index");
    _jump1541:;
    if (o.d0 < b.d0)
    goto _jump1542;
    fail_assertion("index too large");
    _jump1542:;
    if (o.d1 >= 0)
    goto _jump1543;
    fail_assertion("negative array index");
    _jump1543:;
    if (o.d1 < b.d1)
    goto _jump1544;
    fail_assertion("index too large");
    _jump1544:;
    int64_t _319 = 0;
    _319 *= b.d0;
    _319 += o.d0;
    _319 *= b.d1;
    _319 += o.d1;
    int64_t _320 = b.data[_319];
    int64_t _321 = -_320;
    if (_321 >= 0)
    goto _jump1545;
    fail_assertion("negative array index");
    _jump1545:;
    if (_321 < _277.d0)
    goto _jump1546;
    fail_assertion("index too large");
    _jump1546:;
    if (o.d1 >= 0)
    goto _jump1547;
    fail_assertion("negative array index");
    _jump1547:;
    if (o.d1 < _277.d1)
    goto _jump1548;
    fail_assertion("index too large");
    _jump1548:;
    if (b.d1 >= 0)
    goto _jump1549;
    fail_assertion("negative array index");
    _jump1549:;
    if (b.d1 < _277.d2)
    goto _jump1550;
    fail_assertion("index too large");
    _jump1550:;
    int64_t _322 = 0;
    _322 *= _277.d0;
    _322 += _321;
    _322 *= _277.d1;
    _322 += o.d1;
    _322 *= _277.d2;
    _322 += b.d1;
    _a3_int64_t _323 = _277.data[_322];
    int64_t _324;
    // Computing bound for v
    if (b.d0 > 0) 
    goto _jump1551;
    fail_assertion("non-positive loop bound");
    _jump1551:;
    _324 = 0;
    int64_t _325 = 0; // v
    _jump1552:; // Begin body of loop
    _324 += b.d1;
    _325++;
    if (_325 < b.d0)
    goto _jump1552;
    // End body of loop
    if (_324 >= 0)
    goto _jump1553;
    fail_assertion("negative array index");
    _jump1553:;
    if (_324 < b.d0)
    goto _jump1554;
    fail_assertion("index too large");
    _jump1554:;
    if (o.d1 >= 0)
    goto _jump1555;
    fail_assertion("negative array index");
    _jump1555:;
    if (o.d1 < b.d1)
    goto _jump1556;
    fail_assertion("index too large");
    _jump1556:;
    int64_t _326 = 0;
    _326 *= b.d0;
    _326 += _324;
    _326 *= b.d1;
    _326 += o.d1;
    int64_t _327 = b.data[_326];
    _a3_void_t _328;
    // Computing bound for v
    _328.d0 = j;
    if (j > 0) 
    goto _jump1557;
    fail_assertion("non-positive loop bound");
    _jump1557:;
    // Computing bound for w
    _328.d1 = c;
    if (c > 0) 
    goto _jump1558;
    fail_assertion("non-positive loop bound");
    _jump1558:;
    // Computing bound for x
    _328.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump1559;
    fail_assertion("non-positive loop bound");
    _jump1559:;
    // Computing total size of heap memory to allocate
    int64_t _329 = 1;
    _329 *= j;
    _329 *= c;
    _329 *= o.d0;
    _329 *= sizeof(void_t);
    _328.data = jpl_alloc(_329);
    int64_t _330 = 0; // x
    int64_t _331 = 0; // w
    int64_t _332 = 0; // v
    _jump1560:; // Begin body of loop
    a _333;
    if (!k)
    goto _jump1561;
    a _334 = h();
    _333 = _334;
    goto _jump1562;
    _jump1561:;
    a _335;
    if (!k)
    goto _jump1563;
    a _336 = h();
    _335 = _336;
    goto _jump1564;
    _jump1563:;
    a _337 = h();
    _335 = _337;
    _jump1564:;
    _333 = _335;
    _jump1562:;
    void_t _338 = _333.a;
    int64_t _339 = 0;
    _339 *= _328.d0;
    _339 += _332;
    _339 *= _328.d1;
    _339 += _331;
    _339 *= _328.d2;
    _339 += _330;
    _328.data[_339] = _338;
    _330++;
    if (_330 < o.d0)
    goto _jump1560;
    _330 = 0;
    _331++;
    if (_331 < c)
    goto _jump1560;
    _331 = 0;
    _332++;
    if (_332 < j)
    goto _jump1560;
    // End body of loop
    bool _340;
    if (!k)
    goto _jump1565;
    int64_t _341 = j / c;
    bool _342 = _341 > b.d0;
    _340 = _342;
    goto _jump1566;
    _jump1565:;
    bool _343 = false;
    _340 = _343;
    _jump1566:;
    int64_t _344 = l(_327, _328, _340);
    int64_t _345;
    // Computing bound for v
    if (o.d1 > 0) 
    goto _jump1567;
    fail_assertion("non-positive loop bound");
    _jump1567:;
    // Computing bound for w
    if (o.d0 > 0) 
    goto _jump1568;
    fail_assertion("non-positive loop bound");
    _jump1568:;
    _345 = 0;
    int64_t _346 = 0; // w
    int64_t _347 = 0; // v
    _jump1569:; // Begin body of loop
    _345 += _347;
    _346++;
    if (_346 < o.d0)
    goto _jump1569;
    _346 = 0;
    _347++;
    if (_347 < o.d1)
    goto _jump1569;
    // End body of loop
    if (_344 >= 0)
    goto _jump1570;
    fail_assertion("negative array index");
    _jump1570:;
    if (_344 < _323.d0)
    goto _jump1571;
    fail_assertion("index too large");
    _jump1571:;
    if (j >= 0)
    goto _jump1572;
    fail_assertion("negative array index");
    _jump1572:;
    if (j < _323.d1)
    goto _jump1573;
    fail_assertion("index too large");
    _jump1573:;
    if (_345 >= 0)
    goto _jump1574;
    fail_assertion("negative array index");
    _jump1574:;
    if (_345 < _323.d2)
    goto _jump1575;
    fail_assertion("index too large");
    _jump1575:;
    int64_t _348 = 0;
    _348 *= _323.d0;
    _348 += _344;
    _348 *= _323.d1;
    _348 += j;
    _348 *= _323.d2;
    _348 += _345;
    int64_t _349 = _323.data[_348];
    _201.d1 = _349;
    if (_349 > 0) 
    goto _jump1576;
    fail_assertion("non-positive loop bound");
    _jump1576:;
    // Computing bound for x
    _201.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump1577;
    fail_assertion("non-positive loop bound");
    _jump1577:;
    // Computing total size of heap memory to allocate
    int64_t _350 = 1;
    _350 *= _276;
    _350 *= _349;
    _350 *= o.d1;
    _350 *= sizeof(_a2_double);
    _201.data = jpl_alloc(_350);
    int64_t _351 = 0; // x
    int64_t _352 = 0; // w
    int64_t _353 = 0; // v
    _jump1578:; // Begin body of loop
    int64_t _354 = 0;
    _354 *= _201.d0;
    _354 += _353;
    _354 *= _201.d1;
    _354 += _352;
    _354 *= _201.d2;
    _354 += _351;
    _201.data[_354] = o;
    _351++;
    if (_351 < o.d1)
    goto _jump1578;
    _351 = 0;
    _352++;
    if (_352 < _349)
    goto _jump1578;
    _352 = 0;
    _353++;
    if (_353 < _276)
    goto _jump1578;
    // End body of loop
    bool _355;
    if (!_0)
    goto _jump1579;
    bool _356 = !_0;
    _355 = _356;
    goto _jump1580;
    _jump1579:;
    bool _357 = !_0;
    _355 = _357;
    _jump1580:;
    bool _358;
    if (!_355)
    goto _jump1581;
    bool _359 = k;
    if (0 == k)
    goto _jump1582;
    _359 = _0;
    _jump1582:;
    bool _360 = !_359;
    _358 = _360;
    goto _jump1583;
    _jump1581:;
    bool _362;
    if (!k)
    goto _jump1584;
    _362 = _0;
    goto _jump1585;
    _jump1584:;
    bool _363 = false;
    _362 = _363;
    _jump1585:;
    bool _361 = _362;
    if (0 != _362)
    goto _jump1586;
    bool _364 = k;
    if (0 != k)
    goto _jump1587;
    _364 = k;
    _jump1587:;
    _361 = _364;
    _jump1586:;
    _358 = _361;
    _jump1583:;
    bool _365;
    if (!_358)
    goto _jump1588;
    bool _367 = !_0;
    bool _369 = false;
    bool _368 = _369;
    if (0 != _369)
    goto _jump1589;
    _368 = _0;
    _jump1589:;
    bool _370 = _367 == _368;
    bool _366 = _370;
    if (0 == _370)
    goto _jump1590;
    _366 = _0;
    _jump1590:;
    _365 = _366;
    goto _jump1591;
    _jump1588:;
    bool _371;
    if (!_0)
    goto _jump1592;
    bool _372 = false;
    _371 = _372;
    goto _jump1593;
    _jump1592:;
    bool _374 = true;
    bool _373 = _374;
    if (0 != _374)
    goto _jump1594;
    _373 = _0;
    _jump1594:;
    _371 = _373;
    _jump1593:;
    _365 = _371;
    _jump1591:;
    _a3_void_t _375;
    if (!_365)
    goto _jump1595;
    _a3_void_t _376;
    // Computing bound for w
    int64_t _377;
    // Computing bound for w
    if (d > 0) 
    goto _jump1596;
    fail_assertion("non-positive loop bound");
    _jump1596:;
    // Computing bound for x
    if (j > 0) 
    goto _jump1597;
    fail_assertion("non-positive loop bound");
    _jump1597:;
    // Computing bound for y
    if (j > 0) 
    goto _jump1598;
    fail_assertion("non-positive loop bound");
    _jump1598:;
    _377 = 0;
    int64_t _378 = 0; // y
    int64_t _379 = 0; // x
    int64_t _380 = 0; // w
    _jump1599:; // Begin body of loop
    _377 += o.d1;
    _378++;
    if (_378 < j)
    goto _jump1599;
    _378 = 0;
    _379++;
    if (_379 < j)
    goto _jump1599;
    _379 = 0;
    _380++;
    if (_380 < d)
    goto _jump1599;
    // End body of loop
    _376.d0 = _377;
    if (_377 > 0) 
    goto _jump1600;
    fail_assertion("non-positive loop bound");
    _jump1600:;
    // Computing bound for x
    int64_t _381 = -o.d0;
    _376.d1 = _381;
    if (_381 > 0) 
    goto _jump1601;
    fail_assertion("non-positive loop bound");
    _jump1601:;
    // Computing bound for y
    _376.d2 = b.d0;
    if (b.d0 > 0) 
    goto _jump1602;
    fail_assertion("non-positive loop bound");
    _jump1602:;
    // Computing total size of heap memory to allocate
    int64_t _382 = 1;
    _382 *= _377;
    _382 *= _381;
    _382 *= b.d0;
    _382 *= sizeof(void_t);
    _376.data = jpl_alloc(_382);
    int64_t _383 = 0; // y
    int64_t _384 = 0; // x
    int64_t _385 = 0; // w
    _jump1603:; // Begin body of loop
    _a3_void_t _386;
    // Computing bound for z
    _386.d0 = b.d0;
    if (b.d0 > 0) 
    goto _jump1604;
    fail_assertion("non-positive loop bound");
    _jump1604:;
    // Computing bound for A
    int64_t _387 = 367;
    _386.d1 = _387;
    if (_387 > 0) 
    goto _jump1605;
    fail_assertion("non-positive loop bound");
    _jump1605:;
    // Computing bound for B
    bool _388 = false;
    int64_t _389;
    if (!_388)
    goto _jump1606;
    _389 = _383;
    goto _jump1607;
    _jump1606:;
    _389 = b.d0;
    _jump1607:;
    _386.d2 = _389;
    if (_389 > 0) 
    goto _jump1608;
    fail_assertion("non-positive loop bound");
    _jump1608:;
    // Computing total size of heap memory to allocate
    int64_t _390 = 1;
    _390 *= b.d0;
    _390 *= _387;
    _390 *= _389;
    _390 *= sizeof(void_t);
    _386.data = jpl_alloc(_390);
    int64_t _391 = 0; // B
    int64_t _392 = 0; // A
    int64_t _393 = 0; // z
    _jump1609:; // Begin body of loop
    a _394 = h();
    void_t _395 = _394.a;
    int64_t _396 = 0;
    _396 *= _386.d0;
    _396 += _393;
    _396 *= _386.d1;
    _396 += _392;
    _396 *= _386.d2;
    _396 += _391;
    _386.data[_396] = _395;
    _391++;
    if (_391 < _389)
    goto _jump1609;
    _391 = 0;
    _392++;
    if (_392 < _387)
    goto _jump1609;
    _392 = 0;
    _393++;
    if (_393 < b.d0)
    goto _jump1609;
    // End body of loop
    int64_t _397;
    // Computing bound for z
    if (c > 0) 
    goto _jump1610;
    fail_assertion("non-positive loop bound");
    _jump1610:;
    // Computing bound for A
    int64_t _398 = o.d0 + _385;
    if (_398 > 0) 
    goto _jump1611;
    fail_assertion("non-positive loop bound");
    _jump1611:;
    _397 = 0;
    int64_t _399 = 0; // A
    int64_t _400 = 0; // z
    _jump1612:; // Begin body of loop
    _397 += b.d1;
    _399++;
    if (_399 < _398)
    goto _jump1612;
    _399 = 0;
    _400++;
    if (_400 < c)
    goto _jump1612;
    // End body of loop
    int64_t _401;
    // Computing bound for z
    if (_383 > 0) 
    goto _jump1613;
    fail_assertion("non-positive loop bound");
    _jump1613:;
    // Computing bound for A
    if (_383 >= 0)
    goto _jump1614;
    fail_assertion("negative array index");
    _jump1614:;
    if (_383 < b.d0)
    goto _jump1615;
    fail_assertion("index too large");
    _jump1615:;
    if (b.d0 >= 0)
    goto _jump1616;
    fail_assertion("negative array index");
    _jump1616:;
    if (b.d0 < b.d1)
    goto _jump1617;
    fail_assertion("index too large");
    _jump1617:;
    int64_t _402 = 0;
    _402 *= b.d0;
    _402 += _383;
    _402 *= b.d1;
    _402 += b.d0;
    int64_t _403 = b.data[_402];
    if (_403 > 0) 
    goto _jump1618;
    fail_assertion("non-positive loop bound");
    _jump1618:;
    // Computing bound for B
    if (_383 > 0) 
    goto _jump1619;
    fail_assertion("non-positive loop bound");
    _jump1619:;
    _401 = 0;
    int64_t _404 = 0; // B
    int64_t _405 = 0; // A
    int64_t _406 = 0; // z
    _jump1620:; // Begin body of loop
    _401 += o.d0;
    _404++;
    if (_404 < _383)
    goto _jump1620;
    _404 = 0;
    _405++;
    if (_405 < _403)
    goto _jump1620;
    _405 = 0;
    _406++;
    if (_406 < _383)
    goto _jump1620;
    // End body of loop
    if (_397 >= 0)
    goto _jump1621;
    fail_assertion("negative array index");
    _jump1621:;
    if (_397 < _386.d0)
    goto _jump1622;
    fail_assertion("index too large");
    _jump1622:;
    if (o.d0 >= 0)
    goto _jump1623;
    fail_assertion("negative array index");
    _jump1623:;
    if (o.d0 < _386.d1)
    goto _jump1624;
    fail_assertion("index too large");
    _jump1624:;
    if (_401 >= 0)
    goto _jump1625;
    fail_assertion("negative array index");
    _jump1625:;
    if (_401 < _386.d2)
    goto _jump1626;
    fail_assertion("index too large");
    _jump1626:;
    int64_t _407 = 0;
    _407 *= _386.d0;
    _407 += _397;
    _407 *= _386.d1;
    _407 += o.d0;
    _407 *= _386.d2;
    _407 += _401;
    void_t _408 = _386.data[_407];
    int64_t _409 = 0;
    _409 *= _376.d0;
    _409 += _385;
    _409 *= _376.d1;
    _409 += _384;
    _409 *= _376.d2;
    _409 += _383;
    _376.data[_409] = _408;
    _383++;
    if (_383 < b.d0)
    goto _jump1603;
    _383 = 0;
    _384++;
    if (_384 < _381)
    goto _jump1603;
    _384 = 0;
    _385++;
    if (_385 < _377)
    goto _jump1603;
    // End body of loop
    _375 = _376;
    goto _jump1627;
    _jump1595:;
    _a3__a3_void_t _410;
    // Computing bound for w
    int64_t _411;
    if (!k)
    goto _jump1628;
    _411 = b.d0;
    goto _jump1629;
    _jump1628:;
    int64_t _412 = 182;
    _411 = _412;
    _jump1629:;
    _410.d0 = _411;
    if (_411 > 0) 
    goto _jump1630;
    fail_assertion("non-positive loop bound");
    _jump1630:;
    // Computing bound for x
    _a3_int64_t _413;
    // Computing bound for w
    _413.d0 = o.d0;
    if (o.d0 > 0) 
    goto _jump1631;
    fail_assertion("non-positive loop bound");
    _jump1631:;
    // Computing bound for x
    _413.d1 = c;
    if (c > 0) 
    goto _jump1632;
    fail_assertion("non-positive loop bound");
    _jump1632:;
    // Computing bound for y
    _413.d2 = b.d1;
    if (b.d1 > 0) 
    goto _jump1633;
    fail_assertion("non-positive loop bound");
    _jump1633:;
    // Computing total size of heap memory to allocate
    int64_t _414 = 1;
    _414 *= o.d0;
    _414 *= c;
    _414 *= b.d1;
    _414 *= sizeof(int64_t);
    _413.data = jpl_alloc(_414);
    int64_t _415 = 0; // y
    int64_t _416 = 0; // x
    int64_t _417 = 0; // w
    _jump1634:; // Begin body of loop
    int64_t _418 = 0;
    _418 *= _413.d0;
    _418 += _417;
    _418 *= _413.d1;
    _418 += _416;
    _418 *= _413.d2;
    _418 += _415;
    _413.data[_418] = b.d0;
    _415++;
    if (_415 < b.d1)
    goto _jump1634;
    _415 = 0;
    _416++;
    if (_416 < c)
    goto _jump1634;
    _416 = 0;
    _417++;
    if (_417 < o.d0)
    goto _jump1634;
    // End body of loop
    int64_t _419 = b.d1 * o.d0;
    if (b.d0 >= 0)
    goto _jump1635;
    fail_assertion("negative array index");
    _jump1635:;
    if (b.d0 < _413.d0)
    goto _jump1636;
    fail_assertion("index too large");
    _jump1636:;
    if (d >= 0)
    goto _jump1637;
    fail_assertion("negative array index");
    _jump1637:;
    if (d < _413.d1)
    goto _jump1638;
    fail_assertion("index too large");
    _jump1638:;
    if (_419 >= 0)
    goto _jump1639;
    fail_assertion("negative array index");
    _jump1639:;
    if (_419 < _413.d2)
    goto _jump1640;
    fail_assertion("index too large");
    _jump1640:;
    int64_t _420 = 0;
    _420 *= _413.d0;
    _420 += b.d0;
    _420 *= _413.d1;
    _420 += d;
    _420 *= _413.d2;
    _420 += _419;
    int64_t _421 = _413.data[_420];
    _410.d1 = _421;
    if (_421 > 0) 
    goto _jump1641;
    fail_assertion("non-positive loop bound");
    _jump1641:;
    // Computing bound for y
    _410.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump1642;
    fail_assertion("non-positive loop bound");
    _jump1642:;
    // Computing total size of heap memory to allocate
    int64_t _422 = 1;
    _422 *= _411;
    _422 *= _421;
    _422 *= o.d1;
    _422 *= sizeof(_a3_void_t);
    _410.data = jpl_alloc(_422);
    int64_t _423 = 0; // y
    int64_t _424 = 0; // x
    int64_t _425 = 0; // w
    _jump1643:; // Begin body of loop
    _a3_void_t _426;
    // Computing bound for z
    _426.d0 = _424;
    if (_424 > 0) 
    goto _jump1644;
    fail_assertion("non-positive loop bound");
    _jump1644:;
    // Computing bound for A
    _426.d1 = j;
    if (j > 0) 
    goto _jump1645;
    fail_assertion("non-positive loop bound");
    _jump1645:;
    // Computing bound for B
    int64_t _427;
    if (!_0)
    goto _jump1646;
    _427 = o.d1;
    goto _jump1647;
    _jump1646:;
    _427 = c;
    _jump1647:;
    _426.d2 = _427;
    if (_427 > 0) 
    goto _jump1648;
    fail_assertion("non-positive loop bound");
    _jump1648:;
    // Computing total size of heap memory to allocate
    int64_t _428 = 1;
    _428 *= _424;
    _428 *= j;
    _428 *= _427;
    _428 *= sizeof(void_t);
    _426.data = jpl_alloc(_428);
    int64_t _429 = 0; // B
    int64_t _430 = 0; // A
    int64_t _431 = 0; // z
    _jump1649:; // Begin body of loop
    a _432 = h();
    void_t _433 = _432.a;
    int64_t _434 = 0;
    _434 *= _426.d0;
    _434 += _431;
    _434 *= _426.d1;
    _434 += _430;
    _434 *= _426.d2;
    _434 += _429;
    _426.data[_434] = _433;
    _429++;
    if (_429 < _427)
    goto _jump1649;
    _429 = 0;
    _430++;
    if (_430 < j)
    goto _jump1649;
    _430 = 0;
    _431++;
    if (_431 < _424)
    goto _jump1649;
    // End body of loop
    int64_t _435 = 0;
    _435 *= _410.d0;
    _435 += _425;
    _435 *= _410.d1;
    _435 += _424;
    _435 *= _410.d2;
    _435 += _423;
    _410.data[_435] = _426;
    _423++;
    if (_423 < o.d1)
    goto _jump1643;
    _423 = 0;
    _424++;
    if (_424 < _421)
    goto _jump1643;
    _424 = 0;
    _425++;
    if (_425 < _411)
    goto _jump1643;
    // End body of loop
    if (b.d1 >= 0)
    goto _jump1650;
    fail_assertion("negative array index");
    _jump1650:;
    if (b.d1 < _410.d0)
    goto _jump1651;
    fail_assertion("index too large");
    _jump1651:;
    if (o.d1 >= 0)
    goto _jump1652;
    fail_assertion("negative array index");
    _jump1652:;
    if (o.d1 < _410.d1)
    goto _jump1653;
    fail_assertion("index too large");
    _jump1653:;
    if (d >= 0)
    goto _jump1654;
    fail_assertion("negative array index");
    _jump1654:;
    if (d < _410.d2)
    goto _jump1655;
    fail_assertion("index too large");
    _jump1655:;
    int64_t _436 = 0;
    _436 *= _410.d0;
    _436 += b.d1;
    _436 *= _410.d1;
    _436 += o.d1;
    _436 *= _410.d2;
    _436 += d;
    _a3_void_t _437 = _410.data[_436];
    _375 = _437;
    _jump1627:;
    int64_t _438;
    // Computing bound for w
    int64_t _439;
    // Computing bound for w
    int64_t _440 = 788;
    int64_t _441 = o.d1 + _440;
    if (_441 > 0) 
    goto _jump1656;
    fail_assertion("non-positive loop bound");
    _jump1656:;
    // Computing bound for x
    int64_t _442 = 722;
    int64_t _443 = b.d0 % _442;
    if (_443 > 0) 
    goto _jump1657;
    fail_assertion("non-positive loop bound");
    _jump1657:;
    // Computing bound for y
    int64_t _444 = 806;
    if (_444 > 0) 
    goto _jump1658;
    fail_assertion("non-positive loop bound");
    _jump1658:;
    _439 = 0;
    int64_t _445 = 0; // y
    int64_t _446 = 0; // x
    int64_t _447 = 0; // w
    _jump1659:; // Begin body of loop
    _439 += o.d1;
    _445++;
    if (_445 < _444)
    goto _jump1659;
    _445 = 0;
    _446++;
    if (_446 < _443)
    goto _jump1659;
    _446 = 0;
    _447++;
    if (_447 < _441)
    goto _jump1659;
    // End body of loop
    if (_439 > 0) 
    goto _jump1660;
    fail_assertion("non-positive loop bound");
    _jump1660:;
    // Computing bound for x
    if (b.d1 >= 0)
    goto _jump1661;
    fail_assertion("negative array index");
    _jump1661:;
    if (b.d1 < b.d0)
    goto _jump1662;
    fail_assertion("index too large");
    _jump1662:;
    if (b.d1 >= 0)
    goto _jump1663;
    fail_assertion("negative array index");
    _jump1663:;
    if (b.d1 < b.d1)
    goto _jump1664;
    fail_assertion("index too large");
    _jump1664:;
    int64_t _448 = 0;
    _448 *= b.d0;
    _448 += b.d1;
    _448 *= b.d1;
    _448 += b.d1;
    int64_t _449 = b.data[_448];
    if (_449 > 0) 
    goto _jump1665;
    fail_assertion("non-positive loop bound");
    _jump1665:;
    // Computing bound for y
    int64_t _450;
    // Computing bound for w
    if (c > 0) 
    goto _jump1666;
    fail_assertion("non-positive loop bound");
    _jump1666:;
    _450 = 0;
    int64_t _451 = 0; // w
    _jump1667:; // Begin body of loop
    _450 += o.d1;
    _451++;
    if (_451 < c)
    goto _jump1667;
    // End body of loop
    if (_450 > 0) 
    goto _jump1668;
    fail_assertion("non-positive loop bound");
    _jump1668:;
    _438 = 0;
    int64_t _452 = 0; // y
    int64_t _453 = 0; // x
    int64_t _454 = 0; // w
    _jump1669:; // Begin body of loop
    _438 += _454;
    _452++;
    if (_452 < _450)
    goto _jump1669;
    _452 = 0;
    _453++;
    if (_453 < _449)
    goto _jump1669;
    _453 = 0;
    _454++;
    if (_454 < _439)
    goto _jump1669;
    // End body of loop
    int64_t _455 = -d;
    _a3_void_t _456;
    // Computing bound for w
    int64_t _457 = b.d0 - j;
    _456.d0 = _457;
    if (_457 > 0) 
    goto _jump1670;
    fail_assertion("non-positive loop bound");
    _jump1670:;
    // Computing bound for x
    _456.d1 = o.d0;
    if (o.d0 > 0) 
    goto _jump1671;
    fail_assertion("non-positive loop bound");
    _jump1671:;
    // Computing bound for y
    _a1_int64_t _458;
    // Computing bound for w
    int64_t _459 = c + c;
    _458.d0 = _459;
    if (_459 > 0) 
    goto _jump1672;
    fail_assertion("non-positive loop bound");
    _jump1672:;
    // Computing total size of heap memory to allocate
    int64_t _460 = 1;
    _460 *= _459;
    _460 *= sizeof(int64_t);
    _458.data = jpl_alloc(_460);
    int64_t _461 = 0; // w
    _jump1673:; // Begin body of loop
    int64_t _462 = 0;
    _462 *= _458.d0;
    _462 += _461;
    _458.data[_462] = o.d1;
    _461++;
    if (_461 < _459)
    goto _jump1673;
    // End body of loop
    if (o.d1 >= 0)
    goto _jump1674;
    fail_assertion("negative array index");
    _jump1674:;
    if (o.d1 < _458.d0)
    goto _jump1675;
    fail_assertion("index too large");
    _jump1675:;
    int64_t _463 = 0;
    _463 *= _458.d0;
    _463 += o.d1;
    int64_t _464 = _458.data[_463];
    _456.d2 = _464;
    if (_464 > 0) 
    goto _jump1676;
    fail_assertion("non-positive loop bound");
    _jump1676:;
    // Computing total size of heap memory to allocate
    int64_t _465 = 1;
    _465 *= _457;
    _465 *= o.d0;
    _465 *= _464;
    _465 *= sizeof(void_t);
    _456.data = jpl_alloc(_465);
    int64_t _466 = 0; // y
    int64_t _467 = 0; // x
    int64_t _468 = 0; // w
    _jump1677:; // Begin body of loop
    a _469 = h();
    void_t _470 = _469.a;
    int64_t _471 = 0;
    _471 *= _456.d0;
    _471 += _468;
    _471 *= _456.d1;
    _471 += _467;
    _471 *= _456.d2;
    _471 += _466;
    _456.data[_471] = _470;
    _466++;
    if (_466 < _464)
    goto _jump1677;
    _466 = 0;
    _467++;
    if (_467 < o.d0)
    goto _jump1677;
    _467 = 0;
    _468++;
    if (_468 < _457)
    goto _jump1677;
    // End body of loop
    double _472 = 37.0;
    double _473 = 33.0;
    double _474 = 33.0;
    double _475 = _473 / _474;
    bool _476 = _472 <= _475;
    _a3_bool _477;
    if (!_476)
    goto _jump1678;
    _a3_bool _478;
    // Computing bound for w
    _478.d0 = b.d0;
    if (b.d0 > 0) 
    goto _jump1679;
    fail_assertion("non-positive loop bound");
    _jump1679:;
    // Computing bound for x
    _478.d1 = b.d1;
    if (b.d1 > 0) 
    goto _jump1680;
    fail_assertion("non-positive loop bound");
    _jump1680:;
    // Computing bound for y
    _478.d2 = o.d0;
    if (o.d0 > 0) 
    goto _jump1681;
    fail_assertion("non-positive loop bound");
    _jump1681:;
    // Computing total size of heap memory to allocate
    int64_t _479 = 1;
    _479 *= b.d0;
    _479 *= b.d1;
    _479 *= o.d0;
    _479 *= sizeof(bool);
    _478.data = jpl_alloc(_479);
    int64_t _480 = 0; // y
    int64_t _481 = 0; // x
    int64_t _482 = 0; // w
    _jump1682:; // Begin body of loop
    int64_t _483 = 0;
    _483 *= _478.d0;
    _483 += _482;
    _483 *= _478.d1;
    _483 += _481;
    _483 *= _478.d2;
    _483 += _480;
    _478.data[_483] = _0;
    _480++;
    if (_480 < o.d0)
    goto _jump1682;
    _480 = 0;
    _481++;
    if (_481 < b.d1)
    goto _jump1682;
    _481 = 0;
    _482++;
    if (_482 < b.d0)
    goto _jump1682;
    // End body of loop
    _477 = _478;
    goto _jump1683;
    _jump1678:;
    _a3_bool _484;
    // Computing bound for w
    _484.d0 = b.d1;
    if (b.d1 > 0) 
    goto _jump1684;
    fail_assertion("non-positive loop bound");
    _jump1684:;
    // Computing bound for x
    _484.d1 = o.d0;
    if (o.d0 > 0) 
    goto _jump1685;
    fail_assertion("non-positive loop bound");
    _jump1685:;
    // Computing bound for y
    _484.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump1686;
    fail_assertion("non-positive loop bound");
    _jump1686:;
    // Computing total size of heap memory to allocate
    int64_t _485 = 1;
    _485 *= b.d1;
    _485 *= o.d0;
    _485 *= o.d1;
    _485 *= sizeof(bool);
    _484.data = jpl_alloc(_485);
    int64_t _486 = 0; // y
    int64_t _487 = 0; // x
    int64_t _488 = 0; // w
    _jump1687:; // Begin body of loop
    bool _489 = !k;
    int64_t _490 = 0;
    _490 *= _484.d0;
    _490 += _488;
    _490 *= _484.d1;
    _490 += _487;
    _490 *= _484.d2;
    _490 += _486;
    _484.data[_490] = _489;
    _486++;
    if (_486 < o.d1)
    goto _jump1687;
    _486 = 0;
    _487++;
    if (_487 < o.d0)
    goto _jump1687;
    _487 = 0;
    _488++;
    if (_488 < b.d1)
    goto _jump1687;
    // End body of loop
    _477 = _484;
    _jump1683:;
    _a3_void_t _491;
    // Computing bound for w
    _491.d0 = b.d1;
    if (b.d1 > 0) 
    goto _jump1688;
    fail_assertion("non-positive loop bound");
    _jump1688:;
    // Computing bound for x
    _491.d1 = b.d0;
    if (b.d0 > 0) 
    goto _jump1689;
    fail_assertion("non-positive loop bound");
    _jump1689:;
    // Computing bound for y
    _491.d2 = o.d1;
    if (o.d1 > 0) 
    goto _jump1690;
    fail_assertion("non-positive loop bound");
    _jump1690:;
    // Computing total size of heap memory to allocate
    int64_t _492 = 1;
    _492 *= b.d1;
    _492 *= b.d0;
    _492 *= o.d1;
    _492 *= sizeof(void_t);
    _491.data = jpl_alloc(_492);
    int64_t _493 = 0; // y
    int64_t _494 = 0; // x
    int64_t _495 = 0; // w
    _jump1691:; // Begin body of loop
    a _496 = h();
    void_t _497 = _496.a;
    int64_t _498 = 0;
    _498 *= _491.d0;
    _498 += _495;
    _498 *= _491.d1;
    _498 += _494;
    _498 *= _491.d2;
    _498 += _493;
    _491.data[_498] = _497;
    _493++;
    if (_493 < o.d1)
    goto _jump1691;
    _493 = 0;
    _494++;
    if (_494 < b.d0)
    goto _jump1691;
    _494 = 0;
    _495++;
    if (_495 < b.d1)
    goto _jump1691;
    // End body of loop
    bool _499 = d == b.d0;
    int64_t _500 = l(b.d1, _491, _499);
    bool _502;
    if (!k)
    goto _jump1692;
    bool _503 = true;
    _502 = _503;
    goto _jump1693;
    _jump1692:;
    _502 = k;
    _jump1693:;
    bool _501 = _502;
    if (0 != _502)
    goto _jump1694;
    bool _504 = _0;
    if (0 != _0)
    goto _jump1695;
    _504 = _0;
    _jump1695:;
    _501 = _504;
    _jump1694:;
    int64_t _505;
    if (!_501)
    goto _jump1696;
    int64_t _506;
    if (!_0)
    goto _jump1697;
    _506 = j;
    goto _jump1698;
    _jump1697:;
    _506 = b.d1;
    _jump1698:;
    _505 = _506;
    goto _jump1699;
    _jump1696:;
    _505 = o.d1;
    _jump1699:;
    if (_500 >= 0)
    goto _jump1700;
    fail_assertion("negative array index");
    _jump1700:;
    if (_500 < _477.d0)
    goto _jump1701;
    fail_assertion("index too large");
    _jump1701:;
    if (_505 >= 0)
    goto _jump1702;
    fail_assertion("negative array index");
    _jump1702:;
    if (_505 < _477.d1)
    goto _jump1703;
    fail_assertion("index too large");
    _jump1703:;
    if (b.d1 >= 0)
    goto _jump1704;
    fail_assertion("negative array index");
    _jump1704:;
    if (b.d1 < _477.d2)
    goto _jump1705;
    fail_assertion("index too large");
    _jump1705:;
    int64_t _507 = 0;
    _507 *= _477.d0;
    _507 += _500;
    _507 *= _477.d1;
    _507 += _505;
    _507 *= _477.d2;
    _507 += b.d1;
    bool _508 = _477.data[_507];
    int64_t _509 = l(_455, _456, _508);
    if (_438 >= 0)
    goto _jump1706;
    fail_assertion("negative array index");
    _jump1706:;
    if (_438 < _375.d0)
    goto _jump1707;
    fail_assertion("index too large");
    _jump1707:;
    if (_509 >= 0)
    goto _jump1708;
    fail_assertion("negative array index");
    _jump1708:;
    if (_509 < _375.d1)
    goto _jump1709;
    fail_assertion("index too large");
    _jump1709:;
    if (b.d0 >= 0)
    goto _jump1710;
    fail_assertion("negative array index");
    _jump1710:;
    if (b.d0 < _375.d2)
    goto _jump1711;
    fail_assertion("index too large");
    _jump1711:;
    int64_t _510 = 0;
    _510 *= _375.d0;
    _510 += _438;
    _510 *= _375.d1;
    _510 += _509;
    _510 *= _375.d2;
    _510 += b.d0;
    void_t _511 = _375.data[_510];
    double _512 = g(_0);
    a _513 = { _511, _512 };
    return _513;
}

int64_t n() {
    _a1_rgba _0;
    // Computing bound for o
    int64_t _1;
    // Computing bound for o
    int64_t _2 = 593;
    if (_2 > 0) 
    goto _jump1712;
    fail_assertion("non-positive loop bound");
    _jump1712:;
    _1 = 0;
    int64_t _3 = 0; // o
    _jump1713:; // Begin body of loop
    _a3_int64_t _4;
    // Computing bound for p
    int64_t _5 = -d;
    _4.d0 = _5;
    if (_5 > 0) 
    goto _jump1714;
    fail_assertion("non-positive loop bound");
    _jump1714:;
    // Computing bound for q
    _4.d1 = c;
    if (c > 0) 
    goto _jump1715;
    fail_assertion("non-positive loop bound");
    _jump1715:;
    // Computing bound for r
    _4.d2 = j;
    if (j > 0) 
    goto _jump1716;
    fail_assertion("non-positive loop bound");
    _jump1716:;
    // Computing total size of heap memory to allocate
    int64_t _6 = 1;
    _6 *= _5;
    _6 *= c;
    _6 *= j;
    _6 *= sizeof(int64_t);
    _4.data = jpl_alloc(_6);
    int64_t _7 = 0; // r
    int64_t _8 = 0; // q
    int64_t _9 = 0; // p
    _jump1717:; // Begin body of loop
    int64_t _10 = 0;
    _10 *= _4.d0;
    _10 += _9;
    _10 *= _4.d1;
    _10 += _8;
    _10 *= _4.d2;
    _10 += _7;
    _4.data[_10] = _9;
    _7++;
    if (_7 < j)
    goto _jump1717;
    _7 = 0;
    _8++;
    if (_8 < c)
    goto _jump1717;
    _8 = 0;
    _9++;
    if (_9 < _5)
    goto _jump1717;
    // End body of loop
    int64_t _11 = -_3;
    int64_t _12 = n();
    if (j >= 0)
    goto _jump1718;
    fail_assertion("negative array index");
    _jump1718:;
    if (j < _4.d0)
    goto _jump1719;
    fail_assertion("index too large");
    _jump1719:;
    if (_11 >= 0)
    goto _jump1720;
    fail_assertion("negative array index");
    _jump1720:;
    if (_11 < _4.d1)
    goto _jump1721;
    fail_assertion("index too large");
    _jump1721:;
    if (_12 >= 0)
    goto _jump1722;
    fail_assertion("negative array index");
    _jump1722:;
    if (_12 < _4.d2)
    goto _jump1723;
    fail_assertion("index too large");
    _jump1723:;
    int64_t _13 = 0;
    _13 *= _4.d0;
    _13 += j;
    _13 *= _4.d1;
    _13 += _11;
    _13 *= _4.d2;
    _13 += _12;
    int64_t _14 = _4.data[_13];
    _1 += _14;
    _3++;
    if (_3 < _2)
    goto _jump1713;
    // End body of loop
    _0.d0 = _1;
    if (_1 > 0) 
    goto _jump1724;
    fail_assertion("non-positive loop bound");
    _jump1724:;
    // Computing total size of heap memory to allocate
    int64_t _15 = 1;
    _15 *= _1;
    _15 *= sizeof(rgba);
    _0.data = jpl_alloc(_15);
    int64_t _16 = 0; // o
    _jump1725:; // Begin body of loop
    _a3_rgba _17;
    // Computing bound for p
    int64_t _18 = 571;
    _17.d0 = _18;
    if (_18 > 0) 
    goto _jump1726;
    fail_assertion("non-positive loop bound");
    _jump1726:;
    // Computing bound for q
    _17.d1 = j;
    if (j > 0) 
    goto _jump1727;
    fail_assertion("non-positive loop bound");
    _jump1727:;
    // Computing bound for r
    int64_t _19 = 445;
    _17.d2 = _19;
    if (_19 > 0) 
    goto _jump1728;
    fail_assertion("non-positive loop bound");
    _jump1728:;
    // Computing total size of heap memory to allocate
    int64_t _20 = 1;
    _20 *= _18;
    _20 *= j;
    _20 *= _19;
    _20 *= sizeof(rgba);
    _17.data = jpl_alloc(_20);
    int64_t _21 = 0; // r
    int64_t _22 = 0; // q
    int64_t _23 = 0; // p
    _jump1729:; // Begin body of loop
    int64_t _24 = n();
    if (_24 >= 0)
    goto _jump1730;
    fail_assertion("negative array index");
    _jump1730:;
    if (_24 < e.d0)
    goto _jump1731;
    fail_assertion("index too large");
    _jump1731:;
    if (_22 >= 0)
    goto _jump1732;
    fail_assertion("negative array index");
    _jump1732:;
    if (_22 < e.d1)
    goto _jump1733;
    fail_assertion("index too large");
    _jump1733:;
    int64_t _25 = 0;
    _25 *= e.d0;
    _25 += _24;
    _25 *= e.d1;
    _25 += _22;
    rgba _26 = e.data[_25];
    int64_t _27 = 0;
    _27 *= _17.d0;
    _27 += _23;
    _27 *= _17.d1;
    _27 += _22;
    _27 *= _17.d2;
    _27 += _21;
    _17.data[_27] = _26;
    _21++;
    if (_21 < _19)
    goto _jump1729;
    _21 = 0;
    _22++;
    if (_22 < j)
    goto _jump1729;
    _22 = 0;
    _23++;
    if (_23 < _18)
    goto _jump1729;
    // End body of loop
    if (_16 >= 0)
    goto _jump1734;
    fail_assertion("negative array index");
    _jump1734:;
    if (_16 < _17.d0)
    goto _jump1735;
    fail_assertion("index too large");
    _jump1735:;
    if (d >= 0)
    goto _jump1736;
    fail_assertion("negative array index");
    _jump1736:;
    if (d < _17.d1)
    goto _jump1737;
    fail_assertion("index too large");
    _jump1737:;
    if (c >= 0)
    goto _jump1738;
    fail_assertion("negative array index");
    _jump1738:;
    if (c < _17.d2)
    goto _jump1739;
    fail_assertion("index too large");
    _jump1739:;
    int64_t _28 = 0;
    _28 *= _17.d0;
    _28 += _16;
    _28 *= _17.d1;
    _28 += d;
    _28 *= _17.d2;
    _28 += c;
    rgba _29 = _17.data[_28];
    int64_t _30 = 0;
    _30 *= _0.d0;
    _30 += _16;
    _0.data[_30] = _29;
    _16++;
    if (_16 < _1)
    goto _jump1725;
    // End body of loop
    int64_t _31 = n();
    _a3_void_t _32;
    // Computing bound for o
    _a3_int64_t _33;
    // Computing bound for o
    int64_t _34 = 856;
    _33.d0 = _34;
    if (_34 > 0) 
    goto _jump1740;
    fail_assertion("non-positive loop bound");
    _jump1740:;
    // Computing bound for p
    int64_t _35 = 465;
    _33.d1 = _35;
    if (_35 > 0) 
    goto _jump1741;
    fail_assertion("non-positive loop bound");
    _jump1741:;
    // Computing bound for q
    int64_t _36 = n();
    _33.d2 = _36;
    if (_36 > 0) 
    goto _jump1742;
    fail_assertion("non-positive loop bound");
    _jump1742:;
    // Computing total size of heap memory to allocate
    int64_t _37 = 1;
    _37 *= _34;
    _37 *= _35;
    _37 *= _36;
    _37 *= sizeof(int64_t);
    _33.data = jpl_alloc(_37);
    int64_t _38 = 0; // q
    int64_t _39 = 0; // p
    int64_t _40 = 0; // o
    _jump1743:; // Begin body of loop
    int64_t _41 = 0;
    _41 *= _33.d0;
    _41 += _40;
    _41 *= _33.d1;
    _41 += _39;
    _41 *= _33.d2;
    _41 += _38;
    _33.data[_41] = c;
    _38++;
    if (_38 < _36)
    goto _jump1743;
    _38 = 0;
    _39++;
    if (_39 < _35)
    goto _jump1743;
    _39 = 0;
    _40++;
    if (_40 < _34)
    goto _jump1743;
    // End body of loop
    bool _42 = true;
    int64_t _43;
    if (!_42)
    goto _jump1744;
    _43 = c;
    goto _jump1745;
    _jump1744:;
    _43 = d;
    _jump1745:;
    int64_t _44 = -d;
    if (j >= 0)
    goto _jump1746;
    fail_assertion("negative array index");
    _jump1746:;
    if (j < _33.d0)
    goto _jump1747;
    fail_assertion("index too large");
    _jump1747:;
    if (_43 >= 0)
    goto _jump1748;
    fail_assertion("negative array index");
    _jump1748:;
    if (_43 < _33.d1)
    goto _jump1749;
    fail_assertion("index too large");
    _jump1749:;
    if (_44 >= 0)
    goto _jump1750;
    fail_assertion("negative array index");
    _jump1750:;
    if (_44 < _33.d2)
    goto _jump1751;
    fail_assertion("index too large");
    _jump1751:;
    int64_t _45 = 0;
    _45 *= _33.d0;
    _45 += j;
    _45 *= _33.d1;
    _45 += _43;
    _45 *= _33.d2;
    _45 += _44;
    int64_t _46 = _33.data[_45];
    _32.d0 = _46;
    if (_46 > 0) 
    goto _jump1752;
    fail_assertion("non-positive loop bound");
    _jump1752:;
    // Computing bound for p
    _32.d1 = j;
    if (j > 0) 
    goto _jump1753;
    fail_assertion("non-positive loop bound");
    _jump1753:;
    // Computing bound for q
    bool _47 = false;
    int64_t _48;
    if (!_47)
    goto _jump1754;
    _48 = c;
    goto _jump1755;
    _jump1754:;
    int64_t _49;
    // Computing bound for o
    int64_t _50 = 611;
    if (_50 > 0) 
    goto _jump1756;
    fail_assertion("non-positive loop bound");
    _jump1756:;
    _49 = 0;
    int64_t _51 = 0; // o
    _jump1757:; // Begin body of loop
    _49 += d;
    _51++;
    if (_51 < _50)
    goto _jump1757;
    // End body of loop
    _48 = _49;
    _jump1755:;
    _32.d2 = _48;
    if (_48 > 0) 
    goto _jump1758;
    fail_assertion("non-positive loop bound");
    _jump1758:;
    // Computing total size of heap memory to allocate
    int64_t _52 = 1;
    _52 *= _46;
    _52 *= j;
    _52 *= _48;
    _52 *= sizeof(void_t);
    _32.data = jpl_alloc(_52);
    int64_t _53 = 0; // q
    int64_t _54 = 0; // p
    int64_t _55 = 0; // o
    _jump1759:; // Begin body of loop
    a _56 = h();
    void_t _57 = _56.a;
    int64_t _58 = 0;
    _58 *= _32.d0;
    _58 += _55;
    _58 *= _32.d1;
    _58 += _54;
    _58 *= _32.d2;
    _58 += _53;
    _32.data[_58] = _57;
    _53++;
    if (_53 < _48)
    goto _jump1759;
    _53 = 0;
    _54++;
    if (_54 < j)
    goto _jump1759;
    _54 = 0;
    _55++;
    if (_55 < _46)
    goto _jump1759;
    // End body of loop
    bool _60 = !k;
    bool _61 = !_60;
    bool _59 = _61;
    if (0 == _61)
    goto _jump1760;
    bool _62 = true;
    _59 = _62;
    _jump1760:;
    int64_t _63 = l(_31, _32, _59);
    int64_t _64 = n();
    int64_t _65 = _63 - _64;
    if (_65 >= 0)
    goto _jump1761;
    fail_assertion("negative array index");
    _jump1761:;
    if (_65 < _0.d0)
    goto _jump1762;
    fail_assertion("index too large");
    _jump1762:;
    int64_t _66 = 0;
    _66 *= _0.d0;
    _66 += _65;
    rgba _67 = _0.data[_66];
    double _68 = _67.g;
    _a1_int64_t _69;
    if (!k)
    goto _jump1763;
    _a1_int64_t _70;
    // Computing bound for p
    int64_t _71 = 863;
    _70.d0 = _71;
    if (_71 > 0) 
    goto _jump1764;
    fail_assertion("non-positive loop bound");
    _jump1764:;
    // Computing total size of heap memory to allocate
    int64_t _72 = 1;
    _72 *= _71;
    _72 *= sizeof(int64_t);
    _70.data = jpl_alloc(_72);
    int64_t _73 = 0; // p
    _jump1765:; // Begin body of loop
    int64_t _74 = 0;
    _74 *= _70.d0;
    _74 += _73;
    _70.data[_74] = _73;
    _73++;
    if (_73 < _71)
    goto _jump1765;
    // End body of loop
    _69 = _70;
    goto _jump1766;
    _jump1763:;
    _a3__a3__a1_int64_t _75;
    // Computing bound for p
    int64_t _76 = n();
    _75.d0 = _76;
    if (_76 > 0) 
    goto _jump1767;
    fail_assertion("non-positive loop bound");
    _jump1767:;
    // Computing bound for q
    _75.d1 = j;
    if (j > 0) 
    goto _jump1768;
    fail_assertion("non-positive loop bound");
    _jump1768:;
    // Computing bound for r
    int64_t _77 = n();
    _75.d2 = _77;
    if (_77 > 0) 
    goto _jump1769;
    fail_assertion("non-positive loop bound");
    _jump1769:;
    // Computing total size of heap memory to allocate
    int64_t _78 = 1;
    _78 *= _76;
    _78 *= j;
    _78 *= _77;
    _78 *= sizeof(_a3__a1_int64_t);
    _75.data = jpl_alloc(_78);
    int64_t _79 = 0; // r
    int64_t _80 = 0; // q
    int64_t _81 = 0; // p
    _jump1770:; // Begin body of loop
    _a3__a1_int64_t _82;
    // Computing bound for s
    int64_t _83;
    // Computing bound for s
    if (_81 > 0) 
    goto _jump1771;
    fail_assertion("non-positive loop bound");
    _jump1771:;
    _83 = 0;
    int64_t _84 = 0; // s
    _jump1772:; // Begin body of loop
    int64_t _85 = n();
    _83 += _85;
    _84++;
    if (_84 < _81)
    goto _jump1772;
    // End body of loop
    _82.d0 = _83;
    if (_83 > 0) 
    goto _jump1773;
    fail_assertion("non-positive loop bound");
    _jump1773:;
    // Computing bound for t
    int64_t _86;
    // Computing bound for s
    int64_t _87 = 248;
    if (_87 > 0) 
    goto _jump1774;
    fail_assertion("non-positive loop bound");
    _jump1774:;
    _86 = 0;
    int64_t _88 = 0; // s
    _jump1775:; // Begin body of loop
    int64_t _89 = n();
    _86 += _89;
    _88++;
    if (_88 < _87)
    goto _jump1775;
    // End body of loop
    _82.d1 = _86;
    if (_86 > 0) 
    goto _jump1776;
    fail_assertion("non-positive loop bound");
    _jump1776:;
    // Computing bound for u
    int64_t _90;
    // Computing bound for s
    if (_81 > 0) 
    goto _jump1777;
    fail_assertion("non-positive loop bound");
    _jump1777:;
    _90 = 0;
    int64_t _91 = 0; // s
    _jump1778:; // Begin body of loop
    _90 += _80;
    _91++;
    if (_91 < _81)
    goto _jump1778;
    // End body of loop
    _82.d2 = _90;
    if (_90 > 0) 
    goto _jump1779;
    fail_assertion("non-positive loop bound");
    _jump1779:;
    // Computing total size of heap memory to allocate
    int64_t _92 = 1;
    _92 *= _83;
    _92 *= _86;
    _92 *= _90;
    _92 *= sizeof(_a1_int64_t);
    _82.data = jpl_alloc(_92);
    int64_t _93 = 0; // u
    int64_t _94 = 0; // t
    int64_t _95 = 0; // s
    _jump1780:; // Begin body of loop
    _a1_int64_t _96;
    if (!k)
    goto _jump1781;
    int64_t _97 = n();
    _a1_int64_t _98;
    _98.d0 = 2;
    _98.data = jpl_alloc(sizeof(int64_t) * 2);
    _98.data[0] = _97;
    _98.data[1] = j;
    _96 = _98;
    goto _jump1782;
    _jump1781:;
    _a1_int64_t _99;
    // Computing bound for v
    int64_t _100 = 520;
    _99.d0 = _100;
    if (_100 > 0) 
    goto _jump1783;
    fail_assertion("non-positive loop bound");
    _jump1783:;
    // Computing total size of heap memory to allocate
    int64_t _101 = 1;
    _101 *= _100;
    _101 *= sizeof(int64_t);
    _99.data = jpl_alloc(_101);
    int64_t _102 = 0; // v
    _jump1784:; // Begin body of loop
    int64_t _103 = 0;
    _103 *= _99.d0;
    _103 += _102;
    _99.data[_103] = _79;
    _102++;
    if (_102 < _100)
    goto _jump1784;
    // End body of loop
    _96 = _99;
    _jump1782:;
    int64_t _104 = 0;
    _104 *= _82.d0;
    _104 += _95;
    _104 *= _82.d1;
    _104 += _94;
    _104 *= _82.d2;
    _104 += _93;
    _82.data[_104] = _96;
    _93++;
    if (_93 < _90)
    goto _jump1780;
    _93 = 0;
    _94++;
    if (_94 < _86)
    goto _jump1780;
    _94 = 0;
    _95++;
    if (_95 < _83)
    goto _jump1780;
    // End body of loop
    int64_t _105 = 0;
    _105 *= _75.d0;
    _105 += _81;
    _105 *= _75.d1;
    _105 += _80;
    _105 *= _75.d2;
    _105 += _79;
    _75.data[_105] = _82;
    _79++;
    if (_79 < _77)
    goto _jump1770;
    _79 = 0;
    _80++;
    if (_80 < j)
    goto _jump1770;
    _80 = 0;
    _81++;
    if (_81 < _76)
    goto _jump1770;
    // End body of loop
    int64_t _106;
    // Computing bound for p
    if (d > 0) 
    goto _jump1785;
    fail_assertion("non-positive loop bound");
    _jump1785:;
    // Computing bound for q
    if (c > 0) 
    goto _jump1786;
    fail_assertion("non-positive loop bound");
    _jump1786:;
    // Computing bound for r
    int64_t _107 = n();
    int64_t _108 = j / _107;
    if (_108 > 0) 
    goto _jump1787;
    fail_assertion("non-positive loop bound");
    _jump1787:;
    _106 = 0;
    int64_t _109 = 0; // r
    int64_t _110 = 0; // q
    int64_t _111 = 0; // p
    _jump1788:; // Begin body of loop
    _106 += c;
    _109++;
    if (_109 < _108)
    goto _jump1788;
    _109 = 0;
    _110++;
    if (_110 < c)
    goto _jump1788;
    _110 = 0;
    _111++;
    if (_111 < d)
    goto _jump1788;
    // End body of loop
    _a3_void_t _112;
    // Computing bound for p
    int64_t _113 = 467;
    _112.d0 = _113;
    if (_113 > 0) 
    goto _jump1789;
    fail_assertion("non-positive loop bound");
    _jump1789:;
    // Computing bound for q
    int64_t _114 = -j;
    int64_t _115 = 45;
    int64_t _116 = _114 / _115;
    _112.d1 = _116;
    if (_116 > 0) 
    goto _jump1790;
    fail_assertion("non-positive loop bound");
    _jump1790:;
    // Computing bound for r
    _112.d2 = j;
    if (j > 0) 
    goto _jump1791;
    fail_assertion("non-positive loop bound");
    _jump1791:;
    // Computing total size of heap memory to allocate
    int64_t _117 = 1;
    _117 *= _113;
    _117 *= _116;
    _117 *= j;
    _117 *= sizeof(void_t);
    _112.data = jpl_alloc(_117);
    int64_t _118 = 0; // r
    int64_t _119 = 0; // q
    int64_t _120 = 0; // p
    _jump1792:; // Begin body of loop
    a _121 = h();
    void_t _122 = _121.a;
    int64_t _123 = 0;
    _123 *= _112.d0;
    _123 += _120;
    _123 *= _112.d1;
    _123 += _119;
    _123 *= _112.d2;
    _123 += _118;
    _112.data[_123] = _122;
    _118++;
    if (_118 < j)
    goto _jump1792;
    _118 = 0;
    _119++;
    if (_119 < _116)
    goto _jump1792;
    _119 = 0;
    _120++;
    if (_120 < _113)
    goto _jump1792;
    // End body of loop
    bool _124 = false;
    bool _125;
    if (!_124)
    goto _jump1793;
    bool _126 = k;
    if (0 != k)
    goto _jump1794;
    bool _127 = false;
    _126 = _127;
    _jump1794:;
    _125 = _126;
    goto _jump1795;
    _jump1793:;
    _125 = k;
    _jump1795:;
    int64_t _128 = l(_106, _112, _125);
    bool _129 = d > d;
    int64_t _130;
    if (!_129)
    goto _jump1796;
    int64_t _131 = -j;
    _130 = _131;
    goto _jump1797;
    _jump1796:;
    bool _132 = true;
    int64_t _133;
    if (!_132)
    goto _jump1798;
    _133 = j;
    goto _jump1799;
    _jump1798:;
    _133 = c;
    _jump1799:;
    int64_t _134 = n();
    if (_133 >= 0)
    goto _jump1800;
    fail_assertion("negative array index");
    _jump1800:;
    if (_133 < b.d0)
    goto _jump1801;
    fail_assertion("index too large");
    _jump1801:;
    if (_134 >= 0)
    goto _jump1802;
    fail_assertion("negative array index");
    _jump1802:;
    if (_134 < b.d1)
    goto _jump1803;
    fail_assertion("index too large");
    _jump1803:;
    int64_t _135 = 0;
    _135 *= b.d0;
    _135 += _133;
    _135 *= b.d1;
    _135 += _134;
    int64_t _136 = b.data[_135];
    _130 = _136;
    _jump1797:;
    int64_t _137 = -_130;
    if (_128 >= 0)
    goto _jump1804;
    fail_assertion("negative array index");
    _jump1804:;
    if (_128 < _75.d0)
    goto _jump1805;
    fail_assertion("index too large");
    _jump1805:;
    if (_137 >= 0)
    goto _jump1806;
    fail_assertion("negative array index");
    _jump1806:;
    if (_137 < _75.d1)
    goto _jump1807;
    fail_assertion("index too large");
    _jump1807:;
    if (d >= 0)
    goto _jump1808;
    fail_assertion("negative array index");
    _jump1808:;
    if (d < _75.d2)
    goto _jump1809;
    fail_assertion("index too large");
    _jump1809:;
    int64_t _138 = 0;
    _138 *= _75.d0;
    _138 += _128;
    _138 *= _75.d1;
    _138 += _137;
    _138 *= _75.d2;
    _138 += d;
    _a3__a1_int64_t _139 = _75.data[_138];
    int64_t _140;
    // Computing bound for p
    int64_t _141 = n();
    if (_141 > 0) 
    goto _jump1810;
    fail_assertion("non-positive loop bound");
    _jump1810:;
    // Computing bound for q
    int64_t _142 = -c;
    if (_142 > 0) 
    goto _jump1811;
    fail_assertion("non-positive loop bound");
    _jump1811:;
    _140 = 0;
    int64_t _143 = 0; // q
    int64_t _144 = 0; // p
    _jump1812:; // Begin body of loop
    int64_t _145;
    // Computing bound for r
    bool _146;
    if (!k)
    goto _jump1813;
    bool _147 = false;
    _146 = _147;
    goto _jump1814;
    _jump1813:;
    _146 = k;
    _jump1814:;
    bool _148;
    if (!_146)
    goto _jump1815;
    bool _149 = !k;
    _148 = _149;
    goto _jump1816;
    _jump1815:;
    int64_t _150 = 450;
    bool _151 = _143 == _150;
    _148 = _151;
    _jump1816:;
    int64_t _152;
    if (!_148)
    goto _jump1817;
    _152 = j;
    goto _jump1818;
    _jump1817:;
    _152 = c;
    _jump1818:;
    if (_152 > 0) 
    goto _jump1819;
    fail_assertion("non-positive loop bound");
    _jump1819:;
    // Computing bound for s
    _a1_int64_t _153;
    // Computing bound for r
    int64_t _154 = 554;
    _153.d0 = _154;
    if (_154 > 0) 
    goto _jump1820;
    fail_assertion("non-positive loop bound");
    _jump1820:;
    // Computing total size of heap memory to allocate
    int64_t _155 = 1;
    _155 *= _154;
    _155 *= sizeof(int64_t);
    _153.data = jpl_alloc(_155);
    int64_t _156 = 0; // r
    _jump1821:; // Begin body of loop
    int64_t _157 = n();
    int64_t _158 = 0;
    _158 *= _153.d0;
    _158 += _156;
    _153.data[_158] = _157;
    _156++;
    if (_156 < _154)
    goto _jump1821;
    // End body of loop
    bool _159 = true;
    int64_t _160;
    if (!_159)
    goto _jump1822;
    int64_t _161 = -_144;
    _160 = _161;
    goto _jump1823;
    _jump1822:;
    int64_t _162 = -_143;
    _160 = _162;
    _jump1823:;
    if (_160 >= 0)
    goto _jump1824;
    fail_assertion("negative array index");
    _jump1824:;
    if (_160 < _153.d0)
    goto _jump1825;
    fail_assertion("index too large");
    _jump1825:;
    int64_t _163 = 0;
    _163 *= _153.d0;
    _163 += _160;
    int64_t _164 = _153.data[_163];
    if (_164 > 0) 
    goto _jump1826;
    fail_assertion("non-positive loop bound");
    _jump1826:;
    // Computing bound for t
    if (_143 > 0) 
    goto _jump1827;
    fail_assertion("non-positive loop bound");
    _jump1827:;
    _145 = 0;
    int64_t _165 = 0; // t
    int64_t _166 = 0; // s
    int64_t _167 = 0; // r
    _jump1828:; // Begin body of loop
    int64_t _168 = 950;
    bool _169 = _166 < _168;
    _a1_int64_t _170;
    if (!_169)
    goto _jump1829;
    _a1_int64_t _171;
    _171.d0 = 2;
    _171.data = jpl_alloc(sizeof(int64_t) * 2);
    _171.data[0] = _144;
    _171.data[1] = d;
    _170 = _171;
    goto _jump1830;
    _jump1829:;
    _a1_int64_t _172;
    // Computing bound for u
    _172.d0 = j;
    if (j > 0) 
    goto _jump1831;
    fail_assertion("non-positive loop bound");
    _jump1831:;
    // Computing total size of heap memory to allocate
    int64_t _173 = 1;
    _173 *= j;
    _173 *= sizeof(int64_t);
    _172.data = jpl_alloc(_173);
    int64_t _174 = 0; // u
    _jump1832:; // Begin body of loop
    int64_t _175 = 493;
    int64_t _176 = 0;
    _176 *= _172.d0;
    _176 += _174;
    _172.data[_176] = _175;
    _174++;
    if (_174 < j)
    goto _jump1832;
    // End body of loop
    _170 = _172;
    _jump1830:;
    int64_t _177 = n();
    int64_t _178 = c % _177;
    if (_178 >= 0)
    goto _jump1833;
    fail_assertion("negative array index");
    _jump1833:;
    if (_178 < _170.d0)
    goto _jump1834;
    fail_assertion("index too large");
    _jump1834:;
    int64_t _179 = 0;
    _179 *= _170.d0;
    _179 += _178;
    int64_t _180 = _170.data[_179];
    _145 += _180;
    _165++;
    if (_165 < _143)
    goto _jump1828;
    _165 = 0;
    _166++;
    if (_166 < _164)
    goto _jump1828;
    _166 = 0;
    _167++;
    if (_167 < _152)
    goto _jump1828;
    // End body of loop
    _140 += _145;
    _143++;
    if (_143 < _142)
    goto _jump1812;
    _143 = 0;
    _144++;
    if (_144 < _141)
    goto _jump1812;
    // End body of loop
    bool _181 = false;
    bool _182 = !_181;
    int64_t _183;
    if (!_182)
    goto _jump1835;
    _183 = c;
    goto _jump1836;
    _jump1835:;
    int64_t _184 = n();
    int64_t _185 = j / _184;
    int64_t _186;
    // Computing bound for p
    if (d > 0) 
    goto _jump1837;
    fail_assertion("non-positive loop bound");
    _jump1837:;
    // Computing bound for q
    if (c > 0) 
    goto _jump1838;
    fail_assertion("non-positive loop bound");
    _jump1838:;
    _186 = 0;
    int64_t _187 = 0; // q
    int64_t _188 = 0; // p
    _jump1839:; // Begin body of loop
    _186 += c;
    _187++;
    if (_187 < c)
    goto _jump1839;
    _187 = 0;
    _188++;
    if (_188 < d)
    goto _jump1839;
    // End body of loop
    int64_t _189 = _185 % _186;
    _a1_int64_t _190;
    _190.d0 = 2;
    _190.data = jpl_alloc(sizeof(int64_t) * 2);
    _190.data[0] = c;
    _190.data[1] = _189;
    int64_t _191;
    // Computing bound for p
    int64_t _192;
    // Computing bound for p
    int64_t _193 = n();
    if (_193 > 0) 
    goto _jump1840;
    fail_assertion("non-positive loop bound");
    _jump1840:;
    // Computing bound for q
    int64_t _194 = n();
    if (_194 > 0) 
    goto _jump1841;
    fail_assertion("non-positive loop bound");
    _jump1841:;
    // Computing bound for r
    int64_t _195 = 218;
    if (_195 > 0) 
    goto _jump1842;
    fail_assertion("non-positive loop bound");
    _jump1842:;
    _192 = 0;
    int64_t _196 = 0; // r
    int64_t _197 = 0; // q
    int64_t _198 = 0; // p
    _jump1843:; // Begin body of loop
    int64_t _199 = 591;
    _192 += _199;
    _196++;
    if (_196 < _195)
    goto _jump1843;
    _196 = 0;
    _197++;
    if (_197 < _194)
    goto _jump1843;
    _197 = 0;
    _198++;
    if (_198 < _193)
    goto _jump1843;
    // End body of loop
    if (_192 > 0) 
    goto _jump1844;
    fail_assertion("non-positive loop bound");
    _jump1844:;
    // Computing bound for q
    if (d > 0) 
    goto _jump1845;
    fail_assertion("non-positive loop bound");
    _jump1845:;
    // Computing bound for r
    int64_t _200 = 690;
    int64_t _201 = _200 / c;
    int64_t _202 = _201 - d;
    if (_202 > 0) 
    goto _jump1846;
    fail_assertion("non-positive loop bound");
    _jump1846:;
    _191 = 0;
    int64_t _203 = 0; // r
    int64_t _204 = 0; // q
    int64_t _205 = 0; // p
    _jump1847:; // Begin body of loop
    _a2_int64_t _206;
    // Computing bound for s
    int64_t _207 = n();
    _206.d0 = _207;
    if (_207 > 0) 
    goto _jump1848;
    fail_assertion("non-positive loop bound");
    _jump1848:;
    // Computing bound for t
    _206.d1 = _203;
    if (_203 > 0) 
    goto _jump1849;
    fail_assertion("non-positive loop bound");
    _jump1849:;
    // Computing total size of heap memory to allocate
    int64_t _208 = 1;
    _208 *= _207;
    _208 *= _203;
    _208 *= sizeof(int64_t);
    _206.data = jpl_alloc(_208);
    int64_t _209 = 0; // t
    int64_t _210 = 0; // s
    _jump1850:; // Begin body of loop
    int64_t _211 = 0;
    _211 *= _206.d0;
    _211 += _210;
    _211 *= _206.d1;
    _211 += _209;
    _206.data[_211] = _209;
    _209++;
    if (_209 < _203)
    goto _jump1850;
    _209 = 0;
    _210++;
    if (_210 < _207)
    goto _jump1850;
    // End body of loop
    int64_t _212 = 105;
    int64_t _213 = 173;
    if (_212 >= 0)
    goto _jump1851;
    fail_assertion("negative array index");
    _jump1851:;
    if (_212 < _206.d0)
    goto _jump1852;
    fail_assertion("index too large");
    _jump1852:;
    if (_213 >= 0)
    goto _jump1853;
    fail_assertion("negative array index");
    _jump1853:;
    if (_213 < _206.d1)
    goto _jump1854;
    fail_assertion("index too large");
    _jump1854:;
    int64_t _214 = 0;
    _214 *= _206.d0;
    _214 += _212;
    _214 *= _206.d1;
    _214 += _213;
    int64_t _215 = _206.data[_214];
    _191 += _215;
    _203++;
    if (_203 < _202)
    goto _jump1847;
    _203 = 0;
    _204++;
    if (_204 < d)
    goto _jump1847;
    _204 = 0;
    _205++;
    if (_205 < _192)
    goto _jump1847;
    // End body of loop
    if (_191 >= 0)
    goto _jump1855;
    fail_assertion("negative array index");
    _jump1855:;
    if (_191 < _190.d0)
    goto _jump1856;
    fail_assertion("index too large");
    _jump1856:;
    int64_t _216 = 0;
    _216 *= _190.d0;
    _216 += _191;
    int64_t _217 = _190.data[_216];
    _183 = _217;
    _jump1836:;
    if (_140 >= 0)
    goto _jump1857;
    fail_assertion("negative array index");
    _jump1857:;
    if (_140 < _139.d0)
    goto _jump1858;
    fail_assertion("index too large");
    _jump1858:;
    if (_183 >= 0)
    goto _jump1859;
    fail_assertion("negative array index");
    _jump1859:;
    if (_183 < _139.d1)
    goto _jump1860;
    fail_assertion("index too large");
    _jump1860:;
    if (c >= 0)
    goto _jump1861;
    fail_assertion("negative array index");
    _jump1861:;
    if (c < _139.d2)
    goto _jump1862;
    fail_assertion("index too large");
    _jump1862:;
    int64_t _218 = 0;
    _218 *= _139.d0;
    _218 += _140;
    _218 *= _139.d1;
    _218 += _183;
    _218 *= _139.d2;
    _218 += c;
    _a1_int64_t _219 = _139.data[_218];
    _69 = _219;
    _jump1766:;
    _a1__a1_bool _220;
    // Computing bound for r
    int64_t _221;
    // Computing bound for r
    int64_t _222 = n();
    if (_222 > 0) 
    goto _jump1863;
    fail_assertion("non-positive loop bound");
    _jump1863:;
    _221 = 0;
    int64_t _223 = 0; // r
    _jump1864:; // Begin body of loop
    _221 += c;
    _223++;
    if (_223 < _222)
    goto _jump1864;
    // End body of loop
    _220.d0 = _221;
    if (_221 > 0) 
    goto _jump1865;
    fail_assertion("non-positive loop bound");
    _jump1865:;
    // Computing total size of heap memory to allocate
    int64_t _224 = 1;
    _224 *= _221;
    _224 *= sizeof(_a1_bool);
    _220.data = jpl_alloc(_224);
    int64_t _225 = 0; // r
    _jump1866:; // Begin body of loop
    _a1_bool _226;
    _226.d0 = 1;
    _226.data = jpl_alloc(sizeof(bool) * 1);
    _226.data[0] = k;
    int64_t _227 = 0;
    _227 *= _220.d0;
    _227 += _225;
    _220.data[_227] = _226;
    _225++;
    if (_225 < _221)
    goto _jump1866;
    // End body of loop
    int64_t _228 = n();
    bool _229 = c < _228;
    bool _230 = !_229;
    int64_t _231;
    if (!_230)
    goto _jump1867;
    int64_t _232;
    // Computing bound for r
    if (j > 0) 
    goto _jump1868;
    fail_assertion("non-positive loop bound");
    _jump1868:;
    _232 = 0;
    int64_t _233 = 0; // r
    _jump1869:; // Begin body of loop
    int64_t _234 = 71;
    _232 += _234;
    _233++;
    if (_233 < j)
    goto _jump1869;
    // End body of loop
    _231 = _232;
    goto _jump1870;
    _jump1867:;
    int64_t _235 = n();
    int64_t _236 = -_235;
    int64_t _237 = -_236;
    _231 = _237;
    _jump1870:;
    if (_231 >= 0)
    goto _jump1871;
    fail_assertion("negative array index");
    _jump1871:;
    if (_231 < _220.d0)
    goto _jump1872;
    fail_assertion("index too large");
    _jump1872:;
    int64_t _238 = 0;
    _238 *= _220.d0;
    _238 += _231;
    _a1_bool _239 = _220.data[_238];
    if (d >= 0)
    goto _jump1873;
    fail_assertion("negative array index");
    _jump1873:;
    if (d < _239.d0)
    goto _jump1874;
    fail_assertion("index too large");
    _jump1874:;
    int64_t _240 = 0;
    _240 *= _239.d0;
    _240 += d;
    bool _241 = _239.data[_240];
    _a1__a3_int64_t _242;
    if (!_241)
    goto _jump1875;
    _a3_int64_t _243;
    if (!k)
    goto _jump1876;
    _a3_int64_t _244;
    // Computing bound for r
    _244.d0 = j;
    if (j > 0) 
    goto _jump1877;
    fail_assertion("non-positive loop bound");
    _jump1877:;
    // Computing bound for s
    _244.d1 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1878;
    fail_assertion("non-positive loop bound");
    _jump1878:;
    // Computing bound for t
    _244.d2 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1879;
    fail_assertion("non-positive loop bound");
    _jump1879:;
    // Computing total size of heap memory to allocate
    int64_t _245 = 1;
    _245 *= j;
    _245 *= _69.d0;
    _245 *= _69.d0;
    _245 *= sizeof(int64_t);
    _244.data = jpl_alloc(_245);
    int64_t _246 = 0; // t
    int64_t _247 = 0; // s
    int64_t _248 = 0; // r
    _jump1880:; // Begin body of loop
    int64_t _249 = 582;
    int64_t _250 = 0;
    _250 *= _244.d0;
    _250 += _248;
    _250 *= _244.d1;
    _250 += _247;
    _250 *= _244.d2;
    _250 += _246;
    _244.data[_250] = _249;
    _246++;
    if (_246 < _69.d0)
    goto _jump1880;
    _246 = 0;
    _247++;
    if (_247 < _69.d0)
    goto _jump1880;
    _247 = 0;
    _248++;
    if (_248 < j)
    goto _jump1880;
    // End body of loop
    _243 = _244;
    goto _jump1881;
    _jump1876:;
    bool _251 = true;
    bool _252 = !_251;
    bool _253 = !_252;
    _a3_int64_t _254;
    if (!_253)
    goto _jump1882;
    _a3_int64_t _255;
    if (!k)
    goto _jump1883;
    _a3_int64_t _256;
    // Computing bound for r
    int64_t _257 = 838;
    _256.d0 = _257;
    if (_257 > 0) 
    goto _jump1884;
    fail_assertion("non-positive loop bound");
    _jump1884:;
    // Computing bound for s
    int64_t _258 = n();
    _256.d1 = _258;
    if (_258 > 0) 
    goto _jump1885;
    fail_assertion("non-positive loop bound");
    _jump1885:;
    // Computing bound for t
    _256.d2 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1886;
    fail_assertion("non-positive loop bound");
    _jump1886:;
    // Computing total size of heap memory to allocate
    int64_t _259 = 1;
    _259 *= _257;
    _259 *= _258;
    _259 *= _69.d0;
    _259 *= sizeof(int64_t);
    _256.data = jpl_alloc(_259);
    int64_t _260 = 0; // t
    int64_t _261 = 0; // s
    int64_t _262 = 0; // r
    _jump1887:; // Begin body of loop
    int64_t _263 = 0;
    _263 *= _256.d0;
    _263 += _262;
    _263 *= _256.d1;
    _263 += _261;
    _263 *= _256.d2;
    _263 += _260;
    _256.data[_263] = _261;
    _260++;
    if (_260 < _69.d0)
    goto _jump1887;
    _260 = 0;
    _261++;
    if (_261 < _258)
    goto _jump1887;
    _261 = 0;
    _262++;
    if (_262 < _257)
    goto _jump1887;
    // End body of loop
    _255 = _256;
    goto _jump1888;
    _jump1883:;
    _a3_int64_t _264;
    // Computing bound for r
    _264.d0 = j;
    if (j > 0) 
    goto _jump1889;
    fail_assertion("non-positive loop bound");
    _jump1889:;
    // Computing bound for s
    _264.d1 = c;
    if (c > 0) 
    goto _jump1890;
    fail_assertion("non-positive loop bound");
    _jump1890:;
    // Computing bound for t
    _264.d2 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1891;
    fail_assertion("non-positive loop bound");
    _jump1891:;
    // Computing total size of heap memory to allocate
    int64_t _265 = 1;
    _265 *= j;
    _265 *= c;
    _265 *= _69.d0;
    _265 *= sizeof(int64_t);
    _264.data = jpl_alloc(_265);
    int64_t _266 = 0; // t
    int64_t _267 = 0; // s
    int64_t _268 = 0; // r
    _jump1892:; // Begin body of loop
    int64_t _269 = 0;
    _269 *= _264.d0;
    _269 += _268;
    _269 *= _264.d1;
    _269 += _267;
    _269 *= _264.d2;
    _269 += _266;
    _264.data[_269] = d;
    _266++;
    if (_266 < _69.d0)
    goto _jump1892;
    _266 = 0;
    _267++;
    if (_267 < c)
    goto _jump1892;
    _267 = 0;
    _268++;
    if (_268 < j)
    goto _jump1892;
    // End body of loop
    _255 = _264;
    _jump1888:;
    _254 = _255;
    goto _jump1893;
    _jump1882:;
    _a3_int64_t _270;
    // Computing bound for r
    _270.d0 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1894;
    fail_assertion("non-positive loop bound");
    _jump1894:;
    // Computing bound for s
    int64_t _271 = 11;
    _270.d1 = _271;
    if (_271 > 0) 
    goto _jump1895;
    fail_assertion("non-positive loop bound");
    _jump1895:;
    // Computing bound for t
    int64_t _272 = 978;
    int64_t _273 = _272 * d;
    _270.d2 = _273;
    if (_273 > 0) 
    goto _jump1896;
    fail_assertion("non-positive loop bound");
    _jump1896:;
    // Computing total size of heap memory to allocate
    int64_t _274 = 1;
    _274 *= _69.d0;
    _274 *= _271;
    _274 *= _273;
    _274 *= sizeof(int64_t);
    _270.data = jpl_alloc(_274);
    int64_t _275 = 0; // t
    int64_t _276 = 0; // s
    int64_t _277 = 0; // r
    _jump1897:; // Begin body of loop
    int64_t _278;
    // Computing bound for u
    int64_t _279 = n();
    if (_279 > 0) 
    goto _jump1898;
    fail_assertion("non-positive loop bound");
    _jump1898:;
    _278 = 0;
    int64_t _280 = 0; // u
    _jump1899:; // Begin body of loop
    _278 += _276;
    _280++;
    if (_280 < _279)
    goto _jump1899;
    // End body of loop
    int64_t _281 = 0;
    _281 *= _270.d0;
    _281 += _277;
    _281 *= _270.d1;
    _281 += _276;
    _281 *= _270.d2;
    _281 += _275;
    _270.data[_281] = _278;
    _275++;
    if (_275 < _273)
    goto _jump1897;
    _275 = 0;
    _276++;
    if (_276 < _271)
    goto _jump1897;
    _276 = 0;
    _277++;
    if (_277 < _69.d0)
    goto _jump1897;
    // End body of loop
    _254 = _270;
    _jump1893:;
    _243 = _254;
    _jump1881:;
    _a1__a3_int64_t _282;
    _282.d0 = 1;
    _282.data = jpl_alloc(sizeof(_a3_int64_t) * 1);
    _282.data[0] = _243;
    _242 = _282;
    goto _jump1900;
    _jump1875:;
    _a1__a3_int64_t _283;
    // Computing bound for r
    int64_t _284 = n();
    int64_t _285 = _284 - j;
    _283.d0 = _285;
    if (_285 > 0) 
    goto _jump1901;
    fail_assertion("non-positive loop bound");
    _jump1901:;
    // Computing total size of heap memory to allocate
    int64_t _286 = 1;
    _286 *= _285;
    _286 *= sizeof(_a3_int64_t);
    _283.data = jpl_alloc(_286);
    int64_t _287 = 0; // r
    _jump1902:; // Begin body of loop
    _a3_int64_t _288;
    // Computing bound for s
    int64_t _289;
    if (!k)
    goto _jump1903;
    _289 = c;
    goto _jump1904;
    _jump1903:;
    _289 = j;
    _jump1904:;
    int64_t _290 = -d;
    int64_t _291 = _289 * _290;
    _288.d0 = _291;
    if (_291 > 0) 
    goto _jump1905;
    fail_assertion("non-positive loop bound");
    _jump1905:;
    // Computing bound for t
    bool _292 = _68 == _68;
    int64_t _293;
    if (!_292)
    goto _jump1906;
    int64_t _294 = -j;
    _293 = _294;
    goto _jump1907;
    _jump1906:;
    _293 = _69.d0;
    _jump1907:;
    int64_t _295 = _69.d0 / _293;
    _288.d1 = _295;
    if (_295 > 0) 
    goto _jump1908;
    fail_assertion("non-positive loop bound");
    _jump1908:;
    // Computing bound for u
    int64_t _296 = c - j;
    int64_t _297 = -_296;
    int64_t _298 = -_297;
    _288.d2 = _298;
    if (_298 > 0) 
    goto _jump1909;
    fail_assertion("non-positive loop bound");
    _jump1909:;
    // Computing total size of heap memory to allocate
    int64_t _299 = 1;
    _299 *= _291;
    _299 *= _295;
    _299 *= _298;
    _299 *= sizeof(int64_t);
    _288.data = jpl_alloc(_299);
    int64_t _300 = 0; // u
    int64_t _301 = 0; // t
    int64_t _302 = 0; // s
    _jump1910:; // Begin body of loop
    int64_t _303 = n();
    int64_t _304 = 0;
    _304 *= _288.d0;
    _304 += _302;
    _304 *= _288.d1;
    _304 += _301;
    _304 *= _288.d2;
    _304 += _300;
    _288.data[_304] = _303;
    _300++;
    if (_300 < _298)
    goto _jump1910;
    _300 = 0;
    _301++;
    if (_301 < _295)
    goto _jump1910;
    _301 = 0;
    _302++;
    if (_302 < _291)
    goto _jump1910;
    // End body of loop
    int64_t _305 = 0;
    _305 *= _283.d0;
    _305 += _287;
    _283.data[_305] = _288;
    _287++;
    if (_287 < _285)
    goto _jump1902;
    // End body of loop
    _242 = _283;
    _jump1900:;
    int64_t _306 = -j;
    _a3_void_t _307;
    // Computing bound for r
    _307.d0 = j;
    if (j > 0) 
    goto _jump1911;
    fail_assertion("non-positive loop bound");
    _jump1911:;
    // Computing bound for s
    int64_t _308 = 574;
    int64_t _309 = -_308;
    int64_t _310 = -_309;
    _307.d1 = _310;
    if (_310 > 0) 
    goto _jump1912;
    fail_assertion("non-positive loop bound");
    _jump1912:;
    // Computing bound for t
    int64_t _311;
    // Computing bound for r
    if (c > 0) 
    goto _jump1913;
    fail_assertion("non-positive loop bound");
    _jump1913:;
    // Computing bound for s
    if (c > 0) 
    goto _jump1914;
    fail_assertion("non-positive loop bound");
    _jump1914:;
    _311 = 0;
    int64_t _312 = 0; // s
    int64_t _313 = 0; // r
    _jump1915:; // Begin body of loop
    _311 += _313;
    _312++;
    if (_312 < c)
    goto _jump1915;
    _312 = 0;
    _313++;
    if (_313 < c)
    goto _jump1915;
    // End body of loop
    bool _314 = d < d;
    int64_t _315;
    if (!_314)
    goto _jump1916;
    int64_t _316 = -c;
    _315 = _316;
    goto _jump1917;
    _jump1916:;
    _315 = d;
    _jump1917:;
    bool _317 = _311 != _315;
    int64_t _318;
    if (!_317)
    goto _jump1918;
    _318 = d;
    goto _jump1919;
    _jump1918:;
    int64_t _319 = 16;
    _318 = _319;
    _jump1919:;
    _307.d2 = _318;
    if (_318 > 0) 
    goto _jump1920;
    fail_assertion("non-positive loop bound");
    _jump1920:;
    // Computing total size of heap memory to allocate
    int64_t _320 = 1;
    _320 *= j;
    _320 *= _310;
    _320 *= _318;
    _320 *= sizeof(void_t);
    _307.data = jpl_alloc(_320);
    int64_t _321 = 0; // t
    int64_t _322 = 0; // s
    int64_t _323 = 0; // r
    _jump1921:; // Begin body of loop
    a _324 = h();
    double _325 = _324.b;
    double _326 = 90.0;
    double _327 = 35.0;
    double _328 = -_327;
    rgba _329 = { _325, _326, _68, _328 };
    _a2_double _330;
    // Computing bound for u
    _330.d0 = j;
    if (j > 0) 
    goto _jump1922;
    fail_assertion("non-positive loop bound");
    _jump1922:;
    // Computing bound for v
    int64_t _331 = n();
    _330.d1 = _331;
    if (_331 > 0) 
    goto _jump1923;
    fail_assertion("non-positive loop bound");
    _jump1923:;
    // Computing total size of heap memory to allocate
    int64_t _332 = 1;
    _332 *= j;
    _332 *= _331;
    _332 *= sizeof(double);
    _330.data = jpl_alloc(_332);
    int64_t _333 = 0; // v
    int64_t _334 = 0; // u
    _jump1924:; // Begin body of loop
    double _335;
    // Computing bound for w
    if (_69.d0 > 0) 
    goto _jump1925;
    fail_assertion("non-positive loop bound");
    _jump1925:;
    _335 = 0;
    int64_t _336 = 0; // w
    _jump1926:; // Begin body of loop
    _335 += _68;
    _336++;
    if (_336 < _69.d0)
    goto _jump1926;
    // End body of loop
    int64_t _337 = 0;
    _337 *= _330.d0;
    _337 += _334;
    _337 *= _330.d1;
    _337 += _333;
    _330.data[_337] = _335;
    _333++;
    if (_333 < _331)
    goto _jump1924;
    _333 = 0;
    _334++;
    if (_334 < j)
    goto _jump1924;
    // End body of loop
    a _338 = m(_329, _330);
    void_t _339 = _338.a;
    int64_t _340 = 0;
    _340 *= _307.d0;
    _340 += _323;
    _340 *= _307.d1;
    _340 += _322;
    _340 *= _307.d2;
    _340 += _321;
    _307.data[_340] = _339;
    _321++;
    if (_321 < _318)
    goto _jump1921;
    _321 = 0;
    _322++;
    if (_322 < _310)
    goto _jump1921;
    _322 = 0;
    _323++;
    if (_323 < j)
    goto _jump1921;
    // End body of loop
    int64_t _342 = -d;
    _a3_void_t _343;
    // Computing bound for r
    _343.d0 = j;
    if (j > 0) 
    goto _jump1927;
    fail_assertion("non-positive loop bound");
    _jump1927:;
    // Computing bound for s
    int64_t _344 = n();
    _343.d1 = _344;
    if (_344 > 0) 
    goto _jump1928;
    fail_assertion("non-positive loop bound");
    _jump1928:;
    // Computing bound for t
    int64_t _345 = 536;
    _343.d2 = _345;
    if (_345 > 0) 
    goto _jump1929;
    fail_assertion("non-positive loop bound");
    _jump1929:;
    // Computing total size of heap memory to allocate
    int64_t _346 = 1;
    _346 *= j;
    _346 *= _344;
    _346 *= _345;
    _346 *= sizeof(void_t);
    _343.data = jpl_alloc(_346);
    int64_t _347 = 0; // t
    int64_t _348 = 0; // s
    int64_t _349 = 0; // r
    _jump1930:; // Begin body of loop
    a _350 = h();
    void_t _351 = _350.a;
    int64_t _352 = 0;
    _352 *= _343.d0;
    _352 += _349;
    _352 *= _343.d1;
    _352 += _348;
    _352 *= _343.d2;
    _352 += _347;
    _343.data[_352] = _351;
    _347++;
    if (_347 < _345)
    goto _jump1930;
    _347 = 0;
    _348++;
    if (_348 < _344)
    goto _jump1930;
    _348 = 0;
    _349++;
    if (_349 < j)
    goto _jump1930;
    // End body of loop
    bool _353 = !k;
    int64_t _354 = l(_342, _343, _353);
    bool _355 = _354 == c;
    bool _341 = _355;
    if (0 != _355)
    goto _jump1931;
    bool _356 = true;
    bool _357;
    if (!_356)
    goto _jump1932;
    bool _358 = k;
    if (0 == k)
    goto _jump1933;
    bool _359 = _68 > _68;
    _358 = _359;
    _jump1933:;
    bool _360;
    if (!_358)
    goto _jump1934;
    _a3_bool _361;
    // Computing bound for r
    _361.d0 = d;
    if (d > 0) 
    goto _jump1935;
    fail_assertion("non-positive loop bound");
    _jump1935:;
    // Computing bound for s
    _361.d1 = c;
    if (c > 0) 
    goto _jump1936;
    fail_assertion("non-positive loop bound");
    _jump1936:;
    // Computing bound for t
    _361.d2 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1937;
    fail_assertion("non-positive loop bound");
    _jump1937:;
    // Computing total size of heap memory to allocate
    int64_t _362 = 1;
    _362 *= d;
    _362 *= c;
    _362 *= _69.d0;
    _362 *= sizeof(bool);
    _361.data = jpl_alloc(_362);
    int64_t _363 = 0; // t
    int64_t _364 = 0; // s
    int64_t _365 = 0; // r
    _jump1938:; // Begin body of loop
    int64_t _366 = 0;
    _366 *= _361.d0;
    _366 += _365;
    _366 *= _361.d1;
    _366 += _364;
    _366 *= _361.d2;
    _366 += _363;
    _361.data[_366] = k;
    _363++;
    if (_363 < _69.d0)
    goto _jump1938;
    _363 = 0;
    _364++;
    if (_364 < c)
    goto _jump1938;
    _364 = 0;
    _365++;
    if (_365 < d)
    goto _jump1938;
    // End body of loop
    int64_t _367 = 593;
    int64_t _368 = n();
    int64_t _369 = n();
    if (_367 >= 0)
    goto _jump1939;
    fail_assertion("negative array index");
    _jump1939:;
    if (_367 < _361.d0)
    goto _jump1940;
    fail_assertion("index too large");
    _jump1940:;
    if (_368 >= 0)
    goto _jump1941;
    fail_assertion("negative array index");
    _jump1941:;
    if (_368 < _361.d1)
    goto _jump1942;
    fail_assertion("index too large");
    _jump1942:;
    if (_369 >= 0)
    goto _jump1943;
    fail_assertion("negative array index");
    _jump1943:;
    if (_369 < _361.d2)
    goto _jump1944;
    fail_assertion("index too large");
    _jump1944:;
    int64_t _370 = 0;
    _370 *= _361.d0;
    _370 += _367;
    _370 *= _361.d1;
    _370 += _368;
    _370 *= _361.d2;
    _370 += _369;
    bool _371 = _361.data[_370];
    _360 = _371;
    goto _jump1945;
    _jump1934:;
    bool _373 = _69.d0 < _69.d0;
    bool _372 = _373;
    if (0 == _373)
    goto _jump1946;
    bool _374 = false;
    _372 = _374;
    _jump1946:;
    _360 = _372;
    _jump1945:;
    _357 = _360;
    goto _jump1947;
    _jump1932:;
    bool _375 = true;
    bool _376 = _375 == k;
    bool _377 = d <= d;
    bool _378 = false;
    bool _379 = true;
    bool _380 = _378 == _379;
    _a1_bool _381;
    _381.d0 = 3;
    _381.data = jpl_alloc(sizeof(bool) * 3);
    _381.data[0] = _376;
    _381.data[1] = _377;
    _381.data[2] = _380;
    int64_t _382 = n();
    if (_382 >= 0)
    goto _jump1948;
    fail_assertion("negative array index");
    _jump1948:;
    if (_382 < _381.d0)
    goto _jump1949;
    fail_assertion("index too large");
    _jump1949:;
    int64_t _383 = 0;
    _383 *= _381.d0;
    _383 += _382;
    bool _384 = _381.data[_383];
    _357 = _384;
    _jump1947:;
    _341 = _357;
    _jump1931:;
    int64_t _385 = l(_306, _307, _341);
    if (_385 >= 0)
    goto _jump1950;
    fail_assertion("negative array index");
    _jump1950:;
    if (_385 < _242.d0)
    goto _jump1951;
    fail_assertion("index too large");
    _jump1951:;
    int64_t _386 = 0;
    _386 *= _242.d0;
    _386 += _385;
    _a3_int64_t _387 = _242.data[_386];
    _a3__a3_rgba _388;
    // Computing bound for z
    _388.d0 = _387.d0;
    if (_387.d0 > 0) 
    goto _jump1952;
    fail_assertion("non-positive loop bound");
    _jump1952:;
    // Computing bound for A
    _388.d1 = _69.d0;
    if (_69.d0 > 0) 
    goto _jump1953;
    fail_assertion("non-positive loop bound");
    _jump1953:;
    // Computing bound for B
    _388.d2 = _387.d2;
    if (_387.d2 > 0) 
    goto _jump1954;
    fail_assertion("non-positive loop bound");
    _jump1954:;
    // Computing total size of heap memory to allocate
    int64_t _389 = 1;
    _389 *= _387.d0;
    _389 *= _69.d0;
    _389 *= _387.d2;
    _389 *= sizeof(_a3_rgba);
    _388.data = jpl_alloc(_389);
    int64_t _390 = 0; // B
    int64_t _391 = 0; // A
    int64_t _392 = 0; // z
    _jump1955:; // Begin body of loop
    int64_t _393 = -_387.d2;
    int64_t _394 = _393 - d;
    bool _395 = false;
    int64_t _396;
    if (!_395)
    goto _jump1956;
    _396 = _387.d0;
    goto _jump1957;
    _jump1956:;
    int64_t _397;
    // Computing bound for C
    if (_387.d0 > 0) 
    goto _jump1958;
    fail_assertion("non-positive loop bound");
    _jump1958:;
    // Computing bound for D
    if (_387.d2 > 0) 
    goto _jump1959;
    fail_assertion("non-positive loop bound");
    _jump1959:;
    // Computing bound for E
    if (_69.d0 > 0) 
    goto _jump1960;
    fail_assertion("non-positive loop bound");
    _jump1960:;
    _397 = 0;
    int64_t _398 = 0; // E
    int64_t _399 = 0; // D
    int64_t _400 = 0; // C
    _jump1961:; // Begin body of loop
    _397 += _398;
    _398++;
    if (_398 < _69.d0)
    goto _jump1961;
    _398 = 0;
    _399++;
    if (_399 < _387.d2)
    goto _jump1961;
    _399 = 0;
    _400++;
    if (_400 < _387.d0)
    goto _jump1961;
    // End body of loop
    _396 = _397;
    _jump1957:;
    bool _401 = _394 > _396;
    _a3_rgba _402;
    if (!_401)
    goto _jump1962;
    bool _403 = true;
    double _404;
    if (!_403)
    goto _jump1963;
    double _405 = 1.0;
    _404 = _405;
    goto _jump1964;
    _jump1963:;
    double _406 = 55.0;
    _404 = _406;
    _jump1964:;
    a _407 = h();
    double _408 = _407.b;
    bool _409 = _404 != _408;
    _a3_rgba _410;
    if (!_409)
    goto _jump1965;
    _a3_rgba _411;
    // Computing bound for C
    _411.d0 = _390;
    if (_390 > 0) 
    goto _jump1966;
    fail_assertion("non-positive loop bound");
    _jump1966:;
    // Computing bound for D
    _411.d1 = _387.d2;
    if (_387.d2 > 0) 
    goto _jump1967;
    fail_assertion("non-positive loop bound");
    _jump1967:;
    // Computing bound for E
    _411.d2 = _391;
    if (_391 > 0) 
    goto _jump1968;
    fail_assertion("non-positive loop bound");
    _jump1968:;
    // Computing total size of heap memory to allocate
    int64_t _412 = 1;
    _412 *= _390;
    _412 *= _387.d2;
    _412 *= _391;
    _412 *= sizeof(rgba);
    _411.data = jpl_alloc(_412);
    int64_t _413 = 0; // E
    int64_t _414 = 0; // D
    int64_t _415 = 0; // C
    _jump1969:; // Begin body of loop
    if (_415 >= 0)
    goto _jump1970;
    fail_assertion("negative array index");
    _jump1970:;
    if (_415 < e.d0)
    goto _jump1971;
    fail_assertion("index too large");
    _jump1971:;
    if (_390 >= 0)
    goto _jump1972;
    fail_assertion("negative array index");
    _jump1972:;
    if (_390 < e.d1)
    goto _jump1973;
    fail_assertion("index too large");
    _jump1973:;
    int64_t _416 = 0;
    _416 *= e.d0;
    _416 += _415;
    _416 *= e.d1;
    _416 += _390;
    rgba _417 = e.data[_416];
    int64_t _418 = 0;
    _418 *= _411.d0;
    _418 += _415;
    _418 *= _411.d1;
    _418 += _414;
    _418 *= _411.d2;
    _418 += _413;
    _411.data[_418] = _417;
    _413++;
    if (_413 < _391)
    goto _jump1969;
    _413 = 0;
    _414++;
    if (_414 < _387.d2)
    goto _jump1969;
    _414 = 0;
    _415++;
    if (_415 < _390)
    goto _jump1969;
    // End body of loop
    _410 = _411;
    goto _jump1974;
    _jump1965:;
    _a3_rgba _419;
    // Computing bound for C
    _419.d0 = _387.d1;
    if (_387.d1 > 0) 
    goto _jump1975;
    fail_assertion("non-positive loop bound");
    _jump1975:;
    // Computing bound for D
    _419.d1 = _387.d0;
    if (_387.d0 > 0) 
    goto _jump1976;
    fail_assertion("non-positive loop bound");
    _jump1976:;
    // Computing bound for E
    _419.d2 = _392;
    if (_392 > 0) 
    goto _jump1977;
    fail_assertion("non-positive loop bound");
    _jump1977:;
    // Computing total size of heap memory to allocate
    int64_t _420 = 1;
    _420 *= _387.d1;
    _420 *= _387.d0;
    _420 *= _392;
    _420 *= sizeof(rgba);
    _419.data = jpl_alloc(_420);
    int64_t _421 = 0; // E
    int64_t _422 = 0; // D
    int64_t _423 = 0; // C
    _jump1978:; // Begin body of loop
    int64_t _424 = n();
    if (_69.d0 >= 0)
    goto _jump1979;
    fail_assertion("negative array index");
    _jump1979:;
    if (_69.d0 < e.d0)
    goto _jump1980;
    fail_assertion("index too large");
    _jump1980:;
    if (_424 >= 0)
    goto _jump1981;
    fail_assertion("negative array index");
    _jump1981:;
    if (_424 < e.d1)
    goto _jump1982;
    fail_assertion("index too large");
    _jump1982:;
    int64_t _425 = 0;
    _425 *= e.d0;
    _425 += _69.d0;
    _425 *= e.d1;
    _425 += _424;
    rgba _426 = e.data[_425];
    int64_t _427 = 0;
    _427 *= _419.d0;
    _427 += _423;
    _427 *= _419.d1;
    _427 += _422;
    _427 *= _419.d2;
    _427 += _421;
    _419.data[_427] = _426;
    _421++;
    if (_421 < _392)
    goto _jump1978;
    _421 = 0;
    _422++;
    if (_422 < _387.d0)
    goto _jump1978;
    _422 = 0;
    _423++;
    if (_423 < _387.d1)
    goto _jump1978;
    // End body of loop
    _410 = _419;
    _jump1974:;
    _402 = _410;
    goto _jump1983;
    _jump1962:;
    _a3_rgba _428;
    // Computing bound for C
    int64_t _429;
    // Computing bound for C
    if (_387.d0 > 0) 
    goto _jump1984;
    fail_assertion("non-positive loop bound");
    _jump1984:;
    // Computing bound for D
    if (j > 0) 
    goto _jump1985;
    fail_assertion("non-positive loop bound");
    _jump1985:;
    _429 = 0;
    int64_t _430 = 0; // D
    int64_t _431 = 0; // C
    _jump1986:; // Begin body of loop
    _429 += d;
    _430++;
    if (_430 < j)
    goto _jump1986;
    _430 = 0;
    _431++;
    if (_431 < _387.d0)
    goto _jump1986;
    // End body of loop
    if (_429 >= 0)
    goto _jump1987;
    fail_assertion("negative array index");
    _jump1987:;
    if (_429 < b.d0)
    goto _jump1988;
    fail_assertion("index too large");
    _jump1988:;
    if (_387.d2 >= 0)
    goto _jump1989;
    fail_assertion("negative array index");
    _jump1989:;
    if (_387.d2 < b.d1)
    goto _jump1990;
    fail_assertion("index too large");
    _jump1990:;
    int64_t _432 = 0;
    _432 *= b.d0;
    _432 += _429;
    _432 *= b.d1;
    _432 += _387.d2;
    int64_t _433 = b.data[_432];
    _428.d0 = _433;
    if (_433 > 0) 
    goto _jump1991;
    fail_assertion("non-positive loop bound");
    _jump1991:;
    // Computing bound for D
    _428.d1 = _387.d0;
    if (_387.d0 > 0) 
    goto _jump1992;
    fail_assertion("non-positive loop bound");
    _jump1992:;
    // Computing bound for E
    _428.d2 = d;
    if (d > 0) 
    goto _jump1993;
    fail_assertion("non-positive loop bound");
    _jump1993:;
    // Computing total size of heap memory to allocate
    int64_t _434 = 1;
    _434 *= _433;
    _434 *= _387.d0;
    _434 *= d;
    _434 *= sizeof(rgba);
    _428.data = jpl_alloc(_434);
    int64_t _435 = 0; // E
    int64_t _436 = 0; // D
    int64_t _437 = 0; // C
    _jump1994:; // Begin body of loop
    _a2_rgba _438;
    if (!k)
    goto _jump1995;
    _438 = e;
    goto _jump1996;
    _jump1995:;
    _438 = e;
    _jump1996:;
    int64_t _439 = n();
    if (_439 >= 0)
    goto _jump1997;
    fail_assertion("negative array index");
    _jump1997:;
    if (_439 < _387.d0)
    goto _jump1998;
    fail_assertion("index too large");
    _jump1998:;
    if (_387.d2 >= 0)
    goto _jump1999;
    fail_assertion("negative array index");
    _jump1999:;
    if (_387.d2 < _387.d1)
    goto _jump2000;
    fail_assertion("index too large");
    _jump2000:;
    if (_390 >= 0)
    goto _jump2001;
    fail_assertion("negative array index");
    _jump2001:;
    if (_390 < _387.d2)
    goto _jump2002;
    fail_assertion("index too large");
    _jump2002:;
    int64_t _440 = 0;
    _440 *= _387.d0;
    _440 += _439;
    _440 *= _387.d1;
    _440 += _387.d2;
    _440 *= _387.d2;
    _440 += _390;
    int64_t _441 = _387.data[_440];
    if (_441 >= 0)
    goto _jump2003;
    fail_assertion("negative array index");
    _jump2003:;
    if (_441 < _438.d0)
    goto _jump2004;
    fail_assertion("index too large");
    _jump2004:;
    if (_387.d2 >= 0)
    goto _jump2005;
    fail_assertion("negative array index");
    _jump2005:;
    if (_387.d2 < _438.d1)
    goto _jump2006;
    fail_assertion("index too large");
    _jump2006:;
    int64_t _442 = 0;
    _442 *= _438.d0;
    _442 += _441;
    _442 *= _438.d1;
    _442 += _387.d2;
    rgba _443 = _438.data[_442];
    int64_t _444 = 0;
    _444 *= _428.d0;
    _444 += _437;
    _444 *= _428.d1;
    _444 += _436;
    _444 *= _428.d2;
    _444 += _435;
    _428.data[_444] = _443;
    _435++;
    if (_435 < d)
    goto _jump1994;
    _435 = 0;
    _436++;
    if (_436 < _387.d0)
    goto _jump1994;
    _436 = 0;
    _437++;
    if (_437 < _433)
    goto _jump1994;
    // End body of loop
    _402 = _428;
    _jump1983:;
    int64_t _445 = 0;
    _445 *= _388.d0;
    _445 += _392;
    _445 *= _388.d1;
    _445 += _391;
    _445 *= _388.d2;
    _445 += _390;
    _388.data[_445] = _402;
    _390++;
    if (_390 < _387.d2)
    goto _jump1955;
    _390 = 0;
    _391++;
    if (_391 < _69.d0)
    goto _jump1955;
    _391 = 0;
    _392++;
    if (_392 < _387.d0)
    goto _jump1955;
    // End body of loop
    if (_387.d2 >= 0)
    goto _jump2007;
    fail_assertion("negative array index");
    _jump2007:;
    if (_387.d2 < _388.d0)
    goto _jump2008;
    fail_assertion("index too large");
    _jump2008:;
    if (_387.d2 >= 0)
    goto _jump2009;
    fail_assertion("negative array index");
    _jump2009:;
    if (_387.d2 < _388.d1)
    goto _jump2010;
    fail_assertion("index too large");
    _jump2010:;
    if (d >= 0)
    goto _jump2011;
    fail_assertion("negative array index");
    _jump2011:;
    if (d < _388.d2)
    goto _jump2012;
    fail_assertion("index too large");
    _jump2012:;
    int64_t _446 = 0;
    _446 *= _388.d0;
    _446 += _387.d2;
    _446 *= _388.d1;
    _446 += _387.d2;
    _446 *= _388.d2;
    _446 += d;
    _a3_rgba _447 = _388.data[_446];
    _a2_double _448 = f(_447);
    _a3__a3_rgba _449;
    // Computing bound for C
    _a3_void_t _450;
    // Computing bound for C
    _450.d0 = _448.d0;
    if (_448.d0 > 0) 
    goto _jump2013;
    fail_assertion("non-positive loop bound");
    _jump2013:;
    // Computing bound for D
    int64_t _451;
    // Computing bound for C
    int64_t _452 = _387.d0 % j;
    if (_452 > 0) 
    goto _jump2014;
    fail_assertion("non-positive loop bound");
    _jump2014:;
    // Computing bound for D
    if (_387.d2 > 0) 
    goto _jump2015;
    fail_assertion("non-positive loop bound");
    _jump2015:;
    _451 = 0;
    int64_t _453 = 0; // D
    int64_t _454 = 0; // C
    _jump2016:; // Begin body of loop
    _451 += _387.d2;
    _453++;
    if (_453 < _387.d2)
    goto _jump2016;
    _453 = 0;
    _454++;
    if (_454 < _452)
    goto _jump2016;
    // End body of loop
    _450.d1 = _451;
    if (_451 > 0) 
    goto _jump2017;
    fail_assertion("non-positive loop bound");
    _jump2017:;
    // Computing bound for E
    _450.d2 = _387.d1;
    if (_387.d1 > 0) 
    goto _jump2018;
    fail_assertion("non-positive loop bound");
    _jump2018:;
    // Computing total size of heap memory to allocate
    int64_t _455 = 1;
    _455 *= _448.d0;
    _455 *= _451;
    _455 *= _387.d1;
    _455 *= sizeof(void_t);
    _450.data = jpl_alloc(_455);
    int64_t _456 = 0; // E
    int64_t _457 = 0; // D
    int64_t _458 = 0; // C
    _jump2019:; // Begin body of loop
    int64_t _459 = n();
    bool _460 = _459 > _387.d0;
    void_t _461;
    if (!_460)
    goto _jump2020;
    a _462 = h();
    void_t _463 = _462.a;
    _461 = _463;
    goto _jump2021;
    _jump2020:;
    a _464 = h();
    void_t _465 = _464.a;
    _461 = _465;
    _jump2021:;
    int64_t _466 = 0;
    _466 *= _450.d0;
    _466 += _458;
    _466 *= _450.d1;
    _466 += _457;
    _466 *= _450.d2;
    _466 += _456;
    _450.data[_466] = _461;
    _456++;
    if (_456 < _387.d1)
    goto _jump2019;
    _456 = 0;
    _457++;
    if (_457 < _451)
    goto _jump2019;
    _457 = 0;
    _458++;
    if (_458 < _448.d0)
    goto _jump2019;
    // End body of loop
    bool _467 = _448.d0 > j;
    int64_t _468 = l(_387.d1, _450, _467);
    _449.d0 = _468;
    if (_468 > 0) 
    goto _jump2022;
    fail_assertion("non-positive loop bound");
    _jump2022:;
    // Computing bound for D
    int64_t _469 = 363;
    int64_t _470 = _469 % _387.d0;
    _449.d1 = _470;
    if (_470 > 0) 
    goto _jump2023;
    fail_assertion("non-positive loop bound");
    _jump2023:;
    // Computing bound for E
    int64_t _471 = -_387.d2;
    _449.d2 = _471;
    if (_471 > 0) 
    goto _jump2024;
    fail_assertion("non-positive loop bound");
    _jump2024:;
    // Computing total size of heap memory to allocate
    int64_t _472 = 1;
    _472 *= _468;
    _472 *= _470;
    _472 *= _471;
    _472 *= sizeof(_a3_rgba);
    _449.data = jpl_alloc(_472);
    int64_t _473 = 0; // E
    int64_t _474 = 0; // D
    int64_t _475 = 0; // C
    _jump2025:; // Begin body of loop
    _a3_rgba _476;
    // Computing bound for F
    _476.d0 = _448.d0;
    if (_448.d0 > 0) 
    goto _jump2026;
    fail_assertion("non-positive loop bound");
    _jump2026:;
    // Computing bound for G
    _a2_int64_t _477;
    // Computing bound for F
    _477.d0 = _475;
    if (_475 > 0) 
    goto _jump2027;
    fail_assertion("non-positive loop bound");
    _jump2027:;
    // Computing bound for G
    _477.d1 = _448.d1;
    if (_448.d1 > 0) 
    goto _jump2028;
    fail_assertion("non-positive loop bound");
    _jump2028:;
    // Computing total size of heap memory to allocate
    int64_t _478 = 1;
    _478 *= _475;
    _478 *= _448.d1;
    _478 *= sizeof(int64_t);
    _477.data = jpl_alloc(_478);
    int64_t _479 = 0; // G
    int64_t _480 = 0; // F
    _jump2029:; // Begin body of loop
    int64_t _481 = 0;
    _481 *= _477.d0;
    _481 += _480;
    _481 *= _477.d1;
    _481 += _479;
    _477.data[_481] = c;
    _479++;
    if (_479 < _448.d1)
    goto _jump2029;
    _479 = 0;
    _480++;
    if (_480 < _475)
    goto _jump2029;
    // End body of loop
    int64_t _482;
    // Computing bound for F
    if (_387.d0 > 0) 
    goto _jump2030;
    fail_assertion("non-positive loop bound");
    _jump2030:;
    // Computing bound for G
    if (_387.d1 > 0) 
    goto _jump2031;
    fail_assertion("non-positive loop bound");
    _jump2031:;
    _482 = 0;
    int64_t _483 = 0; // G
    int64_t _484 = 0; // F
    _jump2032:; // Begin body of loop
    _482 += _483;
    _483++;
    if (_483 < _387.d1)
    goto _jump2032;
    _483 = 0;
    _484++;
    if (_484 < _387.d0)
    goto _jump2032;
    // End body of loop
    if (_482 >= 0)
    goto _jump2033;
    fail_assertion("negative array index");
    _jump2033:;
    if (_482 < _477.d0)
    goto _jump2034;
    fail_assertion("index too large");
    _jump2034:;
    if (_387.d1 >= 0)
    goto _jump2035;
    fail_assertion("negative array index");
    _jump2035:;
    if (_387.d1 < _477.d1)
    goto _jump2036;
    fail_assertion("index too large");
    _jump2036:;
    int64_t _485 = 0;
    _485 *= _477.d0;
    _485 += _482;
    _485 *= _477.d1;
    _485 += _387.d1;
    int64_t _486 = _477.data[_485];
    _476.d1 = _486;
    if (_486 > 0) 
    goto _jump2037;
    fail_assertion("non-positive loop bound");
    _jump2037:;
    // Computing bound for H
    _476.d2 = _473;
    if (_473 > 0) 
    goto _jump2038;
    fail_assertion("non-positive loop bound");
    _jump2038:;
    // Computing total size of heap memory to allocate
    int64_t _487 = 1;
    _487 *= _448.d0;
    _487 *= _486;
    _487 *= _473;
    _487 *= sizeof(rgba);
    _476.data = jpl_alloc(_487);
    int64_t _488 = 0; // H
    int64_t _489 = 0; // G
    int64_t _490 = 0; // F
    _jump2039:; // Begin body of loop
    bool _491 = true;
    double _492 = g(_491);
    double _493 = -_492;
    bool _494 = false;
    double _495 = g(_494);
    double _496 = -_495;
    bool _497 = false;
    bool _498 = !_497;
    double _499 = g(_498);
    double _500;
    // Computing bound for I
    bool _501 = false;
    int64_t _502;
    if (!_501)
    goto _jump2040;
    _502 = _387.d0;
    goto _jump2041;
    _jump2040:;
    _502 = _69.d0;
    _jump2041:;
    if (_502 > 0) 
    goto _jump2042;
    fail_assertion("non-positive loop bound");
    _jump2042:;
    _500 = 0;
    int64_t _503 = 0; // I
    _jump2043:; // Begin body of loop
    if (_448.d0 >= 0)
    goto _jump2044;
    fail_assertion("negative array index");
    _jump2044:;
    if (_448.d0 < _448.d0)
    goto _jump2045;
    fail_assertion("index too large");
    _jump2045:;
    if (_387.d2 >= 0)
    goto _jump2046;
    fail_assertion("negative array index");
    _jump2046:;
    if (_387.d2 < _448.d1)
    goto _jump2047;
    fail_assertion("index too large");
    _jump2047:;
    int64_t _504 = 0;
    _504 *= _448.d0;
    _504 += _448.d0;
    _504 *= _448.d1;
    _504 += _387.d2;
    double _505 = _448.data[_504];
    _500 += _505;
    _503++;
    if (_503 < _502)
    goto _jump2043;
    // End body of loop
    rgba _506 = { _493, _496, _499, _500 };
    int64_t _507 = 0;
    _507 *= _476.d0;
    _507 += _490;
    _507 *= _476.d1;
    _507 += _489;
    _507 *= _476.d2;
    _507 += _488;
    _476.data[_507] = _506;
    _488++;
    if (_488 < _473)
    goto _jump2039;
    _488 = 0;
    _489++;
    if (_489 < _486)
    goto _jump2039;
    _489 = 0;
    _490++;
    if (_490 < _448.d0)
    goto _jump2039;
    // End body of loop
    int64_t _508 = 0;
    _508 *= _449.d0;
    _508 += _475;
    _508 *= _449.d1;
    _508 += _474;
    _508 *= _449.d2;
    _508 += _473;
    _449.data[_508] = _476;
    _473++;
    if (_473 < _471)
    goto _jump2025;
    _473 = 0;
    _474++;
    if (_474 < _470)
    goto _jump2025;
    _474 = 0;
    _475++;
    if (_475 < _468)
    goto _jump2025;
    // End body of loop
    if (_387.d1 >= 0)
    goto _jump2048;
    fail_assertion("negative array index");
    _jump2048:;
    if (_387.d1 < _449.d0)
    goto _jump2049;
    fail_assertion("index too large");
    _jump2049:;
    if (_387.d2 >= 0)
    goto _jump2050;
    fail_assertion("negative array index");
    _jump2050:;
    if (_387.d2 < _449.d1)
    goto _jump2051;
    fail_assertion("index too large");
    _jump2051:;
    if (d >= 0)
    goto _jump2052;
    fail_assertion("negative array index");
    _jump2052:;
    if (d < _449.d2)
    goto _jump2053;
    fail_assertion("index too large");
    _jump2053:;
    int64_t _509 = 0;
    _509 *= _449.d0;
    _509 += _387.d1;
    _509 *= _449.d1;
    _509 += _387.d2;
    _509 *= _449.d2;
    _509 += d;
    _a3_rgba _510 = _449.data[_509];
    _a2_double _511 = f(_510);
    return _387.d0;
}

void jpl_main(struct args args) {
    bool _0 = true;
    bool _1;
    if (!_0)
    goto _jump1;
    int64_t _2;
    // Computing bound for a
    int64_t _3 = 465;
    if (_3 > 0) 
    goto _jump2;
    fail_assertion("non-positive loop bound");
    _jump2:;
    // Computing bound for b
    int64_t _4 = 863;
    if (_4 > 0) 
    goto _jump3;
    fail_assertion("non-positive loop bound");
    _jump3:;
    // Computing bound for c
    int64_t _5 = 677;
    if (_5 > 0) 
    goto _jump4;
    fail_assertion("non-positive loop bound");
    _jump4:;
    _2 = 0;
    int64_t _6 = 0; // c
    int64_t _7 = 0; // b
    int64_t _8 = 0; // a
    _jump5:; // Begin body of loop
    int64_t _9;
    // Computing bound for d
    if (_7 > 0) 
    goto _jump6;
    fail_assertion("non-positive loop bound");
    _jump6:;
    _9 = 0;
    int64_t _10 = 0; // d
    _jump7:; // Begin body of loop
    _9 += _8;
    _10++;
    if (_10 < _7)
    goto _jump7;
    // End body of loop
    int64_t _11 = _9 - _6;
    _2 += _11;
    _6++;
    if (_6 < _5)
    goto _jump5;
    _6 = 0;
    _7++;
    if (_7 < _4)
    goto _jump5;
    _7 = 0;
    _8++;
    if (_8 < _3)
    goto _jump5;
    // End body of loop
    int64_t _12 = -_2;
    double _13 = 61.0;
    double _14 = 79.0;
    _a1_double _15;
    _15.d0 = 1;
    _15.data = jpl_alloc(sizeof(double) * 1);
    _15.data[0] = _14;
    int64_t _16 = 902;
    if (_16 >= 0)
    goto _jump8;
    fail_assertion("negative array index");
    _jump8:;
    if (_16 < _15.d0)
    goto _jump9;
    fail_assertion("index too large");
    _jump9:;
    int64_t _17 = 0;
    _17 *= _15.d0;
    _17 += _16;
    double _18 = _15.data[_17];
    bool _19 = _13 <= _18;
    int64_t _20;
    if (!_19)
    goto _jump10;
    int64_t _21;
    // Computing bound for a
    int64_t _22 = 550;
    if (_22 > 0) 
    goto _jump11;
    fail_assertion("non-positive loop bound");
    _jump11:;
    // Computing bound for b
    int64_t _23 = 909;
    if (_23 > 0) 
    goto _jump12;
    fail_assertion("non-positive loop bound");
    _jump12:;
    _21 = 0;
    int64_t _24 = 0; // b
    int64_t _25 = 0; // a
    _jump13:; // Begin body of loop
    _21 += _24;
    _24++;
    if (_24 < _23)
    goto _jump13;
    _24 = 0;
    _25++;
    if (_25 < _22)
    goto _jump13;
    // End body of loop
    int64_t _26 = 637;
    int64_t _27 = _21 * _26;
    _20 = _27;
    goto _jump14;
    _jump10:;
    int64_t _28 = 751;
    _20 = _28;
    _jump14:;
    bool _29 = _12 != _20;
    double _30 = 67.0;
    double _31 = -_30;
    double _32 = 31.0;
    double _33 = -_32;
    double _34 = 81.0;
    double _35 = 31.0;
    double _36 = _34 - _35;
    _a1_double _37;
    _37.d0 = 3;
    _37.data = jpl_alloc(sizeof(double) * 3);
    _37.data[0] = _31;
    _37.data[1] = _33;
    _37.data[2] = _36;
    int64_t _38;
    // Computing bound for a
    int64_t _39 = 881;
    if (_39 > 0) 
    goto _jump15;
    fail_assertion("non-positive loop bound");
    _jump15:;
    _38 = 0;
    int64_t _40 = 0; // a
    _jump16:; // Begin body of loop
    int64_t _41 = -_40;
    _38 += _41;
    _40++;
    if (_40 < _39)
    goto _jump16;
    // End body of loop
    int64_t _42 = 888;
    int64_t _43 = _38 * _42;
    if (_43 >= 0)
    goto _jump17;
    fail_assertion("negative array index");
    _jump17:;
    if (_43 < _37.d0)
    goto _jump18;
    fail_assertion("index too large");
    _jump18:;
    int64_t _44 = 0;
    _44 *= _37.d0;
    _44 += _43;
    double _45 = _37.data[_44];
    double _46;
    // Computing bound for a
    int64_t _47;
    // Computing bound for a
    int64_t _48 = 413;
    int64_t _49 = -_48;
    if (_49 > 0) 
    goto _jump19;
    fail_assertion("non-positive loop bound");
    _jump19:;
    _47 = 0;
    int64_t _50 = 0; // a
    _jump20:; // Begin body of loop
    bool _52 = true;
    bool _51 = _52;
    if (0 == _52)
    goto _jump21;
    bool _53 = false;
    _51 = _53;
    _jump21:;
    int64_t _54;
    if (!_51)
    goto _jump22;
    int64_t _55;
    // Computing bound for b
    int64_t _56 = 485;
    if (_56 > 0) 
    goto _jump23;
    fail_assertion("non-positive loop bound");
    _jump23:;
    _55 = 0;
    int64_t _57 = 0; // b
    _jump24:; // Begin body of loop
    int64_t _58 = 303;
    _55 += _58;
    _57++;
    if (_57 < _56)
    goto _jump24;
    // End body of loop
    _54 = _55;
    goto _jump25;
    _jump22:;
    bool _59 = true;
    int64_t _60;
    if (!_59)
    goto _jump26;
    _60 = _50;
    goto _jump27;
    _jump26:;
    _60 = _50;
    _jump27:;
    _54 = _60;
    _jump25:;
    _47 += _54;
    _50++;
    if (_50 < _49)
    goto _jump20;
    // End body of loop
    if (_47 > 0) 
    goto _jump28;
    fail_assertion("non-positive loop bound");
    _jump28:;
    _46 = 0;
    int64_t _61 = 0; // a
    _jump29:; // Begin body of loop
    double _62 = 18.0;
    _46 += _62;
    _61++;
    if (_61 < _47)
    goto _jump29;
    // End body of loop
    bool _63 = _45 == _46;
    bool _64 = _29 == _63;
    _1 = _64;
    goto _jump30;
    _jump1:;
    int64_t _65 = 231;
    int64_t _66 = 44;
    bool _67 = _65 > _66;
    _a1_bool _68;
    _68.d0 = 1;
    _68.data = jpl_alloc(sizeof(bool) * 1);
    _68.data[0] = _67;
    int64_t _69 = 418;
    if (_69 >= 0)
    goto _jump31;
    fail_assertion("negative array index");
    _jump31:;
    if (_69 < _68.d0)
    goto _jump32;
    fail_assertion("index too large");
    _jump32:;
    int64_t _70 = 0;
    _70 *= _68.d0;
    _70 += _69;
    bool _71 = _68.data[_70];
    bool _72;
    if (!_71)
    goto _jump33;
    bool _74 = true;
    bool _75;
    if (!_74)
    goto _jump34;
    bool _76 = false;
    _75 = _76;
    goto _jump35;
    _jump34:;
    bool _77 = true;
    _75 = _77;
    _jump35:;
    bool _73 = _75;
    if (0 != _75)
    goto _jump36;
    bool _78 = false;
    bool _79;
    if (!_78)
    goto _jump37;
    bool _80 = false;
    _79 = _80;
    goto _jump38;
    _jump37:;
    bool _81 = true;
    _79 = _81;
    _jump38:;
    _73 = _79;
    _jump36:;
    bool _82 = !_73;
    bool _83;
    if (!_82)
    goto _jump39;
    bool _84 = true;
    double _85;
    if (!_84)
    goto _jump40;
    double _86 = 63.0;
    double _87 = -_86;
    _85 = _87;
    goto _jump41;
    _jump40:;
    double _88 = 13.0;
    double _89 = 28.0;
    double _90 = _88 - _89;
    _85 = _90;
    _jump41:;
    double _91;
    // Computing bound for a
    int64_t _92 = 77;
    if (_92 > 0) 
    goto _jump42;
    fail_assertion("non-positive loop bound");
    _jump42:;
    // Computing bound for b
    int64_t _93 = 11;
    if (_93 > 0) 
    goto _jump43;
    fail_assertion("non-positive loop bound");
    _jump43:;
    // Computing bound for c
    int64_t _94 = 941;
    int64_t _95 = -_94;
    if (_95 > 0) 
    goto _jump44;
    fail_assertion("non-positive loop bound");
    _jump44:;
    _91 = 0;
    int64_t _96 = 0; // c
    int64_t _97 = 0; // b
    int64_t _98 = 0; // a
    _jump45:; // Begin body of loop
    double _99;
    // Computing bound for d
    if (_96 > 0) 
    goto _jump46;
    fail_assertion("non-positive loop bound");
    _jump46:;
    _99 = 0;
    int64_t _100 = 0; // d
    _jump47:; // Begin body of loop
    double _101 = 15.0;
    _99 += _101;
    _100++;
    if (_100 < _96)
    goto _jump47;
    // End body of loop
    _91 += _99;
    _96++;
    if (_96 < _95)
    goto _jump45;
    _96 = 0;
    _97++;
    if (_97 < _93)
    goto _jump45;
    _97 = 0;
    _98++;
    if (_98 < _92)
    goto _jump45;
    // End body of loop
    bool _102 = _85 >= _91;
    _83 = _102;
    goto _jump48;
    _jump39:;
    bool _103 = false;
    double _104;
    if (!_103)
    goto _jump49;
    double _105 = 11.0;
    double _106 = -_105;
    _104 = _106;
    goto _jump50;
    _jump49:;
    double _107 = 47.0;
    _104 = _107;
    _jump50:;
    double _108 = 32.0;
    double _109 = 90.0;
    double _110 = -_109;
    double _111 = _108 * _110;
    bool _112 = _104 == _111;
    _83 = _112;
    _jump48:;
    _72 = _83;
    goto _jump51;
    _jump33:;
    bool _113 = false;
    bool _114;
    if (!_113)
    goto _jump52;
    bool _116 = false;
    bool _115 = _116;
    if (0 != _116)
    goto _jump53;
    bool _117 = false;
    _115 = _117;
    _jump53:;
    _114 = _115;
    goto _jump54;
    _jump52:;
    bool _118 = false;
    bool _119 = !_118;
    _114 = _119;
    _jump54:;
    bool _120 = !_114;
    _72 = _120;
    _jump51:;
    bool _121 = !_72;
    _1 = _121;
    _jump30:;
    if (0 != _1)
    goto _jump55;
    fail_assertion("a");
    _jump55:;
    _a2_int64_t _122;
    // Computing bound for b
    bool _123 = false;
    bool _124 = false;
    bool _125 = _123 != _124;
    bool _126 = !_125;
    bool _127 = !_126;
    int64_t _128;
    if (!_127)
    goto _jump56;
    int64_t _129;
    // Computing bound for b
    int64_t _130 = 720;
    if (_130 > 0) 
    goto _jump57;
    fail_assertion("non-positive loop bound");
    _jump57:;
    _129 = 0;
    int64_t _131 = 0; // b
    _jump58:; // Begin body of loop
    int64_t _132 = 986;
    _129 += _132;
    _131++;
    if (_131 < _130)
    goto _jump58;
    // End body of loop
    int64_t _133 = 311;
    int64_t _134 = _129 + _133;
    _128 = _134;
    goto _jump59;
    _jump56:;
    int64_t _135;
    // Computing bound for b
    int64_t _136;
    // Computing bound for b
    int64_t _137 = 126;
    if (_137 > 0) 
    goto _jump60;
    fail_assertion("non-positive loop bound");
    _jump60:;
    // Computing bound for c
    int64_t _138 = 874;
    if (_138 > 0) 
    goto _jump61;
    fail_assertion("non-positive loop bound");
    _jump61:;
    // Computing bound for d
    int64_t _139 = 735;
    if (_139 > 0) 
    goto _jump62;
    fail_assertion("non-positive loop bound");
    _jump62:;
    _136 = 0;
    int64_t _140 = 0; // d
    int64_t _141 = 0; // c
    int64_t _142 = 0; // b
    _jump63:; // Begin body of loop
    _136 += _140;
    _140++;
    if (_140 < _139)
    goto _jump63;
    _140 = 0;
    _141++;
    if (_141 < _138)
    goto _jump63;
    _141 = 0;
    _142++;
    if (_142 < _137)
    goto _jump63;
    // End body of loop
    if (_136 > 0) 
    goto _jump64;
    fail_assertion("non-positive loop bound");
    _jump64:;
    // Computing bound for c
    int64_t _143 = 200;
    if (_143 > 0) 
    goto _jump65;
    fail_assertion("non-positive loop bound");
    _jump65:;
    // Computing bound for d
    int64_t _144 = 503;
    int64_t _145 = -_144;
    if (_145 > 0) 
    goto _jump66;
    fail_assertion("non-positive loop bound");
    _jump66:;
    _135 = 0;
    int64_t _146 = 0; // d
    int64_t _147 = 0; // c
    int64_t _148 = 0; // b
    _jump67:; // Begin body of loop
    _135 += _147;
    _146++;
    if (_146 < _145)
    goto _jump67;
    _146 = 0;
    _147++;
    if (_147 < _143)
    goto _jump67;
    _147 = 0;
    _148++;
    if (_148 < _136)
    goto _jump67;
    // End body of loop
    bool _149 = true;
    bool _150 = !_149;
    int64_t _151;
    if (!_150)
    goto _jump68;
    int64_t _152 = 587;
    _151 = _152;
    goto _jump69;
    _jump68:;
    int64_t _153 = 505;
    _151 = _153;
    _jump69:;
    int64_t _154 = _135 / _151;
    _128 = _154;
    _jump59:;
    int64_t _155;
    // Computing bound for b
    int64_t _156;
    // Computing bound for b
    int64_t _157;
    // Computing bound for b
    int64_t _158 = 467;
    if (_158 > 0) 
    goto _jump70;
    fail_assertion("non-positive loop bound");
    _jump70:;
    _157 = 0;
    int64_t _159 = 0; // b
    _jump71:; // Begin body of loop
    _157 += _159;
    _159++;
    if (_159 < _158)
    goto _jump71;
    // End body of loop
    if (_157 > 0) 
    goto _jump72;
    fail_assertion("non-positive loop bound");
    _jump72:;
    // Computing bound for c
    int64_t _160 = 102;
    int64_t _161 = -_160;
    if (_161 > 0) 
    goto _jump73;
    fail_assertion("non-positive loop bound");
    _jump73:;
    _156 = 0;
    int64_t _162 = 0; // c
    int64_t _163 = 0; // b
    _jump74:; // Begin body of loop
    _156 += _162;
    _162++;
    if (_162 < _161)
    goto _jump74;
    _162 = 0;
    _163++;
    if (_163 < _157)
    goto _jump74;
    // End body of loop
    if (_156 > 0) 
    goto _jump75;
    fail_assertion("non-positive loop bound");
    _jump75:;
    // Computing bound for c
    int64_t _164 = 350;
    int64_t _165 = -_164;
    if (_165 > 0) 
    goto _jump76;
    fail_assertion("non-positive loop bound");
    _jump76:;
    // Computing bound for d
    int64_t _166 = 541;
    int64_t _167 = 880;
    int64_t _168 = _166 / _167;
    int64_t _169 = 719;
    int64_t _170 = -_169;
    int64_t _171 = _168 * _170;
    if (_171 > 0) 
    goto _jump77;
    fail_assertion("non-positive loop bound");
    _jump77:;
    _155 = 0;
    int64_t _172 = 0; // d
    int64_t _173 = 0; // c
    int64_t _174 = 0; // b
    _jump78:; // Begin body of loop
    int64_t _175 = 784;
    _155 += _175;
    _172++;
    if (_172 < _171)
    goto _jump78;
    _172 = 0;
    _173++;
    if (_173 < _165)
    goto _jump78;
    _173 = 0;
    _174++;
    if (_174 < _156)
    goto _jump78;
    // End body of loop
    int64_t _176;
    // Computing bound for b
    int64_t _177 = 219;
    if (_177 > 0) 
    goto _jump79;
    fail_assertion("non-positive loop bound");
    _jump79:;
    // Computing bound for c
    int64_t _178 = 930;
    if (_178 > 0) 
    goto _jump80;
    fail_assertion("non-positive loop bound");
    _jump80:;
    _176 = 0;
    int64_t _179 = 0; // c
    int64_t _180 = 0; // b
    _jump81:; // Begin body of loop
    int64_t _181 = -_179;
    _176 += _181;
    _179++;
    if (_179 < _178)
    goto _jump81;
    _179 = 0;
    _180++;
    if (_180 < _177)
    goto _jump81;
    // End body of loop
    int64_t _182 = -_176;
    int64_t _183 = _155 + _182;
    int64_t _184 = _128 % _183;
    int64_t _185 = -_184;
    _122.d0 = _185;
    if (_185 > 0) 
    goto _jump82;
    fail_assertion("non-positive loop bound");
    _jump82:;
    // Computing bound for c
    bool _186 = true;
    int64_t _187;
    if (!_186)
    goto _jump83;
    bool _188 = true;
    bool _189 = !_188;
    bool _190 = !_189;
    int64_t _191;
    if (!_190)
    goto _jump84;
    int64_t _192 = 991;
    _191 = _192;
    goto _jump85;
    _jump84:;
    int64_t _193 = 426;
    _191 = _193;
    _jump85:;
    int64_t _194 = 589;
    int64_t _195 = 790;
    int64_t _196 = -_195;
    int64_t _197 = _194 * _196;
    int64_t _198 = -_197;
    int64_t _199 = _191 / _198;
    int64_t _200 = -_199;
    _187 = _200;
    goto _jump86;
    _jump83:;
    int64_t _201 = 933;
    int64_t _202 = -_201;
    int64_t _203 = -_202;
    _187 = _203;
    _jump86:;
    _122.d1 = _187;
    if (_187 > 0) 
    goto _jump87;
    fail_assertion("non-positive loop bound");
    _jump87:;
    // Computing total size of heap memory to allocate
    int64_t _204 = 1;
    _204 *= _185;
    _204 *= _187;
    _204 *= sizeof(int64_t);
    _122.data = jpl_alloc(_204);
    int64_t _205 = 0; // c
    int64_t _206 = 0; // b
    _jump88:; // Begin body of loop
    _a2_int64_t _207;
    // Computing bound for d
    int64_t _208 = 194;
    int64_t _209 = 811;
    int64_t _210 = _208 / _209;
    _207.d0 = _210;
    if (_210 > 0) 
    goto _jump89;
    fail_assertion("non-positive loop bound");
    _jump89:;
    // Computing bound for e
    _207.d1 = _205;
    if (_205 > 0) 
    goto _jump90;
    fail_assertion("non-positive loop bound");
    _jump90:;
    // Computing total size of heap memory to allocate
    int64_t _211 = 1;
    _211 *= _210;
    _211 *= _205;
    _211 *= sizeof(int64_t);
    _207.data = jpl_alloc(_211);
    int64_t _212 = 0; // e
    int64_t _213 = 0; // d
    _jump91:; // Begin body of loop
    int64_t _214 = 311;
    _a2_int64_t _215;
    // Computing bound for f
    int64_t _216 = 468;
    _215.d0 = _216;
    if (_216 > 0) 
    goto _jump92;
    fail_assertion("non-positive loop bound");
    _jump92:;
    // Computing bound for g
    _215.d1 = _212;
    if (_212 > 0) 
    goto _jump93;
    fail_assertion("non-positive loop bound");
    _jump93:;
    // Computing total size of heap memory to allocate
    int64_t _217 = 1;
    _217 *= _216;
    _217 *= _212;
    _217 *= sizeof(int64_t);
    _215.data = jpl_alloc(_217);
    int64_t _218 = 0; // g
    int64_t _219 = 0; // f
    _jump94:; // Begin body of loop
    int64_t _220 = 965;
    int64_t _221 = 0;
    _221 *= _215.d0;
    _221 += _219;
    _221 *= _215.d1;
    _221 += _218;
    _215.data[_221] = _220;
    _218++;
    if (_218 < _212)
    goto _jump94;
    _218 = 0;
    _219++;
    if (_219 < _216)
    goto _jump94;
    // End body of loop
    int64_t _222;
    // Computing bound for f
    if (_213 > 0) 
    goto _jump95;
    fail_assertion("non-positive loop bound");
    _jump95:;
    // Computing bound for g
    if (_212 > 0) 
    goto _jump96;
    fail_assertion("non-positive loop bound");
    _jump96:;
    // Computing bound for h
    if (_213 > 0) 
    goto _jump97;
    fail_assertion("non-positive loop bound");
    _jump97:;
    _222 = 0;
    int64_t _223 = 0; // h
    int64_t _224 = 0; // g
    int64_t _225 = 0; // f
    _jump98:; // Begin body of loop
    _222 += _223;
    _223++;
    if (_223 < _213)
    goto _jump98;
    _223 = 0;
    _224++;
    if (_224 < _212)
    goto _jump98;
    _224 = 0;
    _225++;
    if (_225 < _213)
    goto _jump98;
    // End body of loop
    int64_t _226;
    // Computing bound for f
    if (_213 > 0) 
    goto _jump99;
    fail_assertion("non-positive loop bound");
    _jump99:;
    // Computing bound for g
    if (_205 > 0) 
    goto _jump100;
    fail_assertion("non-positive loop bound");
    _jump100:;
    _226 = 0;
    int64_t _227 = 0; // g
    int64_t _228 = 0; // f
    _jump101:; // Begin body of loop
    _226 += _206;
    _227++;
    if (_227 < _205)
    goto _jump101;
    _227 = 0;
    _228++;
    if (_228 < _213)
    goto _jump101;
    // End body of loop
    if (_222 >= 0)
    goto _jump102;
    fail_assertion("negative array index");
    _jump102:;
    if (_222 < _215.d0)
    goto _jump103;
    fail_assertion("index too large");
    _jump103:;
    if (_226 >= 0)
    goto _jump104;
    fail_assertion("negative array index");
    _jump104:;
    if (_226 < _215.d1)
    goto _jump105;
    fail_assertion("index too large");
    _jump105:;
    int64_t _229 = 0;
    _229 *= _215.d0;
    _229 += _222;
    _229 *= _215.d1;
    _229 += _226;
    int64_t _230 = _215.data[_229];
    bool _231 = _214 == _230;
    int64_t _232;
    if (!_231)
    goto _jump106;
    int64_t _233 = 915;
    int64_t _234 = -_233;
    _232 = _234;
    goto _jump107;
    _jump106:;
    int64_t _235 = 220;
    _232 = _235;
    _jump107:;
    int64_t _236 = 0;
    _236 *= _207.d0;
    _236 += _213;
    _236 *= _207.d1;
    _236 += _212;
    _207.data[_236] = _232;
    _212++;
    if (_212 < _205)
    goto _jump91;
    _212 = 0;
    _213++;
    if (_213 < _210)
    goto _jump91;
    // End body of loop
    int64_t _237;
    // Computing bound for d
    if (_206 > 0) 
    goto _jump108;
    fail_assertion("non-positive loop bound");
    _jump108:;
    // Computing bound for e
    bool _238 = true;
    int64_t _239;
    if (!_238)
    goto _jump109;
    _239 = _205;
    goto _jump110;
    _jump109:;
    int64_t _240 = 475;
    _239 = _240;
    _jump110:;
    int64_t _241;
    // Computing bound for d
    if (_205 > 0) 
    goto _jump111;
    fail_assertion("non-positive loop bound");
    _jump111:;
    // Computing bound for e
    int64_t _242 = -_205;
    if (_242 > 0) 
    goto _jump112;
    fail_assertion("non-positive loop bound");
    _jump112:;
    _241 = 0;
    int64_t _243 = 0; // e
    int64_t _244 = 0; // d
    _jump113:; // Begin body of loop
    int64_t _245 = 665;
    _241 += _245;
    _243++;
    if (_243 < _242)
    goto _jump113;
    _243 = 0;
    _244++;
    if (_244 < _205)
    goto _jump113;
    // End body of loop
    bool _246 = false;
    int64_t _247;
    if (!_246)
    goto _jump114;
    int64_t _248;
    // Computing bound for d
    int64_t _249 = 273;
    if (_249 > 0) 
    goto _jump115;
    fail_assertion("non-positive loop bound");
    _jump115:;
    // Computing bound for e
    int64_t _250 = 284;
    if (_250 > 0) 
    goto _jump116;
    fail_assertion("non-positive loop bound");
    _jump116:;
    _248 = 0;
    int64_t _251 = 0; // e
    int64_t _252 = 0; // d
    _jump117:; // Begin body of loop
    _248 += _252;
    _251++;
    if (_251 < _250)
    goto _jump117;
    _251 = 0;
    _252++;
    if (_252 < _249)
    goto _jump117;
    // End body of loop
    _247 = _248;
    goto _jump118;
    _jump114:;
    int64_t _253 = 359;
    _247 = _253;
    _jump118:;
    int64_t _254 = _241 - _247;
    int64_t _255 = _239 + _254;
    if (_255 > 0) 
    goto _jump119;
    fail_assertion("non-positive loop bound");
    _jump119:;
    _237 = 0;
    int64_t _256 = 0; // e
    int64_t _257 = 0; // d
    _jump120:; // Begin body of loop
    _a1_int64_t _258;
    _258.d0 = 2;
    _258.data = jpl_alloc(sizeof(int64_t) * 2);
    _258.data[0] = _257;
    _258.data[1] = _257;
    if (_256 >= 0)
    goto _jump121;
    fail_assertion("negative array index");
    _jump121:;
    if (_256 < _258.d0)
    goto _jump122;
    fail_assertion("index too large");
    _jump122:;
    int64_t _259 = 0;
    _259 *= _258.d0;
    _259 += _256;
    int64_t _260 = _258.data[_259];
    int64_t _261 = 73;
    int64_t _262 = _260 + _261;
    _237 += _262;
    _256++;
    if (_256 < _255)
    goto _jump120;
    _256 = 0;
    _257++;
    if (_257 < _206)
    goto _jump120;
    // End body of loop
    if (_237 >= 0)
    goto _jump123;
    fail_assertion("negative array index");
    _jump123:;
    if (_237 < _207.d0)
    goto _jump124;
    fail_assertion("index too large");
    _jump124:;
    if (_206 >= 0)
    goto _jump125;
    fail_assertion("negative array index");
    _jump125:;
    if (_206 < _207.d1)
    goto _jump126;
    fail_assertion("index too large");
    _jump126:;
    int64_t _263 = 0;
    _263 *= _207.d0;
    _263 += _237;
    _263 *= _207.d1;
    _263 += _206;
    int64_t _264 = _207.data[_263];
    int64_t _265 = 0;
    _265 *= _122.d0;
    _265 += _206;
    _265 *= _122.d1;
    _265 += _205;
    _122.data[_265] = _264;
    _205++;
    if (_205 < _187)
    goto _jump88;
    _205 = 0;
    _206++;
    if (_206 < _185)
    goto _jump88;
    // End body of loop
    _a2_rgba _266 = read_image("e.png");
    int64_t _267;
    // Computing bound for j
    int64_t _268 = 152;
    if (_268 > 0) 
    goto _jump1087;
    fail_assertion("non-positive loop bound");
    _jump1087:;
    // Computing bound for k
    int64_t _269 = 333;
    int64_t _270 = -_269;
    int64_t _271 = 454;
    _a1_int64_t _272;
    _272.d0 = 3;
    _272.data = jpl_alloc(sizeof(int64_t) * 3);
    _272.data[0] = _270;
    _272.data[1] = _122.d0;
    _272.data[2] = _271;
    if (_122.d0 >= 0)
    goto _jump1088;
    fail_assertion("negative array index");
    _jump1088:;
    if (_122.d0 < _272.d0)
    goto _jump1089;
    fail_assertion("index too large");
    _jump1089:;
    int64_t _273 = 0;
    _273 *= _272.d0;
    _273 += _122.d0;
    int64_t _274 = _272.data[_273];
    int64_t _275 = 930;
    int64_t _276 = _274 / _275;
    if (_276 > 0) 
    goto _jump1090;
    fail_assertion("non-positive loop bound");
    _jump1090:;
    _267 = 0;
    int64_t _277 = 0; // k
    int64_t _278 = 0; // j
    _jump1091:; // Begin body of loop
    int64_t _279 = -_122.d0;
    _267 += _279;
    _277++;
    if (_277 < _276)
    goto _jump1091;
    _277 = 0;
    _278++;
    if (_278 < _268)
    goto _jump1091;
    // End body of loop
    _a2_int64_t _280;
    // Computing bound for k
    int64_t _281 = 653;
    _280.d0 = _281;
    if (_281 > 0) 
    goto _jump1092;
    fail_assertion("non-positive loop bound");
    _jump1092:;
    // Computing bound for l
    int64_t _282 = 303;
    int64_t _283 = -_282;
    _280.d1 = _283;
    if (_283 > 0) 
    goto _jump1093;
    fail_assertion("non-positive loop bound");
    _jump1093:;
    // Computing total size of heap memory to allocate
    int64_t _284 = 1;
    _284 *= _281;
    _284 *= _283;
    _284 *= sizeof(int64_t);
    _280.data = jpl_alloc(_284);
    int64_t _285 = 0; // l
    int64_t _286 = 0; // k
    _jump1094:; // Begin body of loop
    int64_t _287 = 0;
    _287 *= _280.d0;
    _287 += _286;
    _287 *= _280.d1;
    _287 += _285;
    _280.data[_287] = _285;
    _285++;
    if (_285 < _283)
    goto _jump1094;
    _285 = 0;
    _286++;
    if (_286 < _281)
    goto _jump1094;
    // End body of loop
    int64_t _288;
    // Computing bound for k
    if (_267 > 0) 
    goto _jump1095;
    fail_assertion("non-positive loop bound");
    _jump1095:;
    _288 = 0;
    int64_t _289 = 0; // k
    _jump1096:; // Begin body of loop
    int64_t _290;
    // Computing bound for l
    int64_t _291 = 358;
    if (_291 > 0) 
    goto _jump1097;
    fail_assertion("non-positive loop bound");
    _jump1097:;
    // Computing bound for m
    if (_122.d1 > 0) 
    goto _jump1098;
    fail_assertion("non-positive loop bound");
    _jump1098:;
    _290 = 0;
    int64_t _292 = 0; // m
    int64_t _293 = 0; // l
    _jump1099:; // Begin body of loop
    _290 += _292;
    _292++;
    if (_292 < _122.d1)
    goto _jump1099;
    _292 = 0;
    _293++;
    if (_293 < _291)
    goto _jump1099;
    // End body of loop
    _288 += _290;
    _289++;
    if (_289 < _267)
    goto _jump1096;
    // End body of loop
    if (_288 >= 0)
    goto _jump1100;
    fail_assertion("negative array index");
    _jump1100:;
    if (_288 < _280.d0)
    goto _jump1101;
    fail_assertion("index too large");
    _jump1101:;
    if (_122.d0 >= 0)
    goto _jump1102;
    fail_assertion("negative array index");
    _jump1102:;
    if (_122.d0 < _280.d1)
    goto _jump1103;
    fail_assertion("index too large");
    _jump1103:;
    int64_t _294 = 0;
    _294 *= _280.d0;
    _294 += _288;
    _294 *= _280.d1;
    _294 += _122.d0;
    int64_t _295 = _280.data[_294];
    bool _296 = _295 > _122.d0;
    bool _297;
    if (!_296)
    goto _jump1104;
    bool _298 = _122.d0 >= _122.d0;
    _297 = _298;
    goto _jump1105;
    _jump1104:;
    bool _299 = false;
    bool _300 = !_299;
    _297 = _300;
    _jump1105:;
    bool _301 = true;
    bool _302;
    if (!_301)
    goto _jump1106;
    bool _303 = false;
    bool _304 = !_303;
    _302 = _304;
    goto _jump1107;
    _jump1106:;
    int64_t _305 = -_122.d0;
    bool _306 = _122.d0 != _305;
    _302 = _306;
    _jump1107:;
    bool _307 = !_302;
    bool _308 = _297 != _307;
    _a2_rgba _309 = read_image("r.png");
    int64_t s = _309.d0;
    int64_t t = _309.d1;
    _a3_int64_t _310;
    if (!_308)
    goto _jump2054;
    _a3_int64_t _311;
    // Computing bound for v
    _311.d0 = _122.d0;
    if (_122.d0 > 0) 
    goto _jump2055;
    fail_assertion("non-positive loop bound");
    _jump2055:;
    // Computing bound for w
    _311.d1 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump2056;
    fail_assertion("non-positive loop bound");
    _jump2056:;
    // Computing bound for x
    int64_t _312;
    // Computing bound for v
    int64_t _313 = n();
    int64_t _314 = _313 - _267;
    if (_314 > 0) 
    goto _jump2057;
    fail_assertion("non-positive loop bound");
    _jump2057:;
    _312 = 0;
    int64_t _315 = 0; // v
    _jump2058:; // Begin body of loop
    _312 += _266.d1;
    _315++;
    if (_315 < _314)
    goto _jump2058;
    // End body of loop
    int64_t _316 = _312 / _267;
    _311.d2 = _316;
    if (_316 > 0) 
    goto _jump2059;
    fail_assertion("non-positive loop bound");
    _jump2059:;
    // Computing total size of heap memory to allocate
    int64_t _317 = 1;
    _317 *= _122.d0;
    _317 *= _309.d1;
    _317 *= _316;
    _317 *= sizeof(int64_t);
    _311.data = jpl_alloc(_317);
    int64_t _318 = 0; // x
    int64_t _319 = 0; // w
    int64_t _320 = 0; // v
    _jump2060:; // Begin body of loop
    int64_t _321 = 0;
    _321 *= _311.d0;
    _321 += _320;
    _321 *= _311.d1;
    _321 += _319;
    _321 *= _311.d2;
    _321 += _318;
    _311.data[_321] = _319;
    _318++;
    if (_318 < _316)
    goto _jump2060;
    _318 = 0;
    _319++;
    if (_319 < _309.d1)
    goto _jump2060;
    _319 = 0;
    _320++;
    if (_320 < _122.d0)
    goto _jump2060;
    // End body of loop
    _310 = _311;
    goto _jump2061;
    _jump2054:;
    _a2__a1__a3_int64_t _322;
    // Computing bound for v
    int64_t _323 = 341;
    int64_t _324 = _323 * _309.d1;
    _322.d0 = _324;
    if (_324 > 0) 
    goto _jump2062;
    fail_assertion("non-positive loop bound");
    _jump2062:;
    // Computing bound for w
    _a2_int64_t _325;
    // Computing bound for v
    _325.d0 = _122.d0;
    if (_122.d0 > 0) 
    goto _jump2063;
    fail_assertion("non-positive loop bound");
    _jump2063:;
    // Computing bound for w
    _325.d1 = _266.d0;
    if (_266.d0 > 0) 
    goto _jump2064;
    fail_assertion("non-positive loop bound");
    _jump2064:;
    // Computing total size of heap memory to allocate
    int64_t _326 = 1;
    _326 *= _122.d0;
    _326 *= _266.d0;
    _326 *= sizeof(int64_t);
    _325.data = jpl_alloc(_326);
    int64_t _327 = 0; // w
    int64_t _328 = 0; // v
    _jump2065:; // Begin body of loop
    int64_t _329 = 0;
    _329 *= _325.d0;
    _329 += _328;
    _329 *= _325.d1;
    _329 += _327;
    _325.data[_329] = _309.d0;
    _327++;
    if (_327 < _266.d0)
    goto _jump2065;
    _327 = 0;
    _328++;
    if (_328 < _122.d0)
    goto _jump2065;
    // End body of loop
    int64_t _330 = -_309.d0;
    int64_t _331 = n();
    if (_330 >= 0)
    goto _jump2066;
    fail_assertion("negative array index");
    _jump2066:;
    if (_330 < _122.d0)
    goto _jump2067;
    fail_assertion("index too large");
    _jump2067:;
    if (_331 >= 0)
    goto _jump2068;
    fail_assertion("negative array index");
    _jump2068:;
    if (_331 < _122.d1)
    goto _jump2069;
    fail_assertion("index too large");
    _jump2069:;
    int64_t _332 = 0;
    _332 *= _122.d0;
    _332 += _330;
    _332 *= _122.d1;
    _332 += _331;
    int64_t _333 = _122.data[_332];
    if (_267 >= 0)
    goto _jump2070;
    fail_assertion("negative array index");
    _jump2070:;
    if (_267 < _325.d0)
    goto _jump2071;
    fail_assertion("index too large");
    _jump2071:;
    if (_333 >= 0)
    goto _jump2072;
    fail_assertion("negative array index");
    _jump2072:;
    if (_333 < _325.d1)
    goto _jump2073;
    fail_assertion("index too large");
    _jump2073:;
    int64_t _334 = 0;
    _334 *= _325.d0;
    _334 += _267;
    _334 *= _325.d1;
    _334 += _333;
    int64_t _335 = _325.data[_334];
    _322.d1 = _335;
    if (_335 > 0) 
    goto _jump2074;
    fail_assertion("non-positive loop bound");
    _jump2074:;
    // Computing total size of heap memory to allocate
    int64_t _336 = 1;
    _336 *= _324;
    _336 *= _335;
    _336 *= sizeof(_a1__a3_int64_t);
    _322.data = jpl_alloc(_336);
    int64_t _337 = 0; // w
    int64_t _338 = 0; // v
    _jump2075:; // Begin body of loop
    _a3_int64_t _339;
    if (!_308)
    goto _jump2076;
    _a3_int64_t _340;
    // Computing bound for x
    _340.d0 = _267;
    if (_267 > 0) 
    goto _jump2077;
    fail_assertion("non-positive loop bound");
    _jump2077:;
    // Computing bound for y
    _340.d1 = _337;
    if (_337 > 0) 
    goto _jump2078;
    fail_assertion("non-positive loop bound");
    _jump2078:;
    // Computing bound for z
    _340.d2 = _122.d0;
    if (_122.d0 > 0) 
    goto _jump2079;
    fail_assertion("non-positive loop bound");
    _jump2079:;
    // Computing total size of heap memory to allocate
    int64_t _341 = 1;
    _341 *= _267;
    _341 *= _337;
    _341 *= _122.d0;
    _341 *= sizeof(int64_t);
    _340.data = jpl_alloc(_341);
    int64_t _342 = 0; // z
    int64_t _343 = 0; // y
    int64_t _344 = 0; // x
    _jump2080:; // Begin body of loop
    int64_t _345 = 0;
    _345 *= _340.d0;
    _345 += _344;
    _345 *= _340.d1;
    _345 += _343;
    _345 *= _340.d2;
    _345 += _342;
    _340.data[_345] = _266.d1;
    _342++;
    if (_342 < _122.d0)
    goto _jump2080;
    _342 = 0;
    _343++;
    if (_343 < _337)
    goto _jump2080;
    _343 = 0;
    _344++;
    if (_344 < _267)
    goto _jump2080;
    // End body of loop
    _339 = _340;
    goto _jump2081;
    _jump2076:;
    _a3_int64_t _346;
    // Computing bound for x
    _346.d0 = _338;
    if (_338 > 0) 
    goto _jump2082;
    fail_assertion("non-positive loop bound");
    _jump2082:;
    // Computing bound for y
    _346.d1 = _267;
    if (_267 > 0) 
    goto _jump2083;
    fail_assertion("non-positive loop bound");
    _jump2083:;
    // Computing bound for z
    _346.d2 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump2084;
    fail_assertion("non-positive loop bound");
    _jump2084:;
    // Computing total size of heap memory to allocate
    int64_t _347 = 1;
    _347 *= _338;
    _347 *= _267;
    _347 *= _309.d1;
    _347 *= sizeof(int64_t);
    _346.data = jpl_alloc(_347);
    int64_t _348 = 0; // z
    int64_t _349 = 0; // y
    int64_t _350 = 0; // x
    _jump2085:; // Begin body of loop
    int64_t _351 = 0;
    _351 *= _346.d0;
    _351 += _350;
    _351 *= _346.d1;
    _351 += _349;
    _351 *= _346.d2;
    _351 += _348;
    _346.data[_351] = _349;
    _348++;
    if (_348 < _309.d1)
    goto _jump2085;
    _348 = 0;
    _349++;
    if (_349 < _267)
    goto _jump2085;
    _349 = 0;
    _350++;
    if (_350 < _338)
    goto _jump2085;
    // End body of loop
    _339 = _346;
    _jump2081:;
    _a3_int64_t _352;
    // Computing bound for x
    int64_t _353 = n();
    _352.d0 = _353;
    if (_353 > 0) 
    goto _jump2086;
    fail_assertion("non-positive loop bound");
    _jump2086:;
    // Computing bound for y
    if (_309.d0 >= 0)
    goto _jump2087;
    fail_assertion("negative array index");
    _jump2087:;
    if (_309.d0 < _122.d0)
    goto _jump2088;
    fail_assertion("index too large");
    _jump2088:;
    if (_309.d0 >= 0)
    goto _jump2089;
    fail_assertion("negative array index");
    _jump2089:;
    if (_309.d0 < _122.d1)
    goto _jump2090;
    fail_assertion("index too large");
    _jump2090:;
    int64_t _354 = 0;
    _354 *= _122.d0;
    _354 += _309.d0;
    _354 *= _122.d1;
    _354 += _309.d0;
    int64_t _355 = _122.data[_354];
    _352.d1 = _355;
    if (_355 > 0) 
    goto _jump2091;
    fail_assertion("non-positive loop bound");
    _jump2091:;
    // Computing bound for z
    _352.d2 = _338;
    if (_338 > 0) 
    goto _jump2092;
    fail_assertion("non-positive loop bound");
    _jump2092:;
    // Computing total size of heap memory to allocate
    int64_t _356 = 1;
    _356 *= _353;
    _356 *= _355;
    _356 *= _338;
    _356 *= sizeof(int64_t);
    _352.data = jpl_alloc(_356);
    int64_t _357 = 0; // z
    int64_t _358 = 0; // y
    int64_t _359 = 0; // x
    _jump2093:; // Begin body of loop
    int64_t _360 = n();
    int64_t _361 = 0;
    _361 *= _352.d0;
    _361 += _359;
    _361 *= _352.d1;
    _361 += _358;
    _361 *= _352.d2;
    _361 += _357;
    _352.data[_361] = _360;
    _357++;
    if (_357 < _338)
    goto _jump2093;
    _357 = 0;
    _358++;
    if (_358 < _355)
    goto _jump2093;
    _358 = 0;
    _359++;
    if (_359 < _353)
    goto _jump2093;
    // End body of loop
    _a1__a3_int64_t _362;
    _362.d0 = 2;
    _362.data = jpl_alloc(sizeof(_a3_int64_t) * 2);
    _362.data[0] = _339;
    _362.data[1] = _352;
    int64_t _363 = 0;
    _363 *= _322.d0;
    _363 += _338;
    _363 *= _322.d1;
    _363 += _337;
    _322.data[_363] = _362;
    _337++;
    if (_337 < _335)
    goto _jump2075;
    _337 = 0;
    _338++;
    if (_338 < _324)
    goto _jump2075;
    // End body of loop
    if (_266.d1 >= 0)
    goto _jump2094;
    fail_assertion("negative array index");
    _jump2094:;
    if (_266.d1 < _122.d0)
    goto _jump2095;
    fail_assertion("index too large");
    _jump2095:;
    if (_266.d1 >= 0)
    goto _jump2096;
    fail_assertion("negative array index");
    _jump2096:;
    if (_266.d1 < _122.d1)
    goto _jump2097;
    fail_assertion("index too large");
    _jump2097:;
    int64_t _364 = 0;
    _364 *= _122.d0;
    _364 += _266.d1;
    _364 *= _122.d1;
    _364 += _266.d1;
    int64_t _365 = _122.data[_364];
    if (_365 >= 0)
    goto _jump2098;
    fail_assertion("negative array index");
    _jump2098:;
    if (_365 < _322.d0)
    goto _jump2099;
    fail_assertion("index too large");
    _jump2099:;
    if (_309.d0 >= 0)
    goto _jump2100;
    fail_assertion("negative array index");
    _jump2100:;
    if (_309.d0 < _322.d1)
    goto _jump2101;
    fail_assertion("index too large");
    _jump2101:;
    int64_t _366 = 0;
    _366 *= _322.d0;
    _366 += _365;
    _366 *= _322.d1;
    _366 += _309.d0;
    _a1__a3_int64_t _367 = _322.data[_366];
    int64_t _368 = n();
    if (_368 >= 0)
    goto _jump2102;
    fail_assertion("negative array index");
    _jump2102:;
    if (_368 < _367.d0)
    goto _jump2103;
    fail_assertion("index too large");
    _jump2103:;
    int64_t _369 = 0;
    _369 *= _367.d0;
    _369 += _368;
    _a3_int64_t _370 = _367.data[_369];
    _310 = _370;
    _jump2061:;
    double _371 = 59.0;
    bool _373 = _122.d0 == _122.d1;
    bool _372 = _373;
    if (0 == _373)
    goto _jump2104;
    _372 = _308;
    _jump2104:;
    bool _374 = _308 != _372;
    bool _375;
    if (!_374)
    goto _jump2105;
    int64_t _376 = 886;
    int64_t _377;
    // Computing bound for A
    if (_309.d0 > 0) 
    goto _jump2106;
    fail_assertion("non-positive loop bound");
    _jump2106:;
    // Computing bound for B
    _a1_bool _378;
    // Computing bound for A
    _378.d0 = _310.d0;
    if (_310.d0 > 0) 
    goto _jump2107;
    fail_assertion("non-positive loop bound");
    _jump2107:;
    // Computing total size of heap memory to allocate
    int64_t _379 = 1;
    _379 *= _310.d0;
    _379 *= sizeof(bool);
    _378.data = jpl_alloc(_379);
    int64_t _380 = 0; // A
    _jump2108:; // Begin body of loop
    bool _381 = false;
    int64_t _382 = 0;
    _382 *= _378.d0;
    _382 += _380;
    _378.data[_382] = _381;
    _380++;
    if (_380 < _310.d0)
    goto _jump2108;
    // End body of loop
    int64_t _383 = 691;
    if (_383 >= 0)
    goto _jump2109;
    fail_assertion("negative array index");
    _jump2109:;
    if (_383 < _378.d0)
    goto _jump2110;
    fail_assertion("index too large");
    _jump2110:;
    int64_t _384 = 0;
    _384 *= _378.d0;
    _384 += _383;
    bool _385 = _378.data[_384];
    int64_t _386;
    if (!_385)
    goto _jump2111;
    int64_t _387 = n();
    int64_t _388 = _387 % _309.d0;
    _386 = _388;
    goto _jump2112;
    _jump2111:;
    int64_t _389 = n();
    _386 = _389;
    _jump2112:;
    if (_386 > 0) 
    goto _jump2113;
    fail_assertion("non-positive loop bound");
    _jump2113:;
    _377 = 0;
    int64_t _390 = 0; // B
    int64_t _391 = 0; // A
    _jump2114:; // Begin body of loop
    _377 += _309.d1;
    _390++;
    if (_390 < _386)
    goto _jump2114;
    _390 = 0;
    _391++;
    if (_391 < _309.d0)
    goto _jump2114;
    // End body of loop
    bool _392 = _376 >= _377;
    _375 = _392;
    goto _jump2115;
    _jump2105:;
    bool _393 = true;
    double _394;
    if (!_393)
    goto _jump2116;
    double _395 = g(_308);
    bool _396 = _371 != _371;
    double _397 = g(_396);
    double _398 = _395 + _397;
    _394 = _398;
    goto _jump2117;
    _jump2116:;
    _394 = _371;
    _jump2117:;
    double _399;
    // Computing bound for A
    int64_t _400 = n();
    if (_400 > 0) 
    goto _jump2118;
    fail_assertion("non-positive loop bound");
    _jump2118:;
    // Computing bound for B
    if (_266.d1 > 0) 
    goto _jump2119;
    fail_assertion("non-positive loop bound");
    _jump2119:;
    _399 = 0;
    int64_t _401 = 0; // B
    int64_t _402 = 0; // A
    _jump2120:; // Begin body of loop
    double _403 = 27.0;
    _399 += _403;
    _401++;
    if (_401 < _266.d1)
    goto _jump2120;
    _401 = 0;
    _402++;
    if (_402 < _400)
    goto _jump2120;
    // End body of loop
    double _404 = 1.0;
    bool _405 = false;
    double _406 = g(_405);
    double _407 = 90.0;
    rgba _408 = { _399, _404, _406, _407 };
    double _409 = _408.r;
    bool _410 = _394 > _409;
    _375 = _410;
    _jump2115:;
    _a3_int64_t _411;
    if (!_375)
    goto _jump2121;
    _a3_int64_t _412;
    // Computing bound for A
    _412.d0 = _310.d2;
    if (_310.d2 > 0) 
    goto _jump2122;
    fail_assertion("non-positive loop bound");
    _jump2122:;
    // Computing bound for B
    _a3_int64_t _413;
    // Computing bound for A
    _413.d0 = _266.d1;
    if (_266.d1 > 0) 
    goto _jump2123;
    fail_assertion("non-positive loop bound");
    _jump2123:;
    // Computing bound for B
    _413.d1 = _310.d1;
    if (_310.d1 > 0) 
    goto _jump2124;
    fail_assertion("non-positive loop bound");
    _jump2124:;
    // Computing bound for C
    _413.d2 = _267;
    if (_267 > 0) 
    goto _jump2125;
    fail_assertion("non-positive loop bound");
    _jump2125:;
    // Computing total size of heap memory to allocate
    int64_t _414 = 1;
    _414 *= _266.d1;
    _414 *= _310.d1;
    _414 *= _267;
    _414 *= sizeof(int64_t);
    _413.data = jpl_alloc(_414);
    int64_t _415 = 0; // C
    int64_t _416 = 0; // B
    int64_t _417 = 0; // A
    _jump2126:; // Begin body of loop
    int64_t _418 = 0;
    _418 *= _413.d0;
    _418 += _417;
    _418 *= _413.d1;
    _418 += _416;
    _418 *= _413.d2;
    _418 += _415;
    _413.data[_418] = _122.d1;
    _415++;
    if (_415 < _267)
    goto _jump2126;
    _415 = 0;
    _416++;
    if (_416 < _310.d1)
    goto _jump2126;
    _416 = 0;
    _417++;
    if (_417 < _266.d1)
    goto _jump2126;
    // End body of loop
    _a3_bool _419;
    // Computing bound for A
    bool _420 = false;
    int64_t _421;
    if (!_420)
    goto _jump2127;
    _421 = _267;
    goto _jump2128;
    _jump2127:;
    _421 = _122.d1;
    _jump2128:;
    _419.d0 = _421;
    if (_421 > 0) 
    goto _jump2129;
    fail_assertion("non-positive loop bound");
    _jump2129:;
    // Computing bound for B
    int64_t _422 = 693;
    _419.d1 = _422;
    if (_422 > 0) 
    goto _jump2130;
    fail_assertion("non-positive loop bound");
    _jump2130:;
    // Computing bound for C
    int64_t _423;
    // Computing bound for A
    if (_122.d1 > 0) 
    goto _jump2131;
    fail_assertion("non-positive loop bound");
    _jump2131:;
    _423 = 0;
    int64_t _424 = 0; // A
    _jump2132:; // Begin body of loop
    int64_t _425 = n();
    _423 += _425;
    _424++;
    if (_424 < _122.d1)
    goto _jump2132;
    // End body of loop
    _419.d2 = _423;
    if (_423 > 0) 
    goto _jump2133;
    fail_assertion("non-positive loop bound");
    _jump2133:;
    // Computing total size of heap memory to allocate
    int64_t _426 = 1;
    _426 *= _421;
    _426 *= _422;
    _426 *= _423;
    _426 *= sizeof(bool);
    _419.data = jpl_alloc(_426);
    int64_t _427 = 0; // C
    int64_t _428 = 0; // B
    int64_t _429 = 0; // A
    _jump2134:; // Begin body of loop
    bool _430 = _371 != _371;
    int64_t _431 = 0;
    _431 *= _419.d0;
    _431 += _429;
    _431 *= _419.d1;
    _431 += _428;
    _431 *= _419.d2;
    _431 += _427;
    _419.data[_431] = _430;
    _427++;
    if (_427 < _423)
    goto _jump2134;
    _427 = 0;
    _428++;
    if (_428 < _422)
    goto _jump2134;
    _428 = 0;
    _429++;
    if (_429 < _421)
    goto _jump2134;
    // End body of loop
    int64_t _432;
    // Computing bound for A
    if (_309.d0 > 0) 
    goto _jump2135;
    fail_assertion("non-positive loop bound");
    _jump2135:;
    // Computing bound for B
    if (_267 > 0) 
    goto _jump2136;
    fail_assertion("non-positive loop bound");
    _jump2136:;
    // Computing bound for C
    if (_309.d0 > 0) 
    goto _jump2137;
    fail_assertion("non-positive loop bound");
    _jump2137:;
    _432 = 0;
    int64_t _433 = 0; // C
    int64_t _434 = 0; // B
    int64_t _435 = 0; // A
    _jump2138:; // Begin body of loop
    _432 += _266.d1;
    _433++;
    if (_433 < _309.d0)
    goto _jump2138;
    _433 = 0;
    _434++;
    if (_434 < _267)
    goto _jump2138;
    _434 = 0;
    _435++;
    if (_435 < _309.d0)
    goto _jump2138;
    // End body of loop
    if (_432 >= 0)
    goto _jump2139;
    fail_assertion("negative array index");
    _jump2139:;
    if (_432 < _419.d0)
    goto _jump2140;
    fail_assertion("index too large");
    _jump2140:;
    if (_310.d1 >= 0)
    goto _jump2141;
    fail_assertion("negative array index");
    _jump2141:;
    if (_310.d1 < _419.d1)
    goto _jump2142;
    fail_assertion("index too large");
    _jump2142:;
    if (_122.d1 >= 0)
    goto _jump2143;
    fail_assertion("negative array index");
    _jump2143:;
    if (_122.d1 < _419.d2)
    goto _jump2144;
    fail_assertion("index too large");
    _jump2144:;
    int64_t _436 = 0;
    _436 *= _419.d0;
    _436 += _432;
    _436 *= _419.d1;
    _436 += _310.d1;
    _436 *= _419.d2;
    _436 += _122.d1;
    bool _437 = _419.data[_436];
    int64_t _438;
    if (!_437)
    goto _jump2145;
    _a3_void_t _439;
    // Computing bound for A
    _439.d0 = _310.d1;
    if (_310.d1 > 0) 
    goto _jump2146;
    fail_assertion("non-positive loop bound");
    _jump2146:;
    // Computing bound for B
    _439.d1 = _310.d0;
    if (_310.d0 > 0) 
    goto _jump2147;
    fail_assertion("non-positive loop bound");
    _jump2147:;
    // Computing bound for C
    int64_t _440;
    // Computing bound for A
    int64_t _441 = n();
    if (_441 > 0) 
    goto _jump2148;
    fail_assertion("non-positive loop bound");
    _jump2148:;
    // Computing bound for B
    if (_122.d1 > 0) 
    goto _jump2149;
    fail_assertion("non-positive loop bound");
    _jump2149:;
    _440 = 0;
    int64_t _442 = 0; // B
    int64_t _443 = 0; // A
    _jump2150:; // Begin body of loop
    _440 += _266.d0;
    _442++;
    if (_442 < _122.d1)
    goto _jump2150;
    _442 = 0;
    _443++;
    if (_443 < _441)
    goto _jump2150;
    // End body of loop
    _439.d2 = _440;
    if (_440 > 0) 
    goto _jump2151;
    fail_assertion("non-positive loop bound");
    _jump2151:;
    // Computing total size of heap memory to allocate
    int64_t _444 = 1;
    _444 *= _310.d1;
    _444 *= _310.d0;
    _444 *= _440;
    _444 *= sizeof(void_t);
    _439.data = jpl_alloc(_444);
    int64_t _445 = 0; // C
    int64_t _446 = 0; // B
    int64_t _447 = 0; // A
    _jump2152:; // Begin body of loop
    a _448 = h();
    void_t _449 = _448.a;
    int64_t _450 = 0;
    _450 *= _439.d0;
    _450 += _447;
    _450 *= _439.d1;
    _450 += _446;
    _450 *= _439.d2;
    _450 += _445;
    _439.data[_450] = _449;
    _445++;
    if (_445 < _440)
    goto _jump2152;
    _445 = 0;
    _446++;
    if (_446 < _310.d0)
    goto _jump2152;
    _446 = 0;
    _447++;
    if (_447 < _310.d1)
    goto _jump2152;
    // End body of loop
    bool _451 = true;
    bool _452;
    if (!_451)
    goto _jump2153;
    bool _453 = _267 >= _122.d0;
    _452 = _453;
    goto _jump2154;
    _jump2153:;
    bool _455 = false;
    bool _454 = _455;
    if (0 != _455)
    goto _jump2155;
    _454 = _308;
    _jump2155:;
    _452 = _454;
    _jump2154:;
    int64_t _456 = l(_266.d1, _439, _452);
    _438 = _456;
    goto _jump2156;
    _jump2145:;
    _438 = _309.d1;
    _jump2156:;
    int64_t _457;
    // Computing bound for A
    if (_266.d1 > 0) 
    goto _jump2157;
    fail_assertion("non-positive loop bound");
    _jump2157:;
    _457 = 0;
    int64_t _458 = 0; // A
    _jump2158:; // Begin body of loop
    _457 += _309.d1;
    _458++;
    if (_458 < _266.d1)
    goto _jump2158;
    // End body of loop
    double _459 = 65.0;
    double _460 = -_371;
    bool _461 = _459 <= _460;
    int64_t _462;
    if (!_461)
    goto _jump2159;
    int64_t _463;
    // Computing bound for A
    int64_t _464;
    if (!_308)
    goto _jump2160;
    _464 = _266.d0;
    goto _jump2161;
    _jump2160:;
    _464 = _309.d0;
    _jump2161:;
    if (_464 > 0) 
    goto _jump2162;
    fail_assertion("non-positive loop bound");
    _jump2162:;
    // Computing bound for B
    if (_267 > 0) 
    goto _jump2163;
    fail_assertion("non-positive loop bound");
    _jump2163:;
    _463 = 0;
    int64_t _465 = 0; // B
    int64_t _466 = 0; // A
    _jump2164:; // Begin body of loop
    int64_t _467 = 164;
    _463 += _467;
    _465++;
    if (_465 < _267)
    goto _jump2164;
    _465 = 0;
    _466++;
    if (_466 < _464)
    goto _jump2164;
    // End body of loop
    _462 = _463;
    goto _jump2165;
    _jump2159:;
    _462 = _310.d0;
    _jump2165:;
    if (_457 >= 0)
    goto _jump2166;
    fail_assertion("negative array index");
    _jump2166:;
    if (_457 < _310.d0)
    goto _jump2167;
    fail_assertion("index too large");
    _jump2167:;
    if (_310.d0 >= 0)
    goto _jump2168;
    fail_assertion("negative array index");
    _jump2168:;
    if (_310.d0 < _310.d1)
    goto _jump2169;
    fail_assertion("index too large");
    _jump2169:;
    if (_462 >= 0)
    goto _jump2170;
    fail_assertion("negative array index");
    _jump2170:;
    if (_462 < _310.d2)
    goto _jump2171;
    fail_assertion("index too large");
    _jump2171:;
    int64_t _468 = 0;
    _468 *= _310.d0;
    _468 += _457;
    _468 *= _310.d1;
    _468 += _310.d0;
    _468 *= _310.d2;
    _468 += _462;
    int64_t _469 = _310.data[_468];
    if (_438 >= 0)
    goto _jump2172;
    fail_assertion("negative array index");
    _jump2172:;
    if (_438 < _413.d0)
    goto _jump2173;
    fail_assertion("index too large");
    _jump2173:;
    if (_267 >= 0)
    goto _jump2174;
    fail_assertion("negative array index");
    _jump2174:;
    if (_267 < _413.d1)
    goto _jump2175;
    fail_assertion("index too large");
    _jump2175:;
    if (_469 >= 0)
    goto _jump2176;
    fail_assertion("negative array index");
    _jump2176:;
    if (_469 < _413.d2)
    goto _jump2177;
    fail_assertion("index too large");
    _jump2177:;
    int64_t _470 = 0;
    _470 *= _413.d0;
    _470 += _438;
    _470 *= _413.d1;
    _470 += _267;
    _470 *= _413.d2;
    _470 += _469;
    int64_t _471 = _413.data[_470];
    _412.d1 = _471;
    if (_471 > 0) 
    goto _jump2178;
    fail_assertion("non-positive loop bound");
    _jump2178:;
    // Computing bound for C
    int64_t _472 = n();
    _412.d2 = _472;
    if (_472 > 0) 
    goto _jump2179;
    fail_assertion("non-positive loop bound");
    _jump2179:;
    // Computing total size of heap memory to allocate
    int64_t _473 = 1;
    _473 *= _310.d2;
    _473 *= _471;
    _473 *= _472;
    _473 *= sizeof(int64_t);
    _412.data = jpl_alloc(_473);
    int64_t _474 = 0; // C
    int64_t _475 = 0; // B
    int64_t _476 = 0; // A
    _jump2180:; // Begin body of loop
    int64_t _477 = 0;
    _477 *= _412.d0;
    _477 += _476;
    _477 *= _412.d1;
    _477 += _475;
    _477 *= _412.d2;
    _477 += _474;
    _412.data[_477] = _122.d1;
    _474++;
    if (_474 < _472)
    goto _jump2180;
    _474 = 0;
    _475++;
    if (_475 < _471)
    goto _jump2180;
    _475 = 0;
    _476++;
    if (_476 < _310.d2)
    goto _jump2180;
    // End body of loop
    _411 = _412;
    goto _jump2181;
    _jump2121:;
    bool _478 = true;
    _a2__a3_int64_t _479;
    if (!_478)
    goto _jump2182;
    _a2__a3_int64_t _480;
    // Computing bound for A
    _480.d0 = _267;
    if (_267 > 0) 
    goto _jump2183;
    fail_assertion("non-positive loop bound");
    _jump2183:;
    // Computing bound for B
    _480.d1 = _122.d0;
    if (_122.d0 > 0) 
    goto _jump2184;
    fail_assertion("non-positive loop bound");
    _jump2184:;
    // Computing total size of heap memory to allocate
    int64_t _481 = 1;
    _481 *= _267;
    _481 *= _122.d0;
    _481 *= sizeof(_a3_int64_t);
    _480.data = jpl_alloc(_481);
    int64_t _482 = 0; // B
    int64_t _483 = 0; // A
    _jump2185:; // Begin body of loop
    bool _484 = _310.d0 >= _483;
    _a3_int64_t _485;
    if (!_484)
    goto _jump2186;
    _485 = _310;
    goto _jump2187;
    _jump2186:;
    _485 = _310;
    _jump2187:;
    int64_t _486 = 0;
    _486 *= _480.d0;
    _486 += _483;
    _486 *= _480.d1;
    _486 += _482;
    _480.data[_486] = _485;
    _482++;
    if (_482 < _122.d0)
    goto _jump2185;
    _482 = 0;
    _483++;
    if (_483 < _267)
    goto _jump2185;
    // End body of loop
    _479 = _480;
    goto _jump2188;
    _jump2182:;
    _a2__a3_int64_t _487;
    if (!_308)
    goto _jump2189;
    _a2__a3_int64_t _488;
    // Computing bound for A
    _488.d0 = _122.d1;
    if (_122.d1 > 0) 
    goto _jump2190;
    fail_assertion("non-positive loop bound");
    _jump2190:;
    // Computing bound for B
    _488.d1 = _310.d2;
    if (_310.d2 > 0) 
    goto _jump2191;
    fail_assertion("non-positive loop bound");
    _jump2191:;
    // Computing total size of heap memory to allocate
    int64_t _489 = 1;
    _489 *= _122.d1;
    _489 *= _310.d2;
    _489 *= sizeof(_a3_int64_t);
    _488.data = jpl_alloc(_489);
    int64_t _490 = 0; // B
    int64_t _491 = 0; // A
    _jump2192:; // Begin body of loop
    int64_t _492 = 0;
    _492 *= _488.d0;
    _492 += _491;
    _492 *= _488.d1;
    _492 += _490;
    _488.data[_492] = _310;
    _490++;
    if (_490 < _310.d2)
    goto _jump2192;
    _490 = 0;
    _491++;
    if (_491 < _122.d1)
    goto _jump2192;
    // End body of loop
    _487 = _488;
    goto _jump2193;
    _jump2189:;
    _a2__a2__a3_int64_t _493;
    // Computing bound for A
    _493.d0 = _122.d0;
    if (_122.d0 > 0) 
    goto _jump2194;
    fail_assertion("non-positive loop bound");
    _jump2194:;
    // Computing bound for B
    _493.d1 = _309.d0;
    if (_309.d0 > 0) 
    goto _jump2195;
    fail_assertion("non-positive loop bound");
    _jump2195:;
    // Computing total size of heap memory to allocate
    int64_t _494 = 1;
    _494 *= _122.d0;
    _494 *= _309.d0;
    _494 *= sizeof(_a2__a3_int64_t);
    _493.data = jpl_alloc(_494);
    int64_t _495 = 0; // B
    int64_t _496 = 0; // A
    _jump2196:; // Begin body of loop
    _a2__a3_int64_t _497;
    // Computing bound for C
    _497.d0 = _310.d1;
    if (_310.d1 > 0) 
    goto _jump2197;
    fail_assertion("non-positive loop bound");
    _jump2197:;
    // Computing bound for D
    _497.d1 = _266.d1;
    if (_266.d1 > 0) 
    goto _jump2198;
    fail_assertion("non-positive loop bound");
    _jump2198:;
    // Computing total size of heap memory to allocate
    int64_t _498 = 1;
    _498 *= _310.d1;
    _498 *= _266.d1;
    _498 *= sizeof(_a3_int64_t);
    _497.data = jpl_alloc(_498);
    int64_t _499 = 0; // D
    int64_t _500 = 0; // C
    _jump2199:; // Begin body of loop
    int64_t _501 = 0;
    _501 *= _497.d0;
    _501 += _500;
    _501 *= _497.d1;
    _501 += _499;
    _497.data[_501] = _310;
    _499++;
    if (_499 < _266.d1)
    goto _jump2199;
    _499 = 0;
    _500++;
    if (_500 < _310.d1)
    goto _jump2199;
    // End body of loop
    int64_t _502 = 0;
    _502 *= _493.d0;
    _502 += _496;
    _502 *= _493.d1;
    _502 += _495;
    _493.data[_502] = _497;
    _495++;
    if (_495 < _309.d0)
    goto _jump2196;
    _495 = 0;
    _496++;
    if (_496 < _122.d0)
    goto _jump2196;
    // End body of loop
    bool _503 = true;
    bool _504 = _503 != _308;
    int64_t _505;
    if (!_504)
    goto _jump2200;
    _505 = _310.d2;
    goto _jump2201;
    _jump2200:;
    _505 = _309.d1;
    _jump2201:;
    int64_t _506;
    // Computing bound for A
    int64_t _507 = -_310.d1;
    if (_507 > 0) 
    goto _jump2202;
    fail_assertion("non-positive loop bound");
    _jump2202:;
    // Computing bound for B
    int64_t _508 = _122.d1 % _309.d1;
    if (_508 > 0) 
    goto _jump2203;
    fail_assertion("non-positive loop bound");
    _jump2203:;
    _506 = 0;
    int64_t _509 = 0; // B
    int64_t _510 = 0; // A
    _jump2204:; // Begin body of loop
    _506 += _309.d1;
    _509++;
    if (_509 < _508)
    goto _jump2204;
    _509 = 0;
    _510++;
    if (_510 < _507)
    goto _jump2204;
    // End body of loop
    if (_505 >= 0)
    goto _jump2205;
    fail_assertion("negative array index");
    _jump2205:;
    if (_505 < _493.d0)
    goto _jump2206;
    fail_assertion("index too large");
    _jump2206:;
    if (_506 >= 0)
    goto _jump2207;
    fail_assertion("negative array index");
    _jump2207:;
    if (_506 < _493.d1)
    goto _jump2208;
    fail_assertion("index too large");
    _jump2208:;
    int64_t _511 = 0;
    _511 *= _493.d0;
    _511 += _505;
    _511 *= _493.d1;
    _511 += _506;
    _a2__a3_int64_t _512 = _493.data[_511];
    _487 = _512;
    _jump2193:;
    _479 = _487;
    _jump2188:;
    int64_t _513 = 568;
    if (_513 >= 0)
    goto _jump2209;
    fail_assertion("negative array index");
    _jump2209:;
    if (_513 < _479.d0)
    goto _jump2210;
    fail_assertion("index too large");
    _jump2210:;
    if (_309.d0 >= 0)
    goto _jump2211;
    fail_assertion("negative array index");
    _jump2211:;
    if (_309.d0 < _479.d1)
    goto _jump2212;
    fail_assertion("index too large");
    _jump2212:;
    int64_t _514 = 0;
    _514 *= _479.d0;
    _514 += _513;
    _514 *= _479.d1;
    _514 += _309.d0;
    _a3_int64_t _515 = _479.data[_514];
    _411 = _515;
    _jump2181:;
    _a1_double _517;
    // Computing bound for E
    int64_t _518 = _310.d0 % _122.d1;
    _517.d0 = _518;
    if (_518 > 0) 
    goto _jump2213;
    fail_assertion("non-positive loop bound");
    _jump2213:;
    // Computing total size of heap memory to allocate
    int64_t _519 = 1;
    _519 *= _518;
    _519 *= sizeof(double);
    _517.data = jpl_alloc(_519);
    int64_t _520 = 0; // E
    _jump2214:; // Begin body of loop
    int64_t _521 = 0;
    _521 *= _517.d0;
    _521 += _520;
    _517.data[_521] = _371;
    _520++;
    if (_520 < _518)
    goto _jump2214;
    // End body of loop
    if (_310.d0 >= 0)
    goto _jump2215;
    fail_assertion("negative array index");
    _jump2215:;
    if (_310.d0 < _517.d0)
    goto _jump2216;
    fail_assertion("index too large");
    _jump2216:;
    int64_t _522 = 0;
    _522 *= _517.d0;
    _522 += _310.d0;
    double _523 = _517.data[_522];
    bool _524 = !_308;
    double _525;
    if (!_524)
    goto _jump2217;
    double _526 = g(_308);
    _525 = _526;
    goto _jump2218;
    _jump2217:;
    double _527 = 7.0;
    _525 = _527;
    _jump2218:;
    double _528 = 61.0;
    double _529 = -_528;
    rgba _530 = { _523, _371, _525, _529 };
    double _531 = _530.a;
    _a2_bool _532;
    // Computing bound for E
    _532.d0 = _310.d2;
    if (_310.d2 > 0) 
    goto _jump2219;
    fail_assertion("non-positive loop bound");
    _jump2219:;
    // Computing bound for F
    int64_t _533;
    // Computing bound for E
    int64_t _534 = 472;
    if (_534 > 0) 
    goto _jump2220;
    fail_assertion("non-positive loop bound");
    _jump2220:;
    // Computing bound for F
    if (_266.d1 > 0) 
    goto _jump2221;
    fail_assertion("non-positive loop bound");
    _jump2221:;
    // Computing bound for G
    if (_309.d0 > 0) 
    goto _jump2222;
    fail_assertion("non-positive loop bound");
    _jump2222:;
    _533 = 0;
    int64_t _535 = 0; // G
    int64_t _536 = 0; // F
    int64_t _537 = 0; // E
    _jump2223:; // Begin body of loop
    _533 += _411.d0;
    _535++;
    if (_535 < _309.d0)
    goto _jump2223;
    _535 = 0;
    _536++;
    if (_536 < _266.d1)
    goto _jump2223;
    _536 = 0;
    _537++;
    if (_537 < _534)
    goto _jump2223;
    // End body of loop
    _532.d1 = _533;
    if (_533 > 0) 
    goto _jump2224;
    fail_assertion("non-positive loop bound");
    _jump2224:;
    // Computing total size of heap memory to allocate
    int64_t _538 = 1;
    _538 *= _310.d2;
    _538 *= _533;
    _538 *= sizeof(bool);
    _532.data = jpl_alloc(_538);
    int64_t _539 = 0; // F
    int64_t _540 = 0; // E
    _jump2225:; // Begin body of loop
    int64_t _541 = 0;
    _541 *= _532.d0;
    _541 += _540;
    _541 *= _532.d1;
    _541 += _539;
    _532.data[_541] = _308;
    _539++;
    if (_539 < _533)
    goto _jump2225;
    _539 = 0;
    _540++;
    if (_540 < _310.d2)
    goto _jump2225;
    // End body of loop
    if (_267 >= 0)
    goto _jump2226;
    fail_assertion("negative array index");
    _jump2226:;
    if (_267 < _122.d0)
    goto _jump2227;
    fail_assertion("index too large");
    _jump2227:;
    if (_122.d0 >= 0)
    goto _jump2228;
    fail_assertion("negative array index");
    _jump2228:;
    if (_122.d0 < _122.d1)
    goto _jump2229;
    fail_assertion("index too large");
    _jump2229:;
    int64_t _542 = 0;
    _542 *= _122.d0;
    _542 += _267;
    _542 *= _122.d1;
    _542 += _122.d0;
    int64_t _543 = _122.data[_542];
    if (_310.d1 >= 0)
    goto _jump2230;
    fail_assertion("negative array index");
    _jump2230:;
    if (_310.d1 < _532.d0)
    goto _jump2231;
    fail_assertion("index too large");
    _jump2231:;
    if (_543 >= 0)
    goto _jump2232;
    fail_assertion("negative array index");
    _jump2232:;
    if (_543 < _532.d1)
    goto _jump2233;
    fail_assertion("index too large");
    _jump2233:;
    int64_t _544 = 0;
    _544 *= _532.d0;
    _544 += _310.d1;
    _544 *= _532.d1;
    _544 += _543;
    bool _545 = _532.data[_544];
    a _546;
    if (!_545)
    goto _jump2234;
    a _547 = h();
    _546 = _547;
    goto _jump2235;
    _jump2234:;
    a _548 = h();
    _546 = _548;
    _jump2235:;
    double _549 = _546.b;
    bool _550 = _531 != _549;
    bool _516 = _550;
    if (0 == _550)
    goto _jump2236;
    bool _551 = _310.d2 < _411.d0;
    rgba _552;
    if (!_551)
    goto _jump2237;
    bool _553 = true;
    double _554 = g(_553);
    double _555;
    // Computing bound for E
    if (_122.d0 > 0) 
    goto _jump2238;
    fail_assertion("non-positive loop bound");
    _jump2238:;
    // Computing bound for F
    if (_411.d1 >= 0)
    goto _jump2239;
    fail_assertion("negative array index");
    _jump2239:;
    if (_411.d1 < _122.d0)
    goto _jump2240;
    fail_assertion("index too large");
    _jump2240:;
    if (_266.d0 >= 0)
    goto _jump2241;
    fail_assertion("negative array index");
    _jump2241:;
    if (_266.d0 < _122.d1)
    goto _jump2242;
    fail_assertion("index too large");
    _jump2242:;
    int64_t _556 = 0;
    _556 *= _122.d0;
    _556 += _411.d1;
    _556 *= _122.d1;
    _556 += _266.d0;
    int64_t _557 = _122.data[_556];
    if (_557 > 0) 
    goto _jump2243;
    fail_assertion("non-positive loop bound");
    _jump2243:;
    // Computing bound for G
    if (_266.d1 > 0) 
    goto _jump2244;
    fail_assertion("non-positive loop bound");
    _jump2244:;
    _555 = 0;
    int64_t _558 = 0; // G
    int64_t _559 = 0; // F
    int64_t _560 = 0; // E
    _jump2245:; // Begin body of loop
    double _561 = 58.0;
    _555 += _561;
    _558++;
    if (_558 < _266.d1)
    goto _jump2245;
    _558 = 0;
    _559++;
    if (_559 < _557)
    goto _jump2245;
    _559 = 0;
    _560++;
    if (_560 < _122.d0)
    goto _jump2245;
    // End body of loop
    rgba _562 = { _554, _555, _371, _371 };
    _552 = _562;
    goto _jump2246;
    _jump2237:;
    double _563 = 81.0;
    double _564 = -_563;
    double _565;
    // Computing bound for E
    if (_411.d0 > 0) 
    goto _jump2247;
    fail_assertion("non-positive loop bound");
    _jump2247:;
    // Computing bound for F
    if (_266.d1 > 0) 
    goto _jump2248;
    fail_assertion("non-positive loop bound");
    _jump2248:;
    // Computing bound for G
    int64_t _566 = n();
    int64_t _567 = _566 * _267;
    if (_567 > 0) 
    goto _jump2249;
    fail_assertion("non-positive loop bound");
    _jump2249:;
    _565 = 0;
    int64_t _568 = 0; // G
    int64_t _569 = 0; // F
    int64_t _570 = 0; // E
    _jump2250:; // Begin body of loop
    _565 += _371;
    _568++;
    if (_568 < _567)
    goto _jump2250;
    _568 = 0;
    _569++;
    if (_569 < _266.d1)
    goto _jump2250;
    _569 = 0;
    _570++;
    if (_570 < _411.d0)
    goto _jump2250;
    // End body of loop
    double _571;
    // Computing bound for E
    if (_266.d1 > 0) 
    goto _jump2251;
    fail_assertion("non-positive loop bound");
    _jump2251:;
    // Computing bound for F
    if (_122.d0 > 0) 
    goto _jump2252;
    fail_assertion("non-positive loop bound");
    _jump2252:;
    _571 = 0;
    int64_t _572 = 0; // F
    int64_t _573 = 0; // E
    _jump2253:; // Begin body of loop
    double _574 = 80.0;
    _571 += _574;
    _572++;
    if (_572 < _122.d0)
    goto _jump2253;
    _572 = 0;
    _573++;
    if (_573 < _266.d1)
    goto _jump2253;
    // End body of loop
    double _575 = -_571;
    double _576 = _371 + _371;
    rgba _577 = { _564, _565, _575, _576 };
    _552 = _577;
    _jump2246:;
    double _578 = _552.r;
    if (_411.d2 >= 0)
    goto _jump2254;
    fail_assertion("negative array index");
    _jump2254:;
    if (_411.d2 < _266.d0)
    goto _jump2255;
    fail_assertion("index too large");
    _jump2255:;
    if (_266.d0 >= 0)
    goto _jump2256;
    fail_assertion("negative array index");
    _jump2256:;
    if (_266.d0 < _266.d1)
    goto _jump2257;
    fail_assertion("index too large");
    _jump2257:;
    int64_t _579 = 0;
    _579 *= _266.d0;
    _579 += _411.d2;
    _579 *= _266.d1;
    _579 += _266.d0;
    rgba _580 = _266.data[_579];
    double _581 = _580.g;
    bool _582 = _578 == _581;
    _516 = _582;
    _jump2236:;
    bool _583;
    if (!_516)
    goto _jump2258;
    _583 = _308;
    goto _jump2259;
    _jump2258:;
    bool _584;
    if (!_516)
    goto _jump2260;
    _584 = _516;
    goto _jump2261;
    _jump2260:;
    _584 = _516;
    _jump2261:;
    _583 = _584;
    _jump2259:;
    double _585 = g(_583);
    int64_t _586 = 523;
    if (_122.d0 >= 0)
    goto _jump2262;
    fail_assertion("negative array index");
    _jump2262:;
    if (_122.d0 < _309.d0)
    goto _jump2263;
    fail_assertion("index too large");
    _jump2263:;
    if (_586 >= 0)
    goto _jump2264;
    fail_assertion("negative array index");
    _jump2264:;
    if (_586 < _309.d1)
    goto _jump2265;
    fail_assertion("index too large");
    _jump2265:;
    int64_t _587 = 0;
    _587 *= _309.d0;
    _587 += _122.d0;
    _587 *= _309.d1;
    _587 += _586;
    rgba _588 = _309.data[_587];
    double _589 = _588.g;
    _a1_double _590;
    _590.d0 = 2;
    _590.data = jpl_alloc(sizeof(double) * 2);
    _590.data[0] = _371;
    _590.data[1] = _371;
    int64_t _591 = -_122.d0;
    if (_591 >= 0)
    goto _jump2266;
    fail_assertion("negative array index");
    _jump2266:;
    if (_591 < _590.d0)
    goto _jump2267;
    fail_assertion("index too large");
    _jump2267:;
    int64_t _592 = 0;
    _592 *= _590.d0;
    _592 += _591;
    double _593 = _590.data[_592];
    double _594;
    // Computing bound for F
    int64_t _595 = 74;
    int64_t _596 = -_595;
    if (_596 > 0) 
    goto _jump2268;
    fail_assertion("non-positive loop bound");
    _jump2268:;
    _594 = 0;
    int64_t _597 = 0; // F
    _jump2269:; // Begin body of loop
    double _598 = 10.0;
    double _599 = -_598;
    _594 += _599;
    _597++;
    if (_597 < _596)
    goto _jump2269;
    // End body of loop
    double _600 = _593 * _594;
    double _601 = 65.0;
    double _602 = -_601;
    double _603 = g(_516);
    double _604 = 27.0;
    double _605 = -_604;
    a _606 = h();
    double _607 = _606.b;
    rgba _608 = { _602, _603, _605, _607 };
    double _609 = _608.a;
    rgba _610 = { _585, _589, _600, _609 };
    _a2_double _611;
    if (!_516)
    goto _jump2270;
    _a2_double _612;
    // Computing bound for F
    int64_t _613 = -_266.d1;
    _612.d0 = _613;
    if (_613 > 0) 
    goto _jump2271;
    fail_assertion("non-positive loop bound");
    _jump2271:;
    // Computing bound for G
    _612.d1 = _309.d1;
    if (_309.d1 > 0) 
    goto _jump2272;
    fail_assertion("non-positive loop bound");
    _jump2272:;
    // Computing total size of heap memory to allocate
    int64_t _614 = 1;
    _614 *= _613;
    _614 *= _309.d1;
    _614 *= sizeof(double);
    _612.data = jpl_alloc(_614);
    int64_t _615 = 0; // G
    int64_t _616 = 0; // F
    _jump2273:; // Begin body of loop
    a _617 = h();
    double _618 = _617.b;
    int64_t _619 = 0;
    _619 *= _612.d0;
    _619 += _616;
    _619 *= _612.d1;
    _619 += _615;
    _612.data[_619] = _618;
    _615++;
    if (_615 < _309.d1)
    goto _jump2273;
    _615 = 0;
    _616++;
    if (_616 < _613)
    goto _jump2273;
    // End body of loop
    _611 = _612;
    goto _jump2274;
    _jump2270:;
    _a3_rgba _620;
    // Computing bound for F
    _620.d0 = _411.d2;
    if (_411.d2 > 0) 
    goto _jump2275;
    fail_assertion("non-positive loop bound");
    _jump2275:;
    // Computing bound for G
    _620.d1 = _266.d0;
    if (_266.d0 > 0) 
    goto _jump2276;
    fail_assertion("non-positive loop bound");
    _jump2276:;
    // Computing bound for H
    _620.d2 = _411.d1;
    if (_411.d1 > 0) 
    goto _jump2277;
    fail_assertion("non-positive loop bound");
    _jump2277:;
    // Computing total size of heap memory to allocate
    int64_t _621 = 1;
    _621 *= _411.d2;
    _621 *= _266.d0;
    _621 *= _411.d1;
    _621 *= sizeof(rgba);
    _620.data = jpl_alloc(_621);
    int64_t _622 = 0; // H
    int64_t _623 = 0; // G
    int64_t _624 = 0; // F
    _jump2278:; // Begin body of loop
    if (_624 >= 0)
    goto _jump2279;
    fail_assertion("negative array index");
    _jump2279:;
    if (_624 < _266.d0)
    goto _jump2280;
    fail_assertion("index too large");
    _jump2280:;
    if (_267 >= 0)
    goto _jump2281;
    fail_assertion("negative array index");
    _jump2281:;
    if (_267 < _266.d1)
    goto _jump2282;
    fail_assertion("index too large");
    _jump2282:;
    int64_t _625 = 0;
    _625 *= _266.d0;
    _625 += _624;
    _625 *= _266.d1;
    _625 += _267;
    rgba _626 = _266.data[_625];
    int64_t _627 = 0;
    _627 *= _620.d0;
    _627 += _624;
    _627 *= _620.d1;
    _627 += _623;
    _627 *= _620.d2;
    _627 += _622;
    _620.data[_627] = _626;
    _622++;
    if (_622 < _411.d1)
    goto _jump2278;
    _622 = 0;
    _623++;
    if (_623 < _266.d0)
    goto _jump2278;
    _623 = 0;
    _624++;
    if (_624 < _411.d2)
    goto _jump2278;
    // End body of loop
    _a2_double _628 = f(_620);
    _611 = _628;
    _jump2274:;
    a _629 = m(_610, _611);
    void_t _630 = _629.a;
    bool _631 = true;
    a _632;
    if (!_631)
    goto _jump2283;
    a _633 = h();
    _632 = _633;
    goto _jump2284;
    _jump2283:;
    a _634 = h();
    _632 = _634;
    _jump2284:;
    double _635 = _632.b;
    double _636;
    // Computing bound for F
    int64_t _637;
    // Computing bound for F
    if (_310.d2 > 0) 
    goto _jump2285;
    fail_assertion("non-positive loop bound");
    _jump2285:;
    _637 = 0;
    int64_t _638 = 0; // F
    _jump2286:; // Begin body of loop
    int64_t _639 = _411.d2 / _310.d2;
    _637 += _639;
    _638++;
    if (_638 < _310.d2)
    goto _jump2286;
    // End body of loop
    if (_637 > 0) 
    goto _jump2287;
    fail_assertion("non-positive loop bound");
    _jump2287:;
    // Computing bound for G
    if (_310.d0 > 0) 
    goto _jump2288;
    fail_assertion("non-positive loop bound");
    _jump2288:;
    _636 = 0;
    int64_t _640 = 0; // G
    int64_t _641 = 0; // F
    _jump2289:; // Begin body of loop
    a _642 = h();
    double _643 = _642.b;
    bool _644 = false;
    double _645;
    if (!_644)
    goto _jump2290;
    double _646 = -_371;
    _645 = _646;
    goto _jump2291;
    _jump2290:;
    _645 = _371;
    _jump2291:;
    double _647 = -_645;
    double _648 = fmod(_643, _647);
    _636 += _648;
    _640++;
    if (_640 < _310.d0)
    goto _jump2289;
    _640 = 0;
    _641++;
    if (_641 < _637)
    goto _jump2289;
    // End body of loop
    double _649 = _635 * _636;
    a _650 = { _630, _649 };
    show("(IntType)", &_122.d1);
    write_image(_266, "H.png");
}

